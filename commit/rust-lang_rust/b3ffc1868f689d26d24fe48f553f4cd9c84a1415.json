{"sha": "b3ffc1868f689d26d24fe48f553f4cd9c84a1415", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZmZjMTg2OGY2ODlkMjZkMjRmZTQ4ZjU1M2Y0Y2Q5Yzg0YTE0MTU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-26T11:18:34Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-26T11:18:34Z"}, "message": "Merge pull request #689 from mcarton/entries\n\nImprove the `MAP_ENTRY` lint", "tree": {"sha": "eb24835653cb35b28571c1adcb20506e903eda6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb24835653cb35b28571c1adcb20506e903eda6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3ffc1868f689d26d24fe48f553f4cd9c84a1415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ffc1868f689d26d24fe48f553f4cd9c84a1415", "html_url": "https://github.com/rust-lang/rust/commit/b3ffc1868f689d26d24fe48f553f4cd9c84a1415", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3ffc1868f689d26d24fe48f553f4cd9c84a1415/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f13b841282a4832e8642b82dd3b652046de55c97", "url": "https://api.github.com/repos/rust-lang/rust/commits/f13b841282a4832e8642b82dd3b652046de55c97", "html_url": "https://github.com/rust-lang/rust/commit/f13b841282a4832e8642b82dd3b652046de55c97"}, {"sha": "aa1df8e9fff6db1aec49e1d01f5495fce1c653ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1df8e9fff6db1aec49e1d01f5495fce1c653ac", "html_url": "https://github.com/rust-lang/rust/commit/aa1df8e9fff6db1aec49e1d01f5495fce1c653ac"}], "stats": {"total": 164, "additions": 104, "deletions": 60}, "files": [{"sha": "6242b44dd6e343ade5e45390febb16f01008e646", "filename": "src/entry.rs", "status": "modified", "additions": 88, "deletions": 52, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b3ffc1868f689d26d24fe48f553f4cd9c84a1415/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ffc1868f689d26d24fe48f553f4cd9c84a1415/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=b3ffc1868f689d26d24fe48f553f4cd9c84a1415", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n+use rustc_front::intravisit::{Visitor, walk_expr, walk_block};\n use syntax::codemap::Span;\n use utils::SpanlessEq;\n use utils::{BTREEMAP_PATH, HASHMAP_PATH};\n@@ -41,73 +42,108 @@ impl LintPass for HashMapLint {\n \n impl LateLintPass for HashMapLint {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if_let_chain! {\n-            [\n-                let ExprIf(ref check, ref then, _) = expr.node,\n-                let ExprUnary(UnOp::UnNot, ref check) = check.node,\n-                let ExprMethodCall(ref name, _, ref params) = check.node,\n-                params.len() >= 2,\n-                name.node.as_str() == \"contains_key\"\n-            ], {\n-                let key = match params[1].node {\n-                    ExprAddrOf(_, ref key) => key,\n-                    _ => return\n-                };\n-\n-                let map = &params[0];\n-                let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(map));\n-\n-                let kind = if match_type(cx, obj_ty, &BTREEMAP_PATH) {\n-                    \"BTreeMap\"\n-                }\n-                else if match_type(cx, obj_ty, &HASHMAP_PATH) {\n-                    \"HashMap\"\n-                }\n-                else {\n-                    return\n-                };\n+        if let ExprIf(ref check, ref then_block, ref else_block) = expr.node {\n+            if let ExprUnary(UnOp::UnNot, ref check) = check.node {\n+                if let Some((ty, map, key)) = check_cond(cx, check) {\n+                    // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n+                    // we can give a better error message\n+                    let sole_expr = else_block.is_none() &&\n+                        if then_block.expr.is_some() { 1 } else { 0 } + then_block.stmts.len() == 1;\n \n-                let sole_expr = if then.expr.is_some() { 1 } else { 0 } + then.stmts.len() == 1;\n+                    let mut visitor = InsertVisitor {\n+                        cx: cx,\n+                        span: expr.span,\n+                        ty: ty,\n+                        map: map,\n+                        key: key,\n+                        sole_expr: sole_expr,\n+                    };\n \n-                if let Some(ref then) = then.expr {\n-                    check_for_insert(cx, expr.span, map, key, then, sole_expr, kind);\n+                    walk_block(&mut visitor, then_block);\n                 }\n+            } else if let Some(ref else_block) = *else_block {\n+                if let Some((ty, map, key)) = check_cond(cx, check) {\n+                    let mut visitor = InsertVisitor {\n+                        cx: cx,\n+                        span: expr.span,\n+                        ty: ty,\n+                        map: map,\n+                        key: key,\n+                        sole_expr: false,\n+                    };\n \n-                for stmt in &then.stmts {\n-                    if let StmtSemi(ref stmt, _) = stmt.node {\n-                        check_for_insert(cx, expr.span, map, key, stmt, sole_expr, kind);\n-                    }\n+                    walk_expr(&mut visitor, else_block);\n                 }\n             }\n         }\n     }\n }\n \n-fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr: &Expr, sole_expr: bool, kind: &str) {\n-    if_let_chain! {\n-        [\n+fn check_cond<'a, 'tcx, 'b>(cx: &'a LateContext<'a, 'tcx>, check: &'b Expr) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n+    if_let_chain! {[\n+        let ExprMethodCall(ref name, _, ref params) = check.node,\n+        params.len() >= 2,\n+        name.node.as_str() == \"contains_key\",\n+        let ExprAddrOf(_, ref key) = params[1].node\n+    ], {\n+        let map = &params[0];\n+        let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(map));\n+\n+        return if match_type(cx, obj_ty, &BTREEMAP_PATH) {\n+            Some((\"BTreeMap\", map, key))\n+        }\n+        else if match_type(cx, obj_ty, &HASHMAP_PATH) {\n+            Some((\"HashMap\", map, key))\n+        }\n+        else {\n+            None\n+        };\n+    }}\n+\n+    None\n+}\n+\n+struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    span: Span,\n+    ty: &'static str,\n+    map: &'b Expr,\n+    key: &'b Expr,\n+    sole_expr: bool,\n+}\n+\n+impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if_let_chain! {[\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n             name.node.as_str() == \"insert\",\n-            get_item_name(cx, map) == get_item_name(cx, &*params[0]),\n-            SpanlessEq::new(cx).eq_expr(key, &params[1])\n+            get_item_name(self.cx, self.map) == get_item_name(self.cx, &*params[0]),\n+            SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {\n-            let help = if sole_expr {\n-                format!(\"{}.entry({}).or_insert({})\",\n-                        snippet(cx, map.span, \"map\"),\n-                        snippet(cx, params[1].span, \"..\"),\n-                        snippet(cx, params[2].span, \"..\"))\n-            }\n-            else {\n-                format!(\"{}.entry({})\",\n-                        snippet(cx, map.span, \"map\"),\n-                        snippet(cx, params[1].span, \"..\"))\n-            };\n-\n-            span_lint_and_then(cx, MAP_ENTRY, span,\n-                               &format!(\"usage of `contains_key` followed by `insert` on `{}`\", kind), |db| {\n-                db.span_suggestion(span, \"Consider using\", help);\n+\n+            span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n+                               &format!(\"usage of `contains_key` followed by `insert` on `{}`\", self.ty), |db| {\n+                if self.sole_expr {\n+                    let help = format!(\"{}.entry({}).or_insert({})\",\n+                                       snippet(self.cx, self.map.span, \"map\"),\n+                                       snippet(self.cx, params[1].span, \"..\"),\n+                                       snippet(self.cx, params[2].span, \"..\"));\n+\n+                    db.span_suggestion(self.span, \"Consider using\", help);\n+                }\n+                else {\n+                    let help = format!(\"Consider using `{}.entry({})`\",\n+                                       snippet(self.cx, self.map.span, \"map\"),\n+                                       snippet(self.cx, params[1].span, \"..\"));\n+\n+                    db.span_note(self.span, &help);\n+                }\n             });\n+        }}\n+\n+        if !self.sole_expr {\n+            walk_expr(self, expr);\n         }\n     }\n }"}, {"sha": "7dc4054ec5bf94404ad9276a990183268576bbd2", "filename": "tests/compile-fail/entry.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3ffc1868f689d26d24fe48f553f4cd9c84a1415/tests%2Fcompile-fail%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ffc1868f689d26d24fe48f553f4cd9c84a1415/tests%2Fcompile-fail%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fentry.rs?ref=b3ffc1868f689d26d24fe48f553f4cd9c84a1415", "patch": "@@ -19,29 +19,37 @@ fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n fn insert_if_absent1<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { foo(); m.insert(k, v); }\n     //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| HELP Consider\n-    //~| SUGGESTION m.entry(k)\n+    //~| NOTE Consider using `m.entry(k)`\n }\n \n fn insert_if_absent2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { m.insert(k, v) } else { None };\n     //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| HELP Consider\n-    //~| SUGGESTION m.entry(k).or_insert(v)\n+    //~| NOTE Consider using `m.entry(k)`\n+}\n+\n+fn insert_if_present2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if m.contains_key(&k) { None } else { m.insert(k, v) };\n+    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n+    //~| NOTE Consider using `m.entry(k)`\n }\n \n fn insert_if_absent3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { foo(); m.insert(k, v) } else { None };\n     //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| HELP Consider\n-    //~| SUGGESTION m.entry(k)\n+    //~| NOTE Consider using `m.entry(k)`\n+}\n+\n+fn insert_if_present3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if m.contains_key(&k) { None } else { foo(); m.insert(k, v) };\n+    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n+    //~| NOTE Consider using `m.entry(k)`\n }\n \n fn insert_in_btreemap<K: Ord, V>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { foo(); m.insert(k, v) } else { None };\n     //~^ ERROR usage of `contains_key` followed by `insert` on `BTreeMap`\n-    //~| HELP Consider\n-    //~| SUGGESTION m.entry(k)\n+    //~| NOTE Consider using `m.entry(k)`\n }\n \n fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {"}]}