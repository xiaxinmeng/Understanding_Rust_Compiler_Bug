{"sha": "d444d0c357e85c90e73585520e2da74304c7265a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NDRkMGMzNTdlODVjOTBlNzM1ODU1MjBlMmRhNzQzMDRjNzI2NWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-09T21:39:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-17T16:06:59Z"}, "message": "collections: Split the `collections` feature\n\nThis commit also deprecates the `as_string` and `as_slice` free functions in the\n`string` and `vec` modules.", "tree": {"sha": "b64c15147beeccf6cd62eb019d76b16dc5260e22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b64c15147beeccf6cd62eb019d76b16dc5260e22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d444d0c357e85c90e73585520e2da74304c7265a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d444d0c357e85c90e73585520e2da74304c7265a", "html_url": "https://github.com/rust-lang/rust/commit/d444d0c357e85c90e73585520e2da74304c7265a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d444d0c357e85c90e73585520e2da74304c7265a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c44f5399e4dd2f9d55e107d365d6fe98f6491dc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c44f5399e4dd2f9d55e107d365d6fe98f6491dc9", "html_url": "https://github.com/rust-lang/rust/commit/c44f5399e4dd2f9d55e107d365d6fe98f6491dc9"}], "stats": {"total": 352, "additions": 197, "deletions": 155}, "files": [{"sha": "f6204173ed7a57c6ff59f9fdfa3a3d97636b55a8", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -10,10 +10,11 @@\n \n //! A priority queue implemented with a binary heap.\n //!\n-//! Insertion and popping the largest element have `O(log n)` time complexity. Checking the largest\n-//! element is `O(1)`. Converting a vector to a binary heap can be done in-place, and has `O(n)`\n-//! complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to\n-//! be used for an `O(n log n)` in-place heapsort.\n+//! Insertion and popping the largest element have `O(log n)` time complexity.\n+//! Checking the largest element is `O(1)`. Converting a vector to a binary heap\n+//! can be done in-place, and has `O(n)` complexity. A binary heap can also be\n+//! converted to a sorted vector in-place, allowing it to be used for an `O(n\n+//! log n)` in-place heapsort.\n //!\n //! # Examples\n //!\n@@ -539,8 +540,9 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// The elements are removed in arbitrary order.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+    #[unstable(feature = \"drain\",\n+               reason = \"matches collection reform specification, \\\n+                         waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain(..) }\n     }\n@@ -678,7 +680,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n-#[unstable(feature = \"collections\", reason = \"recent addition\")]\n+#[unstable(feature = \"drain\", reason = \"recent addition\")]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }"}, {"sha": "5709ed7a2949917255a9bf4d9f5aaff652c46c8f", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -156,8 +156,7 @@ const FALSE: &'static bool = &false;\n /// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[unstable(feature = \"collections\",\n-           reason = \"RFC 509\")]\n+#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n pub struct BitVec {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n@@ -181,14 +180,16 @@ impl Index<usize> for BitVec {\n \n /// Computes how many blocks are needed to store that many bits\n fn blocks_for_bits(bits: usize) -> usize {\n-    // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make sure we\n-    // reserve enough. But if we want exactly a multiple of 32, this will actually allocate\n-    // one too many. So we need to check if that's the case. We can do that by computing if\n-    // bitwise AND by `32 - 1` is 0. But LLVM should be able to optimize the semantically\n-    // superior modulo operator on a power of two to this.\n+    // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make\n+    // sure we reserve enough. But if we want exactly a multiple of 32, this\n+    // will actually allocate one too many. So we need to check if that's the\n+    // case. We can do that by computing if bitwise AND by `32 - 1` is 0. But\n+    // LLVM should be able to optimize the semantically superior modulo operator\n+    // on a power of two to this.\n     //\n     // Note that we can technically avoid this branch with the expression\n-    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX this will overflow.\n+    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX\n+    // this will overflow.\n     if bits % u32::BITS == 0 {\n         bits / u32::BITS\n     } else {\n@@ -202,6 +203,7 @@ fn mask_for_bits(bits: usize) -> u32 {\n     !0 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n \n+#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n impl BitVec {\n     /// Applies the given operation to the blocks of self and other, and sets\n     /// self to be the result. This relies on the caller not to corrupt the\n@@ -407,8 +409,6 @@ impl BitVec {\n     /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: usize, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n@@ -608,7 +608,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections, bit_vec_append_split_off)]\n+    /// # #![feature(bitvec, append)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut a = BitVec::from_bytes(&[0b10000000]);\n@@ -621,7 +621,7 @@ impl BitVec {\n     /// assert!(a.eq_vec(&[true, false, false, false, false, false, false, false,\n     ///                    false, true, true, false, false, false, false, true]));\n     /// ```\n-    #[unstable(feature = \"bit_vec_append_split_off\",\n+    #[unstable(feature = \"append\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn append(&mut self, other: &mut Self) {\n         let b = self.len() % u32::BITS;\n@@ -651,7 +651,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections, bit_vec_append_split_off)]\n+    /// # #![feature(bitvec, split_off)]\n     /// use std::collections::BitVec;\n     /// let mut a = BitVec::new();\n     /// a.push(true);\n@@ -666,7 +666,7 @@ impl BitVec {\n     /// assert!(a.eq_vec(&[true, false]));\n     /// assert!(b.eq_vec(&[false, true]));\n     /// ```\n-    #[unstable(feature = \"bit_vec_append_split_off\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         assert!(at <= self.len(), \"`at` out of bounds\");\n@@ -1254,8 +1254,7 @@ impl<'a> IntoIterator for &'a BitVec {\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n-#[unstable(feature = \"collections\",\n-           reason = \"RFC 509\")]\n+#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n pub struct BitSet {\n     bit_vec: BitVec,\n }\n@@ -1322,6 +1321,7 @@ impl cmp::PartialEq for BitSet {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for BitSet {}\n \n+#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n impl BitSet {\n     /// Creates a new empty `BitSet`.\n     ///\n@@ -1808,7 +1808,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections, bit_set_append_split_off)]\n+    /// # #![feature(collections, append)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let mut a = BitSet::new();\n@@ -1826,7 +1826,7 @@ impl BitSet {\n     /// assert_eq!(b.len(), 0);\n     /// assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01110010])));\n     /// ```\n-    #[unstable(feature = \"bit_set_append_split_off\",\n+    #[unstable(feature = \"append\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn append(&mut self, other: &mut Self) {\n         self.union_with(other);\n@@ -1839,7 +1839,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections, bit_set_append_split_off)]\n+    /// # #![feature(bitset, split_off)]\n     /// use std::collections::{BitSet, BitVec};\n     /// let mut a = BitSet::new();\n     /// a.insert(2);\n@@ -1854,7 +1854,7 @@ impl BitSet {\n     /// assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100000])));\n     /// assert_eq!(b, BitSet::from_bit_vec(BitVec::from_bytes(&[0b00010010])));\n     /// ```\n-    #[unstable(feature = \"bit_set_append_split_off\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let mut other = BitSet::new();"}, {"sha": "127f470c9aaaeb9b009f475e97d2d2911af49f41", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -1520,7 +1520,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// }\n     /// assert_eq!(Some((&5, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&K>, max: Bound<&K>) -> Range<'a, K, V> {\n         range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n@@ -1548,7 +1548,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     println!(\"{} => {}\", name, balance);\n     /// }\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range_mut<'a>(&'a mut self, min: Bound<&K>, max: Bound<&K>) -> RangeMut<'a, K, V> {\n         range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,"}, {"sha": "5914e2f296a33cc284eaa26ae19b6dbc783e7f4a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -102,7 +102,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// Makes a new BTreeSet with the given B.\n     ///\n     /// B cannot be less than 2.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"btree_b\",\n                reason = \"probably want this to be on the type, eventually\")]\n     pub fn with_b(b: usize) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n@@ -154,7 +154,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// }\n     /// assert_eq!(Some(&5), set.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&T>, max: Bound<&T>) -> Range<'a, T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }"}, {"sha": "e90e6c065a2c282f19a80b0220a5e0552c4d07fd", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -13,21 +13,26 @@\n //! This module defines a container which uses an efficient bit mask\n //! representation to hold C-like enum variants.\n \n+#![unstable(feature = \"enumset\",\n+            reason = \"matches collection reform specification, \\\n+                      waiting for dust to settle\")]\n+\n use core::prelude::*;\n use core::marker;\n use core::fmt;\n use core::iter::{FromIterator};\n use core::ops::{Sub, BitOr, BitAnd, BitXor};\n \n-// FIXME(contentions): implement union family of methods? (general design may be wrong here)\n+// FIXME(contentions): implement union family of methods? (general design may be\n+// wrong here)\n \n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]\n /// A specialized set implementation to use enum types.\n ///\n-/// It is a logic error for an item to be modified in such a way that the transformation of the\n-/// item to or from a `usize`, as determined by the `CLike` trait, changes while the item is in the\n-/// set. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe\n-/// code.\n+/// It is a logic error for an item to be modified in such a way that the\n+/// transformation of the item to or from a `usize`, as determined by the\n+/// `CLike` trait, changes while the item is in the set. This is normally only\n+/// possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n@@ -93,22 +98,16 @@ fn bit<E:CLike>(e: &E) -> usize {\n \n impl<E:CLike> EnumSet<E> {\n     /// Returns an empty `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn new() -> EnumSet<E> {\n         EnumSet {bits: 0, marker: marker::PhantomData}\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn len(&self) -> usize {\n         self.bits.count_ones() as usize\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n@@ -118,22 +117,16 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == 0\n     }\n \n     /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == other.bits\n     }\n \n     /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n         other.is_superset(self)\n     }\n@@ -151,33 +144,25 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, e: E) -> bool {\n         let result = !self.contains(&e);\n         self.bits |= bit(&e);\n         result\n     }\n \n     /// Removes an enum from the EnumSet\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn remove(&mut self, e: &E) -> bool {\n         let result = self.contains(e);\n         self.bits &= !bit(e);\n         result\n     }\n \n     /// Returns `true` if an `EnumSet` contains a given enum.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn contains(&self, e: &E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n     /// Returns an iterator over an `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn iter(&self) -> Iter<E> {\n         Iter::new(self.bits)\n     }"}, {"sha": "9762381381c6092cf7342c7b1754fbbc1107c537", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -10,14 +10,17 @@\n \n //! Collection types.\n //!\n-//! See [std::collections](../std/collections) for a detailed discussion of collections in Rust.\n+//! See [std::collections](../std/collections) for a detailed discussion of\n+//! collections in Rust.\n \n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"collections\"]\n-#![unstable(feature = \"collections\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n+#![unstable(feature = \"collections\",\n+            reason = \"library is unlikely to be stabilized with the current \\\n+                      layout and name, use std::collections instead\")]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n@@ -107,14 +110,12 @@ pub mod vec;\n pub mod vec_deque;\n pub mod vec_map;\n \n-#[unstable(feature = \"collections\",\n-           reason = \"RFC 509\")]\n+#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n pub mod bit_vec {\n     pub use bit::{BitVec, Iter};\n }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"RFC 509\")]\n+#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n pub mod bit_set {\n     pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n@@ -133,6 +134,7 @@ pub mod btree_set {\n \n // FIXME(#14344) this shouldn't be necessary\n #[doc(hidden)]\n+#[unstable(feature = \"issue_14344_fixme\")]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}\n \n #[cfg(not(test))]\n@@ -141,6 +143,7 @@ mod std {\n }\n \n /// An endpoint of a range of keys.\n+#[unstable(feature = \"collections_bound\")]\n #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n pub enum Bound<T> {\n     /// An inclusive bound."}, {"sha": "a732ce9e81df718f59615e185320e394181eca54", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -801,7 +801,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"linked_list_extras\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n@@ -824,7 +824,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"linked_list_extras\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {"}, {"sha": "f37c4aede6a1af8a24252868fa507166f7ef952c", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n #![unstable(feature = \"collections_range\", reason = \"was just added\")]\n \n //! Range syntax."}, {"sha": "c5418c9a0db8e6fd06bf7e8f0e86b571bf60f65f", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -11,7 +11,8 @@\n //! Utilities for slice manipulation\n //!\n //! The `slice` module contains useful code to help work with slice values.\n-//! Slices are a view into a block of memory represented as a pointer and a length.\n+//! Slices are a view into a block of memory represented as a pointer and a\n+//! length.\n //!\n //! ```\n //! // slicing a Vec\n@@ -69,8 +70,9 @@\n //! }\n //! ```\n //!\n-//! This iterator yields mutable references to the slice's elements, so while the element\n-//! type of the slice is `i32`, the element type of the iterator is `&mut i32`.\n+//! This iterator yields mutable references to the slice's elements, so while\n+//! the element type of the slice is `i32`, the element type of the iterator is\n+//! `&mut i32`.\n //!\n //! * `.iter()` and `.iter_mut()` are the explicit methods to return the default\n //!   iterators.\n@@ -278,29 +280,29 @@ impl<T> [T] {\n     }\n \n     /// Returns all but the first element of a slice.\n-    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n+    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed\")]\n     #[inline]\n     pub fn tail(&self) -> &[T] {\n         core_slice::SliceExt::tail(self)\n     }\n \n     /// Returns all but the first element of a mutable slice\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"slice_extras\",\n                reason = \"likely to be renamed or removed\")]\n     #[inline]\n     pub fn tail_mut(&mut self) -> &mut [T] {\n         core_slice::SliceExt::tail_mut(self)\n     }\n \n     /// Returns all but the last element of a slice.\n-    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n+    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed\")]\n     #[inline]\n     pub fn init(&self) -> &[T] {\n         core_slice::SliceExt::init(self)\n     }\n \n     /// Returns all but the last element of a mutable slice\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"slice_extras\",\n                reason = \"likely to be renamed or removed\")]\n     #[inline]\n     pub fn init_mut(&mut self) -> &mut [T] {\n@@ -727,13 +729,13 @@ impl<T> [T] {\n     }\n \n     /// Find the first index containing a matching value.\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"slice_position_elem\")]\n     pub fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         core_slice::SliceExt::position_elem(self, t)\n     }\n \n     /// Find the last index containing a matching value.\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"slice_position_elem\")]\n     pub fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         core_slice::SliceExt::rposition_elem(self, t)\n     }\n@@ -869,7 +871,7 @@ impl<T> [T] {\n     /// assert_eq!(Some(vec![1, 3, 2]), perms.next());\n     /// assert_eq!(Some(vec![3, 1, 2]), perms.next());\n     /// ```\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"permutations\")]\n     #[inline]\n     pub fn permutations(&self) -> Permutations<T> where T: Clone {\n         // NB see hack module in this file\n@@ -893,7 +895,7 @@ impl<T> [T] {\n     /// let b: &mut [_] = &mut [1, 0, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"permutations\",\n                reason = \"uncertain if this merits inclusion in std\")]\n     pub fn next_permutation(&mut self) -> bool where T: Ord {\n         core_slice::SliceExt::next_permutation(self)\n@@ -916,7 +918,7 @@ impl<T> [T] {\n     /// let b: &mut [_] = &mut [0, 1, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"permutations\",\n                reason = \"uncertain if this merits inclusion in std\")]\n     pub fn prev_permutation(&mut self) -> bool where T: Ord {\n         core_slice::SliceExt::prev_permutation(self)\n@@ -940,7 +942,7 @@ impl<T> [T] {\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3, 4, 5]);\n     /// ```\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"clone_from_slice\")]\n     pub fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n@@ -967,7 +969,7 @@ impl<T> [T] {\n     /// assert_eq!(num_moved, 3);\n     /// assert!(a == [6, 7, 8, 4, 5]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"move_from\",\n                reason = \"uncertain about this API approach\")]\n     #[inline]\n     pub fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n@@ -997,10 +999,12 @@ impl<T> [T] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable(feature = \"collections\", reason = \"recently changed\")]\n+#[unstable(feature = \"slice_concat_ext\",\n+           reason = \"trait should not have to exist\")]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized> {\n-    #[unstable(feature = \"collections\", reason = \"recently changed\")]\n+    #[unstable(feature = \"slice_concat_ext\",\n+               reason = \"trait should not have to exist\")]\n     /// The resulting type after concatenation\n     type Output;\n \n@@ -1014,8 +1018,8 @@ pub trait SliceConcatExt<T: ?Sized> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn concat(&self) -> Self::Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a given separator\n-    /// between each.\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n     ///\n     /// # Examples\n     ///\n@@ -1060,7 +1064,7 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n ///\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"permutations\")]\n #[derive(Clone)]\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n@@ -1072,7 +1076,7 @@ pub struct ElementSwaps {\n \n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"permutations\")]\n     pub fn new(length: usize) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n@@ -1194,13 +1198,13 @@ impl Iterator for ElementSwaps {\n /// swap applied.\n ///\n /// Generates even and odd permutations alternately.\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"permutations\")]\n pub struct Permutations<T> {\n     swaps: ElementSwaps,\n     v: Vec<T>,\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"permutations\", reason = \"trait is unstable\")]\n impl<T: Clone> Iterator for Permutations<T> {\n     type Item = Vec<T>;\n "}, {"sha": "61e09a2670ab3777e98efde583f3969d3bece185", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -366,7 +366,7 @@ impl<'a> Iterator for Recompositions<'a> {\n ///\n /// For use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"str_utf16\")]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n@@ -591,7 +591,7 @@ impl str {\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"slice_chars\",\n                reason = \"may have yet to prove its worth\")]\n     pub fn slice_chars(&self, begin: usize, end: usize) -> &str {\n         core_str::StrExt::slice_chars(self, begin, end)\n@@ -1068,7 +1068,7 @@ impl str {\n     }\n \n     /// Returns an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_utf16\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn utf16_units(&self) -> Utf16Units {\n         Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n@@ -1527,7 +1527,7 @@ impl str {\n     /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n     /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_matches\",\n                reason = \"method got recently added\")]\n     pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n         core_str::StrExt::matches(self, pat)\n@@ -1560,7 +1560,7 @@ impl str {\n     /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n     /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_matches\",\n                reason = \"method got recently added\")]\n     pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n@@ -1605,7 +1605,7 @@ impl str {\n     /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_matches\",\n                reason = \"might have its iterator type changed\")]\n     // NB: Right now MatchIndices yields `(usize, usize)`, but it would\n     // be more consistent with `matches` and `char_indices` to return `(usize, &str)`\n@@ -1649,7 +1649,7 @@ impl str {\n     /// let v: Vec<(usize, usize)> = \"ababa\".rmatch_indices(\"aba\").collect();\n     /// assert_eq!(v, [(2, 5)]); // only the last `aba`\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_matches\",\n                reason = \"might have its iterator type changed\")]\n     // NB: Right now RMatchIndices yields `(usize, usize)`, but it would\n     // be more consistent with `rmatches` and `char_indices` to return `(usize, &str)`\n@@ -1677,7 +1677,7 @@ impl str {\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n     /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"subslice_offset\",\n                reason = \"awaiting convention about comparability of arbitrary slices\")]\n     pub fn subslice_offset(&self, inner: &str) -> usize {\n         core_str::StrExt::subslice_offset(self, inner)\n@@ -1922,14 +1922,14 @@ impl str {\n     }\n \n     /// Escapes each char in `s` with `char::escape_default`.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\")]\n     pub fn escape_default(&self) -> String {\n         self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\")]\n     pub fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()"}, {"sha": "6e37a5731b384b82a60c78d4d1a8ce294cc37ca1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -696,7 +696,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections_drain)]\n+    /// # #![feature(drain)]\n     ///\n     /// let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n     /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n@@ -710,7 +710,7 @@ impl String {\n     /// s.drain(..);\n     /// assert_eq!(s, \"\");\n     /// ```\n-    #[unstable(feature = \"collections_drain\",\n+    #[unstable(feature = \"drain\",\n                reason = \"recently added, matches RFC\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain where R: RangeArgument<usize> {\n         // Memory safety\n@@ -975,10 +975,14 @@ impl ops::Deref for String {\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n \n+#[allow(deprecated)]\n impl<'a> Deref for DerefString<'a> {\n     type Target = String;\n \n@@ -1005,6 +1009,9 @@ impl<'a> Deref for DerefString<'a> {\n /// string_consumer(&as_string(\"foo\"));\n /// ```\n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n@@ -1134,7 +1141,7 @@ impl fmt::Write for String {\n }\n \n /// A draining iterator for `String`.\n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n pub struct Drain<'a> {\n     /// Will be used as &'a mut String in the destructor\n     string: *mut String,\n@@ -1149,7 +1156,7 @@ pub struct Drain<'a> {\n unsafe impl<'a> Sync for Drain<'a> {}\n unsafe impl<'a> Send for Drain<'a> {}\n \n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n impl<'a> Drop for Drain<'a> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -1163,7 +1170,7 @@ impl<'a> Drop for Drain<'a> {\n     }\n }\n \n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n impl<'a> Iterator for Drain<'a> {\n     type Item = char;\n \n@@ -1177,7 +1184,7 @@ impl<'a> Iterator for Drain<'a> {\n     }\n }\n \n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n impl<'a> DoubleEndedIterator for Drain<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {"}, {"sha": "1409ececfc7a5addf6db95b82126fa7d5bb817f7", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -276,7 +276,7 @@ impl<T> Vec<T> {\n     /// the buffer are copied into the vector without cloning, as if\n     /// `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"vec_from_raw_buf\",\n                reason = \"may be better expressed via composition\")]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n@@ -704,7 +704,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec2, []);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"append\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if mem::size_of::<T>() == 0 {\n@@ -742,15 +742,15 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections_drain)]\n+    /// # #![feature(drain)]\n     ///\n     /// // Draining using `..` clears the whole vector.\n     /// let mut v = vec![1, 2, 3];\n     /// let u: Vec<_> = v.drain(..).collect();\n     /// assert_eq!(v, &[]);\n     /// assert_eq!(u, &[1, 2, 3]);\n     /// ```\n-    #[unstable(feature = \"collections_drain\",\n+    #[unstable(feature = \"drain\",\n                reason = \"recently added, matches RFC\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n         // Memory safety\n@@ -851,7 +851,7 @@ impl<T> Vec<T> {\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n     /// assert_eq!(&newtyped_bytes[..], &[Newtype(0x11), Newtype(0x22)]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"map_in_place\",\n                reason = \"API may change to provide stronger guarantees\")]\n     pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n         // FIXME: Assert statically that the types `T` and `U` have the same\n@@ -1043,14 +1043,14 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(split_off)]\n     /// let mut vec = vec![1,2,3];\n     /// let vec2 = vec.split_off(1);\n     /// assert_eq!(vec, [1]);\n     /// assert_eq!(vec2, [2, 3]);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         assert!(at <= self.len(), \"`at` out of bounds\");\n@@ -1091,7 +1091,7 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, [1, 2]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"vec_resize\",\n                reason = \"matches collection reform specification; waiting for dust to settle\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n@@ -1117,7 +1117,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, [1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"vec_push_all\",\n                reason = \"likely to be replaced by a more optimized extend\")]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n@@ -1738,7 +1738,7 @@ unsafe impl<T: Sync> Sync for IntoIter<T> { }\n impl<T> IntoIter<T> {\n     #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"iter_to_vec\")]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self.by_ref() { }\n@@ -1832,7 +1832,7 @@ impl<T> Drop for IntoIter<T> {\n }\n \n /// A draining iterator for `Vec<T>`.\n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve\n     tail_start: usize,\n@@ -1907,12 +1907,17 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n pub struct DerefVec<'a, T:'a> {\n     x: Vec<T>,\n     l: PhantomData<&'a T>,\n }\n \n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n impl<'a, T> Deref for DerefVec<'a, T> {\n     type Target = Vec<T>;\n \n@@ -1923,6 +1928,9 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;\n@@ -1948,6 +1956,9 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n /// vec_consumer(&as_vec(&values));\n /// ```\n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {"}, {"sha": "54127ea8a9ef2ae3a27b86bafc6ba14671e49c81", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -491,7 +491,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf.len(), 1);\n     /// assert_eq!(Some(&5), buf.get(0));\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn truncate(&mut self, len: usize) {\n         for _ in len..self.len() {\n@@ -552,7 +552,7 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n         unsafe {\n@@ -572,7 +572,7 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -638,7 +638,7 @@ impl<T> VecDeque<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain {\n@@ -880,7 +880,7 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(10);\n     /// assert_eq!(buf.swap_back_remove(1), Some(99));\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"the naming of this function may be altered\")]\n     pub fn swap_back_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n@@ -914,7 +914,7 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(20);\n     /// assert_eq!(buf.swap_front_remove(3), Some(99));\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"the naming of this function may be altered\")]\n     pub fn swap_front_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n@@ -1320,7 +1320,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf2.len(), 2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let len = self.len();\n@@ -1383,7 +1383,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf2.len(), 0);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"append\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // naive impl\n@@ -1447,7 +1447,7 @@ impl<T: Clone> VecDeque<T> {\n     ///     assert_eq!(a, b);\n     /// }\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n@@ -1635,7 +1635,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining VecDeque iterator\n-#[unstable(feature = \"collections\",\n+#[unstable(feature = \"drain\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n     inner: &'a mut VecDeque<T>,"}, {"sha": "3fd2455a0044334fa010f2336856174495875d14", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -12,6 +12,8 @@\n //! are O(highest integer key).\n \n #![allow(missing_docs)]\n+#![unstable(feature = \"vecmap\",\n+            reason = \"may not be stabilized in the standard library\")]\n \n use self::Entry::*;\n \n@@ -325,7 +327,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(a[3], \"c\");\n     /// assert_eq!(a[4], \"d\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"append\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn append(&mut self, other: &mut Self) {\n         self.extend(other.drain());\n@@ -358,7 +360,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(b[3], \"c\");\n     /// assert_eq!(b[4], \"d\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let mut other = VecMap::new();\n@@ -410,7 +412,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n         fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n@@ -632,7 +634,7 @@ impl<V> VecMap<V> {\n \n \n impl<'a, V> Entry<'a, V> {\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"entry\",\n                reason = \"will soon be replaced by or_insert\")]\n     #[deprecated(since = \"1.0\",\n                 reason = \"replaced with more ergonomic `or_insert` and `or_insert_with`\")]\n@@ -644,7 +646,7 @@ impl<'a, V> Entry<'a, V> {\n         }\n     }\n \n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"entry\",\n                reason = \"matches entry v3 specification, waiting for dust to settle\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n@@ -655,7 +657,7 @@ impl<'a, V> Entry<'a, V> {\n         }\n     }\n \n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"entry\",\n                reason = \"matches entry v3 specification, waiting for dust to settle\")]\n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n@@ -1003,22 +1005,22 @@ pub struct IntoIter<V> {\n     fn((usize, Option<V>)) -> Option<(usize, V)>>\n }\n \n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"drain\")]\n pub struct Drain<'a, V:'a> {\n     iter: FilterMap<\n     Enumerate<vec::Drain<'a, Option<V>>>,\n     fn((usize, Option<V>)) -> Option<(usize, V)>>\n }\n \n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"drain\")]\n impl<'a, V> Iterator for Drain<'a, V> {\n     type Item = (usize, V);\n \n     fn next(&mut self) -> Option<(usize, V)> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"drain\")]\n impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n     fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n }"}, {"sha": "f8d80035d97fb62f645924142a72f9a7b7b76933", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -281,8 +281,9 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(collections)]\n+\n #![feature(into_cow)]\n+#![feature(str_escape)]\n \n use self::LabelText::*;\n "}, {"sha": "49667bf74cf2cf4642c35341541a27312f41f779", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -25,18 +25,22 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(append)]\n #![feature(associated_consts)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(clone_from_slice)]\n #![feature(collections)]\n #![feature(const_fn)]\n #![feature(duration)]\n #![feature(duration_span)]\n+#![feature(enumset)]\n #![feature(fs_canonicalize)]\n #![feature(hash_default)]\n #![feature(into_cow)]\n #![feature(iter_sum)]\n #![feature(libc)]\n+#![feature(map_in_place)]\n #![feature(num_bits_bytes)]\n #![feature(path_ext)]\n #![feature(quote)]\n@@ -45,10 +49,14 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(slice_bytes)]\n+#![feature(slice_extras)]\n #![feature(slice_patterns)]\n+#![feature(slice_position_elem)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(str_char)]\n+#![feature(str_matches)]\n+#![feature(vec_push_all)]\n #![feature(wrapping)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "297041a99079072577940109fe7e01c2dded21d3", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -33,7 +33,6 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(box_syntax)]\n-#![feature(collections)]\n #![feature(fs_canonicalize)]\n #![feature(libc)]\n #![feature(path_ext)]\n@@ -42,6 +41,7 @@\n #![feature(slice_bytes)]\n #![feature(staged_api)]\n #![feature(step_by)]\n+#![feature(vec_push_all)]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;"}, {"sha": "e369ca46b2c0225e12b296797c85d7d30ba87333", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -26,14 +26,15 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(box_syntax)]\n-#![feature(collections)]\n+#![feature(exit_status)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(staged_api)]\n-#![feature(exit_status)]\n #![feature(set_stdio)]\n+#![feature(staged_api)]\n+#![feature(str_casing)]\n+#![feature(vec_push_all)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "d53689bb1d164c1c396a28e2aa1b1f8d14493156", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -30,17 +30,17 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![cfg_attr(test, feature(test))]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n #![feature(num_bits_bytes)]\n #![feature(quote)]\n #![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(str_casing)]\n #![feature(str_char)]\n-#![cfg_attr(test, feature(test))]\n \n extern crate syntax;\n #[macro_use]"}, {"sha": "bea934c6aa0dc09aacebf59d79908a74e8b181e6", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -27,10 +27,10 @@\n \n #![feature(associated_consts)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n+#![feature(vec_push_all)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "787f914718d4b60922ea662119cf4e682544ecfe", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -20,10 +20,10 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(associated_consts)]\n-#![feature(collections)]\n #![feature(rc_weak)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_extras)]\n #![feature(staged_api)]\n \n #[macro_use] extern crate log;"}, {"sha": "5ace77284953adf8cf44332464b12d8d2362c6e4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -27,7 +27,6 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n #![feature(const_fn)]\n #![feature(fs)]\n #![feature(iter_cmp)]\n@@ -46,6 +45,7 @@\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(unicode)]\n+#![feature(vec_push_all)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "f204fa2b1fd01817abff1354fc1f37ff9473d225", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -77,14 +77,16 @@ This API is completely unstable and subject to change.\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections, collections_drain)]\n+#![feature(drain)]\n #![feature(iter_cmp)]\n #![feature(iter_sum)]\n #![feature(quote)]\n #![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_extras)]\n #![feature(staged_api)]\n+#![feature(vec_push_all)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "0ad5141c5bee69ff555e84018a32cede5656afd7", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -310,7 +310,9 @@ impl char {\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     #[inline]\n-    pub fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n+    pub fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> {\n+        C::encode_utf8(self, dst)\n+    }\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n     /// then returns the number of `u16`s written.\n@@ -345,7 +347,9 @@ impl char {\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     #[inline]\n-    pub fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n+    pub fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> {\n+        C::encode_utf16(self, dst)\n+    }\n \n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n@@ -541,5 +545,7 @@ impl char {\n     #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n     #[inline]\n-    pub fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n+    pub fn width(self, is_cjk: bool) -> Option<usize> {\n+        charwidth::width(self, is_cjk)\n+    }\n }"}, {"sha": "7fdab8789158ee9719efd58b3fc24f4e35e99c31", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -36,6 +36,8 @@ Core encoding and decoding interfaces.\n #![feature(std_misc)]\n #![feature(str_char)]\n #![feature(unicode)]\n+#![feature(vecmap)]\n+#![feature(enumset)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "20211f87689b615e5c2cfd6cf7182f57f17da8b8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -110,7 +110,9 @@\n #![feature(box_raw)]\n #![feature(box_syntax)]\n #![feature(char_internals)]\n+#![feature(clone_from_slice)]\n #![feature(collections)]\n+#![feature(collections_bound)]\n #![feature(const_fn)]\n #![feature(core)]\n #![feature(core_float)]\n@@ -126,6 +128,8 @@\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n #![feature(macro_reexport)]\n+#![feature(slice_concat_ext)]\n+#![feature(slice_position_elem)]\n #![feature(no_std)]\n #![feature(num_bits_bytes)]\n #![feature(oom)]\n@@ -142,6 +146,7 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(vec_push_all)]\n #![feature(wrapping)]\n #![feature(zero_one)]\n #![cfg_attr(test, feature(float_from_str_radix))]"}, {"sha": "7333265bdd41246bc0ea2afbe2385814d2e081a2", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -26,15 +26,17 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(associated_consts)]\n-#![feature(collections)]\n-#![feature(collections_drain)]\n+#![feature(bitset)]\n+#![feature(drain)]\n #![feature(filling_drop)]\n #![feature(libc)]\n #![feature(ref_slice)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_char)]\n+#![feature(str_escape)]\n #![feature(unicode)]\n+#![feature(vec_push_all)]\n \n extern crate fmt_macros;\n extern crate serialize;"}, {"sha": "3affb37ba5b9ff1e47f905903a81147e7b9a6d14", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -56,12 +56,12 @@\n #![deny(missing_docs)]\n \n #![feature(box_syntax)]\n-#![feature(collections)]\n+#![feature(path_ext)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(str_char)]\n-#![feature(path_ext)]\n+#![feature(vec_push_all)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "46649689134664b55c79e311292c274950362a93", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -36,14 +36,14 @@\n \n #![feature(asm)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n #![feature(duration)]\n #![feature(duration_span)]\n #![feature(fnbox)]\n #![feature(iter_cmp)]\n #![feature(libc)]\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n+#![feature(slice_extras)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n "}, {"sha": "e79462a4aafe2145286eed06d507cd2cee6ec3a7", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d444d0c357e85c90e73585520e2da74304c7265a/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d444d0c357e85c90e73585520e2da74304c7265a/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=d444d0c357e85c90e73585520e2da74304c7265a", "patch": "@@ -10,11 +10,11 @@\n \n #![deny(warnings)]\n \n-#![feature(core)]\n #![feature(exit_status)]\n-#![feature(rustdoc)]\n-#![feature(rustc_private)]\n+#![feature(iter_sum)]\n #![feature(path_relative_from)]\n+#![feature(rustc_private)]\n+#![feature(rustdoc)]\n \n extern crate rustdoc;\n extern crate rustc_back;"}]}