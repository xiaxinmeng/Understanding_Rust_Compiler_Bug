{"sha": "91b88c54c2d2af73bcf23d383b4d5d524d222b14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYjg4YzU0YzJkMmFmNzNiY2YyM2QzODNiNGQ1ZDUyNGQyMjJiMTQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-09-18T05:58:26Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-11-25T14:26:15Z"}, "message": "Add `ty` to `LoanPath`.\n\nTo make this clean, refactored old `LoanPath` enum into a\n`LoanPath` struct with a `ty::t` and a newly-added `LoanPathVariant` enum.\n\nThis enabled me to get rid of the ugly and fragile `LoanPath::to_type`\nmethod, and I can probably also get rid of other stuff that was\nsupporting it, maybe.", "tree": {"sha": "bf5fe4cba6ec980e0cafe847b93ba486c61afcec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf5fe4cba6ec980e0cafe847b93ba486c61afcec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91b88c54c2d2af73bcf23d383b4d5d524d222b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91b88c54c2d2af73bcf23d383b4d5d524d222b14", "html_url": "https://github.com/rust-lang/rust/commit/91b88c54c2d2af73bcf23d383b4d5d524d222b14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91b88c54c2d2af73bcf23d383b4d5d524d222b14/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6c8f3b7268040071d61acbeab3b5253b07b7caa", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c8f3b7268040071d61acbeab3b5253b07b7caa", "html_url": "https://github.com/rust-lang/rust/commit/d6c8f3b7268040071d61acbeab3b5253b07b7caa"}], "stats": {"total": 381, "additions": 206, "deletions": 175}, "files": [{"sha": "06c440a9adc2c33dd9887e147265e781d09c1342", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=91b88c54c2d2af73bcf23d383b4d5d524d222b14", "patch": "@@ -19,6 +19,8 @@\n use self::UseError::*;\n \n use middle::borrowck::*;\n+use middle::borrowck::LoanPathElem::*;\n+use middle::borrowck::LoanPathKind::*;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::region;\n@@ -33,51 +35,51 @@ use std::rc::Rc;\n // be less precise in its handling of Box while still allowing moves out of a\n // Box. They should be removed when OwnedPtr is removed from LoanPath.\n \n-fn owned_ptr_base_path<'a>(loan_path: &'a LoanPath) -> &'a LoanPath {\n+fn owned_ptr_base_path<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> &'a LoanPath<'tcx> {\n     //! Returns the base of the leftmost dereference of an OwnedPtr in\n     //! `loan_path`. If there is no dereference of an OwnedPtr in `loan_path`,\n     //! then it just returns `loan_path` itself.\n \n-    return match owned_ptr_base_path_helper(loan_path) {\n+    return match helper(loan_path) {\n         Some(new_loan_path) => new_loan_path,\n         None => loan_path.clone()\n     };\n \n-    fn owned_ptr_base_path_helper<'a>(loan_path: &'a LoanPath) -> Option<&'a LoanPath> {\n-        match *loan_path {\n+    fn helper<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> Option<&'a LoanPath<'tcx>> {\n+        match loan_path.kind {\n             LpVar(_) | LpUpvar(_) => None,\n             LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {\n-                match owned_ptr_base_path_helper(&**lp_base) {\n+                match helper(&**lp_base) {\n                     v @ Some(_) => v,\n                     None => Some(&**lp_base)\n                 }\n             }\n             LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, _, _) => owned_ptr_base_path_helper(&**lp_base)\n+            LpExtend(ref lp_base, _, _) => helper(&**lp_base)\n         }\n     }\n }\n \n-fn owned_ptr_base_path_rc(loan_path: &Rc<LoanPath>) -> Rc<LoanPath> {\n+fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'tcx>> {\n     //! The equivalent of `owned_ptr_base_path` for an &Rc<LoanPath> rather than\n     //! a &LoanPath.\n \n-    return match owned_ptr_base_path_helper(loan_path) {\n+    return match helper(loan_path) {\n         Some(new_loan_path) => new_loan_path,\n         None => loan_path.clone()\n     };\n \n-    fn owned_ptr_base_path_helper(loan_path: &Rc<LoanPath>) -> Option<Rc<LoanPath>> {\n-        match **loan_path {\n+    fn helper<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Option<Rc<LoanPath<'tcx>>> {\n+        match loan_path.kind {\n             LpVar(_) | LpUpvar(_) => None,\n             LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {\n-                match owned_ptr_base_path_helper(lp_base) {\n+                match helper(lp_base) {\n                     v @ Some(_) => v,\n                     None => Some(lp_base.clone())\n                 }\n             }\n             LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, _, _) => owned_ptr_base_path_helper(lp_base)\n+            LpExtend(ref lp_base, _, _) => helper(lp_base)\n         }\n     }\n }\n@@ -86,7 +88,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n     move_data: move_data::FlowedMoveData<'a, 'tcx>,\n-    all_loans: &'a [Loan],\n+    all_loans: &'a [Loan<'tcx>],\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -185,7 +187,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n                                      move_data: move_data::FlowedMoveData<'c, 'tcx>,\n-                                     all_loans: &[Loan],\n+                                     all_loans: &[Loan<'tcx>],\n                                      decl: &ast::FnDecl,\n                                      body: &ast::Block) {\n     debug!(\"check_loans(body id={})\", body.id);\n@@ -204,9 +206,9 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n #[deriving(PartialEq)]\n-enum UseError {\n+enum UseError<'tcx> {\n     UseOk,\n-    UseWhileBorrowed(/*loan*/Rc<LoanPath>, /*loan*/Span)\n+    UseWhileBorrowed(/*loan*/Rc<LoanPath<'tcx>>, /*loan*/Span)\n }\n \n fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n@@ -218,7 +220,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan(&self, scope: region::CodeExtent, op: |&Loan| -> bool)\n+    pub fn each_issued_loan(&self, scope: region::CodeExtent, op: |&Loan<'tcx>| -> bool)\n                             -> bool {\n         //! Iterates over each loan that has been issued\n         //! on entrance to `scope`, regardless of whether it is\n@@ -234,7 +236,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n     pub fn each_in_scope_loan(&self,\n                               scope: region::CodeExtent,\n-                              op: |&Loan| -> bool)\n+                              op: |&Loan<'tcx>| -> bool)\n                               -> bool {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n@@ -251,8 +253,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n     fn each_in_scope_loan_affecting_path(&self,\n                                          scope: region::CodeExtent,\n-                                         loan_path: &LoanPath,\n-                                         op: |&Loan| -> bool)\n+                                         loan_path: &LoanPath<'tcx>,\n+                                         op: |&Loan<'tcx>| -> bool)\n                                          -> bool {\n         //! Iterates through all of the in-scope loans affecting `loan_path`,\n         //! calling `op`, and ceasing iteration if `false` is returned.\n@@ -296,7 +298,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         let mut loan_path = loan_path;\n         loop {\n-            match *loan_path {\n+            match loan_path.kind {\n                 LpVar(_) | LpUpvar(_) => {\n                     break;\n                 }\n@@ -366,8 +368,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn report_error_if_loans_conflict(&self,\n-                                          old_loan: &Loan,\n-                                          new_loan: &Loan) {\n+                                          old_loan: &Loan<'tcx>,\n+                                          new_loan: &Loan<'tcx>) {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n@@ -386,10 +388,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn report_error_if_loan_conflicts_with_restriction(&self,\n-                                                           loan1: &Loan,\n-                                                           loan2: &Loan,\n-                                                           old_loan: &Loan,\n-                                                           new_loan: &Loan)\n+                                                           loan1: &Loan<'tcx>,\n+                                                           loan2: &Loan<'tcx>,\n+                                                           old_loan: &Loan<'tcx>,\n+                                                           new_loan: &Loan<'tcx>)\n                                                            -> bool {\n         //! Checks whether the restrictions introduced by `loan1` would\n         //! prohibit `loan2`. Returns false if an error is reported.\n@@ -552,7 +554,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         true\n     }\n \n-    fn is_local_variable_or_arg(&self, cmt: mc::cmt) -> bool {\n+    fn is_local_variable_or_arg(&self, cmt: mc::cmt<'tcx>) -> bool {\n         match cmt.cat {\n           mc::cat_local(_) => true,\n           _ => false\n@@ -562,7 +564,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn consume_common(&self,\n                       id: ast::NodeId,\n                       span: Span,\n-                      cmt: mc::cmt,\n+                      cmt: mc::cmt<'tcx>,\n                       mode: euv::ConsumeMode) {\n         match opt_loan_path(&cmt) {\n             Some(lp) => {\n@@ -603,7 +605,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_for_copy_of_frozen_path(&self,\n                                      id: ast::NodeId,\n                                      span: Span,\n-                                     copy_path: &LoanPath) {\n+                                     copy_path: &LoanPath<'tcx>) {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n@@ -624,7 +626,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_for_move_of_borrowed_path(&self,\n                                        id: ast::NodeId,\n                                        span: Span,\n-                                       move_path: &LoanPath,\n+                                       move_path: &LoanPath<'tcx>,\n                                        move_kind: move_data::MoveKind) {\n         // We want to detect if there are any loans at all, so we search for\n         // any loans incompatible with MutBorrrow, since all other kinds of\n@@ -655,9 +657,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n     pub fn analyze_restrictions_on_use(&self,\n                                        expr_id: ast::NodeId,\n-                                       use_path: &LoanPath,\n+                                       use_path: &LoanPath<'tcx>,\n                                        borrow_kind: ty::BorrowKind)\n-                                       -> UseError {\n+                                       -> UseError<'tcx> {\n         debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={})\",\n                self.tcx().map.node_to_string(expr_id),\n                use_path.repr(self.tcx()));\n@@ -681,7 +683,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                               id: ast::NodeId,\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n-                              lp: &Rc<LoanPath>) {\n+                              lp: &Rc<LoanPath<'tcx>>) {\n         /*!\n          * Reports an error if `expr` (which should be a path)\n          * is using a moved/uninitialized value\n@@ -705,7 +707,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                        id: ast::NodeId,\n                                        span: Span,\n                                        use_kind: MovedValueUseKind,\n-                                       lp: &Rc<LoanPath>)\n+                                       lp: &Rc<LoanPath<'tcx>>)\n     {\n         /*!\n          * Reports an error if assigning to `lp` will use a\n@@ -725,7 +727,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n          *     (*p).x = 22; // not ok, p is uninitialized, can't deref\n          */\n \n-        match **lp {\n+        match lp.kind {\n             LpVar(_) | LpUpvar(_) => {\n                 // assigning to `x` does not require that `x` is initialized\n             }\n@@ -923,11 +925,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn check_for_assignment_to_borrowed_path(\n-            this: &CheckLoanCtxt,\n+        fn check_for_assignment_to_borrowed_path<'a, 'tcx>(\n+            this: &CheckLoanCtxt<'a, 'tcx>,\n             assignment_id: ast::NodeId,\n             assignment_span: Span,\n-            assignee_cmt: mc::cmt)\n+            assignee_cmt: mc::cmt<'tcx>)\n         {\n             //! Check for assignments that violate the terms of an\n             //! outstanding loan.\n@@ -947,7 +949,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n     pub fn report_illegal_mutation(&self,\n                                    span: Span,\n-                                   loan_path: &LoanPath,\n+                                   loan_path: &LoanPath<'tcx>,\n                                    loan: &Loan) {\n         self.bccx.span_err(\n             span,"}, {"sha": "5aeeb3566fd37ad1e8530cd6ce4cca6bc4060c01", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=91b88c54c2d2af73bcf23d383b4d5d524d222b14", "patch": "@@ -13,6 +13,7 @@\n  */\n \n use middle::borrowck::*;\n+use middle::borrowck::LoanPathKind::*;\n use middle::borrowck::gather_loans::move_error::MoveSpanAndPath;\n use middle::borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use middle::borrowck::move_data::*;\n@@ -32,17 +33,18 @@ struct GatherMoveInfo<'tcx> {\n     span_path_opt: Option<MoveSpanAndPath>\n }\n \n-pub fn gather_decl(bccx: &BorrowckCtxt,\n-                   move_data: &MoveData,\n-                   decl_id: ast::NodeId,\n-                   _decl_span: Span,\n-                   var_id: ast::NodeId) {\n-    let loan_path = Rc::new(LpVar(var_id));\n+pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                             move_data: &MoveData<'tcx>,\n+                             decl_id: ast::NodeId,\n+                             _decl_span: Span,\n+                             var_id: ast::NodeId) {\n+    let ty = ty::node_id_to_type(bccx.tcx, var_id);\n+    let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                       move_data: &MoveData,\n+                                       move_data: &MoveData<'tcx>,\n                                        move_error_collector: &MoveErrorCollector<'tcx>,\n                                        move_expr_id: ast::NodeId,\n                                        cmt: mc::cmt<'tcx>,\n@@ -61,7 +63,7 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      move_data: &MoveData,\n+                                      move_data: &MoveData<'tcx>,\n                                       move_error_collector: &MoveErrorCollector<'tcx>,\n                                       move_pat: &ast::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n@@ -82,7 +84,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                         move_data: &MoveData,\n+                         move_data: &MoveData<'tcx>,\n                          move_error_collector: &MoveErrorCollector<'tcx>,\n                          move_info: GatherMoveInfo<'tcx>) {\n     debug!(\"gather_move(move_id={}, cmt={})\",\n@@ -112,13 +114,13 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn gather_assignment(bccx: &BorrowckCtxt,\n-                         move_data: &MoveData,\n-                         assignment_id: ast::NodeId,\n-                         assignment_span: Span,\n-                         assignee_loan_path: Rc<LoanPath>,\n-                         assignee_id: ast::NodeId,\n-                         mode: euv::MutateMode) {\n+pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                   move_data: &MoveData<'tcx>,\n+                                   assignment_id: ast::NodeId,\n+                                   assignment_span: Span,\n+                                   assignee_loan_path: Rc<LoanPath<'tcx>>,\n+                                   assignee_id: ast::NodeId,\n+                                   mode: euv::MutateMode) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,\n                              assignment_id,"}, {"sha": "3cd14060bd8e345af65495b7c96b4ddc02fc1932", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=91b88c54c2d2af73bcf23d383b4d5d524d222b14", "patch": "@@ -17,6 +17,7 @@\n // sure that all of these loans are honored.\n \n use middle::borrowck::*;\n+use middle::borrowck::LoanPathKind::*;\n use middle::borrowck::move_data::MoveData;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n@@ -35,10 +36,10 @@ mod restrictions;\n mod gather_moves;\n mod move_error;\n \n-pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n-                          decl: &ast::FnDecl,\n-                          body: &ast::Block)\n-                          -> (Vec<Loan>, move_data::MoveData)\n+pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                    decl: &ast::FnDecl,\n+                                    body: &ast::Block)\n+                                    -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>)\n {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n@@ -60,9 +61,9 @@ pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n \n struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    move_data: move_data::MoveData,\n+    move_data: move_data::MoveData<'tcx>,\n     move_error_collector: move_error::MoveErrorCollector<'tcx>,\n-    all_loans: Vec<Loan>,\n+    all_loans: Vec<Loan<'tcx>>,\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n     item_ub: region::CodeExtent,\n@@ -395,7 +396,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! For mutable loans of content whose mutability derives\n         //! from a local variable, mark the mutability decl as necessary.\n \n-        match *loan_path {\n+        match loan_path.kind {\n             LpVar(local_id) |\n             LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {\n                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n@@ -427,7 +428,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath)\n+    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath<'tcx>)\n                               -> region::CodeExtent {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the"}, {"sha": "adae34b49dca2d1dc386c27f14a0f6f656ef3164", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=91b88c54c2d2af73bcf23d383b4d5d524d222b14", "patch": "@@ -15,6 +15,8 @@\n pub use self::RestrictionResult::*;\n \n use middle::borrowck::*;\n+use middle::borrowck::LoanPathElem::*;\n+use middle::borrowck::LoanPathKind::*;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty;\n@@ -24,17 +26,17 @@ use util::ppaux::Repr;\n use std::rc::Rc;\n \n #[deriving(Show)]\n-pub enum RestrictionResult {\n+pub enum RestrictionResult<'tcx> {\n     Safe,\n-    SafeIf(Rc<LoanPath>, Vec<Rc<LoanPath>>)\n+    SafeIf(Rc<LoanPath<'tcx>>, Vec<Rc<LoanPath<'tcx>>>)\n }\n \n pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       cause: euv::LoanCause,\n                                       cmt: mc::cmt<'tcx>,\n                                       loan_region: ty::Region)\n-                                      -> RestrictionResult {\n+                                      -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n@@ -57,9 +59,11 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n-                cmt: mc::cmt<'tcx>) -> RestrictionResult {\n+                cmt: mc::cmt<'tcx>) -> RestrictionResult<'tcx> {\n         debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));\n \n+        let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n+\n         match cmt.cat.clone() {\n             mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n@@ -72,13 +76,13 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n \n             mc::cat_local(local_id) => {\n                 // R-Variable, locally declared\n-                let lp = Rc::new(LpVar(local_id));\n+                let lp = new_lp(LpVar(local_id));\n                 SafeIf(lp.clone(), vec![lp])\n             }\n \n             mc::cat_upvar(mc::Upvar { id, .. }) => {\n                 // R-Variable, captured into closure\n-                let lp = Rc::new(LpUpvar(id));\n+                let lp = new_lp(LpUpvar(id));\n                 SafeIf(lp.clone(), vec![lp])\n             }\n \n@@ -96,10 +100,9 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 // the memory, so no additional restrictions are\n                 // needed.\n                 let result = self.restrict(cmt_base);\n-                self.extend(result, cmt.mutbl, LpInterior(i))\n+                self.extend(result, &cmt, LpInterior(i))\n             }\n \n-\n             mc::cat_static_item(..) => {\n                 Safe\n             }\n@@ -116,7 +119,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                         // Eventually we should make these non-special and\n                         // just rely on Deref<T> implementation.\n                         let result = self.restrict(cmt_base);\n-                        self.extend(result, cmt.mutbl, LpDeref(pk))\n+                        self.extend(result, &cmt, LpDeref(pk))\n                     }\n                     mc::Implicit(bk, lt) | mc::BorrowedPtr(bk, lt) => {\n                         // R-Deref-[Mut-]Borrowed\n@@ -140,7 +143,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                                 // references lifetime ends (by a newly-unfrozen\n                                 // borrow).\n                                 let result = self.restrict(cmt_base);\n-                                self.extend(result, cmt.mutbl, LpDeref(pk))\n+                                self.extend(result, &cmt, LpDeref(pk))\n                             }\n                         }\n                     }\n@@ -152,13 +155,14 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     }\n \n     fn extend(&self,\n-              result: RestrictionResult,\n-              mc: mc::MutabilityCategory,\n-              elem: LoanPathElem) -> RestrictionResult {\n+              result: RestrictionResult<'tcx>,\n+              cmt: &mc::cmt<'tcx>,\n+              elem: LoanPathElem) -> RestrictionResult<'tcx> {\n         match result {\n             Safe => Safe,\n             SafeIf(base_lp, mut base_vec) => {\n-                let lp = Rc::new(LpExtend(base_lp, mc, elem));\n+                let v = LpExtend(base_lp, cmt.mutbl, elem);\n+                let lp = Rc::new(LoanPath::new(v, cmt.ty));\n                 base_vec.push(lp.clone());\n                 SafeIf(lp, base_vec)\n             }"}, {"sha": "41f7b7dba1da6009f4c39f902421b60f9779ff9f", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=91b88c54c2d2af73bcf23d383b4d5d524d222b14", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                                      e: EntryOrExit,\n                                      cfgidx: CFGIndex,\n                                      dfcx: &DataFlowContext<'a, 'tcx, O>,\n-                                     to_lp: |uint| -> Rc<LoanPath>) -> String {\n+                                     to_lp: |uint| -> Rc<LoanPath<'tcx>>) -> String {\n         let mut saw_some = false;\n         let mut set = \"{\".to_string();\n         dfcx.each_bit_for_node(e, cfgidx, |index| {"}, {"sha": "dd6de13ba25c86269c52f52ad2df5e013c12c7f9", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 84, "deletions": 64, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=91b88c54c2d2af73bcf23d383b4d5d524d222b14", "patch": "@@ -12,7 +12,7 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::LoanPath::*;\n+pub use self::LoanPathKind::*;\n pub use self::LoanPathElem::*;\n pub use self::bckerr_code::*;\n pub use self::AliasableViolationKind::*;\n@@ -125,7 +125,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n \n /// Collection of conclusions determined via borrow checker analyses.\n pub struct AnalysisData<'a, 'tcx: 'a> {\n-    pub all_loans: Vec<Loan>,\n+    pub all_loans: Vec<Loan<'tcx>>,\n     pub loans: DataFlowContext<'a, 'tcx, LoanDataFlowOperator>,\n     pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n@@ -254,11 +254,11 @@ pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n // Loans and loan paths\n \n /// Record of a loan that was issued.\n-pub struct Loan {\n+pub struct Loan<'tcx> {\n     index: uint,\n-    loan_path: Rc<LoanPath>,\n+    loan_path: Rc<LoanPath<'tcx>>,\n     kind: ty::BorrowKind,\n-    restricted_paths: Vec<Rc<LoanPath>>,\n+    restricted_paths: Vec<Rc<LoanPath<'tcx>>>,\n \n     /// gen_scope indicates where loan is introduced. Typically the\n     /// loan is introduced at the point of the borrow, but in some\n@@ -276,33 +276,31 @@ pub struct Loan {\n     cause: euv::LoanCause,\n }\n \n-impl Loan {\n-    pub fn loan_path(&self) -> Rc<LoanPath> {\n+impl<'tcx> Loan<'tcx> {\n+    pub fn loan_path(&self) -> Rc<LoanPath<'tcx>> {\n         self.loan_path.clone()\n     }\n }\n \n #[deriving(PartialEq, Eq, Hash, Show)]\n-pub enum LoanPath {\n-    LpVar(ast::NodeId),                   // `x` in doc.rs\n-    LpUpvar(ty::UpvarId),                 // `x` captured by-value into closure\n-    LpDowncast(Rc<LoanPath>, ast::DefId), // `x` downcast to particular enum variant\n-    LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n+pub struct LoanPath<'tcx> {\n+    kind: LoanPathKind<'tcx>,\n+    ty: ty::Ty<'tcx>,\n }\n \n-impl LoanPath {\n-    fn kill_id(&self, tcx: &ty::ctxt) -> ast::NodeId {\n-        //! Returns the lifetime of the local variable that forms the\n-        //! base of this path.  (See move_data::add_gen_kills.)\n-        match *self {\n-            LpVar(id) =>\n-                tcx.region_maps.var_scope(id),\n-            LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) =>\n-                closure_to_block(closure_expr_id, tcx),\n-            LpDowncast(ref base_lp, _) | LpExtend(ref base_lp, _, _) =>\n-                base_lp.kill_id(tcx),\n-        }\n+#[deriving(PartialEq, Eq, Hash, Show)]\n+pub enum LoanPathKind<'tcx> {\n+    LpVar(ast::NodeId),                         // `x` in doc.rs\n+    LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n+    LpDowncast(Rc<LoanPath<'tcx>>, ast::DefId), // `x` downcast to particular enum variant\n+    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem)\n+}\n+\n+impl<'tcx> LoanPath<'tcx> {\n+    fn new(kind: LoanPathKind<'tcx>, ty: ty::Ty<'tcx>) -> LoanPath<'tcx> {\n+        LoanPath { kind: kind, ty: ty }\n     }\n+\n }\n \n #[deriving(PartialEq, Eq, Hash, Show)]\n@@ -312,7 +310,7 @@ pub enum LoanPathElem {\n }\n \n pub fn closure_to_block(closure_id: ast::NodeId,\n-                    tcx: &ty::ctxt) -> ast::NodeId {\n+                        tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n             ast::ExprProc(_, ref block) |\n@@ -327,9 +325,9 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n     }\n }\n \n-impl LoanPath {\n-    pub fn kill_scope(&self, tcx: &ty::ctxt) -> region::CodeExtent {\n-        match *self {\n+impl<'tcx> LoanPath<'tcx> {\n+    pub fn kill_scope(&self, tcx: &ty::ctxt<'tcx>) -> region::CodeExtent {\n+        match self.kind {\n             LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, tcx);\n@@ -340,8 +338,8 @@ impl LoanPath {\n         }\n     }\n \n-    fn has_fork(&self, other: &LoanPath) -> bool {\n-        match (self, other) {\n+    fn has_fork(&self, other: &LoanPath<'tcx>) -> bool {\n+        match (&self.kind, &other.kind) {\n             (&LpExtend(ref base, _, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n                 if id == id2 {\n                     base.has_fork(&**base2)\n@@ -355,74 +353,96 @@ impl LoanPath {\n     }\n \n     fn depth(&self) -> uint {\n-        match *self {\n+        match self.kind {\n             LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n             LpExtend(ref base, _, LpInterior(_)) => base.depth() + 1,\n             _ => 0,\n         }\n     }\n \n-    fn common(&self, other: &LoanPath) -> Option<LoanPath> {\n-        match (self, other) {\n-            (&LpExtend(ref base, a, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n+    fn common(&self, other: &LoanPath<'tcx>) -> Option<LoanPath<'tcx>> {\n+        match (&self.kind, &other.kind) {\n+            (&LpExtend(ref base, a, LpInterior(id)),\n+             &LpExtend(ref base2, _, LpInterior(id2))) => {\n                 if id == id2 {\n+                    assert!(self.ty == other.ty);\n                     base.common(&**base2).map(|x| {\n                         let xd = x.depth();\n                         if base.depth() == xd && base2.depth() == xd {\n-                            LpExtend(Rc::new(x), a, LpInterior(id))\n+                            LoanPath {\n+                                kind: LpExtend(Rc::new(x), a, LpInterior(id)),\n+                                ty: self.ty,\n+                            }\n                         } else {\n                             x\n                         }\n                     })\n                 } else {\n                     base.common(&**base2)\n-                },\n+                }\n+            }\n             (&LpExtend(ref base, _, LpDeref(_)), _) => base.common(other),\n             (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&**other),\n-            (&LpVar(id), &LpVar(id2)) => if id == id2 { Some(LpVar(id)) } else { None },\n-            (&LpUpvar(id), &LpUpvar(id2)) => if id == id2 { Some(LpUpvar(id)) } else { None },\n+            (&LpVar(id), &LpVar(id2)) => {\n+                if id == id2 {\n+                    assert!(self.ty == other.ty);\n+                    Some(LoanPath { kind: LpVar(id), ty: self.ty })\n+                } else {\n+                    None\n+                }\n+            }\n+            (&LpUpvar(id), &LpUpvar(id2)) => {\n+                if id == id2 {\n+                    assert!(self.ty == other.ty);\n+                    Some(LoanPath { kind: LpUpvar(id), ty: self.ty })\n+                } else {\n+                    None\n+                }\n+            }\n             _ => None,\n         }\n     }\n }\n \n-pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n+pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n     //! Computes the `LoanPath` (if any) for a `cmt`.\n     //! Note that this logic is somewhat duplicated in\n     //! the method `compute()` found in `gather_loans::restrictions`,\n     //! which allows it to share common loan path pieces as it\n     //! traverses the CMT.\n \n+    let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n+\n     match cmt.cat {\n         mc::cat_rvalue(..) |\n         mc::cat_static_item => {\n             None\n         }\n \n         mc::cat_local(id) => {\n-            Some(Rc::new(LpVar(id)))\n+            Some(new_lp(LpVar(id)))\n         }\n \n         mc::cat_upvar(mc::Upvar { id, .. }) => {\n-            Some(Rc::new(LpUpvar(id)))\n+            Some(new_lp(LpUpvar(id)))\n         }\n \n         mc::cat_deref(ref cmt_base, _, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n+                new_lp(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n             })\n         }\n \n         mc::cat_interior(ref cmt_base, ik) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                Rc::new(LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n+                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n             })\n         }\n \n         mc::cat_downcast(ref cmt_base, variant_def_id) =>\n             opt_loan_path(cmt_base)\n             .map(|lp| {\n-                Rc::new(LpDowncast(lp, variant_def_id))\n+                new_lp(LpDowncast(lp, variant_def_id))\n             }),\n \n     }\n@@ -492,9 +512,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report_use_of_moved_value(&self,\n                                      use_span: Span,\n                                      use_kind: MovedValueUseKind,\n-                                     lp: &LoanPath,\n+                                     lp: &LoanPath<'tcx>,\n                                      the_move: &move_data::Move,\n-                                     moved_lp: &LoanPath) {\n+                                     moved_lp: &LoanPath<'tcx>) {\n         let verb = match use_kind {\n             MovedInUse => \"use\",\n             MovedInCapture => \"capture\",\n@@ -643,7 +663,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     pub fn report_reassigned_immutable_variable(&self,\n                                                 span: Span,\n-                                                lp: &LoanPath,\n+                                                lp: &LoanPath<'tcx>,\n                                                 assign:\n                                                 &move_data::Assignment) {\n         self.tcx.sess.span_err(\n@@ -874,9 +894,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn append_loan_path_to_string(&self,\n-                                   loan_path: &LoanPath,\n-                                   out: &mut String) {\n-        match *loan_path {\n+                                      loan_path: &LoanPath<'tcx>,\n+                                      out: &mut String) {\n+        match loan_path.kind {\n             LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n             LpVar(id) => {\n                 out.push_str(ty::local_var_name_str(self.tcx, id).get());\n@@ -918,9 +938,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn append_autoderefd_loan_path_to_string(&self,\n-                                              loan_path: &LoanPath,\n-                                              out: &mut String) {\n-        match *loan_path {\n+                                                 loan_path: &LoanPath<'tcx>,\n+                                                 out: &mut String) {\n+        match loan_path.kind {\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // For a path like `(*x).f` or `(*x)[3]`, autoderef\n                 // rules would normally allow users to omit the `*x`.\n@@ -942,7 +962,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn loan_path_to_string(&self, loan_path: &LoanPath) -> String {\n+    pub fn loan_path_to_string(&self, loan_path: &LoanPath<'tcx>) -> String {\n         let mut result = String::new();\n         self.append_loan_path_to_string(loan_path, &mut result);\n         result\n@@ -979,8 +999,8 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Loan {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Loan<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Loan_{}({}, {}, {}-{}, {})\",\n                  self.index,\n                  self.loan_path.repr(tcx),\n@@ -991,19 +1011,19 @@ impl<'tcx> Repr<'tcx> for Loan {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for LoanPath {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        match self {\n-            &LpVar(id) => {\n+impl<'tcx> Repr<'tcx> for LoanPath<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match self.kind {\n+            LpVar(id) => {\n                 format!(\"$({})\", tcx.map.node_to_string(id))\n             }\n \n-            &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n+            LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n                 let s = tcx.map.node_to_string(var_id);\n                 format!(\"$({} captured by id={})\", s, closure_expr_id)\n             }\n \n-            &LpDowncast(ref lp, variant_def_id) => {\n+            LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n                     ty::item_path_str(tcx, variant_def_id)\n                 } else {\n@@ -1012,11 +1032,11 @@ impl<'tcx> Repr<'tcx> for LoanPath {\n                 format!(\"({}->{})\", lp.repr(tcx), variant_str)\n             }\n \n-            &LpExtend(ref lp, _, LpDeref(_)) => {\n+            LpExtend(ref lp, _, LpDeref(_)) => {\n                 format!(\"{}.*\", lp.repr(tcx))\n             }\n \n-            &LpExtend(ref lp, _, LpInterior(ref interior)) => {\n+            LpExtend(ref lp, _, LpInterior(ref interior)) => {\n                 format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n             }\n         }"}, {"sha": "53e5d36836e88ec1998f0cc43c5b6508281b21bc", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=91b88c54c2d2af73bcf23d383b4d5d524d222b14", "patch": "@@ -21,6 +21,8 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use std::uint;\n use middle::borrowck::*;\n+use middle::borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n+use middle::borrowck::LoanPathElem::{LpInterior};\n use middle::cfg;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::BitwiseOperator;\n@@ -34,12 +36,12 @@ use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, NodeSet};\n use util::ppaux::Repr;\n \n-pub struct MoveData {\n+pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `doc.rs`.\n-    pub paths: RefCell<Vec<MovePath>>,\n+    pub paths: RefCell<Vec<MovePath<'tcx>>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<FnvHashMap<Rc<LoanPath>, MovePathIndex>>,\n+    pub path_map: RefCell<FnvHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n     pub moves: RefCell<Vec<Move>>,\n@@ -59,7 +61,7 @@ pub struct MoveData {\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n-    pub move_data: MoveData,\n+    pub move_data: MoveData<'tcx>,\n \n     pub dfcx_moves: MoveDataFlow<'a, 'tcx>,\n \n@@ -103,9 +105,9 @@ impl MoveIndex {\n static InvalidMoveIndex: MoveIndex =\n     MoveIndex(uint::MAX);\n \n-pub struct MovePath {\n+pub struct MovePath<'tcx> {\n     /// Loan path corresponding to this move path\n-    pub loan_path: Rc<LoanPath>,\n+    pub loan_path: Rc<LoanPath<'tcx>>,\n \n     /// Parent pointer, `InvalidMovePathIndex` if root\n     pub parent: MovePathIndex,\n@@ -166,7 +168,7 @@ pub struct AssignDataFlowOperator;\n pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOperator>;\n \n fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n-    match *loan_path {\n+    match loan_path.kind {\n         LpVar(_) | LpUpvar(_) => {\n             true\n         }\n@@ -182,8 +184,8 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n     }\n }\n \n-impl MoveData {\n-    pub fn new() -> MoveData {\n+impl<'tcx> MoveData<'tcx> {\n+    pub fn new() -> MoveData<'tcx> {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n             path_map: RefCell::new(FnvHashMap::new()),\n@@ -194,7 +196,7 @@ impl MoveData {\n         }\n     }\n \n-    pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath> {\n+    pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath<'tcx>> {\n         (*self.paths.borrow())[index.get()].loan_path.clone()\n     }\n \n@@ -237,8 +239,8 @@ impl MoveData {\n     }\n \n     pub fn move_path(&self,\n-                     tcx: &ty::ctxt,\n-                     lp: Rc<LoanPath>) -> MovePathIndex {\n+                     tcx: &ty::ctxt<'tcx>,\n+                     lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         /*!\n          * Returns the existing move path index for `lp`, if any,\n          * and otherwise adds a new index for `lp` and any of its\n@@ -252,7 +254,7 @@ impl MoveData {\n             None => {}\n         }\n \n-        let index = match *lp {\n+        let index = match lp.kind {\n             LpVar(..) | LpUpvar(..) => {\n                 let index = MovePathIndex(self.paths.borrow().len());\n \n@@ -297,19 +299,19 @@ impl MoveData {\n         return index;\n     }\n \n-    fn existing_move_path(&self, lp: &Rc<LoanPath>)\n+    fn existing_move_path(&self, lp: &Rc<LoanPath<'tcx>>)\n                           -> Option<MovePathIndex> {\n         self.path_map.borrow().get(lp).cloned()\n     }\n \n-    fn existing_base_paths(&self, lp: &Rc<LoanPath>)\n+    fn existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>)\n                            -> Vec<MovePathIndex> {\n         let mut result = vec!();\n         self.add_existing_base_paths(lp, &mut result);\n         result\n     }\n \n-    fn add_existing_base_paths(&self, lp: &Rc<LoanPath>,\n+    fn add_existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>,\n                                result: &mut Vec<MovePathIndex>) {\n         /*!\n          * Adds any existing move path indices for `lp` and any base\n@@ -324,7 +326,7 @@ impl MoveData {\n                 });\n             }\n             None => {\n-                match **lp {\n+                match lp.kind {\n                     LpVar(..) | LpUpvar(..) => { }\n                     LpDowncast(ref b, _) |\n                     LpExtend(ref b, _, _) => {\n@@ -337,8 +339,8 @@ impl MoveData {\n     }\n \n     pub fn add_move(&self,\n-                    tcx: &ty::ctxt,\n-                    lp: Rc<LoanPath>,\n+                    tcx: &ty::ctxt<'tcx>,\n+                    lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n         /*!\n@@ -366,8 +368,8 @@ impl MoveData {\n     }\n \n     pub fn add_assignment(&self,\n-                          tcx: &ty::ctxt,\n-                          lp: Rc<LoanPath>,\n+                          tcx: &ty::ctxt<'tcx>,\n+                          lp: Rc<LoanPath<'tcx>>,\n                           assign_id: ast::NodeId,\n                           span: Span,\n                           assignee_id: ast::NodeId,\n@@ -409,7 +411,7 @@ impl MoveData {\n     }\n \n     fn add_gen_kills(&self,\n-                     tcx: &ty::ctxt,\n+                     tcx: &ty::ctxt<'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         /*!\n@@ -436,10 +438,10 @@ impl MoveData {\n         // Kill all moves related to a variable `x` when it goes out\n         // of scope:\n         for path in self.paths.borrow().iter() {\n-            match *path.loan_path {\n+            match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n-                    let path = *self.path_map.borrow().get(&path.loan_path);\n+                    let path = self.path_map.borrow()[path.loan_path];\n                     self.kill_moves(path, kill_scope.node_id(), dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -450,7 +452,7 @@ impl MoveData {\n         for (assignment_index, assignment) in\n                 self.var_assignments.borrow().iter().enumerate() {\n             let lp = self.path_loan_path(assignment.path);\n-            match *lp {\n+            match lp.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(tcx);\n                     dfcx_assign.add_kill(kill_scope.node_id(), assignment_index);\n@@ -531,7 +533,7 @@ impl MoveData {\n }\n \n impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n-    pub fn new(move_data: MoveData,\n+    pub fn new(move_data: MoveData<'tcx>,\n                tcx: &'a ty::ctxt<'tcx>,\n                cfg: &cfg::CFG,\n                id_range: ast_util::IdRange,\n@@ -569,7 +571,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n     pub fn kind_of_move_of_path(&self,\n                                 id: ast::NodeId,\n-                                loan_path: &Rc<LoanPath>)\n+                                loan_path: &Rc<LoanPath<'tcx>>)\n                                 -> Option<MoveKind> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n \n@@ -591,8 +593,8 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n     pub fn each_move_of(&self,\n                         id: ast::NodeId,\n-                        loan_path: &Rc<LoanPath>,\n-                        f: |&Move, &LoanPath| -> bool)\n+                        loan_path: &Rc<LoanPath<'tcx>>,\n+                        f: |&Move, &LoanPath<'tcx>| -> bool)\n                         -> bool {\n         /*!\n          * Iterates through each move of `loan_path` (or some base path\n@@ -651,7 +653,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n     pub fn each_assignment_of(&self,\n                               id: ast::NodeId,\n-                              loan_path: &Rc<LoanPath>,\n+                              loan_path: &Rc<LoanPath<'tcx>>,\n                               f: |&Assignment| -> bool)\n                               -> bool {\n         /*!"}, {"sha": "03167c9ac8a56d331f92457df8bd04b46c2f6bea", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b88c54c2d2af73bcf23d383b4d5d524d222b14/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=91b88c54c2d2af73bcf23d383b4d5d524d222b14", "patch": "@@ -98,7 +98,7 @@ pub enum categorization<'tcx> {\n     cat_local(ast::NodeId),                    // local variable\n     cat_deref(cmt<'tcx>, uint, PointerKind),   // deref of a ptr\n     cat_interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n-    cat_downcast(cmt, ast::DefId),             // selects a particular enum variant (*1)\n+    cat_downcast(cmt<'tcx>, ast::DefId),       // selects a particular enum variant (*1)\n \n     // (*1) downcast is only required if the enum has more than one variant\n }\n@@ -1118,7 +1118,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_pattern(&self,\n                        cmt: cmt<'tcx>,\n                        pat: &ast::Pat,\n-                       op: |&MemCategorizationContext<TYPER>,\n+                       op: |&MemCategorizationContext<'t,TYPER>,\n                             cmt<'tcx>,\n                             &ast::Pat|)\n                        -> McResult<()> {"}]}