{"sha": "340f3fd7a909b30509a63916df06f2b885d113f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MGYzZmQ3YTkwOWIzMDUwOWE2MzkxNmRmMDZmMmI4ODVkMTEzZjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T20:16:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T21:51:50Z"}, "message": "rollup merge of #20410: japaric/assoc-types\n\nConflicts:\n\tsrc/liballoc/lib.rs\n\tsrc/libcollections/lib.rs\n\tsrc/libcollections/slice.rs\n\tsrc/libcore/ops.rs\n\tsrc/libcore/prelude.rs\n\tsrc/libcore/ptr.rs\n\tsrc/librustc/middle/traits/project.rs\n\tsrc/libstd/c_str.rs\n\tsrc/libstd/io/mem.rs\n\tsrc/libstd/io/mod.rs\n\tsrc/libstd/lib.rs\n\tsrc/libstd/path/posix.rs\n\tsrc/libstd/path/windows.rs\n\tsrc/libstd/prelude.rs\n\tsrc/libstd/rt/exclusive.rs\n\tsrc/libsyntax/lib.rs\n\tsrc/test/compile-fail/issue-18566.rs\n\tsrc/test/run-pass/deref-mut-on-ref.rs\n\tsrc/test/run-pass/deref-on-ref.rs\n\tsrc/test/run-pass/dst-deref-mut.rs\n\tsrc/test/run-pass/dst-deref.rs\n\tsrc/test/run-pass/fixup-deref-mut.rs\n\tsrc/test/run-pass/issue-13264.rs\n\tsrc/test/run-pass/overloaded-autoderef-indexing.rs", "tree": {"sha": "344f3d621e187b41d23ef01f621ff68ebe810a03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/344f3d621e187b41d23ef01f621ff68ebe810a03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/340f3fd7a909b30509a63916df06f2b885d113f7", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/340f3fd7a909b30509a63916df06f2b885d113f7", "html_url": "https://github.com/rust-lang/rust/commit/340f3fd7a909b30509a63916df06f2b885d113f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/340f3fd7a909b30509a63916df06f2b885d113f7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cf9929a9a901b68d4624167542924e8b181e96a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf9929a9a901b68d4624167542924e8b181e96a", "html_url": "https://github.com/rust-lang/rust/commit/8cf9929a9a901b68d4624167542924e8b181e96a"}, {"sha": "1abee08cbdbd62a83805aa5b5068df9e00471f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/1abee08cbdbd62a83805aa5b5068df9e00471f06", "html_url": "https://github.com/rust-lang/rust/commit/1abee08cbdbd62a83805aa5b5068df9e00471f06"}], "stats": {"total": 1486, "additions": 898, "deletions": 588}, "files": [{"sha": "59106aa97772a4da6f0697d19092e8abd03c0509", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -247,7 +247,9 @@ impl<T> BorrowFrom<Arc<T>> for T {\n }\n \n #[experimental = \"Deref is experimental.\"]\n-impl<T> Deref<T> for Arc<T> {\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+\n     #[inline]\n     fn deref(&self) -> &T {\n         &self.inner().data"}, {"sha": "e836b08459bb8032a67e0b4033031b44c52ee2f6", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -155,11 +155,13 @@ impl fmt::Show for Box<Any> {\n     }\n }\n \n-impl<Sized? T> Deref<T> for Box<T> {\n+impl<Sized? T> Deref for Box<T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { &**self }\n }\n \n-impl<Sized? T> DerefMut<T> for Box<T> {\n+impl<Sized? T> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n \n@@ -212,7 +214,7 @@ mod test {\n \n     #[test]\n     fn deref() {\n-        fn homura<T: Deref<i32>>(_: T) { }\n+        fn homura<T: Deref<Target=i32>>(_: T) { }\n         homura(box 765i32);\n     }\n }"}, {"sha": "aab513ddeb7b1fc0a1302e12da4c430a34aba9aa", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -66,6 +66,7 @@\n #![no_std]\n #![allow(unknown_features)]\n #![feature(lang_items, phase, unsafe_destructor, default_type_params, old_orphan_check)]\n+#![feature(associated_types)]\n \n #[phase(plugin, link)]\n extern crate core;"}, {"sha": "c57231fc434cd5701d9a01840bdcfacf04d22e60", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -355,7 +355,9 @@ impl<T> BorrowFrom<Rc<T>> for T {\n }\n \n #[experimental = \"Deref is experimental.\"]\n-impl<T> Deref<T> for Rc<T> {\n+impl<T> Deref for Rc<T> {\n+    type Target = T;\n+\n     #[inline(always)]\n     fn deref(&self) -> &T {\n         &self.inner().value"}, {"sha": "da98c19e888fa3e1785eac81aac82e01bf409459", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -518,13 +518,15 @@ mod stack {\n         marker: marker::InvariantLifetime<'id>\n     }\n \n-    impl<'id, T> Deref<T> for IdRef<'id, T> {\n+    impl<'id, T> Deref for IdRef<'id, T> {\n+        type Target = T;\n+\n         fn deref(&self) -> &T {\n             &*self.inner\n         }\n     }\n \n-    impl<'id, T> DerefMut<T> for IdRef<'id, T> {\n+    impl<'id, T> DerefMut for IdRef<'id, T> {\n         fn deref_mut(&mut self) -> &mut T {\n             &mut *self.inner\n         }"}, {"sha": "3dddcae11ce7cb982e63ba583172646b10e5cc60", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -457,7 +457,9 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n ///     flag: &'a Cell<bool>,\n /// }\n ///\n-/// impl<'a> Deref<Node<uint, uint>> for Nasty<'a> {\n+/// impl<'a> Deref for Nasty<'a> {\n+///     type Target = Node<uint, uint>;\n+///\n ///     fn deref(&self) -> &Node<uint, uint> {\n ///         if self.flag.get() {\n ///             &*self.second\n@@ -513,7 +515,7 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Sized? Q, NodeRef: Deref<Node<K, V>>>(node: NodeRef, key: &Q)\n+    pub fn search<Sized? Q, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n                   -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n@@ -590,7 +592,7 @@ impl <K, V> Node<K, V> {\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n     /// Returns a reference to the node that contains the pointed-to edge or key/value pair. This\n     /// is very different from `edge` and `edge_mut` because those return children of the node\n     /// returned by `node`.\n@@ -599,7 +601,9 @@ impl<K, V, NodeRef: Deref<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, Nod\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Converts a handle into one that stores the same information using a raw pointer. This can\n     /// be useful in conjunction with `from_raw` when the type system is insufficient for\n     /// determining the lifetimes of the nodes.\n@@ -655,7 +659,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n+impl<K, V, NodeRef: Deref<Target=Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n     // This doesn't exist because there are no uses for it,\n     // but is fine to add, analagous to edge_mut.\n     //\n@@ -669,7 +673,7 @@ pub enum ForceResult<NodeRef, Type> {\n     Internal(Handle<NodeRef, Type, handle::Internal>)\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafOrInternal> {\n+impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafOrInternal> {\n     /// Figure out whether this handle is pointing to something in a leaf node or to something in\n     /// an internal node, clarifying the type according to the result.\n     pub fn force(self) -> ForceResult<NodeRef, Type> {\n@@ -686,8 +690,9 @@ impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafO\n         }\n     }\n }\n-\n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Leaf> {\n+impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Tries to insert this key-value pair at the given index in this leaf node\n     /// If the node is full, we have to split it.\n     ///\n@@ -719,7 +724,9 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n+impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n     /// confused with `node`, which references the parent node of what is returned here.\n     pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n@@ -802,7 +809,9 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::Edge, NodeType> {\n+impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n     /// This is unsafe because the handle might point to the first edge in the node, which has no\n     /// pair to its left.\n@@ -864,7 +873,7 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n+impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target=Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n                                                                          NodeType> {\n     // These are fine to include, but are currently unneeded.\n     //\n@@ -883,8 +892,9 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef\n     // }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n-                                                                            NodeType> {\n+impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n+    NodeRef: 'a + Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n@@ -900,7 +910,9 @@ impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<Node\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::KV, NodeType> {\n+impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n     /// to by this handle.\n     pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n@@ -920,7 +932,9 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::KV,\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Leaf> {\n+impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+{\n     /// Removes the key/value pair at the handle's location.\n     ///\n     /// # Panics (in debug build)\n@@ -931,7 +945,9 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Le\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Internal> {\n+impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal> where\n+    NodeRef: Deref<Target=Node<K, V>> + DerefMut\n+{\n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n     unsafe fn steal_rightward(&mut self) {"}, {"sha": "fac9ab8107a72fbc5578b7c1e144123660b4766d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -26,6 +26,7 @@\n #![feature(unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![feature(old_orphan_check)]\n+#![feature(associated_types)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;\n@@ -121,7 +122,6 @@ mod prelude {\n     pub use core::result::Result::{Ok, Err};\n \n     // in core and collections (may differ).\n-    pub use slice::{PartialEqSliceExt, OrdSliceExt};\n     pub use slice::{AsSlice, SliceExt};\n     pub use str::{from_str, Str, StrExt};\n \n@@ -130,7 +130,7 @@ mod prelude {\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n-    pub use slice::{CloneSliceExt, SliceConcatExt};\n+    pub use slice::SliceConcatExt;\n     pub use str::IntoMaybeOwned;\n     pub use string::{String, ToString};\n     pub use vec::Vec;"}, {"sha": "1c1b48f8cef678d05dae6d9751564dbadd8b102d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 261, "deletions": 238, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -91,7 +91,7 @@ use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n use core::clone::Clone;\n use core::cmp::Ordering::{mod, Greater, Less};\n-use core::cmp::{mod, Ord};\n+use core::cmp::{mod, Ord, PartialEq};\n use core::iter::{Iterator, IteratorExt, IteratorCloneExt};\n use core::iter::{range, range_step, MultiplicativeIterator};\n use core::kinds::Sized;\n@@ -108,7 +108,7 @@ use self::Direction::*;\n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, Windows};\n-pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n+pub use core::slice::{Iter, IterMut};\n pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n@@ -126,7 +126,9 @@ pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n \n /// Allocating extension methods for slices.\n #[unstable = \"needs associated types, may merge with other traits\"]\n-pub trait SliceExt<T> for Sized? {\n+pub trait SliceExt for Sized? {\n+    type Item;\n+\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -145,7 +147,7 @@ pub trait SliceExt<T> for Sized? {\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n     #[stable]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n     /// from the range [start,end).\n@@ -169,7 +171,7 @@ pub trait SliceExt<T> for Sized? {\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n     #[experimental = \"uncertain about this API approach\"]\n-    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n+    fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n     /// Returns a subslice spanning the interval [`start`, `end`).\n     ///\n@@ -178,23 +180,23 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice(&self, start: uint, end: uint) -> &[T];\n+    fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_from(&self, start: uint) -> &[T];\n+    fn slice_from(&self, start: uint) -> &[Self::Item];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_to(&self, end: uint) -> &[T];\n+    fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n     ///\n@@ -204,32 +206,32 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Panics if `mid > len`.\n     #[stable]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n+    fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice\n     #[stable]\n-    fn iter(&self) -> Iter<T>;\n+    fn iter(&self) -> Iter<Self::Item>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n     #[stable]\n-    fn split<F>(&self, pred: F) -> Split<T, F>\n-                where F: FnMut(&T) -> bool;\n+    fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n+                where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n-                 where F: FnMut(&T) -> bool;\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n+                 where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n-                  where F: FnMut(&T) -> bool;\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n+                  where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over all contiguous windows of length\n     /// `size`. The windows overlap. If the slice is shorter than\n@@ -251,7 +253,7 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn windows(&self, size: uint) -> Windows<T>;\n+    fn windows(&self, size: uint) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n     /// time. The chunks do not overlap. If `size` does not divide the\n@@ -274,41 +276,41 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn chunks(&self, size: uint) -> Chunks<T>;\n+    fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n     #[stable]\n-    fn get(&self, index: uint) -> Option<&T>;\n+    fn get(&self, index: uint) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n     #[stable]\n-    fn first(&self) -> Option<&T>;\n+    fn first(&self) -> Option<&Self::Item>;\n \n     /// Deprecated: renamed to `first`.\n     #[deprecated = \"renamed to `first`\"]\n-    fn head(&self) -> Option<&T> { self.first() }\n+    fn head(&self) -> Option<&Self::Item> { self.first() }\n \n     /// Returns all but the first element of a slice.\n     #[experimental = \"likely to be renamed\"]\n-    fn tail(&self) -> &[T];\n+    fn tail(&self) -> &[Self::Item];\n \n     /// Returns all but the last element of a slice.\n     #[experimental = \"likely to be renamed\"]\n-    fn init(&self) -> &[T];\n+    fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n     #[stable]\n-    fn last(&self) -> Option<&T>;\n+    fn last(&self) -> Option<&Self::Item>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[stable]\n-    unsafe fn get_unchecked(&self, index: uint) -> &T;\n+    unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n \n     /// Deprecated: renamed to `get_unchecked`.\n     #[deprecated = \"renamed to get_unchecked\"]\n-    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+    unsafe fn unsafe_get(&self, index: uint) -> &Self::Item {\n         self.get_unchecked(index)\n     }\n \n@@ -320,7 +322,7 @@ pub trait SliceExt<T> for Sized? {\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[stable]\n-    fn as_ptr(&self) -> *const T;\n+    fn as_ptr(&self) -> *const Self::Item;\n \n     /// Binary search a sorted slice with a comparator function.\n     ///\n@@ -356,7 +358,7 @@ pub trait SliceExt<T> for Sized? {\n     /// ```\n     #[stable]\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n-        F: FnMut(&T) -> Ordering;\n+        F: FnMut(&Self::Item) -> Ordering;\n \n     /// Return the number of elements in the slice\n     ///\n@@ -383,12 +385,12 @@ pub trait SliceExt<T> for Sized? {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     #[stable]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n+    fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n     #[stable]\n-    fn as_mut_slice(&mut self) -> &mut [T];\n+    fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n@@ -397,70 +399,70 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n     #[stable]\n-    fn iter_mut(&mut self) -> IterMut<T>;\n+    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[stable]\n-    fn first_mut(&mut self) -> Option<&mut T>;\n+    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Depreated: renamed to `first_mut`.\n     #[deprecated = \"renamed to first_mut\"]\n-    fn head_mut(&mut self) -> Option<&mut T> {\n+    fn head_mut(&mut self) -> Option<&mut Self::Item> {\n         self.first_mut()\n     }\n \n     /// Returns all but the first element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n-    fn tail_mut(&mut self) -> &mut [T];\n+    fn tail_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns all but the last element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n-    fn init_mut(&mut self) -> &mut [T];\n+    fn init_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable pointer to the last item in the slice.\n     #[stable]\n-    fn last_mut(&mut self) -> Option<&mut T>;\n+    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[stable]\n-    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n-                    where F: FnMut(&T) -> bool;\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n+                    where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n-                     where F: FnMut(&T) -> bool;\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n+                     where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n-                      where F: FnMut(&T) -> bool;\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n+                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n@@ -471,7 +473,7 @@ pub trait SliceExt<T> for Sized? {\n     ///\n     /// Panics if `chunk_size` is 0.\n     #[stable]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T>;\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n     ///\n@@ -529,7 +531,7 @@ pub trait SliceExt<T> for Sized? {\n     /// }\n     /// ```\n     #[stable]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n     ///\n@@ -545,11 +547,11 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an unsafe mutable pointer to the element in index\n     #[stable]\n-    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T;\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n \n     /// Deprecated: renamed to `get_unchecked_mut`.\n     #[deprecated = \"renamed to get_unchecked_mut\"]\n-    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut T {\n+    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut Self::Item {\n         self.get_unchecked_mut(index)\n     }\n \n@@ -562,11 +564,179 @@ pub trait SliceExt<T> for Sized? {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     #[stable]\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n+\n+    /// Copies `self` into a new `Vec`.\n+    #[stable]\n+    fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n+\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    fn partitioned<F>(&self, f: F) -> (Vec<Self::Item>, Vec<Self::Item>) where\n+        Self::Item: Clone,\n+        F: FnMut(&Self::Item) -> bool;\n+\n+    /// Creates an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// for p in perms {\n+    ///   println!(\"{}\", p);\n+    /// }\n+    /// ```\n+    ///\n+    /// Iterating through permutations one by one.\n+    ///\n+    /// ```rust\n+    /// let v = [1i, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n+    /// ```\n+    #[unstable]\n+    fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n+\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n+    ///\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n+    /// ```\n+    #[experimental]\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n+\n+    /// Sorts the slice, in place.\n+    ///\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [-5i, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5i, -3, 1, 2, 4]);\n+    /// ```\n+    #[stable]\n+    fn sort(&mut self) where Self::Item: Ord;\n+\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable]\n+    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+\n+    /// Deprecated: use `binary_search` instead.\n+    #[deprecated = \"use binary_search instead\"]\n+    fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n+        self.binary_search(x)\n+    }\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    /// Find the first index containing a matching value.\n+    #[experimental]\n+    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    /// Find the last index containing a matching value.\n+    #[experimental]\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    /// Return true if the slice contains an element with the given value.\n+    #[stable]\n+    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n+\n+    /// Returns true if `needle` is a prefix of the slice.\n+    #[stable]\n+    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    /// Returns true if `needle` is a suffix of the slice.\n+    #[stable]\n+    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    /// Convert `self` into a vector without clones or allocation.\n+    #[experimental]\n+    fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T> SliceExt<T> for [T] {\n+impl<T> SliceExt for [T] {\n+    type Item = T;\n+\n     #[inline]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n@@ -781,229 +951,82 @@ impl<T> SliceExt<T> for [T] {\n     fn as_mut_ptr(&mut self) -> *mut T {\n         core_slice::SliceExt::as_mut_ptr(self)\n     }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Extension traits for slices over specifc kinds of data\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Extension methods for boxed slices.\n-#[experimental = \"likely to merge into SliceExt if it survives\"]\n-pub trait BoxedSliceExt<T> {\n-    /// Convert `self` into a vector without clones or allocation.\n-    #[experimental]\n-    fn into_vec(self) -> Vec<T>;\n-}\n-\n-#[experimental = \"trait is experimental\"]\n-impl<T> BoxedSliceExt<T> for Box<[T]> {\n-    fn into_vec(mut self) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n-    }\n-}\n-\n-/// Allocating extension methods for slices containing `Clone` elements.\n-#[unstable = \"likely to be merged into SliceExt\"]\n-pub trait CloneSliceExt<T> for Sized? {\n-    /// Copies `self` into a new `Vec`.\n-    #[stable]\n-    fn to_vec(&self) -> Vec<T>;\n-\n-    /// Deprecated: use `iter().cloned().partition(f)` instead.\n-    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n-\n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// for p in perms {\n-    ///   println!(\"{}\", p);\n-    /// }\n-    /// ```\n-    ///\n-    /// Iterating through permutations one by one.\n-    ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n-    /// ```\n-    #[unstable]\n-    fn permutations(&self) -> Permutations<T>;\n-\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n-    ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n-    /// ```\n-    #[experimental]\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> {\n+    fn to_vec(&self) -> Vec<T> where T: Clone {\n         let mut vector = Vec::with_capacity(self.len());\n         vector.push_all(self);\n         vector\n     }\n \n \n     #[inline]\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool, T: Clone {\n         self.iter().cloned().partition(f)\n     }\n \n     /// Returns an iterator over all permutations of a vector.\n-    fn permutations(&self) -> Permutations<T> {\n+    fn permutations(&self) -> Permutations<T> where T: Clone {\n         Permutations{\n             swaps: ElementSwaps::new(self.len()),\n             v: self.to_vec(),\n         }\n     }\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n-        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n+        core_slice::SliceExt::clone_from_slice(self, src)\n     }\n-}\n \n-/// Allocating extension methods for slices on Ord values.\n-#[unstable = \"likely to merge with SliceExt\"]\n-pub trait OrdSliceExt<T> for Sized? {\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n-    /// ```\n-    #[stable]\n-    fn sort(&mut self);\n+    #[inline]\n+    fn sort(&mut self) where T: Ord {\n+        self.sort_by(|a, b| a.cmp(b))\n+    }\n \n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Ok` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search(&13),  Ok(9));\n-    /// assert_eq!(s.binary_search(&4),   Err(7));\n-    /// assert_eq!(s.binary_search(&100), Err(13));\n-    /// let r = s.binary_search(&1);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable]\n-    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n+        core_slice::SliceExt::binary_search(self, x)\n+    }\n \n-    /// Deprecated: use `binary_search` instead.\n-    #[deprecated = \"use binary_search instead\"]\n-    fn binary_search_elem(&self, x: &T) -> Result<uint, uint> {\n-        self.binary_search(x)\n+    fn next_permutation(&mut self) -> bool where T: Ord {\n+        core_slice::SliceExt::next_permutation(self)\n     }\n \n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n-    fn next_permutation(&mut self) -> bool;\n+    fn prev_permutation(&mut self) -> bool where T: Ord {\n+        core_slice::SliceExt::prev_permutation(self)\n+    }\n \n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n-    fn prev_permutation(&mut self) -> bool;\n-}\n+    fn position_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+        core_slice::SliceExt::position_elem(self, t)\n+    }\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: Ord> OrdSliceExt<T> for [T] {\n-    #[inline]\n-    fn sort(&mut self) {\n-        self.sort_by(|a, b| a.cmp(b))\n+    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+        core_slice::SliceExt::rposition_elem(self, t)\n     }\n \n-    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n-        core_slice::OrdSliceExt::binary_search(self, x)\n+    fn contains(&self, x: &T) -> bool where T: PartialEq {\n+        core_slice::SliceExt::contains(self, x)\n     }\n \n-    fn next_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::next_permutation(self)\n+    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::starts_with(self, needle)\n     }\n \n-    fn prev_permutation(&mut self) -> bool {\n-        core_slice::OrdSliceExt::prev_permutation(self)\n+    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::ends_with(self, needle)\n+    }\n+\n+    fn into_vec(mut self: Box<Self>) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n+            mem::forget(self);\n+            xs\n+        }\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Extension traits for slices over specifc kinds of data\n+////////////////////////////////////////////////////////////////////////////////\n #[unstable = \"U should be an associated type\"]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<Sized? T, U> for Sized? {\n@@ -1423,7 +1446,7 @@ mod tests {\n     use std::boxed::Box;\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n     use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n-    use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n+    use prelude::AsSlice;\n     use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n     use core::cell::Cell;\n     use core::default::Default;"}, {"sha": "769679ec4d448e99335814f22fe4d76e0d79dadf", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -29,7 +29,6 @@ use core::raw::Slice as RawSlice;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n-use slice::CloneSliceExt;\n use str::{mod, CharRange, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n@@ -96,7 +95,7 @@ impl String {\n     #[inline]\n     #[experimental = \"needs investigation to see if to_string() can match perf\"]\n     pub fn from_str(string: &str) -> String {\n-        String { vec: string.as_bytes().to_vec() }\n+        String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n     }\n \n     /// Returns the vector as a string buffer, if possible, taking care not to\n@@ -942,7 +941,9 @@ impl ops::Slice<uint, str> for String {\n }\n \n #[experimental = \"waiting on Deref stabilization\"]\n-impl ops::Deref<str> for String {\n+impl ops::Deref for String {\n+    type Target = str;\n+\n     fn deref<'a>(&'a self) -> &'a str {\n         unsafe { mem::transmute(self.vec[]) }\n     }\n@@ -954,7 +955,9 @@ pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n \n-impl<'a> Deref<String> for DerefString<'a> {\n+impl<'a> Deref for DerefString<'a> {\n+    type Target = String;\n+\n     fn deref<'b>(&'b self) -> &'b String {\n         unsafe { mem::transmute(&*self.x) }\n     }"}, {"sha": "7e36792742171166fceba37d7f735f4c4b0bc3e7", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -65,8 +65,6 @@ use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n-use slice::CloneSliceExt;\n-\n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n@@ -1220,7 +1218,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n \n #[unstable]\n impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n+    fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten\n@@ -1305,12 +1303,14 @@ impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n }\n \n #[experimental = \"waiting on Deref stability\"]\n-impl<T> ops::Deref<[T]> for Vec<T> {\n+impl<T> ops::Deref for Vec<T> {\n+    type Target = [T];\n+\n     fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n }\n \n #[experimental = \"waiting on DerefMut stability\"]\n-impl<T> ops::DerefMut<[T]> for Vec<T> {\n+impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n }\n \n@@ -1720,7 +1720,9 @@ pub struct DerefVec<'a, T> {\n }\n \n #[experimental]\n-impl<'a, T> Deref<Vec<T>> for DerefVec<'a, T> {\n+impl<'a, T> Deref for DerefVec<'a, T> {\n+    type Target = Vec<T>;\n+\n     fn deref<'b>(&'b self) -> &'b Vec<T> {\n         &self.x\n     }"}, {"sha": "ba7714ad9bc8cb321b9a1db2eb0d89eac3bf9e61", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -54,7 +54,7 @@ macro_rules! array_impls {\n             #[stable]\n             impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; $N] where\n                 A: PartialEq<B>,\n-                Rhs: Deref<[B]>,\n+                Rhs: Deref<Target=[B]>,\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &Rhs) -> bool { PartialEq::eq(self[], &**other) }\n@@ -65,7 +65,7 @@ macro_rules! array_impls {\n             #[stable]\n             impl<'a, A, B, Lhs> PartialEq<[B; $N]> for Lhs where\n                 A: PartialEq<B>,\n-                Lhs: Deref<[A]>\n+                Lhs: Deref<Target=[A]>\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &[B; $N]) -> bool { PartialEq::eq(&**self, other[]) }"}, {"sha": "7e4d73d598d8d8227bed2325082170b019a34f15", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -191,7 +191,9 @@ impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> Deref<B> for Cow<'a, T, B> where B: ToOwned<T>  {\n+impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n+    type Target = B;\n+\n     fn deref(&self) -> &B {\n         match *self {\n             Borrowed(borrowed) => borrowed,"}, {"sha": "47204dfc422f4eb778d7cd5d13d77dd1b5f3e22e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -424,7 +424,9 @@ pub struct Ref<'b, T:'b> {\n }\n \n #[unstable = \"waiting for `Deref` to become stable\"]\n-impl<'b, T> Deref<T> for Ref<'b, T> {\n+impl<'b, T> Deref for Ref<'b, T> {\n+    type Target = T;\n+\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n         self._value\n@@ -480,15 +482,17 @@ pub struct RefMut<'b, T:'b> {\n }\n \n #[unstable = \"waiting for `Deref` to become stable\"]\n-impl<'b, T> Deref<T> for RefMut<'b, T> {\n+impl<'b, T> Deref for RefMut<'b, T> {\n+    type Target = T;\n+\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n         self._value\n     }\n }\n \n #[unstable = \"waiting for `DerefMut` to become stable\"]\n-impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n+impl<'b, T> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         self._value"}, {"sha": "d7a675b3104ecb4287e520dce800fa2c315d4824", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -1175,7 +1175,7 @@ pub trait IteratorCloneExt<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone, D: Deref<A>, I: Iterator<D>> IteratorCloneExt<A> for I {\n+impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> IteratorCloneExt<A> for I {\n     fn cloned(self) -> Cloned<I> {\n         Cloned { it: self }\n     }\n@@ -1186,7 +1186,7 @@ pub struct Cloned<I> {\n     it: I,\n }\n \n-impl<A: Clone, D: Deref<A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n+impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n     fn next(&mut self) -> Option<A> {\n         self.it.next().cloned()\n     }\n@@ -1196,15 +1196,15 @@ impl<A: Clone, D: Deref<A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n     }\n }\n \n-impl<A: Clone, D: Deref<A>, I: DoubleEndedIterator<D>>\n+impl<A: Clone, D: Deref<Target=A>, I: DoubleEndedIterator<D>>\n         DoubleEndedIterator<A> for Cloned<I> {\n     fn next_back(&mut self) -> Option<A> {\n         self.it.next_back().cloned()\n     }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone, D: Deref<A>, I: ExactSizeIterator<D>> ExactSizeIterator<A> for Cloned<I> {}\n+impl<A: Clone, D: Deref<Target=A>, I: ExactSizeIterator<D>> ExactSizeIterator<A> for Cloned<I> {}\n \n #[unstable = \"recently renamed for extension trait conventions\"]\n /// An extension trait for cloneable iterators."}, {"sha": "ba9103520d8751f5e3e1751f0ce6cdfeec42f553", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -44,7 +44,9 @@ impl<T: Zeroable> NonZero<T> {\n     }\n }\n \n-impl<T: Zeroable> Deref<T> for NonZero<T> {\n+impl<T: Zeroable> Deref for NonZero<T> {\n+    type Target = T;\n+\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n         let NonZero(ref inner) = *self;"}, {"sha": "b51d4d91c2f55d090ee67a2f92fce2146815d187", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -861,13 +861,17 @@ pub struct RangeTo<Idx> {\n /// struct.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Deref;\n ///\n /// struct DerefExample<T> {\n ///     value: T\n /// }\n ///\n-/// impl<T> Deref<T> for DerefExample<T> {\n+/// impl<T> Deref for DerefExample<T> {\n+///     type Target = T;\n+///\n ///     fn deref<'a>(&'a self) -> &'a T {\n ///         &self.value\n ///     }\n@@ -879,16 +883,22 @@ pub struct RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n-pub trait Deref<Sized? Result> for Sized? {\n+pub trait Deref for Sized? {\n+    type Sized? Target;\n+\n     /// The method called to dereference a value\n-    fn deref<'a>(&'a self) -> &'a Result;\n+    fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n-impl<'a, Sized? T> Deref<T> for &'a T {\n+impl<'a, Sized? T> Deref for &'a T {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { *self }\n }\n \n-impl<'a, Sized? T> Deref<T> for &'a mut T {\n+impl<'a, Sized? T> Deref for &'a mut T {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { *self }\n }\n \n@@ -901,19 +911,23 @@ impl<'a, Sized? T> Deref<T> for &'a mut T {\n /// struct.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::{Deref, DerefMut};\n ///\n /// struct DerefMutExample<T> {\n ///     value: T\n /// }\n ///\n-/// impl<T> Deref<T> for DerefMutExample<T> {\n+/// impl<T> Deref for DerefMutExample<T> {\n+///     type Target = T;\n+///\n ///     fn deref<'a>(&'a self) -> &'a T {\n ///         &self.value\n ///     }\n /// }\n ///\n-/// impl<T> DerefMut<T> for DerefMutExample<T> {\n+/// impl<T> DerefMut for DerefMutExample<T> {\n ///     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n ///         &mut self.value\n ///     }\n@@ -926,12 +940,12 @@ impl<'a, Sized? T> Deref<T> for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n-pub trait DerefMut<Sized? Result> for Sized? : Deref<Result> {\n+pub trait DerefMut for Sized? : Deref {\n     /// The method called to mutably dereference a value\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut Result;\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut <Self as Deref>::Target;\n }\n \n-impl<'a, Sized? T> DerefMut<T> for &'a mut T {\n+impl<'a, Sized? T> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n "}, {"sha": "b9749f57d5832edda48e425a4f6d81bcc0d1c81f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -699,7 +699,7 @@ impl<T> Option<T> {\n     }\n }\n \n-impl<'a, T: Clone, D: Deref<T>> Option<D> {\n+impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n     /// Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\n     /// Useful for converting an Option<&T> to an Option<T>.\n     #[unstable = \"recently added as part of collections reform\"]"}, {"sha": "8cb631380095f06b26025d8bc9d47b68c03b1aac", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -49,5 +49,4 @@ pub use option::Option::{mod, Some, None};\n pub use ptr::{PtrExt, MutPtrExt};\n pub use result::Result::{mod, Ok, Err};\n pub use slice::{AsSlice, SliceExt};\n-pub use slice::{PartialEqSliceExt, OrdSliceExt};\n pub use str::{Str, StrExt};"}, {"sha": "f29d75181492b0b31df14ddd5af4d45a197779f6", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -243,7 +243,9 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n \n /// Methods on raw pointers\n #[stable]\n-pub trait PtrExt<T> : Sized {\n+pub trait PtrExt: Sized {\n+    type Target;\n+\n     /// Returns the null pointer.\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> Self;\n@@ -271,7 +273,7 @@ pub trait PtrExt<T> : Sized {\n     /// memory.\n     #[unstable = \"Option is not clearly the right return type, and we may want \\\n                   to tie the return lifetime to a borrow of the raw pointer\"]\n-    unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n+    unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;\n \n     /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.\n@@ -287,7 +289,9 @@ pub trait PtrExt<T> : Sized {\n \n /// Methods on mutable raw pointers\n #[stable]\n-pub trait MutPtrExt<T>{\n+pub trait MutPtrExt {\n+    type Target;\n+\n     /// Returns `None` if the pointer is null, or else returns a mutable\n     /// reference to the value wrapped in `Some`.\n     ///\n@@ -297,11 +301,13 @@ pub trait MutPtrExt<T>{\n     /// of the returned pointer.\n     #[unstable = \"Option is not clearly the right return type, and we may want \\\n                   to tie the return lifetime to a borrow of the raw pointer\"]\n-    unsafe fn as_mut<'a>(&self) -> Option<&'a mut T>;\n+    unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n }\n \n #[stable]\n-impl<T> PtrExt<T> for *const T {\n+impl<T> PtrExt for *const T {\n+    type Target = T;\n+\n     #[inline]\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> *const T { null() }\n@@ -333,7 +339,9 @@ impl<T> PtrExt<T> for *const T {\n }\n \n #[stable]\n-impl<T> PtrExt<T> for *mut T {\n+impl<T> PtrExt for *mut T {\n+    type Target = T;\n+\n     #[inline]\n     #[deprecated = \"call ptr::null instead\"]\n     fn null() -> *mut T { null_mut() }\n@@ -365,7 +373,9 @@ impl<T> PtrExt<T> for *mut T {\n }\n \n #[stable]\n-impl<T> MutPtrExt<T> for *mut T {\n+impl<T> MutPtrExt for *mut T {\n+    type Target = T;\n+\n     #[inline]\n     #[unstable = \"return value does not necessarily convey all possible \\\n                   information\"]"}, {"sha": "07addf7a56969cd75af39cf38ac68b9dd2698384", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 145, "deletions": 174, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -64,57 +64,77 @@ use raw::Slice as RawSlice;\n \n /// Extension methods for slices.\n #[allow(missing_docs)] // docs in libcollections\n-pub trait SliceExt<T> for Sized? {\n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T];\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n-    fn iter<'a>(&'a self) -> Iter<'a, T>;\n-    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P>\n-                    where P: FnMut(&T) -> bool;\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P>\n-                     where P: FnMut(&T) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, T, P>\n-                      where P: FnMut(&T) -> bool;\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T>;\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T>;\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-    fn first<'a>(&'a self) -> Option<&'a T>;\n-    fn tail<'a>(&'a self) -> &'a [T];\n-    fn init<'a>(&'a self) -> &'a [T];\n-    fn last<'a>(&'a self) -> Option<&'a T>;\n-    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T;\n-    fn as_ptr(&self) -> *const T;\n+pub trait SliceExt for Sized? {\n+    type Item;\n+\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [Self::Item];\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [Self::Item];\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n+    fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n+    fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n+                    where P: FnMut(&Self::Item) -> bool;\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, Self::Item, P>\n+                     where P: FnMut(&Self::Item) -> bool;\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, Self::Item, P>\n+                      where P: FnMut(&Self::Item) -> bool;\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, Self::Item>;\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, Self::Item>;\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a Self::Item>;\n+    fn first<'a>(&'a self) -> Option<&'a Self::Item>;\n+    fn tail<'a>(&'a self) -> &'a [Self::Item];\n+    fn init<'a>(&'a self) -> &'a [Self::Item];\n+    fn last<'a>(&'a self) -> Option<&'a Self::Item>;\n+    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a Self::Item;\n+    fn as_ptr(&self) -> *const Self::Item;\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n-        F: FnMut(&T) -> Ordering;\n+        F: FnMut(&Self::Item) -> Ordering;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T];\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n-    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n-    fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n-    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P>\n-                        where P: FnMut(&T) -> bool;\n-    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<T, P>\n-                     where P: FnMut(&T) -> bool;\n-    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<T, P>\n-                      where P: FnMut(&T) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T>;\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [Self::Item];\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [Self::Item];\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [Self::Item];\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n+    fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>\n+                        where P: FnMut(&Self::Item) -> bool;\n+    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<Self::Item, P>\n+                     where P: FnMut(&Self::Item) -> bool;\n+    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<Self::Item, P>\n+                      where P: FnMut(&Self::Item) -> bool;\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, Self::Item>;\n     fn swap(&mut self, a: uint, b: uint);\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [Self::Item], &'a mut [Self::Item]);\n     fn reverse(&mut self);\n-    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n-    fn as_mut_ptr(&mut self) -> *mut T;\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut Self::Item;\n+    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n+\n+    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+\n+    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n+\n+    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n+\n+    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+    fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n+    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n+\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n }\n \n #[unstable]\n-impl<T> SliceExt<T> for [T] {\n+impl<T> SliceExt for [T] {\n+    type Item = T;\n+\n     #[inline]\n     fn slice(&self, start: uint, end: uint) -> &[T] {\n         assert!(start <= end);\n@@ -404,153 +424,41 @@ impl<T> SliceExt<T> for [T] {\n     fn as_mut_ptr(&mut self) -> *mut T {\n         self.repr().data as *mut T\n     }\n-}\n-\n-impl<T> ops::Index<uint, T> for [T] {\n-    fn index(&self, &index: &uint) -> &T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n-    }\n-}\n-\n-impl<T> ops::IndexMut<uint, T> for [T] {\n-    fn index_mut(&mut self, &index: &uint) -> &mut T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n-    }\n-}\n-\n-impl<T> ops::Slice<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.slice_or_fail(start, &self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.slice_or_fail(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-impl<T> ops::SliceMut<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        let len = &self.len();\n-        self.slice_or_fail_mut(start, len)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.slice_or_fail_mut(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-/// Extension methods for slices containing `PartialEq` elements.\n-#[unstable = \"may merge with SliceExt\"]\n-pub trait PartialEqSliceExt<T: PartialEq> for Sized? {\n-    /// Find the first index containing a matching value.\n-    #[experimental]\n-    fn position_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Find the last index containing a matching value.\n-    #[experimental]\n-    fn rposition_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Return true if the slice contains an element with the given value.\n-    #[stable]\n-    fn contains(&self, x: &T) -> bool;\n-\n-    /// Returns true if `needle` is a prefix of the slice.\n-    #[stable]\n-    fn starts_with(&self, needle: &[T]) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the slice.\n-    #[stable]\n-    fn ends_with(&self, needle: &[T]) -> bool;\n-}\n \n-#[unstable = \"trait is unstable\"]\n-impl<T: PartialEq> PartialEqSliceExt<T> for [T] {\n     #[inline]\n-    fn position_elem(&self, x: &T) -> Option<uint> {\n+    fn position_elem(&self, x: &T) -> Option<uint> where T: PartialEq {\n         self.iter().position(|y| *x == *y)\n     }\n \n     #[inline]\n-    fn rposition_elem(&self, t: &T) -> Option<uint> {\n+    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n         self.iter().rposition(|x| *x == *t)\n     }\n \n     #[inline]\n-    fn contains(&self, x: &T) -> bool {\n+    fn contains(&self, x: &T) -> bool where T: PartialEq {\n         self.iter().any(|elt| *x == *elt)\n     }\n \n     #[inline]\n-    fn starts_with(&self, needle: &[T]) -> bool {\n+    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let n = needle.len();\n         self.len() >= n && needle == self[..n]\n     }\n \n     #[inline]\n-    fn ends_with(&self, needle: &[T]) -> bool {\n+    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n         m >= n && needle == self[m-n..]\n     }\n-}\n \n-/// Extension methods for slices containing `Ord` elements.\n-#[unstable = \"may merge with other traits\"]\n-#[allow(missing_docs)] // docs in libcollections\n-pub trait OrdSliceExt<T: Ord> for Sized? {\n-    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n-    fn next_permutation(&mut self) -> bool;\n-    fn prev_permutation(&mut self) -> bool;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[unstable]\n-    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n     #[experimental]\n-    fn next_permutation(&mut self) -> bool {\n+    fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n \n@@ -581,7 +489,7 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n     }\n \n     #[experimental]\n-    fn prev_permutation(&mut self) -> bool {\n+    fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n \n@@ -610,19 +518,9 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n \n         true\n     }\n-}\n \n-/// Extension methods for slices on Clone elements\n-#[unstable = \"may merge with other traits\"]\n-#[allow(missing_docs)] // docs in libcollections\n-pub trait CloneSliceExt<T> for Sized? {\n-    fn clone_from_slice(&mut self, &[T]) -> uint;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T: Clone> CloneSliceExt<T> for [T] {\n     #[inline]\n-    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n         let dst = self.slice_to_mut(min);\n         let src = src.slice_to(min);\n@@ -633,6 +531,79 @@ impl<T: Clone> CloneSliceExt<T> for [T] {\n     }\n }\n \n+impl<T> ops::Index<uint, T> for [T] {\n+    fn index(&self, &index: &uint) -> &T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n+impl<T> ops::IndexMut<uint, T> for [T] {\n+    fn index_mut(&mut self, &index: &uint) -> &mut T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n+impl<T> ops::Slice<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.slice_or_fail(start, &self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.slice_or_fail(&0, end)\n+    }\n+    #[inline]\n+    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        let len = &self.len();\n+        self.slice_or_fail_mut(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.slice_or_fail_mut(&0, end)\n+    }\n+    #[inline]\n+    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Common traits\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "d7f570df07278b3ba3f3d85917644a4d095eeed4", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -21,8 +21,10 @@ use super::VtableImplData;\n \n use middle::infer;\n use middle::subst::Subst;\n-use middle::ty::{mod, AsPredicate, RegionEscape, HasProjectionTypes, ToPolyTraitRef, Ty};\n+use middle::ty::{mod, AsPredicate, ReferencesError, RegionEscape,\n+                 HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n+use std::rc::Rc;\n use util::ppaux::Repr;\n \n pub type PolyProjectionObligation<'tcx> =\n@@ -372,17 +374,28 @@ fn project_type<'cx,'tcx>(\n         return Err(ProjectionTyError::TraitSelectionError(Overflow));\n     }\n \n+    let obligation_trait_ref =\n+        selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n+\n+    debug!(\"project: obligation_trait_ref={}\", obligation_trait_ref.repr(selcx.tcx()));\n+\n+    if obligation_trait_ref.references_error() {\n+        return Ok(ProjectedTy::Progress(selcx.tcx().types.err, vec!()));\n+    }\n+\n     let mut candidates = ProjectionTyCandidateSet {\n         vec: Vec::new(),\n         ambiguous: false,\n     };\n \n     assemble_candidates_from_param_env(selcx,\n                                        obligation,\n+                                       &obligation_trait_ref,\n                                        &mut candidates);\n \n     if let Err(e) = assemble_candidates_from_impls(selcx,\n                                                    obligation,\n+                                                   &obligation_trait_ref,\n                                                    &mut candidates) {\n         return Err(ProjectionTyError::TraitSelectionError(e));\n     }\n@@ -415,17 +428,20 @@ fn project_type<'cx,'tcx>(\n /// there that can answer this question.\n fn assemble_candidates_from_param_env<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     let env_predicates = selcx.param_env().caller_bounds.predicates.clone();\n     let env_predicates = env_predicates.iter().cloned().collect();\n-    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates);\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, env_predicates);\n }\n \n fn assemble_candidates_from_predicates<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     env_predicates: Vec<ty::Predicate<'tcx>>)\n {\n@@ -439,7 +455,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n                 let is_match = infcx.probe(|_| {\n                     let origin = infer::Misc(obligation.cause.span);\n                     let obligation_poly_trait_ref =\n-                        obligation.predicate.trait_ref.to_poly_trait_ref();\n+                        obligation_trait_ref.to_poly_trait_ref();\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n@@ -461,6 +477,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     object_ty: Ty<'tcx>)\n {\n@@ -480,21 +497,21 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     let env_predicates = projection_bounds.iter()\n                                           .map(|p| p.as_predicate())\n                                           .collect();\n-    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates)\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, env_predicates)\n }\n \n fn assemble_candidates_from_impls<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n     -> Result<(), SelectionError<'tcx>>\n {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n-    let trait_ref =\n-        obligation.predicate.trait_ref.to_poly_trait_ref();\n-    let trait_obligation =\n-        obligation.with(trait_ref.to_poly_trait_predicate());\n+    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n     let vtable = match selcx.select(&trait_obligation) {\n         Ok(Some(vtable)) => vtable,\n         Ok(None) => {\n@@ -515,7 +532,8 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n         }\n         super::VtableObject(data) => {\n             assemble_candidates_from_object_type(\n-                selcx, obligation, candidate_set, data.object_ty);\n+                selcx, obligation, obligation_trait_ref, candidate_set,\n+                data.object_ty);\n         }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an"}, {"sha": "d09f2a250b0339bb88582569898793ef8e8c3958", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -293,6 +293,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n+                                                stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                                mut predicates: I)\n+                                                -> EvaluationResult<'tcx>\n+        where I : Iterator<&'a PredicateObligation<'tcx>>, 'tcx:'a\n+    {\n+        let mut result = EvaluatedToOk;\n+        for obligation in predicates {\n+            match self.evaluate_predicate_recursively(stack, obligation) {\n+                EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n+                EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n+                EvaluatedToOk => { }\n+            }\n+        }\n+        result\n+    }\n+\n     fn evaluate_predicate_recursively<'o>(&mut self,\n                                           previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n                                           obligation: &PredicateObligation<'tcx>)\n@@ -324,9 +341,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 EvaluatedToOk\n             }\n \n-            ty::Predicate::Projection(..) => {\n-                // FIXME(#20296) -- we should be able to give a more precise answer here\n-                EvaluatedToAmbig\n+            ty::Predicate::Projection(ref data) => {\n+                self.infcx.probe(|_| {\n+                    let project_obligation = obligation.with(data.clone());\n+                    match project::poly_project_and_unify_type(self, &project_obligation) {\n+                        Ok(Some(subobligations)) => {\n+                            self.evaluate_predicates_recursively(previous_stack,\n+                                                                 subobligations.iter())\n+                        }\n+                        Ok(None) => {\n+                            EvaluatedToAmbig\n+                        }\n+                        Err(_) => {\n+                            EvaluatedToErr(Unimplemented)\n+                        }\n+                    }\n+                })\n             }\n         }\n     }\n@@ -1087,15 +1117,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             selection: Selection<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n-        let mut result = EvaluatedToOk;\n-        for obligation in selection.iter_nested() {\n-            match self.evaluate_predicate_recursively(stack, obligation) {\n-                EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n-                EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n-                EvaluatedToOk => { }\n-            }\n-        }\n-        result\n+        self.evaluate_predicates_recursively(stack, selection.iter_nested())\n     }\n \n     /// Returns true if `candidate_i` should be dropped in favor of `candidate_j`."}, {"sha": "999bc23c27049c486bae9299948e39491549ce76", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -7265,7 +7265,7 @@ impl<T:ReferencesError> ReferencesError for Binder<T> {\n \n impl<T:ReferencesError> ReferencesError for Rc<T> {\n     fn references_error(&self) -> bool {\n-        (&*self).references_error()\n+        (&**self).references_error()\n     }\n }\n "}, {"sha": "aa3ac83c0275f44dbe3c38b62a72de789894343a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -96,13 +96,15 @@ struct GraphBuilder<'a, 'b:'a, 'tcx:'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>\n }\n \n-impl<'a, 'b:'a, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for GraphBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'b:'a, 'tcx:'b> Deref for GraphBuilder<'a, 'b, 'tcx> {\n+    type Target = Resolver<'b, 'tcx>;\n+\n     fn deref(&self) -> &Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b:'a, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for GraphBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'b:'a, 'tcx:'b> DerefMut for GraphBuilder<'a, 'b, 'tcx> {\n     fn deref_mut(&mut self) -> &mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }"}, {"sha": "1bfe4c0407afbb03222caf20c9fd5ff7e9d8a008", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -35,13 +35,15 @@ struct UnusedImportCheckVisitor<'a, 'b:'a, 'tcx:'b> {\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n-impl<'a, 'b, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx:'b> Deref for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+    type Target = Resolver<'b, 'tcx>;\n+\n     fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx:'b> DerefMut for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }"}, {"sha": "4ac9224969ca280214b95e650d63799c784dc3d6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -18,6 +18,7 @@\n \n #![feature(globs, phase, slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(associated_types)]\n \n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;"}, {"sha": "ff415750d648179f6c8b47e574d2f73c2091a2e5", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -35,13 +35,15 @@ struct ExportRecorder<'a, 'b:'a, 'tcx:'b> {\n }\n \n // Deref and DerefMut impls allow treating ExportRecorder as Resolver.\n-impl<'a, 'b, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for ExportRecorder<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx:'b> Deref for ExportRecorder<'a, 'b, 'tcx> {\n+    type Target = Resolver<'b, 'tcx>;\n+\n     fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for ExportRecorder<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx:'b> DerefMut for ExportRecorder<'a, 'b, 'tcx> {\n     fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }"}, {"sha": "0cfc1042ae605eb7522aae14473cdbc233027543", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -1812,6 +1812,18 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n+fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n+              typ: &clean::TyParam) -> fmt::Result {\n+    try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n+    if typ.bounds.len() > 0 {\n+        try!(write!(w, \": {}\", TyParamBounds(&*typ.bounds)))\n+    }\n+    if let Some(ref default) = typ.default {\n+        try!(write!(w, \" = {}\", default));\n+    }\n+    Ok(())\n+}\n+\n fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter, it: &clean::Item, unsafety: ast::Unsafety,\n            g: &clean::Generics, selfty: &clean::SelfTy,\n@@ -1828,17 +1840,6 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n                decl = Method(selfty, d),\n                where_clause = WhereClause(g))\n     }\n-    fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n-                  typ: &clean::TyParam) -> fmt::Result {\n-        try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n-        if typ.bounds.len() > 0 {\n-            try!(write!(w, \": {}\", TyParamBounds(&*typ.bounds)))\n-        }\n-        if let Some(ref default) = typ.default {\n-            try!(write!(w, \" = {}\", default));\n-        }\n-        Ok(())\n-    }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n             method(w, meth, m.unsafety, &m.generics, &m.self_, &m.decl)\n@@ -2123,6 +2124,15 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n+            clean::AssociatedTypeItem(ref typaram) => {\n+                let name = item.name.as_ref().unwrap();\n+                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'>{}<code>\",\n+                            *name,\n+                            shortty(item),\n+                            ConciseStability(&item.stability)));\n+                try!(assoc_type(w, item, typaram));\n+                try!(write!(w, \"</code></h4>\\n\"));\n+            }\n             _ => panic!(\"can't make docs for trait item with name {}\", item.name)\n         }\n         match item.doc_value() {"}, {"sha": "b1433ad7fdc625d249da00d8e076177b9153c576", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -549,8 +549,8 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use prelude::v1::*;\n+    use super::*;\n     use ptr;\n     use thread::Thread;\n     use libc;"}, {"sha": "d4fc4150fae9143877fa8e772875fb9e976215f9", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -311,7 +311,7 @@ fn search_hashed<K, V, M, F>(table: M,\n                              hash: SafeHash,\n                              mut is_match: F)\n                              -> SearchResult<K, V, M> where\n-    M: Deref<RawTable<K, V>>,\n+    M: Deref<Target=RawTable<K, V>>,\n     F: FnMut(&K) -> bool,\n {\n     let size = table.size();"}, {"sha": "a687ba3da8d7fc648936c4203aa8819413415867", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -210,7 +210,7 @@ impl<K, V, M> Bucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<RawTable<K, V>>> Bucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as uint)\n     }\n@@ -279,7 +279,7 @@ impl<K, V, M: Deref<RawTable<K, V>>> Bucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<RawTable<K, V>>> EmptyBucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>>> EmptyBucket<K, V, M> {\n     #[inline]\n     pub fn next(self) -> Bucket<K, V, M> {\n         let mut bucket = self.into_bucket();\n@@ -315,7 +315,7 @@ impl<K, V, M: Deref<RawTable<K, V>>> EmptyBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: DerefMut<RawTable<K, V>>> EmptyBucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> EmptyBucket<K, V, M> {\n     /// Puts given key and value pair, along with the key's hash,\n     /// into this bucket in the hashtable. Note how `self` is 'moved' into\n     /// this function, because this slot will no longer be empty when\n@@ -337,7 +337,7 @@ impl<K, V, M: DerefMut<RawTable<K, V>>> EmptyBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<RawTable<K, V>>> FullBucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n     #[inline]\n     pub fn next(self) -> Bucket<K, V, M> {\n         let mut bucket = self.into_bucket();\n@@ -384,7 +384,7 @@ impl<K, V, M: Deref<RawTable<K, V>>> FullBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: DerefMut<RawTable<K, V>>> FullBucket<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> FullBucket<K, V, M> {\n     /// Removes this bucket's key and value from the hashtable.\n     ///\n     /// This works similarly to `put`, building an `EmptyBucket` out of the\n@@ -428,7 +428,7 @@ impl<K, V, M: DerefMut<RawTable<K, V>>> FullBucket<K, V, M> {\n     }\n }\n \n-impl<'t, K, V, M: Deref<RawTable<K, V>> + 't> FullBucket<K, V, M> {\n+impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + 't> FullBucket<K, V, M> {\n     /// Exchange a bucket state for immutable references into the table.\n     /// Because the underlying reference to the table is also consumed,\n     /// no further changes to the structure of the table are possible;\n@@ -442,7 +442,7 @@ impl<'t, K, V, M: Deref<RawTable<K, V>> + 't> FullBucket<K, V, M> {\n     }\n }\n \n-impl<'t, K, V, M: DerefMut<RawTable<K, V>> + 't> FullBucket<K, V, M> {\n+impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + DerefMut + 't> FullBucket<K, V, M> {\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n@@ -463,7 +463,7 @@ impl<K, V, M> BucketState<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<RawTable<K, V>>> GapThenFull<K, V, M> {\n+impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n     #[inline]\n     pub fn full(&self) -> &FullBucket<K, V, M> {\n         &self.full"}, {"sha": "f47f6237b72910e46568e246a5c8a2175b729d07", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -14,7 +14,7 @@ use sync::mpsc::{Sender, Receiver};\n use io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-use slice::{bytes, CloneSliceExt, SliceExt};\n+use slice::{bytes, SliceExt};\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n "}, {"sha": "ad921e43c0cc58b4be584052b2ad1a5303a14803", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -402,8 +402,8 @@ mod test {\n     use prelude::v1::*;\n \n     use super::*;\n-    use io;\n     use io::{SeekSet, SeekCur, SeekEnd};\n+    use io;\n     use self::test_crate::Bencher;\n \n     #[test]"}, {"sha": "0a7815aeb53671ccbaf7878012f51a1a2bf408ce", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -1941,8 +1941,8 @@ impl fmt::Show for FilePermission {\n #[cfg(test)]\n mod tests {\n     use self::BadReaderBehavior::*;\n-    use super::{IoResult, MemReader, NoProgress, InvalidInput};\n-    use prelude::v1::*;\n+    use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n+    use prelude::v1::{Ok, Vec, Buffer, SliceExt};\n     use uint;\n \n     #[deriving(Clone, PartialEq, Show)]"}, {"sha": "2a18b839778c6b21716a2fcb8d2225d7a27bb875", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -25,7 +25,7 @@ use ops::FnOnce;\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-use slice::{CloneSliceExt, SliceExt};\n+use slice::SliceExt;\n use str::{FromStr, StrExt};\n use vec::Vec;\n "}, {"sha": "cd991c5f884f5ef77be1ab416cb5619665e4ae2b", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -117,13 +117,15 @@ pub struct StdinReaderGuard<'a> {\n     inner: MutexGuard<'a, RaceBox>,\n }\n \n-impl<'a> Deref<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n+impl<'a> Deref for StdinReaderGuard<'a> {\n+    type Target = BufferedReader<StdReader>;\n+\n     fn deref(&self) -> &BufferedReader<StdReader> {\n         &self.inner.0\n     }\n }\n \n-impl<'a> DerefMut<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n+impl<'a> DerefMut for StdinReaderGuard<'a> {\n     fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> {\n         &mut self.inner.0\n     }"}, {"sha": "7c8aab2b31dae9ae8d15895181b43381d4aaff23", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -108,6 +108,7 @@\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(old_orphan_check)]\n+#![feature(associated_types)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "63fd3209cc0193b619f811373be8f97886f57781", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -317,9 +317,8 @@ macro_rules! try {\n #[macro_export]\n macro_rules! vec {\n     ($($x:expr),*) => ({\n-        use std::slice::BoxedSliceExt;\n         let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n-        xs.into_vec()\n+        ::std::slice::SliceExt::into_vec(xs)\n     });\n     ($($x:expr,)*) => (vec![$($x),*])\n }"}, {"sha": "6c64251091a31d945ef7862928b433648bf7502c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -20,7 +20,7 @@ use char::{mod, Char};\n use num::{mod, Int, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnMut;\n-use slice::{SliceExt, CloneSliceExt};\n+use slice::SliceExt;\n use str::StrExt;\n use string::String;\n use vec::Vec;"}, {"sha": "615a20baf893ce34e239fef8712d7a0f39c77e25", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -52,7 +52,6 @@ use ptr;\n use result::Result;\n use result::Result::{Err, Ok};\n use slice::{AsSlice, SliceExt};\n-use slice::CloneSliceExt;\n use str::{Str, StrExt};\n use string::{String, ToString};\n use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, SeqCst};"}, {"sha": "731c3bbe427d5836d0a9134e65715bbe0a956fde", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -71,8 +71,7 @@ use option::Option::{None, Some};\n use str;\n use str::{CowString, MaybeOwned, Str, StrExt};\n use string::String;\n-use slice::{AsSlice, CloneSliceExt};\n-use slice::{PartialEqSliceExt, SliceExt};\n+use slice::{AsSlice, SliceExt};\n use vec::Vec;\n \n /// Typedef for POSIX file paths."}, {"sha": "6075010f3b5ffdb95f0b9c806fb3adef6cc2b229", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -22,8 +22,7 @@ use option::Option::{None, Some};\n use kinds::Sized;\n use str::{FromStr, Str};\n use str;\n-use slice::{CloneSliceExt, Split, AsSlice, SliceConcatExt,\n-            PartialEqSliceExt, SliceExt};\n+use slice::{Split, AsSlice, SliceConcatExt, SliceExt};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -453,7 +452,7 @@ mod tests {\n     use iter::{IteratorExt, DoubleEndedIteratorExt};\n     use option::Option::{mod, Some, None};\n     use path::GenericPath;\n-    use slice::{AsSlice, SliceExt, CloneSliceExt};\n+    use slice::{AsSlice, SliceExt};\n     use str::{mod, Str, StrExt};\n     use string::ToString;\n     use vec::Vec;"}, {"sha": "55086ad3a23f98d5bb7143af8b3a479e770a7500", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -1127,7 +1127,7 @@ mod tests {\n     use iter::{IteratorExt, DoubleEndedIteratorExt};\n     use option::Option::{mod, Some, None};\n     use path::GenericPath;\n-    use slice::{AsSlice, SliceExt, CloneSliceExt};\n+    use slice::{AsSlice, SliceExt};\n     use str::Str;\n     use string::ToString;\n     use vec::Vec;"}, {"sha": "cb5dfafb4a12380dbfb24f047d091811c11f2894", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -36,9 +36,7 @@\n #[stable] #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n #[stable] #[doc(no_inline)] pub use result::Result::{mod, Ok, Err};\n #[stable] #[doc(no_inline)] pub use slice::AsSlice;\n-#[stable] #[doc(no_inline)] pub use slice::{BoxedSliceExt, SliceExt};\n-#[stable] #[doc(no_inline)] pub use slice::{CloneSliceExt, OrdSliceExt};\n-#[stable] #[doc(no_inline)] pub use slice::{PartialEqSliceExt, SliceConcatExt};\n+#[stable] #[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt};\n #[stable] #[doc(no_inline)] pub use str::{Str, StrExt};\n #[stable] #[doc(no_inline)] pub use string::{String, ToString};\n #[stable] #[doc(no_inline)] pub use vec::Vec;"}, {"sha": "f9f9a809221713a86fd821e3079b3ef958e728fd", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -291,12 +291,14 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n     }\n }\n \n-impl<'mutex, T> Deref<T> for MutexGuard<'mutex, T> {\n+impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n+    type Target = T;\n+\n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n-impl<'mutex, T> DerefMut<T> for MutexGuard<'mutex, T> {\n+impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }"}, {"sha": "431aeb9cae9f8ab222846a59ed31fcce8102f07b", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -327,13 +327,17 @@ impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-impl<'rwlock, T> Deref<T> for RWLockReadGuard<'rwlock, T> {\n+impl<'rwlock, T> Deref for RWLockReadGuard<'rwlock, T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-impl<'rwlock, T> Deref<T> for RWLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T> Deref for RWLockWriteGuard<'rwlock, T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-impl<'rwlock, T> DerefMut<T> for RWLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T> DerefMut for RWLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }"}, {"sha": "18cdb3fc6478949180903e8481d04506c0f1a269", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -27,6 +27,7 @@\n #![feature(quote, unsafe_destructor)]\n #![feature(unboxed_closures)]\n #![feature(old_orphan_check)]\n+#![feature(associated_types)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "bc2e09231159aea3b1ad396278530fad6ab67655", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -56,7 +56,9 @@ impl<T> OwnedSlice<T> {\n     }\n }\n \n-impl<T> Deref<[T]> for OwnedSlice<T> {\n+impl<T> Deref for OwnedSlice<T> {\n+    type Target = [T];\n+\n     fn deref(&self) -> &[T] {\n         self.as_slice()\n     }"}, {"sha": "2745b7e13e9bb47acd69148ca03916442a281e62", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -608,7 +608,9 @@ impl InternedString {\n     }\n }\n \n-impl Deref<str> for InternedString {\n+impl Deref for InternedString {\n+    type Target = str;\n+\n     fn deref(&self) -> &str { &*self.string }\n }\n "}, {"sha": "a989b32372390be2e9f7026559beea2572e87fb5", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -77,7 +77,9 @@ impl<T: 'static> P<T> {\n     }\n }\n \n-impl<T> Deref<T> for P<T> {\n+impl<T> Deref for P<T> {\n+    type Target = T;\n+\n     fn deref<'a>(&'a self) -> &'a T {\n         &*self.ptr\n     }"}, {"sha": "6e087778de9cdf0031e8db960802aea614394a4c", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -126,7 +126,9 @@ impl BorrowFrom<RcStr> for str {\n     }\n }\n \n-impl Deref<str> for RcStr {\n+impl Deref for RcStr {\n+    type Target = str;\n+\n     fn deref(&self) -> &str { self.string[] }\n }\n "}, {"sha": "34beb53bd07cc7391d8272706deffbd01c76ae42", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -1,3 +1,12 @@\n+S 2015-01-01 7d4f487\n+  freebsd-x86_64 5dc87adb17bc33abc08f1bf4c092e0b5b92a6ca4\n+  linux-i386 63bf82a5b540d8acbbf1e445ce48be0fa0f003fc\n+  linux-x86_64 b1a414355ef5d2feff18ab9d008a2e9afc7b4625\n+  macos-i386 26042e3e648eb40848bf02f3e05ba31fd686179c\n+  macos-x86_64 f01d7c6faf5db480a18a521c6971364f4ce8ddca\n+  winnt-i386 6f04af045d26a0c87d487ba7254d4ad0c166ecaf\n+  winnt-x86_64 392ab49482ec926de6a167afe920518b9a502a3f\n+\n S 2014-12-30 023dfb0\n   freebsd-x86_64 41ecd0ac557c823831c46696c7d78dc250398f25\n   linux-i386 fe6b59bf70a397e18629cb82264f7c6a70df34d4"}, {"sha": "05960a5b8e1dd6196a51f865972be9c745200433", "filename": "src/test/auxiliary/overloaded_autoderef_xc.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct DerefWithHelper<H, T> {\n@@ -24,7 +26,9 @@ impl<T> Helper<T> for Option<T> {\n     }\n }\n \n-impl<T, H: Helper<T>> Deref<T> for DerefWithHelper<H, T> {\n+impl<T, H: Helper<T>> Deref for DerefWithHelper<H, T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T {\n         self.helper.helper_borrow()\n     }"}, {"sha": "5743216b6ca69e1ae98e757597f9dc3825a46b75", "filename": "src/test/compile-fail/associated-types-ICE-when-projecting-out-of-err.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not ICE when the self type is `ty::err`, but rather\n+// just propagate the error.\n+\n+#![crate_type = \"lib\"]\n+#![feature(associated_types, default_type_params, lang_items)]\n+#![no_std]\n+\n+#[lang=\"sized\"]\n+pub trait Sized for Sized? {\n+    // Empty.\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS=Self> {\n+    type Output;\n+\n+    fn add(self, RHS) -> Self::Output;\n+}\n+\n+fn ice<A>(a: A) {\n+    let r = loop {};\n+    r = r + a; // here the type `r` is not yet inferred, hence `r+a` generates an error.\n+    //~^ ERROR type of this value must be known\n+}"}, {"sha": "7cd170f7773e9ced96363f891023624a3e35b265", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref-mut.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -11,19 +11,23 @@\n // Test how overloaded deref interacts with borrows when DerefMut\n // is implemented.\n \n+#![feature(associated_types)]\n+\n use std::ops::{Deref, DerefMut};\n \n struct Own<T> {\n     value: *mut T\n }\n \n-impl<T> Deref<T> for Own<T> {\n+impl<T> Deref for Own<T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T {\n         unsafe { &*self.value }\n     }\n }\n \n-impl<T> DerefMut<T> for Own<T> {\n+impl<T> DerefMut for Own<T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.value }\n     }"}, {"sha": "759467aeda36e53e32a9780cef0f6c938cf3df0e", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -11,13 +11,17 @@\n // Test how overloaded deref interacts with borrows when only\n // Deref and not DerefMut is implemented.\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct Rc<T> {\n     value: *const T\n }\n \n-impl<T> Deref<T> for Rc<T> {\n+impl<T> Deref for Rc<T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T {\n         unsafe { &*self.value }\n     }"}, {"sha": "74dceab18ea48b2c8d179c7482578d70d7d07383", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-deref-mut.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -11,19 +11,23 @@\n // Test how overloaded deref interacts with borrows when DerefMut\n // is implemented.\n \n+#![feature(associated_types)]\n+\n use std::ops::{Deref, DerefMut};\n \n struct Own<T> {\n     value: *mut T\n }\n \n-impl<T> Deref<T> for Own<T> {\n+impl<T> Deref for Own<T> {\n+    type Target = T;\n+\n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.value }\n     }\n }\n \n-impl<T> DerefMut<T> for Own<T> {\n+impl<T> DerefMut for Own<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.value }\n     }"}, {"sha": "635e440c6fe120b1532a509ef1562fcbfee85449", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-deref.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -11,13 +11,17 @@\n // Test how overloaded deref interacts with borrows when only\n // Deref and not DerefMut is implemented.\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct Rc<T> {\n     value: *const T\n }\n \n-impl<T> Deref<T> for Rc<T> {\n+impl<T> Deref for Rc<T> {\n+    type Target = T;\n+\n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.value }\n     }"}, {"sha": "ab770c099e125a04e2798f241f4522f1d4d0b519", "filename": "src/test/compile-fail/infinite-autoderef.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -10,11 +10,15 @@\n \n // error-pattern: reached the recursion limit while auto-dereferencing\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct Foo;\n \n-impl Deref<Foo> for Foo {\n+impl Deref for Foo {\n+    type Target = Foo;\n+\n     fn deref(&self) -> &Foo {\n         self\n     }"}, {"sha": "491707a9e3104706411a5e21b13c28a05b62c9a2", "filename": "src/test/compile-fail/issue-18566.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fissue-18566.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Fcompile-fail%2Fissue-18566.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18566.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,10 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct MyPtr<'a>(&'a mut uint);\n-impl<'a> Deref<uint> for MyPtr<'a> {\n+impl<'a> Deref for MyPtr<'a> {\n+    type Target = uint;\n+\n     fn deref<'b>(&'b self) -> &'b uint { self.0 }\n }\n "}, {"sha": "3b53203d218e047bb746e24d8764fd89c0a98e3d", "filename": "src/test/run-pass/associated-types-conditional-dispatch.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we evaluate projection predicates to winnow out\n+// candidates during trait selection and method resolution (#20296).\n+// If we don't properly winnow out candidates based on the output type\n+// `Target=[A]`, then the impl marked with `(*)` is seen to conflict\n+// with all the others.\n+\n+#![feature(associated_types, default_type_params)]\n+\n+use std::ops::Deref;\n+\n+pub trait MyEq<Sized? U=Self> for Sized? {\n+    fn eq(&self, u: &U) -> bool;\n+}\n+\n+impl<A, B> MyEq<[B]> for [A]\n+    where A : MyEq<B>\n+{\n+    fn eq(&self, other: &[B]) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other.iter())\n+                       .all(|(a, b)| MyEq::eq(a, b))\n+    }\n+}\n+\n+// (*) This impl conflicts with everything unless the `Target=[A]`\n+// constraint is considered.\n+impl<'a, A, B, Lhs> MyEq<[B; 0]> for Lhs\n+    where A: MyEq<B>, Lhs: Deref<Target=[A]>\n+{\n+    fn eq(&self, other: &[B; 0]) -> bool {\n+        MyEq::eq(&**self, other.as_slice())\n+    }\n+}\n+\n+struct DerefWithHelper<H, T> {\n+    pub helper: H\n+}\n+\n+trait Helper<T> {\n+    fn helper_borrow(&self) -> &T;\n+}\n+\n+impl<T> Helper<T> for Option<T> {\n+    fn helper_borrow(&self) -> &T {\n+        self.as_ref().unwrap()\n+    }\n+}\n+\n+impl<T, H: Helper<T>> Deref for DerefWithHelper<H, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        self.helper.helper_borrow()\n+    }\n+}\n+\n+pub fn check<T: MyEq>(x: T, y: T) -> bool {\n+    let d: DerefWithHelper<Option<T>, T> = DerefWithHelper { helper: Some(x) };\n+    d.eq(&y)\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "f43be17786299ec00c8985306c3529fc5e67c258", "filename": "src/test/run-pass/deref-mut-on-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fderef-mut-on-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fderef-mut-on-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-mut-on-ref.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -10,9 +10,9 @@\n \n // Test that `&mut T` implements `DerefMut<T>`\n \n-use std::ops::DerefMut;\n+use std::ops::{Deref, DerefMut};\n \n-fn inc<T:DerefMut<int>>(mut t: T) {\n+fn inc<T: Deref<Target=int> + DerefMut>(mut t: T) {\n     *t += 1;\n }\n "}, {"sha": "e95d942c8cf73c89a404aad4f7834b16a99faeae", "filename": "src/test/run-pass/deref-on-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fderef-on-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fderef-on-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-on-ref.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -12,7 +12,7 @@\n \n use std::ops::Deref;\n \n-fn deref<U:Copy,T:Deref<U>>(t: T) -> U {\n+fn deref<U:Copy,T:Deref<Target=U>>(t: T) -> U {\n     *t\n }\n "}, {"sha": "0e0ed1f436c9a019829452f680d963d00629e484", "filename": "src/test/run-pass/dst-deref-mut.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fdst-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fdst-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-deref-mut.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -10,19 +10,23 @@\n \n // Test that a custom deref with a fat pointer return type does not ICE\n \n+#![feature(associated_types)]\n+\n use std::ops::{Deref, DerefMut};\n \n pub struct Arr {\n     ptr: Box<[uint]>\n }\n \n-impl Deref<[uint]> for Arr {\n+impl Deref for Arr {\n+    type Target = [uint];\n+\n     fn deref(&self) -> &[uint] {\n         panic!();\n     }\n }\n \n-impl DerefMut<[uint]> for Arr {\n+impl DerefMut for Arr {\n     fn deref_mut(&mut self) -> &mut [uint] {\n         &mut *self.ptr\n     }"}, {"sha": "a39670a27b9678e373f63b3c554d175f6e85f800", "filename": "src/test/run-pass/dst-deref.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fdst-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fdst-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-deref.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -10,13 +10,17 @@\n \n // Test that a custom deref with a fat pointer return type does not ICE\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n pub struct Arr {\n     ptr: Box<[uint]>\n }\n \n-impl Deref<[uint]> for Arr {\n+impl Deref for Arr {\n+    type Target = [uint];\n+\n     fn deref(&self) -> &[uint] {\n         &*self.ptr\n     }"}, {"sha": "8fb3893e5decfa8b051eb2848a562231a7cdd29c", "filename": "src/test/run-pass/fixup-deref-mut.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Ffixup-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Ffixup-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixup-deref-mut.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,20 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::{Deref, DerefMut};\n \n // Generic unique/owned smaht pointer.\n struct Own<T> {\n     value: *mut T\n }\n \n-impl<T> Deref<T> for Own<T> {\n+impl<T> Deref for Own<T> {\n+    type Target = T;\n+\n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.value }\n     }\n }\n \n-impl<T> DerefMut<T> for Own<T> {\n+impl<T> DerefMut for Own<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.value }\n     }"}, {"sha": "00b508ab92c30e1a4acc194e0621e25f726342a1", "filename": "src/test/run-pass/issue-13264.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fissue-13264.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fissue-13264.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13264.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct Root {\n     jsref: JSRef\n }\n \n-impl Deref<JSRef> for Root {\n+impl Deref for Root {\n+    type Target = JSRef;\n+\n     fn deref<'a>(&'a self) -> &'a JSRef {\n         &self.jsref\n     }\n@@ -25,7 +29,9 @@ struct JSRef {\n     node: *const Node\n }\n \n-impl Deref<Node> for JSRef {\n+impl Deref for JSRef {\n+    type Target = Node;\n+\n     fn deref<'a>(&'a self) -> &'a Node {\n         self.get()\n     }"}, {"sha": "45cfabcd872ec653d176c00f009416f5b08372b8", "filename": "src/test/run-pass/issue-16774.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fissue-16774.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Fissue-16774.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16774.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+#![feature(associated_types, unboxed_closures)]\n \n use std::ops::{Deref, DerefMut};\n \n@@ -25,14 +25,16 @@ impl Drop for X {\n     }\n }\n \n-impl Deref<int> for X {\n+impl Deref for X {\n+    type Target = int;\n+\n     fn deref(&self) -> &int {\n         let &X(box ref x) = self;\n         x\n     }\n }\n \n-impl DerefMut<int> for X {\n+impl DerefMut for X {\n     fn deref_mut(&mut self) -> &mut int {\n         let &X(box ref mut x) = self;\n         x"}, {"sha": "e9eb924d4493dc0817022e33607873f2bc7ed902", "filename": "src/test/run-pass/overloaded-autoderef-count.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::cell::Cell;\n use std::ops::{Deref, DerefMut};\n \n@@ -32,14 +34,16 @@ impl<T> DerefCounter<T> {\n     }\n }\n \n-impl<T> Deref<T> for DerefCounter<T> {\n+impl<T> Deref for DerefCounter<T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T {\n         self.count_imm.set(self.count_imm.get() + 1);\n         &self.value\n     }\n }\n \n-impl<T> DerefMut<T> for DerefCounter<T> {\n+impl<T> DerefMut for DerefCounter<T> {\n     fn deref_mut(&mut self) -> &mut T {\n         self.count_mut += 1;\n         &mut self.value"}, {"sha": "6d8d09b321ee540b0c3bc72ea559983ae104be47", "filename": "src/test/run-pass/overloaded-autoderef-indexing.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct DerefArray<'a, T:'a> {\n     inner: &'a [T]\n }\n \n-impl<'a, T> Deref<&'a [T]> for DerefArray<'a, T> {\n+impl<'a, T> Deref for DerefArray<'a, T> {\n+    type Target = &'a [T];\n+\n     fn deref<'b>(&'b self) -> &'b &'a [T] {\n         &self.inner\n     }"}, {"sha": "cafb665fc370d1e5a072d9592ea3ae8ce1a5acd9", "filename": "src/test/run-pass/overloaded-autoderef-order.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::rc::Rc;\n use std::ops::Deref;\n \n@@ -24,7 +26,9 @@ impl<X, Y> DerefWrapper<X, Y> {\n     }\n }\n \n-impl<X, Y> Deref<Y> for DerefWrapper<X, Y> {\n+impl<X, Y> Deref for DerefWrapper<X, Y> {\n+    type Target = Y;\n+\n     fn deref(&self) -> &Y {\n         &self.y\n     }\n@@ -49,7 +53,9 @@ mod priv_test {\n         }\n     }\n \n-    impl<X, Y> Deref<Y> for DerefWrapperHideX<X, Y> {\n+    impl<X, Y> Deref for DerefWrapperHideX<X, Y> {\n+        type Target = Y;\n+\n         fn deref(&self) -> &Y {\n             &self.y\n         }"}, {"sha": "23efba157495c4a11dc3cc83c55b0f134cbca178", "filename": "src/test/run-pass/overloaded-autoderef-vtable.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-vtable.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::Deref;\n \n struct DerefWithHelper<H, T> {\n@@ -24,7 +26,9 @@ impl<T> Helper<T> for Option<T> {\n     }\n }\n \n-impl<T, H: Helper<T>> Deref<T> for DerefWithHelper<H, T> {\n+impl<T, H: Helper<T>> Deref for DerefWithHelper<H, T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T {\n         self.helper.helper_borrow()\n     }"}, {"sha": "b6fb38d5cc2cfd0520c55b327fc3c07f0cfe9765", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::cell::Cell;\n use std::ops::{Deref, DerefMut};\n use std::vec::Vec;\n@@ -32,14 +34,16 @@ impl<T> DerefCounter<T> {\n     }\n }\n \n-impl<T> Deref<T> for DerefCounter<T> {\n+impl<T> Deref for DerefCounter<T> {\n+    type Target = T;\n+\n     fn deref(&self) -> &T {\n         self.count_imm.set(self.count_imm.get() + 1);\n         &self.value\n     }\n }\n \n-impl<T> DerefMut<T> for DerefCounter<T> {\n+impl<T> DerefMut for DerefCounter<T> {\n     fn deref_mut(&mut self) -> &mut T {\n         self.count_mut += 1;\n         &mut self.value"}, {"sha": "62b61c153c7077d8330ad997fd17d9a055ff7570", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340f3fd7a909b30509a63916df06f2b885d113f7/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=340f3fd7a909b30509a63916df06f2b885d113f7", "patch": "@@ -49,7 +49,7 @@ fn main() {\n             stream.write(&[2]);\n         }\n     }).detach();\n-    let addr = rx.recv().unwarp();\n+    let addr = rx.recv().unwrap();\n \n     let (tx, rx) = channel();\n     for _ in range(0u, 1000) {"}]}