{"sha": "918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "node_id": "C_kwDOAAsO6NoAKDkxOGQwYWMzOGU4YzNiY2Y0ZmI1ZWUyMjQxZmIxNDk3OWM3M2MzMTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-14T01:19:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-14T01:19:24Z"}, "message": "Auto merge of #104986 - compiler-errors:opaques, r=oli-obk\n\nCombine `ty::Projection` and `ty::Opaque` into `ty::Alias`\n\nImplements https://github.com/rust-lang/types-team/issues/79.\n\nThis PR consolidates `ty::Projection` and `ty::Opaque` into a single `ty::Alias`, with an `AliasKind` and `AliasTy` type (renamed from `ty::ProjectionTy`, which is the inner data of `ty::Projection`) defined as so:\n\n```\nenum AliasKind {\n  Projection,\n  Opaque,\n}\n\nstruct AliasTy<'tcx> {\n  def_id: DefId,\n  substs: SubstsRef<'tcx>,\n}\n```\n\nSince we don't have access to `TyCtxt` in type flags computation, and because repeatedly calling `DefKind` on the def-id is expensive, these two types are distinguished with `ty::AliasKind`, conveniently glob-imported into `ty::{Projection, Opaque}`. For example:\n\n```diff\n  match ty.kind() {\n-   ty::Opaque(..) =>\n+   ty::Alias(ty::Opaque, ..) => {}\n    _ => {}\n  }\n```\n\nThis PR also consolidates match arms that treated `ty::Opaque` and `ty::Projection` identically.\n\nr? `@ghost`", "tree": {"sha": "927355e933124955c8e2411e2ca16d31a962dfef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/927355e933124955c8e2411e2ca16d31a962dfef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "html_url": "https://github.com/rust-lang/rust/commit/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "url": "https://api.github.com/repos/rust-lang/rust/commits/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "html_url": "https://github.com/rust-lang/rust/commit/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812"}, {"sha": "99417d54afe7a9f8a74c9eea4338d039f36b9a45", "url": "https://api.github.com/repos/rust-lang/rust/commits/99417d54afe7a9f8a74c9eea4338d039f36b9a45", "html_url": "https://github.com/rust-lang/rust/commit/99417d54afe7a9f8a74c9eea4338d039f36b9a45"}], "stats": {"total": 1306, "additions": 632, "deletions": 674}, "files": [{"sha": "a92cb6bb38d4766ac9c919e07a732e84aa65d5cd", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -697,8 +697,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     .map_bound(|p| p.predicates),\n                 None,\n             ),\n-            ty::Opaque(did, substs) => {\n-                find_fn_kind_from_did(tcx.bound_explicit_item_bounds(*did), Some(*substs))\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n+                find_fn_kind_from_did(tcx.bound_explicit_item_bounds(*def_id), Some(*substs))\n             }\n             ty::Closure(_, substs) => match substs.as_closure().kind() {\n                 ty::ClosureKind::Fn => Some(hir::Mutability::Not),"}, {"sha": "e6520301818d82beb2bb99c754fa3b6f7eedf945", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n         let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n-        if let ty::Opaque(def_id, _) = *output_ty.kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *output_ty.kind() {\n             output_ty = self.infcx.tcx.type_of(def_id)\n         };\n "}, {"sha": "819c2678d6c4d4ccead480763760400e56cae706", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -235,7 +235,7 @@ fn push_debuginfo_type_name<'tcx>(\n                 let projection_bounds: SmallVec<[_; 4]> = trait_data\n                     .projection_bounds()\n                     .map(|bound| {\n-                        let ExistentialProjection { item_def_id, term, .. } =\n+                        let ExistentialProjection { def_id: item_def_id, term, .. } =\n                             tcx.erase_late_bound_regions(bound);\n                         // FIXME(associated_const_equality): allow for consts here\n                         (item_def_id, term.ty().unwrap())\n@@ -411,9 +411,8 @@ fn push_debuginfo_type_name<'tcx>(\n         ty::Error(_)\n         | ty::Infer(_)\n         | ty::Placeholder(..)\n-        | ty::Projection(..)\n+        | ty::Alias(..)\n         | ty::Bound(..)\n-        | ty::Opaque(..)\n         | ty::GeneratorWitness(..) => {\n             bug!(\n                 \"debuginfo: Trying to create type name for \\"}, {"sha": "498c008738793912e46e0b25afca0b8180a07d34", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -142,12 +142,11 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n         | ty::Foreign(..)\n         | ty::Infer(ty::FreshIntTy(_))\n         | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Projection(..)\n+        // FIXME(oli-obk): we could look behind opaque types\n+        | ty::Alias(..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n-        // FIXME(oli-obk): we could look behind opaque types\n-        | ty::Opaque(..)\n         | ty::Infer(_)\n         // FIXME(oli-obk): we can probably encode closures just like structs\n         | ty::Closure(..)\n@@ -307,11 +306,10 @@ pub fn valtree_to_const_value<'tcx>(\n         | ty::Foreign(..)\n         | ty::Infer(ty::FreshIntTy(_))\n         | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Projection(..)\n+        | ty::Alias(..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n-        | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Closure(..)\n         | ty::Generator(..)"}, {"sha": "9b56757eb3951a4ee201a538268f286f7b12edce", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -82,11 +82,9 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n             ty::Adt(ref adt, _) => {\n                 ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx)\n             }\n-            ty::Projection(_)\n-            | ty::Opaque(_, _)\n-            | ty::Param(_)\n-            | ty::Placeholder(_)\n-            | ty::Infer(_) => throw_inval!(TooGeneric),\n+            ty::Alias(..) | ty::Param(_) | ty::Placeholder(_) | ty::Infer(_) => {\n+                throw_inval!(TooGeneric)\n+            }\n             ty::Bound(_, _) => bug!(\"bound ty during ctfe\"),\n             ty::Bool\n             | ty::Char"}, {"sha": "f905d3fb479a0b7e343c7dd187239f94f3543705", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -601,8 +601,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             | ty::Placeholder(..)\n             | ty::Bound(..)\n             | ty::Param(..)\n-            | ty::Opaque(..)\n-            | ty::Projection(..)\n+            | ty::Alias(..)\n             | ty::GeneratorWitness(..) => bug!(\"Encountered invalid type {:?}\", ty),\n         }\n     }"}, {"sha": "decddf47b715d7a9f4aff4df1f52ee0a7f48c6a3", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 };\n \n                 let kind = match parent_ty.ty.kind() {\n-                    &ty::Opaque(def_id, substs) => {\n+                    &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                         self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n                     }\n                     kind => kind,\n@@ -652,7 +652,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, \"`SetDiscriminant`is not allowed until deaggregation\");\n                 }\n                 let pty = place.ty(&self.body.local_decls, self.tcx).ty.kind();\n-                if !matches!(pty, ty::Adt(..) | ty::Generator(..) | ty::Opaque(..)) {\n+                if !matches!(pty, ty::Adt(..) | ty::Generator(..) | ty::Alias(ty::Opaque, ..)) {\n                     self.fail(\n                         location,\n                         format!("}, {"sha": "dd65d4fd591e547a93089cff9fa0e0ac27690ece", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -58,8 +58,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             // Types with identity (print the module path).\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n-            | ty::Opaque(def_id, substs)\n-            | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n+            | ty::Alias(_, ty::AliasTy { def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n             ty::Foreign(def_id) => self.print_def_path(def_id, &[]),"}, {"sha": "c8c10385f0cd60c4d035985c1931e1277e6f8f1a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1146,10 +1146,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             debug!(?substs_trait_ref_and_assoc_item);\n \n-            ty::ProjectionTy {\n-                item_def_id: assoc_item.def_id,\n-                substs: substs_trait_ref_and_assoc_item,\n-            }\n+            ty::AliasTy { def_id: assoc_item.def_id, substs: substs_trait_ref_and_assoc_item }\n         });\n \n         if !speculative {\n@@ -1195,7 +1192,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // the \"projection predicate\" for:\n                 //\n                 // `<T as Iterator>::Item = u32`\n-                let assoc_item_def_id = projection_ty.skip_binder().item_def_id;\n+                let assoc_item_def_id = projection_ty.skip_binder().def_id;\n                 let def_kind = tcx.def_kind(assoc_item_def_id);\n                 match (def_kind, term.unpack()) {\n                     (hir::def::DefKind::AssocTy, ty::TermKind::Ty(_))\n@@ -1244,7 +1241,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 //\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n-                let param_ty = tcx.mk_ty(ty::Projection(projection_ty.skip_binder()));\n+                let param_ty = tcx.mk_ty(ty::Alias(ty::Projection, projection_ty.skip_binder()));\n                 self.add_bounds(param_ty, ast_bounds.iter(), bounds, candidate.bound_vars());\n             }\n         }"}, {"sha": "dd841707b29069e3510d38db347891b553afa1c5", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1440,7 +1440,7 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> E\n                 impl<'tcx> ty::visit::TypeVisitor<'tcx> for OpaqueTypeCollector {\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         match *t.kind() {\n-                            ty::Opaque(def, _) => {\n+                            ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, substs: _ }) => {\n                                 self.0.push(def);\n                                 ControlFlow::CONTINUE\n                             }"}, {"sha": "ba7d31cea2e2f3e778702c331738ca93ab9dffc7", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -571,10 +571,10 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Projection(proj) = ty.kind()\n-            && self.tcx().def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n+        if let ty::Alias(ty::Projection, proj) = ty.kind()\n+            && self.tcx().def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n         {\n-            if let Some((ty, _)) = self.types.get(&proj.item_def_id) {\n+            if let Some((ty, _)) = self.types.get(&proj.def_id) {\n                 return *ty;\n             }\n             //FIXME(RPITIT): Deny nested RPITIT in substs too\n@@ -586,9 +586,9 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n                 span: self.span,\n                 kind: TypeVariableOriginKind::MiscVariable,\n             });\n-            self.types.insert(proj.item_def_id, (infer_ty, proj.substs));\n+            self.types.insert(proj.def_id, (infer_ty, proj.substs));\n             // Recurse into bounds\n-            for (pred, pred_span) in self.tcx().bound_explicit_item_bounds(proj.item_def_id).subst_iter_copied(self.tcx(), proj.substs) {\n+            for (pred, pred_span) in self.tcx().bound_explicit_item_bounds(proj.def_id).subst_iter_copied(self.tcx(), proj.substs) {\n                 let pred = pred.fold_with(self);\n                 let pred = self.ocx.normalize(\n                     &ObligationCause::misc(self.span, self.body_id),\n@@ -601,7 +601,7 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n                     ObligationCause::new(\n                         self.span,\n                         self.body_id,\n-                        ObligationCauseCode::BindingObligation(proj.item_def_id, pred_span),\n+                        ObligationCauseCode::BindingObligation(proj.def_id, pred_span),\n                     ),\n                     self.param_env,\n                     pred,\n@@ -1734,8 +1734,8 @@ pub fn check_type_bounds<'tcx>(\n     let normalize_param_env = {\n         let mut predicates = param_env.caller_bounds().iter().collect::<Vec<_>>();\n         match impl_ty_value.kind() {\n-            ty::Projection(proj)\n-                if proj.item_def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n+            ty::Alias(ty::Projection, proj)\n+                if proj.def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n             {\n                 // Don't include this predicate if the projected type is\n                 // exactly the same as the projection. This can occur in\n@@ -1746,8 +1746,8 @@ pub fn check_type_bounds<'tcx>(\n             _ => predicates.push(\n                 ty::Binder::bind_with_vars(\n                     ty::ProjectionPredicate {\n-                        projection_ty: ty::ProjectionTy {\n-                            item_def_id: trait_ty.def_id,\n+                        projection_ty: ty::AliasTy {\n+                            def_id: trait_ty.def_id,\n                             substs: rebased_substs,\n                         },\n                         term: impl_ty_value.into(),"}, {"sha": "57f0cae12bb312bb5afd14d971fed8bac0ad31a1", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -352,11 +352,7 @@ fn bounds_from_generic_predicates<'tcx>(\n         // insert the associated types where they correspond, but for now let's be \"lazy\" and\n         // propose this instead of the following valid resugaring:\n         // `T: Trait, Trait::Assoc = K` \u2192 `T: Trait<Assoc = K>`\n-        where_clauses.push(format!(\n-            \"{} = {}\",\n-            tcx.def_path_str(p.projection_ty.item_def_id),\n-            p.term,\n-        ));\n+        where_clauses.push(format!(\"{} = {}\", tcx.def_path_str(p.projection_ty.def_id), p.term));\n     }\n     let where_clauses = if where_clauses.is_empty() {\n         String::new()"}, {"sha": "94d333c336ef3f2768267d1ea3ce72147dd57e25", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -759,7 +759,7 @@ impl<'tcx> TypeVisitor<'tcx> for GATSubstCollector<'tcx> {\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n-            ty::Projection(p) if p.item_def_id == self.gat => {\n+            ty::Alias(ty::Projection, p) if p.def_id == self.gat => {\n                 for (idx, subst) in p.substs.iter().enumerate() {\n                     match subst.unpack() {\n                         GenericArgKind::Lifetime(lt) if !lt.is_late_bound() => {\n@@ -1592,12 +1592,12 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     {\n         for arg in fn_output.walk() {\n             if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                && let ty::Projection(proj) = ty.kind()\n-                && tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n-                && tcx.impl_trait_in_trait_parent(proj.item_def_id) == fn_def_id.to_def_id()\n+                && let ty::Alias(ty::Projection, proj) = ty.kind()\n+                && tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n+                && tcx.impl_trait_in_trait_parent(proj.def_id) == fn_def_id.to_def_id()\n             {\n-                let span = tcx.def_span(proj.item_def_id);\n-                let bounds = wfcx.tcx().explicit_item_bounds(proj.item_def_id);\n+                let span = tcx.def_span(proj.def_id);\n+                let bounds = wfcx.tcx().explicit_item_bounds(proj.def_id);\n                 let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n                     let bound = ty::EarlyBinder(bound).subst(tcx, proj.substs);\n                     let normalized_bound = wfcx.normalize(span, None, bound);"}, {"sha": "6469f389bf91b313141ce01452fe74cb68b72f98", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -223,7 +223,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Tuple(..) => {\n                 self.check_primitive_impl(item.owner_id.def_id, self_ty, items, ty.span)\n             }\n-            ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n+            ty::Alias(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     ty.span,"}, {"sha": "b4ad3467e7d87ac67cac22c7705cedb92ea5cccf", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1749,7 +1749,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                 ty::Param(param_ty) => {\n                     self.arg_is_constrained[param_ty.index as usize] = true;\n                 }\n-                ty::Projection(_) => return ControlFlow::Continue(()),\n+                ty::Alias(ty::Projection, _) => return ControlFlow::Continue(()),\n                 _ => (),\n             }\n             t.super_visit_with(self)"}, {"sha": "79d75231e5d76d04024a44ebcc76621ea4449ecb", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -408,9 +408,9 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             //     identity substs of the trait.\n             // * It must be an associated type for this trait (*not* a\n             //   supertrait).\n-            if let ty::Projection(projection) = ty.kind() {\n+            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n                 projection.substs == trait_identity_substs\n-                    && tcx.associated_item(projection.item_def_id).container_id(tcx) == def_id\n+                    && tcx.associated_item(projection.def_id).container_id(tcx) == def_id\n             } else {\n                 false\n             }"}, {"sha": "b678990f94e918ba6f9f26ad160b9771b19366b7", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -52,7 +52,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // Using the ItemCtxt convert the HIR for the unresolved assoc type into a\n             // ty which is a fully resolved projection.\n             // For the code example above, this would mean converting Self::Assoc<3>\n-            // into a ty::Projection(<Self as Foo>::Assoc<3>)\n+            // into a ty::Alias(ty::Projection, <Self as Foo>::Assoc<3>)\n             let item_hir_id = tcx\n                 .hir()\n                 .parent_iter(hir_id)\n@@ -68,8 +68,8 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // the def_id that this query was called with. We filter to only type and const args here\n             // as a precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n             // but it can't hurt to be safe ^^\n-            if let ty::Projection(projection) = ty.kind() {\n-                let generics = tcx.generics_of(projection.item_def_id);\n+            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n+                let generics = tcx.generics_of(projection.def_id);\n \n                 let arg_index = segment\n                     .args\n@@ -666,7 +666,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n \n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id: def_id, tcx, found: None, typeck_types: vec![] };\n+    let mut locator = ConstraintLocator { def_id, tcx, found: None, typeck_types: vec![] };\n \n     debug!(?scope);\n \n@@ -803,7 +803,7 @@ fn find_opaque_ty_constraints_for_rpit(\n     if let Some(concrete) = concrete {\n         let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n         debug!(?scope);\n-        let mut locator = ConstraintChecker { def_id: def_id, tcx, found: concrete };\n+        let mut locator = ConstraintChecker { def_id, tcx, found: concrete };\n \n         match tcx.hir().get(scope) {\n             Node::Item(it) => intravisit::walk_item(&mut locator, it),"}, {"sha": "95c971c0d7845eee2d63668b8527c419b67eb4e6", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Projection(..) if !self.include_nonconstraining => {\n+            ty::Alias(ty::Projection, ..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::CONTINUE;\n             }"}, {"sha": "af8d7e8515865583d84f4769944025e7d6483ded", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -196,13 +196,13 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 }\n             }\n \n-            ty::Projection(obj) => {\n+            ty::Alias(ty::Projection, obj) => {\n                 // This corresponds to `<T as Foo<'a>>::Bar`. In this case, we should use the\n                 // explicit predicates as well.\n                 debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n-                    tcx.parent(obj.item_def_id),\n+                    tcx.parent(obj.def_id),\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,"}, {"sha": "b51b740d08e2e7a2e87f7bb578205bbcc430237c", "filename": "compiler/rustc_hir_analysis/src/outlives/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -90,7 +90,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                         // ```\n                         //\n                         // Here we want to add an explicit `where <T as Iterator>::Item: 'a`.\n-                        let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.item_def_id, proj_ty.substs);\n+                        let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.def_id, proj_ty.substs);\n                         required_predicates\n                             .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n                             .or_insert(span);"}, {"sha": "5e4d82b6fd5697ce31b095b0431a804f67d383f5", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -249,14 +249,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_substs(current, def.did(), substs, variance);\n             }\n \n-            ty::Projection(ref data) => {\n+            ty::Alias(_, ref data) => {\n                 self.add_constraints_from_invariant_substs(current, data.substs, variance);\n             }\n \n-            ty::Opaque(_, substs) => {\n-                self.add_constraints_from_invariant_substs(current, substs, variance);\n-            }\n-\n             ty::Dynamic(data, r, _) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);"}, {"sha": "3c29c72841e44579ce491c1e28ba2cac9283e6ed", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -111,11 +111,13 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n         #[instrument(level = \"trace\", skip(self), ret)]\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n             match t.kind() {\n-                ty::Opaque(def_id, substs) => self.visit_opaque(*def_id, substs),\n-                ty::Projection(proj)\n-                    if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+                ty::Alias(_, ty::AliasTy { def_id, substs })\n+                    if matches!(\n+                        self.tcx.def_kind(*def_id),\n+                        DefKind::OpaqueTy | DefKind::ImplTraitPlaceholder\n+                    ) =>\n                 {\n-                    self.visit_opaque(proj.item_def_id, proj.substs)\n+                    self.visit_opaque(*def_id, substs)\n                 }\n                 _ => t.super_visit_with(self),\n             }\n@@ -167,7 +169,7 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n                 }\n             }\n             ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy { substs, item_def_id: _ },\n+                projection_ty: ty::AliasTy { substs, def_id: _ },\n                 term,\n             })) => {\n                 for subst in &substs[1..] {"}, {"sha": "a86bd80a668b03d74aed8daed979d3679f264765", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.can_coerce(arm_ty, ret_ty)\n                     && prior_arm.map_or(true, |(_, ty, _)| self.can_coerce(ty, ret_ty))\n                     // The match arms need to unify for the case of `impl Trait`.\n-                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n+                    && !matches!(ret_ty.kind(), ty::Alias(ty::Opaque, ..))\n             }\n             _ => false,\n         };\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let substs = sig.output().walk().find_map(|arg| {\n                     if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                        && let ty::Opaque(def_id, substs) = *ty.kind()\n+                        && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) = *ty.kind()\n                         && def_id == rpit_def_id\n                     {\n                         Some(substs)"}, {"sha": "b050ad20afbdbcca92547e224feda97a9d8af8b8", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -38,7 +38,6 @@ use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::cast::{CastKind, CastTy};\n use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable, VariantDef};\n use rustc_session::lint;\n use rustc_session::Session;\n@@ -75,10 +74,8 @@ enum PointerKind<'tcx> {\n     VTable(Option<DefId>),\n     /// Slice\n     Length,\n-    /// The unsize info of this projection\n-    OfProjection(ty::ProjectionTy<'tcx>),\n-    /// The unsize info of this opaque ty\n-    OfOpaque(DefId, SubstsRef<'tcx>),\n+    /// The unsize info of this projection or opaque type\n+    OfAlias(ty::AliasTy<'tcx>),\n     /// The unsize info of this parameter\n     OfParam(ty::ParamTy),\n }\n@@ -118,8 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Pointers to foreign types are thin, despite being unsized\n             ty::Foreign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n-            ty::Projection(pi) => Some(PointerKind::OfProjection(pi)),\n-            ty::Opaque(def_id, substs) => Some(PointerKind::OfOpaque(def_id, substs)),\n+            ty::Alias(_, pi) => Some(PointerKind::OfAlias(pi)),\n             ty::Param(p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information.\n             ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) => None,\n@@ -976,11 +972,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             Some(PointerKind::Thin) => Ok(CastKind::AddrPtrCast),\n             Some(PointerKind::VTable(_)) => Err(CastError::IntToFatCast(Some(\"a vtable\"))),\n             Some(PointerKind::Length) => Err(CastError::IntToFatCast(Some(\"a length\"))),\n-            Some(\n-                PointerKind::OfProjection(_)\n-                | PointerKind::OfOpaque(_, _)\n-                | PointerKind::OfParam(_),\n-            ) => Err(CastError::IntToFatCast(None)),\n+            Some(PointerKind::OfAlias(_) | PointerKind::OfParam(_)) => {\n+                Err(CastError::IntToFatCast(None))\n+            }\n         }\n     }\n "}, {"sha": "a96d27868a6d50d128ec8f1230c5a0825c7b91fa", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -167,9 +167,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n-            ty::Opaque(def_id, substs) => self.deduce_signature_from_predicates(\n-                self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n-            ),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => self\n+                .deduce_signature_from_predicates(\n+                    self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n+                ),\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -677,17 +678,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     get_future_output(obligation.predicate, obligation.cause.span)\n                 })?\n             }\n-            ty::Opaque(def_id, substs) => self\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => self\n                 .tcx\n                 .bound_explicit_item_bounds(def_id)\n                 .subst_iter_copied(self.tcx, substs)\n                 .find_map(|(p, s)| get_future_output(p, s))?,\n             ty::Error(_) => return None,\n-            ty::Projection(proj)\n-                if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            ty::Alias(ty::Projection, proj)\n+                if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n                 self.tcx\n-                    .bound_explicit_item_bounds(proj.item_def_id)\n+                    .bound_explicit_item_bounds(proj.def_id)\n                     .subst_iter_copied(self.tcx, proj.substs)\n                     .find_map(|(p, s)| get_future_output(p, s))?\n             }\n@@ -743,11 +744,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // The `Future` trait has only one associated item, `Output`,\n         // so check that this is what we see.\n         let output_assoc_item = self.tcx.associated_item_def_ids(future_trait)[0];\n-        if output_assoc_item != predicate.projection_ty.item_def_id {\n+        if output_assoc_item != predicate.projection_ty.def_id {\n             span_bug!(\n                 cause_span,\n                 \"projecting associated item `{:?}` from future, which is not Output `{:?}`\",\n-                predicate.projection_ty.item_def_id,\n+                predicate.projection_ty.def_id,\n                 output_assoc_item,\n             );\n         }"}, {"sha": "a4ca7571142b6b1ea2c165521d834c01c3fa8377", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1805,7 +1805,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         {\n             let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n             // Get the `impl Trait`'s `DefId`.\n-            if let ty::Opaque(def_id, _) = ty.kind()\n+            if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = ty.kind()\n                 // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n                 // get the `Trait`'s `DefId`.\n                 && let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) ="}, {"sha": "4e2a78562240710741f64a61f99c76a75550fb4b", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -2391,7 +2391,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n-            ty::Opaque(_, _) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, substs: _ }) => {\n                 self.suggest_await_on_field_access(&mut err, ident, base, base_ty.peel_refs());\n             }\n             _ => {}"}, {"sha": "c8ea8ba5ab0655837ce7c16617890516e8c25e01", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -716,7 +716,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if formal_ret.has_infer_types() {\n             for ty in ret_ty.walk() {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n-                    && let ty::Opaque(def_id, _) = *ty.kind()\n+                    && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n                     && self.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n                     return None;"}, {"sha": "615f374b2ec0b8e3f2c34d63247424d4a4f9dd12", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -2124,7 +2124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                ty::Opaque(new_def_id, _)\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: new_def_id, substs: _ })\n                 | ty::Closure(new_def_id, _)\n                 | ty::FnDef(new_def_id, _) => {\n                     def_id = new_def_id;\n@@ -2217,7 +2217,7 @@ fn find_param_in_ty<'tcx>(ty: Ty<'tcx>, param_to_point_at: ty::GenericArg<'tcx>)\n         if arg == param_to_point_at {\n             return true;\n         } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Projection(..) = ty.kind()\n+            && let ty::Alias(ty::Projection, ..) = ty.kind()\n         {\n             // This logic may seem a bit strange, but typically when\n             // we have a projection type in a function signature, the"}, {"sha": "e6e1098e33d74057a0615355aaacc1f7a497c3a8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -174,10 +174,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let fn_sig = substs.as_closure().sig();\n                     Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n                 }\n-                ty::Opaque(def_id, substs) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                     self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n                         if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n                         // args tuple will always be substs[1]\n                         && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n                         {\n@@ -194,7 +194,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::Dynamic(data, _, ty::Dyn) => {\n                     data.iter().find_map(|pred| {\n                         if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                        && Some(proj.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n                         // for existential projection, substs are shifted over by 1\n                         && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n                         {\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n                     self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n                         if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n                         && proj.projection_ty.self_ty() == found\n                         // args tuple will always be substs[1]\n                         && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()"}, {"sha": "d83b9eb995d2b687e2502191122f00e4e91ffd8c", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -563,7 +563,7 @@ fn check_must_not_suspend_ty<'tcx>(\n         }\n         ty::Adt(def, _) => check_must_not_suspend_def(fcx.tcx, def.did(), hir_id, data),\n         // FIXME: support adding the attribute to TAITs\n-        ty::Opaque(def, _) => {\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, substs: _ }) => {\n             let mut has_emitted = false;\n             for &(predicate, _) in fcx.tcx.explicit_item_bounds(def) {\n                 // We only look at the `DefId`, so it is safe to skip the binder here."}, {"sha": "41cd6bf314ebf557527bde7bf783f163ee9ef29a", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -557,9 +557,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         .chain(projection_ty.substs.iter().skip(1)),\n                                 );\n \n-                                let quiet_projection_ty = ty::ProjectionTy {\n+                                let quiet_projection_ty = ty::AliasTy {\n                                     substs: substs_with_infer_self,\n-                                    item_def_id: projection_ty.item_def_id,\n+                                    def_id: projection_ty.def_id,\n                                 };\n \n                                 let term = pred.skip_binder().term;\n@@ -1982,7 +1982,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         | ty::Float(_)\n                         | ty::Adt(_, _)\n                         | ty::Str\n-                        | ty::Projection(_)\n+                        | ty::Alias(ty::Projection, _)\n                         | ty::Param(_) => format!(\"{deref_ty}\"),\n                         // we need to test something like  <&[_]>::len or <(&[u32])>::len\n                         // and Vec::function();\n@@ -2282,7 +2282,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             t.def_id() == info.def_id\n                         }\n                         ty::PredicateKind::Clause(ty::Clause::Projection(p)) => {\n-                            p.projection_ty.item_def_id == info.def_id\n+                            p.projection_ty.def_id == info.def_id\n                         }\n                         _ => false,\n                     }"}, {"sha": "d25d9672c36d05ef7e638be2860812a0cfe671a3", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -546,7 +546,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             impl<'tcx> ty::TypeVisitor<'tcx> for RecursionChecker {\n                 type BreakTy = ();\n                 fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                    if let ty::Opaque(def_id, _) = *t.kind() {\n+                    if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *t.kind() {\n                         if def_id == self.def_id.to_def_id() {\n                             return ControlFlow::Break(());\n                         }"}, {"sha": "e9186540a7b7c53869366303bba18d2791432f5f", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -411,16 +411,16 @@ impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> ToTrace<'tcx> for ty::ProjectionTy<'tcx> {\n+impl<'tcx> ToTrace<'tcx> for ty::AliasTy<'tcx> {\n     fn to_trace(\n         tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n-        let a_ty = tcx.mk_projection(a.item_def_id, a.substs);\n-        let b_ty = tcx.mk_projection(b.item_def_id, b.substs);\n+        let a_ty = tcx.mk_projection(a.def_id, a.substs);\n+        let b_ty = tcx.mk_projection(b.def_id, b.substs);\n         TypeTrace {\n             cause: cause.clone(),\n             values: Terms(ExpectedFound::new(a_is_expected, a_ty.into(), b_ty.into())),"}, {"sha": "ec5221379d2c9314f93dedab1163b409569203e6", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -453,10 +453,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Projection(..)\n+            | ty::Alias(..)\n             | ty::Foreign(..)\n-            | ty::Param(..)\n-            | ty::Opaque(..) => {\n+            | ty::Param(..) => {\n                 if t.flags().intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {"}, {"sha": "316077f69d99b65ffc8fb15c4bd43c1853b60c34", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -675,7 +675,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 // relatable.\n                 Ok(t)\n             }\n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 let s = self.relate(substs, substs)?;\n                 Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n             }"}, {"sha": "9fd4bdee096ac81dc36862ab93218da4d7019b07", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -100,11 +100,15 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n             }\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+            (\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }),\n+            ) if a_def_id == b_def_id => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n             }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-                if self.fields.define_opaque_types && did.is_local() =>\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }))\n+                if self.fields.define_opaque_types && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "3d2b2c6ff2dad9a56cc8ab22144158d0ffb03c93", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -339,11 +339,13 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n impl<'tcx> InferCtxt<'tcx> {\n     pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         let (def_id, substs) = match *ty.kind() {\n-            ty::Opaque(def_id, substs) => (def_id, substs),\n-            ty::Projection(data)\n-                if self.tcx.def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            ty::Alias(_, ty::AliasTy { def_id, substs })\n+                if matches!(\n+                    self.tcx.def_kind(def_id),\n+                    DefKind::OpaqueTy | DefKind::ImplTraitPlaceholder\n+                ) =>\n             {\n-                (data.item_def_id, data.substs)\n+                (def_id, substs)\n             }\n             _ => return None,\n         };\n@@ -357,7 +359,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     .kind()\n                     .map_bound(|kind| match kind {\n                         ty::PredicateKind::Clause(ty::Clause::Projection(projection_predicate))\n-                            if projection_predicate.projection_ty.item_def_id == item_def_id =>\n+                            if projection_predicate.projection_ty.def_id == item_def_id =>\n                         {\n                             projection_predicate.term.ty()\n                         }\n@@ -1730,7 +1732,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     let extra = expected == found;\n                     let sort_string = |ty: Ty<'tcx>, path: Option<PathBuf>| {\n                         let mut s = match (extra, ty.kind()) {\n-                            (true, ty::Opaque(def_id, _)) => {\n+                            (true, ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. })) => {\n                                 let sm = self.tcx.sess.source_map();\n                                 let pos = sm.lookup_char_pos(self.tcx.def_span(*def_id).lo());\n                                 format!(\n@@ -1740,12 +1742,12 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                     pos.col.to_usize() + 1,\n                                 )\n                             }\n-                            (true, ty::Projection(proj))\n-                                if self.tcx.def_kind(proj.item_def_id)\n+                            (true, ty::Alias(ty::Projection, proj))\n+                                if self.tcx.def_kind(proj.def_id)\n                                     == DefKind::ImplTraitPlaceholder =>\n                             {\n                                 let sm = self.tcx.sess.source_map();\n-                                let pos = sm.lookup_char_pos(self.tcx.def_span(proj.item_def_id).lo());\n+                                let pos = sm.lookup_char_pos(self.tcx.def_span(proj.def_id).lo());\n                                 format!(\n                                     \" (trait associated opaque type at <{}:{}:{}>)\",\n                                     sm.filename_for_diagnostics(&pos.file.name),\n@@ -2383,7 +2385,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n                         // suggest:\n                         // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-                        ty::Closure(_, _substs) | ty::Opaque(_, _substs) if return_impl_trait => {\n+                        ty::Closure(..) | ty::Alias(ty::Opaque, ..) if return_impl_trait => {\n                             new_binding_suggestion(&mut err, type_param_span);\n                         }\n                         _ => {\n@@ -2765,7 +2767,9 @@ impl TyCategory {\n     pub fn from_ty(tcx: TyCtxt<'_>, ty: Ty<'_>) -> Option<(Self, DefId)> {\n         match *ty.kind() {\n             ty::Closure(def_id, _) => Some((Self::Closure, def_id)),\n-            ty::Opaque(def_id, _) => Some((Self::Opaque, def_id)),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => {\n+                Some((Self::Opaque, def_id))\n+            }\n             ty::Generator(def_id, ..) => {\n                 Some((Self::Generator(tcx.generator_kind(def_id).unwrap()), def_id))\n             }"}, {"sha": "4f9e069c1763d08789c78175be6c926fe3e3d8fa", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -852,7 +852,10 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n             match inner.unpack() {\n                 GenericArgKind::Lifetime(_) => {}\n                 GenericArgKind::Type(ty) => {\n-                    if matches!(ty.kind(), ty::Opaque(..) | ty::Closure(..) | ty::Generator(..)) {\n+                    if matches!(\n+                        ty.kind(),\n+                        ty::Alias(ty::Opaque, ..) | ty::Closure(..) | ty::Generator(..)\n+                    ) {\n                         // Opaque types can't be named by the user right now.\n                         //\n                         // Both the generic arguments of closures and generators can"}, {"sha": "62655d11ca309fd448cd44c8c7dfc4c85e4585fd", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -486,12 +486,14 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n                 StatementAsExpression::CorrectType\n             }\n-            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n-                if last_def_id == exp_def_id =>\n-            {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+            (\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: last_def_id, substs: _ }),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: exp_def_id, substs: _ }),\n+            ) if last_def_id == exp_def_id => StatementAsExpression::CorrectType,\n+            (\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: last_def_id, substs: last_bounds }),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: exp_def_id, substs: exp_bounds }),\n+            ) => {\n                 debug!(\n                     \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n                     last_def_id, last_bounds, exp_def_id, exp_bounds"}, {"sha": "8f53b1ccdf45829c758721072cf55d1063f730ff", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -205,12 +205,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Projection(..)\n+            | ty::Alias(..)\n             | ty::Foreign(..)\n             | ty::Param(..)\n             | ty::Closure(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Opaque(..) => t.super_fold_with(self),\n+            | ty::GeneratorWitness(..) => t.super_fold_with(self),\n \n             ty::Placeholder(..) | ty::Bound(..) => bug!(\"unexpected type {:?}\", t),\n         }"}, {"sha": "47d76dc5bdf02904cebcff63dd042038284cd0d4", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -105,11 +105,13 @@ where\n             Ok(v)\n         }\n \n-        (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-            infcx.super_combine_tys(this, a, b)\n-        }\n-        (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-            if this.define_opaque_types() && did.is_local() =>\n+        (\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: _ }),\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }),\n+        ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n+        (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }), _)\n+        | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }))\n+            if this.define_opaque_types() && def_id.is_local() =>\n         {\n             this.add_obligations(\n                 infcx"}, {"sha": "3b9683e5b59333542f09347aaeaf123bd9b7295a", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -275,13 +275,13 @@ where\n     ///   `ProjectionEq(projection = ?U)`, `ProjectionEq(other_projection = ?U)`.\n     fn relate_projection_ty(\n         &mut self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n+        projection_ty: ty::AliasTy<'tcx>,\n         value_ty: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         use rustc_span::DUMMY_SP;\n \n         match *value_ty.kind() {\n-            ty::Projection(other_projection_ty) => {\n+            ty::Alias(ty::Projection, other_projection_ty) => {\n                 let var = self.infcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: DUMMY_SP,\n@@ -335,7 +335,9 @@ where\n                 return Ok(value_ty);\n             }\n \n-            ty::Projection(projection_ty) if D::normalization() == NormalizationStrategy::Lazy => {\n+            ty::Alias(ty::Projection, projection_ty)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n                 return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_ty_var(vid)));\n             }\n \n@@ -406,8 +408,8 @@ where\n             }\n         };\n         let (a, b) = match (a.kind(), b.kind()) {\n-            (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n-            (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n+            (&ty::Alias(ty::Opaque, ..), _) => (a, generalize(b, false)?),\n+            (_, &ty::Alias(ty::Opaque, ..)) => (generalize(a, true)?, b),\n             _ => unreachable!(),\n         };\n         let cause = ObligationCause::dummy_with_span(self.delegate.span());\n@@ -608,26 +610,30 @@ where\n \n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-                infcx.super_combine_tys(self, a, b).or_else(|err| {\n-                    self.tcx().sess.delay_span_bug(\n-                        self.delegate.span(),\n-                        \"failure to relate an opaque to itself should result in an error later on\",\n-                    );\n-                    if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n-                })\n-            }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..)) if did.is_local() => {\n+            (\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }),\n+            ) if a_def_id == b_def_id => infcx.super_combine_tys(self, a, b).or_else(|err| {\n+                self.tcx().sess.delay_span_bug(\n+                    self.delegate.span(),\n+                    \"failure to relate an opaque to itself should result in an error later on\",\n+                );\n+                if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n+            }),\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }))\n+                if def_id.is_local() =>\n+            {\n                 self.relate_opaques(a, b)\n             }\n \n-            (&ty::Projection(projection_ty), _)\n+            (&ty::Alias(ty::Projection, projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n                 Ok(self.relate_projection_ty(projection_ty, b))\n             }\n \n-            (_, &ty::Projection(projection_ty))\n+            (_, &ty::Alias(ty::Projection, projection_ty))\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n                 Ok(self.relate_projection_ty(projection_ty, a))"}, {"sha": "67e4554c4c7074b7ba400ecb080eddc381b58e93", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -66,7 +66,9 @@ impl<'tcx> InferCtxt<'tcx> {\n             lt_op: |lt| lt,\n             ct_op: |ct| ct,\n             ty_op: |ty| match *ty.kind() {\n-                ty::Opaque(def_id, _substs) if replace_opaque_type(def_id) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ })\n+                    if replace_opaque_type(def_id) =>\n+                {\n                     let def_span = self.tcx.def_span(def_id);\n                     let span = if span.contains(def_span) { def_span } else { span };\n                     let code = traits::ObligationCauseCode::OpaqueReturnType(None);\n@@ -104,7 +106,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n         let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n         let process = |a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected| match *a.kind() {\n-            ty::Opaque(def_id, substs) if def_id.is_local() => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) if def_id.is_local() => {\n                 let def_id = def_id.expect_local();\n                 let origin = match self.defining_use_anchor {\n                     DefiningAnchor::Bind(_) => {\n@@ -147,18 +149,21 @@ impl<'tcx> InferCtxt<'tcx> {\n                     DefiningAnchor::Bubble => self.opaque_ty_origin_unchecked(def_id, cause.span),\n                     DefiningAnchor::Error => return None,\n                 };\n-                if let ty::Opaque(did2, _) = *b.kind() {\n+                if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }) =\n+                    *b.kind()\n+                {\n                     // We could accept this, but there are various ways to handle this situation, and we don't\n                     // want to make a decision on it right now. Likely this case is so super rare anyway, that\n                     // no one encounters it in practice.\n                     // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n                     // where it is of no concern, so we only check for TAITs.\n-                    if let Some(OpaqueTyOrigin::TyAlias) =\n-                        did2.as_local().and_then(|did2| self.opaque_type_origin(did2, cause.span))\n+                    if let Some(OpaqueTyOrigin::TyAlias) = b_def_id\n+                        .as_local()\n+                        .and_then(|b_def_id| self.opaque_type_origin(b_def_id, cause.span))\n                     {\n                         self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n                             span: cause.span,\n-                            hidden_type: self.tcx.def_span(did2),\n+                            hidden_type: self.tcx.def_span(b_def_id),\n                             opaque_type: self.tcx.def_span(def_id),\n                         });\n                     }\n@@ -475,7 +480,7 @@ where\n                 substs.as_generator().resume_ty().visit_with(self);\n             }\n \n-            ty::Opaque(def_id, ref substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, ref substs }) => {\n                 // Skip lifetime paramters that are not captures.\n                 let variances = self.tcx.variances_of(*def_id);\n \n@@ -486,11 +491,11 @@ where\n                 }\n             }\n \n-            ty::Projection(proj)\n-                if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            ty::Alias(ty::Projection, proj)\n+                if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n                 // Skip lifetime paramters that are not captures.\n-                let variances = self.tcx.variances_of(proj.item_def_id);\n+                let variances = self.tcx.variances_of(proj.def_id);\n \n                 for (v, s) in std::iter::zip(variances, proj.substs.iter()) {\n                     if *v != ty::Variance::Bivariant {\n@@ -563,9 +568,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n                     // FIXME(RPITIT): Don't replace RPITITs with inference vars.\n-                    ty::Projection(projection_ty)\n+                    ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n-                            && tcx.def_kind(projection_ty.item_def_id)\n+                            && tcx.def_kind(projection_ty.def_id)\n                                 != DefKind::ImplTraitPlaceholder =>\n                     {\n                         self.infer_projection(\n@@ -578,14 +583,14 @@ impl<'tcx> InferCtxt<'tcx> {\n                     }\n                     // Replace all other mentions of the same opaque type with the hidden type,\n                     // as the bounds must hold on the hidden type after all.\n-                    ty::Opaque(def_id2, substs2)\n+                    ty::Alias(ty::Opaque, ty::AliasTy { def_id: def_id2, substs: substs2 })\n                         if def_id.to_def_id() == def_id2 && substs == substs2 =>\n                     {\n                         hidden_ty\n                     }\n                     // FIXME(RPITIT): This can go away when we move to associated types\n-                    ty::Projection(proj)\n-                        if def_id.to_def_id() == proj.item_def_id && substs == proj.substs =>\n+                    ty::Alias(ty::Projection, ty::AliasTy { def_id: def_id2, substs: substs2 })\n+                        if def_id.to_def_id() == def_id2 && substs == substs2 =>\n                     {\n                         hidden_ty\n                     }"}, {"sha": "984bbe169e6cf7ae110549236f2c6145de2dc3d4", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -23,7 +23,7 @@ pub enum Component<'tcx> {\n     // is not in a position to judge which is the best technique, so\n     // we just product the projection as a component and leave it to\n     // the consumer to decide (but see `EscapingProjection` below).\n-    Projection(ty::ProjectionTy<'tcx>),\n+    Projection(ty::AliasTy<'tcx>),\n \n     // In the case where a projection has escaping regions -- meaning\n     // regions bound within the type itself -- we always use\n@@ -130,7 +130,7 @@ fn compute_components<'tcx>(\n             // outlives any other lifetime, which is unsound.\n             // See https://github.com/rust-lang/rust/issues/84305 for\n             // more details.\n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 out.push(Component::Opaque(def_id, substs));\n             },\n \n@@ -142,7 +142,7 @@ fn compute_components<'tcx>(\n             // trait-ref. Therefore, if we see any higher-ranked regions,\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n-            ty::Projection(ref data) => {\n+            ty::Alias(ty::Projection, ref data) => {\n                 if !data.has_escaping_bound_vars() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no"}, {"sha": "da85de60199324b2d236e386699b3f235324b657", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -338,7 +338,7 @@ where\n             substs,\n             true,\n             |ty| match *ty.kind() {\n-                ty::Opaque(def_id, substs) => (def_id, substs),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => (def_id, substs),\n                 _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n             },\n         );\n@@ -349,17 +349,19 @@ where\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n+        projection_ty: ty::AliasTy<'tcx>,\n     ) {\n         self.generic_must_outlive(\n             origin,\n             region,\n             GenericKind::Projection(projection_ty),\n-            projection_ty.item_def_id,\n+            projection_ty.def_id,\n             projection_ty.substs,\n             false,\n             |ty| match ty.kind() {\n-                ty::Projection(projection_ty) => (projection_ty.item_def_id, projection_ty.substs),\n+                ty::Alias(ty::Projection, projection_ty) => {\n+                    (projection_ty.def_id, projection_ty.substs)\n+                }\n                 _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n             },\n         );"}, {"sha": "136da4a3cb12a110eaaffd96606370628219f855", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -178,7 +178,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n             ),\n             Component::Projection(projection_ty) => self.projection_opaque_bounds(\n                 GenericKind::Projection(projection_ty),\n-                projection_ty.item_def_id,\n+                projection_ty.def_id,\n                 projection_ty.substs,\n                 visited,\n             ),"}, {"sha": "4667d99ff00080daacd1ad224218c596b48fb987", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -16,12 +16,12 @@ impl<'tcx> InferCtxt<'tcx> {\n     pub fn infer_projection(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n+        projection_ty: ty::AliasTy<'tcx>,\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         obligations: &mut Vec<PredicateObligation<'tcx>>,\n     ) -> Ty<'tcx> {\n-        let def_id = projection_ty.item_def_id;\n+        let def_id = projection_ty.def_id;\n         let ty_var = self.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::NormalizeProjectionType,\n             span: self.tcx.def_span(def_id),"}, {"sha": "9a427ceacd0a7c63737805a2cb370adfa6788d7c", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -169,7 +169,7 @@ pub struct Verify<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TypeFoldable, TypeVisitable)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n-    Projection(ty::ProjectionTy<'tcx>),\n+    Projection(ty::AliasTy<'tcx>),\n     Opaque(DefId, SubstsRef<'tcx>),\n }\n \n@@ -773,7 +773,7 @@ impl<'tcx> GenericKind<'tcx> {\n     pub fn to_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n-            GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),\n+            GenericKind::Projection(ref p) => tcx.mk_projection(p.def_id, p.substs),\n             GenericKind::Opaque(def_id, substs) => tcx.mk_opaque(def_id, substs),\n         }\n     }"}, {"sha": "58e27f8b21d6366337fe89ecb46c8b5eb255f467", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -130,12 +130,16 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(self.tcx().ty_error_with_guaranteed(e))\n             }\n \n-            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+            (\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }),\n+            ) if a_def_id == b_def_id => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)\n             }\n-            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n-                if self.fields.define_opaque_types && did.is_local() =>\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }))\n+                if self.fields.define_opaque_types && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "aade57be9fe6ef1f17389df22b23518193a1a243", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -77,11 +77,11 @@ pub struct ProjectionCacheStorage<'tcx> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct ProjectionCacheKey<'tcx> {\n-    ty: ty::ProjectionTy<'tcx>,\n+    ty: ty::AliasTy<'tcx>,\n }\n \n impl<'tcx> ProjectionCacheKey<'tcx> {\n-    pub fn new(ty: ty::ProjectionTy<'tcx>) -> Self {\n+    pub fn new(ty: ty::AliasTy<'tcx>) -> Self {\n         Self { ty }\n     }\n }"}, {"sha": "8f0bd3a9abe5e29ac32a3a754f3516790bd9a4c6", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -259,8 +259,7 @@ impl<'tcx> Elaborator<'tcx> {\n                             Component::Projection(projection) => {\n                                 // We might end up here if we have `Foo<<Bar as Baz>::Assoc>: 'a`.\n                                 // With this, we can deduce that `<Bar as Baz>::Assoc: 'a`.\n-                                let ty =\n-                                    tcx.mk_projection(projection.item_def_id, projection.substs);\n+                                let ty = tcx.mk_projection(projection.def_id, projection.substs);\n                                 Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n                                     ty::OutlivesPredicate(ty, r_min),\n                                 )))"}, {"sha": "43862570e80954aa8c11dbd80e4aa4e060e66ed9", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -3016,8 +3016,8 @@ impl ClashingExternDeclarations {\n                         | (Closure(..), Closure(..))\n                         | (Generator(..), Generator(..))\n                         | (GeneratorWitness(..), GeneratorWitness(..))\n-                        | (Projection(..), Projection(..))\n-                        | (Opaque(..), Opaque(..)) => false,\n+                        | (Alias(ty::Projection, ..), Alias(ty::Projection, ..))\n+                        | (Alias(ty::Opaque, ..), Alias(ty::Opaque, ..)) => false,\n \n                         // These definitely should have been caught above.\n                         (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),"}, {"sha": "3808d308186c0ee104b8f6a41d4fbd17f621bb17", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             let Some(proj_term) = proj.term.ty() else { continue };\n \n             let proj_ty =\n-                cx.tcx.mk_projection(proj.projection_ty.item_def_id, proj.projection_ty.substs);\n+                cx.tcx.mk_projection(proj.projection_ty.def_id, proj.projection_ty.substs);\n             // For every instance of the projection type in the bounds,\n             // replace them with the term we're assigning to the associated\n             // type in our opaque type.\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             // with `impl Send: OtherTrait`.\n             for (assoc_pred, assoc_pred_span) in cx\n                 .tcx\n-                .bound_explicit_item_bounds(proj.projection_ty.item_def_id)\n+                .bound_explicit_item_bounds(proj.projection_ty.def_id)\n                 .subst_iter_copied(cx.tcx, &proj.projection_ty.substs)\n             {\n                 let assoc_pred = assoc_pred.fold_with(proj_replacer);\n@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n                     // then we can emit a suggestion to add the bound.\n                     let add_bound = match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n                         (\n-                            ty::Opaque(def_id, _),\n+                            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }),\n                             ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)),\n                         ) => Some(AddBound {\n                             suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),"}, {"sha": "8e27bc03c489aeedf8ab0b5d2cd15776c8cff157", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1139,18 +1139,20 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // While opaque types are checked for earlier, if a projection in a struct field\n             // normalizes to an opaque type, then it will reach this branch.\n-            ty::Opaque(..) => {\n+            ty::Alias(ty::Opaque, ..) => {\n                 FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_opaque, help: None }\n             }\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Projection(..) if matches!(self.mode, CItemKind::Definition) => {\n+            ty::Param(..) | ty::Alias(ty::Projection, ..)\n+                if matches!(self.mode, CItemKind::Definition) =>\n+            {\n                 FfiSafe\n             }\n \n             ty::Param(..)\n-            | ty::Projection(..)\n+            | ty::Alias(ty::Projection, ..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n             | ty::Error(_)\n@@ -1205,7 +1207,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     return ControlFlow::CONTINUE;\n                 }\n \n-                if let ty::Opaque(..) = ty.kind() {\n+                if let ty::Alias(ty::Opaque, ..) = ty.kind() {\n                     ControlFlow::Break(ty)\n                 } else {\n                     ty.super_visit_with(self)"}, {"sha": "fb2c8b1ef647c85d3e9a4679b393703be441bd9f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n \n         if let hir::ExprKind::Match(await_expr, _arms, hir::MatchSource::AwaitDesugar) = expr.kind\n             && let ty = cx.typeck_results().expr_ty(&await_expr)\n-            && let ty::Opaque(future_def_id, _) = ty.kind()\n+            && let ty::Alias(ty::Opaque, ty::AliasTy { def_id: future_def_id, substs: _ }) = ty.kind()\n             && cx.tcx.ty_is_opaque_future(ty)\n             // FIXME: This also includes non-async fns that return `impl Future`.\n             && let async_fn_def_id = cx.tcx.parent(*future_def_id)\n@@ -251,7 +251,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         .map(|inner| MustUsePath::Boxed(Box::new(inner)))\n                 }\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n-                ty::Opaque(def, _) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, substs: _ }) => {\n                     elaborate_predicates_with_span(\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),"}, {"sha": "856f5bc4645fdd34d691e7ab3a824ef603da15d1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1111,8 +1111,8 @@ fn should_encode_trait_impl_trait_tys<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) ->\n     // associated types.\n     tcx.fn_sig(trait_item_def_id).skip_binder().output().walk().any(|arg| {\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Projection(data) = ty.kind()\n-            && tcx.def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder\n+            && let ty::Alias(ty::Projection, data) = ty.kind()\n+            && tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n         {\n             true\n         } else {"}, {"sha": "d00b26a5a3d0b42baafca1d795332bbfc0ddbdcc", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -250,7 +250,7 @@ pub enum ObligationCauseCode<'tcx> {\n     TupleElem,\n \n     /// This is the trait reference from the given projection.\n-    ProjectionWf(ty::ProjectionTy<'tcx>),\n+    ProjectionWf(ty::AliasTy<'tcx>),\n \n     /// Must satisfy all of the where-clause predicates of the\n     /// given item."}, {"sha": "7380c62a6693a85166a3ed26ef4184b572c6ac39", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -76,8 +76,7 @@ pub mod type_op {\n     }\n }\n \n-pub type CanonicalProjectionGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n+pub type CanonicalProjectionGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::AliasTy<'tcx>>>;\n \n pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n \n@@ -218,6 +217,6 @@ pub struct NormalizationResult<'tcx> {\n pub enum OutlivesBound<'tcx> {\n     RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n     RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+    RegionSubProjection(ty::Region<'tcx>, ty::AliasTy<'tcx>),\n     RegionSubOpaque(ty::Region<'tcx>, DefId, SubstsRef<'tcx>),\n }"}, {"sha": "dc333b4702f39e1a2a658c88f8ddce14966db3b6", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -18,12 +18,11 @@ use crate::thir::Thir;\n use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n-    self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n+    self, AdtDef, AdtDefData, AdtKind, AliasTy, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n     ClosureSizeProfileData, Const, ConstS, DefIdTree, FloatTy, FloatVar, FloatVid,\n     GenericParamDefKind, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n-    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, ProjectionTy, Region,\n-    RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy,\n-    Visibility,\n+    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind, ReprOptions,\n+    TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy, Visibility,\n };\n use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n use rustc_ast as ast;\n@@ -116,7 +115,7 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type ListBinderExistentialPredicate = &'tcx List<PolyExistentialPredicate<'tcx>>;\n     type BinderListTy = Binder<'tcx, &'tcx List<Ty<'tcx>>>;\n     type ListTy = &'tcx List<Ty<'tcx>>;\n-    type ProjectionTy = ty::ProjectionTy<'tcx>;\n+    type AliasTy = ty::AliasTy<'tcx>;\n     type ParamTy = ParamTy;\n     type BoundTy = ty::BoundTy;\n     type PlaceholderType = ty::PlaceholderType;\n@@ -2145,8 +2144,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     Bound,\n                     Param,\n                     Infer,\n-                    Projection,\n-                    Opaque,\n+                    Alias,\n                     Foreign\n                 )?;\n \n@@ -2323,7 +2321,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Given a `ty`, return whether it's an `impl Future<...>`.\n     pub fn ty_is_opaque_future(self, ty: Ty<'_>) -> bool {\n-        let ty::Opaque(def_id, _) = ty.kind() else { return false };\n+        let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = ty.kind() else { return false };\n         let future_trait = self.require_lang_item(LangItem::Future, None);\n \n         self.explicit_item_bounds(def_id).iter().any(|(predicate, _)| {\n@@ -2598,7 +2596,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             substs.len(),\n             \"wrong number of generic parameters for {item_def_id:?}: {substs:?}\",\n         );\n-        self.mk_ty(Projection(ProjectionTy { item_def_id, substs }))\n+        self.mk_ty(Alias(ty::Projection, AliasTy { def_id: item_def_id, substs }))\n     }\n \n     #[inline]\n@@ -2668,7 +2666,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_opaque(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(Opaque(def_id, substs))\n+        self.mk_ty(Alias(ty::Opaque, ty::AliasTy { def_id, substs }))\n     }\n \n     pub fn mk_place_field(self, place: Place<'tcx>, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {"}, {"sha": "d7880a32ea9cd8f141b70ecadad0c5fca95836bd", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -3,8 +3,8 @@\n use std::ops::ControlFlow;\n \n use crate::ty::{\n-    visit::TypeVisitable, Const, ConstKind, DefIdTree, ExistentialPredicate, InferConst, InferTy,\n-    PolyTraitPredicate, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n+    visit::TypeVisitable, AliasTy, Const, ConstKind, DefIdTree, ExistentialPredicate, InferConst,\n+    InferTy, Opaque, PolyTraitPredicate, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -457,11 +457,11 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n                 return ControlFlow::Break(());\n             }\n \n-            Opaque(did, _) => {\n-                let parent = self.tcx.parent(*did);\n+            Alias(Opaque, AliasTy { def_id, substs: _ }) => {\n+                let parent = self.tcx.parent(*def_id);\n                 if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n-                    && let Opaque(parent_did, _) = self.tcx.type_of(parent).kind()\n-                    && parent_did == did\n+                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, substs: _ }) = self.tcx.type_of(parent).kind()\n+                    && parent_opaque_def_id == def_id\n                 {\n                     // Okay\n                 } else {"}, {"sha": "22dc921aba1ca13fd53a7604c6eafeb9b6eb6f08", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -337,9 +337,9 @@ impl<'tcx> Ty<'tcx> {\n             ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n-            ty::Projection(_) => \"associated type\".into(),\n+            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{}`\", p).into(),\n-            ty::Opaque(..) => \"opaque type\".into(),\n+            ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n             ty::Error(_) => \"type error\".into(),\n         }\n     }\n@@ -375,9 +375,9 @@ impl<'tcx> Ty<'tcx> {\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n-            ty::Projection(_) => \"associated type\".into(),\n+            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n             ty::Param(_) => \"type parameter\".into(),\n-            ty::Opaque(..) => \"opaque type\".into(),\n+            ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n         }\n     }\n }\n@@ -400,7 +400,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         diag.note(\"no two closures, even if identical, have the same type\");\n                         diag.help(\"consider boxing your closure and/or using it as a trait object\");\n                     }\n-                    (ty::Opaque(..), ty::Opaque(..)) => {\n+                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n                         // Issue #63167\n                         diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n                     }\n@@ -439,11 +439,11 @@ impl<'tcx> TyCtxt<'tcx> {\n                              #traits-as-parameters\",\n                         );\n                     }\n-                    (ty::Projection(_), ty::Projection(_)) => {\n+                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n                         diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n-                    (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p))\n-                        if self.def_kind(proj.item_def_id) != DefKind::ImplTraitPlaceholder =>\n+                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n+                        if self.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n                     {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n@@ -466,7 +466,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(self);\n                             let path =\n                                 self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n-                            let item_name = self.item_name(proj.item_def_id);\n+                            let item_name = self.item_name(proj.def_id);\n                             let item_args = self.format_generic_args(assoc_substs);\n \n                             let path = if path.ends_with('>') {\n@@ -493,8 +493,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                             diag.note(\"you might be missing a type parameter or trait bound\");\n                         }\n                     }\n-                    (ty::Param(p), ty::Dynamic(..) | ty::Opaque(..))\n-                    | (ty::Dynamic(..) | ty::Opaque(..), ty::Param(p)) => {\n+                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n+                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n@@ -553,7 +553,7 @@ impl<T> Trait<T> for X {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n-                    (ty::Projection(proj_ty), _) if self.def_kind(proj_ty.item_def_id) != DefKind::ImplTraitPlaceholder => {\n+                    (ty::Alias(ty::Projection, proj_ty), _) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n                         self.expected_projection(\n                             diag,\n                             proj_ty,\n@@ -562,7 +562,7 @@ impl<T> Trait<T> for X {\n                             cause.code(),\n                         );\n                     }\n-                    (_, ty::Projection(proj_ty)) if self.def_kind(proj_ty.item_def_id) != DefKind::ImplTraitPlaceholder => {\n+                    (_, ty::Alias(ty::Projection, proj_ty)) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n                         let msg = format!(\n                             \"consider constraining the associated type `{}` to `{}`\",\n                             values.found, values.expected,\n@@ -624,10 +624,10 @@ impl<T> Trait<T> for X {\n         diag: &mut Diagnostic,\n         msg: &str,\n         body_owner_def_id: DefId,\n-        proj_ty: &ty::ProjectionTy<'tcx>,\n+        proj_ty: &ty::AliasTy<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> bool {\n-        let assoc = self.associated_item(proj_ty.item_def_id);\n+        let assoc = self.associated_item(proj_ty.def_id);\n         let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n         if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n             if let Some(hir_generics) = item.generics() {\n@@ -680,7 +680,7 @@ impl<T> Trait<T> for X {\n     fn expected_projection(\n         self,\n         diag: &mut Diagnostic,\n-        proj_ty: &ty::ProjectionTy<'tcx>,\n+        proj_ty: &ty::AliasTy<'tcx>,\n         values: ExpectedFound<Ty<'tcx>>,\n         body_owner_def_id: DefId,\n         cause_code: &ObligationCauseCode<'_>,\n@@ -703,7 +703,7 @@ impl<T> Trait<T> for X {\n         );\n         let impl_comparison =\n             matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n-        let assoc = self.associated_item(proj_ty.item_def_id);\n+        let assoc = self.associated_item(proj_ty.def_id);\n         if !callable_scope || impl_comparison {\n             // We do not want to suggest calling functions when the reason of the\n             // type error is a comparison of an `impl` with its `trait` or when the\n@@ -716,7 +716,7 @@ impl<T> Trait<T> for X {\n                 diag,\n                 assoc.container_id(self),\n                 current_method_ident,\n-                proj_ty.item_def_id,\n+                proj_ty.def_id,\n                 values.expected,\n             );\n             // Possibly suggest constraining the associated type to conform to the\n@@ -775,11 +775,12 @@ fn foo(&self) -> Self::T { String::new() }\n         self,\n         diag: &mut Diagnostic,\n         msg: &str,\n-        proj_ty: &ty::ProjectionTy<'tcx>,\n+        proj_ty: &ty::AliasTy<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> bool {\n-        let assoc = self.associated_item(proj_ty.item_def_id);\n-        if let ty::Opaque(def_id, _) = *proj_ty.self_ty().kind() {\n+        let assoc = self.associated_item(proj_ty.def_id);\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *proj_ty.self_ty().kind()\n+        {\n             let opaque_local_def_id = def_id.as_local();\n             let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n                 match &self.hir().expect_item(opaque_local_def_id).kind {\n@@ -828,7 +829,7 @@ fn foo(&self) -> Self::T { String::new() }\n             .filter_map(|(_, item)| {\n                 let method = self.fn_sig(item.def_id);\n                 match *method.output().skip_binder().kind() {\n-                    ty::Projection(ty::ProjectionTy { item_def_id, .. })\n+                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n                         if item_def_id == proj_ty_item_def_id =>\n                     {\n                         Some(("}, {"sha": "44650827810abf11095901cb7907f433098996b6", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -126,7 +126,7 @@ pub fn simplify_type<'tcx>(\n             TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n             TreatParams::AsInfer => None,\n         },\n-        ty::Opaque(..) | ty::Projection(_) => match treat_params {\n+        ty::Alias(..) => match treat_params {\n             // When treating `ty::Param` as a placeholder, projections also\n             // don't unify with anything else as long as they are fully normalized.\n             //\n@@ -225,7 +225,7 @@ impl DeepRejectCtxt {\n         match impl_ty.kind() {\n             // Start by checking whether the type in the impl may unify with\n             // pretty much everything. Just return `true` in that case.\n-            ty::Param(_) | ty::Projection(_) | ty::Error(_) | ty::Opaque(..) => return true,\n+            ty::Param(_) | ty::Error(_) | ty::Alias(..) => return true,\n             // These types only unify with inference variables or their own\n             // variant.\n             ty::Bool\n@@ -323,8 +323,6 @@ impl DeepRejectCtxt {\n                 _ => false,\n             },\n \n-            ty::Opaque(..) => true,\n-\n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n \n@@ -344,7 +342,7 @@ impl DeepRejectCtxt {\n             // projections can unify with other stuff.\n             //\n             // Looking forward to lazy normalization this is the safer strategy anyways.\n-            ty::Projection(_) => true,\n+            ty::Alias(..) => true,\n \n             ty::Error(_) => true,\n "}, {"sha": "174ac74fc9e61f6e5b3cdaec8fc1b54491605092", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -155,12 +155,12 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Projection(data) => {\n+            &ty::Alias(ty::Projection, data) => {\n                 self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n-            &ty::Opaque(_, substs) => {\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, substs }) => {\n                 self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n                 self.add_substs(substs);\n             }\n@@ -345,7 +345,7 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_projection_ty(&mut self, projection_ty: ty::ProjectionTy<'_>) {\n+    fn add_projection_ty(&mut self, projection_ty: ty::AliasTy<'_>) {\n         self.add_substs(projection_ty.substs);\n     }\n "}, {"sha": "5d5089cec82a696d105c196e45d16808e20569c5", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> Ty<'tcx> {\n                 InhabitedPredicate::True\n             }\n             Never => InhabitedPredicate::False,\n-            Param(_) | Projection(_) => InhabitedPredicate::GenericType(self),\n+            Param(_) | Alias(ty::Projection, _) => InhabitedPredicate::GenericType(self),\n             Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n             // use a query for more complex cases\n             Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),"}, {"sha": "7f66b993646a32058461edd9b1063ea46a892475", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -271,7 +271,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n-                    ty::Param(_) | ty::Projection(_) => {\n+                    ty::Param(_) | ty::Alias(ty::Projection, _) => {\n                         debug_assert!(tail.has_non_region_param());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n@@ -349,7 +349,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 }\n             }\n \n-            ty::Projection(_) | ty::Opaque(..) => {\n+            ty::Alias(..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     Err(err)\n@@ -757,10 +757,9 @@ where\n                     }\n                 }\n \n-                ty::Projection(_)\n+                ty::Alias(..)\n                 | ty::Bound(..)\n                 | ty::Placeholder(..)\n-                | ty::Opaque(..)\n                 | ty::Param(_)\n                 | ty::Infer(_)\n                 | ty::Error(_) => bug!(\"TyAndLayout::field: unexpected type `{}`\", this.ty),"}, {"sha": "6cb28a0fd8077984dc8a3306034962b647cbd00c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -64,6 +64,7 @@ use std::ops::ControlFlow;\n use std::{fmt, str};\n \n pub use crate::ty::diagnostics::*;\n+pub use rustc_type_ir::AliasKind::*;\n pub use rustc_type_ir::DynKind::*;\n pub use rustc_type_ir::InferTy::*;\n pub use rustc_type_ir::RegionKind::*;\n@@ -93,14 +94,13 @@ pub use self::parameterized::ParameterizedOverTcx;\n pub use self::rvalue_scopes::RvalueScopes;\n pub use self::sty::BoundRegionKind::*;\n pub use self::sty::{\n-    Article, Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar,\n+    AliasTy, Article, Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar,\n     BoundVariableKind, CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid,\n     EarlyBoundRegion, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig,\n     FreeRegion, GenSig, GeneratorSubsts, GeneratorSubstsParts, InlineConstSubsts,\n     InlineConstSubstsParts, ParamConst, ParamTy, PolyExistentialPredicate,\n     PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef,\n-    ProjectionTy, Region, RegionKind, RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts,\n-    VarianceDiagInfo,\n+    Region, RegionKind, RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts, VarianceDiagInfo,\n };\n pub use self::trait_def::TraitDef;\n \n@@ -1010,7 +1010,7 @@ impl<'tcx> TermKind<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ProjectionPredicate<'tcx> {\n-    pub projection_ty: ProjectionTy<'tcx>,\n+    pub projection_ty: AliasTy<'tcx>,\n     pub term: Term<'tcx>,\n }\n \n@@ -1046,7 +1046,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n         // Ok to skip binder since trait `DefId` does not care about regions.\n-        self.skip_binder().projection_ty.item_def_id\n+        self.skip_binder().projection_ty.def_id\n     }\n }\n "}, {"sha": "3fad349bff8124a2f474dd73bcf105729175e9ce", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -275,10 +275,9 @@ fn characteristic_def_id_of_type_cached<'a>(\n         | ty::Uint(_)\n         | ty::Str\n         | ty::FnPtr(_)\n-        | ty::Projection(_)\n+        | ty::Alias(..)\n         | ty::Placeholder(..)\n         | ty::Param(_)\n-        | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Bound(..)\n         | ty::Error(_)"}, {"sha": "6acc2dc65d36942c7f7e53b5f8d28e12952af228", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -718,17 +718,17 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Foreign(def_id) => {\n                 p!(print_def_path(def_id, &[]));\n             }\n-            ty::Projection(ref data) => {\n+            ty::Alias(ty::Projection, ref data) => {\n                 if !(self.should_print_verbose() || NO_QUERIES.with(|q| q.get()))\n-                    && self.tcx().def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder\n+                    && self.tcx().def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n                 {\n-                    return self.pretty_print_opaque_impl_type(data.item_def_id, data.substs);\n+                    return self.pretty_print_opaque_impl_type(data.def_id, data.substs);\n                 } else {\n                     p!(print(data))\n                 }\n             }\n             ty::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 // FIXME(eddyb) print this with `print_def_path`.\n                 // We use verbose printing in 'NO_QUERIES' mode, to\n                 // avoid needing to call `predicates_of`. This should\n@@ -743,7 +743,9 @@ pub trait PrettyPrinter<'tcx>:\n                 let parent = self.tcx().parent(def_id);\n                 match self.tcx().def_kind(parent) {\n                     DefKind::TyAlias | DefKind::AssocTy => {\n-                        if let ty::Opaque(d, _) = *self.tcx().type_of(parent).kind() {\n+                        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: d, substs: _ }) =\n+                            *self.tcx().type_of(parent).kind()\n+                        {\n                             if d == def_id {\n                                 // If the type alias directly starts with the `impl` of the\n                                 // opaque type we're printing, then skip the `::{opaque#1}`.\n@@ -1019,8 +1021,8 @@ pub trait PrettyPrinter<'tcx>:\n                         // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n                         // unless we can find out what generator return type it comes from.\n                         let term = if let Some(ty) = term.skip_binder().ty()\n-                            && let ty::Projection(proj) = ty.kind()\n-                            && let Some(assoc) = tcx.opt_associated_item(proj.item_def_id)\n+                            && let ty::Alias(ty::Projection, proj) = ty.kind()\n+                            && let Some(assoc) = tcx.opt_associated_item(proj.def_id)\n                             && assoc.trait_container(tcx) == tcx.lang_items().gen_trait()\n                             && assoc.name == rustc_span::sym::Return\n                         {\n@@ -2653,7 +2655,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::ExistentialProjection<'tcx> {\n-        let name = cx.tcx().associated_item(self.item_def_id).name;\n+        let name = cx.tcx().associated_item(self.def_id).name;\n         p!(write(\"{} = \", name), print(self.term))\n     }\n \n@@ -2740,8 +2742,8 @@ define_print_and_forward_display! {\n       }\n     }\n \n-    ty::ProjectionTy<'tcx> {\n-        p!(print_def_path(self.item_def_id, self.substs));\n+    ty::AliasTy<'tcx> {\n+        p!(print_def_path(self.def_id, self.substs));\n     }\n \n     ty::ClosureKind {"}, {"sha": "1eac8859ca93487bed32fdf2d088805b2603431d", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -270,21 +270,17 @@ impl<'tcx> Relate<'tcx> for abi::Abi {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n+impl<'tcx> Relate<'tcx> for ty::AliasTy<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: ty::ProjectionTy<'tcx>,\n-        b: ty::ProjectionTy<'tcx>,\n-    ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>> {\n-        if a.item_def_id != b.item_def_id {\n-            Err(TypeError::ProjectionMismatched(expected_found(\n-                relation,\n-                a.item_def_id,\n-                b.item_def_id,\n-            )))\n+        a: ty::AliasTy<'tcx>,\n+        b: ty::AliasTy<'tcx>,\n+    ) -> RelateResult<'tcx, ty::AliasTy<'tcx>> {\n+        if a.def_id != b.def_id {\n+            Err(TypeError::ProjectionMismatched(expected_found(relation, a.def_id, b.def_id)))\n         } else {\n             let substs = relation.relate(a.substs, b.substs)?;\n-            Ok(ty::ProjectionTy { item_def_id: a.item_def_id, substs: &substs })\n+            Ok(ty::AliasTy { def_id: a.def_id, substs: &substs })\n         }\n     }\n }\n@@ -295,12 +291,8 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n         a: ty::ExistentialProjection<'tcx>,\n         b: ty::ExistentialProjection<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>> {\n-        if a.item_def_id != b.item_def_id {\n-            Err(TypeError::ProjectionMismatched(expected_found(\n-                relation,\n-                a.item_def_id,\n-                b.item_def_id,\n-            )))\n+        if a.def_id != b.def_id {\n+            Err(TypeError::ProjectionMismatched(expected_found(relation, a.def_id, b.def_id)))\n         } else {\n             let term = relation.relate_with_variance(\n                 ty::Invariant,\n@@ -314,7 +306,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 a.substs,\n                 b.substs,\n             )?;\n-            Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, term })\n+            Ok(ty::ExistentialProjection { def_id: a.def_id, substs, term })\n         }\n     }\n }\n@@ -559,14 +551,15 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         }\n \n         // these two are already handled downstream in case of lazy normalization\n-        (&ty::Projection(a_data), &ty::Projection(b_data)) => {\n+        (&ty::Alias(ty::Projection, a_data), &ty::Alias(ty::Projection, b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n-            Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n+            Ok(tcx.mk_projection(projection_ty.def_id, projection_ty.substs))\n         }\n \n-        (&ty::Opaque(a_def_id, a_substs), &ty::Opaque(b_def_id, b_substs))\n-            if a_def_id == b_def_id =>\n-        {\n+        (\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: a_substs }),\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: b_substs }),\n+        ) if a_def_id == b_def_id => {\n             if relation.intercrate() {\n                 // During coherence, opaque types should be treated as equal to each other, even if their generic params\n                 // differ, as they could resolve to the same hidden type, even for different generic params."}, {"sha": "3c6800cf293dee25e44b9b807a7c14550330f8cf", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -651,8 +651,7 @@ impl<'tcx> TypeSuperFoldable<'tcx> for Ty<'tcx> {\n             }\n             ty::GeneratorWitness(types) => ty::GeneratorWitness(types.try_fold_with(folder)?),\n             ty::Closure(did, substs) => ty::Closure(did, substs.try_fold_with(folder)?),\n-            ty::Projection(data) => ty::Projection(data.try_fold_with(folder)?),\n-            ty::Opaque(did, substs) => ty::Opaque(did, substs.try_fold_with(folder)?),\n+            ty::Alias(kind, data) => ty::Alias(kind, data.try_fold_with(folder)?),\n \n             ty::Bool\n             | ty::Char\n@@ -697,8 +696,7 @@ impl<'tcx> TypeSuperVisitable<'tcx> for Ty<'tcx> {\n             ty::Generator(_did, ref substs, _) => substs.visit_with(visitor),\n             ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n             ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n-            ty::Projection(ref data) => data.visit_with(visitor),\n-            ty::Opaque(_, ref substs) => substs.visit_with(visitor),\n+            ty::Alias(_, ref data) => data.visit_with(visitor),\n \n             ty::Bool\n             | ty::Char"}, {"sha": "27de48c1f83454e78f93baea50359551e127af32", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -693,7 +693,7 @@ impl<'tcx> ExistentialPredicate<'tcx> {\n         match (*self, *other) {\n             (Trait(_), Trait(_)) => Ordering::Equal,\n             (Projection(ref a), Projection(ref b)) => {\n-                tcx.def_path_hash(a.item_def_id).cmp(&tcx.def_path_hash(b.item_def_id))\n+                tcx.def_path_hash(a.def_id).cmp(&tcx.def_path_hash(b.def_id))\n             }\n             (AutoTrait(ref a), AutoTrait(ref b)) => {\n                 tcx.def_path_hash(*a).cmp(&tcx.def_path_hash(*b))\n@@ -1139,28 +1139,41 @@ impl<'tcx, T: IntoIterator> Binder<'tcx, T> {\n     }\n }\n \n-/// Represents the projection of an associated type. In explicit UFCS\n-/// form this would be written `<T as Trait<..>>::N`.\n+/// Represents the projection of an associated type.\n+///\n+/// For a projection, this would be `<Ty as Trait<...>>::N`.\n+///\n+/// For an opaque type, there is no explicit syntax.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub struct ProjectionTy<'tcx> {\n-    /// The parameters of the associated item.\n+pub struct AliasTy<'tcx> {\n+    /// The parameters of the associated or opaque item.\n+    ///\n+    /// For a projection, these are the substitutions for the trait and the\n+    /// GAT substitutions, if there are any.\n+    ///\n+    /// For RPIT the substitutions are for the generics of the function,\n+    /// while for TAIT it is used for the generic parameters of the alias.\n     pub substs: SubstsRef<'tcx>,\n \n-    /// The `DefId` of the `TraitItem` for the associated type `N`.\n+    /// The `DefId` of the `TraitItem` for the associated type `N` if this is a projection,\n+    /// or the `OpaqueType` item if this is an opaque.\n+    ///\n+    /// During codegen, `tcx.type_of(def_id)` can be used to get the type of the\n+    /// underlying type if the type is an opaque.\n     ///\n-    /// Note that this is not the `DefId` of the `TraitRef` containing this\n-    /// associated type, which is in `tcx.associated_item(item_def_id).container`,\n-    /// aka. `tcx.parent(item_def_id).unwrap()`.\n-    pub item_def_id: DefId,\n+    /// Note that if this is an associated type, this is not the `DefId` of the\n+    /// `TraitRef` containing this associated type, which is in `tcx.associated_item(def_id).container`,\n+    /// aka. `tcx.parent(def_id)`.\n+    pub def_id: DefId,\n }\n \n-impl<'tcx> ProjectionTy<'tcx> {\n+impl<'tcx> AliasTy<'tcx> {\n     pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n-        match tcx.def_kind(self.item_def_id) {\n-            DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.item_def_id),\n+        match tcx.def_kind(self.def_id) {\n+            DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.def_id),\n             DefKind::ImplTraitPlaceholder => {\n-                tcx.parent(tcx.impl_trait_in_trait_parent(self.item_def_id))\n+                tcx.parent(tcx.impl_trait_in_trait_parent(self.def_id))\n             }\n             kind => bug!(\"unexpected DefKind in ProjectionTy: {kind:?}\"),\n         }\n@@ -1173,11 +1186,14 @@ impl<'tcx> ProjectionTy<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {\n-        let def_id = tcx.parent(self.item_def_id);\n-        assert_eq!(tcx.def_kind(def_id), DefKind::Trait);\n-        let trait_generics = tcx.generics_of(def_id);\n+        debug_assert!(matches!(tcx.def_kind(self.def_id), DefKind::AssocTy | DefKind::AssocConst));\n+        let trait_def_id = self.trait_def_id(tcx);\n+        let trait_generics = tcx.generics_of(trait_def_id);\n         (\n-            ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, trait_generics) },\n+            ty::TraitRef {\n+                def_id: trait_def_id,\n+                substs: self.substs.truncate_to(tcx, trait_generics),\n+            },\n             &self.substs[trait_generics.count()..],\n         )\n     }\n@@ -1405,7 +1421,7 @@ impl From<BoundVar> for BoundTy {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExistentialProjection<'tcx> {\n-    pub item_def_id: DefId,\n+    pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub term: Term<'tcx>,\n }\n@@ -1418,7 +1434,7 @@ impl<'tcx> ExistentialProjection<'tcx> {\n     /// then this function would return an `exists T. T: Iterator` existential trait\n     /// reference.\n     pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::ExistentialTraitRef<'tcx> {\n-        let def_id = tcx.parent(self.item_def_id);\n+        let def_id = tcx.parent(self.def_id);\n         let subst_count = tcx.generics_of(def_id).count() - 1;\n         let substs = tcx.intern_substs(&self.substs[..subst_count]);\n         ty::ExistentialTraitRef { def_id, substs }\n@@ -1433,8 +1449,8 @@ impl<'tcx> ExistentialProjection<'tcx> {\n         debug_assert!(!self_ty.has_escaping_bound_vars());\n \n         ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n-                item_def_id: self.item_def_id,\n+            projection_ty: ty::AliasTy {\n+                def_id: self.def_id,\n                 substs: tcx.mk_substs_trait(self_ty, self.substs),\n             },\n             term: self.term,\n@@ -1449,7 +1465,7 @@ impl<'tcx> ExistentialProjection<'tcx> {\n         projection_predicate.projection_ty.substs.type_at(0);\n \n         Self {\n-            item_def_id: projection_predicate.projection_ty.item_def_id,\n+            def_id: projection_predicate.projection_ty.def_id,\n             substs: tcx.intern_substs(&projection_predicate.projection_ty.substs[1..]),\n             term: projection_predicate.term,\n         }\n@@ -1466,7 +1482,7 @@ impl<'tcx> PolyExistentialProjection<'tcx> {\n     }\n \n     pub fn item_def_id(&self) -> DefId {\n-        self.skip_binder().item_def_id\n+        self.skip_binder().def_id\n     }\n }\n \n@@ -1973,7 +1989,7 @@ impl<'tcx> Ty<'tcx> {\n \n     #[inline]\n     pub fn is_impl_trait(self) -> bool {\n-        matches!(self.kind(), Opaque(..))\n+        matches!(self.kind(), Alias(ty::Opaque, ..))\n     }\n \n     #[inline]\n@@ -2040,7 +2056,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Adt(adt, _) if adt.is_enum() => adt.repr().discr_type().to_ty(tcx),\n             ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n \n-            ty::Param(_) | ty::Projection(_) | ty::Opaque(..) | ty::Infer(ty::TyVar(_)) => {\n+            ty::Param(_) | ty::Alias(..) | ty::Infer(ty::TyVar(_)) => {\n                 let assoc_items = tcx.associated_item_def_ids(\n                     tcx.require_lang_item(hir::LangItem::DiscriminantKind, None),\n                 );\n@@ -2120,7 +2136,7 @@ impl<'tcx> Ty<'tcx> {\n \n             // type parameters only have unit metadata if they're sized, so return true\n             // to make sure we double check this during confirmation\n-            ty::Param(_) |  ty::Projection(_) | ty::Opaque(..) => (tcx.types.unit, true),\n+            ty::Param(_) |  ty::Alias(..) => (tcx.types.unit, true),\n \n             ty::Infer(ty::TyVar(_))\n             | ty::Bound(..)\n@@ -2196,7 +2212,7 @@ impl<'tcx> Ty<'tcx> {\n \n             ty::Adt(def, _substs) => def.sized_constraint(tcx).0.is_empty(),\n \n-            ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => false,\n+            ty::Alias(..) | ty::Param(_) => false,\n \n             ty::Infer(ty::TyVar(_)) => false,\n \n@@ -2252,9 +2268,12 @@ impl<'tcx> Ty<'tcx> {\n             ty::Generator(..) | ty::GeneratorWitness(..) => false,\n \n             // Might be, but not \"trivial\" so just giving the safe answer.\n-            ty::Adt(..) | ty::Closure(..) | ty::Opaque(..) => false,\n+            ty::Adt(..) | ty::Closure(..) => false,\n+\n+            // Needs normalization or revealing to determine, so no is the safe answer.\n+            ty::Alias(..) => false,\n \n-            ty::Projection(..) | ty::Param(..) | ty::Infer(..) | ty::Error(..) => false,\n+            ty::Param(..) | ty::Infer(..) | ty::Error(..) => false,\n \n             ty::Bound(..) | ty::Placeholder(..) => {\n                 bug!(\"`is_trivially_pure_clone_copy` applied to unexpected type: {:?}\", self);"}, {"sha": "b8a19e582c9dcf3fa9aec79f1fed5e16005b96fd", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n                 ty::Tuple(_) => break,\n \n-                ty::Projection(_) | ty::Opaque(..) => {\n+                ty::Alias(..) => {\n                     let normalized = normalize(ty);\n                     if ty == normalized {\n                         return ty;\n@@ -332,8 +332,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                 }\n-                (ty::Projection(_) | ty::Opaque(..), _)\n-                | (_, ty::Projection(_) | ty::Opaque(..)) => {\n+                (ty::Alias(..), _) | (_, ty::Alias(..)) => {\n                     // If either side is a projection, attempt to\n                     // progress via normalization. (Should be safe to\n                     // apply to both sides as normalization is\n@@ -826,7 +825,7 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Opaque(def_id, substs) = *t.kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) = *t.kind() {\n             self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n         } else if t.has_opaque_types() {\n             t.super_fold_with(self)\n@@ -938,10 +937,9 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n             | ty::Infer(_)\n-            | ty::Opaque(..)\n+            | ty::Alias(..)\n             | ty::Param(_)\n-            | ty::Placeholder(_)\n-            | ty::Projection(_) => false,\n+            | ty::Placeholder(_) => false,\n         }\n     }\n \n@@ -978,10 +976,9 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n             | ty::Infer(_)\n-            | ty::Opaque(..)\n+            | ty::Alias(..)\n             | ty::Param(_)\n-            | ty::Placeholder(_)\n-            | ty::Projection(_) => false,\n+            | ty::Placeholder(_) => false,\n         }\n     }\n \n@@ -1101,12 +1098,9 @@ impl<'tcx> Ty<'tcx> {\n             //\n             // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n             // called for known, fully-monomorphized types.\n-            ty::Projection(_)\n-            | ty::Opaque(..)\n-            | ty::Param(_)\n-            | ty::Bound(..)\n-            | ty::Placeholder(_)\n-            | ty::Infer(_) => false,\n+            ty::Alias(..) | ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) => {\n+                false\n+            }\n \n             ty::Foreign(_) | ty::GeneratorWitness(..) | ty::Error(_) => false,\n         }\n@@ -1237,11 +1231,10 @@ pub fn needs_drop_components<'tcx>(\n \n         // These require checking for `Copy` bounds or `Adt` destructors.\n         ty::Adt(..)\n-        | ty::Projection(..)\n+        | ty::Alias(..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n-        | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Closure(..)\n         | ty::Generator(..) => Ok(smallvec![ty]),\n@@ -1265,13 +1258,12 @@ pub fn is_trivially_const_drop<'tcx>(ty: Ty<'tcx>) -> bool {\n         | ty::Never\n         | ty::Foreign(_) => true,\n \n-        ty::Opaque(..)\n+        ty::Alias(..)\n         | ty::Dynamic(..)\n         | ty::Error(_)\n         | ty::Bound(..)\n         | ty::Param(_)\n         | ty::Placeholder(_)\n-        | ty::Projection(_)\n         | ty::Infer(_) => false,\n \n         // Not trivial because they have components, and instead of looking inside,"}, {"sha": "b302572f3cabdf3db89d88a04f8d3ba38e065f2b", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -654,7 +654,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // ignore the inputs to a projection, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n-            if let ty::Projection(..) | ty::Opaque(..) = t.kind() {\n+            if let ty::Alias(..) = t.kind() {\n                 return ControlFlow::CONTINUE;\n             }\n         }"}, {"sha": "34dbb6e9f68ea1cf6fe295448322edf3f532cea9", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -165,7 +165,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 stack.push(ty.into());\n                 stack.push(lt.into());\n             }\n-            ty::Projection(data) => {\n+            ty::Alias(_, data) => {\n                 stack.extend(data.substs.iter().rev());\n             }\n             ty::Dynamic(obj, lt, _) => {\n@@ -188,7 +188,6 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 }));\n             }\n             ty::Adt(_, substs)\n-            | ty::Opaque(_, substs)\n             | ty::Closure(_, substs)\n             | ty::Generator(_, substs, _)\n             | ty::FnDef(_, substs) => {"}, {"sha": "2643d33cee00abde2688faf2b4f25186ff8ccf6b", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -373,7 +373,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // the case of `!`, no return value is required, as the block will never return.\n             // Opaque types of empty bodies also need this unit assignment, in order to infer that their\n             // type is actually unit. Otherwise there will be no defining use found in the MIR.\n-            if destination_ty.is_unit() || matches!(destination_ty.kind(), ty::Opaque(..)) {\n+            if destination_ty.is_unit()\n+                || matches!(destination_ty.kind(), ty::Alias(ty::Opaque, ..))\n+            {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination, this.tcx);"}, {"sha": "7e1f708b0d6a1685f01257e69c479cb20097bbc9", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 ty::Dynamic(..) => {\n                     \"trait objects cannot be used in patterns\".to_string()\n                 }\n-                ty::Opaque(..) => {\n+                ty::Alias(ty::Opaque, ..) => {\n                     \"opaque types cannot be used in patterns\".to_string()\n                 }\n                 ty::Closure(..) => {"}, {"sha": "8f80cb95e58e70ff3512a5c95c93977c3e3490af", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -845,7 +845,7 @@ fn is_useful<'p, 'tcx>(\n \n         // Opaque types can't get destructured/split, but the patterns can\n         // actually hint at hidden types, so we use the patterns' types instead.\n-        if let ty::Opaque(..) = ty.kind() {\n+        if let ty::Alias(ty::Opaque, ..) = ty.kind() {\n             if let Some(row) = rows.first() {\n                 ty = row.head().ty();\n             }"}, {"sha": "ef7589d3ef2315f9bbf21e9c880c5f03e4e39122", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -849,7 +849,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n             };\n \n             let kind = match parent_ty.ty.kind() {\n-                &ty::Opaque(def_id, substs) => {\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                     self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n                 }\n                 kind => kind,"}, {"sha": "6cabef92d8c2190e7f31514eb319eee727dcc9c2", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -52,7 +52,11 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n fn maybe_zst(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n         // maybe ZST (could be more precise)\n-        ty::Adt(..) | ty::Array(..) | ty::Closure(..) | ty::Tuple(..) | ty::Opaque(..) => true,\n+        ty::Adt(..)\n+        | ty::Array(..)\n+        | ty::Closure(..)\n+        | ty::Tuple(..)\n+        | ty::Alias(ty::Opaque, ..) => true,\n         // definitely ZST\n         ty::FnDef(..) | ty::Never => true,\n         // unreachable or can't be ZST"}, {"sha": "d80c05d6b38268d734924a5b7d5a95732eb3be40", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -88,10 +88,7 @@ trait DefIdVisitor<'tcx> {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.skeleton().visit_trait(trait_ref)\n     }\n-    fn visit_projection_ty(\n-        &mut self,\n-        projection: ty::ProjectionTy<'tcx>,\n-    ) -> ControlFlow<Self::BreakTy> {\n+    fn visit_projection_ty(&mut self, projection: ty::AliasTy<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.skeleton().visit_projection_ty(projection)\n     }\n     fn visit_predicates(\n@@ -118,18 +115,15 @@ where\n         if self.def_id_visitor.shallow() { ControlFlow::CONTINUE } else { substs.visit_with(self) }\n     }\n \n-    fn visit_projection_ty(\n-        &mut self,\n-        projection: ty::ProjectionTy<'tcx>,\n-    ) -> ControlFlow<V::BreakTy> {\n+    fn visit_projection_ty(&mut self, projection: ty::AliasTy<'tcx>) -> ControlFlow<V::BreakTy> {\n         let tcx = self.def_id_visitor.tcx();\n-        let (trait_ref, assoc_substs) = if tcx.def_kind(projection.item_def_id)\n+        let (trait_ref, assoc_substs) = if tcx.def_kind(projection.def_id)\n             != DefKind::ImplTraitPlaceholder\n         {\n             projection.trait_ref_and_own_substs(tcx)\n         } else {\n             // HACK(RPITIT): Remove this when RPITITs are lowered to regular assoc tys\n-            let def_id = tcx.impl_trait_in_trait_parent(projection.item_def_id);\n+            let def_id = tcx.impl_trait_in_trait_parent(projection.def_id);\n             let trait_generics = tcx.generics_of(def_id);\n             (\n                 ty::TraitRef { def_id, substs: projection.substs.truncate_to(tcx, trait_generics) },\n@@ -214,7 +208,7 @@ where\n                     }\n                 }\n             }\n-            ty::Projection(proj) => {\n+            ty::Alias(ty::Projection, proj) => {\n                 if self.def_id_visitor.skip_assoc_tys() {\n                     // Visitors searching for minimal visibility/reachability want to\n                     // conservatively approximate associated types like `<Type as Trait>::Alias`\n@@ -241,7 +235,7 @@ where\n                     self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref)?;\n                 }\n             }\n-            ty::Opaque(def_id, ..) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => {\n                 // Skip repeated `Opaque`s to avoid infinite recursion.\n                 if self.visited_opaque_tys.insert(def_id) {\n                     // The intent is to treat `impl Trait1 + Trait2` identically to"}, {"sha": "281b2d88f483bd66bd16e2994fad7df908f79619", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -216,8 +216,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n         match *ty.kind() {\n             // Print all nominal types as paths (unlike `pretty_print_type`).\n             ty::FnDef(def_id, substs)\n-            | ty::Opaque(def_id, substs)\n-            | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n+            | ty::Alias(_, ty::AliasTy { def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n \n@@ -287,11 +286,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n         // Similar to `pretty_path_qualified`, but for the other\n         // types that are printed as paths (see `print_type` above).\n         match self_ty.kind() {\n-            ty::FnDef(..)\n-            | ty::Opaque(..)\n-            | ty::Projection(_)\n-            | ty::Closure(..)\n-            | ty::Generator(..)\n+            ty::FnDef(..) | ty::Alias(..) | ty::Closure(..) | ty::Generator(..)\n                 if trait_ref.is_none() =>\n             {\n                 self.print_type(self_ty)"}, {"sha": "c9ddb084d63a12d2f5198bae6c2f19ec3493a12b", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -240,7 +240,7 @@ fn encode_predicate<'tcx>(\n             s.push_str(&encode_substs(tcx, trait_ref.substs, dict, options));\n         }\n         ty::ExistentialPredicate::Projection(projection) => {\n-            let name = encode_ty_name(tcx, projection.item_def_id);\n+            let name = encode_ty_name(tcx, projection.def_id);\n             let _ = write!(s, \"u{}{}\", name.len(), &name);\n             s.push_str(&encode_substs(tcx, projection.substs, dict, options));\n             match projection.term.unpack() {\n@@ -646,10 +646,9 @@ fn encode_ty<'tcx>(\n         | ty::Error(..)\n         | ty::GeneratorWitness(..)\n         | ty::Infer(..)\n-        | ty::Opaque(..)\n+        | ty::Alias(..)\n         | ty::Param(..)\n-        | ty::Placeholder(..)\n-        | ty::Projection(..) => {\n+        | ty::Placeholder(..) => {\n             bug!(\"encode_ty: unexpected `{:?}`\", ty.kind());\n         }\n     };\n@@ -799,10 +798,9 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n         | ty::Error(..)\n         | ty::GeneratorWitness(..)\n         | ty::Infer(..)\n-        | ty::Opaque(..)\n+        | ty::Alias(..)\n         | ty::Param(..)\n-        | ty::Placeholder(..)\n-        | ty::Projection(..) => {\n+        | ty::Placeholder(..) => {\n             bug!(\"transform_ty: unexpected `{:?}`\", ty.kind());\n         }\n     }"}, {"sha": "b7f055d9146a05c30dc41af17d8c5ebe0e34c938", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -439,8 +439,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             // Mangle all nominal types as paths.\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n-            | ty::Opaque(def_id, substs)\n-            | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n+            | ty::Alias(_, ty::AliasTy { def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => {\n                 self = self.print_def_path(def_id, substs)?;\n@@ -544,7 +543,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                         cx = cx.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n                     }\n                     ty::ExistentialPredicate::Projection(projection) => {\n-                        let name = cx.tcx.associated_item(projection.item_def_id).name;\n+                        let name = cx.tcx.associated_item(projection.def_id).name;\n                         cx.push(\"p\");\n                         cx.push_ident(name.as_str());\n                         cx = match projection.term.unpack() {"}, {"sha": "aef2f8ff9911cc90b565bf27c02d946d0ffcd766", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -579,14 +579,14 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     pub fn is_of_param(&self, ty: Ty<'_>) -> bool {\n         match ty.kind() {\n             ty::Param(_) => true,\n-            ty::Projection(p) => self.is_of_param(p.self_ty()),\n+            ty::Alias(ty::Projection, p) => self.is_of_param(p.self_ty()),\n             _ => false,\n         }\n     }\n \n     fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n         if let Some(ty) = p.term().skip_binder().ty() {\n-            matches!(ty.kind(), ty::Projection(proj) if proj == &p.skip_binder().projection_ty)\n+            matches!(ty.kind(), ty::Alias(ty::Projection, proj) if proj == &p.skip_binder().projection_ty)\n         } else {\n             false\n         }"}, {"sha": "7c569621cfeb85ab3b64cd2c2bc05c3b045180f5", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -659,7 +659,7 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n             | ty::RawPtr(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Projection(..) => self.found_non_local_ty(ty),\n+            | ty::Alias(ty::Projection, ..) => self.found_non_local_ty(ty),\n \n             ty::Param(..) => self.found_param_ty(ty),\n \n@@ -704,7 +704,7 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n                 );\n                 ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n             }\n-            ty::Opaque(..) => {\n+            ty::Alias(ty::Opaque, ..) => {\n                 // This merits some explanation.\n                 // Normally, opaque types are not involved when performing\n                 // coherence checking, since it is illegal to directly"}, {"sha": "19a1f2481770067250878c92e734e436c2d0f4d4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1636,8 +1636,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let normalized_ty = ocx.normalize(\n                     &obligation.cause,\n                     obligation.param_env,\n-                    self.tcx\n-                        .mk_projection(data.projection_ty.item_def_id, data.projection_ty.substs),\n+                    self.tcx.mk_projection(data.projection_ty.def_id, data.projection_ty.substs),\n                 );\n \n                 debug!(?obligation.cause, ?obligation.param_env);\n@@ -1688,10 +1687,10 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let secondary_span = match predicate.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => self\n                     .tcx\n-                    .opt_associated_item(proj.projection_ty.item_def_id)\n+                    .opt_associated_item(proj.projection_ty.def_id)\n                     .and_then(|trait_assoc_item| {\n                         self.tcx\n-                            .trait_of_item(proj.projection_ty.item_def_id)\n+                            .trait_of_item(proj.projection_ty.def_id)\n                             .map(|id| (trait_assoc_item, id))\n                     })\n                     .and_then(|(trait_assoc_item, id)| {\n@@ -1747,7 +1746,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let trait_def_id = pred.projection_ty.trait_def_id(self.tcx);\n         let self_ty = pred.projection_ty.self_ty();\n \n-        if Some(pred.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output() {\n+        if Some(pred.projection_ty.def_id) == self.tcx.lang_items().fn_once_output() {\n             Some(format!(\n                 \"expected `{self_ty}` to be a {fn_kind} that returns `{expected_ty}`, but it returns `{normalized_ty}`\",\n                 fn_kind = self_ty.prefix_string(self.tcx)\n@@ -1790,8 +1789,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ty::Closure(..) => Some(9),\n                 ty::Tuple(..) => Some(10),\n                 ty::Param(..) => Some(11),\n-                ty::Projection(..) => Some(12),\n-                ty::Opaque(..) => Some(13),\n+                ty::Alias(ty::Projection, ..) => Some(12),\n+                ty::Alias(ty::Opaque, ..) => Some(13),\n                 ty::Never => Some(14),\n                 ty::Adt(..) => Some(15),\n                 ty::Generator(..) => Some(16),"}, {"sha": "e17c3777485780eeb6a02664ad48e6f86b058b16", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -371,7 +371,7 @@ fn suggest_restriction<'tcx>(\n     msg: &str,\n     err: &mut Diagnostic,\n     fn_sig: Option<&hir::FnSig<'_>>,\n-    projection: Option<&ty::ProjectionTy<'_>>,\n+    projection: Option<&ty::AliasTy<'_>>,\n     trait_pred: ty::PolyTraitPredicate<'tcx>,\n     // When we are dealing with a trait, `super_traits` will be `Some`:\n     // Given `trait T: A + B + C {}`\n@@ -497,7 +497,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let self_ty = trait_pred.skip_binder().self_ty();\n         let (param_ty, projection) = match self_ty.kind() {\n             ty::Param(_) => (true, None),\n-            ty::Projection(projection) => (false, Some(projection)),\n+            ty::Alias(ty::Projection, projection) => (false, Some(projection)),\n             _ => (false, None),\n         };\n \n@@ -857,10 +857,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     fn_sig.inputs().map_bound(|inputs| &inputs[1..]),\n                 ))\n             }\n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n                     if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                    && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n                     // args tuple will always be substs[1]\n                     && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n                     {\n@@ -877,7 +877,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ty::Dynamic(data, _, ty::Dyn) => {\n                 data.iter().find_map(|pred| {\n                     if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                    && Some(proj.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                    && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n                     // for existential projection, substs are shifted over by 1\n                     && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n                     {\n@@ -894,7 +894,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ty::Param(_) => {\n                 obligation.param_env.caller_bounds().iter().find_map(|pred| {\n                     if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                    && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n                     && proj.projection_ty.self_ty() == found\n                     // args tuple will always be substs[1]\n                     && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n@@ -2641,7 +2641,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 Some(ident) => err.span_note(ident.span, &msg),\n                                 None => err.note(&msg),\n                             },\n-                            ty::Opaque(def_id, _) => {\n+                            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => {\n                                 // Avoid printing the future from `core::future::identity_future`, it's not helpful\n                                 if tcx.parent(*def_id) == identity_future {\n                                     break 'print;\n@@ -3218,7 +3218,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n             for diff in &type_diffs {\n                 let Sorts(expected_found) = diff else { continue; };\n-                let ty::Projection(proj) = expected_found.expected.kind() else { continue; };\n+                let ty::Alias(ty::Projection, proj) = expected_found.expected.kind() else { continue; };\n \n                 let origin =\n                     TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n@@ -3245,7 +3245,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // This corresponds to `<ExprTy as Iterator>::Item = _`.\n                 let trait_ref = ty::Binder::dummy(ty::PredicateKind::Clause(\n                     ty::Clause::Projection(ty::ProjectionPredicate {\n-                        projection_ty: ty::ProjectionTy { substs, item_def_id: proj.item_def_id },\n+                        projection_ty: ty::AliasTy { substs, def_id: proj.def_id },\n                         term: ty_var.into(),\n                     }),\n                 ));\n@@ -3260,7 +3260,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if ocx.select_where_possible().is_empty() {\n                     // `ty_var` now holds the type that `Item` is for `ExprTy`.\n                     let ty_var = self.resolve_vars_if_possible(ty_var);\n-                    assocs_in_this_method.push(Some((span, (proj.item_def_id, ty_var))));\n+                    assocs_in_this_method.push(Some((span, (proj.def_id, ty_var))));\n                 } else {\n                     // `<ExprTy as Iterator>` didn't select, so likely we've\n                     // reached the end of the iterator chain, like the originating"}, {"sha": "3e85ea69635e645c953b4e3eec401e1f3390e318", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -589,7 +589,7 @@ fn object_ty_for_trait<'tcx>(\n             let pred = obligation.predicate.to_opt_poly_projection_pred()?;\n             Some(pred.map_bound(|p| {\n                 ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n-                    item_def_id: p.projection_ty.item_def_id,\n+                    def_id: p.projection_ty.def_id,\n                     substs: p.projection_ty.substs,\n                     term: p.term,\n                 })\n@@ -794,13 +794,13 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n                         ControlFlow::CONTINUE\n                     }\n                 }\n-                ty::Projection(ref data)\n-                    if self.tcx.def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+                ty::Alias(ty::Projection, ref data)\n+                    if self.tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder =>\n                 {\n                     // We'll deny these later in their own pass\n                     ControlFlow::CONTINUE\n                 }\n-                ty::Projection(ref data) => {\n+                ty::Alias(ty::Projection, ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n                     // Compute supertraits of current trait lazily.\n@@ -861,10 +861,10 @@ pub fn contains_illegal_impl_trait_in_trait<'tcx>(\n     // FIXME(RPITIT): Perhaps we should use a visitor here?\n     ty.skip_binder().walk().find_map(|arg| {\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Projection(proj) = ty.kind()\n-            && tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n+            && let ty::Alias(ty::Projection, proj) = ty.kind()\n+            && tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n         {\n-            Some(MethodViolationCode::ReferencesImplTraitInTrait(tcx.def_span(proj.item_def_id)))\n+            Some(MethodViolationCode::ReferencesImplTraitInTrait(tcx.def_span(proj.def_id)))\n         } else {\n             None\n         }"}, {"sha": "ca9ee04c58c10d2b1811ab8c172615d4ba1bfabf", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -45,7 +45,7 @@ pub type PolyProjectionObligation<'tcx> = Obligation<'tcx, ty::PolyProjectionPre\n \n pub type ProjectionObligation<'tcx> = Obligation<'tcx, ty::ProjectionPredicate<'tcx>>;\n \n-pub type ProjectionTyObligation<'tcx> = Obligation<'tcx, ty::ProjectionTy<'tcx>>;\n+pub type ProjectionTyObligation<'tcx> = Obligation<'tcx, ty::AliasTy<'tcx>>;\n \n pub(super) struct InProgress;\n \n@@ -496,7 +496,9 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs })\n+                if !substs.has_escaping_bound_vars() =>\n+            {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n@@ -523,7 +525,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Projection(data) if !data.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n                 // This branch is *mostly* just an optimization: when we don't\n                 // have escaping bound vars, we don't need to replace them with\n                 // placeholders (see branch below). *Also*, we know that we can\n@@ -562,7 +564,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 normalized_ty.ty().unwrap()\n             }\n \n-            ty::Projection(data) => {\n+            ty::Alias(ty::Projection, data) => {\n                 // If there are escaping bound vars, we temporarily replace the\n                 // bound vars with placeholders. Note though, that in the case\n                 // that we still can't project for whatever reason (e.g. self\n@@ -957,7 +959,7 @@ impl<'tcx> TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n pub fn normalize_projection_type<'a, 'b, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n+    projection_ty: ty::AliasTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n@@ -995,7 +997,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n+    projection_ty: ty::AliasTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n@@ -1177,7 +1179,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n fn normalize_to_error<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n+    projection_ty: ty::AliasTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n ) -> NormalizedTy<'tcx> {\n@@ -1189,10 +1191,9 @@ fn normalize_to_error<'a, 'tcx>(\n         predicate: trait_ref.without_const().to_predicate(selcx.tcx()),\n     };\n     let tcx = selcx.infcx.tcx;\n-    let def_id = projection_ty.item_def_id;\n     let new_value = selcx.infcx.next_ty_var(TypeVariableOrigin {\n         kind: TypeVariableOriginKind::NormalizeProjectionType,\n-        span: tcx.def_span(def_id),\n+        span: tcx.def_span(projection_ty.def_id),\n     });\n     Normalized { value: new_value, obligations: vec![trait_obligation] }\n }\n@@ -1270,7 +1271,7 @@ fn project<'cx, 'tcx>(\n             // need to investigate whether or not this is fine.\n             selcx\n                 .tcx()\n-                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs)\n+                .mk_projection(obligation.predicate.def_id, obligation.predicate.substs)\n                 .into(),\n         )),\n         // Error occurred while trying to processing impls.\n@@ -1290,13 +1291,12 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n     candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n     let tcx = selcx.tcx();\n-    if tcx.def_kind(obligation.predicate.item_def_id) == DefKind::ImplTraitPlaceholder {\n-        let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.item_def_id);\n+    if tcx.def_kind(obligation.predicate.def_id) == DefKind::ImplTraitPlaceholder {\n+        let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.def_id);\n         // If we are trying to project an RPITIT with trait's default `Self` parameter,\n         // then we must be within a default trait body.\n         if obligation.predicate.self_ty()\n-            == ty::InternalSubsts::identity_for_item(tcx, obligation.predicate.item_def_id)\n-                .type_at(0)\n+            == ty::InternalSubsts::identity_for_item(tcx, obligation.predicate.def_id).type_at(0)\n             && tcx.associated_item(trait_fn_def_id).defaultness(tcx).has_value()\n         {\n             candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(\n@@ -1377,8 +1377,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let bounds = match *obligation.predicate.self_ty().kind() {\n-        ty::Projection(ref data) => tcx.bound_item_bounds(data.item_def_id).subst(tcx, data.substs),\n-        ty::Opaque(def_id, substs) => tcx.bound_item_bounds(def_id).subst(tcx, substs),\n+        ty::Alias(_, ref data) => tcx.bound_item_bounds(data.def_id).subst(tcx, data.substs),\n         ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n@@ -1430,7 +1429,7 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     };\n     let env_predicates = data\n         .projection_bounds()\n-        .filter(|bound| bound.item_def_id() == obligation.predicate.item_def_id)\n+        .filter(|bound| bound.item_def_id() == obligation.predicate.def_id)\n         .map(|p| p.with_self_ty(tcx, object_ty).to_predicate(tcx));\n \n     assemble_candidates_from_predicates(\n@@ -1462,7 +1461,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n             predicate.kind().skip_binder()\n         {\n             let data = bound_predicate.rebind(data);\n-            if data.projection_def_id() != obligation.predicate.item_def_id {\n+            if data.projection_def_id() != obligation.predicate.def_id {\n                 continue;\n             }\n \n@@ -1503,7 +1502,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n     candidate_set: &mut ProjectionCandidateSet<'tcx>,\n ) {\n     // Can't assemble candidate from impl for RPITIT\n-    if selcx.tcx().def_kind(obligation.predicate.item_def_id) == DefKind::ImplTraitPlaceholder {\n+    if selcx.tcx().def_kind(obligation.predicate.def_id) == DefKind::ImplTraitPlaceholder {\n         return;\n     }\n \n@@ -1555,7 +1554,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // NOTE: This should be kept in sync with the similar code in\n                 // `rustc_ty_utils::instance::resolve_associated_item()`.\n                 let node_item =\n-                    assoc_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n+                    assoc_def(selcx, impl_data.impl_def_id, obligation.predicate.def_id)\n                         .map_err(|ErrorGuaranteed { .. }| ())?;\n \n                 if node_item.is_final() {\n@@ -1616,8 +1615,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                          // type parameters, opaques, and unnormalized projections have pointer\n                         // metadata if they're known (e.g. by the param_env) to be sized\n                         ty::Param(_)\n-                        | ty::Projection(..)\n-                        | ty::Opaque(..)\n+                        | ty::Alias(..)\n                         | ty::Bound(..)\n                         | ty::Placeholder(..)\n                         | ty::Infer(..)\n@@ -1671,7 +1669,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n \n                         // type parameters, opaques, and unnormalized projections have pointer\n                         // metadata if they're known (e.g. by the param_env) to be sized\n-                        ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n+                        ty::Param(_) | ty::Alias(..)\n                             if selcx.infcx.predicate_must_hold_modulo_regions(\n                                 &obligation.with(\n                                     selcx.tcx(),\n@@ -1687,8 +1685,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n \n                         // FIXME(compiler-errors): are Bound and Placeholder types ever known sized?\n                         ty::Param(_)\n-                        | ty::Projection(..)\n-                        | ty::Opaque(..)\n+                        | ty::Alias(..)\n                         | ty::Bound(..)\n                         | ty::Placeholder(..)\n                         | ty::Infer(..)\n@@ -1788,7 +1785,7 @@ fn confirm_candidate<'cx, 'tcx>(\n         ProjectionCandidate::ImplTraitInTrait(ImplTraitInTraitCandidate::Trait) => Progress {\n             term: selcx\n                 .tcx()\n-                .mk_opaque(obligation.predicate.item_def_id, obligation.predicate.substs)\n+                .mk_opaque(obligation.predicate.def_id, obligation.predicate.substs)\n                 .into(),\n             obligations: vec![],\n         },\n@@ -1860,7 +1857,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         gen_sig,\n     )\n     .map_bound(|(trait_ref, yield_ty, return_ty)| {\n-        let name = tcx.associated_item(obligation.predicate.item_def_id).name;\n+        let name = tcx.associated_item(obligation.predicate.def_id).name;\n         let ty = if name == sym::Return {\n             return_ty\n         } else if name == sym::Yield {\n@@ -1870,9 +1867,9 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         };\n \n         ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n+            projection_ty: ty::AliasTy {\n                 substs: trait_ref.substs,\n-                item_def_id: obligation.predicate.item_def_id,\n+                def_id: obligation.predicate.def_id,\n             },\n             term: ty.into(),\n         }\n@@ -1909,12 +1906,12 @@ fn confirm_future_candidate<'cx, 'tcx>(\n         gen_sig,\n     )\n     .map_bound(|(trait_ref, return_ty)| {\n-        debug_assert_eq!(tcx.associated_item(obligation.predicate.item_def_id).name, sym::Output);\n+        debug_assert_eq!(tcx.associated_item(obligation.predicate.def_id).name, sym::Output);\n \n         ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n+            projection_ty: ty::AliasTy {\n                 substs: trait_ref.substs,\n-                item_def_id: obligation.predicate.item_def_id,\n+                def_id: obligation.predicate.def_id,\n             },\n             term: return_ty.into(),\n         }\n@@ -1934,7 +1931,7 @@ fn confirm_builtin_candidate<'cx, 'tcx>(\n     let self_ty = obligation.predicate.self_ty();\n     let substs = tcx.mk_substs([self_ty.into()].iter());\n     let lang_items = tcx.lang_items();\n-    let item_def_id = obligation.predicate.item_def_id;\n+    let item_def_id = obligation.predicate.def_id;\n     let trait_def_id = tcx.trait_of_item(item_def_id).unwrap();\n     let (term, obligations) = if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n         let discriminant_def_id = tcx.require_lang_item(LangItem::Discriminant, None);\n@@ -1968,8 +1965,10 @@ fn confirm_builtin_candidate<'cx, 'tcx>(\n         bug!(\"unexpected builtin trait with associated type: {:?}\", obligation.predicate);\n     };\n \n-    let predicate =\n-        ty::ProjectionPredicate { projection_ty: ty::ProjectionTy { substs, item_def_id }, term };\n+    let predicate = ty::ProjectionPredicate {\n+        projection_ty: ty::AliasTy { substs, def_id: item_def_id },\n+        term,\n+    };\n \n     confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n         .with_addl_obligations(obligations)\n@@ -2038,10 +2037,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n         flag,\n     )\n     .map_bound(|(trait_ref, ret_type)| ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy {\n-            substs: trait_ref.substs,\n-            item_def_id: fn_once_output_def_id,\n-        },\n+        projection_ty: ty::AliasTy { substs: trait_ref.substs, def_id: fn_once_output_def_id },\n         term: ret_type.into(),\n     });\n \n@@ -2122,7 +2118,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let tcx = selcx.tcx();\n \n     let ImplSourceUserDefinedData { impl_def_id, substs, mut nested } = impl_impl_source;\n-    let assoc_item_id = obligation.predicate.item_def_id;\n+    let assoc_item_id = obligation.predicate.def_id;\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n@@ -2222,7 +2218,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let tcx = selcx.tcx();\n     let mut obligations = data.nested;\n \n-    let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.item_def_id);\n+    let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.def_id);\n     let Ok(leaf_def) = assoc_def(selcx, data.impl_def_id, trait_fn_def_id) else {\n         return Progress { term: tcx.ty_error().into(), obligations };\n     };\n@@ -2233,9 +2229,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     // Use the default `impl Trait` for the trait, e.g., for a default trait body\n     if leaf_def.item.container == ty::AssocItemContainer::TraitContainer {\n         return Progress {\n-            term: tcx\n-                .mk_opaque(obligation.predicate.item_def_id, obligation.predicate.substs)\n-                .into(),\n+            term: tcx.mk_opaque(obligation.predicate.def_id, obligation.predicate.substs).into(),\n             obligations,\n         };\n     }\n@@ -2302,7 +2296,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         obligation.recursion_depth + 1,\n         tcx.bound_trait_impl_trait_tys(impl_fn_def_id)\n             .map_bound(|tys| {\n-                tys.map_or_else(|_| tcx.ty_error(), |tys| tys[&obligation.predicate.item_def_id])\n+                tys.map_or_else(|_| tcx.ty_error(), |tys| tys[&obligation.predicate.def_id])\n             })\n             .subst(tcx, impl_fn_substs),\n         &mut obligations,\n@@ -2320,7 +2314,7 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n ) {\n     let tcx = selcx.tcx();\n     let own = tcx\n-        .predicates_of(obligation.predicate.item_def_id)\n+        .predicates_of(obligation.predicate.def_id)\n         .instantiate_own(tcx, obligation.predicate.substs);\n     for (predicate, span) in std::iter::zip(own.predicates, own.spans) {\n         let normalized = normalize_with_depth_to(\n@@ -2343,13 +2337,13 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n             ObligationCause::new(\n                 obligation.cause.span,\n                 obligation.cause.body_id,\n-                super::ItemObligation(obligation.predicate.item_def_id),\n+                super::ItemObligation(obligation.predicate.def_id),\n             )\n         } else {\n             ObligationCause::new(\n                 obligation.cause.span,\n                 obligation.cause.body_id,\n-                super::BindingObligation(obligation.predicate.item_def_id, span),\n+                super::BindingObligation(obligation.predicate.def_id, span),\n             )\n         };\n         nested.push(Obligation::with_depth("}, {"sha": "0f21813bc40ae1a85dfd1185f7199ecd2eec708a", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -62,9 +62,8 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n         // The following *might* require a destructor: needs deeper inspection.\n         ty::Dynamic(..)\n-        | ty::Projection(..)\n+        | ty::Alias(..)\n         | ty::Param(_)\n-        | ty::Opaque(..)\n         | ty::Placeholder(..)\n         | ty::Infer(_)\n         | ty::Bound(..)"}, {"sha": "777de195895b89de6c9f1e50c422de074b842bed", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -205,7 +205,9 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs })\n+                if !substs.has_escaping_bound_vars() =>\n+            {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.try_super_fold_with(self),\n@@ -242,7 +244,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Projection(data) if !data.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n                 // This branch is just an optimization: when we don't have escaping bound vars,\n                 // we don't need to replace them with placeholders (see branch below).\n \n@@ -291,7 +293,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Projection(data) => {\n+            ty::Alias(ty::Projection, data) => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n                 let tcx = self.infcx.tcx;"}, {"sha": "829d4f60986054141a68d95400b1f34746e3df28", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -138,7 +138,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Before we go into the whole placeholder thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.skip_binder().trait_ref.self_ty().kind() {\n-            ty::Projection(_) | ty::Opaque(..) => {}\n+            ty::Alias(..) => {}\n             ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -394,7 +394,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // still be provided by a manual implementation for\n                     // this trait and type.\n                 }\n-                ty::Param(..) | ty::Projection(..) => {\n+                ty::Param(..) | ty::Alias(ty::Projection, ..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -536,10 +536,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let ty = traits::normalize_projection_type(\n                 self,\n                 param_env,\n-                ty::ProjectionTy {\n-                    item_def_id: tcx.lang_items().deref_target()?,\n-                    substs: trait_ref.substs,\n-                },\n+                ty::AliasTy { def_id: tcx.lang_items().deref_target()?, substs: trait_ref.substs },\n                 cause.clone(),\n                 0,\n                 // We're *intentionally* throwing these away,\n@@ -737,13 +734,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.skip_binder().kind() {\n-            ty::Opaque(..)\n+            ty::Alias(..)\n             | ty::Dynamic(..)\n             | ty::Error(_)\n             | ty::Bound(..)\n             | ty::Param(_)\n-            | ty::Placeholder(_)\n-            | ty::Projection(_) => {\n+            | ty::Placeholder(_) => {\n                 // We don't know if these are `~const Destruct`, at least\n                 // not structurally... so don't push a candidate.\n             }\n@@ -829,8 +825,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Generator(_, _, _)\n             | ty::GeneratorWitness(_)\n             | ty::Never\n-            | ty::Projection(_)\n-            | ty::Opaque(_, _)\n+            | ty::Alias(..)\n             | ty::Param(_)\n             | ty::Bound(_, _)\n             | ty::Error(_)"}, {"sha": "85456853ce08c66cffd744c7112974852a37b043", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -155,8 +155,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n         let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n         let (def_id, substs) = match *placeholder_self_ty.kind() {\n-            ty::Projection(proj) => (proj.item_def_id, proj.substs),\n-            ty::Opaque(def_id, substs) => (def_id, substs),\n+            ty::Alias(_, ty::AliasTy { def_id, substs }) => (def_id, substs),\n             _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n         };\n \n@@ -184,7 +183,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 .map_err(|_| Unimplemented)\n         })?);\n \n-        if let ty::Projection(..) = placeholder_self_ty.kind() {\n+        if let ty::Alias(ty::Projection, ..) = placeholder_self_ty.kind() {\n             let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates;\n             debug!(?predicates, \"projection predicates\");\n             for predicate in predicates {\n@@ -1279,7 +1278,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // If we have a projection type, make sure to normalize it so we replace it\n                 // with a fresh infer variable\n-                ty::Projection(..) => {\n+                ty::Alias(ty::Projection, ..) => {\n                     let predicate = normalize_with_depth_to(\n                         self,\n                         obligation.param_env,"}, {"sha": "115897851d67317e8ad4670714e864e4ae28131c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1595,8 +1595,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n         let (def_id, substs) = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n-            ty::Projection(ref data) => (data.item_def_id, data.substs),\n-            ty::Opaque(def_id, substs) => (def_id, substs),\n+            ty::Alias(_, ty::AliasTy { def_id, substs }) => (def_id, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -1745,7 +1744,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             });\n \n         if is_match {\n-            let generics = self.tcx().generics_of(obligation.predicate.item_def_id);\n+            let generics = self.tcx().generics_of(obligation.predicate.def_id);\n             // FIXME(generic-associated-types): Addresses aggressive inference in #92917.\n             // If this type is a GAT, and of the GAT substs resolve to something new,\n             // that means that we must have newly inferred something about the GAT.\n@@ -2067,7 +2066,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }))\n             }\n \n-            ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => None,\n+            ty::Alias(..) | ty::Param(_) => None,\n             ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n             ty::Placeholder(..)\n@@ -2167,7 +2166,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Adt(..) | ty::Projection(..) | ty::Param(..) | ty::Opaque(..) => {\n+            ty::Adt(..) | ty::Alias(..) | ty::Param(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n@@ -2220,7 +2219,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Projection(..)\n+            | ty::Alias(ty::Projection, ..)\n             | ty::Bound(..)\n             | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble constituent types of unexpected type: {:?}\", t);\n@@ -2260,7 +2259,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 t.rebind(def.all_fields().map(|f| f.ty(self.tcx(), substs)).collect())\n             }\n \n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 // We can resolve the `impl Trait` to its concrete type,\n                 // which enforces a DAG between the functions requiring\n                 // the auto trait bounds in question."}, {"sha": "892a7afd799c73c64ff0a5c6ba5bbf156b68fa9e", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -95,10 +95,7 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n             ty::Foreign(_) => {\n                 return ControlFlow::Break(ty);\n             }\n-            ty::Opaque(..) => {\n-                return ControlFlow::Break(ty);\n-            }\n-            ty::Projection(..) => {\n+            ty::Alias(..) => {\n                 return ControlFlow::Break(ty);\n             }\n             ty::Closure(..) => {"}, {"sha": "74c4ae8854c34e4d9fb628808f5523a4f4707c65", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -234,9 +234,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            if let Some(ty::Projection(projection_ty)) = proj.term.ty().map(|ty| ty.kind())\n+            if let Some(ty::Alias(ty::Projection, projection_ty)) = proj.term.ty().map(|ty| ty.kind())\n                 && let Some(&impl_item_id) =\n-                    tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n+                    tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.def_id)\n                 && let Some(impl_item_span) = items\n                     .iter()\n                     .find(|item| item.id.owner_id.to_def_id() == impl_item_id)\n@@ -249,9 +249,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n-            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = *pred.self_ty().kind()\n+            if let ty::Alias(ty::Projection, ty::AliasTy { def_id, .. }) = *pred.self_ty().kind()\n                 && let Some(&impl_item_id) =\n-                    tcx.impl_item_implementor_ids(impl_def_id).get(&item_def_id)\n+                    tcx.impl_item_implementor_ids(impl_def_id).get(&def_id)\n                 && let Some(impl_item_span) = items\n                     .iter()\n                     .find(|item| item.id.owner_id.to_def_id() == impl_item_id)\n@@ -369,7 +369,7 @@ impl<'tcx> WfPredicates<'tcx> {\n \n     /// Pushes the obligations required for `trait_ref::Item` to be WF\n     /// into `self.out`.\n-    fn compute_projection(&mut self, data: ty::ProjectionTy<'tcx>) {\n+    fn compute_projection(&mut self, data: ty::AliasTy<'tcx>) {\n         // A projection is well-formed if\n         //\n         // (a) its predicates hold (*)\n@@ -392,7 +392,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         //     `i32: Copy`\n         // ]\n         // Projection types do not require const predicates.\n-        let obligations = self.nominal_obligations_without_const(data.item_def_id, data.substs);\n+        let obligations = self.nominal_obligations_without_const(data.def_id, data.substs);\n         self.out.extend(obligations);\n \n         let tcx = self.tcx();\n@@ -556,7 +556,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // Simple cases that are WF if their type args are WF.\n                 }\n \n-                ty::Projection(data) => {\n+                ty::Alias(ty::Projection, data) => {\n                     walker.skip_current_subtree(); // Subtree handled by compute_projection.\n                     self.compute_projection(data);\n                 }\n@@ -648,12 +648,12 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // types appearing in the fn signature\n                 }\n \n-                ty::Opaque(did, substs) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                     // All of the requirements on type parameters\n                     // have already been checked for `impl Trait` in\n                     // return position. We do need to check type-alias-impl-trait though.\n-                    if ty::is_impl_trait_defn(self.tcx, did).is_none() {\n-                        let obligations = self.nominal_obligations(did, substs);\n+                    if ty::is_impl_trait_defn(self.tcx, def_id).is_none() {\n+                        let obligations = self.nominal_obligations(def_id, substs);\n                         self.out.extend(obligations);\n                     }\n                 }"}, {"sha": "53bafde0ea20e9fdcc52f63b587bb4d223185ea2", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -432,7 +432,10 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                         (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n                     }\n                 }\n-                (&ty::Opaque(def_id, ..), OpaqueType(opaque_ty_id, ..)) => def_id == opaque_ty_id.0,\n+                (\n+                    &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }),\n+                    OpaqueType(opaque_ty_id, ..),\n+                ) => def_id == opaque_ty_id.0,\n                 (&ty::FnDef(def_id, ..), FnDef(fn_def_id, ..)) => def_id == fn_def_id.0,\n                 (&ty::Str, Str) => true,\n                 (&ty::Never, Never) => true,\n@@ -786,7 +789,7 @@ impl<'tcx> ty::TypeFolder<'tcx> for ReplaceOpaqueTyFolder<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Opaque(def_id, substs) = *ty.kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) = *ty.kind() {\n             if def_id == self.opaque_ty_id.0 && substs == self.identity_substs {\n                 return self.tcx.mk_ty(ty::Bound(\n                     self.binder_index,"}, {"sha": "f3fd315c71ee5fa43aaf47771f94849e399ac3a4", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -66,15 +66,6 @@ impl<'tcx> LowerInto<'tcx, SubstsRef<'tcx>> for &chalk_ir::Substitution<RustInte\n     }\n }\n \n-impl<'tcx> LowerInto<'tcx, chalk_ir::AliasTy<RustInterner<'tcx>>> for ty::ProjectionTy<'tcx> {\n-    fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::AliasTy<RustInterner<'tcx>> {\n-        chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n-            associated_ty_id: chalk_ir::AssocTypeId(self.item_def_id),\n-            substitution: self.substs.lower_into(interner),\n-        })\n-    }\n-}\n-\n impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>>>\n     for ChalkEnvironmentAndGoal<'tcx>\n {\n@@ -255,7 +246,10 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n         // FIXME(associated_const_equality): teach chalk about terms for alias eq.\n         chalk_ir::AliasEq {\n             ty: self.term.ty().unwrap().lower_into(interner),\n-            alias: self.projection_ty.lower_into(interner),\n+            alias: chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n+                associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.def_id),\n+                substitution: self.projection_ty.substs.lower_into(interner),\n+            }),\n         }\n     }\n }\n@@ -353,8 +347,13 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             ty::Tuple(types) => {\n                 chalk_ir::TyKind::Tuple(types.len(), types.as_substs().lower_into(interner))\n             }\n-            ty::Projection(proj) => chalk_ir::TyKind::Alias(proj.lower_into(interner)),\n-            ty::Opaque(def_id, substs) => {\n+            ty::Alias(ty::Projection, ty::AliasTy { def_id, substs }) => {\n+                chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n+                    associated_ty_id: chalk_ir::AssocTypeId(def_id),\n+                    substitution: substs.lower_into(interner),\n+                }))\n+            }\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),\n                     substitution: substs.lower_into(interner),\n@@ -442,27 +441,35 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n                 mutbl.lower_into(interner),\n             ),\n             TyKind::Str => ty::Str,\n-            TyKind::OpaqueType(opaque_ty, substitution) => {\n-                ty::Opaque(opaque_ty.0, substitution.lower_into(interner))\n-            }\n-            TyKind::AssociatedType(assoc_ty, substitution) => ty::Projection(ty::ProjectionTy {\n-                substs: substitution.lower_into(interner),\n-                item_def_id: assoc_ty.0,\n-            }),\n+            TyKind::OpaqueType(opaque_ty, substitution) => ty::Alias(\n+                ty::Opaque,\n+                ty::AliasTy { def_id: opaque_ty.0, substs: substitution.lower_into(interner) },\n+            ),\n+            TyKind::AssociatedType(assoc_ty, substitution) => ty::Alias(\n+                ty::Projection,\n+                ty::AliasTy { substs: substitution.lower_into(interner), def_id: assoc_ty.0 },\n+            ),\n             TyKind::Foreign(def_id) => ty::Foreign(def_id.0),\n             TyKind::Error => return interner.tcx.ty_error(),\n             TyKind::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n                 universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n                 name: ty::BoundVar::from_usize(placeholder.idx),\n             }),\n             TyKind::Alias(alias_ty) => match alias_ty {\n-                chalk_ir::AliasTy::Projection(projection) => ty::Projection(ty::ProjectionTy {\n-                    item_def_id: projection.associated_ty_id.0,\n-                    substs: projection.substitution.lower_into(interner),\n-                }),\n-                chalk_ir::AliasTy::Opaque(opaque) => {\n-                    ty::Opaque(opaque.opaque_ty_id.0, opaque.substitution.lower_into(interner))\n-                }\n+                chalk_ir::AliasTy::Projection(projection) => ty::Alias(\n+                    ty::Projection,\n+                    ty::AliasTy {\n+                        def_id: projection.associated_ty_id.0,\n+                        substs: projection.substitution.lower_into(interner),\n+                    },\n+                ),\n+                chalk_ir::AliasTy::Opaque(opaque) => ty::Alias(\n+                    ty::Opaque,\n+                    ty::AliasTy {\n+                        def_id: opaque.opaque_ty_id.0,\n+                        substs: opaque.substitution.lower_into(interner),\n+                    },\n+                ),\n             },\n             TyKind::Function(_quantified_ty) => unimplemented!(),\n             TyKind::BoundVar(_bound) => ty::Bound(\n@@ -688,7 +695,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n                     binders.clone(),\n                     chalk_ir::WhereClause::AliasEq(chalk_ir::AliasEq {\n                         alias: chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n-                            associated_ty_id: chalk_ir::AssocTypeId(predicate.item_def_id),\n+                            associated_ty_id: chalk_ir::AssocTypeId(predicate.def_id),\n                             substitution: interner\n                                 .tcx\n                                 .mk_substs_trait(self_ty, predicate.substs)\n@@ -844,7 +851,7 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n         let (trait_ref, own_substs) = self.projection_ty.trait_ref_and_own_substs(interner.tcx);\n         chalk_solve::rust_ir::AliasEqBound {\n             trait_bound: trait_ref.lower_into(interner),\n-            associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.item_def_id),\n+            associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.def_id),\n             parameters: own_substs.iter().map(|arg| arg.lower_into(interner)).collect(),\n             value: self.term.ty().unwrap().lower_into(interner),\n         }"}, {"sha": "3f661ce69235caaf0cb69c8df90277e9fdbfb0be", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -112,7 +112,7 @@ fn dropck_outlives<'tcx>(\n \n                     // A projection that we couldn't resolve - it\n                     // might have a destructor.\n-                    ty::Projection(..) | ty::Opaque(..) => {\n+                    ty::Alias(..) => {\n                         result.kinds.push(ty.into());\n                     }\n \n@@ -268,7 +268,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n         }\n \n         // Types that can't be resolved. Pass them forward.\n-        ty::Projection(..) | ty::Opaque(..) | ty::Param(..) => {\n+        ty::Alias(..) | ty::Param(..) => {\n             constraints.dtorck_types.push(ty);\n         }\n "}, {"sha": "9589342b3c73f6cf981055828db383b439eba538", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -444,7 +444,7 @@ fn layout_of_uncached<'tcx>(\n         }\n \n         // Types with no meaningful known layout.\n-        ty::Projection(_) | ty::Opaque(..) => {\n+        ty::Alias(..) => {\n             // NOTE(eddyb) `layout_of` query should've normalized these away,\n             // if that was possible, so there's no reason to try again here.\n             return Err(LayoutError::Unknown(ty));"}, {"sha": "0df060fc5fb71eae719d70216303c22e90f8af17", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -152,7 +152,7 @@ where\n                             queue_type(self, required);\n                         }\n                     }\n-                    ty::Array(..) | ty::Opaque(..) | ty::Projection(..) | ty::Param(_) => {\n+                    ty::Array(..) | ty::Alias(..) | ty::Param(_) => {\n                         if ty == component {\n                             // Return the type to the caller: they may be able\n                             // to normalize further than we can."}, {"sha": "5279fc69a31b3cb6a72b1cd2e665efff89fbd316", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -37,7 +37,7 @@ fn sized_constraint_for_ty<'tcx>(\n                 .collect()\n         }\n \n-        Projection(..) | Opaque(..) => {\n+        Alias(..) => {\n             // must calculate explicitly.\n             // FIXME: consider special-casing always-Sized projections\n             vec![ty]"}, {"sha": "c992dbccd62d5656439cc6ca72578f8656200075", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -42,7 +42,7 @@ pub trait Interner {\n     type ListBinderExistentialPredicate: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type BinderListTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type ListTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n-    type ProjectionTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type AliasTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type ParamTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type BoundTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type PlaceholderType: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;"}, {"sha": "e9ffbca96280d85503651104987002c0d733310e", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 38, "deletions": 67, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -19,19 +19,8 @@ use rustc_data_structures::stable_hasher::HashStable;\n use rustc_serialize::{Decodable, Decoder, Encodable};\n \n /// Specifies how a trait object is represented.\n-#[derive(\n-    Clone,\n-    Copy,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    Debug,\n-    Encodable,\n-    Decodable,\n-    HashStable_Generic\n-)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum DynKind {\n     /// An unsized `dyn Trait` object\n     Dyn,\n@@ -46,6 +35,13 @@ pub enum DynKind {\n     DynStar,\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub enum AliasKind {\n+    Projection,\n+    Opaque,\n+}\n+\n /// Defines the kinds of types used by the type system.\n ///\n /// Types written by the user start out as `hir::TyKind` and get\n@@ -170,21 +166,8 @@ pub enum TyKind<I: Interner> {\n     /// A tuple type. For example, `(i32, bool)`.\n     Tuple(I::ListTy),\n \n-    /// The projection of an associated type. For example,\n-    /// `<T as Trait<..>>::N`.\n-    Projection(I::ProjectionTy),\n-\n-    /// Opaque (`impl Trait`) type found in a return type.\n-    ///\n-    /// The `DefId` comes either from\n-    /// * the `impl Trait` ast::Ty node,\n-    /// * or the `type Foo = impl Trait` declaration\n-    ///\n-    /// For RPIT the substitutions are for the generics of the function,\n-    /// while for TAIT it is used for the generic parameters of the alias.\n-    ///\n-    /// During codegen, `tcx.type_of(def_id)` can be used to get the underlying type.\n-    Opaque(I::DefId, I::SubstsRef),\n+    /// A projection or opaque type. Both of these types\n+    Alias(AliasKind, I::AliasTy),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}`.\n     Param(I::ParamTy),\n@@ -252,13 +235,12 @@ const fn tykind_discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n         GeneratorWitness(_) => 17,\n         Never => 18,\n         Tuple(_) => 19,\n-        Projection(_) => 20,\n-        Opaque(_, _) => 21,\n-        Param(_) => 22,\n-        Bound(_, _) => 23,\n-        Placeholder(_) => 24,\n-        Infer(_) => 25,\n-        Error(_) => 26,\n+        Alias(_, _) => 20,\n+        Param(_) => 21,\n+        Bound(_, _) => 22,\n+        Placeholder(_) => 23,\n+        Infer(_) => 24,\n+        Error(_) => 25,\n     }\n }\n \n@@ -286,8 +268,7 @@ impl<I: Interner> Clone for TyKind<I> {\n             GeneratorWitness(g) => GeneratorWitness(g.clone()),\n             Never => Never,\n             Tuple(t) => Tuple(t.clone()),\n-            Projection(p) => Projection(p.clone()),\n-            Opaque(d, s) => Opaque(d.clone(), s.clone()),\n+            Alias(k, p) => Alias(*k, p.clone()),\n             Param(p) => Param(p.clone()),\n             Bound(d, b) => Bound(d.clone(), b.clone()),\n             Placeholder(p) => Placeholder(p.clone()),\n@@ -323,8 +304,7 @@ impl<I: Interner> PartialEq for TyKind<I> {\n                 }\n                 (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n                 (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n-                (Projection(a_p), Projection(b_p)) => a_p == b_p,\n-                (Opaque(a_d, a_s), Opaque(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Alias(a_i, a_p), Alias(b_i, b_p)) => a_i == b_i && a_p == b_p,\n                 (Param(a_p), Param(b_p)) => a_p == b_p,\n                 (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d == b_d && a_b == b_b,\n                 (Placeholder(a_p), Placeholder(b_p)) => a_p == b_p,\n@@ -381,8 +361,7 @@ impl<I: Interner> Ord for TyKind<I> {\n                 }\n                 (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g.cmp(b_g),\n                 (Tuple(a_t), Tuple(b_t)) => a_t.cmp(b_t),\n-                (Projection(a_p), Projection(b_p)) => a_p.cmp(b_p),\n-                (Opaque(a_d, a_s), Opaque(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (Alias(a_i, a_p), Alias(b_i, b_p)) => a_i.cmp(b_i).then_with(|| a_p.cmp(b_p)),\n                 (Param(a_p), Param(b_p)) => a_p.cmp(b_p),\n                 (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d.cmp(b_d).then_with(|| a_b.cmp(b_b)),\n                 (Placeholder(a_p), Placeholder(b_p)) => a_p.cmp(b_p),\n@@ -443,10 +422,9 @@ impl<I: Interner> hash::Hash for TyKind<I> {\n             }\n             GeneratorWitness(g) => g.hash(state),\n             Tuple(t) => t.hash(state),\n-            Projection(p) => p.hash(state),\n-            Opaque(d, s) => {\n-                d.hash(state);\n-                s.hash(state)\n+            Alias(i, p) => {\n+                i.hash(state);\n+                p.hash(state);\n             }\n             Param(p) => p.hash(state),\n             Bound(d, b) => {\n@@ -485,8 +463,7 @@ impl<I: Interner> fmt::Debug for TyKind<I> {\n             GeneratorWitness(g) => f.debug_tuple_field1_finish(\"GeneratorWitness\", g),\n             Never => f.write_str(\"Never\"),\n             Tuple(t) => f.debug_tuple_field1_finish(\"Tuple\", t),\n-            Projection(p) => f.debug_tuple_field1_finish(\"Projection\", p),\n-            Opaque(d, s) => f.debug_tuple_field2_finish(\"Opaque\", d, s),\n+            Alias(i, a) => f.debug_tuple_field2_finish(\"Alias\", i, a),\n             Param(p) => f.debug_tuple_field1_finish(\"Param\", p),\n             Bound(d, b) => f.debug_tuple_field2_finish(\"Bound\", d, b),\n             Placeholder(p) => f.debug_tuple_field1_finish(\"Placeholder\", p),\n@@ -513,7 +490,7 @@ where\n     I::ListBinderExistentialPredicate: Encodable<E>,\n     I::BinderListTy: Encodable<E>,\n     I::ListTy: Encodable<E>,\n-    I::ProjectionTy: Encodable<E>,\n+    I::AliasTy: Encodable<E>,\n     I::ParamTy: Encodable<E>,\n     I::BoundTy: Encodable<E>,\n     I::PlaceholderType: Encodable<E>,\n@@ -586,13 +563,10 @@ where\n             Tuple(substs) => e.emit_enum_variant(disc, |e| {\n                 substs.encode(e);\n             }),\n-            Projection(p) => e.emit_enum_variant(disc, |e| {\n+            Alias(k, p) => e.emit_enum_variant(disc, |e| {\n+                k.encode(e);\n                 p.encode(e);\n             }),\n-            Opaque(def_id, substs) => e.emit_enum_variant(disc, |e| {\n-                def_id.encode(e);\n-                substs.encode(e);\n-            }),\n             Param(p) => e.emit_enum_variant(disc, |e| {\n                 p.encode(e);\n             }),\n@@ -630,8 +604,9 @@ where\n     I::ListBinderExistentialPredicate: Decodable<D>,\n     I::BinderListTy: Decodable<D>,\n     I::ListTy: Decodable<D>,\n-    I::ProjectionTy: Decodable<D>,\n+    I::AliasTy: Decodable<D>,\n     I::ParamTy: Decodable<D>,\n+    I::AliasTy: Decodable<D>,\n     I::BoundTy: Decodable<D>,\n     I::PlaceholderType: Decodable<D>,\n     I::InferTy: Decodable<D>,\n@@ -660,13 +635,12 @@ where\n             17 => GeneratorWitness(Decodable::decode(d)),\n             18 => Never,\n             19 => Tuple(Decodable::decode(d)),\n-            20 => Projection(Decodable::decode(d)),\n-            21 => Opaque(Decodable::decode(d), Decodable::decode(d)),\n-            22 => Param(Decodable::decode(d)),\n-            23 => Bound(Decodable::decode(d), Decodable::decode(d)),\n-            24 => Placeholder(Decodable::decode(d)),\n-            25 => Infer(Decodable::decode(d)),\n-            26 => Error(Decodable::decode(d)),\n+            20 => Alias(Decodable::decode(d), Decodable::decode(d)),\n+            21 => Param(Decodable::decode(d)),\n+            22 => Bound(Decodable::decode(d), Decodable::decode(d)),\n+            23 => Placeholder(Decodable::decode(d)),\n+            24 => Infer(Decodable::decode(d)),\n+            25 => Error(Decodable::decode(d)),\n             _ => panic!(\n                 \"{}\",\n                 format!(\n@@ -695,7 +669,7 @@ where\n     I::Mutability: HashStable<CTX>,\n     I::BinderListTy: HashStable<CTX>,\n     I::ListTy: HashStable<CTX>,\n-    I::ProjectionTy: HashStable<CTX>,\n+    I::AliasTy: HashStable<CTX>,\n     I::BoundTy: HashStable<CTX>,\n     I::ParamTy: HashStable<CTX>,\n     I::PlaceholderType: HashStable<CTX>,\n@@ -772,13 +746,10 @@ where\n             Tuple(substs) => {\n                 substs.hash_stable(__hcx, __hasher);\n             }\n-            Projection(p) => {\n+            Alias(k, p) => {\n+                k.hash_stable(__hcx, __hasher);\n                 p.hash_stable(__hcx, __hasher);\n             }\n-            Opaque(def_id, substs) => {\n-                def_id.hash_stable(__hcx, __hasher);\n-                substs.hash_stable(__hcx, __hasher);\n-            }\n             Param(p) => {\n                 p.hash_stable(__hcx, __hasher);\n             }"}, {"sha": "4a4dc899ba9a379279fa6e0e1d7ea50002dee894", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -414,14 +414,14 @@ fn clean_projection_predicate<'tcx>(\n }\n \n fn clean_projection<'tcx>(\n-    ty: ty::Binder<'tcx, ty::ProjectionTy<'tcx>>,\n+    ty: ty::Binder<'tcx, ty::AliasTy<'tcx>>,\n     cx: &mut DocContext<'tcx>,\n     def_id: Option<DefId>,\n ) -> Type {\n-    if cx.tcx.def_kind(ty.skip_binder().item_def_id) == DefKind::ImplTraitPlaceholder {\n+    if cx.tcx.def_kind(ty.skip_binder().def_id) == DefKind::ImplTraitPlaceholder {\n         let bounds = cx\n             .tcx\n-            .explicit_item_bounds(ty.skip_binder().item_def_id)\n+            .explicit_item_bounds(ty.skip_binder().def_id)\n             .iter()\n             .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, ty.skip_binder().substs))\n             .collect::<Vec<_>>();\n@@ -453,11 +453,11 @@ fn compute_should_show_cast(self_def_id: Option<DefId>, trait_: &Path, self_type\n }\n \n fn projection_to_path_segment<'tcx>(\n-    ty: ty::Binder<'tcx, ty::ProjectionTy<'tcx>>,\n+    ty: ty::Binder<'tcx, ty::AliasTy<'tcx>>,\n     cx: &mut DocContext<'tcx>,\n ) -> PathSegment {\n-    let item = cx.tcx.associated_item(ty.skip_binder().item_def_id);\n-    let generics = cx.tcx.generics_of(ty.skip_binder().item_def_id);\n+    let item = cx.tcx.associated_item(ty.skip_binder().def_id);\n+    let generics = cx.tcx.generics_of(ty.skip_binder().def_id);\n     PathSegment {\n         name: item.name,\n         args: GenericArgs::AngleBracketed {\n@@ -1487,7 +1487,9 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n         hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             let res = match ty.kind() {\n-                ty::Projection(proj) => Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id),\n+                ty::Alias(ty::Projection, proj) => {\n+                    Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id)\n+                }\n                 // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n                 ty::Error(_) => return Type::Infer,\n                 // Otherwise, this is an inherent associated type.\n@@ -1823,7 +1825,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             Tuple(t.iter().map(|t| clean_middle_ty(bound_ty.rebind(t), cx, None)).collect())\n         }\n \n-        ty::Projection(ref data) => clean_projection(bound_ty.rebind(*data), cx, def_id),\n+        ty::Alias(ty::Projection, ref data) => clean_projection(bound_ty.rebind(*data), cx, def_id),\n \n         ty::Param(ref p) => {\n             if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n@@ -1833,7 +1835,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             }\n         }\n \n-        ty::Opaque(def_id, substs) => {\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n             // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n             // by looking up the bounds associated with the def_id.\n             let bounds = cx"}, {"sha": "4f0eb8b8076e5fae8214dfb8a71ace1658385d36", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -538,11 +538,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did, .. }, _)), _) | ty::Foreign(did) => {\n                 Res::from_def_id(self.cx.tcx, did)\n             }\n-            ty::Projection(_)\n+            ty::Alias(..)\n             | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n-            | ty::Opaque(..)\n             | ty::Dynamic(..)\n             | ty::Param(_)\n             | ty::Bound(..)"}, {"sha": "3f7429a5fccf83cef8b9f289ac2b1d1c36527125", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -33,8 +33,7 @@ fn main() {\n         TyKind::GeneratorWitness(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Never => (),                //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Tuple(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Projection(..) => (),       //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Opaque(..) => (),           //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Alias(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Param(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Bound(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Placeholder(..) => (),      //~ ERROR usage of `ty::TyKind::<kind>`"}, {"sha": "1f49d6b64646f0282b4d214c63f6ecd69f0e1a60", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -133,82 +133,76 @@ LL |         TyKind::Tuple(..) => (),\n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:36:9\n    |\n-LL |         TyKind::Projection(..) => (),\n+LL |         TyKind::Alias(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:37:9\n    |\n-LL |         TyKind::Opaque(..) => (),\n-   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n-\n-error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:38:9\n-   |\n LL |         TyKind::Param(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:39:9\n+  --> $DIR/ty_tykind_usage.rs:38:9\n    |\n LL |         TyKind::Bound(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:40:9\n+  --> $DIR/ty_tykind_usage.rs:39:9\n    |\n LL |         TyKind::Placeholder(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:41:9\n+  --> $DIR/ty_tykind_usage.rs:40:9\n    |\n LL |         TyKind::Infer(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:42:9\n+  --> $DIR/ty_tykind_usage.rs:41:9\n    |\n LL |         TyKind::Error(_) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:47:12\n+  --> $DIR/ty_tykind_usage.rs:46:12\n    |\n LL |     if let TyKind::Int(int_ty) = kind {}\n    |            ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:49:24\n+  --> $DIR/ty_tykind_usage.rs:48:24\n    |\n LL |     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {}\n    |                        ^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:51:37\n+  --> $DIR/ty_tykind_usage.rs:50:37\n    |\n LL |     fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n    |                                     ^^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:51:53\n+  --> $DIR/ty_tykind_usage.rs:50:53\n    |\n LL |     fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n    |                                                     ^^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:54:9\n+  --> $DIR/ty_tykind_usage.rs:53:9\n    |\n LL |         IrTyKind::Bool\n    |         --------^^^^^^\n    |         |\n    |         help: try using `ty::<kind>` directly: `ty`\n \n-error: aborting due to 33 previous errors\n+error: aborting due to 32 previous errors\n "}, {"sha": "31183266acfcba44236911f54cd37d25113dc8ef", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -1244,7 +1244,7 @@ fn is_mixed_projection_predicate<'tcx>(\n         let mut projection_ty = projection_predicate.projection_ty;\n         loop {\n             match projection_ty.self_ty().kind() {\n-                ty::Projection(inner_projection_ty) => {\n+                ty::Alias(ty::Projection, inner_projection_ty) => {\n                     projection_ty = *inner_projection_ty;\n                 }\n                 ty::Param(param_ty) => {\n@@ -1330,7 +1330,7 @@ fn replace_types<'tcx>(\n                     && let Some(term_ty) = projection_predicate.term.ty()\n                     && let ty::Param(term_param_ty) = term_ty.kind()\n                 {\n-                    let item_def_id = projection_predicate.projection_ty.item_def_id;\n+                    let item_def_id = projection_predicate.projection_ty.def_id;\n                     let assoc_item = cx.tcx.associated_item(item_def_id);\n                     let projection = cx.tcx\n                         .mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(new_ty, []));\n@@ -1390,8 +1390,8 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n                 continue;\n             },\n             ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n-            ty::Projection(_) if ty.has_non_region_param() => TyPosition::new_deref_stable_for_result(precedence, ty),\n-            ty::Infer(_) | ty::Error(_) | ty::Bound(..) | ty::Opaque(..) | ty::Placeholder(_) | ty::Dynamic(..) => {\n+            ty::Alias(ty::Projection, _) if ty.has_non_region_param() => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Infer(_) | ty::Error(_) | ty::Bound(..) | ty::Alias(ty::Opaque, ..) | ty::Placeholder(_) | ty::Dynamic(..) => {\n                 Position::ReborrowStable(precedence).into()\n             },\n             ty::Adt(..) if ty.has_placeholders() || ty.has_opaque_types() => {\n@@ -1417,7 +1417,7 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             | ty::Closure(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Projection(_) => {\n+            | ty::Alias(ty::Projection, _) => {\n                 Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds())).into()\n             },\n         };"}, {"sha": "fcdac90fc237ae1a1a18bd7ffcf3e722e53bb545", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{Clause, EarlyBinder, Opaque, PredicateKind};\n+use rustc_middle::ty::{self, AliasTy, Clause, EarlyBinder, PredicateKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n@@ -62,11 +62,11 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n             return;\n         }\n         let ret_ty = return_ty(cx, hir_id);\n-        if let Opaque(id, subst) = *ret_ty.kind() {\n-            let preds = cx.tcx.explicit_item_bounds(id);\n+        if let ty::Alias(ty::Opaque, AliasTy { def_id, substs }) = *ret_ty.kind() {\n+            let preds = cx.tcx.explicit_item_bounds(def_id);\n             let mut is_future = false;\n             for &(p, _span) in preds {\n-                let p = EarlyBinder(p).subst(cx.tcx, subst);\n+                let p = EarlyBinder(p).subst(cx.tcx, substs);\n                 if let Some(trait_pred) = p.to_opt_poly_trait_pred() {\n                     if Some(trait_pred.skip_binder().trait_ref.def_id) == cx.tcx.lang_items().future_trait() {\n                         is_future = true;"}, {"sha": "73841f9aa9a2112a626dd86e95b34779d90b33ff", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -493,7 +493,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 .filter_by_name_unhygienic(is_empty)\n                 .any(|item| is_is_empty(cx, item))\n         }),\n-        ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n+        ty::Alias(ty::Projection, ref proj) => has_is_empty_impl(cx, proj.def_id),\n         ty::Adt(id, _) => has_is_empty_impl(cx, id.did()),\n         ty::Array(..) | ty::Slice(..) | ty::Str => true,\n         _ => false,"}, {"sha": "f4d3ef3b742509f40debe7616bb272b7f295f274", "filename": "src/tools/clippy/clippy_lints/src/methods/needless_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -151,7 +151,7 @@ fn iterates_same_ty<'tcx>(cx: &LateContext<'tcx>, iter_ty: Ty<'tcx>, collect_ty:\n         && let Some(into_iter_item_proj) = make_projection(cx.tcx, into_iter_trait, item, [collect_ty])\n         && let Ok(into_iter_item_ty) = cx.tcx.try_normalize_erasing_regions(\n             cx.param_env,\n-            cx.tcx.mk_projection(into_iter_item_proj.item_def_id, into_iter_item_proj.substs)\n+            cx.tcx.mk_projection(into_iter_item_proj.def_id, into_iter_item_proj.substs)\n         )\n     {\n         iter_item_ty == into_iter_item_ty"}, {"sha": "8bf542ada04dd80ace50f751c29337d8ecdd71d4", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -82,7 +82,7 @@ fn check_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n                 return Err((span, \"mutable references in const fn are unstable\".into()));\n             },\n-            ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n+            ty::Alias(ty::Opaque, ..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n                 return Err((span, \"function pointers in const fn are unstable\".into()));\n             },"}, {"sha": "33f3b3af3dc02d125223da58b3c9fc694805def0", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918d0ac38e8c3bcf4fb5ee2241fb14979c73c312/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=918d0ac38e8c3bcf4fb5ee2241fb14979c73c312", "patch": "@@ -17,7 +17,7 @@ use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::{\n     self, AdtDef, AssocKind, Binder, BoundRegion, DefIdTree, FnSig, IntTy, List, ParamEnv, Predicate, PredicateKind,\n-    ProjectionTy, Region, RegionKind, SubstsRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor, UintTy,\n+    AliasTy, Region, RegionKind, SubstsRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor, UintTy,\n     VariantDef, VariantDiscr,\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n@@ -79,7 +79,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n                 return true;\n             }\n \n-            if let ty::Opaque(def_id, _) = *inner_ty.kind() {\n+            if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *inner_ty.kind() {\n                 for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n                     match predicate.kind().skip_binder() {\n                         // For `impl Trait<U>`, it will register a predicate of `T: Trait<U>`, so we go through\n@@ -250,7 +250,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n             is_must_use_ty(cx, *ty)\n         },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n-        ty::Opaque(def_id, _) => {\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() {\n                     if cx.tcx.has_attr(trait_predicate.trait_ref.def_id, sym::must_use) {\n@@ -631,7 +631,7 @@ pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'t\n             Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n         },\n         ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id))),\n-        ty::Opaque(id, _) => sig_from_bounds(cx, ty, cx.tcx.item_bounds(id), cx.tcx.opt_parent(id)),\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => sig_from_bounds(cx, ty, cx.tcx.item_bounds(def_id), cx.tcx.opt_parent(def_id)),\n         ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig, None)),\n         ty::Dynamic(bounds, _, _) => {\n             let lang_items = cx.tcx.lang_items();\n@@ -650,7 +650,7 @@ pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'t\n                 _ => None,\n             }\n         },\n-        ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n+        ty::Alias(ty::Projection, proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n             Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n             _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None)),\n         },\n@@ -685,7 +685,7 @@ fn sig_from_bounds<'tcx>(\n                 inputs = Some(i);\n             },\n             PredicateKind::Clause(ty::Clause::Projection(p))\n-                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n+                if Some(p.projection_ty.def_id) == lang_items.fn_once_output()\n                     && p.projection_ty.self_ty() == ty =>\n             {\n                 if output.is_some() {\n@@ -701,14 +701,14 @@ fn sig_from_bounds<'tcx>(\n     inputs.map(|ty| ExprFnSig::Trait(ty, output, predicates_id))\n }\n \n-fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: AliasTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n     let mut inputs = None;\n     let mut output = None;\n     let lang_items = cx.tcx.lang_items();\n \n     for (pred, _) in cx\n         .tcx\n-        .bound_explicit_item_bounds(ty.item_def_id)\n+        .bound_explicit_item_bounds(ty.def_id)\n         .subst_iter_copied(cx.tcx, ty.substs)\n     {\n         match pred.kind().skip_binder() {\n@@ -726,7 +726,7 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n                 inputs = Some(i);\n             },\n             PredicateKind::Clause(ty::Clause::Projection(p))\n-                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() =>\n+                if Some(p.projection_ty.def_id) == lang_items.fn_once_output() =>\n             {\n                 if output.is_some() {\n                     // Multiple different fn trait impls. Is this even allowed?\n@@ -980,13 +980,13 @@ pub fn make_projection<'tcx>(\n     container_id: DefId,\n     assoc_ty: Symbol,\n     substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n-) -> Option<ProjectionTy<'tcx>> {\n+) -> Option<AliasTy<'tcx>> {\n     fn helper<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         container_id: DefId,\n         assoc_ty: Symbol,\n         substs: SubstsRef<'tcx>,\n-    ) -> Option<ProjectionTy<'tcx>> {\n+    ) -> Option<AliasTy<'tcx>> {\n         let Some(assoc_item) = tcx\n             .associated_items(container_id)\n             .find_by_name_and_kind(tcx, Ident::with_dummy_span(assoc_ty), AssocKind::Type, container_id)\n@@ -1039,9 +1039,9 @@ pub fn make_projection<'tcx>(\n             }\n         }\n \n-        Some(ProjectionTy {\n+        Some(AliasTy {\n             substs,\n-            item_def_id: assoc_item.def_id,\n+            def_id: assoc_item.def_id,\n         })\n     }\n     helper(\n@@ -1065,7 +1065,7 @@ pub fn make_normalized_projection<'tcx>(\n     assoc_ty: Symbol,\n     substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n ) -> Option<Ty<'tcx>> {\n-    fn helper<'tcx>(tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: ProjectionTy<'tcx>) -> Option<Ty<'tcx>> {\n+    fn helper<'tcx>(tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: AliasTy<'tcx>) -> Option<Ty<'tcx>> {\n         #[cfg(debug_assertions)]\n         if let Some((i, subst)) = ty\n             .substs\n@@ -1081,7 +1081,7 @@ pub fn make_normalized_projection<'tcx>(\n             );\n             return None;\n         }\n-        match tcx.try_normalize_erasing_regions(param_env, tcx.mk_projection(ty.item_def_id, ty.substs)) {\n+        match tcx.try_normalize_erasing_regions(param_env, tcx.mk_projection(ty.def_id, ty.substs)) {\n             Ok(ty) => Some(ty),\n             Err(e) => {\n                 debug_assert!(false, \"failed to normalize type `{ty}`: {e:#?}\");"}]}