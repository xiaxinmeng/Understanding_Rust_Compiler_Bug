{"sha": "2ff505ab48faf3f5d3c4174449e3a53ece19141e", "node_id": "C_kwDOAAsO6NoAKDJmZjUwNWFiNDhmYWYzZjVkM2M0MTc0NDQ5ZTNhNTNlY2UxOTE0MWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-30T09:14:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-30T09:14:12Z"}, "message": "Auto merge of #12428 - lowr:experimental/destructuring-assignment, r=flodiebold\n\nfeat: implement destructuring assignment\n\nThis is an attempt to implement destructuring assignments, or more specifically, type inference for [assignee expressions](https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions).\n\nI'm not sure if this is the right approach, so I don't even expect this to be merged (hence the branch name :wink:) but rather want to propose one direction we could choose. I don't mind getting merged if this is good enough though!\n\nSome notes on the implementation choices:\n\n- Assignee expressions are **not** desugared on HIR level unlike rustc, but are inferred directly along with other expressions. This matches the processing of other syntaxes that are desugared in rustc but not in r-a. I find this reasonable because r-a only needs to infer types and it's easier to relate AST nodes and HIR nodes, so I followed it.\n- Assignee expressions obviously resemble patterns, so type inference for each kind of pattern and its corresponding assignee expressions share a significant amount of logic. I tried to reuse the type inference functions for patterns by introducing `PatLike` trait which generalizes assignee expressions and patterns.\n  - This is not the most elegant solution I suspect (and I really don't like the name of the trait!), but it's cleaner and the change is smaller than other ways I experimented, like making the functions generic without such trait, or making them take `Either<ExprId, PatId>` in place of `PatId`.\n\nin case this is merged:\nCloses #11532\nCloses #11839\nCloses #12322", "tree": {"sha": "003f2d5190ee155469393e1b69c47a951a7cb83d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/003f2d5190ee155469393e1b69c47a951a7cb83d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ff505ab48faf3f5d3c4174449e3a53ece19141e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff505ab48faf3f5d3c4174449e3a53ece19141e", "html_url": "https://github.com/rust-lang/rust/commit/2ff505ab48faf3f5d3c4174449e3a53ece19141e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ff505ab48faf3f5d3c4174449e3a53ece19141e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0102bd469a0d9d5008ce3b5ae0fa1f13e8d18d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0102bd469a0d9d5008ce3b5ae0fa1f13e8d18d0", "html_url": "https://github.com/rust-lang/rust/commit/b0102bd469a0d9d5008ce3b5ae0fa1f13e8d18d0"}, {"sha": "b7a4175cbba679b704a122fcd95917e4d08f385d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7a4175cbba679b704a122fcd95917e4d08f385d", "html_url": "https://github.com/rust-lang/rust/commit/b7a4175cbba679b704a122fcd95917e4d08f385d"}], "stats": {"total": 600, "additions": 532, "deletions": 68}, "files": [{"sha": "dff3449098fa7371bf28eb867fe884e21114286a", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=2ff505ab48faf3f5d3c4174449e3a53ece19141e", "patch": "@@ -536,7 +536,7 @@ impl ExprCollector<'_> {\n \n                 self.alloc_expr(Expr::MacroStmts { tail }, syntax_ptr)\n             }\n-            ast::Expr::UnderscoreExpr(_) => return None,\n+            ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),\n         })\n     }\n "}, {"sha": "49b7ef451eda2a6167f4903c4e8936eb4671e1dd", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=2ff505ab48faf3f5d3c4174449e3a53ece19141e", "patch": "@@ -203,6 +203,7 @@ pub enum Expr {\n     },\n     Array(Array),\n     Literal(Literal),\n+    Underscore,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -345,6 +346,7 @@ impl Expr {\n             },\n             Expr::MacroStmts { tail } => f(*tail),\n             Expr::Literal(_) => {}\n+            Expr::Underscore => {}\n         }\n     }\n }"}, {"sha": "ecadfb6ce4eb3749b00e49efa28e5c731293233a", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=2ff505ab48faf3f5d3c4174449e3a53ece19141e", "patch": "@@ -125,6 +125,39 @@ impl Default for BindingMode {\n     }\n }\n \n+/// Used to generalize patterns and assignee expressions.\n+trait PatLike: Into<ExprOrPatId> + Copy {\n+    type BindingMode: Copy;\n+\n+    fn infer(\n+        this: &mut InferenceContext,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty;\n+}\n+\n+impl PatLike for ExprId {\n+    type BindingMode = ();\n+\n+    fn infer(this: &mut InferenceContext, id: Self, expected_ty: &Ty, _: Self::BindingMode) -> Ty {\n+        this.infer_assignee_expr(id, expected_ty)\n+    }\n+}\n+\n+impl PatLike for PatId {\n+    type BindingMode = BindingMode;\n+\n+    fn infer(\n+        this: &mut InferenceContext,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty {\n+        this.infer_pat(id, expected_ty, default_bm)\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct InferOk<T> {\n     value: T,"}, {"sha": "a1a7b17f37d7daef443b0b868708c8a53ccb5aaa", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 97, "deletions": 2, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=2ff505ab48faf3f5d3c4174449e3a53ece19141e", "patch": "@@ -593,8 +593,8 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(BinaryOp::Assignment { op: None }) => {\n-                    let lhs_ty = self.infer_expr(*lhs, &Expectation::none());\n-                    self.infer_expr_coerce(*rhs, &Expectation::has_type(lhs_ty));\n+                    let rhs_ty = self.infer_expr(*rhs, &Expectation::none());\n+                    self.infer_assignee_expr(*lhs, &rhs_ty);\n                     self.result.standard_types.unit.clone()\n                 }\n                 Some(BinaryOp::LogicOp(_)) => {\n@@ -775,6 +775,12 @@ impl<'a> InferenceContext<'a> {\n                 },\n             },\n             Expr::MacroStmts { tail } => self.infer_expr_inner(*tail, expected),\n+            Expr::Underscore => {\n+                // Underscore expressions may only appear in assignee expressions,\n+                // which are handled by `infer_assignee_expr()`, so any underscore\n+                // expression reaching this branch is an error.\n+                self.err_ty()\n+            }\n         };\n         // use a new type variable if we got unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n@@ -811,6 +817,95 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    pub(super) fn infer_assignee_expr(&mut self, lhs: ExprId, rhs_ty: &Ty) -> Ty {\n+        let is_rest_expr = |expr| {\n+            matches!(\n+                &self.body[expr],\n+                Expr::Range { lhs: None, rhs: None, range_type: RangeOp::Exclusive },\n+            )\n+        };\n+\n+        let rhs_ty = self.resolve_ty_shallow(rhs_ty);\n+\n+        let ty = match &self.body[lhs] {\n+            Expr::Tuple { exprs } => {\n+                // We don't consider multiple ellipses. This is analogous to\n+                // `hir_def::body::lower::ExprCollector::collect_tuple_pat()`.\n+                let ellipsis = exprs.iter().position(|e| is_rest_expr(*e));\n+                let exprs: Vec<_> = exprs.iter().filter(|e| !is_rest_expr(**e)).copied().collect();\n+\n+                self.infer_tuple_pat_like(&rhs_ty, (), ellipsis, &exprs)\n+            }\n+            Expr::Call { callee, args } => {\n+                // Tuple structs\n+                let path = match &self.body[*callee] {\n+                    Expr::Path(path) => Some(path),\n+                    _ => None,\n+                };\n+\n+                // We don't consider multiple ellipses. This is analogous to\n+                // `hir_def::body::lower::ExprCollector::collect_tuple_pat()`.\n+                let ellipsis = args.iter().position(|e| is_rest_expr(*e));\n+                let args: Vec<_> = args.iter().filter(|e| !is_rest_expr(**e)).copied().collect();\n+\n+                self.infer_tuple_struct_pat_like(path, &rhs_ty, (), lhs, ellipsis, &args)\n+            }\n+            Expr::Array(Array::ElementList(elements)) => {\n+                let elem_ty = match rhs_ty.kind(Interner) {\n+                    TyKind::Array(st, _) => st.clone(),\n+                    _ => self.err_ty(),\n+                };\n+\n+                // There's no need to handle `..` as it cannot be bound.\n+                let sub_exprs = elements.iter().filter(|e| !is_rest_expr(**e));\n+\n+                for e in sub_exprs {\n+                    self.infer_assignee_expr(*e, &elem_ty);\n+                }\n+\n+                match rhs_ty.kind(Interner) {\n+                    TyKind::Array(_, _) => rhs_ty.clone(),\n+                    // Even when `rhs_ty` is not an array type, this assignee\n+                    // expression is infered to be an array (of unknown element\n+                    // type and length). This should not be just an error type,\n+                    // because we are to compute the unifiability of this type and\n+                    // `rhs_ty` in the end of this function to issue type mismatches.\n+                    _ => TyKind::Array(self.err_ty(), crate::consteval::usize_const(None))\n+                        .intern(Interner),\n+                }\n+            }\n+            Expr::RecordLit { path, fields, .. } => {\n+                let subs = fields.iter().map(|f| (f.name.clone(), f.expr));\n+\n+                self.infer_record_pat_like(path.as_deref(), &rhs_ty, (), lhs.into(), subs)\n+            }\n+            Expr::Underscore => rhs_ty.clone(),\n+            _ => {\n+                // `lhs` is a place expression, a unit struct, or an enum variant.\n+                let lhs_ty = self.infer_expr(lhs, &Expectation::none());\n+\n+                // This is the only branch where this function may coerce any type.\n+                // We are returning early to avoid the unifiability check below.\n+                let lhs_ty = self.insert_type_vars_shallow(lhs_ty);\n+                let ty = match self.coerce(None, &rhs_ty, &lhs_ty) {\n+                    Ok(ty) => ty,\n+                    Err(_) => self.err_ty(),\n+                };\n+                self.write_expr_ty(lhs, ty.clone());\n+                return ty;\n+            }\n+        };\n+\n+        let ty = self.insert_type_vars_shallow(ty);\n+        if !self.unify(&ty, &rhs_ty) {\n+            self.result\n+                .type_mismatches\n+                .insert(lhs.into(), TypeMismatch { expected: rhs_ty.clone(), actual: ty.clone() });\n+        }\n+        self.write_expr_ty(lhs, ty.clone());\n+        ty\n+    }\n+\n     fn infer_overloadable_binop(\n         &mut self,\n         lhs: ExprId,"}, {"sha": "dc86f696d4fcad83a49a78a43531ce6b1be99958", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 82, "deletions": 64, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=2ff505ab48faf3f5d3c4174449e3a53ece19141e", "patch": "@@ -4,7 +4,7 @@ use std::iter::repeat_with;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{BindingAnnotation, Expr, Literal, Pat, PatId, RecordFieldPat},\n+    expr::{BindingAnnotation, Expr, Literal, Pat, PatId},\n     path::Path,\n     type_ref::ConstScalar,\n };\n@@ -17,15 +17,20 @@ use crate::{\n     TyKind,\n };\n \n+use super::PatLike;\n+\n impl<'a> InferenceContext<'a> {\n-    fn infer_tuple_struct_pat(\n+    /// Infers type for tuple struct pattern or its corresponding assignee expression.\n+    ///\n+    /// Ellipses found in the original pattern or expression must be filtered out.\n+    pub(super) fn infer_tuple_struct_pat_like<T: PatLike>(\n         &mut self,\n         path: Option<&Path>,\n-        subpats: &[PatId],\n         expected: &Ty,\n-        default_bm: BindingMode,\n-        id: PatId,\n+        default_bm: T::BindingMode,\n+        id: T,\n         ellipsis: Option<usize>,\n+        subs: &[T],\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path, true);\n         let var_data = def.map(|it| it.variant_data(self.db.upcast()));\n@@ -39,8 +44,8 @@ impl<'a> InferenceContext<'a> {\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         let (pre, post) = match ellipsis {\n-            Some(idx) => subpats.split_at(idx),\n-            None => (subpats, &[][..]),\n+            Some(idx) => subs.split_at(idx),\n+            None => (subs, &[][..]),\n         };\n         let post_idx_offset = field_tys.iter().count().saturating_sub(post.len());\n \n@@ -54,22 +59,22 @@ impl<'a> InferenceContext<'a> {\n                     field_tys[field].clone().substitute(Interner, &substs)\n                 });\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n-            self.infer_pat(subpat, &expected_ty, default_bm);\n+            T::infer(self, subpat, &expected_ty, default_bm);\n         }\n \n         ty\n     }\n \n-    fn infer_record_pat(\n+    /// Infers type for record pattern or its corresponding assignee expression.\n+    pub(super) fn infer_record_pat_like<T: PatLike>(\n         &mut self,\n         path: Option<&Path>,\n-        subpats: &[RecordFieldPat],\n         expected: &Ty,\n-        default_bm: BindingMode,\n-        id: PatId,\n+        default_bm: T::BindingMode,\n+        id: T,\n+        subs: impl Iterator<Item = (Name, T)>,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path, false);\n-        let var_data = def.map(|it| it.variant_data(self.db.upcast()));\n         if let Some(variant) = def {\n             self.write_variant_resolution(id.into(), variant);\n         }\n@@ -80,18 +85,64 @@ impl<'a> InferenceContext<'a> {\n             ty.as_adt().map(|(_, s)| s.clone()).unwrap_or_else(|| Substitution::empty(Interner));\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n-        for subpat in subpats {\n-            let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n-            let expected_ty = matching_field.map_or(self.err_ty(), |field| {\n-                field_tys[field].clone().substitute(Interner, &substs)\n-            });\n+        let var_data = def.map(|it| it.variant_data(self.db.upcast()));\n+\n+        for (name, inner) in subs {\n+            let expected_ty = var_data\n+                .as_ref()\n+                .and_then(|it| it.field(&name))\n+                .map_or(self.err_ty(), |f| field_tys[f].clone().substitute(Interner, &substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n-            self.infer_pat(subpat.pat, &expected_ty, default_bm);\n+\n+            T::infer(self, inner, &expected_ty, default_bm);\n         }\n \n         ty\n     }\n \n+    /// Infers type for tuple pattern or its corresponding assignee expression.\n+    ///\n+    /// Ellipses found in the original pattern or expression must be filtered out.\n+    pub(super) fn infer_tuple_pat_like<T: PatLike>(\n+        &mut self,\n+        expected: &Ty,\n+        default_bm: T::BindingMode,\n+        ellipsis: Option<usize>,\n+        subs: &[T],\n+    ) -> Ty {\n+        let expectations = match expected.as_tuple() {\n+            Some(parameters) => &*parameters.as_slice(Interner),\n+            _ => &[],\n+        };\n+\n+        let ((pre, post), n_uncovered_patterns) = match ellipsis {\n+            Some(idx) => (subs.split_at(idx), expectations.len().saturating_sub(subs.len())),\n+            None => ((&subs[..], &[][..]), 0),\n+        };\n+        let mut expectations_iter = expectations\n+            .iter()\n+            .cloned()\n+            .map(|a| a.assert_ty_ref(Interner).clone())\n+            .chain(repeat_with(|| self.table.new_type_var()));\n+\n+        let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + subs.len());\n+\n+        inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns + subs.len()));\n+\n+        // Process pre\n+        for (ty, pat) in inner_tys.iter_mut().zip(pre) {\n+            *ty = T::infer(self, *pat, ty, default_bm);\n+        }\n+\n+        // Process post\n+        for (ty, pat) in inner_tys.iter_mut().skip(pre.len() + n_uncovered_patterns).zip(post) {\n+            *ty = T::infer(self, *pat, ty, default_bm);\n+        }\n+\n+        TyKind::Tuple(inner_tys.len(), Substitution::from_iter(Interner, inner_tys))\n+            .intern(Interner)\n+    }\n+\n     pub(super) fn infer_pat(\n         &mut self,\n         pat: PatId,\n@@ -129,42 +180,7 @@ impl<'a> InferenceContext<'a> {\n \n         let ty = match &self.body[pat] {\n             Pat::Tuple { args, ellipsis } => {\n-                let expectations = match expected.as_tuple() {\n-                    Some(parameters) => &*parameters.as_slice(Interner),\n-                    _ => &[],\n-                };\n-\n-                let ((pre, post), n_uncovered_patterns) = match ellipsis {\n-                    Some(idx) => {\n-                        (args.split_at(*idx), expectations.len().saturating_sub(args.len()))\n-                    }\n-                    None => ((&args[..], &[][..]), 0),\n-                };\n-                let mut expectations_iter = expectations\n-                    .iter()\n-                    .cloned()\n-                    .map(|a| a.assert_ty_ref(Interner).clone())\n-                    .chain(repeat_with(|| self.table.new_type_var()));\n-\n-                let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + args.len());\n-\n-                inner_tys\n-                    .extend(expectations_iter.by_ref().take(n_uncovered_patterns + args.len()));\n-\n-                // Process pre\n-                for (ty, pat) in inner_tys.iter_mut().zip(pre) {\n-                    *ty = self.infer_pat(*pat, ty, default_bm);\n-                }\n-\n-                // Process post\n-                for (ty, pat) in\n-                    inner_tys.iter_mut().skip(pre.len() + n_uncovered_patterns).zip(post)\n-                {\n-                    *ty = self.infer_pat(*pat, ty, default_bm);\n-                }\n-\n-                TyKind::Tuple(inner_tys.len(), Substitution::from_iter(Interner, inner_tys))\n-                    .intern(Interner)\n+                self.infer_tuple_pat_like(&expected, default_bm, *ellipsis, args)\n             }\n             Pat::Or(pats) => {\n                 if let Some((first_pat, rest)) = pats.split_first() {\n@@ -191,16 +207,18 @@ impl<'a> InferenceContext<'a> {\n                 let subty = self.infer_pat(*pat, &expectation, default_bm);\n                 TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n             }\n-            Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n-                p.as_deref(),\n-                subpats,\n-                &expected,\n-                default_bm,\n-                pat,\n-                *ellipsis,\n-            ),\n+            Pat::TupleStruct { path: p, args: subpats, ellipsis } => self\n+                .infer_tuple_struct_pat_like(\n+                    p.as_deref(),\n+                    &expected,\n+                    default_bm,\n+                    pat,\n+                    *ellipsis,\n+                    subpats,\n+                ),\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {\n-                self.infer_record_pat(p.as_deref(), fields, &expected, default_bm, pat)\n+                let subs = fields.iter().map(|f| (f.name.clone(), f.pat));\n+                self.infer_record_pat_like(p.as_deref(), &expected, default_bm, pat.into(), subs)\n             }\n             Pat::Path(path) => {\n                 // FIXME use correct resolver for the surrounding expression"}, {"sha": "0e512ef5ec9ec55a106bb3f569c8335ce9970adb", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=2ff505ab48faf3f5d3c4174449e3a53ece19141e", "patch": "@@ -312,6 +312,24 @@ fn f(text: &str) {\n     );\n }\n \n+#[test]\n+fn destructuring_assign_coerce() {\n+    check_no_mismatches(\n+        r\"\n+//- minicore: deref\n+struct String;\n+impl core::ops::Deref for String { type Target = str; }\n+fn g(_text: &str) {}\n+fn f(text: &str) {\n+    let mut text = text;\n+    let tmp = String;\n+    [text, _] = [&tmp, &tmp];\n+    g(text);\n+}\n+\",\n+    );\n+}\n+\n #[test]\n fn coerce_fn_item_to_fn_ptr() {\n     check_no_mismatches("}, {"sha": "535b948371c756d26dc77abfda96fd5b68b2610f", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 299, "deletions": 1, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff505ab48faf3f5d3c4174449e3a53ece19141e/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=2ff505ab48faf3f5d3c4174449e3a53ece19141e", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_no_mismatches, check_types};\n+use super::{check, check_infer, check_no_mismatches, check_types};\n \n #[test]\n fn infer_box() {\n@@ -2745,3 +2745,301 @@ fn f() {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn destructuring_assignment_slice() {\n+    check_types(\n+        r#\"\n+fn main() {\n+    let a;\n+      //^usize\n+    [a,] = [0usize];\n+\n+    let a;\n+      //^usize\n+    [a, ..] = [0usize; 5];\n+\n+    let a;\n+      //^usize\n+    [.., a] = [0usize; 5];\n+\n+    let a;\n+      //^usize\n+    [.., a, _] = [0usize; 5];\n+\n+    let a;\n+      //^usize\n+    [_, a, ..] = [0usize; 5];\n+\n+    let a: &mut i64 = &mut 0;\n+    [*a, ..] = [1, 2, 3];\n+\n+    let a: usize;\n+    let b;\n+      //^usize\n+    [a, _, b] = [3, 4, 5];\n+      //^usize\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^i64\n+    [[a, ..], .., [.., b]] = [[1, 2], [3i64, 4], [5, 6], [7, 8]];\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_tuple() {\n+    check_types(\n+        r#\"\n+fn main() {\n+    let a;\n+      //^char\n+    let b;\n+      //^i64\n+    (a, b) = ('c', 0i64);\n+\n+    let a;\n+      //^char\n+    (a, ..) = ('c', 0i64);\n+\n+    let a;\n+      //^i64\n+    (.., a) = ('c', 0i64);\n+\n+    let a;\n+      //^char\n+    let b;\n+      //^i64\n+    (a, .., b) = ('c', 0i64);\n+\n+    let a;\n+      //^char\n+    let b;\n+      //^bool\n+    (a, .., b) = ('c', 0i64, true);\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^bool\n+    (_, a, .., b) = ('c', 0i64, true);\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^usize\n+    (_, a, .., b) = ('c', 0i64, true, 0usize);\n+\n+    let mut a = 1;\n+      //^^^^^i64\n+    let mut b: i64 = 0;\n+    (a, b) = (b, a);\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_tuple_struct() {\n+    check_types(\n+        r#\"\n+struct S2(char, i64);\n+struct S3(char, i64, bool);\n+struct S4(char, i64, bool usize);\n+fn main() {\n+    let a;\n+      //^char\n+    let b;\n+      //^i64\n+    S2(a, b) = S2('c', 0i64);\n+\n+    let a;\n+      //^char\n+    let b;\n+      //^i64\n+    S2(a, .., b) = S2('c', 0i64);\n+\n+    let a;\n+      //^char\n+    let b;\n+      //^bool\n+    S3(a, .., b) = S3('c', 0i64, true);\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^bool\n+    S3(_, a, .., b) = S3('c', 0i64, true);\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^usize\n+    S4(_, a, .., b) = S4('c', 0i64, true, 0usize);\n+\n+    struct Swap(i64, i64);\n+\n+    let mut a = 1;\n+      //^^^^^i64\n+    let mut b = 0;\n+      //^^^^^i64\n+    Swap(a, b) = Swap(b, a);\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_struct() {\n+    check_types(\n+        r#\"\n+struct S {\n+    a: usize,\n+    b: char,\n+}\n+struct T {\n+    s: S,\n+    t: i64,\n+}\n+\n+fn main() {\n+    let a;\n+      //^usize\n+    let c;\n+      //^char\n+    S { a, b: c } = S { a: 3, b: 'b' };\n+\n+    let a;\n+      //^char\n+    S { b: a, .. } = S { a: 3, b: 'b' };\n+\n+    let a;\n+      //^char\n+    S { b: a, _ } = S { a: 3, b: 'b' };\n+\n+    let a;\n+      //^usize\n+    let c;\n+      //^char\n+    let t;\n+      //^i64\n+    T { s: S { a, b: c }, t } = T { s: S { a: 3, b: 'b' }, t: 0 };\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_nested() {\n+    check_types(\n+        r#\"\n+struct S {\n+    a: TS,\n+    b: [char; 3],\n+}\n+struct TS(usize, i64);\n+\n+fn main() {\n+    let a;\n+      //^i32\n+    let b;\n+      //^bool\n+    ([.., a], .., b, _) = ([0, 1, 2], true, 'c');\n+\n+    let a;\n+      //^i32\n+    let b;\n+      //^i32\n+    [(.., a, _), .., (b, ..)] = [(1, 2); 5];\n+\n+    let a;\n+      //^usize\n+    let b;\n+      //^char\n+    S { a: TS(a, ..), b: [_, b, ..] } = S { a: TS(0, 0), b: ['a'; 3] };\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_unit_struct() {\n+    // taken from rustc; see https://github.com/rust-lang/rust/pull/95380\n+    check_no_mismatches(\n+        r#\"\n+struct S;\n+enum E { V, }\n+type A = E;\n+\n+fn main() {\n+    let mut a;\n+\n+    (S, a) = (S, ());\n+\n+    (E::V, a) = (E::V, ());\n+\n+    (<E>::V, a) = (E::V, ());\n+    (A::V, a) = (E::V, ());\n+}\n+\n+impl S {\n+    fn check() {\n+        let a;\n+        (Self, a) = (S, ());\n+    }\n+}\n+\n+impl E {\n+    fn check() {\n+        let a;\n+        (Self::V, a) = (E::V, ());\n+    }\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_no_default_binding_mode() {\n+    check(\n+        r#\"\n+struct S { a: usize }\n+struct TS(usize);\n+fn main() {\n+    let x;\n+    [x,] = &[1,];\n+  //^^^^expected &[i32; 1], got [{unknown}; _]\n+\n+    // FIXME we only want the outermost error, but this matches the current\n+    // behavior of slice patterns\n+    let x;\n+    [(x,),] = &[(1,),];\n+  // ^^^^expected {unknown}, got ({unknown},)\n+  //^^^^^^^expected &[(i32,); 1], got [{unknown}; _]\n+\n+    let x;\n+    ((x,),) = &((1,),);\n+  //^^^^^^^expected &((i32,),), got (({unknown},),)\n+\n+    let x;\n+    (x,) = &(1,);\n+  //^^^^expected &(i32,), got ({unknown},)\n+\n+    let x;\n+    (S { a: x },) = &(S { a: 42 },);\n+  //^^^^^^^^^^^^^expected &(S,), got (S,)\n+\n+    let x;\n+    S { a: x } = &S { a: 42 };\n+  //^^^^^^^^^^expected &S, got S\n+\n+    let x;\n+    TS(x) = &TS(42);\n+  //^^^^^expected &TS, got TS\n+}\n+        \"#,\n+    );\n+}"}]}