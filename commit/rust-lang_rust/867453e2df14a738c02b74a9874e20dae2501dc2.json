{"sha": "867453e2df14a738c02b74a9874e20dae2501dc2", "node_id": "C_kwDOAAsO6NoAKDg2NzQ1M2UyZGYxNGE3MzhjMDJiNzRhOTg3NGUyMGRhZTI1MDFkYzI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-09T22:00:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-09T22:00:28Z"}, "message": "Rollup merge of #100098 - compiler-errors:field-suggestion-fixups, r=davidtwco\n\nSome \"this expression has a field\"-related fixes\n\nEach commit does something different and is worth reviewing, but the final diff from `master..HEAD` contains the sum of the changes to the UI tests, since some commits added UI tests \"regressions\" which were later removed in other commits.\n\nThe only change I could see adding on top of this is suppressing `Clone::clone` from the \"this expression has a field that has this method\" suggestion, since it's so commonly implemented by types that it's not worthwhile suggesting in general.", "tree": {"sha": "e078509fbe409ada679bdb72b351bc603f0e42ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e078509fbe409ada679bdb72b351bc603f0e42ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/867453e2df14a738c02b74a9874e20dae2501dc2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi8tj8CRBK7hj4Ov3rIwAASo4IAFPM2Nqwen4HHFubmbUfNXP6\nbY7AJViXSCMm4YYHYtbg0MObKRLFPPnD1P9Eq+uKyxOd9cpxIKSwbTn0JfAxQWLg\nQ4NQw3nad2ZZWYNE0YZ9nZE/WkkvEBUckO2Rg9HeCjHumBuueeXuojCuj+MM1/zB\nq395XVv2h8P6kWlp4YtwtLMkIQW9rdCGhP/q6FVmoHiMlwWwEzVMvsgTJrJ9UKyg\njaTKGSQQA9stTzjv+nFsTlVJV/5vHjJ2cehCuO24VBbZAouNzblawXPYsiTw8tWZ\nvozGQ/tkSsEDBeVUR56l8cOjgQC+9ZcF+z1n3f6RQOQI2KUMYA6ICbyThibTO5k=\n=fga1\n-----END PGP SIGNATURE-----\n", "payload": "tree e078509fbe409ada679bdb72b351bc603f0e42ae\nparent 2059391eb2cebb798e2d713ea60bd99a8c389432\nparent 603ffebd37a26a5b8d3c7372d432f6f2c053371d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1660082428 +0200\ncommitter GitHub <noreply@github.com> 1660082428 +0200\n\nRollup merge of #100098 - compiler-errors:field-suggestion-fixups, r=davidtwco\n\nSome \"this expression has a field\"-related fixes\n\nEach commit does something different and is worth reviewing, but the final diff from `master..HEAD` contains the sum of the changes to the UI tests, since some commits added UI tests \"regressions\" which were later removed in other commits.\n\nThe only change I could see adding on top of this is suppressing `Clone::clone` from the \"this expression has a field that has this method\" suggestion, since it's so commonly implemented by types that it's not worthwhile suggesting in general.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/867453e2df14a738c02b74a9874e20dae2501dc2", "html_url": "https://github.com/rust-lang/rust/commit/867453e2df14a738c02b74a9874e20dae2501dc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/867453e2df14a738c02b74a9874e20dae2501dc2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2059391eb2cebb798e2d713ea60bd99a8c389432", "url": "https://api.github.com/repos/rust-lang/rust/commits/2059391eb2cebb798e2d713ea60bd99a8c389432", "html_url": "https://github.com/rust-lang/rust/commit/2059391eb2cebb798e2d713ea60bd99a8c389432"}, {"sha": "603ffebd37a26a5b8d3c7372d432f6f2c053371d", "url": "https://api.github.com/repos/rust-lang/rust/commits/603ffebd37a26a5b8d3c7372d432f6f2c053371d", "html_url": "https://github.com/rust-lang/rust/commit/603ffebd37a26a5b8d3c7372d432f6f2c053371d"}], "stats": {"total": 158, "additions": 117, "deletions": 41}, "files": [{"sha": "a685add7f56a61903ab96c022c45e16d1bfdcbed", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/867453e2df14a738c02b74a9874e20dae2501dc2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/867453e2df14a738c02b74a9874e20dae2501dc2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=867453e2df14a738c02b74a9874e20dae2501dc2", "patch": "@@ -2526,15 +2526,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         // try to add a suggestion in case the field is a nested field of a field of the Adt\n-        if let Some((fields, substs)) = self.get_field_candidates(span, expr_t) {\n-            for candidate_field in fields.iter() {\n+        let mod_id = self.tcx.parent_module(id).to_def_id();\n+        if let Some((fields, substs)) =\n+            self.get_field_candidates_considering_privacy(span, expr_t, mod_id)\n+        {\n+            for candidate_field in fields {\n                 if let Some(mut field_path) = self.check_for_nested_field_satisfying(\n                     span,\n                     &|candidate_field, _| candidate_field.ident(self.tcx()) == field,\n                     candidate_field,\n                     substs,\n                     vec![],\n-                    self.tcx.parent_module(id).to_def_id(),\n+                    mod_id,\n                 ) {\n                     // field_path includes `field` that we're looking for, so pop it.\n                     field_path.pop();\n@@ -2558,22 +2561,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err\n     }\n \n-    pub(crate) fn get_field_candidates(\n+    pub(crate) fn get_field_candidates_considering_privacy(\n         &self,\n         span: Span,\n-        base_t: Ty<'tcx>,\n-    ) -> Option<(&[ty::FieldDef], SubstsRef<'tcx>)> {\n-        debug!(\"get_field_candidates(span: {:?}, base_t: {:?}\", span, base_t);\n+        base_ty: Ty<'tcx>,\n+        mod_id: DefId,\n+    ) -> Option<(impl Iterator<Item = &'tcx ty::FieldDef> + 'tcx, SubstsRef<'tcx>)> {\n+        debug!(\"get_field_candidates(span: {:?}, base_t: {:?}\", span, base_ty);\n \n-        for (base_t, _) in self.autoderef(span, base_t) {\n+        for (base_t, _) in self.autoderef(span, base_ty) {\n             match base_t.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n+                    let tcx = self.tcx;\n                     let fields = &base_def.non_enum_variant().fields;\n-                    // For compile-time reasons put a limit on number of fields we search\n-                    if fields.len() > 100 {\n-                        return None;\n+                    // Some struct, e.g. some that impl `Deref`, have all private fields\n+                    // because you're expected to deref them to access the _real_ fields.\n+                    // This, for example, will help us suggest accessing a field through a `Box<T>`.\n+                    if fields.iter().all(|field| !field.vis.is_accessible_from(mod_id, tcx)) {\n+                        continue;\n                     }\n-                    return Some((fields, substs));\n+                    return Some((\n+                        fields\n+                            .iter()\n+                            .filter(move |field| field.vis.is_accessible_from(mod_id, tcx))\n+                            // For compile-time reasons put a limit on number of fields we search\n+                            .take(100),\n+                        substs,\n+                    ));\n                 }\n                 _ => {}\n             }\n@@ -2590,7 +2604,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         candidate_field: &ty::FieldDef,\n         subst: SubstsRef<'tcx>,\n         mut field_path: Vec<Ident>,\n-        id: DefId,\n+        mod_id: DefId,\n     ) -> Option<Vec<Ident>> {\n         debug!(\n             \"check_for_nested_field_satisfying(span: {:?}, candidate_field: {:?}, field_path: {:?}\",\n@@ -2602,24 +2616,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // up to a depth of three\n             None\n         } else {\n-            // recursively search fields of `candidate_field` if it's a ty::Adt\n             field_path.push(candidate_field.ident(self.tcx).normalize_to_macros_2_0());\n             let field_ty = candidate_field.ty(self.tcx, subst);\n-            if let Some((nested_fields, subst)) = self.get_field_candidates(span, field_ty) {\n-                for field in nested_fields.iter() {\n-                    if field.vis.is_accessible_from(id, self.tcx) {\n-                        if matches(candidate_field, field_ty) {\n-                            return Some(field_path);\n-                        } else if let Some(field_path) = self.check_for_nested_field_satisfying(\n-                            span,\n-                            matches,\n-                            field,\n-                            subst,\n-                            field_path.clone(),\n-                            id,\n-                        ) {\n-                            return Some(field_path);\n-                        }\n+            if matches(candidate_field, field_ty) {\n+                return Some(field_path);\n+            } else if let Some((nested_fields, subst)) =\n+                self.get_field_candidates_considering_privacy(span, field_ty, mod_id)\n+            {\n+                // recursively search fields of `candidate_field` if it's a ty::Adt\n+                for field in nested_fields {\n+                    if let Some(field_path) = self.check_for_nested_field_satisfying(\n+                        span,\n+                        matches,\n+                        field,\n+                        subst,\n+                        field_path.clone(),\n+                        mod_id,\n+                    ) {\n+                        return Some(field_path);\n                     }\n                 }\n             }"}, {"sha": "f73d0fbb277163acfa2541162a924b2ef1e9fe6c", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/867453e2df14a738c02b74a9874e20dae2501dc2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/867453e2df14a738c02b74a9874e20dae2501dc2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=867453e2df14a738c02b74a9874e20dae2501dc2", "patch": "@@ -1000,7 +1000,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found(&mut err);\n                 }\n \n-                self.check_for_field_method(&mut err, source, span, actual, item_name);\n+                // Don't suggest (for example) `expr.field.method()` if `expr.method()`\n+                // doesn't exist due to unsatisfied predicates.\n+                if unsatisfied_predicates.is_empty() {\n+                    self.check_for_field_method(&mut err, source, span, actual, item_name);\n+                }\n \n                 self.check_for_unwrap_self(&mut err, source, span, actual, item_name);\n \n@@ -1334,10 +1338,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         item_name: Ident,\n     ) {\n         if let SelfSource::MethodCall(expr) = source\n-            && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n+            && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n+            && let Some((fields, substs)) = self.get_field_candidates_considering_privacy(span, actual, mod_id)\n         {\n             let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-            for candidate_field in fields.iter() {\n+            for candidate_field in fields {\n                 if let Some(field_path) = self.check_for_nested_field_satisfying(\n                     span,\n                     &|_, field_ty| {\n@@ -1353,7 +1358,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     candidate_field,\n                     substs,\n                     vec![],\n-                    self.tcx.parent_module(expr.hir_id).to_def_id(),\n+                    mod_id,\n                 ) {\n                     let field_path_str = field_path\n                         .iter()"}, {"sha": "b92449c6e0aff6776e77d51a8efcc9a96e22b265", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=867453e2df14a738c02b74a9874e20dae2501dc2", "patch": "@@ -10,6 +10,10 @@ LL |     let _y = x.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let _y = x.i.clone();\n+   |                ++\n \n error: aborting due to previous error\n "}, {"sha": "ffe3d7b81f51eca8b207d10a60cd3f5154cef018", "filename": "src/test/ui/hrtb/issue-30786.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.stderr?ref=867453e2df14a738c02b74a9874e20dae2501dc2", "patch": "@@ -18,10 +18,6 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let filter = map.stream.filterx(|x: &_| true);\n-   |                      +++++++\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:129:30: 129:37]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:130:24\n@@ -43,10 +39,6 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let count = filter.stream.countx();\n-   |                        +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "208b340d0641067309f2545dff511e8851662e9d", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=867453e2df14a738c02b74a9874e20dae2501dc2", "patch": "@@ -10,6 +10,10 @@ LL |     let _d = c.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let _d = c.x.clone();\n+   |                ++\n \n error: aborting due to previous error\n "}, {"sha": "15e22e946da8a1da79630526c7f82f0fff9b02cb", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=867453e2df14a738c02b74a9874e20dae2501dc2", "patch": "@@ -10,6 +10,14 @@ LL |     let _y = x.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let _y = x.i.clone();\n+   |                ++\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let _y = x.j.x.clone();\n+   |                ++++\n \n error: aborting due to previous error\n "}, {"sha": "3de06b21420b4771d5303554fa8b99ef9392f15b", "filename": "src/test/ui/suggestions/field-access-considering-privacy.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.rs?ref=867453e2df14a738c02b74a9874e20dae2501dc2", "patch": "@@ -0,0 +1,35 @@\n+use a::TyCtxt;\n+\n+mod a {\n+    use std::ops::Deref;\n+    pub struct TyCtxt<'tcx> {\n+        gcx: &'tcx GlobalCtxt<'tcx>,\n+    }\n+\n+    impl<'tcx> Deref for TyCtxt<'tcx> {\n+        type Target = &'tcx GlobalCtxt<'tcx>;\n+\n+        fn deref(&self) -> &Self::Target {\n+            &self.gcx\n+        }\n+    }\n+\n+    pub struct GlobalCtxt<'tcx> {\n+        pub sess: &'tcx Session,\n+        _t: &'tcx (),\n+    }\n+\n+    pub struct Session {\n+        pub opts: (),\n+    }\n+}\n+\n+mod b {\n+    fn foo<'tcx>(tcx: crate::TyCtxt<'tcx>) {\n+        tcx.opts;\n+        //~^ ERROR no field `opts` on type `TyCtxt<'tcx>`\n+        //~| HELP one of the expressions' fields has a field of the same name\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "cbf6f3d10025856fdabcf425d7399f98493f5b8f", "filename": "src/test/ui/suggestions/field-access-considering-privacy.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/867453e2df14a738c02b74a9874e20dae2501dc2/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.stderr?ref=867453e2df14a738c02b74a9874e20dae2501dc2", "patch": "@@ -0,0 +1,14 @@\n+error[E0609]: no field `opts` on type `TyCtxt<'tcx>`\n+  --> $DIR/field-access-considering-privacy.rs:29:13\n+   |\n+LL |         tcx.opts;\n+   |             ^^^^ unknown field\n+   |\n+help: one of the expressions' fields has a field of the same name\n+   |\n+LL |         tcx.sess.opts;\n+   |             +++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0609`."}]}