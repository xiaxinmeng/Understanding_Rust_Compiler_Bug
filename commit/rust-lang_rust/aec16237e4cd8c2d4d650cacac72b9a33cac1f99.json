{"sha": "aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYzE2MjM3ZTRjZDhjMmQ0ZDY1MGNhY2FjNzJiOWEzM2NhYzFmOTk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-07T05:10:51Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-15T06:46:23Z"}, "message": "Suggest casting on numeric type error", "tree": {"sha": "a92044fd8e8499d16464b02a6a6f76488e7ed797", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a92044fd8e8499d16464b02a6a6f76488e7ed797"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "html_url": "https://github.com/rust-lang/rust/commit/aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb345a0be3ba3fa1970fe02789791c5c72788d8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb345a0be3ba3fa1970fe02789791c5c72788d8f", "html_url": "https://github.com/rust-lang/rust/commit/bb345a0be3ba3fa1970fe02789791c5c72788d8f"}], "stats": {"total": 1950, "additions": 1946, "deletions": 4}, "files": [{"sha": "38b6bffcadd6b2543a0cdc4dd67353fe8f6658fe", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "patch": "@@ -1173,6 +1173,37 @@ impl fmt::Debug for Expr {\n     }\n }\n \n+impl Expr {\n+\n+    /// If casting this expression to a given numeric type would be appropriate in case of a type\n+    /// mismatch.\n+    ///\n+    /// We want to minimize the amount of casting operations that are suggested, as it can be a\n+    /// lossy operation with potentially bad side effects, so we only suggest when encountering an\n+    /// expression that indicates that the original type couldn't be directly changed.\n+    pub fn could_cast_in_type_mismatch(&self) -> bool {\n+        match self.node {\n+            ExprCall(..) |\n+            ExprMethodCall(..) |\n+            ExprBinary(..) |\n+            ExprField(..) |\n+            ExprTupField(..) |\n+            ExprIndex(..) |\n+            ExprPath(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn needs_parens_around_cast(&self) -> bool {\n+        match self.node {\n+            ExprBinary(..) |\n+            ExprCast(..) |\n+            ExprType(..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Expr_ {\n     /// A `box x` expression."}, {"sha": "7c55df7ff445f94e1759d7e0eb9e8a464624e43b", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 172, "deletions": 4, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((msg, suggestion)) = self.check_ref(expr, checked_ty, expected) {\n             err.span_suggestion(expr.span, msg, suggestion);\n-        } else {\n+        } else if !self.check_for_cast(&mut err, expr, expr_ty, expected) {\n             let methods = self.get_conversion_methods(expected, checked_ty);\n             if let Ok(expr_text) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                 let suggestions = iter::repeat(expr_text).zip(methods.iter())\n@@ -287,8 +287,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // Maybe remove `&`?\n                         hir::ExprAddrOf(_, ref expr) => {\n                             if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n-                                return Some((\"consider removing the borrow\",\n-                                             code));\n+                                return Some((\"consider removing the borrow\", code));\n                             }\n                         }\n \n@@ -303,12 +302,181 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                  format!(\"*{}\", code)));\n                                 }\n                             }\n-                        },\n+                        }\n                     }\n                 }\n                 None\n             }\n             _ => None,\n         }\n     }\n+\n+    fn check_for_cast(&self,\n+                      err: &mut DiagnosticBuilder<'tcx>,\n+                      expr: &hir::Expr,\n+                      checked_ty: Ty<'tcx>,\n+                      expected_ty: Ty<'tcx>)\n+                      -> bool {\n+        let will_truncate = \"will truncate the source value\";\n+        let depending_on_isize = \"will truncate or zero-extend depending on the bit width of \\\n+                                  `isize`\";\n+        let depending_on_usize = \"will truncate or zero-extend depending on the bit width of \\\n+                                  `usize`\";\n+        let will_sign_extend = \"will sign-extend the source value\";\n+        let will_zero_extend = \"will zero-extend the source value\";\n+\n+        let needs_paren = expr.needs_parens_around_cast();\n+\n+        if let (Ok(src), true) = (self.tcx.sess.codemap().span_to_snippet(expr.span),\n+                                  expr.could_cast_in_type_mismatch()) {\n+            let msg = format!(\"you can cast an `{}` to `{}`\", checked_ty, expected_ty);\n+            let suggestion = format!(\"{}{} as {}{}\",\n+                                     if needs_paren { \"(\" } else { \"\" },\n+                                     src,\n+                                     if needs_paren { \")\" } else { \"\" },\n+                                     expected_ty);\n+\n+            match (&expected_ty.sty, &checked_ty.sty) {\n+                (&ty::TyInt(ref exp), &ty::TyInt(ref found)) => {\n+                    match (found.bit_width(), exp.bit_width()) {\n+                        (Some(found), Some(exp)) if found > exp => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_truncate),\n+                                                suggestion);\n+                        }\n+                        (None, _) | (_, None) => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                                suggestion);\n+                        }\n+                        _ => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                suggestion);\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(ref exp), &ty::TyUint(ref found)) => {\n+                    match (found.bit_width(), exp.bit_width()) {\n+                        (Some(found), Some(exp)) if found > exp => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_truncate),\n+                                                suggestion);\n+                        }\n+                        (None, _) | (_, None) => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                                suggestion);\n+                        }\n+                        _ => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                                suggestion);\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyInt(ref exp), &ty::TyUint(ref found)) => {\n+                    match (found.bit_width(), exp.bit_width()) {\n+                        (Some(found), Some(exp)) if found > exp - 1 => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_truncate),\n+                                                suggestion);\n+                        }\n+                        (None, None) => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_truncate),\n+                                                suggestion);\n+                        }\n+                        (None, _) => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                                suggestion);\n+                        }\n+                        (_, None) => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                                suggestion);\n+                        }\n+                        _ => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                                suggestion);\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(ref exp), &ty::TyInt(ref found)) => {\n+                    match (found.bit_width(), exp.bit_width()) {\n+                        (Some(found), Some(exp)) if found - 1 > exp => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_truncate),\n+                                                suggestion);\n+                        }\n+                        (None, None) => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                suggestion);\n+                        }\n+                        (None, _) => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                                suggestion);\n+                        }\n+                        (_, None) => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                                suggestion);\n+                        }\n+                        _ => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                suggestion);\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyFloat(ref exp), &ty::TyFloat(ref found)) => {\n+                    if found.bit_width() > exp.bit_width() {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the closest possible value\",\n+                                                     msg),\n+                                            suggestion);\n+                        err.warn(\"casting here will cause Undefined Behavior if the value is \\\n+                                  finite but larger or smaller than the largest or smallest \\\n+                                  finite value representable by `f32` (this is a bug and will be \\\n+                                  fixed)\");\n+                    } else {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{} in a lossless way\",\n+                                                     msg),\n+                                            suggestion);\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(_), &ty::TyFloat(_)) | (&ty::TyInt(_), &ty::TyFloat(_)) => {\n+                    err.span_suggestion(expr.span,\n+                                        &format!(\"{}, rounding the float towards zero\",\n+                                                 msg),\n+                                        suggestion);\n+                    err.warn(\"casting here will cause Undefined Behavior if the rounded value \\\n+                              cannot be represented by the target integer type, including `Inf` \\\n+                              and `NaN` (this is a bug and will be fixed)\");\n+                    true\n+                }\n+                (&ty::TyFloat(_), &ty::TyUint(_)) | (&ty::TyFloat(_), &ty::TyInt(_)) => {\n+                    err.span_suggestion(expr.span,\n+                                        &format!(\"{}, producing the floating point representation \\\n+                                                  of the integer, rounded if necessary\",\n+                                                  msg),\n+                                        suggestion);\n+                    true\n+                }\n+                _ => false,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n }"}, {"sha": "36c5767fc0bd0e2361b0949e8fe911709f3e2c8f", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "patch": "@@ -6,6 +6,10 @@ error[E0308]: mismatched types\n ...\n 37 |     write!(hello);\n    |     -------------- in this macro invocation\n+help: you can cast an `usize` to `u64`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+26 |                   ($arr.len() * size_of($arr[0]) as )u64); //~ ERROR mismatched types\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0605]: non-primitive cast: `{integer}` as `()`\n   --> $DIR/issue-26480.rs:32:19"}, {"sha": "24796fbe460457d99145ac9567b35087187eb63f", "filename": "src/test/ui/suggestions/numeric-cast-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs?ref=aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() -> i32 {\n+    4\n+}\n+fn main() {\n+    let x: u32 = foo();\n+    let z: i32 = x + x;\n+}"}, {"sha": "c31095c102df1eb89daf5e3a686b4290c575d556", "filename": "src/test/ui/suggestions/numeric-cast-2.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr?ref=aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-2.rs:15:18\n+   |\n+15 |     let x: u32 = foo();\n+   |                  ^^^^^ expected u32, found i32\n+help: you can cast an `i32` to `u32`, which will sign-extend the source value\n+   |\n+15 |     let x: u32 = foo() as u32;\n+   |                  ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-2.rs:16:18\n+   |\n+16 |     let z: i32 = x + x;\n+   |                  ^^^^^ expected i32, found u32\n+help: you can cast an `u32` to `i32`, which will truncate the source value\n+   |\n+16 |     let z: i32 = (x + x as )i32;\n+   |                  ^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "cca735d30d8cbbc29cc6d5eb23441bb17b14cdef", "filename": "src/test/ui/suggestions/numeric-cast.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs?ref=aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "patch": "@@ -0,0 +1,336 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+fn foo<N>(_x: N) {}\n+\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u64: u64 = 2;\n+    let x_u32: u32 = 3;\n+    let x_u16: u16 = 4;\n+    let x_u8: u8 = 5;\n+    let x_isize: isize = 6;\n+    let x_i64: i64 = 7;\n+    let x_i32: i32 = 8;\n+    let x_i16: i16 = 9;\n+    let x_i8: i8 = 10;\n+    let x_f64: f64 = 11.0;\n+    let x_f32: f32 = 12.0;\n+\n+    foo::<usize>(x_usize);\n+    foo::<usize>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<usize>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<isize>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_isize);\n+    foo::<isize>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<isize>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<u64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u64);\n+    foo::<u64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<u64>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<i64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i64);\n+    foo::<i64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<i64>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<u32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u32);\n+    foo::<u32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<u32>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<i32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i32);\n+    foo::<i32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<i32>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<u16>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u16);\n+    foo::<u16>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<u16>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<i16>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i16);\n+    foo::<i16>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<i16>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<u8>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u8);\n+    foo::<u8>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<u8>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<i8>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i8);\n+    foo::<i8>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<i8>(x_f32);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+\n+    foo::<f64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_f64);\n+    foo::<f64>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<f32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_f64);\n+    //~^ ERROR mismatched types\n+    //~| WARN casting here will cause Undefined Behavior\n+    foo::<f32>(x_f32);\n+}"}, {"sha": "4f4e4205f1fbbe1bc42c27a5a56e42b574c6710e", "filename": "src/test/ui/suggestions/numeric-cast.stderr", "status": "added", "additions": 1364, "deletions": 0, "changes": 1364, "blob_url": "https://github.com/rust-lang/rust/blob/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aec16237e4cd8c2d4d650cacac72b9a33cac1f99/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr?ref=aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "patch": "@@ -0,0 +1,1364 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:29:18\n+   |\n+29 |     foo::<usize>(x_u64);\n+   |                  ^^^^^ expected usize, found u64\n+help: you can cast an `u64` to `usize`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+29 |     foo::<usize>(x_u64 as usize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:31:18\n+   |\n+31 |     foo::<usize>(x_u32);\n+   |                  ^^^^^ expected usize, found u32\n+help: you can cast an `u32` to `usize`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+31 |     foo::<usize>(x_u32 as usize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:33:18\n+   |\n+33 |     foo::<usize>(x_u16);\n+   |                  ^^^^^ expected usize, found u16\n+help: you can cast an `u16` to `usize`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+33 |     foo::<usize>(x_u16 as usize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:35:18\n+   |\n+35 |     foo::<usize>(x_u8);\n+   |                  ^^^^ expected usize, found u8\n+help: you can cast an `u8` to `usize`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+35 |     foo::<usize>(x_u8 as usize);\n+   |                  ^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:37:18\n+   |\n+37 |     foo::<usize>(x_isize);\n+   |                  ^^^^^^^ expected usize, found isize\n+help: you can cast an `isize` to `usize`, which will sign-extend the source value\n+   |\n+37 |     foo::<usize>(x_isize as usize);\n+   |                  ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:39:18\n+   |\n+39 |     foo::<usize>(x_i64);\n+   |                  ^^^^^ expected usize, found i64\n+help: you can cast an `i64` to `usize`, which will truncate or zero-extend depending on the bit width of `isize`\n+   |\n+39 |     foo::<usize>(x_i64 as usize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:41:18\n+   |\n+41 |     foo::<usize>(x_i32);\n+   |                  ^^^^^ expected usize, found i32\n+help: you can cast an `i32` to `usize`, which will truncate or zero-extend depending on the bit width of `isize`\n+   |\n+41 |     foo::<usize>(x_i32 as usize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:43:18\n+   |\n+43 |     foo::<usize>(x_i16);\n+   |                  ^^^^^ expected usize, found i16\n+help: you can cast an `i16` to `usize`, which will truncate or zero-extend depending on the bit width of `isize`\n+   |\n+43 |     foo::<usize>(x_i16 as usize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:45:18\n+   |\n+45 |     foo::<usize>(x_i8);\n+   |                  ^^^^ expected usize, found i8\n+help: you can cast an `i8` to `usize`, which will truncate or zero-extend depending on the bit width of `isize`\n+   |\n+45 |     foo::<usize>(x_i8 as usize);\n+   |                  ^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:47:18\n+   |\n+47 |     foo::<usize>(x_f64);\n+   |                  ^^^^^ expected usize, found f64\n+   |\n+   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `usize`, rounding the float towards zero\n+   |\n+47 |     foo::<usize>(x_f64 as usize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:50:18\n+   |\n+50 |     foo::<usize>(x_f32);\n+   |                  ^^^^^ expected usize, found f32\n+   |\n+   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `usize`, rounding the float towards zero\n+   |\n+50 |     foo::<usize>(x_f32 as usize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:54:18\n+   |\n+54 |     foo::<isize>(x_usize);\n+   |                  ^^^^^^^ expected isize, found usize\n+help: you can cast an `usize` to `isize`, which will truncate the source value\n+   |\n+54 |     foo::<isize>(x_usize as isize);\n+   |                  ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:56:18\n+   |\n+56 |     foo::<isize>(x_u64);\n+   |                  ^^^^^ expected isize, found u64\n+help: you can cast an `u64` to `isize`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+56 |     foo::<isize>(x_u64 as isize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:58:18\n+   |\n+58 |     foo::<isize>(x_u32);\n+   |                  ^^^^^ expected isize, found u32\n+help: you can cast an `u32` to `isize`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+58 |     foo::<isize>(x_u32 as isize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:60:18\n+   |\n+60 |     foo::<isize>(x_u16);\n+   |                  ^^^^^ expected isize, found u16\n+help: you can cast an `u16` to `isize`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+60 |     foo::<isize>(x_u16 as isize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:62:18\n+   |\n+62 |     foo::<isize>(x_u8);\n+   |                  ^^^^ expected isize, found u8\n+help: you can cast an `u8` to `isize`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+62 |     foo::<isize>(x_u8 as isize);\n+   |                  ^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:65:18\n+   |\n+65 |     foo::<isize>(x_i64);\n+   |                  ^^^^^ expected isize, found i64\n+help: you can cast an `i64` to `isize`, which will truncate or zero-extend depending on the bit width of `isize`\n+   |\n+65 |     foo::<isize>(x_i64 as isize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:67:18\n+   |\n+67 |     foo::<isize>(x_i32);\n+   |                  ^^^^^ expected isize, found i32\n+help: you can cast an `i32` to `isize`, which will truncate or zero-extend depending on the bit width of `isize`\n+   |\n+67 |     foo::<isize>(x_i32 as isize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:69:18\n+   |\n+69 |     foo::<isize>(x_i16);\n+   |                  ^^^^^ expected isize, found i16\n+help: you can cast an `i16` to `isize`, which will truncate or zero-extend depending on the bit width of `isize`\n+   |\n+69 |     foo::<isize>(x_i16 as isize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:71:18\n+   |\n+71 |     foo::<isize>(x_i8);\n+   |                  ^^^^ expected isize, found i8\n+help: you can cast an `i8` to `isize`, which will truncate or zero-extend depending on the bit width of `isize`\n+   |\n+71 |     foo::<isize>(x_i8 as isize);\n+   |                  ^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:73:18\n+   |\n+73 |     foo::<isize>(x_f64);\n+   |                  ^^^^^ expected isize, found f64\n+   |\n+   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `isize`, rounding the float towards zero\n+   |\n+73 |     foo::<isize>(x_f64 as isize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:76:18\n+   |\n+76 |     foo::<isize>(x_f32);\n+   |                  ^^^^^ expected isize, found f32\n+   |\n+   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `isize`, rounding the float towards zero\n+   |\n+76 |     foo::<isize>(x_f32 as isize);\n+   |                  ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:80:16\n+   |\n+80 |     foo::<u64>(x_usize);\n+   |                ^^^^^^^ expected u64, found usize\n+help: you can cast an `usize` to `u64`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+80 |     foo::<u64>(x_usize as u64);\n+   |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:83:16\n+   |\n+83 |     foo::<u64>(x_u32);\n+   |                ^^^^^ expected u64, found u32\n+help: you can cast an `u32` to `u64`, which will zero-extend the source value\n+   |\n+83 |     foo::<u64>(x_u32 as u64);\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:85:16\n+   |\n+85 |     foo::<u64>(x_u16);\n+   |                ^^^^^ expected u64, found u16\n+help: you can cast an `u16` to `u64`, which will zero-extend the source value\n+   |\n+85 |     foo::<u64>(x_u16 as u64);\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:87:16\n+   |\n+87 |     foo::<u64>(x_u8);\n+   |                ^^^^ expected u64, found u8\n+help: you can cast an `u8` to `u64`, which will zero-extend the source value\n+   |\n+87 |     foo::<u64>(x_u8 as u64);\n+   |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:89:16\n+   |\n+89 |     foo::<u64>(x_isize);\n+   |                ^^^^^^^ expected u64, found isize\n+help: you can cast an `isize` to `u64`, which will truncate or zero-extend depending on the bit width of `usize`\n+   |\n+89 |     foo::<u64>(x_isize as u64);\n+   |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:91:16\n+   |\n+91 |     foo::<u64>(x_i64);\n+   |                ^^^^^ expected u64, found i64\n+help: you can cast an `i64` to `u64`, which will sign-extend the source value\n+   |\n+91 |     foo::<u64>(x_i64 as u64);\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:93:16\n+   |\n+93 |     foo::<u64>(x_i32);\n+   |                ^^^^^ expected u64, found i32\n+help: you can cast an `i32` to `u64`, which will sign-extend the source value\n+   |\n+93 |     foo::<u64>(x_i32 as u64);\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:95:16\n+   |\n+95 |     foo::<u64>(x_i16);\n+   |                ^^^^^ expected u64, found i16\n+help: you can cast an `i16` to `u64`, which will sign-extend the source value\n+   |\n+95 |     foo::<u64>(x_i16 as u64);\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:97:16\n+   |\n+97 |     foo::<u64>(x_i8);\n+   |                ^^^^ expected u64, found i8\n+help: you can cast an `i8` to `u64`, which will sign-extend the source value\n+   |\n+97 |     foo::<u64>(x_i8 as u64);\n+   |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:99:16\n+   |\n+99 |     foo::<u64>(x_f64);\n+   |                ^^^^^ expected u64, found f64\n+   |\n+   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `u64`, rounding the float towards zero\n+   |\n+99 |     foo::<u64>(x_f64 as u64);\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:102:16\n+    |\n+102 |     foo::<u64>(x_f32);\n+    |                ^^^^^ expected u64, found f32\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `u64`, rounding the float towards zero\n+    |\n+102 |     foo::<u64>(x_f32 as u64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:106:16\n+    |\n+106 |     foo::<i64>(x_usize);\n+    |                ^^^^^^^ expected i64, found usize\n+help: you can cast an `usize` to `i64`, which will truncate or zero-extend depending on the bit width of `isize`\n+    |\n+106 |     foo::<i64>(x_usize as i64);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:108:16\n+    |\n+108 |     foo::<i64>(x_u64);\n+    |                ^^^^^ expected i64, found u64\n+help: you can cast an `u64` to `i64`, which will truncate the source value\n+    |\n+108 |     foo::<i64>(x_u64 as i64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:110:16\n+    |\n+110 |     foo::<i64>(x_u32);\n+    |                ^^^^^ expected i64, found u32\n+help: you can cast an `u32` to `i64`, which will zero-extend the source value\n+    |\n+110 |     foo::<i64>(x_u32 as i64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:112:16\n+    |\n+112 |     foo::<i64>(x_u16);\n+    |                ^^^^^ expected i64, found u16\n+help: you can cast an `u16` to `i64`, which will zero-extend the source value\n+    |\n+112 |     foo::<i64>(x_u16 as i64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:114:16\n+    |\n+114 |     foo::<i64>(x_u8);\n+    |                ^^^^ expected i64, found u8\n+help: you can cast an `u8` to `i64`, which will zero-extend the source value\n+    |\n+114 |     foo::<i64>(x_u8 as i64);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:116:16\n+    |\n+116 |     foo::<i64>(x_isize);\n+    |                ^^^^^^^ expected i64, found isize\n+help: you can cast an `isize` to `i64`, which will truncate or zero-extend depending on the bit width of `isize`\n+    |\n+116 |     foo::<i64>(x_isize as i64);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:119:16\n+    |\n+119 |     foo::<i64>(x_i32);\n+    |                ^^^^^ expected i64, found i32\n+help: you can cast an `i32` to `i64`, which will sign-extend the source value\n+    |\n+119 |     foo::<i64>(x_i32 as i64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:121:16\n+    |\n+121 |     foo::<i64>(x_i16);\n+    |                ^^^^^ expected i64, found i16\n+help: you can cast an `i16` to `i64`, which will sign-extend the source value\n+    |\n+121 |     foo::<i64>(x_i16 as i64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:123:16\n+    |\n+123 |     foo::<i64>(x_i8);\n+    |                ^^^^ expected i64, found i8\n+help: you can cast an `i8` to `i64`, which will sign-extend the source value\n+    |\n+123 |     foo::<i64>(x_i8 as i64);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:125:16\n+    |\n+125 |     foo::<i64>(x_f64);\n+    |                ^^^^^ expected i64, found f64\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `i64`, rounding the float towards zero\n+    |\n+125 |     foo::<i64>(x_f64 as i64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:128:16\n+    |\n+128 |     foo::<i64>(x_f32);\n+    |                ^^^^^ expected i64, found f32\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `i64`, rounding the float towards zero\n+    |\n+128 |     foo::<i64>(x_f32 as i64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:132:16\n+    |\n+132 |     foo::<u32>(x_usize);\n+    |                ^^^^^^^ expected u32, found usize\n+help: you can cast an `usize` to `u32`, which will truncate or zero-extend depending on the bit width of `usize`\n+    |\n+132 |     foo::<u32>(x_usize as u32);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:134:16\n+    |\n+134 |     foo::<u32>(x_u64);\n+    |                ^^^^^ expected u32, found u64\n+help: you can cast an `u64` to `u32`, which will truncate the source value\n+    |\n+134 |     foo::<u32>(x_u64 as u32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:137:16\n+    |\n+137 |     foo::<u32>(x_u16);\n+    |                ^^^^^ expected u32, found u16\n+help: you can cast an `u16` to `u32`, which will zero-extend the source value\n+    |\n+137 |     foo::<u32>(x_u16 as u32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:139:16\n+    |\n+139 |     foo::<u32>(x_u8);\n+    |                ^^^^ expected u32, found u8\n+help: you can cast an `u8` to `u32`, which will zero-extend the source value\n+    |\n+139 |     foo::<u32>(x_u8 as u32);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:141:16\n+    |\n+141 |     foo::<u32>(x_isize);\n+    |                ^^^^^^^ expected u32, found isize\n+help: you can cast an `isize` to `u32`, which will truncate or zero-extend depending on the bit width of `usize`\n+    |\n+141 |     foo::<u32>(x_isize as u32);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:143:16\n+    |\n+143 |     foo::<u32>(x_i64);\n+    |                ^^^^^ expected u32, found i64\n+help: you can cast an `i64` to `u32`, which will truncate the source value\n+    |\n+143 |     foo::<u32>(x_i64 as u32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:145:16\n+    |\n+145 |     foo::<u32>(x_i32);\n+    |                ^^^^^ expected u32, found i32\n+help: you can cast an `i32` to `u32`, which will sign-extend the source value\n+    |\n+145 |     foo::<u32>(x_i32 as u32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:147:16\n+    |\n+147 |     foo::<u32>(x_i16);\n+    |                ^^^^^ expected u32, found i16\n+help: you can cast an `i16` to `u32`, which will sign-extend the source value\n+    |\n+147 |     foo::<u32>(x_i16 as u32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:149:16\n+    |\n+149 |     foo::<u32>(x_i8);\n+    |                ^^^^ expected u32, found i8\n+help: you can cast an `i8` to `u32`, which will sign-extend the source value\n+    |\n+149 |     foo::<u32>(x_i8 as u32);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:151:16\n+    |\n+151 |     foo::<u32>(x_f64);\n+    |                ^^^^^ expected u32, found f64\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `u32`, rounding the float towards zero\n+    |\n+151 |     foo::<u32>(x_f64 as u32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:154:16\n+    |\n+154 |     foo::<u32>(x_f32);\n+    |                ^^^^^ expected u32, found f32\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `u32`, rounding the float towards zero\n+    |\n+154 |     foo::<u32>(x_f32 as u32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:158:16\n+    |\n+158 |     foo::<i32>(x_usize);\n+    |                ^^^^^^^ expected i32, found usize\n+help: you can cast an `usize` to `i32`, which will truncate or zero-extend depending on the bit width of `isize`\n+    |\n+158 |     foo::<i32>(x_usize as i32);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:160:16\n+    |\n+160 |     foo::<i32>(x_u64);\n+    |                ^^^^^ expected i32, found u64\n+help: you can cast an `u64` to `i32`, which will truncate the source value\n+    |\n+160 |     foo::<i32>(x_u64 as i32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:162:16\n+    |\n+162 |     foo::<i32>(x_u32);\n+    |                ^^^^^ expected i32, found u32\n+help: you can cast an `u32` to `i32`, which will truncate the source value\n+    |\n+162 |     foo::<i32>(x_u32 as i32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:164:16\n+    |\n+164 |     foo::<i32>(x_u16);\n+    |                ^^^^^ expected i32, found u16\n+help: you can cast an `u16` to `i32`, which will zero-extend the source value\n+    |\n+164 |     foo::<i32>(x_u16 as i32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:166:16\n+    |\n+166 |     foo::<i32>(x_u8);\n+    |                ^^^^ expected i32, found u8\n+help: you can cast an `u8` to `i32`, which will zero-extend the source value\n+    |\n+166 |     foo::<i32>(x_u8 as i32);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:168:16\n+    |\n+168 |     foo::<i32>(x_isize);\n+    |                ^^^^^^^ expected i32, found isize\n+help: you can cast an `isize` to `i32`, which will truncate or zero-extend depending on the bit width of `isize`\n+    |\n+168 |     foo::<i32>(x_isize as i32);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:170:16\n+    |\n+170 |     foo::<i32>(x_i64);\n+    |                ^^^^^ expected i32, found i64\n+help: you can cast an `i64` to `i32`, which will truncate the source value\n+    |\n+170 |     foo::<i32>(x_i64 as i32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:173:16\n+    |\n+173 |     foo::<i32>(x_i16);\n+    |                ^^^^^ expected i32, found i16\n+help: you can cast an `i16` to `i32`, which will sign-extend the source value\n+    |\n+173 |     foo::<i32>(x_i16 as i32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:175:16\n+    |\n+175 |     foo::<i32>(x_i8);\n+    |                ^^^^ expected i32, found i8\n+help: you can cast an `i8` to `i32`, which will sign-extend the source value\n+    |\n+175 |     foo::<i32>(x_i8 as i32);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:177:16\n+    |\n+177 |     foo::<i32>(x_f64);\n+    |                ^^^^^ expected i32, found f64\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `i32`, rounding the float towards zero\n+    |\n+177 |     foo::<i32>(x_f64 as i32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:180:16\n+    |\n+180 |     foo::<i32>(x_f32);\n+    |                ^^^^^ expected i32, found f32\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `i32`, rounding the float towards zero\n+    |\n+180 |     foo::<i32>(x_f32 as i32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:184:16\n+    |\n+184 |     foo::<u16>(x_usize);\n+    |                ^^^^^^^ expected u16, found usize\n+help: you can cast an `usize` to `u16`, which will truncate or zero-extend depending on the bit width of `usize`\n+    |\n+184 |     foo::<u16>(x_usize as u16);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:186:16\n+    |\n+186 |     foo::<u16>(x_u64);\n+    |                ^^^^^ expected u16, found u64\n+help: you can cast an `u64` to `u16`, which will truncate the source value\n+    |\n+186 |     foo::<u16>(x_u64 as u16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:188:16\n+    |\n+188 |     foo::<u16>(x_u32);\n+    |                ^^^^^ expected u16, found u32\n+help: you can cast an `u32` to `u16`, which will truncate the source value\n+    |\n+188 |     foo::<u16>(x_u32 as u16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:191:16\n+    |\n+191 |     foo::<u16>(x_u8);\n+    |                ^^^^ expected u16, found u8\n+help: you can cast an `u8` to `u16`, which will zero-extend the source value\n+    |\n+191 |     foo::<u16>(x_u8 as u16);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:193:16\n+    |\n+193 |     foo::<u16>(x_isize);\n+    |                ^^^^^^^ expected u16, found isize\n+help: you can cast an `isize` to `u16`, which will truncate or zero-extend depending on the bit width of `usize`\n+    |\n+193 |     foo::<u16>(x_isize as u16);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:195:16\n+    |\n+195 |     foo::<u16>(x_i64);\n+    |                ^^^^^ expected u16, found i64\n+help: you can cast an `i64` to `u16`, which will truncate the source value\n+    |\n+195 |     foo::<u16>(x_i64 as u16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:197:16\n+    |\n+197 |     foo::<u16>(x_i32);\n+    |                ^^^^^ expected u16, found i32\n+help: you can cast an `i32` to `u16`, which will truncate the source value\n+    |\n+197 |     foo::<u16>(x_i32 as u16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:199:16\n+    |\n+199 |     foo::<u16>(x_i16);\n+    |                ^^^^^ expected u16, found i16\n+help: you can cast an `i16` to `u16`, which will sign-extend the source value\n+    |\n+199 |     foo::<u16>(x_i16 as u16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:201:16\n+    |\n+201 |     foo::<u16>(x_i8);\n+    |                ^^^^ expected u16, found i8\n+help: you can cast an `i8` to `u16`, which will sign-extend the source value\n+    |\n+201 |     foo::<u16>(x_i8 as u16);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:203:16\n+    |\n+203 |     foo::<u16>(x_f64);\n+    |                ^^^^^ expected u16, found f64\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `u16`, rounding the float towards zero\n+    |\n+203 |     foo::<u16>(x_f64 as u16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:206:16\n+    |\n+206 |     foo::<u16>(x_f32);\n+    |                ^^^^^ expected u16, found f32\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `u16`, rounding the float towards zero\n+    |\n+206 |     foo::<u16>(x_f32 as u16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:210:16\n+    |\n+210 |     foo::<i16>(x_usize);\n+    |                ^^^^^^^ expected i16, found usize\n+help: you can cast an `usize` to `i16`, which will truncate or zero-extend depending on the bit width of `isize`\n+    |\n+210 |     foo::<i16>(x_usize as i16);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:212:16\n+    |\n+212 |     foo::<i16>(x_u64);\n+    |                ^^^^^ expected i16, found u64\n+help: you can cast an `u64` to `i16`, which will truncate the source value\n+    |\n+212 |     foo::<i16>(x_u64 as i16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:214:16\n+    |\n+214 |     foo::<i16>(x_u32);\n+    |                ^^^^^ expected i16, found u32\n+help: you can cast an `u32` to `i16`, which will truncate the source value\n+    |\n+214 |     foo::<i16>(x_u32 as i16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:216:16\n+    |\n+216 |     foo::<i16>(x_u16);\n+    |                ^^^^^ expected i16, found u16\n+help: you can cast an `u16` to `i16`, which will truncate the source value\n+    |\n+216 |     foo::<i16>(x_u16 as i16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:218:16\n+    |\n+218 |     foo::<i16>(x_u8);\n+    |                ^^^^ expected i16, found u8\n+help: you can cast an `u8` to `i16`, which will zero-extend the source value\n+    |\n+218 |     foo::<i16>(x_u8 as i16);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:220:16\n+    |\n+220 |     foo::<i16>(x_isize);\n+    |                ^^^^^^^ expected i16, found isize\n+help: you can cast an `isize` to `i16`, which will truncate or zero-extend depending on the bit width of `isize`\n+    |\n+220 |     foo::<i16>(x_isize as i16);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:222:16\n+    |\n+222 |     foo::<i16>(x_i64);\n+    |                ^^^^^ expected i16, found i64\n+help: you can cast an `i64` to `i16`, which will truncate the source value\n+    |\n+222 |     foo::<i16>(x_i64 as i16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:224:16\n+    |\n+224 |     foo::<i16>(x_i32);\n+    |                ^^^^^ expected i16, found i32\n+help: you can cast an `i32` to `i16`, which will truncate the source value\n+    |\n+224 |     foo::<i16>(x_i32 as i16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:227:16\n+    |\n+227 |     foo::<i16>(x_i8);\n+    |                ^^^^ expected i16, found i8\n+help: you can cast an `i8` to `i16`, which will sign-extend the source value\n+    |\n+227 |     foo::<i16>(x_i8 as i16);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:229:16\n+    |\n+229 |     foo::<i16>(x_f64);\n+    |                ^^^^^ expected i16, found f64\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `i16`, rounding the float towards zero\n+    |\n+229 |     foo::<i16>(x_f64 as i16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:232:16\n+    |\n+232 |     foo::<i16>(x_f32);\n+    |                ^^^^^ expected i16, found f32\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `i16`, rounding the float towards zero\n+    |\n+232 |     foo::<i16>(x_f32 as i16);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:236:15\n+    |\n+236 |     foo::<u8>(x_usize);\n+    |               ^^^^^^^ expected u8, found usize\n+help: you can cast an `usize` to `u8`, which will truncate or zero-extend depending on the bit width of `usize`\n+    |\n+236 |     foo::<u8>(x_usize as u8);\n+    |               ^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:238:15\n+    |\n+238 |     foo::<u8>(x_u64);\n+    |               ^^^^^ expected u8, found u64\n+help: you can cast an `u64` to `u8`, which will truncate the source value\n+    |\n+238 |     foo::<u8>(x_u64 as u8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:240:15\n+    |\n+240 |     foo::<u8>(x_u32);\n+    |               ^^^^^ expected u8, found u32\n+help: you can cast an `u32` to `u8`, which will truncate the source value\n+    |\n+240 |     foo::<u8>(x_u32 as u8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:242:15\n+    |\n+242 |     foo::<u8>(x_u16);\n+    |               ^^^^^ expected u8, found u16\n+help: you can cast an `u16` to `u8`, which will truncate the source value\n+    |\n+242 |     foo::<u8>(x_u16 as u8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:245:15\n+    |\n+245 |     foo::<u8>(x_isize);\n+    |               ^^^^^^^ expected u8, found isize\n+help: you can cast an `isize` to `u8`, which will truncate or zero-extend depending on the bit width of `usize`\n+    |\n+245 |     foo::<u8>(x_isize as u8);\n+    |               ^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:247:15\n+    |\n+247 |     foo::<u8>(x_i64);\n+    |               ^^^^^ expected u8, found i64\n+help: you can cast an `i64` to `u8`, which will truncate the source value\n+    |\n+247 |     foo::<u8>(x_i64 as u8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:249:15\n+    |\n+249 |     foo::<u8>(x_i32);\n+    |               ^^^^^ expected u8, found i32\n+help: you can cast an `i32` to `u8`, which will truncate the source value\n+    |\n+249 |     foo::<u8>(x_i32 as u8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:251:15\n+    |\n+251 |     foo::<u8>(x_i16);\n+    |               ^^^^^ expected u8, found i16\n+help: you can cast an `i16` to `u8`, which will truncate the source value\n+    |\n+251 |     foo::<u8>(x_i16 as u8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:253:15\n+    |\n+253 |     foo::<u8>(x_i8);\n+    |               ^^^^ expected u8, found i8\n+help: you can cast an `i8` to `u8`, which will sign-extend the source value\n+    |\n+253 |     foo::<u8>(x_i8 as u8);\n+    |               ^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:255:15\n+    |\n+255 |     foo::<u8>(x_f64);\n+    |               ^^^^^ expected u8, found f64\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `u8`, rounding the float towards zero\n+    |\n+255 |     foo::<u8>(x_f64 as u8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:258:15\n+    |\n+258 |     foo::<u8>(x_f32);\n+    |               ^^^^^ expected u8, found f32\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `u8`, rounding the float towards zero\n+    |\n+258 |     foo::<u8>(x_f32 as u8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:262:15\n+    |\n+262 |     foo::<i8>(x_usize);\n+    |               ^^^^^^^ expected i8, found usize\n+help: you can cast an `usize` to `i8`, which will truncate or zero-extend depending on the bit width of `isize`\n+    |\n+262 |     foo::<i8>(x_usize as i8);\n+    |               ^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:264:15\n+    |\n+264 |     foo::<i8>(x_u64);\n+    |               ^^^^^ expected i8, found u64\n+help: you can cast an `u64` to `i8`, which will truncate the source value\n+    |\n+264 |     foo::<i8>(x_u64 as i8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:266:15\n+    |\n+266 |     foo::<i8>(x_u32);\n+    |               ^^^^^ expected i8, found u32\n+help: you can cast an `u32` to `i8`, which will truncate the source value\n+    |\n+266 |     foo::<i8>(x_u32 as i8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:268:15\n+    |\n+268 |     foo::<i8>(x_u16);\n+    |               ^^^^^ expected i8, found u16\n+help: you can cast an `u16` to `i8`, which will truncate the source value\n+    |\n+268 |     foo::<i8>(x_u16 as i8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:270:15\n+    |\n+270 |     foo::<i8>(x_u8);\n+    |               ^^^^ expected i8, found u8\n+help: you can cast an `u8` to `i8`, which will truncate the source value\n+    |\n+270 |     foo::<i8>(x_u8 as i8);\n+    |               ^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:272:15\n+    |\n+272 |     foo::<i8>(x_isize);\n+    |               ^^^^^^^ expected i8, found isize\n+help: you can cast an `isize` to `i8`, which will truncate or zero-extend depending on the bit width of `isize`\n+    |\n+272 |     foo::<i8>(x_isize as i8);\n+    |               ^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:274:15\n+    |\n+274 |     foo::<i8>(x_i64);\n+    |               ^^^^^ expected i8, found i64\n+help: you can cast an `i64` to `i8`, which will truncate the source value\n+    |\n+274 |     foo::<i8>(x_i64 as i8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:276:15\n+    |\n+276 |     foo::<i8>(x_i32);\n+    |               ^^^^^ expected i8, found i32\n+help: you can cast an `i32` to `i8`, which will truncate the source value\n+    |\n+276 |     foo::<i8>(x_i32 as i8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:278:15\n+    |\n+278 |     foo::<i8>(x_i16);\n+    |               ^^^^^ expected i8, found i16\n+help: you can cast an `i16` to `i8`, which will truncate the source value\n+    |\n+278 |     foo::<i8>(x_i16 as i8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:281:15\n+    |\n+281 |     foo::<i8>(x_f64);\n+    |               ^^^^^ expected i8, found f64\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `i8`, rounding the float towards zero\n+    |\n+281 |     foo::<i8>(x_f64 as i8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:284:15\n+    |\n+284 |     foo::<i8>(x_f32);\n+    |               ^^^^^ expected i8, found f32\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+help: you can cast an `f32` to `i8`, rounding the float towards zero\n+    |\n+284 |     foo::<i8>(x_f32 as i8);\n+    |               ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:288:16\n+    |\n+288 |     foo::<f64>(x_usize);\n+    |                ^^^^^^^ expected f64, found usize\n+help: you can cast an `usize` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+288 |     foo::<f64>(x_usize as f64);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:290:16\n+    |\n+290 |     foo::<f64>(x_u64);\n+    |                ^^^^^ expected f64, found u64\n+help: you can cast an `u64` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+290 |     foo::<f64>(x_u64 as f64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:292:16\n+    |\n+292 |     foo::<f64>(x_u32);\n+    |                ^^^^^ expected f64, found u32\n+help: you can cast an `u32` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+292 |     foo::<f64>(x_u32 as f64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:294:16\n+    |\n+294 |     foo::<f64>(x_u16);\n+    |                ^^^^^ expected f64, found u16\n+help: you can cast an `u16` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+294 |     foo::<f64>(x_u16 as f64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:296:16\n+    |\n+296 |     foo::<f64>(x_u8);\n+    |                ^^^^ expected f64, found u8\n+help: you can cast an `u8` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+296 |     foo::<f64>(x_u8 as f64);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:298:16\n+    |\n+298 |     foo::<f64>(x_isize);\n+    |                ^^^^^^^ expected f64, found isize\n+help: you can cast an `isize` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+298 |     foo::<f64>(x_isize as f64);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:300:16\n+    |\n+300 |     foo::<f64>(x_i64);\n+    |                ^^^^^ expected f64, found i64\n+help: you can cast an `i64` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+300 |     foo::<f64>(x_i64 as f64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:302:16\n+    |\n+302 |     foo::<f64>(x_i32);\n+    |                ^^^^^ expected f64, found i32\n+help: you can cast an `i32` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+302 |     foo::<f64>(x_i32 as f64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:304:16\n+    |\n+304 |     foo::<f64>(x_i16);\n+    |                ^^^^^ expected f64, found i16\n+help: you can cast an `i16` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+304 |     foo::<f64>(x_i16 as f64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:306:16\n+    |\n+306 |     foo::<f64>(x_i8);\n+    |                ^^^^ expected f64, found i8\n+help: you can cast an `i8` to `f64`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+306 |     foo::<f64>(x_i8 as f64);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:309:16\n+    |\n+309 |     foo::<f64>(x_f32);\n+    |                ^^^^^ expected f64, found f32\n+help: you can cast an `f32` to `f64` in a lossless way\n+    |\n+309 |     foo::<f64>(x_f32 as f64);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:312:16\n+    |\n+312 |     foo::<f32>(x_usize);\n+    |                ^^^^^^^ expected f32, found usize\n+help: you can cast an `usize` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+312 |     foo::<f32>(x_usize as f32);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:314:16\n+    |\n+314 |     foo::<f32>(x_u64);\n+    |                ^^^^^ expected f32, found u64\n+help: you can cast an `u64` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+314 |     foo::<f32>(x_u64 as f32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:316:16\n+    |\n+316 |     foo::<f32>(x_u32);\n+    |                ^^^^^ expected f32, found u32\n+help: you can cast an `u32` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+316 |     foo::<f32>(x_u32 as f32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:318:16\n+    |\n+318 |     foo::<f32>(x_u16);\n+    |                ^^^^^ expected f32, found u16\n+help: you can cast an `u16` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+318 |     foo::<f32>(x_u16 as f32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:320:16\n+    |\n+320 |     foo::<f32>(x_u8);\n+    |                ^^^^ expected f32, found u8\n+help: you can cast an `u8` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+320 |     foo::<f32>(x_u8 as f32);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:322:16\n+    |\n+322 |     foo::<f32>(x_isize);\n+    |                ^^^^^^^ expected f32, found isize\n+help: you can cast an `isize` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+322 |     foo::<f32>(x_isize as f32);\n+    |                ^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:324:16\n+    |\n+324 |     foo::<f32>(x_i64);\n+    |                ^^^^^ expected f32, found i64\n+help: you can cast an `i64` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+324 |     foo::<f32>(x_i64 as f32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:326:16\n+    |\n+326 |     foo::<f32>(x_i32);\n+    |                ^^^^^ expected f32, found i32\n+help: you can cast an `i32` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+326 |     foo::<f32>(x_i32 as f32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:328:16\n+    |\n+328 |     foo::<f32>(x_i16);\n+    |                ^^^^^ expected f32, found i16\n+help: you can cast an `i16` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+328 |     foo::<f32>(x_i16 as f32);\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:330:16\n+    |\n+330 |     foo::<f32>(x_i8);\n+    |                ^^^^ expected f32, found i8\n+help: you can cast an `i8` to `f32`, producing the floating point representation of the integer, rounded if necessary\n+    |\n+330 |     foo::<f32>(x_i8 as f32);\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:332:16\n+    |\n+332 |     foo::<f32>(x_f64);\n+    |                ^^^^^ expected f32, found f64\n+    |\n+    = warning: Currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by `f32`. This is a bug and will be fixed.\n+help: you can cast an `f64` to `f32`, producing the closest possible value\n+    |\n+332 |     foo::<f32>(x_f64 as f32);\n+    |                ^^^^^^^^^^^^\n+\n+error: aborting due to 132 previous errors\n+"}]}