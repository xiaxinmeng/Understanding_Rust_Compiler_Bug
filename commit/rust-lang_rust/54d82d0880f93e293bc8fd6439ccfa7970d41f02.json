{"sha": "54d82d0880f93e293bc8fd6439ccfa7970d41f02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZDgyZDA4ODBmOTNlMjkzYmM4ZmQ2NDM5Y2NmYTc5NzBkNDFmMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-23T17:13:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-23T17:13:44Z"}, "message": "Auto merge of #53571 - MaloJaffre:vecdeque-emergency, r=RalfJung\n\nFix unsoundness for VecDeque\n\n See individual commit for more details.\n\nr? @RalfJung.\n\nFixes https://github.com/rust-lang/rust/issues/53566, fixes https://github.com/rust-lang/rust/issues/53529", "tree": {"sha": "126fd86573b48b32068c677ccccf13ff4f4f709d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/126fd86573b48b32068c677ccccf13ff4f4f709d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54d82d0880f93e293bc8fd6439ccfa7970d41f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54d82d0880f93e293bc8fd6439ccfa7970d41f02", "html_url": "https://github.com/rust-lang/rust/commit/54d82d0880f93e293bc8fd6439ccfa7970d41f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54d82d0880f93e293bc8fd6439ccfa7970d41f02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5284b0b57275cb18618ef1532ee7f07c32a1e18", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5284b0b57275cb18618ef1532ee7f07c32a1e18", "html_url": "https://github.com/rust-lang/rust/commit/e5284b0b57275cb18618ef1532ee7f07c32a1e18"}, {"sha": "f8d5ed47e50fa964878263572f583d8a96ddc910", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d5ed47e50fa964878263572f583d8a96ddc910", "html_url": "https://github.com/rust-lang/rust/commit/f8d5ed47e50fa964878263572f583d8a96ddc910"}], "stats": {"total": 194, "additions": 27, "deletions": 167}, "files": [{"sha": "571f35a2031d2a0b9e1eb57ac1f9728ca2fb245f", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 27, "deletions": 167, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/54d82d0880f93e293bc8fd6439ccfa7970d41f02/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d82d0880f93e293bc8fd6439ccfa7970d41f02/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=54d82d0880f93e293bc8fd6439ccfa7970d41f02", "patch": "@@ -202,23 +202,6 @@ impl<T> VecDeque<T> {\n                                  len);\n     }\n \n-    /// Returns a pair of slices which contain the contents of the buffer not used by the VecDeque.\n-    #[inline]\n-    unsafe fn unused_as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n-        let head = self.head;\n-        let tail = self.tail;\n-        let buf = self.buffer_as_mut_slice();\n-        if head != tail {\n-            // In buf, head..tail contains the VecDeque and tail..head is unused.\n-            // So calling `ring_slices` with tail and head swapped returns unused slices.\n-            RingSlices::ring_slices(buf, tail, head)\n-        } else {\n-            // Swapping doesn't help when head == tail.\n-            let (before, after) = buf.split_at_mut(head);\n-            (after, before)\n-        }\n-    }\n-\n     /// Copies a potentially wrapping block of memory len long from src to dest.\n     /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n     /// most one continuous overlapping region between src and dest).\n@@ -1851,148 +1834,8 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        // Copies all values from `src_slice` to the start of `dst_slice`.\n-        unsafe fn copy_whole_slice<T>(src_slice: &[T], dst_slice: &mut [T]) {\n-            let len = src_slice.len();\n-            ptr::copy_nonoverlapping(src_slice.as_ptr(), dst_slice[..len].as_mut_ptr(), len);\n-        }\n-\n-        let src_total = other.len();\n-\n-        // Guarantees there is space in `self` for `other`.\n-        self.reserve(src_total);\n-\n-        self.head = {\n-            let original_head = self.head;\n-\n-            // The goal is to copy all values from `other` into `self`. To avoid any\n-            // mismatch, all valid values in `other` are retrieved...\n-            let (src_high, src_low) = other.as_slices();\n-            // and unoccupied parts of self are retrieved.\n-            let (dst_high, dst_low) = unsafe { self.unused_as_mut_slices() };\n-\n-            // Then all that is needed is to copy all values from\n-            // src (src_high and src_low) to dst (dst_high and dst_low).\n-            //\n-            // other [o o o . . . . . o o o o]\n-            //       [5 6 7]         [1 2 3 4]\n-            //       src_low         src_high\n-            //\n-            // self  [. . . . . . o o o o . .]\n-            //       [3 4 5 6 7 .]       [1 2]\n-            //       dst_low             dst_high\n-            //\n-            // Values are not copied one by one but as slices in `copy_whole_slice`.\n-            // What slices are used depends on various properties of src and dst.\n-            // There are 6 cases in total:\n-            //     1. `src` is contiguous and fits in dst_high\n-            //     2. `src` is contiguous and does not fit in dst_high\n-            //     3. `src` is discontiguous and fits in dst_high\n-            //     4. `src` is discontiguous and does not fit in dst_high\n-            //        + src_high is smaller than dst_high\n-            //     5. `src` is discontiguous and does not fit in dst_high\n-            //        + dst_high is smaller than src_high\n-            //     6. `src` is discontiguous and does not fit in dst_high\n-            //        + dst_high is the same size as src_high\n-            let src_contiguous = src_low.is_empty();\n-            let dst_high_fits_src = dst_high.len() >= src_total;\n-            match (src_contiguous, dst_high_fits_src) {\n-                (true, true) => {\n-                    // 1.\n-                    // other [. . . o o o . . . . . .]\n-                    //       []    [1 1 1]\n-                    //\n-                    // self  [. o o o o o . . . . . .]\n-                    //       [.]         [1 1 1 . . .]\n-\n-                    unsafe {\n-                        copy_whole_slice(src_high, dst_high);\n-                    }\n-                    original_head + src_total\n-                }\n-                (true, false) => {\n-                    // 2.\n-                    // other [. . . o o o o o . . . .]\n-                    //       []    [1 1 2 2 2]\n-                    //\n-                    // self  [. . . . . . . o o o . .]\n-                    //       [2 2 2 . . . .]     [1 1]\n-\n-                    let (src_1, src_2) = src_high.split_at(dst_high.len());\n-                    unsafe {\n-                        copy_whole_slice(src_1, dst_high);\n-                        copy_whole_slice(src_2, dst_low);\n-                    }\n-                    src_total - dst_high.len()\n-                }\n-                (false, true) => {\n-                    // 3.\n-                    // other [o o . . . . . . . o o o]\n-                    //       [2 2]             [1 1 1]\n-                    //\n-                    // self  [. o o . . . . . . . . .]\n-                    //       [.]   [1 1 1 2 2 . . . .]\n-\n-                    let (dst_1, dst_2) = dst_high.split_at_mut(src_high.len());\n-                    unsafe {\n-                        copy_whole_slice(src_high, dst_1);\n-                        copy_whole_slice(src_low, dst_2);\n-                    }\n-                    original_head + src_total\n-                }\n-                (false, false) => {\n-                    if src_high.len() < dst_high.len() {\n-                        // 4.\n-                        // other [o o o . . . . . . o o o]\n-                        //       [2 3 3]           [1 1 1]\n-                        //\n-                        // self  [. . . . . . o o . . . .]\n-                        //       [3 3 . . . .]   [1 1 1 2]\n-\n-                        let (dst_1, dst_2) = dst_high.split_at_mut(src_high.len());\n-                        let (src_2, src_3) = src_low.split_at(dst_2.len());\n-                        unsafe {\n-                            copy_whole_slice(src_high, dst_1);\n-                            copy_whole_slice(src_2, dst_2);\n-                            copy_whole_slice(src_3, dst_low);\n-                        }\n-                        src_3.len()\n-                    } else if src_high.len() > dst_high.len() {\n-                        // 5.\n-                        // other [o o o . . . . . o o o o]\n-                        //       [3 3 3]         [1 1 2 2]\n-                        //\n-                        // self  [. . . . . . o o o o . .]\n-                        //       [2 2 3 3 3 .]       [1 1]\n-\n-                        let (src_1, src_2) = src_high.split_at(dst_high.len());\n-                        let (dst_2, dst_3) = dst_low.split_at_mut(src_2.len());\n-                        unsafe {\n-                            copy_whole_slice(src_1, dst_high);\n-                            copy_whole_slice(src_2, dst_2);\n-                            copy_whole_slice(src_low, dst_3);\n-                        }\n-                        dst_2.len() + src_low.len()\n-                    } else {\n-                        // 6.\n-                        // other [o o . . . . . . . o o o]\n-                        //       [2 2]             [1 1 1]\n-                        //\n-                        // self  [. . . . . . . o o . . .]\n-                        //       [2 2 . . . . .]   [1 1 1]\n-\n-                        unsafe {\n-                            copy_whole_slice(src_high, dst_high);\n-                            copy_whole_slice(src_low, dst_low);\n-                        }\n-                        src_low.len()\n-                    }\n-                }\n-            }\n-        };\n-\n-        // Some values now exist in both `other` and `self` but are made inaccessible in `other`.\n-        other.tail = other.head;\n+        // naive impl\n+        self.extend(other.drain(..));\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -2145,11 +1988,11 @@ pub struct Iter<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         f.debug_tuple(\"Iter\")\n-         .field(&self.ring)\n-         .field(&self.tail)\n-         .field(&self.head)\n-         .finish()\n+            .field(&front)\n+            .field(&back)\n+            .finish()\n     }\n }\n \n@@ -2242,11 +2085,11 @@ pub struct IterMut<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let (front, back) = RingSlices::ring_slices(&*self.ring, self.head, self.tail);\n         f.debug_tuple(\"IterMut\")\n-         .field(&self.ring)\n-         .field(&self.tail)\n-         .field(&self.head)\n-         .finish()\n+            .field(&front)\n+            .field(&back)\n+            .finish()\n     }\n }\n \n@@ -3124,4 +2967,21 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn issue_53529() {\n+        use boxed::Box;\n+\n+        let mut dst = VecDeque::new();\n+        dst.push_front(Box::new(1));\n+        dst.push_front(Box::new(2));\n+        assert_eq!(*dst.pop_back().unwrap(), 1);\n+\n+        let mut src = VecDeque::new();\n+        src.push_front(Box::new(2));\n+        dst.append(&mut src);\n+        for a in dst {\n+            assert_eq!(*a, 2);\n+        }\n+    }\n+\n }"}]}