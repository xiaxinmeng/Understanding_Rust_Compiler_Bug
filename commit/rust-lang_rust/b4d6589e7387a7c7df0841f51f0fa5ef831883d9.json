{"sha": "b4d6589e7387a7c7df0841f51f0fa5ef831883d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZDY1ODllNzM4N2E3YzdkZjA4NDFmNTFmMGZhNWVmODMxODgzZDk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-23T18:58:43Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-24T01:08:02Z"}, "message": "Implement type descriptor binding. Un-XFAIL test/run-pass/generic-bind.rs.", "tree": {"sha": "c0078dc90c1bfe0174c26ad0c989b2567bbf16b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0078dc90c1bfe0174c26ad0c989b2567bbf16b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4d6589e7387a7c7df0841f51f0fa5ef831883d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d6589e7387a7c7df0841f51f0fa5ef831883d9", "html_url": "https://github.com/rust-lang/rust/commit/b4d6589e7387a7c7df0841f51f0fa5ef831883d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4d6589e7387a7c7df0841f51f0fa5ef831883d9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "381684043f1ad044c72347d759c1c545c6bccc3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/381684043f1ad044c72347d759c1c545c6bccc3d", "html_url": "https://github.com/rust-lang/rust/commit/381684043f1ad044c72347d759c1c545c6bccc3d"}], "stats": {"total": 119, "additions": 100, "deletions": 19}, "files": [{"sha": "edbe9e29ab70aac8e534a896f8b387fd2e8e5747", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4d6589e7387a7c7df0841f51f0fa5ef831883d9/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b4d6589e7387a7c7df0841f51f0fa5ef831883d9/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=b4d6589e7387a7c7df0841f51f0fa5ef831883d9", "patch": "@@ -480,6 +480,7 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         foreach-simple.rs \\\n                         fun-call-variants.rs \\\n                         fun-indirect-call.rs \\\n+                        generic-bind.rs \\\n                         generic-derived-type.rs \\\n                         generic-fn.rs \\\n                         generic-fn-infer.rs \\"}, {"sha": "30f3cdc44951af88e7d45cda827aeb0e8fe59d9b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b4d6589e7387a7c7df0841f51f0fa5ef831883d9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d6589e7387a7c7df0841f51f0fa5ef831883d9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b4d6589e7387a7c7df0841f51f0fa5ef831883d9", "patch": "@@ -373,11 +373,12 @@ fn T_typaram_ptr(type_names tn) -> TypeRef {\n \n fn T_closure_ptr(type_names tn,\n                  TypeRef lltarget_ty,\n-                 TypeRef llbindings_ty) -> TypeRef {\n+                 TypeRef llbindings_ty,\n+                 uint n_ty_params) -> TypeRef {\n     ret T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc(tn)),\n                                  lltarget_ty,\n-                                 llbindings_ty)\n-                             // FIXME: add captured typarams.\n+                                 llbindings_ty,\n+                                 T_captured_tydescs(tn, n_ty_params))\n                              )));\n }\n \n@@ -388,7 +389,8 @@ fn T_opaque_closure_ptr(type_names tn) -> TypeRef {\n     }\n     auto t = T_closure_ptr(tn, T_struct(vec(T_ptr(T_nil()),\n                                             T_ptr(T_nil()))),\n-                           T_nil());\n+                           T_nil(),\n+                           0u);\n     tn.associate(s, t);\n     ret t;\n }\n@@ -2747,17 +2749,15 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                     @ty.t outgoing_fty,\n                     vec[option.t[@ast.expr]] args,\n                     TypeRef llclosure_ty,\n-                    vec[@ty.t] bound_tys) -> ValueRef {\n+                    vec[@ty.t] bound_tys,\n+                    uint ty_param_count) -> ValueRef {\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty.\n \n     let str s = cx.names.next(\"_rust_thunk\") + sep() + cx.path;\n     let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx, incoming_fty));\n     let ValueRef llthunk = decl_fastcall_fn(cx.llmod, s, llthunk_ty);\n \n-    // FIXME: handle ty params properly.\n-    let vec[ast.ty_param] ty_params = vec();\n-\n     auto fcx = new_fn_ctxt(cx, s, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n \n@@ -2779,11 +2779,33 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                                          vec(C_int(0),\n                                              C_int(abi.fn_field_box)));\n     lltargetclosure = bcx.build.Load(lltargetclosure);\n-    let vec[ValueRef] llargs = vec(fcx.llretptr,\n+\n+    auto outgoing_ret_ty = ty.ty_fn_ret(outgoing_fty);\n+    auto outgoing_arg_tys = ty.ty_fn_args(outgoing_fty);\n+\n+    auto llretptr = fcx.llretptr;\n+    if (ty.type_has_dynamic_size(outgoing_ret_ty)) {\n+        llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.tn));\n+    }\n+\n+    let vec[ValueRef] llargs = vec(llretptr,\n                                    fcx.lltaskptr,\n                                    lltargetclosure);\n-    let uint a = 0u;\n+\n+    // Copy in the type parameters.\n+    let uint i = 0u;\n+    while (i < ty_param_count) {\n+        auto lltyparam_ptr =\n+            bcx.build.GEP(llbody, vec(C_int(0),\n+                                      C_int(abi.closure_elt_ty_params),\n+                                      C_int(i as int)));\n+        llargs += vec(bcx.build.Load(lltyparam_ptr));\n+        i += 1u;\n+    }\n+\n+    let uint a = 2u + i;    // retptr, task ptr, env come first\n     let int b = 0;\n+    let uint outgoing_arg_index = 0u;\n     for (option.t[@ast.expr] arg in args) {\n         alt (arg) {\n \n@@ -2800,17 +2822,27 @@ fn trans_bind_thunk(@crate_ctxt cx,\n             // Arg will be provided when the thunk is invoked.\n             case (none[@ast.expr]) {\n                 let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n+                if (ty.type_has_dynamic_size(outgoing_arg_tys.\n+                        (outgoing_arg_index).ty)) {\n+                    // Cast to a generic typaram pointer in order to make a\n+                    // type-compatible call.\n+                    passed_arg = bcx.build.PointerCast(passed_arg,\n+                                                       T_typaram_ptr(cx.tn));\n+                }\n                 llargs += passed_arg;\n                 a += 1u;\n             }\n         }\n+\n+        outgoing_arg_index += 0u;\n     }\n \n     // FIXME: turn this call + ret into a tail call.\n     auto lltargetfn = bcx.build.GEP(lltarget,\n                                     vec(C_int(0),\n                                         C_int(abi.fn_field_code)));\n     lltargetfn = bcx.build.Load(lltargetfn);\n+\n     auto r = bcx.build.FastCall(lltargetfn, llargs);\n     bcx.build.RetVoid();\n \n@@ -2835,7 +2867,23 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 }\n             }\n         }\n-        if (_vec.len[@ast.expr](bound) == 0u) {\n+\n+        // Figure out which tydescs we need to pass, if any.\n+        // FIXME: typestate botch\n+        let @ty.t outgoing_fty = ty.plain_ty(ty.ty_nil);\n+        let vec[ValueRef] lltydescs = vec();\n+        alt (f_res.generic) {\n+            case (none[generic_info]) {\n+                outgoing_fty = ty.expr_ty(f);\n+            }\n+            case (some[generic_info](?ginfo)) {\n+                outgoing_fty = ginfo.item_type;\n+                lltydescs = ginfo.tydescs;\n+            }\n+        }\n+        auto ty_param_count = _vec.len[ValueRef](lltydescs);\n+\n+        if (_vec.len[@ast.expr](bound) == 0u && ty_param_count == 0u) {\n             // Trivial 'binding': just return the static pair-ptr.\n             ret f_res.res;\n         } else {\n@@ -2846,20 +2894,27 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             // Translate the bound expressions.\n             let vec[@ty.t] bound_tys = vec();\n             let vec[ValueRef] bound_vals = vec();\n+            auto i = 0u;\n             for (@ast.expr e in bound) {\n                 auto arg = trans_expr(bcx, e);\n                 bcx = arg.bcx;\n+\n                 append[ValueRef](bound_vals, arg.val);\n                 append[@ty.t](bound_tys, ty.expr_ty(e));\n+\n+                i += 1u;\n             }\n \n+            // Get the type of the bound function.\n+            let TypeRef lltarget_ty = type_of(bcx.fcx.ccx, outgoing_fty);\n+\n             // Synthesize a closure type.\n             let @ty.t bindings_ty = plain_ty(ty.ty_tup(bound_tys));\n-            let TypeRef lltarget_ty = type_of(bcx.fcx.ccx, ty.expr_ty(f));\n             let TypeRef llbindings_ty = type_of(bcx.fcx.ccx, bindings_ty);\n             let TypeRef llclosure_ty = T_closure_ptr(cx.fcx.ccx.tn,\n                                                      lltarget_ty,\n-                                                     llbindings_ty);\n+                                                     llbindings_ty,\n+                                                     ty_param_count);\n \n             // Malloc a box for the body.\n             auto r = trans_malloc_inner(bcx, llclosure_ty);\n@@ -2888,19 +2943,40 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 bcx.build.GEP(closure,\n                               vec(C_int(0),\n                                   C_int(abi.closure_elt_target)));\n-            bcx.build.Store(bcx.build.Load(f_res.res.val), bound_target);\n+            auto src = bcx.build.Load(f_res.res.val);\n+            bcx.build.Store(src, bound_target);\n \n             // Copy expr values into boxed bindings.\n-            let int i = 0;\n+            i = 0u;\n             auto bindings =\n                 bcx.build.GEP(closure,\n                               vec(C_int(0),\n                                   C_int(abi.closure_elt_bindings)));\n             for (ValueRef v in bound_vals) {\n                 auto bound = bcx.build.GEP(bindings,\n-                                           vec(C_int(0),C_int(i)));\n+                                           vec(C_int(0), C_int(i as int)));\n                 bcx = copy_ty(r.bcx, INIT, bound, v, bound_tys.(i)).bcx;\n-                i += 1;\n+                i += 1u;\n+            }\n+\n+            // If necessary, copy tydescs describing type parameters into the\n+            // appropriate slot in the closure.\n+            alt (f_res.generic) {\n+                case (none[generic_info]) { /* nothing to do */ }\n+                case (some[generic_info](?ginfo)) {\n+                    auto ty_params_slot =\n+                        bcx.build.GEP(closure,\n+                                      vec(C_int(0),\n+                                          C_int(abi.closure_elt_ty_params)));\n+                    auto i = 0;\n+                    for (ValueRef td in ginfo.tydescs) {\n+                        auto ty_param_slot = bcx.build.GEP(ty_params_slot,\n+                                                           vec(C_int(0),\n+                                                               C_int(i)));\n+                        bcx.build.Store(td, ty_param_slot);\n+                        i += 1;\n+                    }\n+                }\n             }\n \n             // Make thunk and store thunk-ptr in outer pair's code slot.\n@@ -2910,8 +2986,9 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n \n             let @ty.t pair_ty = node_ann_type(cx.fcx.ccx, ann);\n             let ValueRef llthunk =\n-                trans_bind_thunk(cx.fcx.ccx, pair_ty, ty.expr_ty(f),\n-                                 args, llclosure_ty, bound_tys);\n+                trans_bind_thunk(cx.fcx.ccx, pair_ty, outgoing_fty,\n+                                 args, llclosure_ty, bound_tys,\n+                                 ty_param_count);\n \n             bcx.build.Store(llthunk, pair_code);\n "}, {"sha": "5535879e6e1755916b2fd32d4b75b9bb60813e01", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4d6589e7387a7c7df0841f51f0fa5ef831883d9/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d6589e7387a7c7df0841f51f0fa5ef831883d9/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b4d6589e7387a7c7df0841f51f0fa5ef831883d9", "patch": "@@ -598,19 +598,22 @@ fn ty_fn_args(@t fty) -> vec[arg] {\n         case (ty.ty_fn(_, ?a, _)) { ret a; }\n         case (ty.ty_native_fn(?a, _)) { ret a; }\n     }\n+    fail;\n }\n \n fn ty_fn_proto(@t fty) -> ast.proto {\n     alt (fty.struct) {\n         case (ty.ty_fn(?p, _, _)) { ret p; }\n     }\n+    fail;\n }\n \n fn ty_fn_ret(@t fty) -> @t {\n     alt (fty.struct) {\n         case (ty.ty_fn(_, _, ?r)) { ret r; }\n         case (ty.ty_native_fn(_, ?r)) { ret r; }\n     }\n+    fail;\n }\n \n fn is_fn_ty(@t fty) -> bool {"}]}