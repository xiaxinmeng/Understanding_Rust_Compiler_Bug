{"sha": "1d3231362cbee20a1df032fd871f8afd8980a98e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkMzIzMTM2MmNiZWUyMGExZGYwMzJmZDg3MWY4YWZkODk4MGE5OGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-18T01:59:54Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T18:56:53Z"}, "message": "test: Add k-nucleotide", "tree": {"sha": "7b7af36728d294de64b6b5023baba286e2018b3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b7af36728d294de64b6b5023baba286e2018b3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d3231362cbee20a1df032fd871f8afd8980a98e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d3231362cbee20a1df032fd871f8afd8980a98e", "html_url": "https://github.com/rust-lang/rust/commit/1d3231362cbee20a1df032fd871f8afd8980a98e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d3231362cbee20a1df032fd871f8afd8980a98e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "html_url": "https://github.com/rust-lang/rust/commit/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6"}], "stats": {"total": 314, "additions": 314, "deletions": 0}, "files": [{"sha": "1330e8c892f34332161257558c7e326ca919ef03", "filename": "src/test/run-pass/shootout-k-nucleotide.rs", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/1d3231362cbee20a1df032fd871f8afd8980a98e/src%2Ftest%2Frun-pass%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3231362cbee20a1df032fd871f8afd8980a98e/src%2Ftest%2Frun-pass%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshootout-k-nucleotide.rs?ref=1d3231362cbee20a1df032fd871f8afd8980a98e", "patch": "@@ -0,0 +1,314 @@\n+extern mod std;\n+\n+use core::cast::transmute;\n+use core::i32::range;\n+use core::libc::{STDIN_FILENO, c_int, fdopen, fgets, fileno, fopen, fstat};\n+use core::libc::{stat, strlen};\n+use core::ptr::null;\n+use core::unstable::intrinsics::init;\n+use core::vec::{reverse, slice};\n+use std::sort::quick_sort3;\n+\n+static LINE_LEN: uint = 80;\n+static TABLE: [u8, ..4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n+static TABLE_SIZE: uint = 2 << 16;\n+\n+static OCCURRENCES: [&'static str, ..5] = [\n+    \"GGT\",\n+    \"GGTA\",\n+    \"GGTATT\",\n+    \"GGTATTTTAATT\",\n+    \"GGTATTTTAATTTATAGT\",\n+];\n+\n+// Code implementation\n+\n+#[deriving(Eq, Ord)]\n+struct Code(u64);\n+\n+impl Code {\n+    fn hash(&self) -> u64 {\n+        **self\n+    }\n+\n+    #[inline(always)]\n+    fn push_char(&self, c: u8) -> Code {\n+        Code((**self << 2) + (pack_symbol(c) as u64))\n+    }\n+\n+    fn rotate(&self, c: u8, frame: i32) -> Code {\n+        Code(*self.push_char(c) & ((1u64 << (2 * (frame as u64))) - 1))\n+    }\n+\n+    fn pack(string: &str) -> Code {\n+        let mut code = Code(0u64);\n+        for uint::range(0, string.len()) |i| {\n+            code = code.push_char(string[i]);\n+        }\n+        code\n+    }\n+\n+    // XXX: Inefficient.\n+    fn unpack(&self, frame: i32) -> ~str {\n+        let mut key = **self;\n+        let mut result = ~[];\n+        for (frame as uint).times {\n+            result.push(unpack_symbol((key as u8) & 3));\n+            key >>= 2;\n+        }\n+\n+        reverse(result);\n+        str::from_bytes(result)\n+    }\n+}\n+\n+// Hash table implementation\n+\n+trait TableCallback {\n+    fn f(&self, entry: &mut Entry);\n+}\n+\n+struct BumpCallback;\n+\n+impl TableCallback for BumpCallback {\n+    fn f(&self, entry: &mut Entry) {\n+        entry.count += 1;\n+    }\n+}\n+\n+struct PrintCallback(&'static str);\n+\n+impl TableCallback for PrintCallback {\n+    fn f(&self, entry: &mut Entry) {\n+        println(fmt!(\"%d\\t%s\", entry.count as int, **self));\n+    }\n+}\n+\n+struct Entry {\n+    code: Code,\n+    count: i32,\n+    next: Option<~Entry>,\n+}\n+\n+struct Table {\n+    count: i32,\n+    items: [Option<~Entry>, ..TABLE_SIZE]\n+}\n+\n+impl Table {\n+    fn new() -> Table {\n+        Table {\n+            count: 0,\n+            items: [ None, ..TABLE_SIZE ],\n+        }\n+    }\n+\n+    fn search_remainder<C:TableCallback>(item: &mut Entry, key: Code, c: C) {\n+        match item.next {\n+            None => {\n+                let mut entry = ~Entry {\n+                    code: key,\n+                    count: 0,\n+                    next: None,\n+                };\n+                c.f(entry);\n+                item.next = Some(entry);\n+            }\n+            Some(ref mut entry) => {\n+                if entry.code == key {\n+                    c.f(*entry);\n+                    return;\n+                }\n+\n+                Table::search_remainder(*entry, key, c)\n+            }\n+        }\n+    }\n+\n+    fn lookup<C:TableCallback>(&mut self, key: Code, c: C) {\n+        let index = *key % (TABLE_SIZE as u64);\n+\n+        {\n+            if self.items[index].is_none() {\n+                let mut entry = ~Entry {\n+                    code: key,\n+                    count: 0,\n+                    next: None,\n+                };\n+                c.f(entry);\n+                self.items[index] = Some(entry);\n+                return;\n+            }\n+        }\n+\n+        {\n+            let mut entry = &mut *self.items[index].get_mut_ref();\n+            if entry.code == key {\n+                c.f(*entry);\n+                return;\n+            }\n+\n+            Table::search_remainder(*entry, key, c)\n+        }\n+    }\n+\n+    fn each(&self, f: &fn(entry: &Entry) -> bool) {\n+        for self.items.each |item| {\n+            match *item {\n+                None => {}\n+                Some(ref item) => {\n+                    let mut item: &Entry = *item;\n+                    loop {\n+                        if !f(item) {\n+                            return;\n+                        }\n+\n+                        match item.next {\n+                            None => break,\n+                            Some(ref next_item) => item = &**next_item,\n+                        }\n+                    }\n+                }\n+            };\n+        }\n+    }\n+}\n+\n+// Main program\n+\n+fn pack_symbol(c: u8) -> u8 {\n+    match c {\n+        'a' as u8 | 'A' as u8 => 0,\n+        'c' as u8 | 'C' as u8 => 1,\n+        'g' as u8 | 'G' as u8 => 2,\n+        't' as u8 | 'T' as u8 => 3,\n+        _ => fail!(c.to_str())\n+    }\n+}\n+\n+fn unpack_symbol(c: u8) -> u8 {\n+    TABLE[c]\n+}\n+\n+fn next_char<'a>(mut buf: &'a [u8]) -> &'a [u8] {\n+    loop {\n+        buf = slice(buf, 1, buf.len());\n+        if buf.len() == 0 {\n+            break;\n+        }\n+        if buf[0] != (' ' as u8) && buf[0] != ('\\t' as u8) &&\n+                buf[0] != ('\\n' as u8) && buf[0] != 0 {\n+            break;\n+        }\n+    }\n+    buf\n+}\n+\n+#[inline(never)]\n+fn read_stdin() -> ~[u8] {\n+    unsafe {\n+        let mode = \"r\";\n+        //let stdin = fdopen(STDIN_FILENO as c_int, transmute(&mode[0]));\n+        let path = \"knucleotide-input.txt\";\n+        let stdin = fopen(transmute(&path[0]), transmute(&mode[0]));\n+\n+        let mut st: stat = init();\n+        fstat(fileno(stdin), &mut st);\n+        let mut buf = vec::from_elem(st.st_size as uint, 0);\n+\n+        let header = str::byte_slice_no_callback(\">THREE\");\n+        let header = vec::slice(header, 0, 6);\n+\n+        {\n+            let mut window: &mut [u8] = buf;\n+            loop {\n+                fgets(transmute(&mut window[0]), LINE_LEN as c_int, stdin);\n+\n+                {\n+                    if vec::slice(window, 0, 6) == header {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            while fgets(transmute(&mut window[0]),\n+                        LINE_LEN as c_int,\n+                        stdin) != null() {\n+                window = vec::mut_slice(window,\n+                                        strlen(transmute(&window[0])) as uint,\n+                                        window.len());\n+            }\n+        }\n+\n+        buf\n+    }\n+}\n+\n+#[inline(never)]\n+#[fixed_stack_segment]\n+fn generate_frequencies(frequencies: &mut Table,\n+                        mut input: &[u8],\n+                        frame: i32) {\n+    let mut code = Code(0);\n+    \n+    // Pull first frame.\n+    for (frame as uint).times {\n+        code = code.push_char(input[0]);\n+        input = next_char(input);\n+    }\n+    frequencies.lookup(code, BumpCallback);\n+\n+    while input.len() != 0 && input[0] != ('>' as u8) {\n+        code = code.rotate(input[0], frame);\n+        frequencies.lookup(code, BumpCallback);\n+        input = next_char(input);\n+    }\n+}\n+\n+#[inline(never)]\n+#[fixed_stack_segment]\n+fn print_frequencies(frequencies: &Table, frame: i32) {\n+    let mut vector = ~[];\n+    for frequencies.each |entry| {\n+        vector.push((entry.code, entry.count));\n+    }\n+    quick_sort3(vector);\n+\n+    let mut total_count = 0;\n+    for vector.each |&(_, count)| {\n+        total_count += count;\n+    }\n+\n+    for vector.each |&(key, count)| {\n+        println(fmt!(\"%s %.3f\",\n+                     key.unpack(frame),\n+                     (count as float * 100.0) / (total_count as float)));\n+    }\n+}\n+\n+fn print_occurrences(frequencies: &mut Table, occurrence: &'static str) {\n+    frequencies.lookup(Code::pack(occurrence), PrintCallback(occurrence))\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let input = read_stdin();\n+\n+    let mut frequencies = ~Table::new();\n+    generate_frequencies(frequencies, input, 1);\n+    print_frequencies(frequencies, 1);\n+\n+    *frequencies = Table::new();\n+    generate_frequencies(frequencies, input, 2);\n+    print_frequencies(frequencies, 2);\n+\n+    for range(0, 5) |i| {\n+        let occurrence = OCCURRENCES[i];\n+        *frequencies = Table::new();\n+        generate_frequencies(frequencies,\n+                             input,\n+                             occurrence.len() as i32);\n+        print_occurrences(frequencies, occurrence);\n+    }\n+}\n+"}]}