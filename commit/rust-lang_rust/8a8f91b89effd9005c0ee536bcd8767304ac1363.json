{"sha": "8a8f91b89effd9005c0ee536bcd8767304ac1363", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhOGY5MWI4OWVmZmQ5MDA1YzBlZTUzNmJjZDg3NjczMDRhYzEzNjM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-30T12:06:19Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-01T02:35:37Z"}, "message": "Generalize tuple_like_shim's code to be useful for enums", "tree": {"sha": "f5e487deacde077a34a152ace20a1aa6dbd88eb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5e487deacde077a34a152ace20a1aa6dbd88eb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a8f91b89effd9005c0ee536bcd8767304ac1363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8f91b89effd9005c0ee536bcd8767304ac1363", "html_url": "https://github.com/rust-lang/rust/commit/8a8f91b89effd9005c0ee536bcd8767304ac1363", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a8f91b89effd9005c0ee536bcd8767304ac1363/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfd244d952676009e807dca6a9bfdb378b7db72f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd244d952676009e807dca6a9bfdb378b7db72f", "html_url": "https://github.com/rust-lang/rust/commit/dfd244d952676009e807dca6a9bfdb378b7db72f"}], "stats": {"total": 63, "additions": 39, "deletions": 24}, "files": [{"sha": "42ffcc194ca8c4750a8ac9d33b8668ebb56c0178", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f91b89effd9005c0ee536bcd8767304ac1363/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f91b89effd9005c0ee536bcd8767304ac1363/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=8a8f91b89effd9005c0ee536bcd8767304ac1363", "patch": "@@ -297,18 +297,22 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n     let is_copy = !self_ty.moves_by_default(tcx, tcx.param_env(def_id), builder.span);\n \n+    let dest = Place::Local(RETURN_PLACE);\n+    let src = Place::Local(Local::new(1+0)).deref();\n+\n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n         ty::TyArray(ty, len) => {\n             let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n-            builder.array_shim(ty, len)\n+            builder.array_shim(dest, src, ty, len)\n         }\n         ty::TyClosure(def_id, substs) => {\n             builder.tuple_like_shim(\n-                &substs.upvar_tys(def_id, tcx).collect::<Vec<_>>()\n+                dest, src,\n+                substs.upvar_tys(def_id, tcx)\n             )\n         }\n-        ty::TyTuple(tys, _) => builder.tuple_like_shim(&**tys),\n+        ty::TyTuple(tys, _) => builder.tuple_like_shim(dest, src, tys.iter().cloned()),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty)\n         }\n@@ -382,6 +386,14 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         })\n     }\n \n+    /// Gives the index of an upcoming BasicBlock, with an offset.\n+    /// offset=0 will give you the index of the next BasicBlock,\n+    /// offset=1 will give the index of the next-to-next block,\n+    /// offset=-1 will give you the index of the last-created block\n+    fn block_index_offset(&mut self, offset: usize) -> BasicBlock {\n+        BasicBlock::new(self.blocks.len() + offset)\n+    }\n+\n     fn make_statement(&self, kind: StatementKind<'tcx>) -> Statement<'tcx> {\n         Statement {\n             source_info: self.source_info(),\n@@ -502,11 +514,9 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn array_shim(&mut self, ty: Ty<'tcx>, len: u64) {\n+    fn array_shim(&mut self, dest: Place<'tcx>, src: Place<'tcx>, ty: Ty<'tcx>, len: u64) {\n         let tcx = self.tcx;\n         let span = self.span;\n-        let src = Place::Local(Local::new(1+0)).deref();\n-        let dest = Place::Local(RETURN_PLACE);\n \n         let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let end = self.make_place(Mutability::Not, tcx.types.usize);\n@@ -616,42 +626,47 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         self.block(vec![], TerminatorKind::Resume, true);\n     }\n \n-    fn tuple_like_shim(&mut self, tys: &[ty::Ty<'tcx>]) {\n-        let rcvr = Place::Local(Local::new(1+0)).deref();\n-\n-        let mut previous_place = None;\n-        let return_place = Place::Local(RETURN_PLACE);\n-        for (i, ity) in tys.iter().enumerate() {\n+    fn tuple_like_shim<I>(&mut self, dest: Place<'tcx>,\n+                          src: Place<'tcx>, tys: I)\n+            where I: Iterator<Item = ty::Ty<'tcx>> {\n+        let mut previous_field = None;\n+        for (i, ity) in tys.enumerate() {\n             let field = Field::new(i);\n-            let rcvr_field = rcvr.clone().field(field, *ity);\n+            let src_field = src.clone().field(field, ity);\n+\n+            let dest_field = dest.clone().field(field, ity);\n \n-            let place = return_place.clone().field(field, *ity);\n+            // #(2i + 1) is the cleanup block for the previous clone operation\n+            let cleanup_block = self.block_index_offset(1);\n+            // #(2i + 2) is the next cloning block\n+            // (or the Return terminator if this is the last block)\n+            let next_block = self.block_index_offset(2);\n \n             // BB #(2i)\n-            // `returns[i] = Clone::clone(&rcvr.i);`\n+            // `dest.i = Clone::clone(&src.i);`\n             // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n             self.make_clone_call(\n-                place.clone(),\n-                rcvr_field,\n-                *ity,\n-                BasicBlock::new(2 * i + 2),\n-                BasicBlock::new(2 * i + 1),\n+                dest_field.clone(),\n+                src_field,\n+                ity,\n+                next_block,\n+                cleanup_block,\n             );\n \n             // BB #(2i + 1) (cleanup)\n-            if let Some(previous_place) = previous_place.take() {\n+            if let Some((previous_field, previous_cleanup)) = previous_field.take() {\n                 // Drop previous field and goto previous cleanup block.\n                 self.block(vec![], TerminatorKind::Drop {\n-                    location: previous_place,\n-                    target: BasicBlock::new(2 * i - 1),\n+                    location: previous_field,\n+                    target: previous_cleanup,\n                     unwind: None,\n                 }, true);\n             } else {\n                 // Nothing to drop, just resume.\n                 self.block(vec![], TerminatorKind::Resume, true);\n             }\n \n-            previous_place = Some(place);\n+            previous_field = Some((dest_field, cleanup_block));\n         }\n \n         self.block(vec![], TerminatorKind::Return, false);"}]}