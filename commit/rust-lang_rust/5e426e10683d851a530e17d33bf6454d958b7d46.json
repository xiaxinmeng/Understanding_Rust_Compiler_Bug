{"sha": "5e426e10683d851a530e17d33bf6454d958b7d46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNDI2ZTEwNjgzZDg1MWE1MzBlMTdkMzNiZjY0NTRkOTU4YjdkNDY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-31T22:46:36Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-31T22:46:36Z"}, "message": "optionally only emit basic validation for functions containing unsafe block / unsafe function", "tree": {"sha": "4f64a2124a7b17526169e961a648fee3f87ec656", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f64a2124a7b17526169e961a648fee3f87ec656"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e426e10683d851a530e17d33bf6454d958b7d46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e426e10683d851a530e17d33bf6454d958b7d46", "html_url": "https://github.com/rust-lang/rust/commit/5e426e10683d851a530e17d33bf6454d958b7d46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e426e10683d851a530e17d33bf6454d958b7d46/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6135461f9a44732a61e2422af20030ebd31486e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6135461f9a44732a61e2422af20030ebd31486e8", "html_url": "https://github.com/rust-lang/rust/commit/6135461f9a44732a61e2422af20030ebd31486e8"}], "stats": {"total": 213, "additions": 155, "deletions": 58}, "files": [{"sha": "85d9745246f6877cf6f601eed57bb8b6d75c7df2", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5e426e10683d851a530e17d33bf6454d958b7d46", "patch": "@@ -49,7 +49,7 @@ use rustc_data_structures::indexed_vec;\n use std::collections::BTreeMap;\n use std::fmt;\n \n-/// HIR doesn't commit to a concrete storage type and have its own alias for a vector.\n+/// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n /// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n /// behavior. Unlike AST, HIR is mostly a static structure, so we can use an owned slice instead\n /// of `Vec` to avoid keeping extra capacity.\n@@ -76,14 +76,14 @@ pub mod pat_util;\n pub mod print;\n pub mod svh;\n \n-/// A HirId uniquely identifies a node in the HIR of then current crate. It is\n+/// A HirId uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the DefIndex of the directly enclosing\n /// hir::Item, hir::TraitItem, or hir::ImplItem (i.e. the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n /// This two-level structure makes for more stable values: One can move an item\n /// around within the source code, or add or remove stuff before it, without\n-/// the local_id part of the HirId changing, which is a very useful property\n+/// the local_id part of the HirId changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,"}, {"sha": "c8b9412c5663db2db91c0d42c663d48679bdd64b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5e426e10683d851a530e17d33bf6454d958b7d46", "patch": "@@ -1025,8 +1025,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"the directory the MIR is dumped into\"),\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n           \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n-    mir_emit_validate: bool = (false, parse_bool, [TRACKED],\n-          \"emit Validate MIR statements, interpreted e.g. by miri\"),\n+    mir_emit_validate: usize = (0, parse_uint, [TRACKED],\n+          \"emit Validate MIR statements, interpreted e.g. by miri (0: do not emit; 1: if function \\\n+           contains unsafe block, only validate arguments; 2: always emit full validation)\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "1329378fbef03a5b58f558ee2f6724c1a028024a", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 132, "deletions": 42, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=5e426e10683d851a530e17d33bf6454d958b7d46", "patch": "@@ -14,6 +14,8 @@\n //! of MIR building, and only after this pass we think of the program has having the\n //! normal MIR semantics.\n \n+use syntax_pos::Span;\n+use syntax::ast::NodeId;\n use rustc::ty::{self, TyCtxt, RegionKind};\n use rustc::hir;\n use rustc::mir::*;\n@@ -80,15 +82,78 @@ fn lval_context<'a, 'tcx, D>(\n     }\n }\n \n+/// Check if this function contains an unsafe block or is an unsafe function.\n+fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n+    use rustc::hir::intravisit::{self, Visitor};\n+\n+    let fn_node_id = match src {\n+        MirSource::Fn(node_id) => node_id,\n+        _ => return false, // only functions can have unsafe\n+    };\n+    let fn_item = tcx.hir.expect_item(fn_node_id);\n+\n+    struct FindUnsafe<'b, 'tcx> where 'tcx : 'b {\n+        map: &'b hir::map::Map<'tcx>,\n+        found_unsafe: bool,\n+    }\n+    let mut finder = FindUnsafe { map: &tcx.hir, found_unsafe: false };\n+    finder.visit_item(fn_item);\n+\n+    impl<'b, 'tcx> Visitor<'tcx> for FindUnsafe<'b, 'tcx> {\n+        fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+            intravisit::NestedVisitorMap::OnlyBodies(self.map)\n+        }\n+\n+        fn visit_fn(&mut self, fk: intravisit::FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                    b: hir::BodyId, s: Span, id: NodeId)\n+        {\n+            assert!(!self.found_unsafe, \"We should never see more than one fn\");\n+            let is_unsafe = match fk {\n+                intravisit::FnKind::ItemFn(_, _, unsafety, ..) => unsafety == hir::Unsafety::Unsafe,\n+                intravisit::FnKind::Method(_, sig, ..) => sig.unsafety == hir::Unsafety::Unsafe,\n+                intravisit::FnKind::Closure(_) => false,\n+            };\n+            if is_unsafe {\n+                // This is unsafe, and we are done.\n+                self.found_unsafe = true;\n+            } else {\n+                // Go on searching.\n+                intravisit::walk_fn(self, fk, fd, b, s, id)\n+            }\n+        }\n+\n+        fn visit_block(&mut self, b: &'tcx hir::Block) {\n+            use rustc::hir::BlockCheckMode::*;\n+\n+            if self.found_unsafe { return; } // short-circuit\n+\n+            match b.rules {\n+                UnsafeBlock(_) | PushUnsafeBlock(_) => {\n+                    // We found an unsafe block.\n+                    self.found_unsafe = true;\n+                }\n+                DefaultBlock | PopUnsafeBlock(_) => {\n+                    // No unsafe block here, go on searching.\n+                    intravisit::walk_block(self, b);\n+                }\n+            };\n+        }\n+    }\n+\n+    finder.found_unsafe\n+}\n+\n impl MirPass for AddValidation {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource,\n-                          mir: &mut Mir<'tcx>) {\n-        if !tcx.sess.opts.debugging_opts.mir_emit_validate {\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>)\n+    {\n+        let emit_validate = tcx.sess.opts.debugging_opts.mir_emit_validate;\n+        if emit_validate == 0 {\n             return;\n         }\n-\n+        let restricted_validation = emit_validate == 1 && fn_contains_unsafe(tcx, src);\n         let local_decls = mir.local_decls.clone(); // FIXME: Find a way to get rid of this clone.\n \n         // Convert an lvalue to a validation operand.\n@@ -98,22 +163,40 @@ impl MirPass for AddValidation {\n             ValidationOperand { lval, ty, re, mutbl }\n         };\n \n+        // Emit an Acquire at the beginning of the given block.  If we are in restricted emission mode\n+        // (mir_emit_validate=1), also emit a Release immediately after the Acquire.\n+        let emit_acquire = |block: &mut BasicBlockData<'tcx>, source_info, operands: Vec<_>| {\n+            if operands.len() == 0 {\n+                return; // Nothing to do\n+            }\n+            // Emit the release first, to avoid cloning if we do not emit it\n+            if restricted_validation {\n+                let release_stmt = Statement {\n+                    source_info,\n+                    kind: StatementKind::Validate(ValidationOp::Release, operands.clone()),\n+                };\n+                block.statements.insert(0, release_stmt);\n+            }\n+            // Now, the acquire\n+            let acquire_stmt = Statement {\n+                source_info,\n+                kind: StatementKind::Validate(ValidationOp::Acquire, operands),\n+            };\n+            block.statements.insert(0, acquire_stmt);\n+        };\n+\n         // PART 1\n         // Add an AcquireValid at the beginning of the start block.\n-        if mir.arg_count > 0 {\n-            let acquire_stmt = Statement {\n-                source_info: SourceInfo {\n-                    scope: ARGUMENT_VISIBILITY_SCOPE,\n-                    span: mir.span, // FIXME: Consider using just the span covering the function\n-                                    // argument declaration.\n-                },\n-                kind: StatementKind::Validate(ValidationOp::Acquire,\n-                    // Skip return value, go over all the arguments\n-                    mir.local_decls.iter_enumerated().skip(1).take(mir.arg_count)\n-                    .map(|(local, _)| lval_to_operand(Lvalue::Local(local))).collect()\n-                )\n+        {\n+            let source_info = SourceInfo {\n+                scope: ARGUMENT_VISIBILITY_SCOPE,\n+                span: mir.span, // FIXME: Consider using just the span covering the function\n+                                // argument declaration.\n             };\n-            mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, acquire_stmt);\n+            // Gather all arguments, skip return value.\n+            let operands = mir.local_decls.iter_enumerated().skip(1).take(mir.arg_count)\n+                    .map(|(local, _)| lval_to_operand(Lvalue::Local(local))).collect();\n+            emit_acquire(&mut mir.basic_blocks_mut()[START_BLOCK], source_info, operands);\n         }\n \n         // PART 2\n@@ -125,18 +208,20 @@ impl MirPass for AddValidation {\n                 Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. },\n                                   source_info }) => {\n                     // Before the call: Release all arguments\n-                    let release_stmt = Statement {\n-                        source_info,\n-                        kind: StatementKind::Validate(ValidationOp::Release,\n-                            args.iter().filter_map(|op| {\n-                                match op {\n-                                    &Operand::Consume(ref lval) =>\n-                                        Some(lval_to_operand(lval.clone())),\n-                                    &Operand::Constant(..) => { None },\n-                                }\n-                            }).collect())\n-                    };\n-                    block_data.statements.push(release_stmt);\n+                    if !restricted_validation {\n+                        let release_stmt = Statement {\n+                            source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Release,\n+                                args.iter().filter_map(|op| {\n+                                    match op {\n+                                        &Operand::Consume(ref lval) =>\n+                                            Some(lval_to_operand(lval.clone())),\n+                                        &Operand::Constant(..) => { None },\n+                                    }\n+                                }).collect())\n+                        };\n+                        block_data.statements.push(release_stmt);\n+                    }\n                     // Remember the return destination for later\n                     if let &Some(ref destination) = destination {\n                         returns.push((source_info, destination.0.clone(), destination.1));\n@@ -147,12 +232,14 @@ impl MirPass for AddValidation {\n                 Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref lval, .. },\n                                   source_info }) => {\n                     // Before the call: Release all arguments\n-                    let release_stmt = Statement {\n-                        source_info,\n-                        kind: StatementKind::Validate(ValidationOp::Release,\n-                                vec![lval_to_operand(lval.clone())]),\n-                    };\n-                    block_data.statements.push(release_stmt);\n+                    if !restricted_validation {\n+                        let release_stmt = Statement {\n+                            source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Release,\n+                                    vec![lval_to_operand(lval.clone())]),\n+                        };\n+                        block_data.statements.push(release_stmt);\n+                    }\n                     // drop doesn't return anything, so we need no acquire.\n                 }\n                 _ => {\n@@ -162,18 +249,21 @@ impl MirPass for AddValidation {\n         }\n         // Now we go over the returns we collected to acquire the return values.\n         for (source_info, dest_lval, dest_block) in returns {\n-            let acquire_stmt = Statement {\n+            emit_acquire(\n+                &mut mir.basic_blocks_mut()[dest_block],\n                 source_info,\n-                kind: StatementKind::Validate(ValidationOp::Acquire,\n-                        vec![lval_to_operand(dest_lval)]),\n-            };\n-            mir.basic_blocks_mut()[dest_block].statements.insert(0, acquire_stmt);\n+                vec![lval_to_operand(dest_lval)]\n+            );\n+        }\n+\n+        if restricted_validation {\n+            // No part 3 for us.\n+            return;\n         }\n \n         // PART 3\n         // Add ReleaseValid/AcquireValid around Ref and Cast.  Again an iterator does not seem very\n-        // suited\n-        // as we need to add new statements before and after each Ref.\n+        // suited as we need to add new statements before and after each Ref.\n         for block_data in mir.basic_blocks_mut() {\n             // We want to insert statements around Ref commands as we iterate.  To this end, we\n             // iterate backwards using indices."}, {"sha": "baf0522896c9c8c8120ff7e1d1531c0a8cd1d7c1", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=5e426e10683d851a530e17d33bf6454d958b7d46", "patch": "@@ -77,7 +77,9 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        if !self.tcx.sess.opts.debugging_opts.mir_emit_validate {\n+        // Do NOT delete EndRegion if validation statements are emitted.\n+        // Validation needs EndRegion.\n+        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n             if let StatementKind::EndRegion(_) = statement.kind {\n                 statement.kind = StatementKind::Nop;\n             }"}, {"sha": "558426fcde14de15a84d63ebeae9cfc63799400b", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=5e426e10683d851a530e17d33bf6454d958b7d46", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags: -Z verbose -Z mir-emit-validate\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n \n fn foo(_x: &mut i32) {}\n "}, {"sha": "21723739ca197ddc45442f9583b2bca6ec4ca1d1", "filename": "src/test/mir-opt/validate_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs?ref=5e426e10683d851a530e17d33bf6454d958b7d46", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags: -Z verbose -Z mir-emit-validate\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n \n fn main() {\n     let _x : Box<[i32]> = Box::new([1, 2, 3]);"}, {"sha": "88ae114c579ae9c0add93f25c1bb036f163aea92", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e426e10683d851a530e17d33bf6454d958b7d46/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=5e426e10683d851a530e17d33bf6454d958b7d46", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags: -Z verbose -Z mir-emit-validate\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n \n struct Test {\n     x: i32\n@@ -18,6 +18,10 @@ struct Test {\n fn foo(_x: &i32) {}\n \n fn main() {\n+    // These internal unsafe functions should have no effect on the code generation.\n+    unsafe fn _unused1() {}\n+    fn _unused2(x: *const i32) -> i32 { unsafe { *x }}\n+\n     let t = Test { x: 0 };\n     let t = &t;\n     foo(&t.x);\n@@ -28,18 +32,18 @@ fn main() {\n // fn main() -> () {\n //     let mut _5: &ReErased i32;\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(NodeId(31)))), [((*_2).0: i32)@i32/ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 1 })) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [((*_2).0: i32)@i32/ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n-//         Validate(Acquire, [(*_5)@i32/ReScope(Misc(NodeId(31))) (imm)]);\n-//         Validate(Suspend(ReScope(Misc(NodeId(31)))), [(*_5)@i32/ReScope(Misc(NodeId(31))) (imm)]);\n+//         Validate(Acquire, [(*_5)@i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [(*_5)@i32/ReScope(Misc(NodeId(46))) (imm)]);\n //         _4 = &ReErased (*_5);\n-//         Validate(Acquire, [(*_4)@i32/ReScope(Misc(NodeId(31))) (imm)]);\n-//         Validate(Release, [_4@&ReScope(Misc(NodeId(31))) i32]);\n+//         Validate(Acquire, [(*_4)@i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Release, [_4@&ReScope(Misc(NodeId(46))) i32]);\n //         _3 = const foo(_4) -> bb1;\n //     }\n //     bb1: {\n-//         EndRegion(ReScope(Misc(NodeId(31))));\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 1 })));\n+//         EndRegion(ReScope(Misc(NodeId(46))));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })));\n //         return;\n //     }\n // }"}]}