{"sha": "8b6216df05a1d17e58f789bbd323ce2679f9ab4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNjIxNmRmMDVhMWQxN2U1OGY3ODliYmQzMjNjZTI2NzlmOWFiNGE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-05-03T14:08:39Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-05-03T14:08:39Z"}, "message": "Support macro for trait items", "tree": {"sha": "73e62b8c63857249d2e0419ba0c38ebe67aefab8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73e62b8c63857249d2e0419ba0c38ebe67aefab8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b6216df05a1d17e58f789bbd323ce2679f9ab4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b6216df05a1d17e58f789bbd323ce2679f9ab4a", "html_url": "https://github.com/rust-lang/rust/commit/8b6216df05a1d17e58f789bbd323ce2679f9ab4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b6216df05a1d17e58f789bbd323ce2679f9ab4a/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2474f42ae95bffea7c0bc713f92322bfec4d59a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2474f42ae95bffea7c0bc713f92322bfec4d59a7", "html_url": "https://github.com/rust-lang/rust/commit/2474f42ae95bffea7c0bc713f92322bfec4d59a7"}], "stats": {"total": 189, "additions": 88, "deletions": 101}, "files": [{"sha": "0633eddee0f350a07185b4ab2ad88aa51986cbb4", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 67, "deletions": 82, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/8b6216df05a1d17e58f789bbd323ce2679f9ab4a/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b6216df05a1d17e58f789bbd323ce2679f9ab4a/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=8b6216df05a1d17e58f789bbd323ce2679f9ab4a", "patch": "@@ -150,51 +150,31 @@ pub struct TraitData {\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n-        let src = tr.lookup(db).source(db);\n+        let tr_loc = tr.lookup(db);\n+        let src = tr_loc.source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let auto = src.value.auto_token().is_some();\n-        let ast_id_map = db.ast_id_map(src.file_id);\n+        let module_id = tr_loc.container.module(db);\n \n         let container = AssocContainerId::TraitId(tr);\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = FunctionLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                    ast::ImplItem::ConstDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = ConstLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                    ast::ImplItem::TypeAliasDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = TypeAliasLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n+        let mut items = Vec::new();\n+\n+        if let Some(item_list) = src.value.item_list() {\n+            let mut expander = Expander::new(db, tr_loc.ast_id.file_id, module_id);\n+            items.extend(collect_impl_items(\n+                db,\n+                &mut expander,\n+                item_list.impl_items(),\n+                src.file_id,\n+                container,\n+            ));\n+            items.extend(collect_impl_items_in_macros(\n+                db,\n+                &mut expander,\n+                &src.with_value(item_list),\n+                container,\n+            ));\n+        }\n         Arc::new(TraitData { name, items, auto })\n     }\n \n@@ -232,24 +212,33 @@ impl ImplData {\n         let target_type = TypeRef::from_ast_opt(&lower_ctx, src.value.target_type());\n         let is_negative = src.value.excl_token().is_some();\n         let module_id = impl_loc.container.module(db);\n+        let container = AssocContainerId::ImplId(id);\n \n-        let mut items = Vec::new();\n+        let mut items: Vec<AssocItemId> = Vec::new();\n \n         if let Some(item_list) = src.value.item_list() {\n             let mut expander = Expander::new(db, impl_loc.ast_id.file_id, module_id);\n-            items.extend(collect_impl_items(\n-                db,\n-                &mut expander,\n-                item_list.impl_items(),\n-                src.file_id,\n-                id,\n-            ));\n-            items.extend(collect_impl_items_in_macros(\n-                db,\n-                &mut expander,\n-                &src.with_value(item_list),\n-                id,\n-            ));\n+            items.extend(\n+                collect_impl_items(\n+                    db,\n+                    &mut expander,\n+                    item_list.impl_items(),\n+                    src.file_id,\n+                    container,\n+                )\n+                .into_iter()\n+                .map(|(_, item)| item),\n+            );\n+            items.extend(\n+                collect_impl_items_in_macros(\n+                    db,\n+                    &mut expander,\n+                    &src.with_value(item_list),\n+                    container,\n+                )\n+                .into_iter()\n+                .map(|(_, item)| item),\n+            );\n         }\n \n         let res = ImplData { target_trait, target_type, items, is_negative };\n@@ -296,15 +285,15 @@ fn collect_impl_items_in_macros(\n     db: &dyn DefDatabase,\n     expander: &mut Expander,\n     impl_def: &InFile<ast::ItemList>,\n-    id: ImplId,\n-) -> Vec<AssocItemId> {\n+    container: AssocContainerId,\n+) -> Vec<(Name, AssocItemId)> {\n     let mut res = Vec::new();\n \n     // We set a limit to protect against infinite recursion\n     let limit = 100;\n \n     for m in impl_def.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-        res.extend(collect_impl_items_in_macro(db, expander, m, id, limit))\n+        res.extend(collect_impl_items_in_macro(db, expander, m, container, limit))\n     }\n \n     res\n@@ -314,9 +303,9 @@ fn collect_impl_items_in_macro(\n     db: &dyn DefDatabase,\n     expander: &mut Expander,\n     m: ast::MacroCall,\n-    id: ImplId,\n+    container: AssocContainerId,\n     limit: usize,\n-) -> Vec<AssocItemId> {\n+) -> Vec<(Name, AssocItemId)> {\n     if limit == 0 {\n         return Vec::new();\n     }\n@@ -328,13 +317,14 @@ fn collect_impl_items_in_macro(\n             expander,\n             items.value.items().filter_map(|it| ImplItem::cast(it.syntax().clone())),\n             items.file_id,\n-            id,\n+            container,\n         );\n+\n         // Recursive collect macros\n         // Note that ast::ModuleItem do not include ast::MacroCall\n         // We cannot use ModuleItemOwner::items here\n         for it in items.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-            res.extend(collect_impl_items_in_macro(db, expander, it, id, limit - 1))\n+            res.extend(collect_impl_items_in_macro(db, expander, it, container, limit - 1))\n         }\n         expander.exit(db, mark);\n         res\n@@ -348,39 +338,34 @@ fn collect_impl_items(\n     expander: &mut Expander,\n     impl_items: impl Iterator<Item = ImplItem>,\n     file_id: crate::HirFileId,\n-    id: ImplId,\n-) -> Vec<AssocItemId> {\n+    container: AssocContainerId,\n+) -> Vec<(Name, AssocItemId)> {\n     let items = db.ast_id_map(file_id);\n \n     impl_items\n         .filter_map(|item_node| match item_node {\n             ast::ImplItem::FnDef(it) => {\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n                 let attrs = expander.parse_attrs(&it);\n                 if !expander.is_cfg_enabled(&attrs) {\n                     return None;\n                 }\n-                let def = FunctionLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+                let def = FunctionLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                    .intern(db);\n+                Some((name, def.into()))\n             }\n             ast::ImplItem::ConstDef(it) => {\n-                let def = ConstLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                let def = ConstLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                    .intern(db);\n+                Some((name, def.into()))\n             }\n             ast::ImplItem::TypeAliasDef(it) => {\n-                let def = TypeAliasLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                let def =\n+                    TypeAliasLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                        .intern(db);\n+                Some((name, def.into()))\n             }\n         })\n         .collect()"}, {"sha": "23f682effaa3f5090f417638d4f6d318be8a5521", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8b6216df05a1d17e58f789bbd323ce2679f9ab4a/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b6216df05a1d17e58f789bbd323ce2679f9ab4a/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=8b6216df05a1d17e58f789bbd323ce2679f9ab4a", "patch": "@@ -2055,7 +2055,7 @@ fn test<I: Iterator<Item: Iterator<Item = u32>>>() {\n #[test]\n fn proc_macro_server_types() {\n     assert_snapshot!(\n-        infer_with_mismatches(r#\"\n+        infer(r#\"\n macro_rules! with_api {\n     ($S:ident, $self:ident, $m:ident) => {\n         $m! {\n@@ -2069,9 +2069,9 @@ macro_rules! with_api {\n }\n macro_rules! associated_item {\n     (type TokenStream) =>\n-        (type TokenStream: 'static + Clone;);\n+        (type TokenStream: 'static;);\n     (type Group) =>\n-        (type Group: 'static + Clone;);\n+        (type Group: 'static;);\n     ($($item:tt)*) => ($($item)*;)\n }\n macro_rules! declare_server_traits {\n@@ -2083,39 +2083,41 @@ macro_rules! declare_server_traits {\n         }\n \n         $(pub trait $name: Types {\n-            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n+            $(associated_item!(fn $method($($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n         })*\n \n         pub trait Server: Types $(+ $name)* {}\n         impl<S: Types $(+ $name)*> Server for S {}\n     }\n }\n+\n with_api!(Self, self_, declare_server_traits);\n-struct Group {}\n-struct TokenStream {}\n+struct G {}\n+struct T {}\n struct Rustc;\n impl Types for Rustc {\n-    type TokenStream = TokenStream;\n-    type Group = Group;\n+    type TokenStream = T;\n+    type Group = G;\n }\n+\n fn make<T>() -> T { loop {} }\n impl TokenStream for Rustc {\n     fn new() -> Self::TokenStream {\n         let group: Self::Group = make();\n         make()\n     }\n-}\n-\"#, true),\n+}        \n+\"#),\n         @r###\"\n-    1115..1126 '{ loop {} }': T\n-    1117..1124 'loop {}': !\n-    1122..1124 '{}': ()\n-    1190..1253 '{     ...     }': {unknown}\n-    1204..1209 'group': {unknown}\n-    1225..1229 'make': fn make<{unknown}>() -> {unknown}\n-    1225..1231 'make()': {unknown}\n-    1241..1245 'make': fn make<{unknown}>() -> {unknown}\n-    1241..1247 'make()': {unknown}\n+    1062..1073 '{ loop {} }': T\n+    1064..1071 'loop {}': !\n+    1069..1071 '{}': ()\n+    1137..1200 '{     ...     }': T\n+    1151..1156 'group': G\n+    1172..1176 'make': fn make<G>() -> G\n+    1172..1178 'make()': G\n+    1188..1192 'make': fn make<T>() -> T\n+    1188..1194 'make()': T\n     \"###\n     );\n }"}]}