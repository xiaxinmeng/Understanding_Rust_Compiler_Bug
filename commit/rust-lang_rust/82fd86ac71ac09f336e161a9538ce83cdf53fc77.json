{"sha": "82fd86ac71ac09f336e161a9538ce83cdf53fc77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZmQ4NmFjNzFhYzA5ZjMzNmUxNjFhOTUzOGNlODNjZGY1M2ZjNzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-03T17:16:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-03T17:16:02Z"}, "message": "Merge #2472\n\n2472: Split up ty tests a bit r=matklad a=flodiebold\n\n`simple` is a bit of a kitchen sink (and not all of them are really about 'simple' features), suggestions for further divisions there are welcome :smile: \n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "2c4807d138af0c2f9acc054f7bbcee93faefb628", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c4807d138af0c2f9acc054f7bbcee93faefb628"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82fd86ac71ac09f336e161a9538ce83cdf53fc77", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd5phTCRBK7hj4Ov3rIwAAdHIIAB4TlPzZyvBydtMsbfd1yaFW\ng1+0a/myXiURxNBUVdYDuEqHVAWNQi8gaDSHi9OFf50PVT5rornEdpbzTSB6Sb4E\nv62h/n8GeLH2pozlFopAv1l6DO+7V0Ts4HajHPePIvFv524LvP/i+zk9R4YL61pF\n6XJF+dG4I/9mlUSaqz4aGnZ8BvrTRAead830VVV+b6LkcnicBjSYb98N2TY4H6NQ\nxvbKV3E51sUV+51Pb8xDchYPd/SdJG8cVUw2m7H5oIDq9nhIcFt45a1o4rOPzpHS\nBkqKOb3EF0bPTKGWd49exQS85tx26ZjwBPIB+ukIC8rtl0SLnaI4vIGSus16RUc=\n=dtzn\n-----END PGP SIGNATURE-----\n", "payload": "tree 2c4807d138af0c2f9acc054f7bbcee93faefb628\nparent 96b9d5b44ed50160c7a4eb07a31bee5f05b1ecf3\nparent 9747156f6c5c9b5cccc347a68042e6d9a6b0f704\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575393362 +0000\ncommitter GitHub <noreply@github.com> 1575393362 +0000\n\nMerge #2472\n\n2472: Split up ty tests a bit r=matklad a=flodiebold\n\n`simple` is a bit of a kitchen sink (and not all of them are really about 'simple' features), suggestions for further divisions there are welcome :smile: \n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82fd86ac71ac09f336e161a9538ce83cdf53fc77", "html_url": "https://github.com/rust-lang/rust/commit/82fd86ac71ac09f336e161a9538ce83cdf53fc77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82fd86ac71ac09f336e161a9538ce83cdf53fc77/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96b9d5b44ed50160c7a4eb07a31bee5f05b1ecf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/96b9d5b44ed50160c7a4eb07a31bee5f05b1ecf3", "html_url": "https://github.com/rust-lang/rust/commit/96b9d5b44ed50160c7a4eb07a31bee5f05b1ecf3"}, {"sha": "9747156f6c5c9b5cccc347a68042e6d9a6b0f704", "url": "https://api.github.com/repos/rust-lang/rust/commits/9747156f6c5c9b5cccc347a68042e6d9a6b0f704", "html_url": "https://github.com/rust-lang/rust/commit/9747156f6c5c9b5cccc347a68042e6d9a6b0f704"}], "stats": {"total": 9784, "additions": 4882, "deletions": 4902}, "files": [{"sha": "c520bb375eafd8456772e115c38aacb1f46ef14e", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 6, "deletions": 4902, "changes": 4908, "blob_url": "https://github.com/rust-lang/rust/blob/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=82fd86ac71ac09f336e161a9538ce83cdf53fc77"}, {"sha": "0d9a35ce08fde4bb32bc5eb125adbf016657e518", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=82fd86ac71ac09f336e161a9538ce83cdf53fc77", "patch": "@@ -0,0 +1,268 @@\n+use super::{infer, type_at, type_at_pos};\n+use crate::test_db::TestDB;\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn cfg_impl_block() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:foo cfg:test\n+use foo::S as T;\n+struct S;\n+\n+#[cfg(test)]\n+impl S {\n+    fn foo1(&self) -> i32 { 0 }\n+}\n+\n+#[cfg(not(test))]\n+impl S {\n+    fn foo2(&self) -> i32 { 0 }\n+}\n+\n+fn test() {\n+    let t = (S.foo1(), S.foo2(), T.foo3(), T.foo4());\n+    t<|>;\n+}\n+\n+//- /foo.rs crate:foo\n+struct S;\n+\n+#[cfg(not(test))]\n+impl S {\n+    fn foo3(&self) -> i32 { 0 }\n+}\n+\n+#[cfg(test)]\n+impl S {\n+    fn foo4(&self) -> i32 { 0 }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"(i32, {unknown}, i32, {unknown})\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_macros_expanded() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo(Vec<i32>);\n+\n+macro_rules! foo {\n+    ($($item:expr),*) => {\n+            {\n+                Foo(vec![$($item,)*])\n+            }\n+    };\n+}\n+\n+fn main() {\n+    let x = foo!(1,2);\n+}\n+\"#),\n+        @r###\"\n+    ![0; 17) '{Foo(v...,2,])}': Foo\n+    ![1; 4) 'Foo': Foo({unknown}) -> Foo\n+    ![1; 16) 'Foo(vec![1,2,])': Foo\n+    ![5; 15) 'vec![1,2,]': {unknown}\n+    [156; 182) '{     ...,2); }': ()\n+    [166; 167) 'x': Foo\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_legacy_textual_scoped_macros_expanded() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo(Vec<i32>);\n+\n+#[macro_use]\n+mod m {\n+    macro_rules! foo {\n+        ($($item:expr),*) => {\n+            {\n+                Foo(vec![$($item,)*])\n+            }\n+        };\n+    }\n+}\n+\n+fn main() {\n+    let x = foo!(1,2);\n+    let y = crate::foo!(1,2);\n+}\n+\"#),\n+        @r###\"\n+    ![0; 17) '{Foo(v...,2,])}': Foo\n+    ![1; 4) 'Foo': Foo({unknown}) -> Foo\n+    ![1; 16) 'Foo(vec![1,2,])': Foo\n+    ![5; 15) 'vec![1,2,]': {unknown}\n+    [195; 251) '{     ...,2); }': ()\n+    [205; 206) 'x': Foo\n+    [228; 229) 'y': {unknown}\n+    [232; 248) 'crate:...!(1,2)': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_path_qualified_macros_expanded() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[macro_export]\n+macro_rules! foo {\n+    () => { 42i32 }\n+}\n+\n+mod m {\n+    pub use super::foo as bar;\n+}\n+\n+fn main() {\n+    let x = crate::foo!();\n+    let y = m::bar!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 5) '42i32': i32\n+    ![0; 5) '42i32': i32\n+    [111; 164) '{     ...!(); }': ()\n+    [121; 122) 'x': i32\n+    [148; 149) 'y': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_type_value_macro_having_same_name() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        mod foo {\n+            pub use super::foo;\n+        }\n+    };\n+    ($x:tt) => {\n+        $x\n+    };\n+}\n+\n+foo!();\n+\n+fn foo() {\n+    let foo = foo::foo!(42i32);\n+}\n+\"#),\n+        @r###\"\n+    ![0; 5) '42i32': i32\n+    [171; 206) '{     ...32); }': ()\n+    [181; 184) 'foo': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn processes_impls_generated_by_macros() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+macro_rules! m {\n+    ($ident:ident) => (impl Trait for $ident {})\n+}\n+trait Trait { fn foo(self) -> u128 {} }\n+struct S;\n+m!(S);\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+fn test() {\n+    let x = (foo::foo!(1), foo::foo!(2));\n+    x<|>;\n+}\n+\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! foo {\n+    (1) => { $crate::bar!() };\n+    (2) => { 1 + $crate::baz() };\n+}\n+\n+#[macro_export]\n+macro_rules! bar {\n+    () => { 42 }\n+}\n+\n+pub fn baz() -> usize { 31usize }\n+\"#,\n+    );\n+    assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_builtin_macros_line() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! line {() => {}}\n+\n+fn main() {\n+    let x = line!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 1) '6': i32\n+    [64; 88) '{     ...!(); }': ()\n+    [74; 75) 'x': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_builtin_macros_file() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! file {() => {}}\n+\n+fn main() {\n+    let x = file!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 2) '\"\"': &str\n+    [64; 88) '{     ...!(); }': ()\n+    [74; 75) 'x': &str\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_builtin_macros_column() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! column {() => {}}\n+\n+fn main() {\n+    let x = column!();\n+}\n+\"#),\n+        @r###\"\n+    ![0; 2) '13': i32\n+    [66; 92) '{     ...!(); }': ()\n+    [76; 77) 'x': i32\n+    \"###\n+    );\n+}"}, {"sha": "45164c9e96a59e4802c739c6fe284aba7961734c", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "added", "additions": 1005, "deletions": 0, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=82fd86ac71ac09f336e161a9538ce83cdf53fc77", "patch": "@@ -0,0 +1,1005 @@\n+use super::{infer, type_at, type_at_pos};\n+use crate::test_db::TestDB;\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn infer_slice_method() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"slice\"]\n+impl<T> [T] {\n+    fn foo(&self) -> T {\n+        loop {}\n+    }\n+}\n+\n+#[lang = \"slice_alloc\"]\n+impl<T> [T] {}\n+\n+fn test() {\n+    <[_]>::foo(b\"foo\");\n+}\n+\"#),\n+        @r###\"\n+    [45; 49) 'self': &[T]\n+    [56; 79) '{     ...     }': T\n+    [66; 73) 'loop {}': !\n+    [71; 73) '{}': ()\n+    [133; 160) '{     ...o\"); }': ()\n+    [139; 149) '<[_]>::foo': fn foo<u8>(&[T]) -> T\n+    [139; 157) '<[_]>:...\"foo\")': u8\n+    [150; 156) 'b\"foo\"': &[u8]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_struct() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A { x: u32 }\n+\n+impl A {\n+    fn new() -> A {\n+        A { x: 0 }\n+    }\n+}\n+fn test() {\n+    let a = A::new();\n+    a.x;\n+}\n+\"#),\n+        @r###\"\n+    [49; 75) '{     ...     }': A\n+    [59; 69) 'A { x: 0 }': A\n+    [66; 67) '0': u32\n+    [88; 122) '{     ...a.x; }': ()\n+    [98; 99) 'a': A\n+    [102; 108) 'A::new': fn new() -> A\n+    [102; 110) 'A::new()': A\n+    [116; 117) 'a': A\n+    [116; 119) 'a.x': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_enum() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum A { B, C }\n+\n+impl A {\n+    pub fn b() -> A {\n+        A::B\n+    }\n+    pub fn c() -> A {\n+        A::C\n+    }\n+}\n+fn test() {\n+    let a = A::b();\n+    a;\n+    let c = A::c();\n+    c;\n+}\n+\"#),\n+        @r###\"\n+    [47; 67) '{     ...     }': A\n+    [57; 61) 'A::B': A\n+    [88; 108) '{     ...     }': A\n+    [98; 102) 'A::C': A\n+    [121; 178) '{     ...  c; }': ()\n+    [131; 132) 'a': A\n+    [135; 139) 'A::b': fn b() -> A\n+    [135; 141) 'A::b()': A\n+    [147; 148) 'a': A\n+    [158; 159) 'c': A\n+    [162; 166) 'A::c': fn c() -> A\n+    [162; 168) 'A::c()': A\n+    [174; 175) 'c': A\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_with_modules() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod a {\n+    struct A;\n+    impl A { pub fn thing() -> A { A {} }}\n+}\n+\n+mod b {\n+    struct B;\n+    impl B { pub fn thing() -> u32 { 99 }}\n+\n+    mod c {\n+        struct C;\n+        impl C { pub fn thing() -> C { C {} }}\n+    }\n+}\n+use b::c;\n+\n+fn test() {\n+    let x = a::A::thing();\n+    let y = b::B::thing();\n+    let z = c::C::thing();\n+}\n+\"#),\n+        @r###\"\n+    [56; 64) '{ A {} }': A\n+    [58; 62) 'A {}': A\n+    [126; 132) '{ 99 }': u32\n+    [128; 130) '99': u32\n+    [202; 210) '{ C {} }': C\n+    [204; 208) 'C {}': C\n+    [241; 325) '{     ...g(); }': ()\n+    [251; 252) 'x': A\n+    [255; 266) 'a::A::thing': fn thing() -> A\n+    [255; 268) 'a::A::thing()': A\n+    [278; 279) 'y': u32\n+    [282; 293) 'b::B::thing': fn thing() -> u32\n+    [282; 295) 'b::B::thing()': u32\n+    [305; 306) 'z': C\n+    [309; 320) 'c::C::thing': fn thing() -> C\n+    [309; 322) 'c::C::thing()': C\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Gen<T> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make(val: T) -> Gen<T> {\n+        Gen { val }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make(0u32);\n+}\n+\"#),\n+        @r###\"\n+    [64; 67) 'val': T\n+    [82; 109) '{     ...     }': Gen<T>\n+    [92; 103) 'Gen { val }': Gen<T>\n+    [98; 101) 'val': T\n+    [123; 155) '{     ...32); }': ()\n+    [133; 134) 'a': Gen<u32>\n+    [137; 146) 'Gen::make': fn make<u32>(T) -> Gen<T>\n+    [137; 152) 'Gen::make(0u32)': Gen<u32>\n+    [147; 151) '0u32': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_with_default_param() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Gen<T=u32> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make() -> Gen<T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make();\n+}\n+\"#),\n+        @r###\"\n+    [80; 104) '{     ...     }': Gen<T>\n+    [90; 98) 'loop { }': !\n+    [95; 98) '{ }': ()\n+    [118; 146) '{     ...e(); }': ()\n+    [128; 129) 'a': Gen<u32>\n+    [132; 141) 'Gen::make': fn make<u32>() -> Gen<T>\n+    [132; 143) 'Gen::make()': Gen<u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_with_default_tuple_param() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct Gen<T=()> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make() -> Gen<T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make();\n+    a.val<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_without_args() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Gen<T> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make() -> Gen<T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::<u32>::make();\n+}\n+\"#),\n+        @r###\"\n+    [76; 100) '{     ...     }': Gen<T>\n+    [86; 94) 'loop { }': !\n+    [91; 94) '{ }': ()\n+    [114; 149) '{     ...e(); }': ()\n+    [124; 125) 'a': Gen<u32>\n+    [128; 144) 'Gen::<...::make': fn make<u32>() -> Gen<T>\n+    [128; 146) 'Gen::<...make()': Gen<u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_2_type_params_without_args() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Gen<T, U> {\n+    val: T,\n+    val2: U,\n+}\n+\n+impl<T> Gen<u32, T> {\n+    pub fn make() -> Gen<u32,T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::<u32, u64>::make();\n+}\n+\"#),\n+        @r###\"\n+    [102; 126) '{     ...     }': Gen<u32, T>\n+    [112; 120) 'loop { }': !\n+    [117; 120) '{ }': ()\n+    [140; 180) '{     ...e(); }': ()\n+    [150; 151) 'a': Gen<u32, u64>\n+    [154; 175) 'Gen::<...::make': fn make<u64>() -> Gen<u32, T>\n+    [154; 177) 'Gen::<...make()': Gen<u32, u64>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn cross_crate_associated_method_call() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:other_crate\n+fn test() {\n+    let x = other_crate::foo::S::thing();\n+    x<|>;\n+}\n+\n+//- /lib.rs crate:other_crate\n+mod foo {\n+    struct S;\n+    impl S {\n+        fn thing() -> i128 {}\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"i128\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_trait_method_simple() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait1 {\n+    fn method(&self) -> u32;\n+}\n+struct S1;\n+impl Trait1 for S1 {}\n+trait Trait2 {\n+    fn method(&self) -> i128;\n+}\n+struct S2;\n+impl Trait2 for S2 {}\n+fn test() {\n+    S1.method(); // -> u32\n+    S2.method(); // -> i128\n+}\n+\"#),\n+        @r###\"\n+    [31; 35) 'self': &Self\n+    [110; 114) 'self': &Self\n+    [170; 228) '{     ...i128 }': ()\n+    [176; 178) 'S1': S1\n+    [176; 187) 'S1.method()': u32\n+    [203; 205) 'S2': S2\n+    [203; 214) 'S2.method()': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_scoped() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+mod foo {\n+    pub trait Trait1 {\n+        fn method(&self) -> u32;\n+    }\n+    impl Trait1 for super::S {}\n+}\n+mod bar {\n+    pub trait Trait2 {\n+        fn method(&self) -> i128;\n+    }\n+    impl Trait2 for super::S {}\n+}\n+\n+mod foo_test {\n+    use super::S;\n+    use super::foo::Trait1;\n+    fn test() {\n+        S.method(); // -> u32\n+    }\n+}\n+\n+mod bar_test {\n+    use super::S;\n+    use super::bar::Trait2;\n+    fn test() {\n+        S.method(); // -> i128\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [63; 67) 'self': &Self\n+    [169; 173) 'self': &Self\n+    [300; 337) '{     ...     }': ()\n+    [310; 311) 'S': S\n+    [310; 320) 'S.method()': u32\n+    [416; 454) '{     ...     }': ()\n+    [426; 427) 'S': S\n+    [426; 436) 'S.method()': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_generic_1() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+fn test() {\n+    S.method();\n+}\n+\"#),\n+        @r###\"\n+    [33; 37) 'self': &Self\n+    [92; 111) '{     ...d(); }': ()\n+    [98; 99) 'S': S\n+    [98; 108) 'S.method()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_generic_more_params() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T1, T2, T3> {\n+    fn method1(&self) -> (T1, T2, T3);\n+    fn method2(&self) -> (T3, T2, T1);\n+}\n+struct S1;\n+impl Trait<u8, u16, u32> for S1 {}\n+struct S2;\n+impl<T> Trait<i8, i16, T> for S2 {}\n+fn test() {\n+    S1.method1(); // u8, u16, u32\n+    S1.method2(); // u32, u16, u8\n+    S2.method1(); // i8, i16, {unknown}\n+    S2.method2(); // {unknown}, i16, i8\n+}\n+\"#),\n+        @r###\"\n+    [43; 47) 'self': &Self\n+    [82; 86) 'self': &Self\n+    [210; 361) '{     ..., i8 }': ()\n+    [216; 218) 'S1': S1\n+    [216; 228) 'S1.method1()': (u8, u16, u32)\n+    [250; 252) 'S1': S1\n+    [250; 262) 'S1.method2()': (u32, u16, u8)\n+    [284; 286) 'S2': S2\n+    [284; 296) 'S2.method1()': (i8, i16, {unknown})\n+    [324; 326) 'S2': S2\n+    [324; 336) 'S2.method2()': ({unknown}, i16, i8)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_generic_2() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn test() {\n+    S(1u32).method();\n+}\n+\"#),\n+        @r###\"\n+    [33; 37) 'self': &Self\n+    [102; 127) '{     ...d(); }': ()\n+    [108; 109) 'S': S<u32>(T) -> S<T>\n+    [108; 115) 'S(1u32)': S<u32>\n+    [108; 124) 'S(1u32...thod()': u32\n+    [110; 114) '1u32': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Default {\n+    fn default() -> Self;\n+}\n+struct S;\n+impl Default for S {}\n+fn test() {\n+    let s1: S = Default::default();\n+    let s2 = S::default();\n+    let s3 = <S as Default>::default();\n+}\n+\"#),\n+        @r###\"\n+    [87; 193) '{     ...t(); }': ()\n+    [97; 99) 's1': S\n+    [105; 121) 'Defaul...efault': fn default<S>() -> Self\n+    [105; 123) 'Defaul...ault()': S\n+    [133; 135) 's2': S\n+    [138; 148) 'S::default': fn default<S>() -> Self\n+    [138; 150) 'S::default()': S\n+    [160; 162) 's3': S\n+    [165; 188) '<S as ...efault': fn default<S>() -> Self\n+    [165; 190) '<S as ...ault()': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> T;\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+struct G<T>;\n+impl<T> Trait<T> for G<T> {}\n+fn test() {\n+    let a = S::make();\n+    let b = G::<u64>::make();\n+    let c: f64 = G::make();\n+}\n+\"#),\n+        @r###\"\n+    [127; 211) '{     ...e(); }': ()\n+    [137; 138) 'a': u32\n+    [141; 148) 'S::make': fn make<S, u32>() -> T\n+    [141; 150) 'S::make()': u32\n+    [160; 161) 'b': u64\n+    [164; 178) 'G::<u64>::make': fn make<G<u64>, u64>() -> T\n+    [164; 180) 'G::<u6...make()': u64\n+    [190; 191) 'c': f64\n+    [199; 206) 'G::make': fn make<G<f64>, f64>() -> T\n+    [199; 208) 'G::make()': f64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make<U>() -> (T, U);\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+struct G<T>;\n+impl<T> Trait<T> for G<T> {}\n+fn test() {\n+    let a = S::make::<i64>();\n+    let b: (_, i64) = S::make();\n+    let c = G::<u32>::make::<i64>();\n+    let d: (u32, _) = G::make::<i64>();\n+    let e: (u32, i64) = G::make();\n+}\n+\"#),\n+        @r###\"\n+    [135; 313) '{     ...e(); }': ()\n+    [145; 146) 'a': (u32, i64)\n+    [149; 163) 'S::make::<i64>': fn make<S, u32, i64>() -> (T, U)\n+    [149; 165) 'S::mak...i64>()': (u32, i64)\n+    [175; 176) 'b': (u32, i64)\n+    [189; 196) 'S::make': fn make<S, u32, i64>() -> (T, U)\n+    [189; 198) 'S::make()': (u32, i64)\n+    [208; 209) 'c': (u32, i64)\n+    [212; 233) 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [212; 235) 'G::<u3...i64>()': (u32, i64)\n+    [245; 246) 'd': (u32, i64)\n+    [259; 273) 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [259; 275) 'G::mak...i64>()': (u32, i64)\n+    [285; 286) 'e': (u32, i64)\n+    [301; 308) 'G::make': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [301; 310) 'G::make()': (u32, i64)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_3() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> (Self, T);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<i32> {}\n+fn test() {\n+    let a = S::make();\n+}\n+\"#),\n+        @r###\"\n+    [101; 127) '{     ...e(); }': ()\n+    [111; 112) 'a': (S<i32>, i64)\n+    [115; 122) 'S::make': fn make<S<i32>, i64>() -> (Self, T)\n+    [115; 124) 'S::make()': (S<i32>, i64)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_4() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> (Self, T);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<u64> {}\n+impl Trait<i32> for S<u32> {}\n+fn test() {\n+    let a: (S<u64>, _) = S::make();\n+    let b: (_, i32) = S::make();\n+}\n+\"#),\n+        @r###\"\n+    [131; 203) '{     ...e(); }': ()\n+    [141; 142) 'a': (S<u64>, i64)\n+    [158; 165) 'S::make': fn make<S<u64>, i64>() -> (Self, T)\n+    [158; 167) 'S::make()': (S<u64>, i64)\n+    [177; 178) 'b': (S<u32>, i32)\n+    [191; 198) 'S::make': fn make<S<u32>, i32>() -> (Self, T)\n+    [191; 200) 'S::make()': (S<u32>, i32)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_5() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make<U>() -> (Self, T, U);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<u64> {}\n+fn test() {\n+    let a = <S as Trait<i64>>::make::<u8>();\n+    let b: (S<u64>, _, _) = Trait::<i64>::make::<u8>();\n+}\n+\"#),\n+        @r###\"\n+    [107; 211) '{     ...>(); }': ()\n+    [117; 118) 'a': (S<u64>, i64, u8)\n+    [121; 150) '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [121; 152) '<S as ...<u8>()': (S<u64>, i64, u8)\n+    [162; 163) 'b': (S<u64>, i64, u8)\n+    [182; 206) 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [182; 208) 'Trait:...<u8>()': (S<u64>, i64, u8)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_call_trait_method_on_generic_param_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {\n+    fn method(&self) -> u32;\n+}\n+fn test<T: Trait>(t: T) {\n+    t.method();\n+}\n+\"#),\n+        @r###\"\n+    [30; 34) 'self': &Self\n+    [64; 65) 't': T\n+    [70; 89) '{     ...d(); }': ()\n+    [76; 77) 't': T\n+    [76; 86) 't.method()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_call_trait_method_on_generic_param_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn method(&self) -> T;\n+}\n+fn test<U, T: Trait<U>>(t: T) {\n+    t.method();\n+}\n+\"#),\n+        @r###\"\n+    [33; 37) 'self': &Self\n+    [71; 72) 't': T\n+    [77; 96) '{     ...d(); }': ()\n+    [83; 84) 't': T\n+    [83; 93) 't.method()': [missing name]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_with_multiple_trait_impls() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Into<T> {\n+    fn into(self) -> T;\n+}\n+struct S;\n+impl Into<u32> for S {}\n+impl Into<u64> for S {}\n+fn test() {\n+    let x: u32 = S.into();\n+    let y: u64 = S.into();\n+    let z = Into::<u64>::into(S);\n+}\n+\"#),\n+        @r###\"\n+    [29; 33) 'self': Self\n+    [111; 202) '{     ...(S); }': ()\n+    [121; 122) 'x': u32\n+    [130; 131) 'S': S\n+    [130; 138) 'S.into()': u32\n+    [148; 149) 'y': u64\n+    [157; 158) 'S': S\n+    [157; 165) 'S.into()': u64\n+    [175; 176) 'z': u64\n+    [179; 196) 'Into::...::into': fn into<S, u64>(Self) -> T\n+    [179; 199) 'Into::...nto(S)': u64\n+    [197; 198) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn method_resolution_unify_impl_self_type() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S<T>;\n+impl S<u32> { fn foo(&self) -> u8 {} }\n+impl S<i32> { fn foo(&self) -> i8 {} }\n+fn test() { (S::<u32>.foo(), S::<i32>.foo())<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"(u8, i8)\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_before_autoref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(&self) -> i8 { 0 } }\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_by_value_before_autoref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone { fn clone(&self) -> Self; }\n+struct S;\n+impl Clone for S {}\n+impl Clone for &S {}\n+fn test() { (S.clone(), (&S).clone(), (&&S).clone())<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"(S, S, &S)\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_before_autoderef() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(self) -> i8 { 0 } }\n+impl Trait for &S { fn foo(self) -> u128 { 0 } }\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_impl_before_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(self) -> i8 { 0 } }\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i8\");\n+}\n+\n+#[test]\n+fn method_resolution_impl_ref_before_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(&self) -> i8 { 0 } }\n+impl Trait for &S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i8\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_autoderef() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_from_prelude() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:other_crate\n+struct S;\n+impl Clone for S {}\n+\n+fn test() {\n+    S.clone()<|>;\n+}\n+\n+//- /lib.rs crate:other_crate\n+#[prelude_import] use foo::*;\n+\n+mod foo {\n+    trait Clone {\n+        fn clone(&self) -> Self;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"S\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_for_unknown_trait() {\n+    // The blanket impl shouldn't apply because we can't even resolve UnknownTrait\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T> Trait for T where T: UnknownTrait {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_not_met() {\n+    // The blanket impl shouldn't apply because we can't prove S: Clone\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T> Trait for T where T: Clone {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    // This is also to make sure that we don't resolve to the foo method just\n+    // because that's the only method named foo we can find, which would make\n+    // the below tests not work\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_inline_not_met() {\n+    // The blanket impl shouldn't apply because we can't prove S: Clone\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T: Clone> Trait for T {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {}\n+impl<T> Trait for T where T: Clone {}\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Into<T> { fn into(self) -> T; }\n+trait From<T> { fn from(other: T) -> Self; }\n+struct S1;\n+struct S2;\n+impl From<S2> for S1 {}\n+impl<T, U> Into<U> for T where U: From<T> {}\n+fn test() { S2.into()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_inline() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Into<T> { fn into(self) -> T; }\n+trait From<T> { fn from(other: T) -> Self; }\n+struct S1;\n+struct S2;\n+impl From<S2> for S1 {}\n+impl<T, U: From<T>> Into<U> for T {}\n+fn test() { S2.into()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_encountering_fn_type() {\n+    type_at(\n+        r#\"\n+//- /main.rs\n+fn foo() {}\n+trait FnOnce { fn call(self); }\n+fn test() { foo.call()<|>; }\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn method_resolution_slow() {\n+    // this can get quite slow if we set the solver size limit too high\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait SendX {}\n+\n+struct S1; impl SendX for S1 {}\n+struct S2; impl SendX for S2 {}\n+struct U1;\n+\n+trait Trait { fn method(self); }\n+\n+struct X1<A, B> {}\n+impl<A, B> SendX for X1<A, B> where A: SendX, B: SendX {}\n+\n+struct S<B, C> {}\n+\n+trait FnX {}\n+\n+impl<B, C> Trait for S<B, C> where C: FnX, B: SendX {}\n+\n+fn test() { (S {}).method()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}"}, {"sha": "cb3890b42396ae018650d155329968e1180f1080", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=82fd86ac71ac09f336e161a9538ce83cdf53fc77", "patch": "@@ -0,0 +1,238 @@\n+use super::infer;\n+use insta::assert_snapshot;\n+use test_utils::covers;\n+\n+#[test]\n+fn infer_pattern() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(x: &i32) {\n+    let y = x;\n+    let &z = x;\n+    let a = z;\n+    let (c, d) = (1, \"hello\");\n+\n+    for (e, f) in some_iter {\n+        let g = e;\n+    }\n+\n+    if let [val] = opt {\n+        let h = val;\n+    }\n+\n+    let lambda = |a: u64, b, c: i32| { a + b; c };\n+\n+    let ref ref_to_x = x;\n+    let mut mut_x = x;\n+    let ref mut mut_ref_to_x = x;\n+    let k = mut_ref_to_x;\n+}\n+\"#),\n+        @r###\"\n+    [9; 10) 'x': &i32\n+    [18; 369) '{     ...o_x; }': ()\n+    [28; 29) 'y': &i32\n+    [32; 33) 'x': &i32\n+    [43; 45) '&z': &i32\n+    [44; 45) 'z': i32\n+    [48; 49) 'x': &i32\n+    [59; 60) 'a': i32\n+    [63; 64) 'z': i32\n+    [74; 80) '(c, d)': (i32, &str)\n+    [75; 76) 'c': i32\n+    [78; 79) 'd': &str\n+    [83; 95) '(1, \"hello\")': (i32, &str)\n+    [84; 85) '1': i32\n+    [87; 94) '\"hello\"': &str\n+    [102; 152) 'for (e...     }': ()\n+    [106; 112) '(e, f)': ({unknown}, {unknown})\n+    [107; 108) 'e': {unknown}\n+    [110; 111) 'f': {unknown}\n+    [116; 125) 'some_iter': {unknown}\n+    [126; 152) '{     ...     }': ()\n+    [140; 141) 'g': {unknown}\n+    [144; 145) 'e': {unknown}\n+    [158; 205) 'if let...     }': ()\n+    [165; 170) '[val]': {unknown}\n+    [173; 176) 'opt': {unknown}\n+    [177; 205) '{     ...     }': ()\n+    [191; 192) 'h': {unknown}\n+    [195; 198) 'val': {unknown}\n+    [215; 221) 'lambda': |u64, u64, i32| -> i32\n+    [224; 256) '|a: u6...b; c }': |u64, u64, i32| -> i32\n+    [225; 226) 'a': u64\n+    [233; 234) 'b': u64\n+    [236; 237) 'c': i32\n+    [244; 256) '{ a + b; c }': i32\n+    [246; 247) 'a': u64\n+    [246; 251) 'a + b': u64\n+    [250; 251) 'b': u64\n+    [253; 254) 'c': i32\n+    [267; 279) 'ref ref_to_x': &&i32\n+    [282; 283) 'x': &i32\n+    [293; 302) 'mut mut_x': &i32\n+    [305; 306) 'x': &i32\n+    [316; 336) 'ref mu...f_to_x': &mut &i32\n+    [339; 340) 'x': &i32\n+    [350; 351) 'k': &mut &i32\n+    [354; 366) 'mut_ref_to_x': &mut &i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_pattern_match_ergonomics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T>(T);\n+\n+fn test() {\n+    let A(n) = &A(1);\n+    let A(n) = &mut A(1);\n+}\n+\"#),\n+    @r###\"\n+    [28; 79) '{     ...(1); }': ()\n+    [38; 42) 'A(n)': A<i32>\n+    [40; 41) 'n': &i32\n+    [45; 50) '&A(1)': &A<i32>\n+    [46; 47) 'A': A<i32>(T) -> A<T>\n+    [46; 50) 'A(1)': A<i32>\n+    [48; 49) '1': i32\n+    [60; 64) 'A(n)': A<i32>\n+    [62; 63) 'n': &mut i32\n+    [67; 76) '&mut A(1)': &mut A<i32>\n+    [72; 73) 'A': A<i32>(T) -> A<T>\n+    [72; 76) 'A(1)': A<i32>\n+    [74; 75) '1': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_pattern_match_ergonomics_ref() {\n+    covers!(match_ergonomics_ref);\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let v = &(1, &2);\n+    let (_, &w) = v;\n+}\n+\"#),\n+    @r###\"\n+    [11; 57) '{     ...= v; }': ()\n+    [21; 22) 'v': &(i32, &i32)\n+    [25; 33) '&(1, &2)': &(i32, &i32)\n+    [26; 33) '(1, &2)': (i32, &i32)\n+    [27; 28) '1': i32\n+    [30; 32) '&2': &i32\n+    [31; 32) '2': i32\n+    [43; 50) '(_, &w)': (i32, &i32)\n+    [44; 45) '_': i32\n+    [47; 49) '&w': &i32\n+    [48; 49) 'w': i32\n+    [53; 54) 'v': &(i32, &i32)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_adt_pattern() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum E {\n+    A { x: usize },\n+    B\n+}\n+\n+struct S(u32, E);\n+\n+fn test() {\n+    let e = E::A { x: 3 };\n+\n+    let S(y, z) = foo;\n+    let E::A { x: new_var } = e;\n+\n+    match e {\n+        E::A { x } => x,\n+        E::B if foo => 1,\n+        E::B => 10,\n+    };\n+\n+    let ref d @ E::A { .. } = e;\n+    d;\n+}\n+\"#),\n+        @r###\"\n+    [68; 289) '{     ...  d; }': ()\n+    [78; 79) 'e': E\n+    [82; 95) 'E::A { x: 3 }': E\n+    [92; 93) '3': usize\n+    [106; 113) 'S(y, z)': S\n+    [108; 109) 'y': u32\n+    [111; 112) 'z': E\n+    [116; 119) 'foo': S\n+    [129; 148) 'E::A {..._var }': E\n+    [139; 146) 'new_var': usize\n+    [151; 152) 'e': E\n+    [159; 245) 'match ...     }': usize\n+    [165; 166) 'e': E\n+    [177; 187) 'E::A { x }': E\n+    [184; 185) 'x': usize\n+    [191; 192) 'x': usize\n+    [202; 206) 'E::B': E\n+    [210; 213) 'foo': bool\n+    [217; 218) '1': usize\n+    [228; 232) 'E::B': E\n+    [236; 238) '10': usize\n+    [256; 275) 'ref d ...{ .. }': &E\n+    [264; 275) 'E::A { .. }': E\n+    [278; 279) 'e': E\n+    [285; 286) 'd': &E\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_generics_in_patterns() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T> {\n+    x: T,\n+}\n+\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+fn test(a1: A<u32>, o: Option<u64>) {\n+    let A { x: x2 } = a1;\n+    let A::<i64> { x: x3 } = A { x: 1 };\n+    match o {\n+        Option::Some(t) => t,\n+        _ => 1,\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [79; 81) 'a1': A<u32>\n+    [91; 92) 'o': Option<u64>\n+    [107; 244) '{     ...  }; }': ()\n+    [117; 128) 'A { x: x2 }': A<u32>\n+    [124; 126) 'x2': u32\n+    [131; 133) 'a1': A<u32>\n+    [143; 161) 'A::<i6...: x3 }': A<i64>\n+    [157; 159) 'x3': i64\n+    [164; 174) 'A { x: 1 }': A<i64>\n+    [171; 172) '1': i64\n+    [180; 241) 'match ...     }': u64\n+    [186; 187) 'o': Option<u64>\n+    [198; 213) 'Option::Some(t)': Option<u64>\n+    [211; 212) 't': u64\n+    [217; 218) 't': u64\n+    [228; 229) '_': Option<u64>\n+    [233; 234) '1': u64\n+    \"###\n+    );\n+}"}, {"sha": "09d684ac2af58e3e4244c66b86d4bf11d1df8ff8", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=82fd86ac71ac09f336e161a9538ce83cdf53fc77", "patch": "@@ -0,0 +1,333 @@\n+use super::infer;\n+use insta::assert_snapshot;\n+use test_utils::covers;\n+\n+#[test]\n+fn bug_484() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+   let x = if true {};\n+}\n+\"#),\n+        @r###\"\n+    [11; 37) '{    l... {}; }': ()\n+    [20; 21) 'x': ()\n+    [24; 34) 'if true {}': ()\n+    [27; 31) 'true': bool\n+    [32; 34) '{}': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn no_panic_on_field_of_enum() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum X {}\n+\n+fn test(x: X) {\n+    x.some_field;\n+}\n+\"#),\n+        @r###\"\n+    [20; 21) 'x': X\n+    [26; 47) '{     ...eld; }': ()\n+    [32; 33) 'x': X\n+    [32; 44) 'x.some_field': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn bug_585() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    X {};\n+    match x {\n+        A::B {} => (),\n+        A::Y() => (),\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [11; 89) '{     ...   } }': ()\n+    [17; 21) 'X {}': {unknown}\n+    [27; 87) 'match ...     }': ()\n+    [33; 34) 'x': {unknown}\n+    [45; 52) 'A::B {}': {unknown}\n+    [56; 58) '()': ()\n+    [68; 74) 'A::Y()': {unknown}\n+    [78; 80) '()': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn bug_651() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn quux() {\n+    let y = 92;\n+    1 + y;\n+}\n+\"#),\n+        @r###\"\n+    [11; 41) '{     ...+ y; }': ()\n+    [21; 22) 'y': i32\n+    [25; 27) '92': i32\n+    [33; 34) '1': i32\n+    [33; 38) '1 + y': i32\n+    [37; 38) 'y': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn recursive_vars() {\n+    covers!(type_var_cycles_resolve_completely);\n+    covers!(type_var_cycles_resolve_as_possible);\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let y = unknown;\n+    [y, &y];\n+}\n+\"#),\n+        @r###\"\n+    [11; 48) '{     ...&y]; }': ()\n+    [21; 22) 'y': &{unknown}\n+    [25; 32) 'unknown': &{unknown}\n+    [38; 45) '[y, &y]': [&&{unknown};_]\n+    [39; 40) 'y': &{unknown}\n+    [42; 44) '&y': &&{unknown}\n+    [43; 44) 'y': &{unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn recursive_vars_2() {\n+    covers!(type_var_cycles_resolve_completely);\n+    covers!(type_var_cycles_resolve_as_possible);\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let x = unknown;\n+    let y = unknown;\n+    [(x, y), (&y, &x)];\n+}\n+\"#),\n+        @r###\"\n+    [11; 80) '{     ...x)]; }': ()\n+    [21; 22) 'x': &&{unknown}\n+    [25; 32) 'unknown': &&{unknown}\n+    [42; 43) 'y': &&{unknown}\n+    [46; 53) 'unknown': &&{unknown}\n+    [59; 77) '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown});_]\n+    [60; 66) '(x, y)': (&&&{unknown}, &&&{unknown})\n+    [61; 62) 'x': &&{unknown}\n+    [64; 65) 'y': &&{unknown}\n+    [68; 76) '(&y, &x)': (&&&{unknown}, &&&{unknown})\n+    [69; 71) '&y': &&&{unknown}\n+    [70; 71) 'y': &&{unknown}\n+    [73; 75) '&x': &&&{unknown}\n+    [74; 75) 'x': &&{unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_1() {\n+    // caused stack overflow, taken from std\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Maybe<T> {\n+    Real(T),\n+    Fake,\n+}\n+\n+fn write() {\n+    match something_unknown {\n+        Maybe::Real(ref mut something) => (),\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [54; 139) '{     ...   } }': ()\n+    [60; 137) 'match ...     }': ()\n+    [66; 83) 'someth...nknown': Maybe<{unknown}>\n+    [94; 124) 'Maybe:...thing)': Maybe<{unknown}>\n+    [106; 123) 'ref mu...ething': &mut {unknown}\n+    [128; 130) '()': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_2() {\n+    covers!(type_var_resolves_to_int_var);\n+    // caused \"equating two type variables, ...\", taken from std\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test_line_buffer() {\n+    &[0, b'\\n', 1, b'\\n'];\n+}\n+\"#),\n+        @r###\"\n+    [23; 53) '{     ...n']; }': ()\n+    [29; 50) '&[0, b...b'\\n']': &[u8;_]\n+    [30; 50) '[0, b'...b'\\n']': [u8;_]\n+    [31; 32) '0': u8\n+    [34; 39) 'b'\\n'': u8\n+    [41; 42) '1': u8\n+    [44; 49) 'b'\\n'': u8\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_3() {\n+    // taken from rustc\n+    assert_snapshot!(\n+        infer(r#\"\n+pub fn compute() {\n+    match nope!() {\n+        SizeSkeleton::Pointer { non_zero: true, tail } => {}\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [18; 108) '{     ...   } }': ()\n+    [24; 106) 'match ...     }': ()\n+    [30; 37) 'nope!()': {unknown}\n+    [48; 94) 'SizeSk...tail }': {unknown}\n+    [82; 86) 'true': {unknown}\n+    [88; 92) 'tail': {unknown}\n+    [98; 100) '{}': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_4() {\n+    // taken from rustc\n+    assert_snapshot!(\n+        infer(r#\"\n+pub fn primitive_type() {\n+    match *self {\n+        BorrowedRef { type_: Primitive(p), ..} => {},\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [25; 106) '{     ...   } }': ()\n+    [31; 104) 'match ...     }': ()\n+    [37; 42) '*self': {unknown}\n+    [38; 42) 'self': {unknown}\n+    [53; 91) 'Borrow...), ..}': {unknown}\n+    [74; 86) 'Primitive(p)': {unknown}\n+    [84; 85) 'p': {unknown}\n+    [95; 97) '{}': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_std_crash_5() {\n+    // taken from rustc\n+    assert_snapshot!(\n+        infer(r#\"\n+fn extra_compiler_flags() {\n+    for content in doesnt_matter {\n+        let name = if doesnt_matter {\n+            first\n+        } else {\n+            &content\n+        };\n+\n+        let content = if ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.contains(&name) {\n+            name\n+        } else {\n+            content\n+        };\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [27; 323) '{     ...   } }': ()\n+    [33; 321) 'for co...     }': ()\n+    [37; 44) 'content': &{unknown}\n+    [48; 61) 'doesnt_matter': {unknown}\n+    [62; 321) '{     ...     }': ()\n+    [76; 80) 'name': &&{unknown}\n+    [83; 167) 'if doe...     }': &&{unknown}\n+    [86; 99) 'doesnt_matter': bool\n+    [100; 129) '{     ...     }': &&{unknown}\n+    [114; 119) 'first': &&{unknown}\n+    [135; 167) '{     ...     }': &&{unknown}\n+    [149; 157) '&content': &&{unknown}\n+    [150; 157) 'content': &{unknown}\n+    [182; 189) 'content': &{unknown}\n+    [192; 314) 'if ICE...     }': &{unknown}\n+    [195; 232) 'ICE_RE..._VALUE': {unknown}\n+    [195; 248) 'ICE_RE...&name)': bool\n+    [242; 247) '&name': &&&{unknown}\n+    [243; 247) 'name': &&{unknown}\n+    [249; 277) '{     ...     }': &&{unknown}\n+    [263; 267) 'name': &&{unknown}\n+    [283; 314) '{     ...     }': &{unknown}\n+    [297; 304) 'content': &{unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_nested_generics_crash() {\n+    // another crash found typechecking rustc\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Canonical<V> {\n+    value: V,\n+}\n+struct QueryResponse<V> {\n+    value: V,\n+}\n+fn test<R>(query_response: Canonical<QueryResponse<R>>) {\n+    &query_response.value;\n+}\n+\"#),\n+        @r###\"\n+    [92; 106) 'query_response': Canonical<QueryResponse<R>>\n+    [137; 167) '{     ...lue; }': ()\n+    [143; 164) '&query....value': &QueryResponse<R>\n+    [144; 158) 'query_response': Canonical<QueryResponse<R>>\n+    [144; 164) 'query_....value': QueryResponse<R>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn bug_1030() {\n+    assert_snapshot!(infer(r#\"\n+struct HashSet<T, H>;\n+struct FxHasher;\n+type FxHashSet<T> = HashSet<T, FxHasher>;\n+\n+impl<T, H> HashSet<T, H> {\n+    fn default() -> HashSet<T, H> {}\n+}\n+\n+pub fn main_loop() {\n+    FxHashSet::default();\n+}\n+\"#),\n+    @r###\"\n+    [144; 146) '{}': ()\n+    [169; 198) '{     ...t(); }': ()\n+    [175; 193) 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<T, H>\n+    [175; 195) 'FxHash...ault()': HashSet<{unknown}, FxHasher>\n+    \"###\n+    );\n+}"}, {"sha": "18976c9aee23eb2f979d3e48c068fe3196710296", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "added", "additions": 1608, "deletions": 0, "changes": 1608, "blob_url": "https://github.com/rust-lang/rust/blob/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=82fd86ac71ac09f336e161a9538ce83cdf53fc77", "patch": "@@ -0,0 +1,1608 @@\n+use super::{infer, type_at, type_at_pos};\n+use crate::test_db::TestDB;\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn infer_box() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+fn test() {\n+    let x = box 1;\n+    let t = (x, box x, box &1, box [1]);\n+    t<|>;\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use prelude::*;\n+mod prelude {}\n+\n+mod boxed {\n+    pub struct Box<T: ?Sized> {\n+        inner: *mut T,\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"(Box<i32>, Box<Box<i32>>, Box<&i32>, Box<[i32;_]>)\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_adt_self() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs\n+enum Nat { Succ(Self), Demo(Nat), Zero }\n+\n+fn test() {\n+    let foo: Nat = Nat::Zero;\n+    if let Nat::Succ(x) = foo {\n+        x<|>\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"Nat\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_ranges() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn test() {\n+    let a = ..;\n+    let b = 1..;\n+    let c = ..2u32;\n+    let d = 1..2usize;\n+    let e = ..=10;\n+    let f = 'a'..='z';\n+\n+    let t = (a, b, c, d, e, f);\n+    t<|>;\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use prelude::*;\n+mod prelude {}\n+\n+pub mod ops {\n+    pub struct Range<Idx> {\n+        pub start: Idx,\n+        pub end: Idx,\n+    }\n+    pub struct RangeFrom<Idx> {\n+        pub start: Idx,\n+    }\n+    struct RangeFull;\n+    pub struct RangeInclusive<Idx> {\n+        start: Idx,\n+        end: Idx,\n+        is_empty: u8,\n+    }\n+    pub struct RangeTo<Idx> {\n+        pub end: Idx,\n+    }\n+    pub struct RangeToInclusive<Idx> {\n+        pub end: Idx,\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\n+        \"(RangeFull, RangeFrom<i32>, RangeTo<u32>, Range<usize>, RangeToInclusive<i32>, RangeInclusive<char>)\",\n+        type_at_pos(&db, pos),\n+    );\n+}\n+\n+#[test]\n+fn infer_while_let() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { Some(T), None }\n+\n+fn test() {\n+    let foo: Option<f32> = None;\n+    while let Option::Some(x) = foo {\n+        <|>x\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"f32\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_basics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(a: u32, b: isize, c: !, d: &str) {\n+    a;\n+    b;\n+    c;\n+    d;\n+    1usize;\n+    1isize;\n+    \"test\";\n+    1.0f32;\n+}\"#),\n+        @r###\"\n+    [9; 10) 'a': u32\n+    [17; 18) 'b': isize\n+    [27; 28) 'c': !\n+    [33; 34) 'd': &str\n+    [42; 121) '{     ...f32; }': !\n+    [48; 49) 'a': u32\n+    [55; 56) 'b': isize\n+    [62; 63) 'c': !\n+    [69; 70) 'd': &str\n+    [76; 82) '1usize': usize\n+    [88; 94) '1isize': isize\n+    [100; 106) '\"test\"': &str\n+    [112; 118) '1.0f32': f32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_let() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let a = 1isize;\n+    let b: usize = 1;\n+    let c = b;\n+    let d: u32;\n+    let e;\n+    let f: i32 = e;\n+}\n+\"#),\n+        @r###\"\n+    [11; 118) '{     ...= e; }': ()\n+    [21; 22) 'a': isize\n+    [25; 31) '1isize': isize\n+    [41; 42) 'b': usize\n+    [52; 53) '1': usize\n+    [63; 64) 'c': usize\n+    [67; 68) 'b': usize\n+    [78; 79) 'd': u32\n+    [94; 95) 'e': i32\n+    [105; 106) 'f': i32\n+    [114; 115) 'e': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_paths() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn a() -> u32 { 1 }\n+\n+mod b {\n+    fn c() -> u32 { 1 }\n+}\n+\n+fn test() {\n+    a();\n+    b::c();\n+}\n+\"#),\n+        @r###\"\n+    [15; 20) '{ 1 }': u32\n+    [17; 18) '1': u32\n+    [48; 53) '{ 1 }': u32\n+    [50; 51) '1': u32\n+    [67; 91) '{     ...c(); }': ()\n+    [73; 74) 'a': fn a() -> u32\n+    [73; 76) 'a()': u32\n+    [82; 86) 'b::c': fn c() -> u32\n+    [82; 88) 'b::c()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_path_type() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+\n+impl S {\n+    fn foo() -> i32 { 1 }\n+}\n+\n+fn test() {\n+    S::foo();\n+    <S>::foo();\n+}\n+\"#),\n+        @r###\"\n+    [41; 46) '{ 1 }': i32\n+    [43; 44) '1': i32\n+    [60; 93) '{     ...o(); }': ()\n+    [66; 72) 'S::foo': fn foo() -> i32\n+    [66; 74) 'S::foo()': i32\n+    [80; 88) '<S>::foo': fn foo() -> i32\n+    [80; 90) '<S>::foo()': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_struct() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A {\n+    b: B,\n+    c: C,\n+}\n+struct B;\n+struct C(usize);\n+\n+fn test() {\n+    let c = C(1);\n+    B;\n+    let a: A = A { b: B, c: C(1) };\n+    a.b;\n+    a.c;\n+}\n+\"#),\n+        @r###\"\n+    [72; 154) '{     ...a.c; }': ()\n+    [82; 83) 'c': C\n+    [86; 87) 'C': C(usize) -> C\n+    [86; 90) 'C(1)': C\n+    [88; 89) '1': usize\n+    [96; 97) 'B': B\n+    [107; 108) 'a': A\n+    [114; 133) 'A { b:...C(1) }': A\n+    [121; 122) 'B': B\n+    [127; 128) 'C': C(usize) -> C\n+    [127; 131) 'C(1)': C\n+    [129; 130) '1': usize\n+    [139; 140) 'a': A\n+    [139; 142) 'a.b': B\n+    [148; 149) 'a': A\n+    [148; 151) 'a.c': C\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_enum() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum E {\n+  V1 { field: u32 },\n+  V2\n+}\n+fn test() {\n+  E::V1 { field: 1 };\n+  E::V2;\n+}\"#),\n+        @r###\"\n+    [48; 82) '{   E:...:V2; }': ()\n+    [52; 70) 'E::V1 ...d: 1 }': E\n+    [67; 68) '1': u32\n+    [74; 79) 'E::V2': E\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_refs() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n+    a;\n+    *a;\n+    &a;\n+    &mut a;\n+    b;\n+    *b;\n+    &b;\n+    c;\n+    *c;\n+    d;\n+    *d;\n+}\n+\"#),\n+        @r###\"\n+    [9; 10) 'a': &u32\n+    [18; 19) 'b': &mut u32\n+    [31; 32) 'c': *const u32\n+    [46; 47) 'd': *mut u32\n+    [59; 150) '{     ... *d; }': ()\n+    [65; 66) 'a': &u32\n+    [72; 74) '*a': u32\n+    [73; 74) 'a': &u32\n+    [80; 82) '&a': &&u32\n+    [81; 82) 'a': &u32\n+    [88; 94) '&mut a': &mut &u32\n+    [93; 94) 'a': &u32\n+    [100; 101) 'b': &mut u32\n+    [107; 109) '*b': u32\n+    [108; 109) 'b': &mut u32\n+    [115; 117) '&b': &&mut u32\n+    [116; 117) 'b': &mut u32\n+    [123; 124) 'c': *const u32\n+    [130; 132) '*c': u32\n+    [131; 132) 'c': *const u32\n+    [138; 139) 'd': *mut u32\n+    [145; 147) '*d': u32\n+    [146; 147) 'd': *mut u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_literals() {\n+    assert_snapshot!(\n+        infer(r##\"\n+fn test() {\n+    5i32;\n+    5f32;\n+    5f64;\n+    \"hello\";\n+    b\"bytes\";\n+    'c';\n+    b'b';\n+    3.14;\n+    5000;\n+    false;\n+    true;\n+    r#\"\n+        //! doc\n+        // non-doc\n+        mod foo {}\n+        \"#;\n+    br#\"yolo\"#;\n+}\n+\"##),\n+        @r###\"\n+    [11; 221) '{     ...o\"#; }': ()\n+    [17; 21) '5i32': i32\n+    [27; 31) '5f32': f32\n+    [37; 41) '5f64': f64\n+    [47; 54) '\"hello\"': &str\n+    [60; 68) 'b\"bytes\"': &[u8]\n+    [74; 77) ''c'': char\n+    [83; 87) 'b'b'': u8\n+    [93; 97) '3.14': f64\n+    [103; 107) '5000': i32\n+    [113; 118) 'false': bool\n+    [124; 128) 'true': bool\n+    [134; 202) 'r#\"   ...    \"#': &str\n+    [208; 218) 'br#\"yolo\"#': &[u8]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_unary_op() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum SomeType {}\n+\n+fn test(x: SomeType) {\n+    let b = false;\n+    let c = !b;\n+    let a = 100;\n+    let d: i128 = -a;\n+    let e = -100;\n+    let f = !!!true;\n+    let g = !42;\n+    let h = !10u32;\n+    let j = !a;\n+    -3.14;\n+    !3;\n+    -x;\n+    !x;\n+    -\"hello\";\n+    !\"hello\";\n+}\n+\"#),\n+        @r###\"\n+    [27; 28) 'x': SomeType\n+    [40; 272) '{     ...lo\"; }': ()\n+    [50; 51) 'b': bool\n+    [54; 59) 'false': bool\n+    [69; 70) 'c': bool\n+    [73; 75) '!b': bool\n+    [74; 75) 'b': bool\n+    [85; 86) 'a': i128\n+    [89; 92) '100': i128\n+    [102; 103) 'd': i128\n+    [112; 114) '-a': i128\n+    [113; 114) 'a': i128\n+    [124; 125) 'e': i32\n+    [128; 132) '-100': i32\n+    [129; 132) '100': i32\n+    [142; 143) 'f': bool\n+    [146; 153) '!!!true': bool\n+    [147; 153) '!!true': bool\n+    [148; 153) '!true': bool\n+    [149; 153) 'true': bool\n+    [163; 164) 'g': i32\n+    [167; 170) '!42': i32\n+    [168; 170) '42': i32\n+    [180; 181) 'h': u32\n+    [184; 190) '!10u32': u32\n+    [185; 190) '10u32': u32\n+    [200; 201) 'j': i128\n+    [204; 206) '!a': i128\n+    [205; 206) 'a': i128\n+    [212; 217) '-3.14': f64\n+    [213; 217) '3.14': f64\n+    [223; 225) '!3': i32\n+    [224; 225) '3': i32\n+    [231; 233) '-x': {unknown}\n+    [232; 233) 'x': SomeType\n+    [239; 241) '!x': {unknown}\n+    [240; 241) 'x': SomeType\n+    [247; 255) '-\"hello\"': {unknown}\n+    [248; 255) '\"hello\"': &str\n+    [261; 269) '!\"hello\"': {unknown}\n+    [262; 269) '\"hello\"': &str\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_backwards() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn takes_u32(x: u32) {}\n+\n+struct S { i32_field: i32 }\n+\n+fn test() -> &mut &f64 {\n+    let a = unknown_function();\n+    takes_u32(a);\n+    let b = unknown_function();\n+    S { i32_field: b };\n+    let c = unknown_function();\n+    &mut &c\n+}\n+\"#),\n+        @r###\"\n+    [14; 15) 'x': u32\n+    [22; 24) '{}': ()\n+    [78; 231) '{     ...t &c }': &mut &f64\n+    [88; 89) 'a': u32\n+    [92; 108) 'unknow...nction': {unknown}\n+    [92; 110) 'unknow...tion()': u32\n+    [116; 125) 'takes_u32': fn takes_u32(u32) -> ()\n+    [116; 128) 'takes_u32(a)': ()\n+    [126; 127) 'a': u32\n+    [138; 139) 'b': i32\n+    [142; 158) 'unknow...nction': {unknown}\n+    [142; 160) 'unknow...tion()': i32\n+    [166; 184) 'S { i3...d: b }': S\n+    [181; 182) 'b': i32\n+    [194; 195) 'c': f64\n+    [198; 214) 'unknow...nction': {unknown}\n+    [198; 216) 'unknow...tion()': f64\n+    [222; 229) '&mut &c': &mut &f64\n+    [227; 229) '&c': &f64\n+    [228; 229) 'c': f64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_self() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+\n+impl S {\n+    fn test(&self) {\n+        self;\n+    }\n+    fn test2(self: &Self) {\n+        self;\n+    }\n+    fn test3() -> Self {\n+        S {}\n+    }\n+    fn test4() -> Self {\n+        Self {}\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [34; 38) 'self': &S\n+    [40; 61) '{     ...     }': ()\n+    [50; 54) 'self': &S\n+    [75; 79) 'self': &S\n+    [88; 109) '{     ...     }': ()\n+    [98; 102) 'self': &S\n+    [133; 153) '{     ...     }': S\n+    [143; 147) 'S {}': S\n+    [177; 200) '{     ...     }': S\n+    [187; 194) 'Self {}': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_binary_op() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn f(x: bool) -> i32 {\n+    0i32\n+}\n+\n+fn test() -> bool {\n+    let x = a && b;\n+    let y = true || false;\n+    let z = x == y;\n+    let t = x != y;\n+    let minus_forty: isize = -40isize;\n+    let h = minus_forty <= CONST_2;\n+    let c = f(z || y) + 5;\n+    let d = b;\n+    let g = minus_forty ^= i;\n+    let ten: usize = 10;\n+    let ten_is_eleven = ten == some_num;\n+\n+    ten < 3\n+}\n+\"#),\n+        @r###\"\n+    [6; 7) 'x': bool\n+    [22; 34) '{     0i32 }': i32\n+    [28; 32) '0i32': i32\n+    [54; 370) '{     ... < 3 }': bool\n+    [64; 65) 'x': bool\n+    [68; 69) 'a': bool\n+    [68; 74) 'a && b': bool\n+    [73; 74) 'b': bool\n+    [84; 85) 'y': bool\n+    [88; 92) 'true': bool\n+    [88; 101) 'true || false': bool\n+    [96; 101) 'false': bool\n+    [111; 112) 'z': bool\n+    [115; 116) 'x': bool\n+    [115; 121) 'x == y': bool\n+    [120; 121) 'y': bool\n+    [131; 132) 't': bool\n+    [135; 136) 'x': bool\n+    [135; 141) 'x != y': bool\n+    [140; 141) 'y': bool\n+    [151; 162) 'minus_forty': isize\n+    [172; 180) '-40isize': isize\n+    [173; 180) '40isize': isize\n+    [190; 191) 'h': bool\n+    [194; 205) 'minus_forty': isize\n+    [194; 216) 'minus_...ONST_2': bool\n+    [209; 216) 'CONST_2': isize\n+    [226; 227) 'c': i32\n+    [230; 231) 'f': fn f(bool) -> i32\n+    [230; 239) 'f(z || y)': i32\n+    [230; 243) 'f(z || y) + 5': i32\n+    [232; 233) 'z': bool\n+    [232; 238) 'z || y': bool\n+    [237; 238) 'y': bool\n+    [242; 243) '5': i32\n+    [253; 254) 'd': {unknown}\n+    [257; 258) 'b': {unknown}\n+    [268; 269) 'g': ()\n+    [272; 283) 'minus_forty': isize\n+    [272; 288) 'minus_...y ^= i': ()\n+    [287; 288) 'i': isize\n+    [298; 301) 'ten': usize\n+    [311; 313) '10': usize\n+    [323; 336) 'ten_is_eleven': bool\n+    [339; 342) 'ten': usize\n+    [339; 354) 'ten == some_num': bool\n+    [346; 354) 'some_num': usize\n+    [361; 364) 'ten': usize\n+    [361; 368) 'ten < 3': bool\n+    [367; 368) '3': usize\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_field_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A {\n+    b: B,\n+}\n+struct B;\n+\n+fn test1(a: A) {\n+    let a1 = a;\n+    a1.b;\n+    let a2 = &a;\n+    a2.b;\n+    let a3 = &mut a;\n+    a3.b;\n+    let a4 = &&&&&&&a;\n+    a4.b;\n+    let a5 = &mut &&mut &&mut a;\n+    a5.b;\n+}\n+\n+fn test2(a1: *const A, a2: *mut A) {\n+    a1.b;\n+    a2.b;\n+}\n+\"#),\n+        @r###\"\n+    [44; 45) 'a': A\n+    [50; 213) '{     ...5.b; }': ()\n+    [60; 62) 'a1': A\n+    [65; 66) 'a': A\n+    [72; 74) 'a1': A\n+    [72; 76) 'a1.b': B\n+    [86; 88) 'a2': &A\n+    [91; 93) '&a': &A\n+    [92; 93) 'a': A\n+    [99; 101) 'a2': &A\n+    [99; 103) 'a2.b': B\n+    [113; 115) 'a3': &mut A\n+    [118; 124) '&mut a': &mut A\n+    [123; 124) 'a': A\n+    [130; 132) 'a3': &mut A\n+    [130; 134) 'a3.b': B\n+    [144; 146) 'a4': &&&&&&&A\n+    [149; 157) '&&&&&&&a': &&&&&&&A\n+    [150; 157) '&&&&&&a': &&&&&&A\n+    [151; 157) '&&&&&a': &&&&&A\n+    [152; 157) '&&&&a': &&&&A\n+    [153; 157) '&&&a': &&&A\n+    [154; 157) '&&a': &&A\n+    [155; 157) '&a': &A\n+    [156; 157) 'a': A\n+    [163; 165) 'a4': &&&&&&&A\n+    [163; 167) 'a4.b': B\n+    [177; 179) 'a5': &mut &&mut &&mut A\n+    [182; 200) '&mut &...&mut a': &mut &&mut &&mut A\n+    [187; 200) '&&mut &&mut a': &&mut &&mut A\n+    [188; 200) '&mut &&mut a': &mut &&mut A\n+    [193; 200) '&&mut a': &&mut A\n+    [194; 200) '&mut a': &mut A\n+    [199; 200) 'a': A\n+    [206; 208) 'a5': &mut &&mut &&mut A\n+    [206; 210) 'a5.b': B\n+    [224; 226) 'a1': *const A\n+    [238; 240) 'a2': *mut A\n+    [250; 273) '{     ...2.b; }': ()\n+    [256; 258) 'a1': *const A\n+    [256; 260) 'a1.b': B\n+    [266; 268) 'a2': *mut A\n+    [266; 270) 'a2.b': B\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_argument_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct A<T>(T);\n+\n+impl<T> A<T> {\n+    fn foo(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+struct B<T>(T);\n+\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn test() {\n+    let t = A::foo(&&B(B(A(42))));\n+}\n+\"#),\n+        @r###\"\n+    [68; 72) 'self': &Self\n+    [139; 143) 'self': &A<T>\n+    [151; 174) '{     ...     }': &T\n+    [161; 168) '&self.0': &T\n+    [162; 166) 'self': &A<T>\n+    [162; 168) 'self.0': T\n+    [255; 259) 'self': &B<T>\n+    [278; 301) '{     ...     }': &T\n+    [288; 295) '&self.0': &T\n+    [289; 293) 'self': &B<T>\n+    [289; 295) 'self.0': T\n+    [315; 353) '{     ...))); }': ()\n+    [325; 326) 't': &i32\n+    [329; 335) 'A::foo': fn foo<i32>(&A<T>) -> &T\n+    [329; 350) 'A::foo...42))))': &i32\n+    [336; 349) '&&B(B(A(42)))': &&B<B<A<i32>>>\n+    [337; 349) '&B(B(A(42)))': &B<B<A<i32>>>\n+    [338; 339) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [338; 349) 'B(B(A(42)))': B<B<A<i32>>>\n+    [340; 341) 'B': B<A<i32>>(T) -> B<T>\n+    [340; 348) 'B(A(42))': B<A<i32>>\n+    [342; 343) 'A': A<i32>(T) -> A<T>\n+    [342; 347) 'A(42)': A<i32>\n+    [344; 346) '42': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_method_argument_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct A<T>(*mut T);\n+\n+impl<T> A<T> {\n+    fn foo(&self, x: &A<T>) -> &T {\n+        &*x.0\n+    }\n+}\n+\n+struct B<T>(T);\n+\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn test(a: A<i32>) {\n+    let t = A(0 as *mut _).foo(&&B(B(a)));\n+}\n+\"#),\n+        @r###\"\n+    [68; 72) 'self': &Self\n+    [144; 148) 'self': &A<T>\n+    [150; 151) 'x': &A<T>\n+    [166; 187) '{     ...     }': &T\n+    [176; 181) '&*x.0': &T\n+    [177; 181) '*x.0': T\n+    [178; 179) 'x': &A<T>\n+    [178; 181) 'x.0': *mut T\n+    [268; 272) 'self': &B<T>\n+    [291; 314) '{     ...     }': &T\n+    [301; 308) '&self.0': &T\n+    [302; 306) 'self': &B<T>\n+    [302; 308) 'self.0': T\n+    [326; 327) 'a': A<i32>\n+    [337; 383) '{     ...))); }': ()\n+    [347; 348) 't': &i32\n+    [351; 352) 'A': A<i32>(*mut T) -> A<T>\n+    [351; 365) 'A(0 as *mut _)': A<i32>\n+    [351; 380) 'A(0 as...B(a)))': &i32\n+    [353; 354) '0': i32\n+    [353; 364) '0 as *mut _': *mut i32\n+    [370; 379) '&&B(B(a))': &&B<B<A<i32>>>\n+    [371; 379) '&B(B(a))': &B<B<A<i32>>>\n+    [372; 373) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [372; 379) 'B(B(a))': B<B<A<i32>>>\n+    [374; 375) 'B': B<A<i32>>(T) -> B<T>\n+    [374; 378) 'B(a)': B<A<i32>>\n+    [376; 377) 'a': A<i32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_in_elseif() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo { field: i32 }\n+fn main(foo: Foo) {\n+    if true {\n+\n+    } else if false {\n+        foo.field\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [35; 38) 'foo': Foo\n+    [45; 109) '{     ...   } }': ()\n+    [51; 107) 'if tru...     }': ()\n+    [54; 58) 'true': bool\n+    [59; 67) '{      }': ()\n+    [73; 107) 'if fal...     }': ()\n+    [76; 81) 'false': bool\n+    [82; 107) '{     ...     }': i32\n+    [92; 95) 'foo': Foo\n+    [92; 101) 'foo.field': i32\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn infer_if_match_with_return() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo() {\n+    let _x1 = if true {\n+        1\n+    } else {\n+        return;\n+    };\n+    let _x2 = if true {\n+        2\n+    } else {\n+        return\n+    };\n+    let _x3 = match true {\n+        true => 3,\n+        _ => {\n+            return;\n+        }\n+    };\n+    let _x4 = match true {\n+        true => 4,\n+        _ => return\n+    };\n+}\"#),\n+        @r###\"\n+    [10; 323) '{     ...  }; }': ()\n+    [20; 23) '_x1': i32\n+    [26; 80) 'if tru...     }': i32\n+    [29; 33) 'true': bool\n+    [34; 51) '{     ...     }': i32\n+    [44; 45) '1': i32\n+    [57; 80) '{     ...     }': !\n+    [67; 73) 'return': !\n+    [90; 93) '_x2': i32\n+    [96; 149) 'if tru...     }': i32\n+    [99; 103) 'true': bool\n+    [104; 121) '{     ...     }': i32\n+    [114; 115) '2': i32\n+    [127; 149) '{     ...     }': !\n+    [137; 143) 'return': !\n+    [159; 162) '_x3': i32\n+    [165; 247) 'match ...     }': i32\n+    [171; 175) 'true': bool\n+    [186; 190) 'true': bool\n+    [194; 195) '3': i32\n+    [205; 206) '_': bool\n+    [210; 241) '{     ...     }': !\n+    [224; 230) 'return': !\n+    [257; 260) '_x4': i32\n+    [263; 320) 'match ...     }': i32\n+    [269; 273) 'true': bool\n+    [284; 288) 'true': bool\n+    [292; 293) '4': i32\n+    [303; 304) '_': bool\n+    [308; 314) 'return': !\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn infer_inherent_method() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A;\n+\n+impl A {\n+    fn foo(self, x: u32) -> i32 {}\n+}\n+\n+mod b {\n+    impl super::A {\n+        fn bar(&self, x: u64) -> i64 {}\n+    }\n+}\n+\n+fn test(a: A) {\n+    a.foo(1);\n+    (&a).bar(1);\n+    a.bar(1);\n+}\n+\"#),\n+        @r###\"\n+    [32; 36) 'self': A\n+    [38; 39) 'x': u32\n+    [53; 55) '{}': ()\n+    [103; 107) 'self': &A\n+    [109; 110) 'x': u64\n+    [124; 126) '{}': ()\n+    [144; 145) 'a': A\n+    [150; 198) '{     ...(1); }': ()\n+    [156; 157) 'a': A\n+    [156; 164) 'a.foo(1)': i32\n+    [162; 163) '1': u32\n+    [170; 181) '(&a).bar(1)': i64\n+    [171; 173) '&a': &A\n+    [172; 173) 'a': A\n+    [179; 180) '1': u64\n+    [187; 188) 'a': A\n+    [187; 195) 'a.bar(1)': i64\n+    [193; 194) '1': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_inherent_method_str() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"str\"]\n+impl str {\n+    fn foo(&self) -> i32 {}\n+}\n+\n+fn test() {\n+    \"foo\".foo();\n+}\n+\"#),\n+        @r###\"\n+    [40; 44) 'self': &str\n+    [53; 55) '{}': ()\n+    [69; 89) '{     ...o(); }': ()\n+    [75; 80) '\"foo\"': &str\n+    [75; 86) '\"foo\".foo()': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_tuple() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(x: &str, y: isize) {\n+    let a: (u32, &str) = (1, \"a\");\n+    let b = (a, x);\n+    let c = (y, x);\n+    let d = (c, x);\n+    let e = (1, \"e\");\n+    let f = (e, \"d\");\n+}\n+\"#),\n+        @r###\"\n+    [9; 10) 'x': &str\n+    [18; 19) 'y': isize\n+    [28; 170) '{     ...d\"); }': ()\n+    [38; 39) 'a': (u32, &str)\n+    [55; 63) '(1, \"a\")': (u32, &str)\n+    [56; 57) '1': u32\n+    [59; 62) '\"a\"': &str\n+    [73; 74) 'b': ((u32, &str), &str)\n+    [77; 83) '(a, x)': ((u32, &str), &str)\n+    [78; 79) 'a': (u32, &str)\n+    [81; 82) 'x': &str\n+    [93; 94) 'c': (isize, &str)\n+    [97; 103) '(y, x)': (isize, &str)\n+    [98; 99) 'y': isize\n+    [101; 102) 'x': &str\n+    [113; 114) 'd': ((isize, &str), &str)\n+    [117; 123) '(c, x)': ((isize, &str), &str)\n+    [118; 119) 'c': (isize, &str)\n+    [121; 122) 'x': &str\n+    [133; 134) 'e': (i32, &str)\n+    [137; 145) '(1, \"e\")': (i32, &str)\n+    [138; 139) '1': i32\n+    [141; 144) '\"e\"': &str\n+    [155; 156) 'f': ((i32, &str), &str)\n+    [159; 167) '(e, \"d\")': ((i32, &str), &str)\n+    [160; 161) 'e': (i32, &str)\n+    [163; 166) '\"d\"': &str\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_array() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(x: &str, y: isize) {\n+    let a = [x];\n+    let b = [a, a];\n+    let c = [b, b];\n+\n+    let d = [y, 1, 2, 3];\n+    let d = [1, y, 2, 3];\n+    let e = [y];\n+    let f = [d, d];\n+    let g = [e, e];\n+\n+    let h = [1, 2];\n+    let i = [\"a\", \"b\"];\n+\n+    let b = [a, [\"b\"]];\n+    let x: [u8; 0] = [];\n+}\n+\"#),\n+        @r###\"\n+    [9; 10) 'x': &str\n+    [18; 19) 'y': isize\n+    [28; 293) '{     ... []; }': ()\n+    [38; 39) 'a': [&str;_]\n+    [42; 45) '[x]': [&str;_]\n+    [43; 44) 'x': &str\n+    [55; 56) 'b': [[&str;_];_]\n+    [59; 65) '[a, a]': [[&str;_];_]\n+    [60; 61) 'a': [&str;_]\n+    [63; 64) 'a': [&str;_]\n+    [75; 76) 'c': [[[&str;_];_];_]\n+    [79; 85) '[b, b]': [[[&str;_];_];_]\n+    [80; 81) 'b': [[&str;_];_]\n+    [83; 84) 'b': [[&str;_];_]\n+    [96; 97) 'd': [isize;_]\n+    [100; 112) '[y, 1, 2, 3]': [isize;_]\n+    [101; 102) 'y': isize\n+    [104; 105) '1': isize\n+    [107; 108) '2': isize\n+    [110; 111) '3': isize\n+    [122; 123) 'd': [isize;_]\n+    [126; 138) '[1, y, 2, 3]': [isize;_]\n+    [127; 128) '1': isize\n+    [130; 131) 'y': isize\n+    [133; 134) '2': isize\n+    [136; 137) '3': isize\n+    [148; 149) 'e': [isize;_]\n+    [152; 155) '[y]': [isize;_]\n+    [153; 154) 'y': isize\n+    [165; 166) 'f': [[isize;_];_]\n+    [169; 175) '[d, d]': [[isize;_];_]\n+    [170; 171) 'd': [isize;_]\n+    [173; 174) 'd': [isize;_]\n+    [185; 186) 'g': [[isize;_];_]\n+    [189; 195) '[e, e]': [[isize;_];_]\n+    [190; 191) 'e': [isize;_]\n+    [193; 194) 'e': [isize;_]\n+    [206; 207) 'h': [i32;_]\n+    [210; 216) '[1, 2]': [i32;_]\n+    [211; 212) '1': i32\n+    [214; 215) '2': i32\n+    [226; 227) 'i': [&str;_]\n+    [230; 240) '[\"a\", \"b\"]': [&str;_]\n+    [231; 234) '\"a\"': &str\n+    [236; 239) '\"b\"': &str\n+    [251; 252) 'b': [[&str;_];_]\n+    [255; 265) '[a, [\"b\"]]': [[&str;_];_]\n+    [256; 257) 'a': [&str;_]\n+    [259; 264) '[\"b\"]': [&str;_]\n+    [260; 263) '\"b\"': &str\n+    [275; 276) 'x': [u8;_]\n+    [288; 290) '[]': [u8;_]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_struct_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T> {\n+    x: T,\n+}\n+\n+fn test(a1: A<u32>, i: i32) {\n+    a1.x;\n+    let a2 = A { x: i };\n+    a2.x;\n+    let a3 = A::<i128> { x: 1 };\n+    a3.x;\n+}\n+\"#),\n+        @r###\"\n+    [36; 38) 'a1': A<u32>\n+    [48; 49) 'i': i32\n+    [56; 147) '{     ...3.x; }': ()\n+    [62; 64) 'a1': A<u32>\n+    [62; 66) 'a1.x': u32\n+    [76; 78) 'a2': A<i32>\n+    [81; 91) 'A { x: i }': A<i32>\n+    [88; 89) 'i': i32\n+    [97; 99) 'a2': A<i32>\n+    [97; 101) 'a2.x': i32\n+    [111; 113) 'a3': A<i128>\n+    [116; 134) 'A::<i1...x: 1 }': A<i128>\n+    [131; 132) '1': i128\n+    [140; 142) 'a3': A<i128>\n+    [140; 144) 'a3.x': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_tuple_struct_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T>(T);\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    A(42);\n+    A(42u128);\n+    Some(\"x\");\n+    Option::Some(\"x\");\n+    None;\n+    let x: Option<i64> = None;\n+}\n+\"#),\n+        @r###\"\n+    [76; 184) '{     ...one; }': ()\n+    [82; 83) 'A': A<i32>(T) -> A<T>\n+    [82; 87) 'A(42)': A<i32>\n+    [84; 86) '42': i32\n+    [93; 94) 'A': A<u128>(T) -> A<T>\n+    [93; 102) 'A(42u128)': A<u128>\n+    [95; 101) '42u128': u128\n+    [108; 112) 'Some': Some<&str>(T) -> Option<T>\n+    [108; 117) 'Some(\"x\")': Option<&str>\n+    [113; 116) '\"x\"': &str\n+    [123; 135) 'Option::Some': Some<&str>(T) -> Option<T>\n+    [123; 140) 'Option...e(\"x\")': Option<&str>\n+    [136; 139) '\"x\"': &str\n+    [146; 150) 'None': Option<{unknown}>\n+    [160; 161) 'x': Option<i64>\n+    [177; 181) 'None': Option<i64>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_function_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn id<T>(t: T) -> T { t }\n+\n+fn test() {\n+    id(1u32);\n+    id::<i128>(1);\n+    let x: u64 = id(1);\n+}\n+\"#),\n+        @r###\"\n+    [10; 11) 't': T\n+    [21; 26) '{ t }': T\n+    [23; 24) 't': T\n+    [38; 98) '{     ...(1); }': ()\n+    [44; 46) 'id': fn id<u32>(T) -> T\n+    [44; 52) 'id(1u32)': u32\n+    [47; 51) '1u32': u32\n+    [58; 68) 'id::<i128>': fn id<i128>(T) -> T\n+    [58; 71) 'id::<i128>(1)': i128\n+    [69; 70) '1': i128\n+    [81; 82) 'x': u64\n+    [90; 92) 'id': fn id<u64>(T) -> T\n+    [90; 95) 'id(1)': u64\n+    [93; 94) '1': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_impl_generics() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+impl<Y, X> A<X, Y> {\n+    fn x(self) -> X {\n+        self.x\n+    }\n+    fn y(self) -> Y {\n+        self.y\n+    }\n+    fn z<T>(self, t: T) -> (X, Y, T) {\n+        (self.x, self.y, t)\n+    }\n+}\n+\n+fn test() -> i128 {\n+    let a = A { x: 1u64, y: 1i64 };\n+    a.x();\n+    a.y();\n+    a.z(1i128);\n+    a.z::<u128>(1);\n+}\n+\"#),\n+        @r###\"\n+    [74; 78) 'self': A<X, Y>\n+    [85; 107) '{     ...     }': X\n+    [95; 99) 'self': A<X, Y>\n+    [95; 101) 'self.x': X\n+    [117; 121) 'self': A<X, Y>\n+    [128; 150) '{     ...     }': Y\n+    [138; 142) 'self': A<X, Y>\n+    [138; 144) 'self.y': Y\n+    [163; 167) 'self': A<X, Y>\n+    [169; 170) 't': T\n+    [188; 223) '{     ...     }': (X, Y, T)\n+    [198; 217) '(self.....y, t)': (X, Y, T)\n+    [199; 203) 'self': A<X, Y>\n+    [199; 205) 'self.x': X\n+    [207; 211) 'self': A<X, Y>\n+    [207; 213) 'self.y': Y\n+    [215; 216) 't': T\n+    [245; 342) '{     ...(1); }': ()\n+    [255; 256) 'a': A<u64, i64>\n+    [259; 281) 'A { x:...1i64 }': A<u64, i64>\n+    [266; 270) '1u64': u64\n+    [275; 279) '1i64': i64\n+    [287; 288) 'a': A<u64, i64>\n+    [287; 292) 'a.x()': u64\n+    [298; 299) 'a': A<u64, i64>\n+    [298; 303) 'a.y()': i64\n+    [309; 310) 'a': A<u64, i64>\n+    [309; 319) 'a.z(1i128)': (u64, i64, i128)\n+    [313; 318) '1i128': i128\n+    [325; 326) 'a': A<u64, i64>\n+    [325; 339) 'a.z::<u128>(1)': (u64, i64, u128)\n+    [337; 338) '1': u128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_impl_generics_with_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+impl<T> Option<T> {\n+    fn as_ref(&self) -> Option<&T> {}\n+}\n+fn test(o: Option<u32>) {\n+    (&o).as_ref();\n+    o.as_ref();\n+}\n+\"#),\n+        @r###\"\n+    [78; 82) 'self': &Option<T>\n+    [98; 100) '{}': ()\n+    [111; 112) 'o': Option<u32>\n+    [127; 165) '{     ...f(); }': ()\n+    [133; 146) '(&o).as_ref()': Option<&u32>\n+    [134; 136) '&o': &Option<u32>\n+    [135; 136) 'o': Option<u32>\n+    [152; 153) 'o': Option<u32>\n+    [152; 162) 'o.as_ref()': Option<&u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_generic_chain() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T> {\n+    x: T,\n+}\n+impl<T2> A<T2> {\n+    fn x(self) -> T2 {\n+        self.x\n+    }\n+}\n+fn id<T>(t: T) -> T { t }\n+\n+fn test() -> i128 {\n+     let x = 1;\n+     let y = id(x);\n+     let a = A { x: id(y) };\n+     let z = id(a.x);\n+     let b = A { x: z };\n+     b.x()\n+}\n+\"#),\n+        @r###\"\n+    [53; 57) 'self': A<T2>\n+    [65; 87) '{     ...     }': T2\n+    [75; 79) 'self': A<T2>\n+    [75; 81) 'self.x': T2\n+    [99; 100) 't': T\n+    [110; 115) '{ t }': T\n+    [112; 113) 't': T\n+    [135; 261) '{     ....x() }': i128\n+    [146; 147) 'x': i128\n+    [150; 151) '1': i128\n+    [162; 163) 'y': i128\n+    [166; 168) 'id': fn id<i128>(T) -> T\n+    [166; 171) 'id(x)': i128\n+    [169; 170) 'x': i128\n+    [182; 183) 'a': A<i128>\n+    [186; 200) 'A { x: id(y) }': A<i128>\n+    [193; 195) 'id': fn id<i128>(T) -> T\n+    [193; 198) 'id(y)': i128\n+    [196; 197) 'y': i128\n+    [211; 212) 'z': i128\n+    [215; 217) 'id': fn id<i128>(T) -> T\n+    [215; 222) 'id(a.x)': i128\n+    [218; 219) 'a': A<i128>\n+    [218; 221) 'a.x': i128\n+    [233; 234) 'b': A<i128>\n+    [237; 247) 'A { x: z }': A<i128>\n+    [244; 245) 'z': i128\n+    [254; 255) 'b': A<i128>\n+    [254; 259) 'b.x()': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_const() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Struct;\n+\n+impl Struct {\n+    const FOO: u32 = 1;\n+}\n+\n+enum Enum {}\n+\n+impl Enum {\n+    const BAR: u32 = 2;\n+}\n+\n+trait Trait {\n+    const ID: u32;\n+}\n+\n+struct TraitTest;\n+\n+impl Trait for TraitTest {\n+    const ID: u32 = 5;\n+}\n+\n+fn test() {\n+    let x = Struct::FOO;\n+    let y = Enum::BAR;\n+    let z = TraitTest::ID;\n+}\n+\"#),\n+        @r###\"\n+    [52; 53) '1': u32\n+    [105; 106) '2': u32\n+    [213; 214) '5': u32\n+    [229; 307) '{     ...:ID; }': ()\n+    [239; 240) 'x': u32\n+    [243; 254) 'Struct::FOO': u32\n+    [264; 265) 'y': u32\n+    [268; 277) 'Enum::BAR': u32\n+    [287; 288) 'z': u32\n+    [291; 304) 'TraitTest::ID': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_type_alias() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<X, Y> { x: X, y: Y }\n+type Foo = A<u32, i128>;\n+type Bar<T> = A<T, u128>;\n+type Baz<U, V> = A<V, U>;\n+fn test(x: Foo, y: Bar<&str>, z: Baz<i8, u8>) {\n+    x.x;\n+    x.y;\n+    y.x;\n+    y.y;\n+    z.x;\n+    z.y;\n+}\n+\"#),\n+        @r###\"\n+    [116; 117) 'x': A<u32, i128>\n+    [124; 125) 'y': A<&str, u128>\n+    [138; 139) 'z': A<u8, i8>\n+    [154; 211) '{     ...z.y; }': ()\n+    [160; 161) 'x': A<u32, i128>\n+    [160; 163) 'x.x': u32\n+    [169; 170) 'x': A<u32, i128>\n+    [169; 172) 'x.y': i128\n+    [178; 179) 'y': A<&str, u128>\n+    [178; 181) 'y.x': &str\n+    [187; 188) 'y': A<&str, u128>\n+    [187; 190) 'y.y': u128\n+    [196; 197) 'z': A<u8, i8>\n+    [196; 199) 'z.x': u8\n+    [205; 206) 'z': A<u8, i8>\n+    [205; 208) 'z.y': i8\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn recursive_type_alias() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<X> {}\n+type Foo = Foo;\n+type Bar = A<Bar>;\n+fn test(x: Foo) {}\n+\"#),\n+        @r###\"\n+    [59; 60) 'x': {unknown}\n+    [67; 69) '{}': ()\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn infer_type_param() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn id<T>(x: T) -> T {\n+    x\n+}\n+\n+fn clone<T>(x: &T) -> T {\n+    *x\n+}\n+\n+fn test() {\n+    let y = 10u32;\n+    id(y);\n+    let x: bool = clone(z);\n+    id::<i128>(1);\n+}\n+\"#),\n+        @r###\"\n+    [10; 11) 'x': T\n+    [21; 30) '{     x }': T\n+    [27; 28) 'x': T\n+    [44; 45) 'x': &T\n+    [56; 66) '{     *x }': T\n+    [62; 64) '*x': T\n+    [63; 64) 'x': &T\n+    [78; 158) '{     ...(1); }': ()\n+    [88; 89) 'y': u32\n+    [92; 97) '10u32': u32\n+    [103; 105) 'id': fn id<u32>(T) -> T\n+    [103; 108) 'id(y)': u32\n+    [106; 107) 'y': u32\n+    [118; 119) 'x': bool\n+    [128; 133) 'clone': fn clone<bool>(&T) -> T\n+    [128; 136) 'clone(z)': bool\n+    [134; 135) 'z': &bool\n+    [142; 152) 'id::<i128>': fn id<i128>(T) -> T\n+    [142; 155) 'id::<i128>(1)': i128\n+    [153; 154) '1': i128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_const() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Foo;\n+impl Foo { const ASSOC_CONST: u32 = 0; }\n+const GLOBAL_CONST: u32 = 101;\n+fn test() {\n+    const LOCAL_CONST: u32 = 99;\n+    let x = LOCAL_CONST;\n+    let z = GLOBAL_CONST;\n+    let id = Foo::ASSOC_CONST;\n+}\n+\"#),\n+        @r###\"\n+    [49; 50) '0': u32\n+    [80; 83) '101': u32\n+    [95; 213) '{     ...NST; }': ()\n+    [138; 139) 'x': {unknown}\n+    [142; 153) 'LOCAL_CONST': {unknown}\n+    [163; 164) 'z': u32\n+    [167; 179) 'GLOBAL_CONST': u32\n+    [189; 191) 'id': u32\n+    [194; 210) 'Foo::A..._CONST': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_static() {\n+    assert_snapshot!(\n+        infer(r#\"\n+static GLOBAL_STATIC: u32 = 101;\n+static mut GLOBAL_STATIC_MUT: u32 = 101;\n+fn test() {\n+    static LOCAL_STATIC: u32 = 99;\n+    static mut LOCAL_STATIC_MUT: u32 = 99;\n+    let x = LOCAL_STATIC;\n+    let y = LOCAL_STATIC_MUT;\n+    let z = GLOBAL_STATIC;\n+    let w = GLOBAL_STATIC_MUT;\n+}\n+\"#),\n+        @r###\"\n+    [29; 32) '101': u32\n+    [70; 73) '101': u32\n+    [85; 280) '{     ...MUT; }': ()\n+    [173; 174) 'x': {unknown}\n+    [177; 189) 'LOCAL_STATIC': {unknown}\n+    [199; 200) 'y': {unknown}\n+    [203; 219) 'LOCAL_...IC_MUT': {unknown}\n+    [229; 230) 'z': u32\n+    [233; 246) 'GLOBAL_STATIC': u32\n+    [256; 257) 'w': u32\n+    [260; 277) 'GLOBAL...IC_MUT': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn shadowing_primitive() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct i32;\n+struct Foo;\n+\n+impl i32 { fn foo(&self) -> Foo { Foo } }\n+\n+fn main() {\n+    let x: i32 = i32;\n+    x.foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"Foo\");\n+}\n+\n+#[test]\n+fn not_shadowing_primitive_by_module() {\n+    let t = type_at(\n+        r#\"\n+//- /str.rs\n+fn foo() {}\n+\n+//- /main.rs\n+mod str;\n+fn foo() -> &'static str { \"\" }\n+\n+fn main() {\n+    foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"&str\");\n+}\n+\n+#[test]\n+fn not_shadowing_module_by_primitive() {\n+    let t = type_at(\n+        r#\"\n+//- /str.rs\n+fn foo() -> u32 {0}\n+\n+//- /main.rs\n+mod str;\n+fn foo() -> &'static str { \"\" }\n+\n+fn main() {\n+    str::foo()<|>;\n+}\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}"}, {"sha": "93c5f9a15a377bff9c987f841b55d65f88245e47", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "added", "additions": 1424, "deletions": 0, "changes": 1424, "blob_url": "https://github.com/rust-lang/rust/blob/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fd86ac71ac09f336e161a9538ce83cdf53fc77/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=82fd86ac71ac09f336e161a9538ce83cdf53fc77", "patch": "@@ -0,0 +1,1424 @@\n+use super::{infer, type_at, type_at_pos};\n+use crate::test_db::TestDB;\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn infer_await() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct IntFuture;\n+\n+impl Future for IntFuture {\n+    type Output = u64;\n+}\n+\n+fn test() {\n+    let r = IntFuture;\n+    let v = r.await;\n+    v<|>;\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use future::*;\n+mod future {\n+    trait Future {\n+        type Output;\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"u64\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_try() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+fn test() {\n+    let r: Result<i32, u64> = Result::Ok(1);\n+    let v = r?;\n+    v<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    trait Try {\n+        type Ok;\n+        type Error;\n+    }\n+}\n+\n+#[prelude_import] use result::*;\n+mod result {\n+    enum Result<O, E> {\n+        Ok(O),\n+        Err(E)\n+    }\n+\n+    impl<O, E> crate::ops::Try for Result<O, E> {\n+        type Ok = O;\n+        type Error = E;\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"i32\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_for_loop() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+use std::collections::Vec;\n+\n+fn test() {\n+    let v = Vec::new();\n+    v.push(\"foo\");\n+    for x in v {\n+        x<|>;\n+    }\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use iter::*;\n+mod iter {\n+    trait IntoIterator {\n+        type Item;\n+    }\n+}\n+\n+mod collections {\n+    struct Vec<T> {}\n+    impl<T> Vec<T> {\n+        fn new() -> Self { Vec {} }\n+        fn push(&mut self, t: T) { }\n+    }\n+\n+    impl<T> crate::iter::IntoIterator for Vec<T> {\n+        type Item=T;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"&str\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_from_bound_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn foo<T: Trait<u32>>(t: T) {}\n+fn test() {\n+    let s = S(unknown);\n+    foo(s);\n+}\n+\"#),\n+        @r###\"\n+    [86; 87) 't': T\n+    [92; 94) '{}': ()\n+    [105; 144) '{     ...(s); }': ()\n+    [115; 116) 's': S<u32>\n+    [119; 120) 'S': S<u32>(T) -> S<T>\n+    [119; 129) 'S(unknown)': S<u32>\n+    [121; 128) 'unknown': u32\n+    [135; 138) 'foo': fn foo<S<u32>>(T) -> ()\n+    [135; 141) 'foo(s)': ()\n+    [139; 140) 's': S<u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_from_bound_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {}\n+struct S<T>(T);\n+impl<U> Trait<U> for S<U> {}\n+fn foo<U, T: Trait<U>>(t: T) -> U {}\n+fn test() {\n+    let s = S(unknown);\n+    let x: u32 = foo(s);\n+}\n+\"#),\n+        @r###\"\n+    [87; 88) 't': T\n+    [98; 100) '{}': ()\n+    [111; 163) '{     ...(s); }': ()\n+    [121; 122) 's': S<u32>\n+    [125; 126) 'S': S<u32>(T) -> S<T>\n+    [125; 135) 'S(unknown)': S<u32>\n+    [127; 134) 'unknown': u32\n+    [145; 146) 'x': u32\n+    [154; 157) 'foo': fn foo<u32, S<u32>>(T) -> U\n+    [154; 160) 'foo(s)': u32\n+    [158; 159) 's': S<u32>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_project_associated_type() {\n+    // y, z, a don't yet work because of https://github.com/rust-lang/chalk/issues/234\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Iterable {\n+   type Item;\n+}\n+struct S;\n+impl Iterable for S { type Item = u32; }\n+fn test<T: Iterable>() {\n+    let x: <S as Iterable>::Item = 1;\n+    let y: <T as Iterable>::Item = no_matter;\n+    let z: T::Item = no_matter;\n+    let a: <T>::Item = no_matter;\n+}\n+\"#),\n+        @r###\"\n+    [108; 261) '{     ...ter; }': ()\n+    [118; 119) 'x': u32\n+    [145; 146) '1': u32\n+    [156; 157) 'y': {unknown}\n+    [183; 192) 'no_matter': {unknown}\n+    [202; 203) 'z': {unknown}\n+    [215; 224) 'no_matter': {unknown}\n+    [234; 235) 'a': {unknown}\n+    [249; 258) 'no_matter': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_return_associated_type() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Iterable {\n+   type Item;\n+}\n+struct S;\n+impl Iterable for S { type Item = u32; }\n+fn foo1<T: Iterable>(t: T) -> T::Item {}\n+fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item {}\n+fn foo3<T: Iterable>(t: T) -> <T>::Item {}\n+fn test() {\n+    let x = foo1(S);\n+    let y = foo2(S);\n+    let z = foo3(S);\n+}\n+\"#),\n+        @r###\"\n+    [106; 107) 't': T\n+    [123; 125) '{}': ()\n+    [147; 148) 't': T\n+    [178; 180) '{}': ()\n+    [202; 203) 't': T\n+    [221; 223) '{}': ()\n+    [234; 300) '{     ...(S); }': ()\n+    [244; 245) 'x': u32\n+    [248; 252) 'foo1': fn foo1<S>(T) -> <T as Iterable>::Item\n+    [248; 255) 'foo1(S)': u32\n+    [253; 254) 'S': S\n+    [265; 266) 'y': u32\n+    [269; 273) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n+    [269; 276) 'foo2(S)': u32\n+    [274; 275) 'S': S\n+    [286; 287) 'z': u32\n+    [290; 294) 'foo3': fn foo3<S>(T) -> <T as Iterable>::Item\n+    [290; 297) 'foo3(S)': u32\n+    [295; 296) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_type_bound() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Iterable {\n+   type Item;\n+}\n+fn test<T: Iterable<Item=u32>>() {\n+    let y: T::Item = unknown;\n+}\n+\"#),\n+        @r###\"\n+    [67; 100) '{     ...own; }': ()\n+    [77; 78) 'y': {unknown}\n+    [90; 97) 'unknown': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_const_body() {\n+    assert_snapshot!(\n+        infer(r#\"\n+const A: u32 = 1 + 1;\n+static B: u64 = { let x = 1; x };\n+\"#),\n+        @r###\"\n+    [16; 17) '1': u32\n+    [16; 21) '1 + 1': u32\n+    [20; 21) '1': u32\n+    [39; 55) '{ let ...1; x }': u64\n+    [45; 46) 'x': u64\n+    [49; 50) '1': u64\n+    [52; 53) 'x': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn tuple_struct_fields() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S(i32, u64);\n+fn test() -> u64 {\n+    let a = S(4, 6);\n+    let b = a.0;\n+    a.1\n+}\n+\"#),\n+        @r###\"\n+    [38; 87) '{     ... a.1 }': u64\n+    [48; 49) 'a': S\n+    [52; 53) 'S': S(i32, u64) -> S\n+    [52; 59) 'S(4, 6)': S\n+    [54; 55) '4': i32\n+    [57; 58) '6': u64\n+    [69; 70) 'b': i32\n+    [73; 74) 'a': S\n+    [73; 76) 'a.0': i32\n+    [82; 83) 'a': S\n+    [82; 85) 'a.1': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn tuple_struct_with_fn() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S(fn(u32) -> u64);\n+fn test() -> u64 {\n+    let a = S(|i| 2*i);\n+    let b = a.0(4);\n+    a.0(2)\n+}\n+\"#),\n+        @r###\"\n+    [44; 102) '{     ...0(2) }': u64\n+    [54; 55) 'a': S\n+    [58; 59) 'S': S(fn(u32) -> u64) -> S\n+    [58; 68) 'S(|i| 2*i)': S\n+    [60; 67) '|i| 2*i': |i32| -> i32\n+    [61; 62) 'i': i32\n+    [64; 65) '2': i32\n+    [64; 67) '2*i': i32\n+    [66; 67) 'i': i32\n+    [78; 79) 'b': u64\n+    [82; 83) 'a': S\n+    [82; 85) 'a.0': fn(u32) -> u64\n+    [82; 88) 'a.0(4)': u64\n+    [86; 87) '4': u32\n+    [94; 95) 'a': S\n+    [94; 97) 'a.0': fn(u32) -> u64\n+    [94; 100) 'a.0(2)': u64\n+    [98; 99) '2': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn indexing_arrays() {\n+    assert_snapshot!(\n+        infer(\"fn main() { &mut [9][2]; }\"),\n+        @r###\"\n+    [10; 26) '{ &mut...[2]; }': ()\n+    [12; 23) '&mut [9][2]': &mut {unknown}\n+    [17; 20) '[9]': [i32;_]\n+    [17; 23) '[9][2]': {unknown}\n+    [18; 19) '9': i32\n+    [21; 22) '2': i32\n+    \"###\n+    )\n+}\n+\n+#[test]\n+fn deref_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct Arc<T>;\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+}\n+\n+struct S;\n+impl S {\n+    fn foo(&self) -> u128 {}\n+}\n+\n+fn test(s: Arc<S>) {\n+    (*s, s.foo())<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"(S, u128)\");\n+}\n+\n+#[test]\n+fn deref_trait_with_inference_var() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct Arc<T>;\n+fn new_arc<T>() -> Arc<T> {}\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+}\n+\n+struct S;\n+fn foo(a: Arc<S>) {}\n+\n+fn test() {\n+    let a = new_arc();\n+    let b = (*a)<|>;\n+    foo(a);\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"S\");\n+}\n+\n+#[test]\n+fn deref_trait_infinite_recursion() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct S;\n+\n+impl Deref for S {\n+    type Target = S;\n+}\n+\n+fn test(s: S) {\n+    s.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn deref_trait_with_question_mark_size() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct Arc<T>;\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+}\n+\n+struct S;\n+impl S {\n+    fn foo(&self) -> u128 {}\n+}\n+\n+fn test(s: Arc<S>) {\n+    (*s, s.foo())<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"(S, u128)\");\n+}\n+\n+#[test]\n+fn obligation_from_function_clause() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S;\n+\n+trait Trait<T> {}\n+impl Trait<u32> for S {}\n+\n+fn foo<T: Trait<U>, U>(t: T) -> U {}\n+\n+fn test(s: S) {\n+    foo(s)<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn obligation_from_method_clause() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S;\n+\n+trait Trait<T> {}\n+impl Trait<isize> for S {}\n+\n+struct O;\n+impl O {\n+    fn foo<T: Trait<U>, U>(&self, t: T) -> U {}\n+}\n+\n+fn test() {\n+    O.foo(S)<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"isize\");\n+}\n+\n+#[test]\n+fn obligation_from_self_method_clause() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S;\n+\n+trait Trait<T> {}\n+impl Trait<i64> for S {}\n+\n+impl S {\n+    fn foo<U>(&self) -> U where Self: Trait<U> {}\n+}\n+\n+fn test() {\n+    S.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"i64\");\n+}\n+\n+#[test]\n+fn obligation_from_impl_clause() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct S;\n+\n+trait Trait<T> {}\n+impl Trait<&str> for S {}\n+\n+struct O<T>;\n+impl<U, T: Trait<U>> O<T> {\n+    fn foo(&self) -> U {}\n+}\n+\n+fn test(o: O<S>) {\n+    o.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"&str\");\n+}\n+\n+#[test]\n+fn generic_param_env_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {}\n+impl<T> Trait for T where T: Clone {}\n+fn test<T: Clone>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn generic_param_env_1_not_met() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {}\n+impl<T> Trait for T where T: Clone {}\n+fn test<T>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn generic_param_env_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S {}\n+fn test<T: Trait>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn generic_param_env_2_not_met() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S {}\n+fn test<T>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn generic_param_env_deref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+}\n+trait Trait {}\n+impl<T> Deref for T where T: Trait {\n+    type Target = i128;\n+}\n+fn test<T: Trait>(t: T) { (*t)<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i128\");\n+}\n+\n+#[test]\n+fn associated_type_placeholder() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait ApplyL {\n+    type Out;\n+}\n+\n+pub struct RefMutL<T>;\n+\n+impl<T> ApplyL for RefMutL<T> {\n+    type Out = <T as ApplyL>::Out;\n+}\n+\n+fn test<T: ApplyL>() {\n+    let y: <RefMutL<T> as ApplyL>::Out = no_matter;\n+    y<|>;\n+}\n+\"#,\n+    );\n+    // inside the generic function, the associated type gets normalized to a placeholder `ApplL::Out<T>` [https://rust-lang.github.io/rustc-guide/traits/associated-types.html#placeholder-associated-types].\n+    // FIXME: fix type parameter names going missing when going through Chalk\n+    assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+}\n+\n+#[test]\n+fn associated_type_placeholder_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait ApplyL {\n+    type Out;\n+}\n+fn foo<T: ApplyL>(t: T) -> <T as ApplyL>::Out;\n+\n+fn test<T: ApplyL>(t: T) {\n+    let y = foo(t);\n+    y<|>;\n+}\n+\"#,\n+    );\n+    // FIXME here Chalk doesn't normalize the type to a placeholder. I think we\n+    // need to add a rule like Normalize(<T as ApplyL>::Out -> ApplyL::Out<T>)\n+    // to the trait env ourselves here; probably Chalk can't do this by itself.\n+    // assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn impl_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar() -> impl Trait<u64> {}\n+\n+fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\n+\"#),\n+        @r###\"\n+    [30; 34) 'self': &Self\n+    [55; 59) 'self': &Self\n+    [99; 101) '{}': ()\n+    [111; 112) 'x': impl Trait<u64>\n+    [131; 132) 'y': &impl Trait<u64>\n+    [152; 269) '{     ...2(); }': ()\n+    [158; 159) 'x': impl Trait<u64>\n+    [165; 166) 'y': &impl Trait<u64>\n+    [176; 177) 'z': impl Trait<u64>\n+    [180; 183) 'bar': fn bar() -> impl Trait<u64>\n+    [180; 185) 'bar()': impl Trait<u64>\n+    [191; 192) 'x': impl Trait<u64>\n+    [191; 198) 'x.foo()': u64\n+    [204; 205) 'y': &impl Trait<u64>\n+    [204; 211) 'y.foo()': u64\n+    [217; 218) 'z': impl Trait<u64>\n+    [217; 224) 'z.foo()': u64\n+    [230; 231) 'x': impl Trait<u64>\n+    [230; 238) 'x.foo2()': i64\n+    [244; 245) 'y': &impl Trait<u64>\n+    [244; 252) 'y.foo2()': i64\n+    [258; 259) 'z': impl Trait<u64>\n+    [258; 266) 'z.foo2()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar() -> dyn Trait<u64> {}\n+\n+fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\n+\"#),\n+        @r###\"\n+    [30; 34) 'self': &Self\n+    [55; 59) 'self': &Self\n+    [98; 100) '{}': ()\n+    [110; 111) 'x': dyn Trait<u64>\n+    [129; 130) 'y': &dyn Trait<u64>\n+    [149; 266) '{     ...2(); }': ()\n+    [155; 156) 'x': dyn Trait<u64>\n+    [162; 163) 'y': &dyn Trait<u64>\n+    [173; 174) 'z': dyn Trait<u64>\n+    [177; 180) 'bar': fn bar() -> dyn Trait<u64>\n+    [177; 182) 'bar()': dyn Trait<u64>\n+    [188; 189) 'x': dyn Trait<u64>\n+    [188; 195) 'x.foo()': u64\n+    [201; 202) 'y': &dyn Trait<u64>\n+    [201; 208) 'y.foo()': u64\n+    [214; 215) 'z': dyn Trait<u64>\n+    [214; 221) 'z.foo()': u64\n+    [227; 228) 'x': dyn Trait<u64>\n+    [227; 235) 'x.foo2()': i64\n+    [241; 242) 'y': &dyn Trait<u64>\n+    [241; 249) 'y.foo2()': i64\n+    [255; 256) 'z': dyn Trait<u64>\n+    [255; 263) 'z.foo2()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait_bare() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {\n+    fn foo(&self) -> u64;\n+}\n+fn bar() -> Trait {}\n+\n+fn test(x: Trait, y: &Trait) -> u64 {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+}\n+\"#),\n+        @r###\"\n+    [27; 31) 'self': &Self\n+    [61; 63) '{}': ()\n+    [73; 74) 'x': dyn Trait\n+    [83; 84) 'y': &dyn Trait\n+    [101; 176) '{     ...o(); }': ()\n+    [107; 108) 'x': dyn Trait\n+    [114; 115) 'y': &dyn Trait\n+    [125; 126) 'z': dyn Trait\n+    [129; 132) 'bar': fn bar() -> dyn Trait\n+    [129; 134) 'bar()': dyn Trait\n+    [140; 141) 'x': dyn Trait\n+    [140; 147) 'x.foo()': u64\n+    [153; 154) 'y': &dyn Trait\n+    [153; 160) 'y.foo()': u64\n+    [166; 167) 'z': dyn Trait\n+    [166; 173) 'z.foo()': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn weird_bounds() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {}\n+fn test() {\n+    let a: impl Trait + 'lifetime = foo;\n+    let b: impl 'lifetime = foo;\n+    let b: impl (Trait) = foo;\n+    let b: impl ('lifetime) = foo;\n+    let d: impl ?Sized = foo;\n+    let e: impl Trait + ?Sized = foo;\n+}\n+\"#),\n+        @r###\"\n+    [26; 237) '{     ...foo; }': ()\n+    [36; 37) 'a': impl Trait + {error}\n+    [64; 67) 'foo': impl Trait + {error}\n+    [77; 78) 'b': impl {error}\n+    [97; 100) 'foo': impl {error}\n+    [110; 111) 'b': impl Trait\n+    [128; 131) 'foo': impl Trait\n+    [141; 142) 'b': impl {error}\n+    [163; 166) 'foo': impl {error}\n+    [176; 177) 'd': impl {error}\n+    [193; 196) 'foo': impl {error}\n+    [206; 207) 'e': impl Trait + {error}\n+    [231; 234) 'foo': impl Trait + {error}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn assoc_type_bindings() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {\n+    type Type;\n+}\n+\n+fn get<T: Trait>(t: T) -> <T as Trait>::Type {}\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+\n+struct S<T>;\n+impl<T> Trait for S<T> { type Type = T; }\n+\n+fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n+    get(x);\n+    get2(x);\n+    get(y);\n+    get2(y);\n+    get(set(S));\n+    get2(set(S));\n+    get2(S::<str>);\n+}\n+\"#),\n+        @r###\"\n+    [50; 51) 't': T\n+    [78; 80) '{}': ()\n+    [112; 113) 't': T\n+    [123; 125) '{}': ()\n+    [155; 156) 't': T\n+    [166; 169) '{t}': T\n+    [167; 168) 't': T\n+    [257; 258) 'x': T\n+    [263; 264) 'y': impl Trait<Type = i64>\n+    [290; 398) '{     ...r>); }': ()\n+    [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n+    [296; 302) 'get(x)': {unknown}\n+    [300; 301) 'x': T\n+    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> U\n+    [308; 315) 'get2(x)': {unknown}\n+    [313; 314) 'x': T\n+    [321; 324) 'get': fn get<impl Trait<Type = i64>>(T) -> <T as Trait>::Type\n+    [321; 327) 'get(y)': {unknown}\n+    [325; 326) 'y': impl Trait<Type = i64>\n+    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(T) -> U\n+    [333; 340) 'get2(y)': {unknown}\n+    [338; 339) 'y': impl Trait<Type = i64>\n+    [346; 349) 'get': fn get<S<u64>>(T) -> <T as Trait>::Type\n+    [346; 357) 'get(set(S))': u64\n+    [350; 353) 'set': fn set<S<u64>>(T) -> T\n+    [350; 356) 'set(S)': S<u64>\n+    [354; 355) 'S': S<u64>\n+    [363; 367) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [363; 375) 'get2(set(S))': u64\n+    [368; 371) 'set': fn set<S<u64>>(T) -> T\n+    [368; 374) 'set(S)': S<u64>\n+    [372; 373) 'S': S<u64>\n+    [381; 385) 'get2': fn get2<str, S<str>>(T) -> U\n+    [381; 395) 'get2(S::<str>)': str\n+    [386; 394) 'S::<str>': S<str>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn impl_trait_assoc_binding_projection_bug() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+pub trait Language {\n+    type Kind;\n+}\n+pub enum RustLanguage {}\n+impl Language for RustLanguage {\n+    type Kind = SyntaxKind;\n+}\n+struct SyntaxNode<L> {}\n+fn foo() -> impl Iterator<Item = SyntaxNode<RustLanguage>> {}\n+\n+trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+fn api_walkthrough() {\n+    for node in foo() {\n+        node.clone()<|>;\n+    }\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use iter::*;\n+mod iter {\n+    trait IntoIterator {\n+        type Item;\n+    }\n+    trait Iterator {\n+        type Item;\n+    }\n+    impl<T: Iterator> IntoIterator for T {\n+        type Item = <T as Iterator>::Item;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"{unknown}\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn projection_eq_within_chalk() {\n+    // std::env::set_var(\"CHALK_DEBUG\", \"1\");\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait1 {\n+    type Type;\n+}\n+trait Trait2<T> {\n+    fn foo(self) -> T;\n+}\n+impl<T, U> Trait2<T> for U where U: Trait1<Type = T> {}\n+\n+fn test<T: Trait1<Type = u32>>(x: T) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [62; 66) 'self': Self\n+    [164; 165) 'x': T\n+    [170; 186) '{     ...o(); }': ()\n+    [176; 177) 'x': T\n+    [176; 183) 'x.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn where_clause_trait_in_scope_for_method_resolution() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+mod foo {\n+    trait Trait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+\n+fn test<T: foo::Trait>(x: T) {\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn super_trait_method_resolution() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod foo {\n+    trait SuperTrait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+trait Trait1: foo::SuperTrait {}\n+trait Trait2 where Self: foo::SuperTrait {}\n+\n+fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n+    x.foo();\n+    y.foo();\n+}\n+\"#),\n+        @r###\"\n+    [50; 54) 'self': &Self\n+    [63; 65) '{}': ()\n+    [182; 183) 'x': T\n+    [188; 189) 'y': U\n+    [194; 223) '{     ...o(); }': ()\n+    [200; 201) 'x': T\n+    [200; 207) 'x.foo()': u32\n+    [213; 214) 'y': U\n+    [213; 220) 'y.foo()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn super_trait_cycle() {\n+    // This just needs to not crash\n+    assert_snapshot!(\n+        infer(r#\"\n+trait A: B {}\n+trait B: A {}\n+\n+fn test<T: A>(x: T) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [44; 45) 'x': T\n+    [50; 66) '{     ...o(); }': ()\n+    [56; 57) 'x': T\n+    [56; 63) 'x.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn super_trait_assoc_type_bounds() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait SuperTrait { type Type; }\n+trait Trait where Self: SuperTrait {}\n+\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+\n+struct S<T>;\n+impl<T> SuperTrait for S<T> { type Type = T; }\n+impl<T> Trait for S<T> {}\n+\n+fn test() {\n+    get2(set(S));\n+}\n+\"#),\n+        @r###\"\n+    [103; 104) 't': T\n+    [114; 116) '{}': ()\n+    [146; 147) 't': T\n+    [157; 160) '{t}': T\n+    [158; 159) 't': T\n+    [259; 280) '{     ...S)); }': ()\n+    [265; 269) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [265; 277) 'get2(set(S))': u64\n+    [270; 273) 'set': fn set<S<u64>>(T) -> T\n+    [270; 276) 'set(S)': S<u64>\n+    [274; 275) 'S': S<u64>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn fn_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    fn call_once(self, args: Args) -> <Self as FnOnce<Args>>::Output;\n+}\n+\n+fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n+    f.call_once((1, 2));\n+}\n+\"#),\n+        @r###\"\n+    [57; 61) 'self': Self\n+    [63; 67) 'args': Args\n+    [150; 151) 'f': F\n+    [156; 184) '{     ...2)); }': ()\n+    [162; 163) 'f': F\n+    [162; 181) 'f.call...1, 2))': {unknown}\n+    [174; 180) '(1, 2)': (u32, u64)\n+    [175; 176) '1': u32\n+    [178; 179) '2': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+enum Option<T> { Some(T), None }\n+impl<T> Option<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {}\n+}\n+\n+fn test() {\n+    let x = Option::Some(1u32);\n+    x.map(|v| v + 1);\n+    x.map(|_v| 1u64);\n+    let y: Option<i64> = x.map(|_v| 1);\n+}\n+\"#),\n+        @r###\"\n+    [148; 152) 'self': Option<T>\n+    [154; 155) 'f': F\n+    [173; 175) '{}': ()\n+    [189; 308) '{     ... 1); }': ()\n+    [199; 200) 'x': Option<u32>\n+    [203; 215) 'Option::Some': Some<u32>(T) -> Option<T>\n+    [203; 221) 'Option...(1u32)': Option<u32>\n+    [216; 220) '1u32': u32\n+    [227; 228) 'x': Option<u32>\n+    [227; 243) 'x.map(...v + 1)': Option<u32>\n+    [233; 242) '|v| v + 1': |u32| -> u32\n+    [234; 235) 'v': u32\n+    [237; 238) 'v': u32\n+    [237; 242) 'v + 1': u32\n+    [241; 242) '1': u32\n+    [249; 250) 'x': Option<u32>\n+    [249; 265) 'x.map(... 1u64)': Option<u64>\n+    [255; 264) '|_v| 1u64': |u32| -> u64\n+    [256; 258) '_v': u32\n+    [260; 264) '1u64': u64\n+    [275; 276) 'y': Option<i64>\n+    [292; 293) 'x': Option<u32>\n+    [292; 305) 'x.map(|_v| 1)': Option<i64>\n+    [298; 304) '|_v| 1': |u32| -> i64\n+    [299; 301) '_v': u32\n+    [303; 304) '1': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+fn test<F: FnOnce(u32) -> u64>(f: F) {\n+    f(1);\n+    let g = |v| v + 1;\n+    g(1u64);\n+    let h = |v| 1u128 + v;\n+}\n+\"#),\n+        @r###\"\n+    [73; 74) 'f': F\n+    [79; 155) '{     ...+ v; }': ()\n+    [85; 86) 'f': F\n+    [85; 89) 'f(1)': {unknown}\n+    [87; 88) '1': i32\n+    [99; 100) 'g': |u64| -> i32\n+    [103; 112) '|v| v + 1': |u64| -> i32\n+    [104; 105) 'v': u64\n+    [107; 108) 'v': u64\n+    [107; 112) 'v + 1': i32\n+    [111; 112) '1': i32\n+    [118; 119) 'g': |u64| -> i32\n+    [118; 125) 'g(1u64)': i32\n+    [120; 124) '1u64': u64\n+    [135; 136) 'h': |u128| -> u128\n+    [139; 152) '|v| 1u128 + v': |u128| -> u128\n+    [140; 141) 'v': u128\n+    [143; 148) '1u128': u128\n+    [143; 152) '1u128 + v': u128\n+    [151; 152) 'v': u128\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_as_argument_inference_order() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+fn foo1<T, U, F: FnOnce(T) -> U>(x: T, f: F) -> U {}\n+fn foo2<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U {}\n+\n+struct S;\n+impl S {\n+    fn method(self) -> u64;\n+\n+    fn foo1<T, U, F: FnOnce(T) -> U>(self, x: T, f: F) -> U {}\n+    fn foo2<T, U, F: FnOnce(T) -> U>(self, f: F, x: T) -> U {}\n+}\n+\n+fn test() {\n+    let x1 = foo1(S, |s| s.method());\n+    let x2 = foo2(|s| s.method(), S);\n+    let x3 = S.foo1(S, |s| s.method());\n+    let x4 = S.foo2(|s| s.method(), S);\n+}\n+\"#),\n+        @r###\"\n+    [95; 96) 'x': T\n+    [101; 102) 'f': F\n+    [112; 114) '{}': ()\n+    [148; 149) 'f': F\n+    [154; 155) 'x': T\n+    [165; 167) '{}': ()\n+    [202; 206) 'self': S\n+    [254; 258) 'self': S\n+    [260; 261) 'x': T\n+    [266; 267) 'f': F\n+    [277; 279) '{}': ()\n+    [317; 321) 'self': S\n+    [323; 324) 'f': F\n+    [329; 330) 'x': T\n+    [340; 342) '{}': ()\n+    [356; 515) '{     ... S); }': ()\n+    [366; 368) 'x1': u64\n+    [371; 375) 'foo1': fn foo1<S, u64, |S| -> u64>(T, F) -> U\n+    [371; 394) 'foo1(S...hod())': u64\n+    [376; 377) 'S': S\n+    [379; 393) '|s| s.method()': |S| -> u64\n+    [380; 381) 's': S\n+    [383; 384) 's': S\n+    [383; 393) 's.method()': u64\n+    [404; 406) 'x2': u64\n+    [409; 413) 'foo2': fn foo2<S, u64, |S| -> u64>(F, T) -> U\n+    [409; 432) 'foo2(|...(), S)': u64\n+    [414; 428) '|s| s.method()': |S| -> u64\n+    [415; 416) 's': S\n+    [418; 419) 's': S\n+    [418; 428) 's.method()': u64\n+    [430; 431) 'S': S\n+    [442; 444) 'x3': u64\n+    [447; 448) 'S': S\n+    [447; 472) 'S.foo1...hod())': u64\n+    [454; 455) 'S': S\n+    [457; 471) '|s| s.method()': |S| -> u64\n+    [458; 459) 's': S\n+    [461; 462) 's': S\n+    [461; 471) 's.method()': u64\n+    [482; 484) 'x4': u64\n+    [487; 488) 'S': S\n+    [487; 512) 'S.foo2...(), S)': u64\n+    [494; 508) '|s| s.method()': |S| -> u64\n+    [495; 496) 's': S\n+    [498; 499) 's': S\n+    [498; 508) 's.method()': u64\n+    [510; 511) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    type Item;\n+}\n+\n+trait Trait2 {\n+    fn foo(&self) -> u32;\n+}\n+\n+fn test<T: Trait>() where T::Item: Trait2 {\n+    let x: T::Item = no_matter;\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+    type Item;\n+}\n+\n+trait Trait2 {\n+    fn foo(&self) -> u32;\n+}\n+\n+fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n+    let x: T::Item = no_matter;\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn trait_impl_self_ty() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+   fn foo(&self);\n+}\n+\n+struct S;\n+\n+impl Trait<Self> for S {}\n+\n+fn test() {\n+    S.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}\n+\n+#[test]\n+fn trait_impl_self_ty_cycle() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+   fn foo(&self);\n+}\n+\n+struct S<T>;\n+\n+impl Trait for S<Self> {}\n+\n+fn test() {\n+    S.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_cycle_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    type Item;\n+}\n+\n+trait Trait2<T> {}\n+\n+fn test<T: Trait>() where T: Trait2<T::Item> {\n+    let x: T::Item = no_matter<|>;\n+}\n+\"#,\n+    );\n+    // this is a legitimate cycle\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_cycle_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+    type Item;\n+}\n+\n+fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n+    let x: T::Item = no_matter<|>;\n+}\n+\"#,\n+    );\n+    // this is a legitimate cycle\n+    assert_eq!(t, \"{unknown}\");\n+}"}]}