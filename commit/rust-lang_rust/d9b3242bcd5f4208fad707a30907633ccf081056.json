{"sha": "d9b3242bcd5f4208fad707a30907633ccf081056", "node_id": "C_kwDOAAsO6NoAKGQ5YjMyNDJiY2Q1ZjQyMDhmYWQ3MDdhMzA5MDc2MzNjY2YwODEwNTY", "commit": {"author": {"name": "Petr Nevyho\u0161t\u011bn\u00fd", "email": "petr.nevyhosteny@gmail.com", "date": "2021-12-22T18:48:14Z"}, "committer": {"name": "Petr Nevyho\u0161t\u011bn\u00fd", "email": "petr.nevyhosteny@gmail.com", "date": "2021-12-23T09:16:24Z"}, "message": "Fix generic type substitution in impl trait with assoc type", "tree": {"sha": "193133d1960fbf5612ff6d6d7c16addf1f464357", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/193133d1960fbf5612ff6d6d7c16addf1f464357"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9b3242bcd5f4208fad707a30907633ccf081056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9b3242bcd5f4208fad707a30907633ccf081056", "html_url": "https://github.com/rust-lang/rust/commit/d9b3242bcd5f4208fad707a30907633ccf081056", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9b3242bcd5f4208fad707a30907633ccf081056/comments", "author": {"login": "pnevyk", "id": 2601371, "node_id": "MDQ6VXNlcjI2MDEzNzE=", "avatar_url": "https://avatars.githubusercontent.com/u/2601371?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnevyk", "html_url": "https://github.com/pnevyk", "followers_url": "https://api.github.com/users/pnevyk/followers", "following_url": "https://api.github.com/users/pnevyk/following{/other_user}", "gists_url": "https://api.github.com/users/pnevyk/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnevyk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnevyk/subscriptions", "organizations_url": "https://api.github.com/users/pnevyk/orgs", "repos_url": "https://api.github.com/users/pnevyk/repos", "events_url": "https://api.github.com/users/pnevyk/events{/privacy}", "received_events_url": "https://api.github.com/users/pnevyk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnevyk", "id": 2601371, "node_id": "MDQ6VXNlcjI2MDEzNzE=", "avatar_url": "https://avatars.githubusercontent.com/u/2601371?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnevyk", "html_url": "https://github.com/pnevyk", "followers_url": "https://api.github.com/users/pnevyk/followers", "following_url": "https://api.github.com/users/pnevyk/following{/other_user}", "gists_url": "https://api.github.com/users/pnevyk/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnevyk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnevyk/subscriptions", "organizations_url": "https://api.github.com/users/pnevyk/orgs", "repos_url": "https://api.github.com/users/pnevyk/repos", "events_url": "https://api.github.com/users/pnevyk/events{/privacy}", "received_events_url": "https://api.github.com/users/pnevyk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "html_url": "https://github.com/rust-lang/rust/commit/0add6e95e58633fde2fff0bccaf6c7d71ebc130f"}], "stats": {"total": 422, "additions": 411, "deletions": 11}, "files": [{"sha": "6546d8f7fb4eae978b4184d24aa532bfd9210f42", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/d9b3242bcd5f4208fad707a30907633ccf081056/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b3242bcd5f4208fad707a30907633ccf081056/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=d9b3242bcd5f4208fad707a30907633ccf081056", "patch": "@@ -942,4 +942,310 @@ impl FooB for Foo {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn test_assoc_type_when_trait_with_same_name_in_scope() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Foo {}\n+\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl<T: Types> Behavior<T> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Foo {}\n+\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl<T: Types> Behavior<T> for Impl {\n+    fn reproduce(&self, foo: <T as Types>::Foo) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl {\n+    fn reproduce(&self, foo: <u32 as Types>::Foo) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type_qualified() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for std::string::String {\n+    type Foo = bool;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<std::string::String> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for std::string::String {\n+    type Foo = bool;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<std::string::String> for Impl {\n+    fn reproduce(&self, foo: <std::string::String as Types>::Foo) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type_multi_option_ambiguous() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Types2 {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl Types2 for u32 {\n+    type Foo = String;\n+}\n+\n+pub trait Behavior<T: Types + Types2> {\n+    fn reproduce(&self, foo: <T as Types2>::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Types2 {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl Types2 for u32 {\n+    type Foo = String;\n+}\n+\n+pub trait Behavior<T: Types + Types2> {\n+    fn reproduce(&self, foo: <T as Types2>::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl {\n+    fn reproduce(&self, foo: <u32 as Types2>::Foo) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type_multi_option() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Types2 {\n+    type Bar;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl Types2 for u32 {\n+    type Bar = String;\n+}\n+\n+pub trait Behavior<T: Types + Types2> {\n+    fn reproduce(&self, foo: T::Bar);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Types2 {\n+    type Bar;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl Types2 for u32 {\n+    type Bar = String;\n+}\n+\n+pub trait Behavior<T: Types + Types2> {\n+    fn reproduce(&self, foo: T::Bar);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl {\n+    fn reproduce(&self, foo: <u32 as Types2>::Bar) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type_multi_option_foreign() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+mod bar {\n+    pub trait Types2 {\n+        type Bar;\n+    }\n+}\n+\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl bar::Types2 for u32 {\n+    type Bar = String;\n+}\n+\n+pub trait Behavior<T: Types + bar::Types2> {\n+    fn reproduce(&self, foo: T::Bar);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl { $0 }\"#,\n+            r#\"\n+mod bar {\n+    pub trait Types2 {\n+        type Bar;\n+    }\n+}\n+\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl bar::Types2 for u32 {\n+    type Bar = String;\n+}\n+\n+pub trait Behavior<T: Types + bar::Types2> {\n+    fn reproduce(&self, foo: T::Bar);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl {\n+    fn reproduce(&self, foo: <u32 as bar::Types2>::Bar) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n }"}, {"sha": "5507c9cd6840f2a73ed937c8eab37df471fc7b00", "filename": "crates/ide_db/src/path_transform.rs", "status": "modified", "additions": 95, "deletions": 9, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d9b3242bcd5f4208fad707a30907633ccf081056/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b3242bcd5f4208fad707a30907633ccf081056/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fpath_transform.rs?ref=d9b3242bcd5f4208fad707a30907633ccf081056", "patch": "@@ -118,14 +118,20 @@ struct Ctx<'a> {\n \n impl<'a> Ctx<'a> {\n     fn apply(&self, item: &SyntaxNode) {\n-        for event in item.preorder() {\n-            let node = match event {\n-                syntax::WalkEvent::Enter(_) => continue,\n-                syntax::WalkEvent::Leave(it) => it,\n-            };\n-            if let Some(path) = ast::Path::cast(node.clone()) {\n-                self.transform_path(path);\n-            }\n+        // `transform_path` may update a node's parent and that would break the\n+        // tree traversal. Thus all paths in the tree are collected into a vec\n+        // so that such operation is safe.\n+        let paths = item\n+            .preorder()\n+            .filter_map(|event| match event {\n+                syntax::WalkEvent::Enter(_) => None,\n+                syntax::WalkEvent::Leave(node) => Some(node),\n+            })\n+            .filter_map(ast::Path::cast)\n+            .collect::<Vec<_>>();\n+\n+        for path in paths {\n+            self.transform_path(path);\n         }\n     }\n     fn transform_path(&self, path: ast::Path) -> Option<()> {\n@@ -145,10 +151,60 @@ impl<'a> Ctx<'a> {\n         match resolution {\n             hir::PathResolution::TypeParam(tp) => {\n                 if let Some(subst) = self.substs.get(&tp) {\n-                    ted::replace(path.syntax(), subst.clone_subtree().clone_for_update().syntax())\n+                    let parent = path.syntax().parent()?;\n+                    if let Some(parent) = ast::Path::cast(parent.clone()) {\n+                        // Path inside path means that there is an associated\n+                        // type on the type parameter. It is necessary to fully\n+                        // qualify the type with `as Trait`. Even though it\n+                        // might be unnecessary if `subst` is generic type,\n+                        // always fully qualifying the path is safer because of\n+                        // potential clash of associated types from multiple\n+                        // traits\n+\n+                        let trait_ref = find_trait_for_assoc_type(\n+                            self.source_scope,\n+                            tp,\n+                            parent.segment()?.name_ref()?,\n+                        )\n+                        .and_then(|trait_ref| {\n+                            let found_path = self.target_module.find_use_path(\n+                                self.source_scope.db.upcast(),\n+                                hir::ModuleDef::Trait(trait_ref),\n+                            )?;\n+                            match ast::make::ty_path(mod_path_to_ast(&found_path)) {\n+                                ast::Type::PathType(path_ty) => Some(path_ty),\n+                                _ => None,\n+                            }\n+                        });\n+\n+                        let segment = ast::make::path_segment_ty(subst.clone(), trait_ref);\n+                        let qualified =\n+                            ast::make::path_from_segments(std::iter::once(segment), false);\n+                        ted::replace(path.syntax(), qualified.clone_for_update().syntax());\n+                    } else if let Some(path_ty) = ast::PathType::cast(parent) {\n+                        ted::replace(\n+                            path_ty.syntax(),\n+                            subst.clone_subtree().clone_for_update().syntax(),\n+                        );\n+                    } else {\n+                        ted::replace(\n+                            path.syntax(),\n+                            subst.clone_subtree().clone_for_update().syntax(),\n+                        );\n+                    }\n                 }\n             }\n             hir::PathResolution::Def(def) => {\n+                if let hir::ModuleDef::Trait(_) = def {\n+                    if matches!(path.segment()?.kind()?, ast::PathSegmentKind::Type { .. }) {\n+                        // `speculative_resolve` resolves segments like `<T as\n+                        // Trait>` into `Trait`, but just the trait name should\n+                        // not be used as the replacement of the original\n+                        // segment.\n+                        return None;\n+                    }\n+                }\n+\n                 let found_path =\n                     self.target_module.find_use_path(self.source_scope.db.upcast(), def)?;\n                 let res = mod_path_to_ast(&found_path).clone_for_update();\n@@ -195,3 +251,33 @@ fn get_type_args_from_arg_list(generic_arg_list: ast::GenericArgList) -> Option<\n \n     Some(result)\n }\n+\n+fn find_trait_for_assoc_type(\n+    scope: &SemanticsScope,\n+    type_param: hir::TypeParam,\n+    assoc_type: ast::NameRef,\n+) -> Option<hir::Trait> {\n+    let db = scope.db;\n+    let trait_bounds = type_param.trait_bounds(db);\n+\n+    let assoc_type_name = assoc_type.text();\n+\n+    for trait_ in trait_bounds {\n+        let type_aliases = trait_.items(db).into_iter().filter_map(|item| match item {\n+            hir::AssocItem::TypeAlias(ta) => Some(ta),\n+            _ => None,\n+        });\n+\n+        for type_alias in type_aliases {\n+            if assoc_type_name.as_str() == type_alias.name(db).as_text()?.as_str() {\n+                // It is fine to return the first match because in case of\n+                // multiple possibilities, the exact trait must be disambiguated\n+                // in the definition of trait being implemented, so this search\n+                // should not be needed.\n+                return Some(trait_);\n+            }\n+        }\n+    }\n+\n+    None\n+}"}, {"sha": "1e94b4574b10f1bbb1ccf928597344632c90422c", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9b3242bcd5f4208fad707a30907633ccf081056/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b3242bcd5f4208fad707a30907633ccf081056/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=d9b3242bcd5f4208fad707a30907633ccf081056", "patch": "@@ -166,6 +166,14 @@ pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n     ast_from_text(&format!(\"use {};\", name_ref))\n }\n \n+pub fn path_segment_ty(type_ref: ast::Type, trait_ref: Option<ast::PathType>) -> ast::PathSegment {\n+    let text = match trait_ref {\n+        Some(trait_ref) => format!(\"fn f(x: <{} as {}>) {{}}\", type_ref, trait_ref),\n+        None => format!(\"fn f(x: <{}>) {{}}\", type_ref),\n+    };\n+    ast_from_text(&text)\n+}\n+\n pub fn path_segment_self() -> ast::PathSegment {\n     ast_from_text(\"use self;\")\n }\n@@ -196,9 +204,9 @@ pub fn path_from_segments(\n ) -> ast::Path {\n     let segments = segments.into_iter().map(|it| it.syntax().clone()).join(\"::\");\n     ast_from_text(&if is_abs {\n-        format!(\"use ::{};\", segments)\n+        format!(\"fn f(x: ::{}) {{}}\", segments)\n     } else {\n-        format!(\"use {};\", segments)\n+        format!(\"fn f(x: {}) {{}}\", segments)\n     })\n }\n "}]}