{"sha": "c209d44c342a664bad5428ff988ee1084c13bed7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMDlkNDRjMzQyYTY2NGJhZDU0MjhmZjk4OGVlMTA4NGMxM2JlZDc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-05-24T11:37:11Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-24T21:03:33Z"}, "message": "refactor autoderef to avoid registering obligations\n\nRefactor `FnCtxt::autoderef` to use an external iterator and to not\nregister any obligation from the main autoderef loop, but rather to\nregister them after (and if) the loop successfully completes.\n\nFixes #24819\nFixes #25801\nFixes #27631\nFixes #31258\nFixes #31964\nFixes #32320\nFixes #33515\nFixes #33755", "tree": {"sha": "03fd44daa9d481c9e0ac3c06a9662a80d864d854", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03fd44daa9d481c9e0ac3c06a9662a80d864d854"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c209d44c342a664bad5428ff988ee1084c13bed7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c209d44c342a664bad5428ff988ee1084c13bed7", "html_url": "https://github.com/rust-lang/rust/commit/c209d44c342a664bad5428ff988ee1084c13bed7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c209d44c342a664bad5428ff988ee1084c13bed7/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd6e8d45e183861d44ed91a99f0a50403b2776a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd6e8d45e183861d44ed91a99f0a50403b2776a3", "html_url": "https://github.com/rust-lang/rust/commit/dd6e8d45e183861d44ed91a99f0a50403b2776a3"}], "stats": {"total": 744, "additions": 388, "deletions": 356}, "files": [{"sha": "c177ec4dbede7bcfc81ec845d5cff766d41b01b6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -31,7 +31,7 @@ pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n pub use self::project::{MismatchedProjectionTypes, ProjectionMode};\n-pub use self::project::{normalize, Normalized};\n+pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};"}, {"sha": "60f2ca6f4d9b61abe08bf6e97902472635ea207c", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -235,8 +235,9 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n             None => {\n                 span_bug!(\n                     expr_span,\n-                    \"the {}th autoderef failed: {}\",\n+                    \"the {}th autoderef for {} failed: {}\",\n                     autoderef,\n+                    expr_id,\n                     adjusted_ty);\n             }\n         }"}, {"sha": "9e2b7cd034652f28d77264a1b41bef494bf2dfcd", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -0,0 +1,210 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use astconv::AstConv;\n+\n+use super::FnCtxt;\n+\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TraitRef};\n+use rustc::ty::{ToPredicate, TypeFoldable};\n+use rustc::ty::{MethodCall, MethodCallee};\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n+use rustc::hir;\n+\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+\n+#[derive(Copy, Clone, Debug)]\n+enum AutoderefKind {\n+    Builtin,\n+    Overloaded\n+}\n+\n+pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n+    cur_ty: Ty<'tcx>,\n+    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+    at_start: bool,\n+    span: Span\n+}\n+\n+impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n+    type Item = (Ty<'tcx>, usize);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let tcx = self.fcx.tcx;\n+\n+        debug!(\"autoderef: steps={:?}, cur_ty={:?}\",\n+               self.steps, self.cur_ty);\n+        if self.at_start {\n+            self.at_start = false;\n+            debug!(\"autoderef stage #0 is {:?}\", self.cur_ty);\n+            return Some((self.cur_ty, 0));\n+        }\n+\n+        if self.steps.len() == tcx.sess.recursion_limit.get() {\n+            // We've reached the recursion limit, error gracefully.\n+            span_err!(tcx.sess, self.span, E0055,\n+                      \"reached the recursion limit while auto-dereferencing {:?}\",\n+                      self.cur_ty);\n+            return None;\n+        }\n+\n+        if self.cur_ty.is_ty_var() {\n+            return None;\n+        }\n+\n+        // Otherwise, deref if type is derefable:\n+        let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(false, NoPreference) {\n+            (AutoderefKind::Builtin, mt.ty)\n+        } else {\n+            match self.overloaded_deref_ty(self.cur_ty) {\n+                Some(ty) => (AutoderefKind::Overloaded, ty),\n+                _ => return None\n+            }\n+        };\n+\n+        if new_ty.references_error() {\n+            return None;\n+        }\n+\n+        self.steps.push((self.cur_ty, kind));\n+        debug!(\"autoderef stage #{:?} is {:?} from {:?}\", self.steps.len(),\n+               new_ty, (self.cur_ty, kind));\n+        self.cur_ty = new_ty;\n+\n+        Some((self.cur_ty, self.steps.len()))\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n+    fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        debug!(\"overloaded_deref_ty({:?})\", ty);\n+\n+        let tcx = self.fcx.tcx();\n+\n+        // <cur_ty as Deref>\n+        let trait_ref = TraitRef {\n+            def_id: match tcx.lang_items.deref_trait() {\n+                Some(f) => f,\n+                None => return None\n+            },\n+            substs: tcx.mk_substs(Substs::new_trait(vec![], vec![], self.cur_ty))\n+        };\n+\n+        let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+\n+        let mut selcx = traits::SelectionContext::new(self.fcx);\n+        let obligation = traits::Obligation::new(cause.clone(), trait_ref.to_predicate());\n+        if !selcx.evaluate_obligation(&obligation) {\n+            debug!(\"overloaded_deref_ty: cannot match obligation\");\n+            return None;\n+        }\n+\n+        let normalized = traits::normalize_projection_type(\n+            &mut selcx,\n+            ty::ProjectionTy {\n+                trait_ref: trait_ref,\n+                item_name: token::intern(\"Target\")\n+            },\n+            cause,\n+            0\n+        );\n+\n+        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized);\n+        self.obligations.extend(normalized.obligations);\n+\n+        Some(self.fcx.resolve_type_vars_if_possible(&normalized.value))\n+    }\n+\n+    pub fn unambiguous_final_ty(&self) -> Ty<'tcx> {\n+        self.fcx.structurally_resolved_type(self.span, self.cur_ty)\n+    }\n+\n+    pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n+        where I: IntoIterator<Item=&'b hir::Expr>\n+    {\n+        let methods : Vec<_> = self.steps.iter().map(|&(ty, kind)| {\n+            if let AutoderefKind::Overloaded = kind {\n+                self.fcx.try_overloaded_deref(self.span, None, ty, pref)\n+            } else {\n+                None\n+            }\n+        }).collect();\n+\n+        debug!(\"finalize({:?}) - {:?},{:?}\", pref, methods, self.obligations);\n+\n+        for expr in exprs {\n+            debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n+            for (n, method) in methods.iter().enumerate() {\n+                if let &Some(method) = method {\n+                    let method_call = MethodCall::autoderef(expr.id, n as u32);\n+                    self.fcx.tables.borrow_mut().method_map.insert(method_call, method);\n+                }\n+            }\n+        }\n+\n+        for obligation in self.obligations {\n+            self.fcx.register_predicate(obligation);\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+    pub fn autoderef(&'a self,\n+                     span: Span,\n+                     base_ty: Ty<'tcx>)\n+                     -> Autoderef<'a, 'gcx, 'tcx>\n+    {\n+        Autoderef {\n+            fcx: self,\n+            steps: vec![],\n+            cur_ty: self.resolve_type_vars_if_possible(&base_ty),\n+            obligations: vec![],\n+            at_start: true,\n+            span: span\n+        }\n+    }\n+\n+    pub fn try_overloaded_deref(&self,\n+                                span: Span,\n+                                base_expr: Option<&hir::Expr>,\n+                                base_ty: Ty<'tcx>,\n+                                lvalue_pref: LvaluePreference)\n+                                -> Option<MethodCallee<'tcx>>\n+    {\n+        debug!(\"try_overloaded_deref({:?},{:?},{:?},{:?})\",\n+               span, base_expr, base_ty, lvalue_pref);\n+        // Try DerefMut first, if preferred.\n+        let method = match (lvalue_pref, self.tcx.lang_items.deref_mut_trait()) {\n+            (PreferMutLvalue, Some(trait_did)) => {\n+                self.lookup_method_in_trait(span, base_expr,\n+                                            token::intern(\"deref_mut\"), trait_did,\n+                                            base_ty, None)\n+            }\n+            _ => None\n+        };\n+\n+        // Otherwise, fall back to Deref.\n+        let method = match (method, self.tcx.lang_items.deref_trait()) {\n+            (None, Some(trait_did)) => {\n+                self.lookup_method_in_trait(span, base_expr,\n+                                            token::intern(\"deref\"), trait_did,\n+                                            base_ty, None)\n+            }\n+            (method, _) => method\n+        };\n+\n+        method\n+    }\n+}"}, {"sha": "417b2fafecfd3e39fc353a152f26569021a5e72d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::{DeferredCallResolution, Expectation, FnCtxt,\n-            TupleArgumentsFlag, UnresolvedTypeAction};\n+            TupleArgumentsFlag};\n \n use CrateCtxt;\n use middle::cstore::LOCAL_CRATE;\n@@ -72,15 +72,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.check_expr(callee_expr);\n         let original_callee_ty = self.expr_ty(callee_expr);\n-        let (callee_ty, _, result) =\n-            self.autoderef(callee_expr.span,\n-                           original_callee_ty,\n-                           || Some(callee_expr),\n-                           UnresolvedTypeAction::Error,\n-                           LvaluePreference::NoPreference,\n-                           |adj_ty, idx| {\n-                self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n-        });\n+\n+        let mut autoderef = self.autoderef(callee_expr.span, original_callee_ty);\n+        let result = autoderef.by_ref().flat_map(|(adj_ty, idx)| {\n+            self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n+        }).next();\n+        let callee_ty = autoderef.unambiguous_final_ty();\n+        autoderef.finalize(LvaluePreference::NoPreference, Some(callee_expr));\n \n         match result {\n             None => {"}, {"sha": "2225fd588b1cb6d20b9d73b72409aeafa8ed84f3", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{FnCtxt, UnresolvedTypeAction};\n+use check::{FnCtxt};\n \n use rustc::hir;\n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n@@ -220,7 +220,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                          -> CoerceResult<'tcx>\n         // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n-              I: IntoIterator<Item=&'a hir::Expr> {\n+              I: IntoIterator<Item=&'a hir::Expr>\n+    {\n \n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n \n@@ -240,18 +241,16 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let span = self.origin.span();\n \n-        let lvalue_pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n         let mut first_error = None;\n         let mut r_borrow_var = None;\n-        let (_, autoderefs, success) = self.autoderef(span, a, exprs,\n-                                                      UnresolvedTypeAction::Ignore,\n-                                                      lvalue_pref,\n-                                                      |referent_ty, autoderef|\n-        {\n-            if autoderef == 0 {\n+        let mut autoderef = self.autoderef(span, a);\n+        let mut success = None;\n+\n+        for (referent_ty, autoderefs) in autoderef.by_ref() {\n+            if autoderefs == 0 {\n                 // Don't let this pass, otherwise it would cause\n                 // &T to autoref to &&T.\n-                return None;\n+                continue\n             }\n \n             // At this point, we have deref'd `a` to `referent_ty`.  So\n@@ -326,7 +325,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             //     and let regionck figure it out.\n             let r = if !self.use_lub {\n                 r_b // [2] above\n-            } else if autoderef == 1 {\n+            } else if autoderefs == 1 {\n                 r_a // [3] above\n             } else {\n                 if r_borrow_var.is_none() { // create var lazilly, at most once\n@@ -341,30 +340,31 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 mutbl: mt_b.mutbl // [1] above\n             });\n             match self.unify(derefd_ty_a, b) {\n-                Ok(ty) => Some(ty),\n+                Ok(ty) => { success = Some((ty, autoderefs)); break },\n                 Err(err) => {\n                     if first_error.is_none() {\n                         first_error = Some(err);\n                     }\n-                    None\n                 }\n             }\n-        });\n+        }\n \n         // Extract type or return an error. We return the first error\n         // we got, which should be from relating the \"base\" type\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let ty = match success {\n-            Some(ty) => ty,\n+        let (ty, autoderefs) = match success {\n+            Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n                 debug!(\"coerce_borrowed_pointer: failed with err = {:?}\", err);\n                 return Err(err);\n             }\n         };\n \n+        autoderef.finalize(LvaluePreference::from_mutbl(mt_b.mutbl), exprs());\n+\n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         if ty == a && mt_a.mutbl == hir::MutImmutable && autoderefs == 1 {"}, {"sha": "683a67ff07cf9fe9da436290d6067c3aaa70cdb3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 32, "deletions": 68, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -11,11 +11,10 @@\n use super::probe;\n \n use check::{FnCtxt, callee};\n-use check::UnresolvedTypeAction;\n use hir::def_id::DefId;\n use rustc::ty::subst::{self};\n use rustc::traits;\n-use rustc::ty::{self, NoPreference, PreferMutLvalue, Ty};\n+use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk, TypeOrigin};\n@@ -133,10 +132,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             ty: fty,\n             substs: all_substs\n         };\n-        // If this is an `&mut self` method, bias the receiver\n-        // expression towards mutability (this will switch\n-        // e.g. `Deref` to `DerefMut` in overloaded derefs and so on).\n-        self.fixup_derefs_on_method_receiver_if_necessary(&callee);\n+\n+        if let Some(hir::MutMutable) = pick.autoref {\n+            self.convert_lvalue_derefs_to_mutable();\n+        }\n \n         callee\n     }\n@@ -164,22 +163,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             (None, None)\n         };\n \n-        // Commit the autoderefs by calling `autoderef again, but this\n+        // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various tables.\n-        let (autoderefd_ty, n, result) = self.autoderef(self.span,\n-                                                        unadjusted_self_ty,\n-                                                        || Some(self.self_expr),\n-                                                        UnresolvedTypeAction::Error,\n-                                                        NoPreference,\n-                                                        |_, n| {\n-            if n == pick.autoderefs {\n-                Some(())\n-            } else {\n-                None\n-            }\n-        });\n+        let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n+        let (autoderefd_ty, n) = autoderef.nth(pick.autoderefs).unwrap();\n         assert_eq!(n, pick.autoderefs);\n-        assert_eq!(result, Some(()));\n+\n+        autoderef.unambiguous_final_ty();\n+        autoderef.finalize(LvaluePreference::NoPreference, Some(self.self_expr));\n \n         // Write out the final adjustment.\n         self.write_adjustment(self.self_expr.id, AdjustDerefRef(AutoDerefRef {\n@@ -293,27 +284,21 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // yield an object-type (e.g., `&Object` or `Box<Object>`\n         // etc).\n \n-        let (_, _, result) = self.fcx.autoderef(self.span,\n-                                                self_ty,\n-                                                || None,\n-                                                UnresolvedTypeAction::Error,\n-                                                NoPreference,\n-                                                |ty, _| {\n-            match ty.sty {\n-                ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n-                _ => None,\n-            }\n-        });\n-\n-        match result {\n-            Some(r) => r,\n-            None => {\n+        // FIXME: this feels, like, super dubious\n+        self.fcx.autoderef(self.span, self_ty)\n+            .filter_map(|(ty, _)| {\n+                match ty.sty {\n+                    ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n+                    _ => None,\n+                }\n+            })\n+            .next()\n+            .unwrap_or_else(|| {\n                 span_bug!(\n                     self.span,\n                     \"self-type `{}` for ObjectPick never dereferenced to an object\",\n                     self_ty)\n-            }\n-        }\n+            })\n     }\n \n     fn instantiate_method_substs(&mut self,\n@@ -463,24 +448,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // RECONCILIATION\n \n-    /// When we select a method with an `&mut self` receiver, we have to go convert any\n+    /// When we select a method with a mutable autoref, we have to go convert any\n     /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n     /// respectively.\n-    fn fixup_derefs_on_method_receiver_if_necessary(&self,\n-                                                    method_callee: &ty::MethodCallee) {\n-        let sig = match method_callee.ty.sty {\n-            ty::TyFnDef(_, _, ref f) => f.sig.clone(),\n-            _ => return,\n-        };\n-\n-        match sig.0.inputs[0].sty {\n-            ty::TyRef(_, ty::TypeAndMut {\n-                ty: _,\n-                mutbl: hir::MutMutable,\n-            }) => {}\n-            _ => return,\n-        }\n-\n+    fn convert_lvalue_derefs_to_mutable(&self) {\n         // Gather up expressions we want to munge.\n         let mut exprs = Vec::new();\n         exprs.push(self.self_expr);\n@@ -495,8 +466,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={:?}\",\n-               exprs);\n+        debug!(\"convert_lvalue_derefs_to_mutable: exprs={:?}\", exprs);\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n@@ -509,23 +479,17 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 Some(_) | None => 0,\n             };\n \n-            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={:?} \\\n-                                                                  autoderef_count={}\",\n+            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?} \\\n+                                                      autoderef_count={}\",\n                    i, expr, autoderef_count);\n \n             if autoderef_count > 0 {\n-                self.autoderef(expr.span,\n-                               self.expr_ty(expr),\n-                               || Some(expr),\n-                               UnresolvedTypeAction::Error,\n-                               PreferMutLvalue,\n-                               |_, autoderefs| {\n-                    if autoderefs == autoderef_count + 1 {\n-                        Some(())\n-                    } else {\n-                        None\n-                    }\n+                let mut autoderef = self.autoderef(expr.span, self.expr_ty(expr));\n+                autoderef.nth(autoderef_count).unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"expr was deref-able {} times but now isn't?\",\n+                              autoderef_count);\n                 });\n+                autoderef.finalize(PreferMutLvalue, Some(expr));\n             }\n \n             // Don't retry the first one or we might infinite loop!"}, {"sha": "0bb078dfbcba2d5304f81b3f20df9c1d6db0d727", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -13,13 +13,13 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n-use check::{FnCtxt, UnresolvedTypeAction};\n+use check::{FnCtxt};\n use hir::def_id::DefId;\n use hir::def::Def;\n use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n-use rustc::ty::{self, NoPreference, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -208,25 +208,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn create_steps(&self,\n                     span: Span,\n                     self_ty: Ty<'tcx>)\n-                    -> Option<Vec<CandidateStep<'tcx>>> {\n-        let mut steps = Vec::new();\n-\n-        let (final_ty, dereferences, _) = self.autoderef(span,\n-                                                         self_ty,\n-                                                         || None,\n-                                                         UnresolvedTypeAction::Error,\n-                                                         NoPreference,\n-                                                         |t, d| {\n-            steps.push(CandidateStep {\n-                self_ty: t,\n-                autoderefs: d,\n-                unsize: false\n-            });\n-            None::<()> // keep iterating until we can't anymore\n-        });\n+                    -> Option<Vec<CandidateStep<'tcx>>>\n+    {\n+        // FIXME: we don't need to create the entire steps in one pass\n \n+        let mut autoderef = self.autoderef(span, self_ty);\n+        let mut steps: Vec<_> = autoderef.by_ref().map(|(ty, d)| CandidateStep {\n+            self_ty: ty,\n+            autoderefs: d,\n+            unsize: false\n+        }).collect();\n+\n+        let final_ty = autoderef.unambiguous_final_ty();\n         match final_ty.sty {\n             ty::TyArray(elem_ty, _) => {\n+                let dereferences = steps.len() - 1;\n+\n                 steps.push(CandidateStep {\n                     self_ty: self.tcx.mk_slice(elem_ty),\n                     autoderefs: dereferences,\n@@ -237,6 +234,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => (),\n         }\n \n+        debug!(\"create_steps: steps={:?}\", steps);\n+\n         Some(steps)\n     }\n }"}, {"sha": "6f0d2bc0ca5e64a52bb1bd2d07a2723322d6cf06", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 20, "deletions": 43, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -13,15 +13,14 @@\n \n use CrateCtxt;\n \n-use check::{self, FnCtxt, UnresolvedTypeAction};\n+use check::{FnCtxt};\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use middle::cstore;\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::ty::subst::Substs;\n-use rustc::ty::LvaluePreference;\n use rustc::traits::{Obligation, SelectionContext};\n use util::nodemap::{FnvHashSet};\n \n@@ -48,42 +47,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty::TyClosure(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => true,\n             // If it's not a simple function, look for things which implement FnOnce\n             _ => {\n-                if let Ok(fn_once_trait_did) =\n-                        tcx.lang_items.require(FnOnceTraitLangItem) {\n-                    let (_, _, opt_is_fn) = self.autoderef(span,\n-                                                           ty,\n-                                                           || None,\n-                                                           UnresolvedTypeAction::Ignore,\n-                                                           LvaluePreference::NoPreference,\n-                                                           |ty, _| {\n-                        self.probe(|_| {\n-                            let fn_once_substs =\n-                                Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n-                            let trait_ref =\n-                                ty::TraitRef::new(fn_once_trait_did,\n-                                                  tcx.mk_substs(fn_once_substs));\n-                            let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                            let obligation = Obligation::misc(span,\n-                                                              self.body_id,\n-                                                              poly_trait_ref\n-                                                                 .to_predicate());\n-                            let mut selcx = SelectionContext::new(self);\n-\n-                            if selcx.evaluate_obligation(&obligation) {\n-                                Some(())\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                    });\n+                let fn_once = match tcx.lang_items.require(FnOnceTraitLangItem) {\n+                    Ok(fn_once) => fn_once,\n+                    Err(..) => return false\n+                };\n \n-                    opt_is_fn.is_some()\n-                } else {\n-                    false\n-                }\n+                self.autoderef(span, ty).any(|(ty, _)| self.probe(|_| {\n+                    let fn_once_substs =\n+                        Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n+                    let trait_ref =\n+                        ty::TraitRef::new(fn_once,\n+                                          tcx.mk_substs(fn_once_substs));\n+                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                    let obligation = Obligation::misc(span,\n+                                                      self.body_id,\n+                                                      poly_trait_ref\n+                                                      .to_predicate());\n+                    SelectionContext::new(self).evaluate_obligation(&obligation)\n+                }))\n             }\n         }\n     }\n+\n     pub fn report_method_error(&self,\n                                span: Span,\n                                rcvr_ty: Ty<'tcx>,\n@@ -384,15 +369,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n         }\n \n-        self.autoderef(span, rcvr_ty, || None,\n-                       check::UnresolvedTypeAction::Ignore, ty::NoPreference,\n-                       |ty, _| {\n-            if is_local(ty) {\n-                Some(())\n-            } else {\n-                None\n-            }\n-        }).2.is_some()\n+        self.autoderef(span, rcvr_ty).any(|(ty, _)| is_local(ty))\n     }\n }\n "}, {"sha": "5dd00cf3666ade3fcc692af31e728ce74bb2e65f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 197, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -129,6 +129,7 @@ use rustc_back::slice;\n use rustc_const_eval::eval_repeat_count;\n \n mod assoc;\n+mod autoderef;\n pub mod dropck;\n pub mod _match;\n pub mod writeback;\n@@ -1412,17 +1413,6 @@ impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Whether `autoderef` requires types to resolve.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum UnresolvedTypeAction {\n-    /// Produce an error and return `TyError` whenever a type cannot\n-    /// be resolved (i.e. it is `TyInfer`).\n-    Error,\n-    /// Go on without emitting any errors, and return the unresolved\n-    /// type. Useful for probing, e.g. in coercions.\n-    Ignore\n-}\n-\n /// Controls whether the arguments are tupled. This is used for the call\n /// operator.\n ///\n@@ -2228,120 +2218,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Executes an autoderef loop for the type `t`. At each step, invokes `should_stop`\n-    /// to decide whether to terminate the loop. Returns the final type and number of\n-    /// derefs that it performed.\n-    ///\n-    /// Note: this method does not modify the adjustments table. The caller is responsible for\n-    /// inserting an AutoAdjustment record into the `self` using one of the suitable methods.\n-    pub fn autoderef<'b, E, I, T, F>(&self,\n-                                     sp: Span,\n-                                     base_ty: Ty<'tcx>,\n-                                     maybe_exprs: E,\n-                                     unresolved_type_action: UnresolvedTypeAction,\n-                                     mut lvalue_pref: LvaluePreference,\n-                                     mut should_stop: F)\n-                                     -> (Ty<'tcx>, usize, Option<T>)\n-        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n-        where E: Fn() -> I,\n-              I: IntoIterator<Item=&'b hir::Expr>,\n-              F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n-    {\n-        debug!(\"autoderef(base_ty={:?}, lvalue_pref={:?})\",\n-               base_ty, lvalue_pref);\n-\n-        let mut t = base_ty;\n-        for autoderefs in 0..self.tcx.sess.recursion_limit.get() {\n-            let resolved_t = match unresolved_type_action {\n-                UnresolvedTypeAction::Error => {\n-                    self.structurally_resolved_type(sp, t)\n-                }\n-                UnresolvedTypeAction::Ignore => {\n-                    // We can continue even when the type cannot be resolved\n-                    // (i.e. it is an inference variable) because `Ty::builtin_deref`\n-                    // and `try_overloaded_deref` both simply return `None`\n-                    // in such a case without producing spurious errors.\n-                    self.resolve_type_vars_if_possible(&t)\n-                }\n-            };\n-            if resolved_t.references_error() {\n-                return (resolved_t, autoderefs, None);\n-            }\n-\n-            match should_stop(resolved_t, autoderefs) {\n-                Some(x) => return (resolved_t, autoderefs, Some(x)),\n-                None => {}\n-            }\n-\n-            // Otherwise, deref if type is derefable:\n-\n-            // Super subtle: it might seem as though we should\n-            // pass `opt_expr` to `try_overloaded_deref`, so that\n-            // the (implicit) autoref of using an overloaded deref\n-            // would get added to the adjustment table. However we\n-            // do not do that, because it's kind of a\n-            // \"meta-adjustment\" -- instead, we just leave it\n-            // unrecorded and know that there \"will be\" an\n-            // autoref. regionck and other bits of the code base,\n-            // when they encounter an overloaded autoderef, have\n-            // to do some reconstructive surgery. This is a pretty\n-            // complex mess that is begging for a proper MIR.\n-            let mt = if let Some(mt) = resolved_t.builtin_deref(false, lvalue_pref) {\n-                mt\n-            } else if let Some(method) = self.try_overloaded_deref(sp, None,\n-                                                                   resolved_t, lvalue_pref) {\n-                for expr in maybe_exprs() {\n-                    let method_call = MethodCall::autoderef(expr.id, autoderefs as u32);\n-                    self.tables.borrow_mut().method_map.insert(method_call, method);\n-                }\n-                self.make_overloaded_lvalue_return_type(method)\n-            } else {\n-                return (resolved_t, autoderefs, None);\n-            };\n-\n-            t = mt.ty;\n-            if mt.mutbl == hir::MutImmutable {\n-                lvalue_pref = NoPreference;\n-            }\n-        }\n-\n-        // We've reached the recursion limit, error gracefully.\n-        span_err!(self.tcx.sess, sp, E0055,\n-            \"reached the recursion limit while auto-dereferencing {:?}\",\n-            base_ty);\n-        (self.tcx.types.err, 0, None)\n-    }\n-\n-    fn try_overloaded_deref(&self,\n-                            span: Span,\n-                            base_expr: Option<&hir::Expr>,\n-                            base_ty: Ty<'tcx>,\n-                            lvalue_pref: LvaluePreference)\n-                            -> Option<MethodCallee<'tcx>>\n-    {\n-        // Try DerefMut first, if preferred.\n-        let method = match (lvalue_pref, self.tcx.lang_items.deref_mut_trait()) {\n-            (PreferMutLvalue, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, base_expr,\n-                                            token::intern(\"deref_mut\"), trait_did,\n-                                            base_ty, None)\n-            }\n-            _ => None\n-        };\n-\n-        // Otherwise, fall back to Deref.\n-        let method = match (method, self.tcx.lang_items.deref_trait()) {\n-            (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, base_expr,\n-                                            token::intern(\"deref\"), trait_did,\n-                                            base_ty, None)\n-            }\n-            (method, _) => method\n-        };\n-\n-        method\n-    }\n-\n     /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n     /// returns a type of `&T`, but the actual type we assign to the\n     /// *expression* is `T`. So this function just peels off the return\n@@ -2371,29 +2247,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // autoderef that normal method probing does. They could likely be\n         // consolidated.\n \n-        let (ty, autoderefs, final_mt) = self.autoderef(base_expr.span,\n-                                                        base_ty,\n-                                                        || Some(base_expr),\n-                                                        UnresolvedTypeAction::Error,\n-                                                        lvalue_pref,\n-                                                        |adj_ty, idx| {\n-            self.try_index_step(MethodCall::expr(expr.id), expr, base_expr,\n-                                adj_ty, idx, false, lvalue_pref, idx_ty)\n-        });\n+        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n \n-        if final_mt.is_some() {\n-            return final_mt;\n-        }\n+        while let Some((adj_ty, autoderefs)) = autoderef.next() {\n+            if let Some(final_mt) = self.try_index_step(\n+                MethodCall::expr(expr.id),\n+                expr, base_expr, adj_ty, autoderefs,\n+                false, lvalue_pref, idx_ty)\n+            {\n+                autoderef.finalize(lvalue_pref, Some(base_expr));\n+                return Some(final_mt);\n+            }\n \n-        // After we have fully autoderef'd, if the resulting type is [T; n], then\n-        // do a final unsized coercion to yield [T].\n-        if let ty::TyArray(element_ty, _) = ty.sty {\n-            let adjusted_ty = self.tcx.mk_slice(element_ty);\n-            self.try_index_step(MethodCall::expr(expr.id), expr, base_expr,\n-                                adjusted_ty, autoderefs, true, lvalue_pref, idx_ty)\n-        } else {\n-            None\n+            if let ty::TyArray(element_ty, _) = adj_ty.sty {\n+                autoderef.finalize(lvalue_pref, Some(base_expr));\n+                let adjusted_ty = self.tcx.mk_slice(element_ty);\n+                return self.try_index_step(\n+                    MethodCall::expr(expr.id), expr, base_expr,\n+                    adjusted_ty, autoderefs, true, lvalue_pref, idx_ty);\n+            }\n         }\n+        autoderef.unambiguous_final_ty();\n+        None\n     }\n \n     /// To type-check `base_expr[index_expr]`, we progressively autoderef\n@@ -3034,32 +2909,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_t = self.structurally_resolved_type(expr.span,\n                                                      self.expr_ty(base));\n         let mut private_candidate = None;\n-        let (_, autoderefs, field_ty) = self.autoderef(expr.span,\n-                                                       expr_t,\n-                                                       || Some(base),\n-                                                       UnresolvedTypeAction::Error,\n-                                                       lvalue_pref,\n-                                                       |base_t, _| {\n-                if let ty::TyStruct(base_def, substs) = base_t.sty {\n-                    debug!(\"struct named {:?}\",  base_t);\n-                    if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n-                        let field_ty = self.field_ty(expr.span, field, substs);\n-                        if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n-                            return Some(field_ty);\n-                        }\n-                        private_candidate = Some((base_def.did, field_ty));\n+        let mut autoderef = self.autoderef(expr.span, expr_t);\n+        while let Some((base_t, autoderefs)) = autoderef.next() {\n+            if let ty::TyStruct(base_def, substs) = base_t.sty {\n+                debug!(\"struct named {:?}\",  base_t);\n+                if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n+                    let field_ty = self.field_ty(expr.span, field, substs);\n+                    if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n+                        autoderef.finalize(lvalue_pref, Some(base));\n+                        self.write_ty(expr.id, field_ty);\n+                        self.write_autoderef_adjustment(base.id, autoderefs);\n+                        return;\n                     }\n+                    private_candidate = Some((base_def.did, field_ty));\n                 }\n-                None\n-            });\n-        match field_ty {\n-            Some(field_ty) => {\n-                self.write_ty(expr.id, field_ty);\n-                self.write_autoderef_adjustment(base.id, autoderefs);\n-                return;\n             }\n-            None => {}\n         }\n+        autoderef.unambiguous_final_ty();\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n@@ -3132,42 +2998,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      self.expr_ty(base));\n         let mut private_candidate = None;\n         let mut tuple_like = false;\n-        let (_, autoderefs, field_ty) = self.autoderef(expr.span,\n-                                                       expr_t,\n-                                                       || Some(base),\n-                                                       UnresolvedTypeAction::Error,\n-                                                       lvalue_pref,\n-                                                       |base_t, _| {\n-                let (base_def, substs) = match base_t.sty {\n-                    ty::TyStruct(base_def, substs) => (base_def, substs),\n-                    ty::TyTuple(ref v) => {\n-                        tuple_like = true;\n-                        return if idx.node < v.len() { Some(v[idx.node]) } else { None }\n-                    }\n-                    _ => return None,\n-                };\n-\n-                tuple_like = base_def.struct_variant().is_tuple_struct();\n-                if !tuple_like { return None }\n-\n-                debug!(\"tuple struct named {:?}\",  base_t);\n-                if let Some(field) = base_def.struct_variant().fields.get(idx.node) {\n-                    let field_ty = self.field_ty(expr.span, field, substs);\n-                    if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n-                        return Some(field_ty);\n-                    }\n-                    private_candidate = Some((base_def.did, field_ty));\n+        let mut autoderef = self.autoderef(expr.span, expr_t);\n+        while let Some((base_t, autoderefs)) = autoderef.next() {\n+            let field = match base_t.sty {\n+                ty::TyStruct(base_def, substs) => {\n+                    tuple_like = base_def.struct_variant().is_tuple_struct();\n+                    if !tuple_like { continue }\n+\n+                    debug!(\"tuple struct named {:?}\",  base_t);\n+                    base_def.struct_variant().fields.get(idx.node).and_then(|field| {\n+                        let field_ty = self.field_ty(expr.span, field, substs);\n+                        private_candidate = Some((base_def.did, field_ty));\n+                        if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n+                            Some(field_ty)\n+                        } else {\n+                            None\n+                        }\n+                    })\n                 }\n-                None\n-            });\n-        match field_ty {\n-            Some(field_ty) => {\n+                ty::TyTuple(ref v) => {\n+                    tuple_like = true;\n+                    v.get(idx.node).cloned()\n+                }\n+                _ => continue\n+            };\n+\n+            if let Some(field_ty) = field {\n+                autoderef.finalize(lvalue_pref, Some(base));\n                 self.write_ty(expr.id, field_ty);\n                 self.write_autoderef_adjustment(base.id, autoderefs);\n                 return;\n             }\n-            None => {}\n         }\n+        autoderef.unambiguous_final_ty();\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);"}, {"sha": "f86d7ec114b938132fd532a8bc61a08b538b7872", "filename": "src/test/compile-fail/E0055.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Ftest%2Fcompile-fail%2FE0055.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Ftest%2Fcompile-fail%2FE0055.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0055.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -19,5 +19,4 @@ fn main() {\n     let foo = Foo;\n     let ref_foo = &&Foo;\n     ref_foo.foo(); //~ ERROR E0055\n-                   //~^ ERROR E0275\n }"}, {"sha": "764d05be879b8be674f3e9c3adba83e924c051a8", "filename": "src/test/compile-fail/borrowck/borrowck-borrow-overloaded-auto-deref-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref-mut.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -99,7 +99,7 @@ fn assign_field1<'a>(x: Own<Point>) {\n }\n \n fn assign_field2<'a>(x: &'a Own<Point>) {\n-    x.y = 3; //~ ERROR cannot assign\n+    x.y = 3; //~ ERROR cannot borrow\n }\n \n fn assign_field3<'a>(x: &'a mut Own<Point>) {"}, {"sha": "52f5f1cd079ebe52fddc17ffe5664f0841719859", "filename": "src/test/compile-fail/issue-24819.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Ftest%2Fcompile-fail%2Fissue-24819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c209d44c342a664bad5428ff988ee1084c13bed7/src%2Ftest%2Fcompile-fail%2Fissue-24819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24819.rs?ref=c209d44c342a664bad5428ff988ee1084c13bed7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashSet;\n+\n+fn main() {\n+    let mut v = Vec::new();\n+    foo(&mut v);\n+    //~^ ERROR mismatched types\n+    //~| expected struct `std::collections::HashSet`, found struct `std::vec::Vec`\n+}\n+\n+fn foo(h: &mut HashSet<u32>) {\n+}"}]}