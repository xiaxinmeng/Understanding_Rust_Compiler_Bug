{"sha": "0af3775dd2c93cdaf8902f83eb21037e474e058f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZjM3NzVkZDJjOTNjZGFmODkwMmY4M2ViMjEwMzdlNDc0ZTA1OGY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-07T21:46:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:52:07Z"}, "message": "translate tuple-variant constructors using MIR", "tree": {"sha": "f6eff24a41ef82f9a95b57c84febb8765948cd74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6eff24a41ef82f9a95b57c84febb8765948cd74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0af3775dd2c93cdaf8902f83eb21037e474e058f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0af3775dd2c93cdaf8902f83eb21037e474e058f", "html_url": "https://github.com/rust-lang/rust/commit/0af3775dd2c93cdaf8902f83eb21037e474e058f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0af3775dd2c93cdaf8902f83eb21037e474e058f/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a559452b05c20041a27f518d262573c56b876b64", "url": "https://api.github.com/repos/rust-lang/rust/commits/a559452b05c20041a27f518d262573c56b876b64", "html_url": "https://github.com/rust-lang/rust/commit/a559452b05c20041a27f518d262573c56b876b64"}], "stats": {"total": 353, "additions": 215, "deletions": 138}, "files": [{"sha": "360fa24bf36876e8a54a93f99ccb4324a81b48a9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -1264,10 +1264,17 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                     def_id,\n                                                     ROOT_CODE_EXTENT)\n             }\n-            _ => {\n+            Some(hir_map::NodeStructCtor(..)) |\n+            Some(hir_map::NodeVariant(..)) => {\n+                let def_id = tcx.hir.local_def_id(id);\n+                tcx.construct_parameter_environment(tcx.hir.span(id),\n+                                                    def_id,\n+                                                    ROOT_CODE_EXTENT)\n+            }\n+            it => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n-                      `{}` is not an item\",\n-                     tcx.hir.node_to_string(id))\n+                      `{}` = {:?} is unsupported\",\n+                     tcx.hir.node_to_string(id), it)\n             }\n         }\n     }"}, {"sha": "044ed529ef74cfa50c96f36683172d5a04999174", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None,\n+            mir: self.encode_mir(def_id),\n         }\n     }\n \n@@ -426,7 +426,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None,\n+            mir: self.encode_mir(def_id),\n         }\n     }\n "}, {"sha": "19028bfa531be3f415c28ebc19cd1e65c93a8314", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -22,6 +22,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(associated_consts)]\n #![feature(box_patterns)]\n+#![feature(box_syntax)]\n #![feature(i128_type)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -50,6 +51,7 @@ pub mod callgraph;\n pub mod def_use;\n pub mod graphviz;\n mod hair;\n+mod shim;\n pub mod mir_map;\n pub mod pretty;\n pub mod transform;"}, {"sha": "3fa7131a2b6b001a58ff981735388faf5ea68c12", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -22,6 +22,7 @@ use rustc::dep_graph::DepNode;\n use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n+use shim;\n use pretty;\n use hair::cx::Cx;\n \n@@ -30,6 +31,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -44,6 +46,31 @@ pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n             tcx.item_mir(body_owner_def_id);\n         });\n+\n+        // Tuple struct/variant constructors don't have a BodyId, so we need\n+        // to build them separately.\n+        struct GatherCtors<'a, 'tcx: 'a> {\n+            tcx: TyCtxt<'a, 'tcx, 'tcx>\n+        }\n+        impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n+            fn visit_variant_data(&mut self,\n+                                  v: &'tcx hir::VariantData,\n+                                  _: ast::Name,\n+                                  _: &'tcx hir::Generics,\n+                                  _: ast::NodeId,\n+                                  _: Span) {\n+                if let hir::VariantData::Tuple(_, node_id) = *v {\n+                    self.tcx.item_mir(self.tcx.hir.local_def_id(node_id));\n+                }\n+                intravisit::walk_struct_def(self, v)\n+            }\n+            fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n+                NestedVisitorMap::None\n+            }\n+        }\n+        tcx.visit_all_item_likes_in_krate(DepNode::Mir, &mut GatherCtors {\n+            tcx: tcx\n+        }.as_deep_visitor());\n     }\n }\n \n@@ -95,6 +122,10 @@ fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                 _ => hir::BodyId { node_id: expr.id }\n             }\n         }\n+        hir::map::NodeVariant(variant) =>\n+            return create_constructor_shim(tcx, id, &variant.node.data),\n+        hir::map::NodeStructCtor(ctor) =>\n+            return create_constructor_shim(tcx, id, ctor),\n         _ => unsupported()\n     };\n \n@@ -180,6 +211,38 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n     }\n }\n \n+fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     ctor_id: ast::NodeId,\n+                                     v: &'tcx hir::VariantData)\n+                                     -> &'tcx RefCell<Mir<'tcx>>\n+{\n+    let span = tcx.hir.span(ctor_id);\n+    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n+        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n+        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n+            let (mut mir, src) =\n+                shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n+\n+            // Convert the Mir to global types.\n+            let tcx = infcx.tcx.global_tcx();\n+            let mut globalizer = GlobalizeMir {\n+                tcx: tcx,\n+                span: mir.span\n+            };\n+            globalizer.visit_mir(&mut mir);\n+            let mir = unsafe {\n+                mem::transmute::<Mir, Mir<'tcx>>(mir)\n+            };\n+\n+            pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n+\n+            tcx.alloc_mir(mir)\n+        })\n+    } else {\n+        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n "}, {"sha": "3705a317715f422610afa3a4fbd68ecd77d4d9e6", "filename": "src/librustc_mir/shim.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::infer;\n+use rustc::mir::*;\n+use rustc::mir::transform::MirSource;\n+use rustc::ty;\n+\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n+use syntax::ast;\n+use syntax_pos::Span;\n+\n+use std::iter;\n+\n+fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>)\n+    -> IndexVec<Local, LocalDecl<'tcx>>\n+{\n+    iter::once(LocalDecl {\n+        mutability: Mutability::Mut,\n+        ty: sig.output(),\n+        name: None,\n+        source_info: None\n+    }).chain(sig.inputs().iter().map(|ity| LocalDecl {\n+        mutability: Mutability::Not,\n+        ty: *ity,\n+        name: None,\n+        source_info: None,\n+    })).collect()\n+}\n+\n+pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n+                                      ctor_id: ast::NodeId,\n+                                      fields: &[hir::StructField],\n+                                      span: Span)\n+                                      -> (Mir<'tcx>, MirSource)\n+{\n+    let tcx = infcx.tcx;\n+    let def_id = tcx.hir.local_def_id(ctor_id);\n+    let sig = match tcx.item_type(def_id).sty {\n+        ty::TyFnDef(_, _, fty) => tcx.no_late_bound_regions(&fty)\n+            .expect(\"LBR in ADT constructor signature\"),\n+        _ => bug!(\"unexpected type for ctor {:?}\", def_id)\n+    };\n+    let sig = tcx.erase_regions(&sig);\n+\n+    let (adt_def, substs) = match sig.output().sty {\n+        ty::TyAdt(adt_def, substs) => (adt_def, substs),\n+        _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output())\n+    };\n+\n+    debug!(\"build_ctor: def_id={:?} sig={:?} fields={:?}\", def_id, sig, fields);\n+\n+    let local_decls = local_decls_for_sig(&sig);\n+\n+    let source_info = SourceInfo {\n+        span: span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE\n+    };\n+\n+    let variant_no = if adt_def.is_enum() {\n+        adt_def.variant_index_with_id(def_id)\n+    } else {\n+        0\n+    };\n+\n+    // return = ADT(arg0, arg1, ...); return\n+    let start_block = BasicBlockData {\n+        statements: vec![Statement {\n+            source_info: source_info,\n+            kind: StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Aggregate(\n+                    AggregateKind::Adt(adt_def, variant_no, substs, None),\n+                    (1..sig.inputs().len()+1).map(|i| {\n+                        Operand::Consume(Lvalue::Local(Local::new(i)))\n+                    }).collect()\n+                )\n+            )\n+        }],\n+        terminator: Some(Terminator {\n+            source_info: source_info,\n+            kind: TerminatorKind::Return,\n+        }),\n+        is_cleanup: false\n+    };\n+\n+    let mir = Mir::new(\n+        IndexVec::from_elem_n(start_block, 1),\n+        IndexVec::from_elem_n(\n+            VisibilityScopeData { span: span, parent_scope: None }, 1\n+        ),\n+        IndexVec::new(),\n+        sig.output(),\n+        local_decls,\n+        sig.inputs().len(),\n+        vec![],\n+        span\n+    );\n+    (mir, MirSource::Fn(ctor_id))\n+}"}, {"sha": "fe2b21895cce672d8e892ad0ee76c7db29ca4647", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 74, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -34,10 +34,8 @@ use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n-use rustc::ty::subst::Substs;\n-use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n@@ -47,9 +45,8 @@ use rustc::util::common::time;\n use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::{self, DataTypeKind, Session};\n-use abi::{self, FnType};\n+use abi;\n use mir::lvalue::LvalueRef;\n-use adt;\n use attributes;\n use builder::Builder;\n use callee::{Callee};\n@@ -65,7 +62,7 @@ use context::{SharedCrateContext, CrateContextList};\n use debuginfo;\n use declare;\n use machine;\n-use machine::{llalign_of_min, llsize_of};\n+use machine::llsize_of;\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n@@ -76,7 +73,6 @@ use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n use type_of;\n use value::Value;\n-use Disr;\n use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n@@ -615,72 +611,6 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n-pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 def_id: DefId,\n-                                 substs: &'tcx Substs<'tcx>,\n-                                 disr: Disr,\n-                                 llfn: ValueRef) {\n-    attributes::inline(llfn, attributes::InlineAttr::Hint);\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-\n-    let ctor_ty = common::def_ty(ccx.shared(), def_id, substs);\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n-    let fn_ty = FnType::new(ccx, sig, &[]);\n-\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-    if !fn_ty.ret.is_ignore() {\n-        // But if there are no nested returns, we skip the indirection\n-        // and have a single retslot\n-        let dest = if fn_ty.ret.is_indirect() {\n-            get_param(llfn, 0)\n-        } else {\n-            // We create an alloca to hold a pointer of type `ret.original_ty`\n-            // which will hold the pointer to the right alloca which has the\n-            // final ret value\n-            bcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n-        };\n-        // Can return unsized value\n-        let mut dest_val = LvalueRef::new_sized_ty(dest, sig.output(), Alignment::AbiAligned);\n-        dest_val.ty = LvalueTy::Downcast {\n-            adt_def: sig.output().ty_adt_def().unwrap(),\n-            substs: substs,\n-            variant_index: disr.0 as usize,\n-        };\n-        let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n-        let mut arg_idx = 0;\n-        for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let (lldestptr, _) = dest_val.trans_field_ptr(&bcx, i);\n-            let arg = &fn_ty.args[arg_idx];\n-            arg_idx += 1;\n-            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n-                let meta = &fn_ty.args[arg_idx];\n-                arg_idx += 1;\n-                arg.store_fn_arg(&bcx, &mut llarg_idx, get_dataptr(&bcx, lldestptr));\n-                meta.store_fn_arg(&bcx, &mut llarg_idx, get_meta(&bcx, lldestptr));\n-            } else {\n-                arg.store_fn_arg(&bcx, &mut llarg_idx, lldestptr);\n-            }\n-        }\n-        adt::trans_set_discr(&bcx, sig.output(), dest, disr);\n-\n-        if fn_ty.ret.is_indirect() {\n-            bcx.ret_void();\n-            return;\n-        }\n-\n-        if let Some(cast_ty) = fn_ty.ret.cast {\n-            bcx.ret(bcx.load(\n-                bcx.pointercast(dest, cast_ty.ptr_to()),\n-                Some(llalign_of_min(ccx, fn_ty.ret.ty))\n-            ));\n-        } else {\n-            bcx.ret(bcx.load(dest, None))\n-        }\n-    } else {\n-        bcx.ret_void();\n-    }\n-}\n-\n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n@@ -721,7 +651,7 @@ pub fn set_link_section(ccx: &CrateContext,\n }\n \n /// Create the `main` function which will initialise the rust runtime and call\n-/// users\u2019 main function.\n+/// users main function.\n pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n     let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n         Some((id, span)) => {"}, {"sha": "a5b42a973cf271839bfc7b9b0754ca714a00ddd6", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -22,7 +22,6 @@ use rustc::ty::subst::{Substs, Subst};\n use rustc::traits;\n use abi::{Abi, FnType};\n use attributes;\n-use base;\n use builder::Builder;\n use common::{self, CrateContext};\n use cleanup::CleanupScope;\n@@ -35,7 +34,6 @@ use meth;\n use monomorphize::Instance;\n use trans_item::TransItem;\n use type_of;\n-use Disr;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::hir;\n use std::iter;\n@@ -46,9 +44,6 @@ use mir::lvalue::Alignment;\n \n #[derive(Debug)]\n pub enum CalleeData {\n-    /// Constructor for enum variant/tuple-like-struct.\n-    NamedTupleConstructor(Disr),\n-\n     /// Function pointer.\n     Fn(ValueRef),\n \n@@ -92,16 +87,6 @@ impl<'tcx> Callee<'tcx> {\n             }\n         }\n \n-        // FIXME(eddyb) Detect ADT constructors more efficiently.\n-        if let Some(adt_def) = fn_ty.fn_ret().skip_binder().ty_adt_def() {\n-            if let Some(i) = adt_def.variants.iter().position(|v| def_id == v.did) {\n-                return Callee {\n-                    data: NamedTupleConstructor(Disr::for_variant(tcx, adt_def, i)),\n-                    ty: fn_ty\n-                };\n-            }\n-        }\n-\n         let (llfn, ty) = get_fn(ccx, def_id, substs);\n         Callee::ptr(llfn, ty)\n     }\n@@ -185,24 +170,6 @@ impl<'tcx> Callee<'tcx> {\n         match self.data {\n             Fn(llfn) => llfn,\n             Virtual(_) => meth::trans_object_shim(ccx, self),\n-            NamedTupleConstructor(disr) => match self.ty.sty {\n-                ty::TyFnDef(def_id, substs, _) => {\n-                    let instance = Instance::new(def_id, substs);\n-                    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-                        return llfn;\n-                    }\n-\n-                    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                                              TransItem::Fn(instance));\n-                    assert!(!ccx.codegen_unit().contains_item(&TransItem::Fn(instance)));\n-                    let lldecl = declare::define_internal_fn(ccx, &sym, self.ty);\n-                    base::trans_ctor_shim(ccx, def_id, substs, disr, lldecl);\n-                    ccx.instances().borrow_mut().insert(instance, lldecl);\n-\n-                    lldecl\n-                }\n-                _ => bug!(\"expected fn item type, found {}\", self.ty)\n-            },\n             Intrinsic => bug!(\"intrinsic {} getting reified\", self.ty)\n         }\n     }"}, {"sha": "5e6b10f826ce07f890098dac81caf7fd398129eb", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -630,14 +630,15 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                               -> bool {\n             match tcx.item_type(def_id).sty {\n                 ty::TyFnDef(def_id, _, _) => {\n-                    // Some constructors also have type TyFnDef but they are\n-                    // always instantiated inline and don't result in a\n-                    // translation item. Same for FFI functions.\n+                    // foreign items are linked from another library, not\n+                    // translated locally.\n                     if let Some(hir_map::NodeForeignItem(_)) = tcx.hir.get_if_local(def_id) {\n                         return false;\n                     }\n                 }\n-                ty::TyClosure(..) => {}\n+                ty::TyClosure(..) => {\n+                    // TODO: trans items for closures\n+                }\n                 _ => return false\n             }\n \n@@ -697,16 +698,6 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId)\n                                   -> bool {\n-    if let ty::TyFnDef(_, _, sig) = tcx.item_type(def_id).sty {\n-        if let Some(adt_def) = sig.output().skip_binder().ty_adt_def() {\n-            if adt_def.variants.iter().any(|v| def_id == v.did) {\n-                // HACK: ADT constructors are translated in-place and\n-                // do not have a trans-item.\n-                return false;\n-            }\n-        }\n-    }\n-\n     if def_id.is_local() {\n         true\n     } else {"}, {"sha": "0e536d58a56fb924b38a217b4b9c6a07d144ad52", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -37,6 +37,7 @@ use libc::{c_uint, c_char};\n use std::iter;\n \n use syntax::ast;\n+use syntax::attr;\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n \n@@ -601,8 +602,13 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn is_closure(tcx: TyCtxt, def_id: DefId) -> bool {\n-    tcx.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n+pub fn requests_inline(tcx: TyCtxt, def_id: DefId) -> bool {\n+    match tcx.def_key(def_id).disambiguated_data.data {\n+        DefPathData::StructCtor |\n+        DefPathData::EnumVariant(..) |\n+        DefPathData::ClosureExpr => true,\n+        _ => attr::requests_inline(&tcx.get_attrs(def_id)[..]),\n+    }\n }\n \n /// Given a DefId and some Substs, produces the monomorphic item type."}, {"sha": "2f1a2c9134c39f54aa0d8e3e55615df4d09b74fc", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::{self, layout, TypeFoldable};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use base::{self, Lifetime};\n-use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n+use callee::{Callee, CalleeData, Fn, Intrinsic, Virtual};\n use builder::Builder;\n use common::{self, Funclet};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n@@ -491,10 +491,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let fn_ptr = match callee.data {\n-                    NamedTupleConstructor(_) => {\n-                        // FIXME translate this like mir::Rvalue::Aggregate.\n-                        callee.reify(bcx.ccx)\n-                    }\n                     Intrinsic => {\n                         use intrinsic::trans_intrinsic_call;\n "}, {"sha": "5ec9c2a59957dece2eb5d9e30f384e8b9ccaf9e6", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af3775dd2c93cdaf8902f83eb21037e474e058f/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=0af3775dd2c93cdaf8902f83eb21037e474e058f", "patch": "@@ -26,6 +26,7 @@ use monomorphize::Instance;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::definitions::DefPathData;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n use rustc_const_eval::fatal_const_eval_err;\n@@ -178,9 +179,14 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n         }\n \n-        if let ty::TyClosure(..) = mono_ty.sty {\n-            // set an inline hint for all closures\n-            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+        debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n+        match ccx.tcx().def_key(instance.def).disambiguated_data.data {\n+            DefPathData::StructCtor |\n+            DefPathData::EnumVariant(..) |\n+            DefPathData::ClosureExpr => {\n+                attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+            }\n+            _ => {}\n         }\n \n         attributes::from_fn_attrs(ccx, &attrs, lldecl);\n@@ -252,8 +258,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         match *self {\n             TransItem::Fn(ref instance) => {\n                 if self.explicit_linkage(tcx).is_none() &&\n-                   (common::is_closure(tcx, instance.def) ||\n-                    attr::requests_inline(&tcx.get_attrs(instance.def)[..])) {\n+                    common::requests_inline(tcx, instance.def)\n+                {\n                     InstantiationMode::LocalCopy\n                 } else {\n                     InstantiationMode::GloballyShared"}]}