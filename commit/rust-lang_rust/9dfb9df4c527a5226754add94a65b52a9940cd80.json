{"sha": "9dfb9df4c527a5226754add94a65b52a9940cd80", "node_id": "C_kwDOAAsO6NoAKDlkZmI5ZGY0YzUyN2E1MjI2NzU0YWRkOTRhNjViNTJhOTk0MGNkODA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-20T14:18:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-20T14:18:49Z"}, "message": "Auto merge of #13804 - WaffleLapkin:inlay_hint_mods, r=Veykril\n\nSplit inlay hints into modules per hint type\n\nI think this makes the code a lot easier to maintain.", "tree": {"sha": "d9cdf89d49a524ee9fac35214dc90010f9688ea6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9cdf89d49a524ee9fac35214dc90010f9688ea6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dfb9df4c527a5226754add94a65b52a9940cd80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dfb9df4c527a5226754add94a65b52a9940cd80", "html_url": "https://github.com/rust-lang/rust/commit/9dfb9df4c527a5226754add94a65b52a9940cd80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dfb9df4c527a5226754add94a65b52a9940cd80/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccbf8fef9be09ba6aa3cfc90132623a18a65f493", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccbf8fef9be09ba6aa3cfc90132623a18a65f493", "html_url": "https://github.com/rust-lang/rust/commit/ccbf8fef9be09ba6aa3cfc90132623a18a65f493"}, {"sha": "046a5679e36c79b152c484372f020d5945b697a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/046a5679e36c79b152c484372f020d5945b697a0", "html_url": "https://github.com/rust-lang/rust/commit/046a5679e36c79b152c484372f020d5945b697a0"}], "stats": {"total": 5826, "additions": 3003, "deletions": 2823}, "files": [{"sha": "152f31b3a573327a15ea80d0e23b6e8eeaa9be49", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 60, "deletions": 2823, "changes": 2883, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -1,24 +1,26 @@\n use std::fmt;\n \n use either::Either;\n-use hir::{\n-    known, Adjust, AutoBorrow, Callable, HasVisibility, HirDisplay, Mutability, OverloadedDeref,\n-    PointerCast, Safety, Semantics, TypeInfo,\n-};\n-use ide_db::{\n-    base_db::FileRange, famous_defs::FamousDefs, syntax_helpers::node_ext::walk_ty, FxHashMap,\n-    RootDatabase,\n-};\n+use hir::{known, HasVisibility, HirDisplay, Semantics};\n+use ide_db::{base_db::FileRange, famous_defs::FamousDefs, RootDatabase};\n use itertools::Itertools;\n-use stdx::to_lower_snake_case;\n use syntax::{\n-    ast::{self, AstNode, HasArgList, HasGenericParams, HasName, UnaryOp},\n-    match_ast, Direction, NodeOrToken, SmolStr, SyntaxKind, SyntaxNode, SyntaxToken, TextRange,\n-    TextSize, T,\n+    ast::{self, AstNode},\n+    match_ast, NodeOrToken, SyntaxNode, TextRange, TextSize,\n };\n \n use crate::FileId;\n \n+mod closing_brace;\n+mod implicit_static;\n+mod fn_lifetime_fn;\n+mod closure_ret;\n+mod adjustment;\n+mod chaining;\n+mod param_name;\n+mod binding_mode;\n+mod bind_pat;\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct InlayHintsConfig {\n     pub render_colons: bool,\n@@ -227,38 +229,38 @@ fn hints(\n     file_id: FileId,\n     node: SyntaxNode,\n ) {\n-    closing_brace_hints(hints, sema, config, file_id, node.clone());\n+    closing_brace::hints(hints, sema, config, file_id, node.clone());\n     match_ast! {\n         match node {\n             ast::Expr(expr) => {\n-                chaining_hints(hints, sema, &famous_defs, config, file_id, &expr);\n-                adjustment_hints(hints, sema, config, &expr);\n+                chaining::hints(hints, sema, &famous_defs, config, file_id, &expr);\n+                adjustment::hints(hints, sema, config, &expr);\n                 match expr {\n-                    ast::Expr::CallExpr(it) => param_name_hints(hints, sema, config, ast::Expr::from(it)),\n+                    ast::Expr::CallExpr(it) => param_name::hints(hints, sema, config, ast::Expr::from(it)),\n                     ast::Expr::MethodCallExpr(it) => {\n-                        param_name_hints(hints, sema, config, ast::Expr::from(it))\n+                        param_name::hints(hints, sema, config, ast::Expr::from(it))\n                     }\n-                    ast::Expr::ClosureExpr(it) => closure_ret_hints(hints, sema, &famous_defs, config, file_id, it),\n+                    ast::Expr::ClosureExpr(it) => closure_ret::hints(hints, sema, &famous_defs, config, file_id, it),\n                     // We could show reborrows for all expressions, but usually that is just noise to the user\n                     // and the main point here is to show why \"moving\" a mutable reference doesn't necessarily move it\n                     // ast::Expr::PathExpr(_) => reborrow_hints(hints, sema, config, &expr),\n                     _ => None,\n                 }\n             },\n             ast::Pat(it) => {\n-                binding_mode_hints(hints, sema, config, &it);\n+                binding_mode::hints(hints, sema, config, &it);\n                 if let ast::Pat::IdentPat(it) = it {\n-                    bind_pat_hints(hints, sema, config, file_id, &it);\n+                    bind_pat::hints(hints, sema, config, file_id, &it);\n                 }\n                 Some(())\n             },\n             ast::Item(it) => match it {\n                 // FIXME: record impl lifetimes so they aren't being reused in assoc item lifetime inlay hints\n                 ast::Item::Impl(_) => None,\n-                ast::Item::Fn(it) => fn_lifetime_fn_hints(hints, config, it),\n+                ast::Item::Fn(it) => fn_lifetime_fn::hints(hints, config, it),\n                 // static type elisions\n-                ast::Item::Static(it) => implicit_static_hints(hints, config, Either::Left(it)),\n-                ast::Item::Const(it) => implicit_static_hints(hints, config, Either::Right(it)),\n+                ast::Item::Static(it) => implicit_static::hints(hints, config, Either::Left(it)),\n+                ast::Item::Const(it) => implicit_static::hints(hints, config, Either::Right(it)),\n                 _ => None,\n             },\n             // FIXME: fn-ptr type, dyn fn type, and trait object type elisions\n@@ -268,755 +270,6 @@ fn hints(\n     };\n }\n \n-fn closing_brace_hints(\n-    acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<'_, RootDatabase>,\n-    config: &InlayHintsConfig,\n-    file_id: FileId,\n-    node: SyntaxNode,\n-) -> Option<()> {\n-    let min_lines = config.closing_brace_hints_min_lines?;\n-\n-    let name = |it: ast::Name| it.syntax().text_range();\n-\n-    let mut closing_token;\n-    let (label, name_range) = if let Some(item_list) = ast::AssocItemList::cast(node.clone()) {\n-        closing_token = item_list.r_curly_token()?;\n-\n-        let parent = item_list.syntax().parent()?;\n-        match_ast! {\n-            match parent {\n-                ast::Impl(imp) => {\n-                    let imp = sema.to_def(&imp)?;\n-                    let ty = imp.self_ty(sema.db);\n-                    let trait_ = imp.trait_(sema.db);\n-                    let hint_text = match trait_ {\n-                        Some(tr) => format!(\"impl {} for {}\", tr.name(sema.db), ty.display_truncated(sema.db, config.max_length)),\n-                        None => format!(\"impl {}\", ty.display_truncated(sema.db, config.max_length)),\n-                    };\n-                    (hint_text, None)\n-                },\n-                ast::Trait(tr) => {\n-                    (format!(\"trait {}\", tr.name()?), tr.name().map(name))\n-                },\n-                _ => return None,\n-            }\n-        }\n-    } else if let Some(list) = ast::ItemList::cast(node.clone()) {\n-        closing_token = list.r_curly_token()?;\n-\n-        let module = ast::Module::cast(list.syntax().parent()?)?;\n-        (format!(\"mod {}\", module.name()?), module.name().map(name))\n-    } else if let Some(block) = ast::BlockExpr::cast(node.clone()) {\n-        closing_token = block.stmt_list()?.r_curly_token()?;\n-\n-        let parent = block.syntax().parent()?;\n-        match_ast! {\n-            match parent {\n-                ast::Fn(it) => {\n-                    // FIXME: this could include parameters, but `HirDisplay` prints too much info\n-                    // and doesn't respect the max length either, so the hints end up way too long\n-                    (format!(\"fn {}\", it.name()?), it.name().map(name))\n-                },\n-                ast::Static(it) => (format!(\"static {}\", it.name()?), it.name().map(name)),\n-                ast::Const(it) => {\n-                    if it.underscore_token().is_some() {\n-                        (\"const _\".into(), None)\n-                    } else {\n-                        (format!(\"const {}\", it.name()?), it.name().map(name))\n-                    }\n-                },\n-                _ => return None,\n-            }\n-        }\n-    } else if let Some(mac) = ast::MacroCall::cast(node.clone()) {\n-        let last_token = mac.syntax().last_token()?;\n-        if last_token.kind() != T![;] && last_token.kind() != SyntaxKind::R_CURLY {\n-            return None;\n-        }\n-        closing_token = last_token;\n-\n-        (\n-            format!(\"{}!\", mac.path()?),\n-            mac.path().and_then(|it| it.segment()).map(|it| it.syntax().text_range()),\n-        )\n-    } else {\n-        return None;\n-    };\n-\n-    if let Some(mut next) = closing_token.next_token() {\n-        if next.kind() == T![;] {\n-            if let Some(tok) = next.next_token() {\n-                closing_token = next;\n-                next = tok;\n-            }\n-        }\n-        if !(next.kind() == SyntaxKind::WHITESPACE && next.text().contains('\\n')) {\n-            // Only display the hint if the `}` is the last token on the line\n-            return None;\n-        }\n-    }\n-\n-    let mut lines = 1;\n-    node.text().for_each_chunk(|s| lines += s.matches('\\n').count());\n-    if lines < min_lines {\n-        return None;\n-    }\n-\n-    let linked_location = name_range.map(|range| FileRange { file_id, range });\n-    acc.push(InlayHint {\n-        range: closing_token.text_range(),\n-        kind: InlayKind::ClosingBraceHint,\n-        label: InlayHintLabel { parts: vec![InlayHintLabelPart { text: label, linked_location }] },\n-        tooltip: None, // provided by label part location\n-    });\n-\n-    None\n-}\n-\n-fn implicit_static_hints(\n-    acc: &mut Vec<InlayHint>,\n-    config: &InlayHintsConfig,\n-    statik_or_const: Either<ast::Static, ast::Const>,\n-) -> Option<()> {\n-    if config.lifetime_elision_hints != LifetimeElisionHints::Always {\n-        return None;\n-    }\n-\n-    if let Either::Right(it) = &statik_or_const {\n-        if ast::AssocItemList::can_cast(\n-            it.syntax().parent().map_or(SyntaxKind::EOF, |it| it.kind()),\n-        ) {\n-            return None;\n-        }\n-    }\n-\n-    if let Some(ast::Type::RefType(ty)) = statik_or_const.either(|it| it.ty(), |it| it.ty()) {\n-        if ty.lifetime().is_none() {\n-            let t = ty.amp_token()?;\n-            acc.push(InlayHint {\n-                range: t.text_range(),\n-                kind: InlayKind::LifetimeHint,\n-                label: \"'static\".to_owned().into(),\n-                tooltip: Some(InlayTooltip::String(\"Elided static lifetime\".into())),\n-            });\n-        }\n-    }\n-\n-    Some(())\n-}\n-\n-fn fn_lifetime_fn_hints(\n-    acc: &mut Vec<InlayHint>,\n-    config: &InlayHintsConfig,\n-    func: ast::Fn,\n-) -> Option<()> {\n-    if config.lifetime_elision_hints == LifetimeElisionHints::Never {\n-        return None;\n-    }\n-\n-    let mk_lt_hint = |t: SyntaxToken, label: String| InlayHint {\n-        range: t.text_range(),\n-        kind: InlayKind::LifetimeHint,\n-        label: label.into(),\n-        tooltip: Some(InlayTooltip::String(\"Elided lifetime\".into())),\n-    };\n-\n-    let param_list = func.param_list()?;\n-    let generic_param_list = func.generic_param_list();\n-    let ret_type = func.ret_type();\n-    let self_param = param_list.self_param().filter(|it| it.amp_token().is_some());\n-\n-    let is_elided = |lt: &Option<ast::Lifetime>| match lt {\n-        Some(lt) => matches!(lt.text().as_str(), \"'_\"),\n-        None => true,\n-    };\n-\n-    let potential_lt_refs = {\n-        let mut acc: Vec<_> = vec![];\n-        if let Some(self_param) = &self_param {\n-            let lifetime = self_param.lifetime();\n-            let is_elided = is_elided(&lifetime);\n-            acc.push((None, self_param.amp_token(), lifetime, is_elided));\n-        }\n-        param_list.params().filter_map(|it| Some((it.pat(), it.ty()?))).for_each(|(pat, ty)| {\n-            // FIXME: check path types\n-            walk_ty(&ty, &mut |ty| match ty {\n-                ast::Type::RefType(r) => {\n-                    let lifetime = r.lifetime();\n-                    let is_elided = is_elided(&lifetime);\n-                    acc.push((\n-                        pat.as_ref().and_then(|it| match it {\n-                            ast::Pat::IdentPat(p) => p.name(),\n-                            _ => None,\n-                        }),\n-                        r.amp_token(),\n-                        lifetime,\n-                        is_elided,\n-                    ))\n-                }\n-                _ => (),\n-            })\n-        });\n-        acc\n-    };\n-\n-    // allocate names\n-    let mut gen_idx_name = {\n-        let mut gen = (0u8..).map(|idx| match idx {\n-            idx if idx < 10 => SmolStr::from_iter(['\\'', (idx + 48) as char]),\n-            idx => format!(\"'{idx}\").into(),\n-        });\n-        move || gen.next().unwrap_or_default()\n-    };\n-    let mut allocated_lifetimes = vec![];\n-\n-    let mut used_names: FxHashMap<SmolStr, usize> =\n-        match config.param_names_for_lifetime_elision_hints {\n-            true => generic_param_list\n-                .iter()\n-                .flat_map(|gpl| gpl.lifetime_params())\n-                .filter_map(|param| param.lifetime())\n-                .filter_map(|lt| Some((SmolStr::from(lt.text().as_str().get(1..)?), 0)))\n-                .collect(),\n-            false => Default::default(),\n-        };\n-    {\n-        let mut potential_lt_refs = potential_lt_refs.iter().filter(|&&(.., is_elided)| is_elided);\n-        if let Some(_) = &self_param {\n-            if let Some(_) = potential_lt_refs.next() {\n-                allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n-                    // self can't be used as a lifetime, so no need to check for collisions\n-                    \"'self\".into()\n-                } else {\n-                    gen_idx_name()\n-                });\n-            }\n-        }\n-        potential_lt_refs.for_each(|(name, ..)| {\n-            let name = match name {\n-                Some(it) if config.param_names_for_lifetime_elision_hints => {\n-                    if let Some(c) = used_names.get_mut(it.text().as_str()) {\n-                        *c += 1;\n-                        SmolStr::from(format!(\"'{text}{c}\", text = it.text().as_str()))\n-                    } else {\n-                        used_names.insert(it.text().as_str().into(), 0);\n-                        SmolStr::from_iter([\"\\'\", it.text().as_str()])\n-                    }\n-                }\n-                _ => gen_idx_name(),\n-            };\n-            allocated_lifetimes.push(name);\n-        });\n-    }\n-\n-    // fetch output lifetime if elision rule applies\n-    let output = match potential_lt_refs.as_slice() {\n-        [(_, _, lifetime, _), ..] if self_param.is_some() || potential_lt_refs.len() == 1 => {\n-            match lifetime {\n-                Some(lt) => match lt.text().as_str() {\n-                    \"'_\" => allocated_lifetimes.get(0).cloned(),\n-                    \"'static\" => None,\n-                    name => Some(name.into()),\n-                },\n-                None => allocated_lifetimes.get(0).cloned(),\n-            }\n-        }\n-        [..] => None,\n-    };\n-\n-    if allocated_lifetimes.is_empty() && output.is_none() {\n-        return None;\n-    }\n-\n-    // apply hints\n-    // apply output if required\n-    let mut is_trivial = true;\n-    if let (Some(output_lt), Some(r)) = (&output, ret_type) {\n-        if let Some(ty) = r.ty() {\n-            walk_ty(&ty, &mut |ty| match ty {\n-                ast::Type::RefType(ty) if ty.lifetime().is_none() => {\n-                    if let Some(amp) = ty.amp_token() {\n-                        is_trivial = false;\n-                        acc.push(mk_lt_hint(amp, output_lt.to_string()));\n-                    }\n-                }\n-                _ => (),\n-            })\n-        }\n-    }\n-\n-    if config.lifetime_elision_hints == LifetimeElisionHints::SkipTrivial && is_trivial {\n-        return None;\n-    }\n-\n-    let mut a = allocated_lifetimes.iter();\n-    for (_, amp_token, _, is_elided) in potential_lt_refs {\n-        if is_elided {\n-            let t = amp_token?;\n-            let lt = a.next()?;\n-            acc.push(mk_lt_hint(t, lt.to_string()));\n-        }\n-    }\n-\n-    // generate generic param list things\n-    match (generic_param_list, allocated_lifetimes.as_slice()) {\n-        (_, []) => (),\n-        (Some(gpl), allocated_lifetimes) => {\n-            let angle_tok = gpl.l_angle_token()?;\n-            let is_empty = gpl.generic_params().next().is_none();\n-            acc.push(InlayHint {\n-                range: angle_tok.text_range(),\n-                kind: InlayKind::LifetimeHint,\n-                label: format!(\n-                    \"{}{}\",\n-                    allocated_lifetimes.iter().format(\", \"),\n-                    if is_empty { \"\" } else { \", \" }\n-                )\n-                .into(),\n-                tooltip: Some(InlayTooltip::String(\"Elided lifetimes\".into())),\n-            });\n-        }\n-        (None, allocated_lifetimes) => acc.push(InlayHint {\n-            range: func.name()?.syntax().text_range(),\n-            kind: InlayKind::GenericParamListHint,\n-            label: format!(\"<{}>\", allocated_lifetimes.iter().format(\", \"),).into(),\n-            tooltip: Some(InlayTooltip::String(\"Elided lifetimes\".into())),\n-        }),\n-    }\n-    Some(())\n-}\n-\n-fn closure_ret_hints(\n-    acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<'_, RootDatabase>,\n-    famous_defs: &FamousDefs<'_, '_>,\n-    config: &InlayHintsConfig,\n-    file_id: FileId,\n-    closure: ast::ClosureExpr,\n-) -> Option<()> {\n-    if config.closure_return_type_hints == ClosureReturnTypeHints::Never {\n-        return None;\n-    }\n-\n-    if closure.ret_type().is_some() {\n-        return None;\n-    }\n-\n-    if !closure_has_block_body(&closure)\n-        && config.closure_return_type_hints == ClosureReturnTypeHints::WithBlock\n-    {\n-        return None;\n-    }\n-\n-    let param_list = closure.param_list()?;\n-\n-    let closure = sema.descend_node_into_attributes(closure.clone()).pop()?;\n-    let ty = sema.type_of_expr(&ast::Expr::ClosureExpr(closure))?.adjusted();\n-    let callable = ty.as_callable(sema.db)?;\n-    let ty = callable.return_type();\n-    if ty.is_unit() {\n-        return None;\n-    }\n-    acc.push(InlayHint {\n-        range: param_list.syntax().text_range(),\n-        kind: InlayKind::ClosureReturnTypeHint,\n-        label: hint_iterator(sema, &famous_defs, config, &ty)\n-            .unwrap_or_else(|| ty.display_truncated(sema.db, config.max_length).to_string())\n-            .into(),\n-        tooltip: Some(InlayTooltip::HoverRanged(file_id, param_list.syntax().text_range())),\n-    });\n-    Some(())\n-}\n-\n-fn adjustment_hints(\n-    acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<'_, RootDatabase>,\n-    config: &InlayHintsConfig,\n-    expr: &ast::Expr,\n-) -> Option<()> {\n-    if config.adjustment_hints == AdjustmentHints::Never {\n-        return None;\n-    }\n-\n-    // These inherit from the inner expression which would result in duplicate hints\n-    if let ast::Expr::ParenExpr(_)\n-    | ast::Expr::IfExpr(_)\n-    | ast::Expr::BlockExpr(_)\n-    | ast::Expr::MatchExpr(_) = expr\n-    {\n-        return None;\n-    }\n-\n-    let parent = expr.syntax().parent().and_then(ast::Expr::cast);\n-    let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n-    let desc_expr = descended.as_ref().unwrap_or(expr);\n-    let adjustments = sema.expr_adjustments(desc_expr).filter(|it| !it.is_empty())?;\n-    let needs_parens = match parent {\n-        Some(parent) => {\n-            match parent {\n-                ast::Expr::AwaitExpr(_)\n-                | ast::Expr::CallExpr(_)\n-                | ast::Expr::CastExpr(_)\n-                | ast::Expr::FieldExpr(_)\n-                | ast::Expr::MethodCallExpr(_)\n-                | ast::Expr::TryExpr(_) => true,\n-                // FIXME: shorthands need special casing, though not sure if adjustments are even valid there\n-                ast::Expr::RecordExpr(_) => false,\n-                ast::Expr::IndexExpr(index) => index.base().as_ref() == Some(expr),\n-                _ => false,\n-            }\n-        }\n-        None => false,\n-    };\n-    if needs_parens {\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::OpeningParenthesis,\n-            label: \"(\".into(),\n-            tooltip: None,\n-        });\n-    }\n-    for adjustment in adjustments.into_iter().rev() {\n-        // FIXME: Add some nicer tooltips to each of these\n-        let text = match adjustment {\n-            Adjust::NeverToAny if config.adjustment_hints == AdjustmentHints::Always => {\n-                \"<never-to-any>\"\n-            }\n-            Adjust::Deref(None) => \"*\",\n-            Adjust::Deref(Some(OverloadedDeref(Mutability::Mut))) => \"*\",\n-            Adjust::Deref(Some(OverloadedDeref(Mutability::Shared))) => \"*\",\n-            Adjust::Borrow(AutoBorrow::Ref(Mutability::Shared)) => \"&\",\n-            Adjust::Borrow(AutoBorrow::Ref(Mutability::Mut)) => \"&mut \",\n-            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Shared)) => \"&raw const \",\n-            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Mut)) => \"&raw mut \",\n-            // some of these could be represented via `as` casts, but that's not too nice and\n-            // handling everything as a prefix expr makes the `(` and `)` insertion easier\n-            Adjust::Pointer(cast) if config.adjustment_hints == AdjustmentHints::Always => {\n-                match cast {\n-                    PointerCast::ReifyFnPointer => \"<fn-item-to-fn-pointer>\",\n-                    PointerCast::UnsafeFnPointer => \"<safe-fn-pointer-to-unsafe-fn-pointer>\",\n-                    PointerCast::ClosureFnPointer(Safety::Unsafe) => {\n-                        \"<closure-to-unsafe-fn-pointer>\"\n-                    }\n-                    PointerCast::ClosureFnPointer(Safety::Safe) => \"<closure-to-fn-pointer>\",\n-                    PointerCast::MutToConstPointer => \"<mut-ptr-to-const-ptr>\",\n-                    PointerCast::ArrayToPointer => \"<array-ptr-to-element-ptr>\",\n-                    PointerCast::Unsize => \"<unsize>\",\n-                }\n-            }\n-            _ => continue,\n-        };\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::AdjustmentHint,\n-            label: text.into(),\n-            tooltip: None,\n-        });\n-    }\n-    if needs_parens {\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::ClosingParenthesis,\n-            label: \")\".into(),\n-            tooltip: None,\n-        });\n-    }\n-    Some(())\n-}\n-\n-fn chaining_hints(\n-    acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<'_, RootDatabase>,\n-    famous_defs: &FamousDefs<'_, '_>,\n-    config: &InlayHintsConfig,\n-    file_id: FileId,\n-    expr: &ast::Expr,\n-) -> Option<()> {\n-    if !config.chaining_hints {\n-        return None;\n-    }\n-\n-    if matches!(expr, ast::Expr::RecordExpr(_)) {\n-        return None;\n-    }\n-\n-    let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n-    let desc_expr = descended.as_ref().unwrap_or(expr);\n-\n-    let mut tokens = expr\n-        .syntax()\n-        .siblings_with_tokens(Direction::Next)\n-        .filter_map(NodeOrToken::into_token)\n-        .filter(|t| match t.kind() {\n-            SyntaxKind::WHITESPACE if !t.text().contains('\\n') => false,\n-            SyntaxKind::COMMENT => false,\n-            _ => true,\n-        });\n-\n-    // Chaining can be defined as an expression whose next sibling tokens are newline and dot\n-    // Ignoring extra whitespace and comments\n-    let next = tokens.next()?.kind();\n-    if next == SyntaxKind::WHITESPACE {\n-        let mut next_next = tokens.next()?.kind();\n-        while next_next == SyntaxKind::WHITESPACE {\n-            next_next = tokens.next()?.kind();\n-        }\n-        if next_next == T![.] {\n-            let ty = sema.type_of_expr(desc_expr)?.original;\n-            if ty.is_unknown() {\n-                return None;\n-            }\n-            if matches!(expr, ast::Expr::PathExpr(_)) {\n-                if let Some(hir::Adt::Struct(st)) = ty.as_adt() {\n-                    if st.fields(sema.db).is_empty() {\n-                        return None;\n-                    }\n-                }\n-            }\n-            acc.push(InlayHint {\n-                range: expr.syntax().text_range(),\n-                kind: InlayKind::ChainingHint,\n-                label: hint_iterator(sema, &famous_defs, config, &ty)\n-                    .unwrap_or_else(|| ty.display_truncated(sema.db, config.max_length).to_string())\n-                    .into(),\n-                tooltip: Some(InlayTooltip::HoverRanged(file_id, expr.syntax().text_range())),\n-            });\n-        }\n-    }\n-    Some(())\n-}\n-\n-fn param_name_hints(\n-    acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<'_, RootDatabase>,\n-    config: &InlayHintsConfig,\n-    expr: ast::Expr,\n-) -> Option<()> {\n-    if !config.parameter_hints {\n-        return None;\n-    }\n-\n-    let (callable, arg_list) = get_callable(sema, &expr)?;\n-    let hints = callable\n-        .params(sema.db)\n-        .into_iter()\n-        .zip(arg_list.args())\n-        .filter_map(|((param, _ty), arg)| {\n-            // Only annotate hints for expressions that exist in the original file\n-            let range = sema.original_range_opt(arg.syntax())?;\n-            let (param_name, name_syntax) = match param.as_ref()? {\n-                Either::Left(pat) => (\"self\".to_string(), pat.name()),\n-                Either::Right(pat) => match pat {\n-                    ast::Pat::IdentPat(it) => (it.name()?.to_string(), it.name()),\n-                    _ => return None,\n-                },\n-            };\n-            Some((name_syntax, param_name, arg, range))\n-        })\n-        .filter(|(_, param_name, arg, _)| {\n-            !should_hide_param_name_hint(sema, &callable, param_name, arg)\n-        })\n-        .map(|(param, param_name, _, FileRange { range, .. })| {\n-            let mut tooltip = None;\n-            if let Some(name) = param {\n-                if let hir::CallableKind::Function(f) = callable.kind() {\n-                    // assert the file is cached so we can map out of macros\n-                    if let Some(_) = sema.source(f) {\n-                        tooltip = sema.original_range_opt(name.syntax());\n-                    }\n-                }\n-            }\n-\n-            InlayHint {\n-                range,\n-                kind: InlayKind::ParameterHint,\n-                label: param_name.into(),\n-                tooltip: tooltip.map(|it| InlayTooltip::HoverOffset(it.file_id, it.range.start())),\n-            }\n-        });\n-\n-    acc.extend(hints);\n-    Some(())\n-}\n-\n-fn binding_mode_hints(\n-    acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<'_, RootDatabase>,\n-    config: &InlayHintsConfig,\n-    pat: &ast::Pat,\n-) -> Option<()> {\n-    if !config.binding_mode_hints {\n-        return None;\n-    }\n-\n-    let outer_paren_pat = pat\n-        .syntax()\n-        .ancestors()\n-        .skip(1)\n-        .map_while(ast::Pat::cast)\n-        .map_while(|pat| match pat {\n-            ast::Pat::ParenPat(pat) => Some(pat),\n-            _ => None,\n-        })\n-        .last();\n-    let range =\n-        outer_paren_pat.as_ref().map_or_else(|| pat.syntax(), |it| it.syntax()).text_range();\n-    sema.pattern_adjustments(&pat).iter().for_each(|ty| {\n-        let reference = ty.is_reference();\n-        let mut_reference = ty.is_mutable_reference();\n-        let r = match (reference, mut_reference) {\n-            (true, true) => \"&mut\",\n-            (true, false) => \"&\",\n-            _ => return,\n-        };\n-        acc.push(InlayHint {\n-            range,\n-            kind: InlayKind::BindingModeHint,\n-            label: r.to_string().into(),\n-            tooltip: Some(InlayTooltip::String(\"Inferred binding mode\".into())),\n-        });\n-    });\n-    match pat {\n-        ast::Pat::IdentPat(pat) if pat.ref_token().is_none() && pat.mut_token().is_none() => {\n-            let bm = sema.binding_mode_of_pat(pat)?;\n-            let bm = match bm {\n-                hir::BindingMode::Move => return None,\n-                hir::BindingMode::Ref(Mutability::Mut) => \"ref mut\",\n-                hir::BindingMode::Ref(Mutability::Shared) => \"ref\",\n-            };\n-            acc.push(InlayHint {\n-                range: pat.syntax().text_range(),\n-                kind: InlayKind::BindingModeHint,\n-                label: bm.to_string().into(),\n-                tooltip: Some(InlayTooltip::String(\"Inferred binding mode\".into())),\n-            });\n-        }\n-        ast::Pat::OrPat(pat) if outer_paren_pat.is_none() => {\n-            acc.push(InlayHint {\n-                range: pat.syntax().text_range(),\n-                kind: InlayKind::OpeningParenthesis,\n-                label: \"(\".into(),\n-                tooltip: None,\n-            });\n-            acc.push(InlayHint {\n-                range: pat.syntax().text_range(),\n-                kind: InlayKind::ClosingParenthesis,\n-                label: \")\".into(),\n-                tooltip: None,\n-            });\n-        }\n-        _ => (),\n-    }\n-\n-    Some(())\n-}\n-\n-fn bind_pat_hints(\n-    acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<'_, RootDatabase>,\n-    config: &InlayHintsConfig,\n-    file_id: FileId,\n-    pat: &ast::IdentPat,\n-) -> Option<()> {\n-    if !config.type_hints {\n-        return None;\n-    }\n-\n-    let descended = sema.descend_node_into_attributes(pat.clone()).pop();\n-    let desc_pat = descended.as_ref().unwrap_or(pat);\n-    let ty = sema.type_of_pat(&desc_pat.clone().into())?.original;\n-\n-    if should_not_display_type_hint(sema, config, pat, &ty) {\n-        return None;\n-    }\n-\n-    let krate = sema.scope(desc_pat.syntax())?.krate();\n-    let famous_defs = FamousDefs(sema, krate);\n-    let label = hint_iterator(sema, &famous_defs, config, &ty);\n-\n-    let label = match label {\n-        Some(label) => label,\n-        None => {\n-            let ty_name = ty.display_truncated(sema.db, config.max_length).to_string();\n-            if config.hide_named_constructor_hints\n-                && is_named_constructor(sema, pat, &ty_name).is_some()\n-            {\n-                return None;\n-            }\n-            ty_name\n-        }\n-    };\n-\n-    acc.push(InlayHint {\n-        range: match pat.name() {\n-            Some(name) => name.syntax().text_range(),\n-            None => pat.syntax().text_range(),\n-        },\n-        kind: InlayKind::TypeHint,\n-        label: label.into(),\n-        tooltip: pat\n-            .name()\n-            .map(|it| it.syntax().text_range())\n-            .map(|it| InlayTooltip::HoverRanged(file_id, it)),\n-    });\n-\n-    Some(())\n-}\n-\n-fn is_named_constructor(\n-    sema: &Semantics<'_, RootDatabase>,\n-    pat: &ast::IdentPat,\n-    ty_name: &str,\n-) -> Option<()> {\n-    let let_node = pat.syntax().parent()?;\n-    let expr = match_ast! {\n-        match let_node {\n-            ast::LetStmt(it) => it.initializer(),\n-            ast::LetExpr(it) => it.expr(),\n-            _ => None,\n-        }\n-    }?;\n-\n-    let expr = sema.descend_node_into_attributes(expr.clone()).pop().unwrap_or(expr);\n-    // unwrap postfix expressions\n-    let expr = match expr {\n-        ast::Expr::TryExpr(it) => it.expr(),\n-        ast::Expr::AwaitExpr(it) => it.expr(),\n-        expr => Some(expr),\n-    }?;\n-    let expr = match expr {\n-        ast::Expr::CallExpr(call) => match call.expr()? {\n-            ast::Expr::PathExpr(path) => path,\n-            _ => return None,\n-        },\n-        ast::Expr::PathExpr(path) => path,\n-        _ => return None,\n-    };\n-    let path = expr.path()?;\n-\n-    let callable = sema.type_of_expr(&ast::Expr::PathExpr(expr))?.original.as_callable(sema.db);\n-    let callable_kind = callable.map(|it| it.kind());\n-    let qual_seg = match callable_kind {\n-        Some(hir::CallableKind::Function(_) | hir::CallableKind::TupleEnumVariant(_)) => {\n-            path.qualifier()?.segment()\n-        }\n-        _ => path.segment(),\n-    }?;\n-\n-    let ctor_name = match qual_seg.kind()? {\n-        ast::PathSegmentKind::Name(name_ref) => {\n-            match qual_seg.generic_arg_list().map(|it| it.generic_args()) {\n-                Some(generics) => format!(\"{}<{}>\", name_ref, generics.format(\", \")),\n-                None => name_ref.to_string(),\n-            }\n-        }\n-        ast::PathSegmentKind::Type { type_ref: Some(ty), trait_ref: None } => ty.to_string(),\n-        _ => return None,\n-    };\n-    (ctor_name == ty_name).then(|| ())\n-}\n-\n /// Checks if the type is an Iterator from std::iter and replaces its hint with an `impl Iterator<Item = Ty>`.\n fn hint_iterator(\n     sema: &Semantics<'_, RootDatabase>,\n@@ -1067,317 +320,53 @@ fn hint_iterator(\n     None\n }\n \n-fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir::Type) -> bool {\n-    if let Some(hir::Adt::Enum(enum_data)) = pat_ty.as_adt() {\n-        let pat_text = bind_pat.to_string();\n-        enum_data\n-            .variants(db)\n-            .into_iter()\n-            .map(|variant| variant.name(db).to_smol_str())\n-            .any(|enum_name| enum_name == pat_text)\n-    } else {\n-        false\n-    }\n-}\n-\n-fn should_not_display_type_hint(\n-    sema: &Semantics<'_, RootDatabase>,\n-    config: &InlayHintsConfig,\n-    bind_pat: &ast::IdentPat,\n-    pat_ty: &hir::Type,\n-) -> bool {\n-    let db = sema.db;\n-\n-    if pat_ty.is_unknown() {\n-        return true;\n-    }\n-\n-    if let Some(hir::Adt::Struct(s)) = pat_ty.as_adt() {\n-        if s.fields(db).is_empty() && s.name(db).to_smol_str() == bind_pat.to_string() {\n-            return true;\n-        }\n-    }\n-\n-    if config.hide_closure_initialization_hints {\n-        if let Some(parent) = bind_pat.syntax().parent() {\n-            if let Some(it) = ast::LetStmt::cast(parent.clone()) {\n-                if let Some(ast::Expr::ClosureExpr(closure)) = it.initializer() {\n-                    if closure_has_block_body(&closure) {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    for node in bind_pat.syntax().ancestors() {\n-        match_ast! {\n-            match node {\n-                ast::LetStmt(it) => return it.ty().is_some(),\n-                // FIXME: We might wanna show type hints in parameters for non-top level patterns as well\n-                ast::Param(it) => return it.ty().is_some(),\n-                ast::MatchArm(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n-                ast::LetExpr(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n-                ast::IfExpr(_) => return false,\n-                ast::WhileExpr(_) => return false,\n-                ast::ForExpr(it) => {\n-                    // We *should* display hint only if user provided \"in {expr}\" and we know the type of expr (and it's not unit).\n-                    // Type of expr should be iterable.\n-                    return it.in_token().is_none() ||\n-                        it.iterable()\n-                            .and_then(|iterable_expr| sema.type_of_expr(&iterable_expr))\n-                            .map(TypeInfo::original)\n-                            .map_or(true, |iterable_ty| iterable_ty.is_unknown() || iterable_ty.is_unit())\n-                },\n-                _ => (),\n-            }\n-        }\n-    }\n-    false\n-}\n-\n fn closure_has_block_body(closure: &ast::ClosureExpr) -> bool {\n     matches!(closure.body(), Some(ast::Expr::BlockExpr(_)))\n }\n \n-fn should_hide_param_name_hint(\n-    sema: &Semantics<'_, RootDatabase>,\n-    callable: &hir::Callable,\n-    param_name: &str,\n-    argument: &ast::Expr,\n-) -> bool {\n-    // These are to be tested in the `parameter_hint_heuristics` test\n-    // hide when:\n-    // - the parameter name is a suffix of the function's name\n-    // - the argument is a qualified constructing or call expression where the qualifier is an ADT\n-    // - exact argument<->parameter match(ignoring leading underscore) or parameter is a prefix/suffix\n-    //   of argument with _ splitting it off\n-    // - param starts with `ra_fixture`\n-    // - param is a well known name in a unary function\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::Expect;\n+    use itertools::Itertools;\n+    use test_utils::extract_annotations;\n \n-    let param_name = param_name.trim_start_matches('_');\n-    if param_name.is_empty() {\n-        return true;\n-    }\n+    use crate::inlay_hints::AdjustmentHints;\n+    use crate::{fixture, inlay_hints::InlayHintsConfig, LifetimeElisionHints};\n \n-    if matches!(argument, ast::Expr::PrefixExpr(prefix) if prefix.op_kind() == Some(UnaryOp::Not)) {\n-        return false;\n-    }\n+    use super::ClosureReturnTypeHints;\n \n-    let fn_name = match callable.kind() {\n-        hir::CallableKind::Function(it) => Some(it.name(sema.db).to_smol_str()),\n-        _ => None,\n+    pub(super) const DISABLED_CONFIG: InlayHintsConfig = InlayHintsConfig {\n+        render_colons: false,\n+        type_hints: false,\n+        parameter_hints: false,\n+        chaining_hints: false,\n+        lifetime_elision_hints: LifetimeElisionHints::Never,\n+        closure_return_type_hints: ClosureReturnTypeHints::Never,\n+        adjustment_hints: AdjustmentHints::Never,\n+        binding_mode_hints: false,\n+        hide_named_constructor_hints: false,\n+        hide_closure_initialization_hints: false,\n+        param_names_for_lifetime_elision_hints: false,\n+        max_length: None,\n+        closing_brace_hints_min_lines: None,\n     };\n-    let fn_name = fn_name.as_deref();\n-    is_param_name_suffix_of_fn_name(param_name, callable, fn_name)\n-        || is_argument_similar_to_param_name(argument, param_name)\n-        || param_name.starts_with(\"ra_fixture\")\n-        || (callable.n_params() == 1 && is_obvious_param(param_name))\n-        || is_adt_constructor_similar_to_param_name(sema, argument, param_name)\n-}\n-\n-fn is_argument_similar_to_param_name(argument: &ast::Expr, param_name: &str) -> bool {\n-    // check whether param_name and argument are the same or\n-    // whether param_name is a prefix/suffix of argument(split at `_`)\n-    let argument = match get_string_representation(argument) {\n-        Some(argument) => argument,\n-        None => return false,\n+    pub(super) const TEST_CONFIG: InlayHintsConfig = InlayHintsConfig {\n+        type_hints: true,\n+        parameter_hints: true,\n+        chaining_hints: true,\n+        closure_return_type_hints: ClosureReturnTypeHints::WithBlock,\n+        binding_mode_hints: true,\n+        lifetime_elision_hints: LifetimeElisionHints::Always,\n+        ..DISABLED_CONFIG\n     };\n \n-    // std is honestly too panic happy...\n-    let str_split_at = |str: &str, at| str.is_char_boundary(at).then(|| argument.split_at(at));\n-\n-    let param_name = param_name.trim_start_matches('_');\n-    let argument = argument.trim_start_matches('_');\n-\n-    match str_split_at(argument, param_name.len()) {\n-        Some((prefix, rest)) if prefix.eq_ignore_ascii_case(param_name) => {\n-            return rest.is_empty() || rest.starts_with('_');\n-        }\n-        _ => (),\n-    }\n-    match argument.len().checked_sub(param_name.len()).and_then(|at| str_split_at(argument, at)) {\n-        Some((rest, suffix)) if param_name.eq_ignore_ascii_case(suffix) => {\n-            return rest.is_empty() || rest.ends_with('_');\n-        }\n-        _ => (),\n-    }\n-    false\n-}\n-\n-/// Hide the parameter name of a unary function if it is a `_` - prefixed suffix of the function's name, or equal.\n-///\n-/// `fn strip_suffix(suffix)` will be hidden.\n-/// `fn stripsuffix(suffix)` will not be hidden.\n-fn is_param_name_suffix_of_fn_name(\n-    param_name: &str,\n-    callable: &Callable,\n-    fn_name: Option<&str>,\n-) -> bool {\n-    match (callable.n_params(), fn_name) {\n-        (1, Some(function)) => {\n-            function == param_name\n-                || function\n-                    .len()\n-                    .checked_sub(param_name.len())\n-                    .and_then(|at| function.is_char_boundary(at).then(|| function.split_at(at)))\n-                    .map_or(false, |(prefix, suffix)| {\n-                        suffix.eq_ignore_ascii_case(param_name) && prefix.ends_with('_')\n-                    })\n-        }\n-        _ => false,\n-    }\n-}\n-\n-fn is_adt_constructor_similar_to_param_name(\n-    sema: &Semantics<'_, RootDatabase>,\n-    argument: &ast::Expr,\n-    param_name: &str,\n-) -> bool {\n-    let path = match argument {\n-        ast::Expr::CallExpr(c) => c.expr().and_then(|e| match e {\n-            ast::Expr::PathExpr(p) => p.path(),\n-            _ => None,\n-        }),\n-        ast::Expr::PathExpr(p) => p.path(),\n-        ast::Expr::RecordExpr(r) => r.path(),\n-        _ => return false,\n-    };\n-    let path = match path {\n-        Some(it) => it,\n-        None => return false,\n-    };\n-    (|| match sema.resolve_path(&path)? {\n-        hir::PathResolution::Def(hir::ModuleDef::Adt(_)) => {\n-            Some(to_lower_snake_case(&path.segment()?.name_ref()?.text()) == param_name)\n-        }\n-        hir::PathResolution::Def(hir::ModuleDef::Function(_) | hir::ModuleDef::Variant(_)) => {\n-            if to_lower_snake_case(&path.segment()?.name_ref()?.text()) == param_name {\n-                return Some(true);\n-            }\n-            let qual = path.qualifier()?;\n-            match sema.resolve_path(&qual)? {\n-                hir::PathResolution::Def(hir::ModuleDef::Adt(_)) => {\n-                    Some(to_lower_snake_case(&qual.segment()?.name_ref()?.text()) == param_name)\n-                }\n-                _ => None,\n-            }\n-        }\n-        _ => None,\n-    })()\n-    .unwrap_or(false)\n-}\n-\n-fn get_string_representation(expr: &ast::Expr) -> Option<String> {\n-    match expr {\n-        ast::Expr::MethodCallExpr(method_call_expr) => {\n-            let name_ref = method_call_expr.name_ref()?;\n-            match name_ref.text().as_str() {\n-                \"clone\" | \"as_ref\" => method_call_expr.receiver().map(|rec| rec.to_string()),\n-                name_ref => Some(name_ref.to_owned()),\n-            }\n-        }\n-        ast::Expr::MacroExpr(macro_expr) => {\n-            Some(macro_expr.macro_call()?.path()?.segment()?.to_string())\n-        }\n-        ast::Expr::FieldExpr(field_expr) => Some(field_expr.name_ref()?.to_string()),\n-        ast::Expr::PathExpr(path_expr) => Some(path_expr.path()?.segment()?.to_string()),\n-        ast::Expr::PrefixExpr(prefix_expr) => get_string_representation(&prefix_expr.expr()?),\n-        ast::Expr::RefExpr(ref_expr) => get_string_representation(&ref_expr.expr()?),\n-        ast::Expr::CastExpr(cast_expr) => get_string_representation(&cast_expr.expr()?),\n-        _ => None,\n-    }\n-}\n-\n-fn is_obvious_param(param_name: &str) -> bool {\n-    // avoid displaying hints for common functions like map, filter, etc.\n-    // or other obvious words used in std\n-    let is_obvious_param_name =\n-        matches!(param_name, \"predicate\" | \"value\" | \"pat\" | \"rhs\" | \"other\");\n-    param_name.len() == 1 || is_obvious_param_name\n-}\n-\n-fn get_callable(\n-    sema: &Semantics<'_, RootDatabase>,\n-    expr: &ast::Expr,\n-) -> Option<(hir::Callable, ast::ArgList)> {\n-    match expr {\n-        ast::Expr::CallExpr(expr) => {\n-            let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n-            let expr = descended.as_ref().unwrap_or(expr);\n-            sema.type_of_expr(&expr.expr()?)?.original.as_callable(sema.db).zip(expr.arg_list())\n-        }\n-        ast::Expr::MethodCallExpr(expr) => {\n-            let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n-            let expr = descended.as_ref().unwrap_or(expr);\n-            sema.resolve_method_call_as_callable(expr).zip(expr.arg_list())\n-        }\n-        _ => None,\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-    use itertools::Itertools;\n-    use syntax::{TextRange, TextSize};\n-    use test_utils::extract_annotations;\n-\n-    use crate::inlay_hints::AdjustmentHints;\n-    use crate::{fixture, inlay_hints::InlayHintsConfig, LifetimeElisionHints};\n-\n-    use super::ClosureReturnTypeHints;\n-\n-    const DISABLED_CONFIG: InlayHintsConfig = InlayHintsConfig {\n-        render_colons: false,\n-        type_hints: false,\n-        parameter_hints: false,\n-        chaining_hints: false,\n-        lifetime_elision_hints: LifetimeElisionHints::Never,\n-        closure_return_type_hints: ClosureReturnTypeHints::Never,\n-        adjustment_hints: AdjustmentHints::Never,\n-        binding_mode_hints: false,\n-        hide_named_constructor_hints: false,\n-        hide_closure_initialization_hints: false,\n-        param_names_for_lifetime_elision_hints: false,\n-        max_length: None,\n-        closing_brace_hints_min_lines: None,\n-    };\n-    const TEST_CONFIG: InlayHintsConfig = InlayHintsConfig {\n-        type_hints: true,\n-        parameter_hints: true,\n-        chaining_hints: true,\n-        closure_return_type_hints: ClosureReturnTypeHints::WithBlock,\n-        binding_mode_hints: true,\n-        lifetime_elision_hints: LifetimeElisionHints::Always,\n-        ..DISABLED_CONFIG\n-    };\n-\n-    #[track_caller]\n-    fn check(ra_fixture: &str) {\n-        check_with_config(TEST_CONFIG, ra_fixture);\n-    }\n-\n-    #[track_caller]\n-    fn check_params(ra_fixture: &str) {\n-        check_with_config(\n-            InlayHintsConfig { parameter_hints: true, ..DISABLED_CONFIG },\n-            ra_fixture,\n-        );\n+    #[track_caller]\n+    pub(super) fn check(ra_fixture: &str) {\n+        check_with_config(TEST_CONFIG, ra_fixture);\n     }\n \n     #[track_caller]\n-    fn check_types(ra_fixture: &str) {\n-        check_with_config(InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG }, ra_fixture);\n-    }\n-\n-    #[track_caller]\n-    fn check_chains(ra_fixture: &str) {\n-        check_with_config(InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG }, ra_fixture);\n-    }\n-\n-    #[track_caller]\n-    fn check_with_config(config: InlayHintsConfig, ra_fixture: &str) {\n+    pub(super) fn check_with_config(config: InlayHintsConfig, ra_fixture: &str) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n         let mut expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();\n@@ -1392,7 +381,7 @@ mod tests {\n     }\n \n     #[track_caller]\n-    fn check_expect(config: InlayHintsConfig, ra_fixture: &str, expect: Expect) {\n+    pub(super) fn check_expect(config: InlayHintsConfig, ra_fixture: &str, expect: Expect) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();\n         expect.assert_debug_eq(&inlay_hints)\n@@ -1409,1756 +398,4 @@ fn main() {\n }\"#,\n         );\n     }\n-\n-    // Parameter hint tests\n-\n-    #[test]\n-    fn param_hints_only() {\n-        check_params(\n-            r#\"\n-fn foo(a: i32, b: i32) -> i32 { a + b }\n-fn main() {\n-    let _x = foo(\n-        4,\n-      //^ a\n-        4,\n-      //^ b\n-    );\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn param_hints_on_closure() {\n-        check_params(\n-            r#\"\n-fn main() {\n-    let clo = |a: u8, b: u8| a + b;\n-    clo(\n-        1,\n-      //^ a\n-        2,\n-      //^ b\n-    );\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn param_name_similar_to_fn_name_still_hints() {\n-        check_params(\n-            r#\"\n-fn max(x: i32, y: i32) -> i32 { x + y }\n-fn main() {\n-    let _x = max(\n-        4,\n-      //^ x\n-        4,\n-      //^ y\n-    );\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn param_name_similar_to_fn_name() {\n-        check_params(\n-            r#\"\n-fn param_with_underscore(with_underscore: i32) -> i32 { with_underscore }\n-fn main() {\n-    let _x = param_with_underscore(\n-        4,\n-    );\n-}\"#,\n-        );\n-        check_params(\n-            r#\"\n-fn param_with_underscore(underscore: i32) -> i32 { underscore }\n-fn main() {\n-    let _x = param_with_underscore(\n-        4,\n-    );\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn param_name_same_as_fn_name() {\n-        check_params(\n-            r#\"\n-fn foo(foo: i32) -> i32 { foo }\n-fn main() {\n-    let _x = foo(\n-        4,\n-    );\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn never_hide_param_when_multiple_params() {\n-        check_params(\n-            r#\"\n-fn foo(foo: i32, bar: i32) -> i32 { bar + baz }\n-fn main() {\n-    let _x = foo(\n-        4,\n-      //^ foo\n-        8,\n-      //^ bar\n-    );\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn param_hints_look_through_as_ref_and_clone() {\n-        check_params(\n-            r#\"\n-fn foo(bar: i32, baz: f32) {}\n-\n-fn main() {\n-    let bar = 3;\n-    let baz = &\"baz\";\n-    let fez = 1.0;\n-    foo(bar.clone(), bar.clone());\n-                   //^^^^^^^^^^^ baz\n-    foo(bar.as_ref(), bar.as_ref());\n-                    //^^^^^^^^^^^^ baz\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn self_param_hints() {\n-        check_params(\n-            r#\"\n-struct Foo;\n-\n-impl Foo {\n-    fn foo(self: Self) {}\n-    fn bar(self: &Self) {}\n-}\n-\n-fn main() {\n-    Foo::foo(Foo);\n-           //^^^ self\n-    Foo::bar(&Foo);\n-           //^^^^ self\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn param_name_hints_show_for_literals() {\n-        check_params(\n-            r#\"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }\n-fn main() {\n-    test(\n-        0xa_b,\n-      //^^^^^ a\n-        0xa_b,\n-      //^^^^^ b\n-    );\n-}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn function_call_parameter_hint() {\n-        check_params(\n-            r#\"\n-//- minicore: option\n-struct FileId {}\n-struct SmolStr {}\n-\n-struct TextRange {}\n-struct SyntaxKind {}\n-struct NavigationTarget {}\n-\n-struct Test {}\n-\n-impl Test {\n-    fn method(&self, mut param: i32) -> i32 { param * 2 }\n-\n-    fn from_syntax(\n-        file_id: FileId,\n-        name: SmolStr,\n-        focus_range: Option<TextRange>,\n-        full_range: TextRange,\n-        kind: SyntaxKind,\n-        docs: Option<String>,\n-    ) -> NavigationTarget {\n-        NavigationTarget {}\n-    }\n-}\n-\n-fn test_func(mut foo: i32, bar: i32, msg: &str, _: i32, last: i32) -> i32 {\n-    foo + bar\n-}\n-\n-fn main() {\n-    let not_literal = 1;\n-    let _: i32 = test_func(1,    2,      \"hello\", 3,  not_literal);\n-                         //^ foo ^ bar   ^^^^^^^ msg  ^^^^^^^^^^^ last\n-    let t: Test = Test {};\n-    t.method(123);\n-           //^^^ param\n-    Test::method(&t,      3456);\n-               //^^ self  ^^^^ param\n-    Test::from_syntax(\n-        FileId {},\n-        \"impl\".into(),\n-      //^^^^^^^^^^^^^ name\n-        None,\n-      //^^^^ focus_range\n-        TextRange {},\n-      //^^^^^^^^^^^^ full_range\n-        SyntaxKind {},\n-      //^^^^^^^^^^^^^ kind\n-        None,\n-      //^^^^ docs\n-    );\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn parameter_hint_heuristics() {\n-        check_params(\n-            r#\"\n-fn check(ra_fixture_thing: &str) {}\n-\n-fn map(f: i32) {}\n-fn filter(predicate: i32) {}\n-\n-fn strip_suffix(suffix: &str) {}\n-fn stripsuffix(suffix: &str) {}\n-fn same(same: u32) {}\n-fn same2(_same2: u32) {}\n-\n-fn enum_matches_param_name(completion_kind: CompletionKind) {}\n-\n-fn foo(param: u32) {}\n-fn bar(param_eter: u32) {}\n-\n-enum CompletionKind {\n-    Keyword,\n-}\n-\n-fn non_ident_pat((a, b): (u32, u32)) {}\n-\n-fn main() {\n-    const PARAM: u32 = 0;\n-    foo(PARAM);\n-    foo(!PARAM);\n-     // ^^^^^^ param\n-    check(\"\");\n-\n-    map(0);\n-    filter(0);\n-\n-    strip_suffix(\"\");\n-    stripsuffix(\"\");\n-              //^^ suffix\n-    same(0);\n-    same2(0);\n-\n-    enum_matches_param_name(CompletionKind::Keyword);\n-\n-    let param = 0;\n-    foo(param);\n-    foo(param as _);\n-    let param_end = 0;\n-    foo(param_end);\n-    let start_param = 0;\n-    foo(start_param);\n-    let param2 = 0;\n-    foo(param2);\n-      //^^^^^^ param\n-\n-    macro_rules! param {\n-        () => {};\n-    };\n-    foo(param!());\n-\n-    let param_eter = 0;\n-    bar(param_eter);\n-    let param_eter_end = 0;\n-    bar(param_eter_end);\n-    let start_param_eter = 0;\n-    bar(start_param_eter);\n-    let param_eter2 = 0;\n-    bar(param_eter2);\n-      //^^^^^^^^^^^ param_eter\n-\n-    non_ident_pat((0, 0));\n-}\"#,\n-        );\n-    }\n-\n-    // Type-Hint tests\n-\n-    #[test]\n-    fn type_hints_only() {\n-        check_types(\n-            r#\"\n-fn foo(a: i32, b: i32) -> i32 { a + b }\n-fn main() {\n-    let _x = foo(4, 4);\n-      //^^ i32\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn type_hints_bindings_after_at() {\n-        check_types(\n-            r#\"\n-//- minicore: option\n-fn main() {\n-    let ref foo @ bar @ ref mut baz = 0;\n-          //^^^ &i32\n-                //^^^ i32\n-                              //^^^ &mut i32\n-    let [x @ ..] = [0];\n-       //^ [i32; 1]\n-    if let x @ Some(_) = Some(0) {}\n-         //^ Option<i32>\n-    let foo @ (bar, baz) = (3, 3);\n-      //^^^ (i32, i32)\n-             //^^^ i32\n-                  //^^^ i32\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn default_generic_types_should_not_be_displayed() {\n-        check(\n-            r#\"\n-struct Test<K, T = u8> { k: K, t: T }\n-\n-fn main() {\n-    let zz = Test { t: 23u8, k: 33 };\n-      //^^ Test<i32>\n-    let zz_ref = &zz;\n-      //^^^^^^ &Test<i32>\n-    let test = || zz;\n-      //^^^^ || -> Test<i32>\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn shorten_iterators_in_associated_params() {\n-        check_types(\n-            r#\"\n-//- minicore: iterators\n-use core::iter;\n-\n-pub struct SomeIter<T> {}\n-\n-impl<T> SomeIter<T> {\n-    pub fn new() -> Self { SomeIter {} }\n-    pub fn push(&mut self, t: T) {}\n-}\n-\n-impl<T> Iterator for SomeIter<T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        None\n-    }\n-}\n-\n-fn main() {\n-    let mut some_iter = SomeIter::new();\n-          //^^^^^^^^^ SomeIter<Take<Repeat<i32>>>\n-      some_iter.push(iter::repeat(2).take(2));\n-    let iter_of_iters = some_iter.take(2);\n-      //^^^^^^^^^^^^^ impl Iterator<Item = impl Iterator<Item = i32>>\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn iterator_hint_regression_issue_12674() {\n-        // Ensure we don't crash while solving the projection type of iterators.\n-        check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n-            r#\"\n-//- minicore: iterators\n-struct S<T>(T);\n-impl<T> S<T> {\n-    fn iter(&self) -> Iter<'_, T> { loop {} }\n-}\n-struct Iter<'a, T: 'a>(&'a T);\n-impl<'a, T> Iterator for Iter<'a, T> {\n-    type Item = &'a T;\n-    fn next(&mut self) -> Option<Self::Item> { loop {} }\n-}\n-struct Container<'a> {\n-    elements: S<&'a str>,\n-}\n-struct SliceIter<'a, T>(&'a T);\n-impl<'a, T> Iterator for SliceIter<'a, T> {\n-    type Item = &'a T;\n-    fn next(&mut self) -> Option<Self::Item> { loop {} }\n-}\n-\n-fn main(a: SliceIter<'_, Container>) {\n-    a\n-    .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n-    .map(|e| e);\n-}\n-            \"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 484..554,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"impl Iterator<Item = impl Iterator<Item = &&str>>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                484..554,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 484..485,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"SliceIter<Container>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                484..485,\n-                            ),\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn infer_call_method_return_associated_types_with_generic() {\n-        check_types(\n-            r#\"\n-            pub trait Default {\n-                fn default() -> Self;\n-            }\n-            pub trait Foo {\n-                type Bar: Default;\n-            }\n-\n-            pub fn quux<T: Foo>() -> T::Bar {\n-                let y = Default::default();\n-                  //^ <T as Foo>::Bar\n-\n-                y\n-            }\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fn_hints() {\n-        check_types(\n-            r#\"\n-//- minicore: fn, sized\n-fn foo() -> impl Fn() { loop {} }\n-fn foo1() -> impl Fn(f64) { loop {} }\n-fn foo2() -> impl Fn(f64, f64) { loop {} }\n-fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n-fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n-fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n-fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n-fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n-\n-fn main() {\n-    let foo = foo();\n-     // ^^^ impl Fn()\n-    let foo = foo1();\n-     // ^^^ impl Fn(f64)\n-    let foo = foo2();\n-     // ^^^ impl Fn(f64, f64)\n-    let foo = foo3();\n-     // ^^^ impl Fn(f64, f64) -> u32\n-    let foo = foo4();\n-     // ^^^ &dyn Fn(f64, f64) -> u32\n-    let foo = foo5();\n-     // ^^^ &dyn Fn(&dyn Fn(f64, f64) -> u32, f64) -> u32\n-    let foo = foo6();\n-     // ^^^ impl Fn(f64, f64) -> u32\n-    let foo = foo7();\n-     // ^^^ *const impl Fn(f64, f64) -> u32\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn check_hint_range_limit() {\n-        let fixture = r#\"\n-        //- minicore: fn, sized\n-        fn foo() -> impl Fn() { loop {} }\n-        fn foo1() -> impl Fn(f64) { loop {} }\n-        fn foo2() -> impl Fn(f64, f64) { loop {} }\n-        fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n-        fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n-        fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n-        fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n-        fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n-\n-        fn main() {\n-            let foo = foo();\n-            let foo = foo1();\n-            let foo = foo2();\n-             // ^^^ impl Fn(f64, f64)\n-            let foo = foo3();\n-             // ^^^ impl Fn(f64, f64) -> u32\n-            let foo = foo4();\n-            let foo = foo5();\n-            let foo = foo6();\n-            let foo = foo7();\n-        }\n-        \"#;\n-        let (analysis, file_id) = fixture::file(fixture);\n-        let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n-        let inlay_hints = analysis\n-            .inlay_hints(\n-                &InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },\n-                file_id,\n-                Some(TextRange::new(TextSize::from(500), TextSize::from(600))),\n-            )\n-            .unwrap();\n-        let actual =\n-            inlay_hints.into_iter().map(|it| (it.range, it.label.to_string())).collect::<Vec<_>>();\n-        assert_eq!(expected, actual, \"\\nExpected:\\n{:#?}\\n\\nActual:\\n{:#?}\", expected, actual);\n-    }\n-\n-    #[test]\n-    fn fn_hints_ptr_rpit_fn_parentheses() {\n-        check_types(\n-            r#\"\n-//- minicore: fn, sized\n-trait Trait {}\n-\n-fn foo1() -> *const impl Fn() { loop {} }\n-fn foo2() -> *const (impl Fn() + Sized) { loop {} }\n-fn foo3() -> *const (impl Fn() + ?Sized) { loop {} }\n-fn foo4() -> *const (impl Sized + Fn()) { loop {} }\n-fn foo5() -> *const (impl ?Sized + Fn()) { loop {} }\n-fn foo6() -> *const (impl Fn() + Trait) { loop {} }\n-fn foo7() -> *const (impl Fn() + Sized + Trait) { loop {} }\n-fn foo8() -> *const (impl Fn() + ?Sized + Trait) { loop {} }\n-fn foo9() -> *const (impl Fn() -> u8 + ?Sized) { loop {} }\n-fn foo10() -> *const (impl Fn() + Sized + ?Sized) { loop {} }\n-\n-fn main() {\n-    let foo = foo1();\n-    //  ^^^ *const impl Fn()\n-    let foo = foo2();\n-    //  ^^^ *const impl Fn()\n-    let foo = foo3();\n-    //  ^^^ *const (impl Fn() + ?Sized)\n-    let foo = foo4();\n-    //  ^^^ *const impl Fn()\n-    let foo = foo5();\n-    //  ^^^ *const (impl Fn() + ?Sized)\n-    let foo = foo6();\n-    //  ^^^ *const (impl Fn() + Trait)\n-    let foo = foo7();\n-    //  ^^^ *const (impl Fn() + Trait)\n-    let foo = foo8();\n-    //  ^^^ *const (impl Fn() + Trait + ?Sized)\n-    let foo = foo9();\n-    //  ^^^ *const (impl Fn() -> u8 + ?Sized)\n-    let foo = foo10();\n-    //  ^^^ *const impl Fn()\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn unit_structs_have_no_type_hints() {\n-        check_types(\n-            r#\"\n-//- minicore: result\n-struct SyntheticSyntax;\n-\n-fn main() {\n-    match Ok(()) {\n-        Ok(_) => (),\n-        Err(SyntheticSyntax) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn let_statement() {\n-        check_types(\n-            r#\"\n-#[derive(PartialEq)]\n-enum Option<T> { None, Some(T) }\n-\n-#[derive(PartialEq)]\n-struct Test { a: Option<u32>, b: u8 }\n-\n-fn main() {\n-    struct InnerStruct {}\n-\n-    let test = 54;\n-      //^^^^ i32\n-    let test: i32 = 33;\n-    let mut test = 33;\n-          //^^^^ i32\n-    let _ = 22;\n-    let test = \"test\";\n-      //^^^^ &str\n-    let test = InnerStruct {};\n-      //^^^^ InnerStruct\n-\n-    let test = unresolved();\n-\n-    let test = (42, 'a');\n-      //^^^^ (i32, char)\n-    let (a,    (b,     (c,)) = (2, (3, (9.2,));\n-       //^ i32  ^ i32   ^ f64\n-    let &x = &92;\n-       //^ i32\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn if_expr() {\n-        check_types(\n-            r#\"\n-//- minicore: option\n-struct Test { a: Option<u32>, b: u8 }\n-\n-fn main() {\n-    let test = Some(Test { a: Some(3), b: 1 });\n-      //^^^^ Option<Test>\n-    if let None = &test {};\n-    if let test = &test {};\n-         //^^^^ &Option<Test>\n-    if let Some(test) = &test {};\n-              //^^^^ &Test\n-    if let Some(Test { a,             b }) = &test {};\n-                     //^ &Option<u32> ^ &u8\n-    if let Some(Test { a: x,             b: y }) = &test {};\n-                        //^ &Option<u32>    ^ &u8\n-    if let Some(Test { a: Some(x),  b: y }) = &test {};\n-                             //^ &u32  ^ &u8\n-    if let Some(Test { a: None,  b: y }) = &test {};\n-                                  //^ &u8\n-    if let Some(Test { b: y, .. }) = &test {};\n-                        //^ &u8\n-    if test == None {}\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn while_expr() {\n-        check_types(\n-            r#\"\n-//- minicore: option\n-struct Test { a: Option<u32>, b: u8 }\n-\n-fn main() {\n-    let test = Some(Test { a: Some(3), b: 1 });\n-      //^^^^ Option<Test>\n-    while let Some(Test { a: Some(x),  b: y }) = &test {};\n-                                //^ &u32  ^ &u8\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn match_arm_list() {\n-        check_types(\n-            r#\"\n-//- minicore: option\n-struct Test { a: Option<u32>, b: u8 }\n-\n-fn main() {\n-    match Some(Test { a: Some(3), b: 1 }) {\n-        None => (),\n-        test => (),\n-      //^^^^ Option<Test>\n-        Some(Test { a: Some(x), b: y }) => (),\n-                          //^ u32  ^ u8\n-        _ => {}\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn complete_for_hint() {\n-        check_types(\n-            r#\"\n-//- minicore: iterator\n-pub struct Vec<T> {}\n-\n-impl<T> Vec<T> {\n-    pub fn new() -> Self { Vec {} }\n-    pub fn push(&mut self, t: T) {}\n-}\n-\n-impl<T> IntoIterator for Vec<T> {\n-    type Item = T;\n-    type IntoIter = IntoIter<T>;\n-}\n-\n-struct IntoIter<T> {}\n-\n-impl<T> Iterator for IntoIter<T> {\n-    type Item = T;\n-}\n-\n-fn main() {\n-    let mut data = Vec::new();\n-          //^^^^ Vec<&str>\n-    data.push(\"foo\");\n-    for i in data {\n-      //^ &str\n-      let z = i;\n-        //^ &str\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn multi_dyn_trait_bounds() {\n-        check_types(\n-            r#\"\n-pub struct Vec<T> {}\n-\n-impl<T> Vec<T> {\n-    pub fn new() -> Self { Vec {} }\n-}\n-\n-pub struct Box<T> {}\n-\n-trait Display {}\n-auto trait Sync {}\n-\n-fn main() {\n-    // The block expression wrapping disables the constructor hint hiding logic\n-    let _v = { Vec::<Box<&(dyn Display + Sync)>>::new() };\n-      //^^ Vec<Box<&(dyn Display + Sync)>>\n-    let _v = { Vec::<Box<*const (dyn Display + Sync)>>::new() };\n-      //^^ Vec<Box<*const (dyn Display + Sync)>>\n-    let _v = { Vec::<Box<dyn Display + Sync>>::new() };\n-      //^^ Vec<Box<dyn Display + Sync>>\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn shorten_iterator_hints() {\n-        check_types(\n-            r#\"\n-//- minicore: iterators\n-use core::iter;\n-\n-struct MyIter;\n-\n-impl Iterator for MyIter {\n-    type Item = ();\n-    fn next(&mut self) -> Option<Self::Item> {\n-        None\n-    }\n-}\n-\n-fn main() {\n-    let _x = MyIter;\n-      //^^ MyIter\n-    let _x = iter::repeat(0);\n-      //^^ impl Iterator<Item = i32>\n-    fn generic<T: Clone>(t: T) {\n-        let _x = iter::repeat(t);\n-          //^^ impl Iterator<Item = T>\n-        let _chained = iter::repeat(t).take(10);\n-          //^^^^^^^^ impl Iterator<Item = T>\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn skip_constructor_and_enum_type_hints() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                type_hints: true,\n-                hide_named_constructor_hints: true,\n-                ..DISABLED_CONFIG\n-            },\n-            r#\"\n-//- minicore: try, option\n-use core::ops::ControlFlow;\n-\n-mod x {\n-    pub mod y { pub struct Foo; }\n-    pub struct Foo;\n-    pub enum AnotherEnum {\n-        Variant()\n-    };\n-}\n-struct Struct;\n-struct TupleStruct();\n-\n-impl Struct {\n-    fn new() -> Self {\n-        Struct\n-    }\n-    fn try_new() -> ControlFlow<(), Self> {\n-        ControlFlow::Continue(Struct)\n-    }\n-}\n-\n-struct Generic<T>(T);\n-impl Generic<i32> {\n-    fn new() -> Self {\n-        Generic(0)\n-    }\n-}\n-\n-enum Enum {\n-    Variant(u32)\n-}\n-\n-fn times2(value: i32) -> i32 {\n-    2 * value\n-}\n-\n-fn main() {\n-    let enumb = Enum::Variant(0);\n-\n-    let strukt = x::Foo;\n-    let strukt = x::y::Foo;\n-    let strukt = Struct;\n-    let strukt = Struct::new();\n-\n-    let tuple_struct = TupleStruct();\n-\n-    let generic0 = Generic::new();\n-    //  ^^^^^^^^ Generic<i32>\n-    let generic1 = Generic(0);\n-    //  ^^^^^^^^ Generic<i32>\n-    let generic2 = Generic::<i32>::new();\n-    let generic3 = <Generic<i32>>::new();\n-    let generic4 = Generic::<i32>(0);\n-\n-\n-    let option = Some(0);\n-    //  ^^^^^^ Option<i32>\n-    let func = times2;\n-    //  ^^^^ fn times2(i32) -> i32\n-    let closure = |x: i32| x * 2;\n-    //  ^^^^^^^ |i32| -> i32\n-}\n-\n-fn fallible() -> ControlFlow<()> {\n-    let strukt = Struct::try_new()?;\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn shows_constructor_type_hints_when_enabled() {\n-        check_types(\n-            r#\"\n-//- minicore: try\n-use core::ops::ControlFlow;\n-\n-struct Struct;\n-struct TupleStruct();\n-\n-impl Struct {\n-    fn new() -> Self {\n-        Struct\n-    }\n-    fn try_new() -> ControlFlow<(), Self> {\n-        ControlFlow::Continue(Struct)\n-    }\n-}\n-\n-struct Generic<T>(T);\n-impl Generic<i32> {\n-    fn new() -> Self {\n-        Generic(0)\n-    }\n-}\n-\n-fn main() {\n-    let strukt = Struct::new();\n-     // ^^^^^^ Struct\n-    let tuple_struct = TupleStruct();\n-     // ^^^^^^^^^^^^ TupleStruct\n-    let generic0 = Generic::new();\n-     // ^^^^^^^^ Generic<i32>\n-    let generic1 = Generic::<i32>::new();\n-     // ^^^^^^^^ Generic<i32>\n-    let generic2 = <Generic<i32>>::new();\n-     // ^^^^^^^^ Generic<i32>\n-}\n-\n-fn fallible() -> ControlFlow<()> {\n-    let strukt = Struct::try_new()?;\n-     // ^^^^^^ Struct\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn closures() {\n-        check(\n-            r#\"\n-fn main() {\n-    let mut start = 0;\n-          //^^^^^ i32\n-    (0..2).for_each(|increment      | { start += increment; });\n-                   //^^^^^^^^^ i32\n-\n-    let multiply =\n-      //^^^^^^^^ |i32, i32| -> i32\n-      | a,     b| a * b\n-      //^ i32  ^ i32\n-\n-    ;\n-\n-    let _: i32 = multiply(1,  2);\n-                        //^ a ^ b\n-    let multiply_ref = &multiply;\n-      //^^^^^^^^^^^^ &|i32, i32| -> i32\n-\n-    let return_42 = || 42;\n-      //^^^^^^^^^ || -> i32\n-      || { 42 };\n-    //^^ i32\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn return_type_hints_for_closure_without_block() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                closure_return_type_hints: ClosureReturnTypeHints::Always,\n-                ..DISABLED_CONFIG\n-            },\n-            r#\"\n-fn main() {\n-    let a = || { 0 };\n-          //^^ i32\n-    let b = || 0;\n-          //^^ i32\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn skip_closure_type_hints() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                type_hints: true,\n-                hide_closure_initialization_hints: true,\n-                ..DISABLED_CONFIG\n-            },\n-            r#\"\n-//- minicore: fn\n-fn main() {\n-    let multiple_2 = |x: i32| { x * 2 };\n-\n-    let multiple_2 = |x: i32| x * 2;\n-    //  ^^^^^^^^^^ |i32| -> i32\n-\n-    let (not) = (|x: bool| { !x });\n-    //   ^^^ |bool| -> bool\n-\n-    let (is_zero, _b) = (|x: usize| { x == 0 }, false);\n-    //   ^^^^^^^ |usize| -> bool\n-    //            ^^ bool\n-\n-    let plus_one = |x| { x + 1 };\n-    //              ^ u8\n-    foo(plus_one);\n-\n-    let add_mul = bar(|x: u8| { x + 1 });\n-    //  ^^^^^^^ impl FnOnce(u8) -> u8 + ?Sized\n-\n-    let closure = if let Some(6) = add_mul(2).checked_sub(1) {\n-    //  ^^^^^^^ fn(i32) -> i32\n-        |x: i32| { x * 2 }\n-    } else {\n-        |x: i32| { x * 3 }\n-    };\n-}\n-\n-fn foo(f: impl FnOnce(u8) -> u8) {}\n-\n-fn bar(f: impl FnOnce(u8) -> u8) -> impl FnOnce(u8) -> u8 {\n-    move |x: u8| f(x) * 2\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn hint_truncation() {\n-        check_with_config(\n-            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n-            r#\"\n-struct Smol<T>(T);\n-\n-struct VeryLongOuterName<T>(T);\n-\n-fn main() {\n-    let a = Smol(0u32);\n-      //^ Smol<u32>\n-    let b = VeryLongOuterName(0usize);\n-      //^ VeryLongOuterName<\u2026>\n-    let c = Smol(Smol(0u32))\n-      //^ Smol<Smol<\u2026>>\n-}\"#,\n-        );\n-    }\n-\n-    // Chaining hint tests\n-\n-    #[test]\n-    fn chaining_hints_ignore_comments() {\n-        check_expect(\n-            InlayHintsConfig { type_hints: false, chaining_hints: true, ..DISABLED_CONFIG },\n-            r#\"\n-struct A(B);\n-impl A { fn into_b(self) -> B { self.0 } }\n-struct B(C);\n-impl B { fn into_c(self) -> C { self.0 } }\n-struct C;\n-\n-fn main() {\n-    let c = A(B(C))\n-        .into_b() // This is a comment\n-        // This is another comment\n-        .into_c();\n-}\n-\"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 147..172,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"B\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                147..172,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 147..154,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"A\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                147..154,\n-                            ),\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn chaining_hints_without_newlines() {\n-        check_chains(\n-            r#\"\n-struct A(B);\n-impl A { fn into_b(self) -> B { self.0 } }\n-struct B(C);\n-impl B { fn into_c(self) -> C { self.0 } }\n-struct C;\n-\n-fn main() {\n-    let c = A(B(C)).into_b().into_c();\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn struct_access_chaining_hints() {\n-        check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n-            r#\"\n-struct A { pub b: B }\n-struct B { pub c: C }\n-struct C(pub bool);\n-struct D;\n-\n-impl D {\n-    fn foo(&self) -> i32 { 42 }\n-}\n-\n-fn main() {\n-    let x = A { b: B { c: C(true) } }\n-        .b\n-        .c\n-        .0;\n-    let x = D\n-        .foo();\n-}\"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 143..190,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"C\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                143..190,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 143..179,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"B\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                143..179,\n-                            ),\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn generic_chaining_hints() {\n-        check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n-            r#\"\n-struct A<T>(T);\n-struct B<T>(T);\n-struct C<T>(T);\n-struct X<T,R>(T, R);\n-\n-impl<T> A<T> {\n-    fn new(t: T) -> Self { A(t) }\n-    fn into_b(self) -> B<T> { B(self.0) }\n-}\n-impl<T> B<T> {\n-    fn into_c(self) -> C<T> { C(self.0) }\n-}\n-fn main() {\n-    let c = A::new(X(42, true))\n-        .into_b()\n-        .into_c();\n-}\n-\"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 246..283,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"B<X<i32, bool>>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                246..283,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 246..265,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"A<X<i32, bool>>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                246..265,\n-                            ),\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn shorten_iterator_chaining_hints() {\n-        check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n-            r#\"\n-//- minicore: iterators\n-use core::iter;\n-\n-struct MyIter;\n-\n-impl Iterator for MyIter {\n-    type Item = ();\n-    fn next(&mut self) -> Option<Self::Item> {\n-        None\n-    }\n-}\n-\n-fn main() {\n-    let _x = MyIter.by_ref()\n-        .take(5)\n-        .by_ref()\n-        .take(5)\n-        .by_ref();\n-}\n-\"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 174..241,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"impl Iterator<Item = ()>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                174..241,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 174..224,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"impl Iterator<Item = ()>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                174..224,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 174..206,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"impl Iterator<Item = ()>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                174..206,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 174..189,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"&mut MyIter\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                174..189,\n-                            ),\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn hints_in_attr_call() {\n-        check_expect(\n-            TEST_CONFIG,\n-            r#\"\n-//- proc_macros: identity, input_replace\n-struct Struct;\n-impl Struct {\n-    fn chain(self) -> Self {\n-        self\n-    }\n-}\n-#[proc_macros::identity]\n-fn main() {\n-    let strukt = Struct;\n-    strukt\n-        .chain()\n-        .chain()\n-        .chain();\n-    Struct::chain(strukt);\n-}\n-\"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 124..130,\n-                        kind: TypeHint,\n-                        label: [\n-                            \"Struct\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                124..130,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 145..185,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"Struct\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                145..185,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 145..168,\n-                        kind: ChainingHint,\n-                        label: [\n-                            \"Struct\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                145..168,\n-                            ),\n-                        ),\n-                    },\n-                    InlayHint {\n-                        range: 222..228,\n-                        kind: ParameterHint,\n-                        label: [\n-                            \"self\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverOffset(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                42,\n-                            ),\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn hints_lifetimes() {\n-        check(\n-            r#\"\n-fn empty() {}\n-\n-fn no_gpl(a: &()) {}\n- //^^^^^^<'0>\n-          // ^'0\n-fn empty_gpl<>(a: &()) {}\n-      //    ^'0   ^'0\n-fn partial<'b>(a: &(), b: &'b ()) {}\n-//        ^'0, $  ^'0\n-fn partial<'a>(a: &'a (), b: &()) {}\n-//        ^'0, $             ^'0\n-\n-fn single_ret(a: &()) -> &() {}\n-// ^^^^^^^^^^<'0>\n-              // ^'0     ^'0\n-fn full_mul(a: &(), b: &()) {}\n-// ^^^^^^^^<'0, '1>\n-            // ^'0     ^'1\n-\n-fn foo<'c>(a: &'c ()) -> &() {}\n-                      // ^'c\n-\n-fn nested_in(a: &   &X< &()>) {}\n-// ^^^^^^^^^<'0, '1, '2>\n-              //^'0 ^'1 ^'2\n-fn nested_out(a: &()) -> &   &X< &()>{}\n-// ^^^^^^^^^^<'0>\n-               //^'0     ^'0 ^'0 ^'0\n-\n-impl () {\n-    fn foo(&self) {}\n-    // ^^^<'0>\n-        // ^'0\n-    fn foo(&self) -> &() {}\n-    // ^^^<'0>\n-        // ^'0       ^'0\n-    fn foo(&self, a: &()) -> &() {}\n-    // ^^^<'0, '1>\n-        // ^'0       ^'1     ^'0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn hints_lifetimes_named() {\n-        check_with_config(\n-            InlayHintsConfig { param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG },\n-            r#\"\n-fn nested_in<'named>(named: &        &X<      &()>) {}\n-//          ^'named1, 'named2, 'named3, $\n-                          //^'named1 ^'named2 ^'named3\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn hints_lifetimes_trivial_skip() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                lifetime_elision_hints: LifetimeElisionHints::SkipTrivial,\n-                ..TEST_CONFIG\n-            },\n-            r#\"\n-fn no_gpl(a: &()) {}\n-fn empty_gpl<>(a: &()) {}\n-fn partial<'b>(a: &(), b: &'b ()) {}\n-fn partial<'a>(a: &'a (), b: &()) {}\n-\n-fn single_ret(a: &()) -> &() {}\n-// ^^^^^^^^^^<'0>\n-              // ^'0     ^'0\n-fn full_mul(a: &(), b: &()) {}\n-\n-fn foo<'c>(a: &'c ()) -> &() {}\n-                      // ^'c\n-\n-fn nested_in(a: &   &X< &()>) {}\n-fn nested_out(a: &()) -> &   &X< &()>{}\n-// ^^^^^^^^^^<'0>\n-               //^'0     ^'0 ^'0 ^'0\n-\n-impl () {\n-    fn foo(&self) {}\n-    fn foo(&self) -> &() {}\n-    // ^^^<'0>\n-        // ^'0       ^'0\n-    fn foo(&self, a: &()) -> &() {}\n-    // ^^^<'0, '1>\n-        // ^'0       ^'1     ^'0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn hints_lifetimes_static() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                lifetime_elision_hints: LifetimeElisionHints::Always,\n-                ..TEST_CONFIG\n-            },\n-            r#\"\n-trait Trait {}\n-static S: &str = \"\";\n-//        ^'static\n-const C: &str = \"\";\n-//       ^'static\n-const C: &dyn Trait = panic!();\n-//       ^'static\n-\n-impl () {\n-    const C: &str = \"\";\n-    const C: &dyn Trait = panic!();\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn hints_binding_modes() {\n-        check_with_config(\n-            InlayHintsConfig { binding_mode_hints: true, ..DISABLED_CONFIG },\n-            r#\"\n-fn __(\n-    (x,): (u32,),\n-    (x,): &(u32,),\n-  //^^^^&\n-   //^ ref\n-    (x,): &mut (u32,)\n-  //^^^^&mut\n-   //^ ref mut\n-) {\n-    let (x,) = (0,);\n-    let (x,) = &(0,);\n-      //^^^^ &\n-       //^ ref\n-    let (x,) = &mut (0,);\n-      //^^^^ &mut\n-       //^ ref mut\n-    let &mut (x,) = &mut (0,);\n-    let (ref mut x,) = &mut (0,);\n-      //^^^^^^^^^^^^ &mut\n-    let &mut (ref mut x,) = &mut (0,);\n-    let (mut x,) = &mut (0,);\n-      //^^^^^^^^ &mut\n-    match (0,) {\n-        (x,) => ()\n-    }\n-    match &(0,) {\n-        (x,) | (x,) => (),\n-      //^^^^^^^^^^^&\n-       //^ ref\n-              //^ ref\n-      //^^^^^^^^^^^(\n-      //^^^^^^^^^^^)\n-        ((x,) | (x,)) => (),\n-      //^^^^^^^^^^^^^&\n-        //^ ref\n-               //^ ref\n-    }\n-    match &mut (0,) {\n-        (x,) => ()\n-      //^^^^ &mut\n-       //^ ref mut\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn hints_closing_brace() {\n-        check_with_config(\n-            InlayHintsConfig { closing_brace_hints_min_lines: Some(2), ..DISABLED_CONFIG },\n-            r#\"\n-fn a() {}\n-\n-fn f() {\n-} // no hint unless `}` is the last token on the line\n-\n-fn g() {\n-  }\n-//^ fn g\n-\n-fn h<T>(with: T, arguments: u8, ...) {\n-  }\n-//^ fn h\n-\n-trait Tr {\n-    fn f();\n-    fn g() {\n-    }\n-  //^ fn g\n-  }\n-//^ trait Tr\n-impl Tr for () {\n-  }\n-//^ impl Tr for ()\n-impl dyn Tr {\n-  }\n-//^ impl dyn Tr\n-\n-static S0: () = 0;\n-static S1: () = {};\n-static S2: () = {\n- };\n-//^ static S2\n-const _: () = {\n- };\n-//^ const _\n-\n-mod m {\n-  }\n-//^ mod m\n-\n-m! {}\n-m!();\n-m!(\n- );\n-//^ m!\n-\n-m! {\n-  }\n-//^ m!\n-\n-fn f() {\n-    let v = vec![\n-    ];\n-  }\n-//^ fn f\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn adjustment_hints() {\n-        check_with_config(\n-            InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n-            r#\"\n-//- minicore: coerce_unsized\n-fn main() {\n-    let _: u32         = loop {};\n-                       //^^^^^^^<never-to-any>\n-    let _: &u32        = &mut 0;\n-                       //^^^^^^&\n-                       //^^^^^^*\n-    let _: &mut u32    = &mut 0;\n-                       //^^^^^^&mut $\n-                       //^^^^^^*\n-    let _: *const u32  = &mut 0;\n-                       //^^^^^^&raw const $\n-                       //^^^^^^*\n-    let _: *mut u32    = &mut 0;\n-                       //^^^^^^&raw mut $\n-                       //^^^^^^*\n-    let _: fn()        = main;\n-                       //^^^^<fn-item-to-fn-pointer>\n-    let _: unsafe fn() = main;\n-                       //^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n-                       //^^^^<fn-item-to-fn-pointer>\n-    let _: unsafe fn() = main as fn();\n-                       //^^^^^^^^^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n-    let _: fn()        = || {};\n-                       //^^^^^<closure-to-fn-pointer>\n-    let _: unsafe fn() = || {};\n-                       //^^^^^<closure-to-unsafe-fn-pointer>\n-    let _: *const u32  = &mut 0u32 as *mut u32;\n-                       //^^^^^^^^^^^^^^^^^^^^^<mut-ptr-to-const-ptr>\n-    let _: &mut [_]    = &mut [0; 0];\n-                       //^^^^^^^^^^^<unsize>\n-                       //^^^^^^^^^^^&mut $\n-                       //^^^^^^^^^^^*\n-\n-    Struct.consume();\n-    Struct.by_ref();\n-  //^^^^^^(\n-  //^^^^^^&\n-  //^^^^^^)\n-    Struct.by_ref_mut();\n-  //^^^^^^(\n-  //^^^^^^&mut $\n-  //^^^^^^)\n-\n-    (&Struct).consume();\n-   //^^^^^^^*\n-    (&Struct).by_ref();\n-\n-    (&mut Struct).consume();\n-   //^^^^^^^^^^^*\n-    (&mut Struct).by_ref();\n-   //^^^^^^^^^^^&\n-   //^^^^^^^^^^^*\n-    (&mut Struct).by_ref_mut();\n-\n-    // Check that block-like expressions don't duplicate hints\n-    let _: &mut [u32] = (&mut []);\n-                       //^^^^^^^<unsize>\n-                       //^^^^^^^&mut $\n-                       //^^^^^^^*\n-    let _: &mut [u32] = { &mut [] };\n-                        //^^^^^^^<unsize>\n-                        //^^^^^^^&mut $\n-                        //^^^^^^^*\n-    let _: &mut [u32] = unsafe { &mut [] };\n-                               //^^^^^^^<unsize>\n-                               //^^^^^^^&mut $\n-                               //^^^^^^^*\n-    let _: &mut [u32] = if true {\n-        &mut []\n-      //^^^^^^^<unsize>\n-      //^^^^^^^&mut $\n-      //^^^^^^^*\n-    } else {\n-        loop {}\n-      //^^^^^^^<never-to-any>\n-    };\n-    let _: &mut [u32] = match () { () => &mut [] }\n-                                       //^^^^^^^<unsize>\n-                                       //^^^^^^^&mut $\n-                                       //^^^^^^^*\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Struct;\n-impl Struct {\n-    fn consume(self) {}\n-    fn by_ref(&self) {}\n-    fn by_ref_mut(&mut self) {}\n-}\n-trait Trait {}\n-impl Trait for Struct {}\n-\"#,\n-        )\n-    }\n }"}, {"sha": "983aa1dfd56c5d7bbc5277f006b43c53ac3388a2", "filename": "crates/ide/src/inlay_hints/adjustment.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,216 @@\n+//! Implementation of \"adjustment\" inlay hints:\n+//! ```no_run\n+//! let _: u32  = /* <never-to-any> */ loop {};\n+//! let _: &u32 = /* &* */ &mut 0;\n+//! ```\n+use hir::{Adjust, AutoBorrow, Mutability, OverloadedDeref, PointerCast, Safety, Semantics};\n+use ide_db::RootDatabase;\n+\n+use syntax::ast::{self, AstNode};\n+\n+use crate::{AdjustmentHints, InlayHint, InlayHintsConfig, InlayKind};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    expr: &ast::Expr,\n+) -> Option<()> {\n+    if config.adjustment_hints == AdjustmentHints::Never {\n+        return None;\n+    }\n+\n+    // These inherit from the inner expression which would result in duplicate hints\n+    if let ast::Expr::ParenExpr(_)\n+    | ast::Expr::IfExpr(_)\n+    | ast::Expr::BlockExpr(_)\n+    | ast::Expr::MatchExpr(_) = expr\n+    {\n+        return None;\n+    }\n+\n+    let parent = expr.syntax().parent().and_then(ast::Expr::cast);\n+    let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+    let desc_expr = descended.as_ref().unwrap_or(expr);\n+    let adjustments = sema.expr_adjustments(desc_expr).filter(|it| !it.is_empty())?;\n+    let needs_parens = match parent {\n+        Some(parent) => {\n+            match parent {\n+                ast::Expr::AwaitExpr(_)\n+                | ast::Expr::CallExpr(_)\n+                | ast::Expr::CastExpr(_)\n+                | ast::Expr::FieldExpr(_)\n+                | ast::Expr::MethodCallExpr(_)\n+                | ast::Expr::TryExpr(_) => true,\n+                // FIXME: shorthands need special casing, though not sure if adjustments are even valid there\n+                ast::Expr::RecordExpr(_) => false,\n+                ast::Expr::IndexExpr(index) => index.base().as_ref() == Some(expr),\n+                _ => false,\n+            }\n+        }\n+        None => false,\n+    };\n+    if needs_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::OpeningParenthesis,\n+            label: \"(\".into(),\n+            tooltip: None,\n+        });\n+    }\n+    for adjustment in adjustments.into_iter().rev() {\n+        // FIXME: Add some nicer tooltips to each of these\n+        let text = match adjustment {\n+            Adjust::NeverToAny if config.adjustment_hints == AdjustmentHints::Always => {\n+                \"<never-to-any>\"\n+            }\n+            Adjust::Deref(None) => \"*\",\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Mut))) => \"*\",\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Shared))) => \"*\",\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Shared)) => \"&\",\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Mut)) => \"&mut \",\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Shared)) => \"&raw const \",\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Mut)) => \"&raw mut \",\n+            // some of these could be represented via `as` casts, but that's not too nice and\n+            // handling everything as a prefix expr makes the `(` and `)` insertion easier\n+            Adjust::Pointer(cast) if config.adjustment_hints == AdjustmentHints::Always => {\n+                match cast {\n+                    PointerCast::ReifyFnPointer => \"<fn-item-to-fn-pointer>\",\n+                    PointerCast::UnsafeFnPointer => \"<safe-fn-pointer-to-unsafe-fn-pointer>\",\n+                    PointerCast::ClosureFnPointer(Safety::Unsafe) => {\n+                        \"<closure-to-unsafe-fn-pointer>\"\n+                    }\n+                    PointerCast::ClosureFnPointer(Safety::Safe) => \"<closure-to-fn-pointer>\",\n+                    PointerCast::MutToConstPointer => \"<mut-ptr-to-const-ptr>\",\n+                    PointerCast::ArrayToPointer => \"<array-ptr-to-element-ptr>\",\n+                    PointerCast::Unsize => \"<unsize>\",\n+                }\n+            }\n+            _ => continue,\n+        };\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::AdjustmentHint,\n+            label: text.into(),\n+            tooltip: None,\n+        });\n+    }\n+    if needs_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::ClosingParenthesis,\n+            label: \")\".into(),\n+            tooltip: None,\n+        });\n+    }\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},\n+        AdjustmentHints, InlayHintsConfig,\n+    };\n+\n+    #[test]\n+    fn adjustment_hints() {\n+        check_with_config(\n+            InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: coerce_unsized\n+fn main() {\n+    let _: u32         = loop {};\n+                       //^^^^^^^<never-to-any>\n+    let _: &u32        = &mut 0;\n+                       //^^^^^^&\n+                       //^^^^^^*\n+    let _: &mut u32    = &mut 0;\n+                       //^^^^^^&mut $\n+                       //^^^^^^*\n+    let _: *const u32  = &mut 0;\n+                       //^^^^^^&raw const $\n+                       //^^^^^^*\n+    let _: *mut u32    = &mut 0;\n+                       //^^^^^^&raw mut $\n+                       //^^^^^^*\n+    let _: fn()        = main;\n+                       //^^^^<fn-item-to-fn-pointer>\n+    let _: unsafe fn() = main;\n+                       //^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n+                       //^^^^<fn-item-to-fn-pointer>\n+    let _: unsafe fn() = main as fn();\n+                       //^^^^^^^^^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n+    let _: fn()        = || {};\n+                       //^^^^^<closure-to-fn-pointer>\n+    let _: unsafe fn() = || {};\n+                       //^^^^^<closure-to-unsafe-fn-pointer>\n+    let _: *const u32  = &mut 0u32 as *mut u32;\n+                       //^^^^^^^^^^^^^^^^^^^^^<mut-ptr-to-const-ptr>\n+    let _: &mut [_]    = &mut [0; 0];\n+                       //^^^^^^^^^^^<unsize>\n+                       //^^^^^^^^^^^&mut $\n+                       //^^^^^^^^^^^*\n+\n+    Struct.consume();\n+    Struct.by_ref();\n+  //^^^^^^(\n+  //^^^^^^&\n+  //^^^^^^)\n+    Struct.by_ref_mut();\n+  //^^^^^^(\n+  //^^^^^^&mut $\n+  //^^^^^^)\n+\n+    (&Struct).consume();\n+   //^^^^^^^*\n+    (&Struct).by_ref();\n+\n+    (&mut Struct).consume();\n+   //^^^^^^^^^^^*\n+    (&mut Struct).by_ref();\n+   //^^^^^^^^^^^&\n+   //^^^^^^^^^^^*\n+    (&mut Struct).by_ref_mut();\n+\n+    // Check that block-like expressions don't duplicate hints\n+    let _: &mut [u32] = (&mut []);\n+                       //^^^^^^^<unsize>\n+                       //^^^^^^^&mut $\n+                       //^^^^^^^*\n+    let _: &mut [u32] = { &mut [] };\n+                        //^^^^^^^<unsize>\n+                        //^^^^^^^&mut $\n+                        //^^^^^^^*\n+    let _: &mut [u32] = unsafe { &mut [] };\n+                               //^^^^^^^<unsize>\n+                               //^^^^^^^&mut $\n+                               //^^^^^^^*\n+    let _: &mut [u32] = if true {\n+        &mut []\n+      //^^^^^^^<unsize>\n+      //^^^^^^^&mut $\n+      //^^^^^^^*\n+    } else {\n+        loop {}\n+      //^^^^^^^<never-to-any>\n+    };\n+    let _: &mut [u32] = match () { () => &mut [] }\n+                                       //^^^^^^^<unsize>\n+                                       //^^^^^^^&mut $\n+                                       //^^^^^^^*\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Struct;\n+impl Struct {\n+    fn consume(self) {}\n+    fn by_ref(&self) {}\n+    fn by_ref_mut(&mut self) {}\n+}\n+trait Trait {}\n+impl Trait for Struct {}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "754df09df1d1ff9cb565e852b7949d33b10061a2", "filename": "crates/ide/src/inlay_hints/bind_pat.rs", "status": "added", "additions": 961, "deletions": 0, "changes": 961, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,961 @@\n+//! Implementation of \"type\" inlay hints:\n+//! ```no_run\n+//! fn f(a: i32, b: i32) -> i32 { a + b }\n+//! let _x /* i32 */= f(4, 4);\n+//! ```\n+use hir::{HirDisplay, Semantics, TypeInfo};\n+use ide_db::{base_db::FileId, famous_defs::FamousDefs, RootDatabase};\n+\n+use itertools::Itertools;\n+use syntax::{\n+    ast::{self, AstNode, HasName},\n+    match_ast,\n+};\n+\n+use crate::{\n+    inlay_hints::{closure_has_block_body, hint_iterator},\n+    InlayHint, InlayHintsConfig, InlayKind, InlayTooltip,\n+};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    file_id: FileId,\n+    pat: &ast::IdentPat,\n+) -> Option<()> {\n+    if !config.type_hints {\n+        return None;\n+    }\n+\n+    let descended = sema.descend_node_into_attributes(pat.clone()).pop();\n+    let desc_pat = descended.as_ref().unwrap_or(pat);\n+    let ty = sema.type_of_pat(&desc_pat.clone().into())?.original;\n+\n+    if should_not_display_type_hint(sema, config, pat, &ty) {\n+        return None;\n+    }\n+\n+    let krate = sema.scope(desc_pat.syntax())?.krate();\n+    let famous_defs = FamousDefs(sema, krate);\n+    let label = hint_iterator(sema, &famous_defs, config, &ty);\n+\n+    let label = match label {\n+        Some(label) => label,\n+        None => {\n+            let ty_name = ty.display_truncated(sema.db, config.max_length).to_string();\n+            if config.hide_named_constructor_hints\n+                && is_named_constructor(sema, pat, &ty_name).is_some()\n+            {\n+                return None;\n+            }\n+            ty_name\n+        }\n+    };\n+\n+    acc.push(InlayHint {\n+        range: match pat.name() {\n+            Some(name) => name.syntax().text_range(),\n+            None => pat.syntax().text_range(),\n+        },\n+        kind: InlayKind::TypeHint,\n+        label: label.into(),\n+        tooltip: pat\n+            .name()\n+            .map(|it| it.syntax().text_range())\n+            .map(|it| InlayTooltip::HoverRanged(file_id, it)),\n+    });\n+\n+    Some(())\n+}\n+\n+fn should_not_display_type_hint(\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    bind_pat: &ast::IdentPat,\n+    pat_ty: &hir::Type,\n+) -> bool {\n+    let db = sema.db;\n+\n+    if pat_ty.is_unknown() {\n+        return true;\n+    }\n+\n+    if let Some(hir::Adt::Struct(s)) = pat_ty.as_adt() {\n+        if s.fields(db).is_empty() && s.name(db).to_smol_str() == bind_pat.to_string() {\n+            return true;\n+        }\n+    }\n+\n+    if config.hide_closure_initialization_hints {\n+        if let Some(parent) = bind_pat.syntax().parent() {\n+            if let Some(it) = ast::LetStmt::cast(parent.clone()) {\n+                if let Some(ast::Expr::ClosureExpr(closure)) = it.initializer() {\n+                    if closure_has_block_body(&closure) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    for node in bind_pat.syntax().ancestors() {\n+        match_ast! {\n+            match node {\n+                ast::LetStmt(it) => return it.ty().is_some(),\n+                // FIXME: We might wanna show type hints in parameters for non-top level patterns as well\n+                ast::Param(it) => return it.ty().is_some(),\n+                ast::MatchArm(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n+                ast::LetExpr(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n+                ast::IfExpr(_) => return false,\n+                ast::WhileExpr(_) => return false,\n+                ast::ForExpr(it) => {\n+                    // We *should* display hint only if user provided \"in {expr}\" and we know the type of expr (and it's not unit).\n+                    // Type of expr should be iterable.\n+                    return it.in_token().is_none() ||\n+                        it.iterable()\n+                            .and_then(|iterable_expr| sema.type_of_expr(&iterable_expr))\n+                            .map(TypeInfo::original)\n+                            .map_or(true, |iterable_ty| iterable_ty.is_unknown() || iterable_ty.is_unit())\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn is_named_constructor(\n+    sema: &Semantics<'_, RootDatabase>,\n+    pat: &ast::IdentPat,\n+    ty_name: &str,\n+) -> Option<()> {\n+    let let_node = pat.syntax().parent()?;\n+    let expr = match_ast! {\n+        match let_node {\n+            ast::LetStmt(it) => it.initializer(),\n+            ast::LetExpr(it) => it.expr(),\n+            _ => None,\n+        }\n+    }?;\n+\n+    let expr = sema.descend_node_into_attributes(expr.clone()).pop().unwrap_or(expr);\n+    // unwrap postfix expressions\n+    let expr = match expr {\n+        ast::Expr::TryExpr(it) => it.expr(),\n+        ast::Expr::AwaitExpr(it) => it.expr(),\n+        expr => Some(expr),\n+    }?;\n+    let expr = match expr {\n+        ast::Expr::CallExpr(call) => match call.expr()? {\n+            ast::Expr::PathExpr(path) => path,\n+            _ => return None,\n+        },\n+        ast::Expr::PathExpr(path) => path,\n+        _ => return None,\n+    };\n+    let path = expr.path()?;\n+\n+    let callable = sema.type_of_expr(&ast::Expr::PathExpr(expr))?.original.as_callable(sema.db);\n+    let callable_kind = callable.map(|it| it.kind());\n+    let qual_seg = match callable_kind {\n+        Some(hir::CallableKind::Function(_) | hir::CallableKind::TupleEnumVariant(_)) => {\n+            path.qualifier()?.segment()\n+        }\n+        _ => path.segment(),\n+    }?;\n+\n+    let ctor_name = match qual_seg.kind()? {\n+        ast::PathSegmentKind::Name(name_ref) => {\n+            match qual_seg.generic_arg_list().map(|it| it.generic_args()) {\n+                Some(generics) => format!(\"{}<{}>\", name_ref, generics.format(\", \")),\n+                None => name_ref.to_string(),\n+            }\n+        }\n+        ast::PathSegmentKind::Type { type_ref: Some(ty), trait_ref: None } => ty.to_string(),\n+        _ => return None,\n+    };\n+    (ctor_name == ty_name).then(|| ())\n+}\n+\n+fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir::Type) -> bool {\n+    if let Some(hir::Adt::Enum(enum_data)) = pat_ty.as_adt() {\n+        let pat_text = bind_pat.to_string();\n+        enum_data\n+            .variants(db)\n+            .into_iter()\n+            .map(|variant| variant.name(db).to_smol_str())\n+            .any(|enum_name| enum_name == pat_text)\n+    } else {\n+        false\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    // This module also contains tests for super::closure_ret\n+\n+    use expect_test::expect;\n+    use syntax::{TextRange, TextSize};\n+    use test_utils::extract_annotations;\n+\n+    use crate::{fixture, inlay_hints::InlayHintsConfig};\n+\n+    use crate::inlay_hints::tests::{\n+        check, check_expect, check_with_config, DISABLED_CONFIG, TEST_CONFIG,\n+    };\n+    use crate::ClosureReturnTypeHints;\n+\n+    #[track_caller]\n+    fn check_types(ra_fixture: &str) {\n+        check_with_config(InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG }, ra_fixture);\n+    }\n+\n+    #[test]\n+    fn type_hints_only() {\n+        check_types(\n+            r#\"\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn main() {\n+    let _x = foo(4, 4);\n+      //^^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn type_hints_bindings_after_at() {\n+        check_types(\n+            r#\"\n+//- minicore: option\n+fn main() {\n+    let ref foo @ bar @ ref mut baz = 0;\n+          //^^^ &i32\n+                //^^^ i32\n+                              //^^^ &mut i32\n+    let [x @ ..] = [0];\n+       //^ [i32; 1]\n+    if let x @ Some(_) = Some(0) {}\n+         //^ Option<i32>\n+    let foo @ (bar, baz) = (3, 3);\n+      //^^^ (i32, i32)\n+             //^^^ i32\n+                  //^^^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn default_generic_types_should_not_be_displayed() {\n+        check(\n+            r#\"\n+struct Test<K, T = u8> { k: K, t: T }\n+\n+fn main() {\n+    let zz = Test { t: 23u8, k: 33 };\n+      //^^ Test<i32>\n+    let zz_ref = &zz;\n+      //^^^^^^ &Test<i32>\n+    let test = || zz;\n+      //^^^^ || -> Test<i32>\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn shorten_iterators_in_associated_params() {\n+        check_types(\n+            r#\"\n+//- minicore: iterators\n+use core::iter;\n+\n+pub struct SomeIter<T> {}\n+\n+impl<T> SomeIter<T> {\n+    pub fn new() -> Self { SomeIter {} }\n+    pub fn push(&mut self, t: T) {}\n+}\n+\n+impl<T> Iterator for SomeIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let mut some_iter = SomeIter::new();\n+          //^^^^^^^^^ SomeIter<Take<Repeat<i32>>>\n+      some_iter.push(iter::repeat(2).take(2));\n+    let iter_of_iters = some_iter.take(2);\n+      //^^^^^^^^^^^^^ impl Iterator<Item = impl Iterator<Item = i32>>\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn iterator_hint_regression_issue_12674() {\n+        // Ensure we don't crash while solving the projection type of iterators.\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: iterators\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn iter(&self) -> Iter<'_, T> { loop {} }\n+}\n+struct Iter<'a, T: 'a>(&'a T);\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> { loop {} }\n+}\n+struct Container<'a> {\n+    elements: S<&'a str>,\n+}\n+struct SliceIter<'a, T>(&'a T);\n+impl<'a, T> Iterator for SliceIter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> { loop {} }\n+}\n+\n+fn main(a: SliceIter<'_, Container>) {\n+    a\n+    .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n+    .map(|e| e);\n+}\n+            \"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 484..554,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = impl Iterator<Item = &&str>>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                484..554,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 484..485,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"SliceIter<Container>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                484..485,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn infer_call_method_return_associated_types_with_generic() {\n+        check_types(\n+            r#\"\n+            pub trait Default {\n+                fn default() -> Self;\n+            }\n+            pub trait Foo {\n+                type Bar: Default;\n+            }\n+\n+            pub fn quux<T: Foo>() -> T::Bar {\n+                let y = Default::default();\n+                  //^ <T as Foo>::Bar\n+\n+                y\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_hints() {\n+        check_types(\n+            r#\"\n+//- minicore: fn, sized\n+fn foo() -> impl Fn() { loop {} }\n+fn foo1() -> impl Fn(f64) { loop {} }\n+fn foo2() -> impl Fn(f64, f64) { loop {} }\n+fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n+fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n+fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n+fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n+fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo();\n+     // ^^^ impl Fn()\n+    let foo = foo1();\n+     // ^^^ impl Fn(f64)\n+    let foo = foo2();\n+     // ^^^ impl Fn(f64, f64)\n+    let foo = foo3();\n+     // ^^^ impl Fn(f64, f64) -> u32\n+    let foo = foo4();\n+     // ^^^ &dyn Fn(f64, f64) -> u32\n+    let foo = foo5();\n+     // ^^^ &dyn Fn(&dyn Fn(f64, f64) -> u32, f64) -> u32\n+    let foo = foo6();\n+     // ^^^ impl Fn(f64, f64) -> u32\n+    let foo = foo7();\n+     // ^^^ *const impl Fn(f64, f64) -> u32\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn check_hint_range_limit() {\n+        let fixture = r#\"\n+        //- minicore: fn, sized\n+        fn foo() -> impl Fn() { loop {} }\n+        fn foo1() -> impl Fn(f64) { loop {} }\n+        fn foo2() -> impl Fn(f64, f64) { loop {} }\n+        fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n+        fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n+        fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n+        fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n+        fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n+\n+        fn main() {\n+            let foo = foo();\n+            let foo = foo1();\n+            let foo = foo2();\n+             // ^^^ impl Fn(f64, f64)\n+            let foo = foo3();\n+             // ^^^ impl Fn(f64, f64) -> u32\n+            let foo = foo4();\n+            let foo = foo5();\n+            let foo = foo6();\n+            let foo = foo7();\n+        }\n+        \"#;\n+        let (analysis, file_id) = fixture::file(fixture);\n+        let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n+        let inlay_hints = analysis\n+            .inlay_hints(\n+                &InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },\n+                file_id,\n+                Some(TextRange::new(TextSize::from(500), TextSize::from(600))),\n+            )\n+            .unwrap();\n+        let actual =\n+            inlay_hints.into_iter().map(|it| (it.range, it.label.to_string())).collect::<Vec<_>>();\n+        assert_eq!(expected, actual, \"\\nExpected:\\n{:#?}\\n\\nActual:\\n{:#?}\", expected, actual);\n+    }\n+\n+    #[test]\n+    fn fn_hints_ptr_rpit_fn_parentheses() {\n+        check_types(\n+            r#\"\n+//- minicore: fn, sized\n+trait Trait {}\n+\n+fn foo1() -> *const impl Fn() { loop {} }\n+fn foo2() -> *const (impl Fn() + Sized) { loop {} }\n+fn foo3() -> *const (impl Fn() + ?Sized) { loop {} }\n+fn foo4() -> *const (impl Sized + Fn()) { loop {} }\n+fn foo5() -> *const (impl ?Sized + Fn()) { loop {} }\n+fn foo6() -> *const (impl Fn() + Trait) { loop {} }\n+fn foo7() -> *const (impl Fn() + Sized + Trait) { loop {} }\n+fn foo8() -> *const (impl Fn() + ?Sized + Trait) { loop {} }\n+fn foo9() -> *const (impl Fn() -> u8 + ?Sized) { loop {} }\n+fn foo10() -> *const (impl Fn() + Sized + ?Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo1();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo2();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo3();\n+    //  ^^^ *const (impl Fn() + ?Sized)\n+    let foo = foo4();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo5();\n+    //  ^^^ *const (impl Fn() + ?Sized)\n+    let foo = foo6();\n+    //  ^^^ *const (impl Fn() + Trait)\n+    let foo = foo7();\n+    //  ^^^ *const (impl Fn() + Trait)\n+    let foo = foo8();\n+    //  ^^^ *const (impl Fn() + Trait + ?Sized)\n+    let foo = foo9();\n+    //  ^^^ *const (impl Fn() -> u8 + ?Sized)\n+    let foo = foo10();\n+    //  ^^^ *const impl Fn()\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unit_structs_have_no_type_hints() {\n+        check_types(\n+            r#\"\n+//- minicore: result\n+struct SyntheticSyntax;\n+\n+fn main() {\n+    match Ok(()) {\n+        Ok(_) => (),\n+        Err(SyntheticSyntax) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn let_statement() {\n+        check_types(\n+            r#\"\n+#[derive(PartialEq)]\n+enum Option<T> { None, Some(T) }\n+\n+#[derive(PartialEq)]\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    struct InnerStruct {}\n+\n+    let test = 54;\n+      //^^^^ i32\n+    let test: i32 = 33;\n+    let mut test = 33;\n+          //^^^^ i32\n+    let _ = 22;\n+    let test = \"test\";\n+      //^^^^ &str\n+    let test = InnerStruct {};\n+      //^^^^ InnerStruct\n+\n+    let test = unresolved();\n+\n+    let test = (42, 'a');\n+      //^^^^ (i32, char)\n+    let (a,    (b,     (c,)) = (2, (3, (9.2,));\n+       //^ i32  ^ i32   ^ f64\n+    let &x = &92;\n+       //^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn if_expr() {\n+        check_types(\n+            r#\"\n+//- minicore: option\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    let test = Some(Test { a: Some(3), b: 1 });\n+      //^^^^ Option<Test>\n+    if let None = &test {};\n+    if let test = &test {};\n+         //^^^^ &Option<Test>\n+    if let Some(test) = &test {};\n+              //^^^^ &Test\n+    if let Some(Test { a,             b }) = &test {};\n+                     //^ &Option<u32> ^ &u8\n+    if let Some(Test { a: x,             b: y }) = &test {};\n+                        //^ &Option<u32>    ^ &u8\n+    if let Some(Test { a: Some(x),  b: y }) = &test {};\n+                             //^ &u32  ^ &u8\n+    if let Some(Test { a: None,  b: y }) = &test {};\n+                                  //^ &u8\n+    if let Some(Test { b: y, .. }) = &test {};\n+                        //^ &u8\n+    if test == None {}\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn while_expr() {\n+        check_types(\n+            r#\"\n+//- minicore: option\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    let test = Some(Test { a: Some(3), b: 1 });\n+      //^^^^ Option<Test>\n+    while let Some(Test { a: Some(x),  b: y }) = &test {};\n+                                //^ &u32  ^ &u8\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_arm_list() {\n+        check_types(\n+            r#\"\n+//- minicore: option\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    match Some(Test { a: Some(3), b: 1 }) {\n+        None => (),\n+        test => (),\n+      //^^^^ Option<Test>\n+        Some(Test { a: Some(x), b: y }) => (),\n+                          //^ u32  ^ u8\n+        _ => {}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_for_hint() {\n+        check_types(\n+            r#\"\n+//- minicore: iterator\n+pub struct Vec<T> {}\n+\n+impl<T> Vec<T> {\n+    pub fn new() -> Self { Vec {} }\n+    pub fn push(&mut self, t: T) {}\n+}\n+\n+impl<T> IntoIterator for Vec<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+}\n+\n+struct IntoIter<T> {}\n+\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+}\n+\n+fn main() {\n+    let mut data = Vec::new();\n+          //^^^^ Vec<&str>\n+    data.push(\"foo\");\n+    for i in data {\n+      //^ &str\n+      let z = i;\n+        //^ &str\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn multi_dyn_trait_bounds() {\n+        check_types(\n+            r#\"\n+pub struct Vec<T> {}\n+\n+impl<T> Vec<T> {\n+    pub fn new() -> Self { Vec {} }\n+}\n+\n+pub struct Box<T> {}\n+\n+trait Display {}\n+auto trait Sync {}\n+\n+fn main() {\n+    // The block expression wrapping disables the constructor hint hiding logic\n+    let _v = { Vec::<Box<&(dyn Display + Sync)>>::new() };\n+      //^^ Vec<Box<&(dyn Display + Sync)>>\n+    let _v = { Vec::<Box<*const (dyn Display + Sync)>>::new() };\n+      //^^ Vec<Box<*const (dyn Display + Sync)>>\n+    let _v = { Vec::<Box<dyn Display + Sync>>::new() };\n+      //^^ Vec<Box<dyn Display + Sync>>\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn shorten_iterator_hints() {\n+        check_types(\n+            r#\"\n+//- minicore: iterators\n+use core::iter;\n+\n+struct MyIter;\n+\n+impl Iterator for MyIter {\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let _x = MyIter;\n+      //^^ MyIter\n+    let _x = iter::repeat(0);\n+      //^^ impl Iterator<Item = i32>\n+    fn generic<T: Clone>(t: T) {\n+        let _x = iter::repeat(t);\n+          //^^ impl Iterator<Item = T>\n+        let _chained = iter::repeat(t).take(10);\n+          //^^^^^^^^ impl Iterator<Item = T>\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn skip_constructor_and_enum_type_hints() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                hide_named_constructor_hints: true,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: try, option\n+use core::ops::ControlFlow;\n+\n+mod x {\n+    pub mod y { pub struct Foo; }\n+    pub struct Foo;\n+    pub enum AnotherEnum {\n+        Variant()\n+    };\n+}\n+struct Struct;\n+struct TupleStruct();\n+\n+impl Struct {\n+    fn new() -> Self {\n+        Struct\n+    }\n+    fn try_new() -> ControlFlow<(), Self> {\n+        ControlFlow::Continue(Struct)\n+    }\n+}\n+\n+struct Generic<T>(T);\n+impl Generic<i32> {\n+    fn new() -> Self {\n+        Generic(0)\n+    }\n+}\n+\n+enum Enum {\n+    Variant(u32)\n+}\n+\n+fn times2(value: i32) -> i32 {\n+    2 * value\n+}\n+\n+fn main() {\n+    let enumb = Enum::Variant(0);\n+\n+    let strukt = x::Foo;\n+    let strukt = x::y::Foo;\n+    let strukt = Struct;\n+    let strukt = Struct::new();\n+\n+    let tuple_struct = TupleStruct();\n+\n+    let generic0 = Generic::new();\n+    //  ^^^^^^^^ Generic<i32>\n+    let generic1 = Generic(0);\n+    //  ^^^^^^^^ Generic<i32>\n+    let generic2 = Generic::<i32>::new();\n+    let generic3 = <Generic<i32>>::new();\n+    let generic4 = Generic::<i32>(0);\n+\n+\n+    let option = Some(0);\n+    //  ^^^^^^ Option<i32>\n+    let func = times2;\n+    //  ^^^^ fn times2(i32) -> i32\n+    let closure = |x: i32| x * 2;\n+    //  ^^^^^^^ |i32| -> i32\n+}\n+\n+fn fallible() -> ControlFlow<()> {\n+    let strukt = Struct::try_new()?;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn shows_constructor_type_hints_when_enabled() {\n+        check_types(\n+            r#\"\n+//- minicore: try\n+use core::ops::ControlFlow;\n+\n+struct Struct;\n+struct TupleStruct();\n+\n+impl Struct {\n+    fn new() -> Self {\n+        Struct\n+    }\n+    fn try_new() -> ControlFlow<(), Self> {\n+        ControlFlow::Continue(Struct)\n+    }\n+}\n+\n+struct Generic<T>(T);\n+impl Generic<i32> {\n+    fn new() -> Self {\n+        Generic(0)\n+    }\n+}\n+\n+fn main() {\n+    let strukt = Struct::new();\n+     // ^^^^^^ Struct\n+    let tuple_struct = TupleStruct();\n+     // ^^^^^^^^^^^^ TupleStruct\n+    let generic0 = Generic::new();\n+     // ^^^^^^^^ Generic<i32>\n+    let generic1 = Generic::<i32>::new();\n+     // ^^^^^^^^ Generic<i32>\n+    let generic2 = <Generic<i32>>::new();\n+     // ^^^^^^^^ Generic<i32>\n+}\n+\n+fn fallible() -> ControlFlow<()> {\n+    let strukt = Struct::try_new()?;\n+     // ^^^^^^ Struct\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closures() {\n+        check(\n+            r#\"\n+fn main() {\n+    let mut start = 0;\n+          //^^^^^ i32\n+    (0..2).for_each(|increment      | { start += increment; });\n+                   //^^^^^^^^^ i32\n+\n+    let multiply =\n+      //^^^^^^^^ |i32, i32| -> i32\n+      | a,     b| a * b\n+      //^ i32  ^ i32\n+\n+    ;\n+\n+    let _: i32 = multiply(1,  2);\n+                        //^ a ^ b\n+    let multiply_ref = &multiply;\n+      //^^^^^^^^^^^^ &|i32, i32| -> i32\n+\n+    let return_42 = || 42;\n+      //^^^^^^^^^ || -> i32\n+      || { 42 };\n+    //^^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_type_hints_for_closure_without_block() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                closure_return_type_hints: ClosureReturnTypeHints::Always,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+fn main() {\n+    let a = || { 0 };\n+          //^^ i32\n+    let b = || 0;\n+          //^^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn skip_closure_type_hints() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                hide_closure_initialization_hints: true,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let multiple_2 = |x: i32| { x * 2 };\n+\n+    let multiple_2 = |x: i32| x * 2;\n+    //  ^^^^^^^^^^ |i32| -> i32\n+\n+    let (not) = (|x: bool| { !x });\n+    //   ^^^ |bool| -> bool\n+\n+    let (is_zero, _b) = (|x: usize| { x == 0 }, false);\n+    //   ^^^^^^^ |usize| -> bool\n+    //            ^^ bool\n+\n+    let plus_one = |x| { x + 1 };\n+    //              ^ u8\n+    foo(plus_one);\n+\n+    let add_mul = bar(|x: u8| { x + 1 });\n+    //  ^^^^^^^ impl FnOnce(u8) -> u8 + ?Sized\n+\n+    let closure = if let Some(6) = add_mul(2).checked_sub(1) {\n+    //  ^^^^^^^ fn(i32) -> i32\n+        |x: i32| { x * 2 }\n+    } else {\n+        |x: i32| { x * 3 }\n+    };\n+}\n+\n+fn foo(f: impl FnOnce(u8) -> u8) {}\n+\n+fn bar(f: impl FnOnce(u8) -> u8) -> impl FnOnce(u8) -> u8 {\n+    move |x: u8| f(x) * 2\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hint_truncation() {\n+        check_with_config(\n+            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n+            r#\"\n+struct Smol<T>(T);\n+\n+struct VeryLongOuterName<T>(T);\n+\n+fn main() {\n+    let a = Smol(0u32);\n+      //^ Smol<u32>\n+    let b = VeryLongOuterName(0usize);\n+      //^ VeryLongOuterName<\u2026>\n+    let c = Smol(Smol(0u32))\n+      //^ Smol<Smol<\u2026>>\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "846f0a4e0c16d0c794a1d8fc7915a86edd0dbb71", "filename": "crates/ide/src/inlay_hints/binding_mode.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,141 @@\n+//! Implementation of \"binding mode\" inlay hints:\n+//! ```no_run\n+//! let /* & */ (/* ref */ x,) = &(0,);\n+//! ```\n+use hir::{Mutability, Semantics};\n+use ide_db::RootDatabase;\n+\n+use syntax::ast::{self, AstNode};\n+\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    pat: &ast::Pat,\n+) -> Option<()> {\n+    if !config.binding_mode_hints {\n+        return None;\n+    }\n+\n+    let outer_paren_pat = pat\n+        .syntax()\n+        .ancestors()\n+        .skip(1)\n+        .map_while(ast::Pat::cast)\n+        .map_while(|pat| match pat {\n+            ast::Pat::ParenPat(pat) => Some(pat),\n+            _ => None,\n+        })\n+        .last();\n+    let range =\n+        outer_paren_pat.as_ref().map_or_else(|| pat.syntax(), |it| it.syntax()).text_range();\n+    sema.pattern_adjustments(&pat).iter().for_each(|ty| {\n+        let reference = ty.is_reference();\n+        let mut_reference = ty.is_mutable_reference();\n+        let r = match (reference, mut_reference) {\n+            (true, true) => \"&mut\",\n+            (true, false) => \"&\",\n+            _ => return,\n+        };\n+        acc.push(InlayHint {\n+            range,\n+            kind: InlayKind::BindingModeHint,\n+            label: r.to_string().into(),\n+            tooltip: Some(InlayTooltip::String(\"Inferred binding mode\".into())),\n+        });\n+    });\n+    match pat {\n+        ast::Pat::IdentPat(pat) if pat.ref_token().is_none() && pat.mut_token().is_none() => {\n+            let bm = sema.binding_mode_of_pat(pat)?;\n+            let bm = match bm {\n+                hir::BindingMode::Move => return None,\n+                hir::BindingMode::Ref(Mutability::Mut) => \"ref mut\",\n+                hir::BindingMode::Ref(Mutability::Shared) => \"ref\",\n+            };\n+            acc.push(InlayHint {\n+                range: pat.syntax().text_range(),\n+                kind: InlayKind::BindingModeHint,\n+                label: bm.to_string().into(),\n+                tooltip: Some(InlayTooltip::String(\"Inferred binding mode\".into())),\n+            });\n+        }\n+        ast::Pat::OrPat(pat) if outer_paren_pat.is_none() => {\n+            acc.push(InlayHint {\n+                range: pat.syntax().text_range(),\n+                kind: InlayKind::OpeningParenthesis,\n+                label: \"(\".into(),\n+                tooltip: None,\n+            });\n+            acc.push(InlayHint {\n+                range: pat.syntax().text_range(),\n+                kind: InlayKind::ClosingParenthesis,\n+                label: \")\".into(),\n+                tooltip: None,\n+            });\n+        }\n+        _ => (),\n+    }\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},\n+        InlayHintsConfig,\n+    };\n+\n+    #[test]\n+    fn hints_binding_modes() {\n+        check_with_config(\n+            InlayHintsConfig { binding_mode_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+fn __(\n+    (x,): (u32,),\n+    (x,): &(u32,),\n+  //^^^^&\n+   //^ ref\n+    (x,): &mut (u32,)\n+  //^^^^&mut\n+   //^ ref mut\n+) {\n+    let (x,) = (0,);\n+    let (x,) = &(0,);\n+      //^^^^ &\n+       //^ ref\n+    let (x,) = &mut (0,);\n+      //^^^^ &mut\n+       //^ ref mut\n+    let &mut (x,) = &mut (0,);\n+    let (ref mut x,) = &mut (0,);\n+      //^^^^^^^^^^^^ &mut\n+    let &mut (ref mut x,) = &mut (0,);\n+    let (mut x,) = &mut (0,);\n+      //^^^^^^^^ &mut\n+    match (0,) {\n+        (x,) => ()\n+    }\n+    match &(0,) {\n+        (x,) | (x,) => (),\n+      //^^^^^^^^^^^&\n+       //^ ref\n+              //^ ref\n+      //^^^^^^^^^^^(\n+      //^^^^^^^^^^^)\n+        ((x,) | (x,)) => (),\n+      //^^^^^^^^^^^^^&\n+        //^ ref\n+               //^ ref\n+    }\n+    match &mut (0,) {\n+        (x,) => ()\n+      //^^^^ &mut\n+       //^ ref mut\n+    }\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "32421afd39ff3e6129b480afc4e886ed426b26ae", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "added", "additions": 459, "deletions": 0, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,459 @@\n+//! Implementation of \"chaining\" inlay hints.\n+use hir::{HirDisplay, Semantics};\n+use ide_db::{famous_defs::FamousDefs, RootDatabase};\n+use syntax::{\n+    ast::{self, AstNode},\n+    Direction, NodeOrToken, SyntaxKind, T,\n+};\n+\n+use crate::{\n+    inlay_hints::hint_iterator, FileId, InlayHint, InlayHintsConfig, InlayKind, InlayTooltip,\n+};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    famous_defs: &FamousDefs<'_, '_>,\n+    config: &InlayHintsConfig,\n+    file_id: FileId,\n+    expr: &ast::Expr,\n+) -> Option<()> {\n+    if !config.chaining_hints {\n+        return None;\n+    }\n+\n+    if matches!(expr, ast::Expr::RecordExpr(_)) {\n+        return None;\n+    }\n+\n+    let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+    let desc_expr = descended.as_ref().unwrap_or(expr);\n+\n+    let mut tokens = expr\n+        .syntax()\n+        .siblings_with_tokens(Direction::Next)\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| match t.kind() {\n+            SyntaxKind::WHITESPACE if !t.text().contains('\\n') => false,\n+            SyntaxKind::COMMENT => false,\n+            _ => true,\n+        });\n+\n+    // Chaining can be defined as an expression whose next sibling tokens are newline and dot\n+    // Ignoring extra whitespace and comments\n+    let next = tokens.next()?.kind();\n+    if next == SyntaxKind::WHITESPACE {\n+        let mut next_next = tokens.next()?.kind();\n+        while next_next == SyntaxKind::WHITESPACE {\n+            next_next = tokens.next()?.kind();\n+        }\n+        if next_next == T![.] {\n+            let ty = sema.type_of_expr(desc_expr)?.original;\n+            if ty.is_unknown() {\n+                return None;\n+            }\n+            if matches!(expr, ast::Expr::PathExpr(_)) {\n+                if let Some(hir::Adt::Struct(st)) = ty.as_adt() {\n+                    if st.fields(sema.db).is_empty() {\n+                        return None;\n+                    }\n+                }\n+            }\n+            acc.push(InlayHint {\n+                range: expr.syntax().text_range(),\n+                kind: InlayKind::ChainingHint,\n+                label: hint_iterator(sema, &famous_defs, config, &ty)\n+                    .unwrap_or_else(|| ty.display_truncated(sema.db, config.max_length).to_string())\n+                    .into(),\n+                tooltip: Some(InlayTooltip::HoverRanged(file_id, expr.syntax().text_range())),\n+            });\n+        }\n+    }\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::expect;\n+\n+    use crate::{\n+        inlay_hints::tests::{check_expect, check_with_config, DISABLED_CONFIG, TEST_CONFIG},\n+        InlayHintsConfig,\n+    };\n+\n+    #[track_caller]\n+    fn check_chains(ra_fixture: &str) {\n+        check_with_config(InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG }, ra_fixture);\n+    }\n+\n+    #[test]\n+    fn chaining_hints_ignore_comments() {\n+        check_expect(\n+            InlayHintsConfig { type_hints: false, chaining_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+struct A(B);\n+impl A { fn into_b(self) -> B { self.0 } }\n+struct B(C);\n+impl B { fn into_c(self) -> C { self.0 } }\n+struct C;\n+\n+fn main() {\n+    let c = A(B(C))\n+        .into_b() // This is a comment\n+        // This is another comment\n+        .into_c();\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 147..172,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"B\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                147..172,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 147..154,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"A\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                147..154,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn chaining_hints_without_newlines() {\n+        check_chains(\n+            r#\"\n+struct A(B);\n+impl A { fn into_b(self) -> B { self.0 } }\n+struct B(C);\n+impl B { fn into_c(self) -> C { self.0 } }\n+struct C;\n+\n+fn main() {\n+    let c = A(B(C)).into_b().into_c();\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_access_chaining_hints() {\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+struct A { pub b: B }\n+struct B { pub c: C }\n+struct C(pub bool);\n+struct D;\n+\n+impl D {\n+    fn foo(&self) -> i32 { 42 }\n+}\n+\n+fn main() {\n+    let x = A { b: B { c: C(true) } }\n+        .b\n+        .c\n+        .0;\n+    let x = D\n+        .foo();\n+}\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 143..190,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"C\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                143..190,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 143..179,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"B\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                143..179,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn generic_chaining_hints() {\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+struct A<T>(T);\n+struct B<T>(T);\n+struct C<T>(T);\n+struct X<T,R>(T, R);\n+\n+impl<T> A<T> {\n+    fn new(t: T) -> Self { A(t) }\n+    fn into_b(self) -> B<T> { B(self.0) }\n+}\n+impl<T> B<T> {\n+    fn into_c(self) -> C<T> { C(self.0) }\n+}\n+fn main() {\n+    let c = A::new(X(42, true))\n+        .into_b()\n+        .into_c();\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 246..283,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"B<X<i32, bool>>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                246..283,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 246..265,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"A<X<i32, bool>>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                246..265,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn shorten_iterator_chaining_hints() {\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: iterators\n+use core::iter;\n+\n+struct MyIter;\n+\n+impl Iterator for MyIter {\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let _x = MyIter.by_ref()\n+        .take(5)\n+        .by_ref()\n+        .take(5)\n+        .by_ref();\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 174..241,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = ()>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                174..241,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 174..224,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = ()>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                174..224,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 174..206,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = ()>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                174..206,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 174..189,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"&mut MyIter\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                174..189,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_in_attr_call() {\n+        check_expect(\n+            TEST_CONFIG,\n+            r#\"\n+//- proc_macros: identity, input_replace\n+struct Struct;\n+impl Struct {\n+    fn chain(self) -> Self {\n+        self\n+    }\n+}\n+#[proc_macros::identity]\n+fn main() {\n+    let strukt = Struct;\n+    strukt\n+        .chain()\n+        .chain()\n+        .chain();\n+    Struct::chain(strukt);\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 124..130,\n+                        kind: TypeHint,\n+                        label: [\n+                            \"Struct\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                124..130,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 145..185,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"Struct\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                145..185,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 145..168,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"Struct\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                145..168,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 222..228,\n+                        kind: ParameterHint,\n+                        label: [\n+                            \"self\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverOffset(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                42,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+}"}, {"sha": "57605b392a810e037849413c0717614a9742de9f", "filename": "crates/ide/src/inlay_hints/closing_brace.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,193 @@\n+//! Implementation of \"closing brace\" inlay hints:\n+//! ```no_run\n+//! fn g() {\n+//! } /* fn g */\n+//! ```\n+use hir::{HirDisplay, Semantics};\n+use ide_db::{base_db::FileRange, RootDatabase};\n+use syntax::{\n+    ast::{self, AstNode, HasName},\n+    match_ast, SyntaxKind, SyntaxNode, T,\n+};\n+\n+use crate::{\n+    inlay_hints::InlayHintLabelPart, FileId, InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind,\n+};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    file_id: FileId,\n+    node: SyntaxNode,\n+) -> Option<()> {\n+    let min_lines = config.closing_brace_hints_min_lines?;\n+\n+    let name = |it: ast::Name| it.syntax().text_range();\n+\n+    let mut closing_token;\n+    let (label, name_range) = if let Some(item_list) = ast::AssocItemList::cast(node.clone()) {\n+        closing_token = item_list.r_curly_token()?;\n+\n+        let parent = item_list.syntax().parent()?;\n+        match_ast! {\n+            match parent {\n+                ast::Impl(imp) => {\n+                    let imp = sema.to_def(&imp)?;\n+                    let ty = imp.self_ty(sema.db);\n+                    let trait_ = imp.trait_(sema.db);\n+                    let hint_text = match trait_ {\n+                        Some(tr) => format!(\"impl {} for {}\", tr.name(sema.db), ty.display_truncated(sema.db, config.max_length)),\n+                        None => format!(\"impl {}\", ty.display_truncated(sema.db, config.max_length)),\n+                    };\n+                    (hint_text, None)\n+                },\n+                ast::Trait(tr) => {\n+                    (format!(\"trait {}\", tr.name()?), tr.name().map(name))\n+                },\n+                _ => return None,\n+            }\n+        }\n+    } else if let Some(list) = ast::ItemList::cast(node.clone()) {\n+        closing_token = list.r_curly_token()?;\n+\n+        let module = ast::Module::cast(list.syntax().parent()?)?;\n+        (format!(\"mod {}\", module.name()?), module.name().map(name))\n+    } else if let Some(block) = ast::BlockExpr::cast(node.clone()) {\n+        closing_token = block.stmt_list()?.r_curly_token()?;\n+\n+        let parent = block.syntax().parent()?;\n+        match_ast! {\n+            match parent {\n+                ast::Fn(it) => {\n+                    // FIXME: this could include parameters, but `HirDisplay` prints too much info\n+                    // and doesn't respect the max length either, so the hints end up way too long\n+                    (format!(\"fn {}\", it.name()?), it.name().map(name))\n+                },\n+                ast::Static(it) => (format!(\"static {}\", it.name()?), it.name().map(name)),\n+                ast::Const(it) => {\n+                    if it.underscore_token().is_some() {\n+                        (\"const _\".into(), None)\n+                    } else {\n+                        (format!(\"const {}\", it.name()?), it.name().map(name))\n+                    }\n+                },\n+                _ => return None,\n+            }\n+        }\n+    } else if let Some(mac) = ast::MacroCall::cast(node.clone()) {\n+        let last_token = mac.syntax().last_token()?;\n+        if last_token.kind() != T![;] && last_token.kind() != SyntaxKind::R_CURLY {\n+            return None;\n+        }\n+        closing_token = last_token;\n+\n+        (\n+            format!(\"{}!\", mac.path()?),\n+            mac.path().and_then(|it| it.segment()).map(|it| it.syntax().text_range()),\n+        )\n+    } else {\n+        return None;\n+    };\n+\n+    if let Some(mut next) = closing_token.next_token() {\n+        if next.kind() == T![;] {\n+            if let Some(tok) = next.next_token() {\n+                closing_token = next;\n+                next = tok;\n+            }\n+        }\n+        if !(next.kind() == SyntaxKind::WHITESPACE && next.text().contains('\\n')) {\n+            // Only display the hint if the `}` is the last token on the line\n+            return None;\n+        }\n+    }\n+\n+    let mut lines = 1;\n+    node.text().for_each_chunk(|s| lines += s.matches('\\n').count());\n+    if lines < min_lines {\n+        return None;\n+    }\n+\n+    let linked_location = name_range.map(|range| FileRange { file_id, range });\n+    acc.push(InlayHint {\n+        range: closing_token.text_range(),\n+        kind: InlayKind::ClosingBraceHint,\n+        label: InlayHintLabel { parts: vec![InlayHintLabelPart { text: label, linked_location }] },\n+        tooltip: None, // provided by label part location\n+    });\n+\n+    None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},\n+        InlayHintsConfig,\n+    };\n+\n+    #[test]\n+    fn hints_closing_brace() {\n+        check_with_config(\n+            InlayHintsConfig { closing_brace_hints_min_lines: Some(2), ..DISABLED_CONFIG },\n+            r#\"\n+fn a() {}\n+\n+fn f() {\n+} // no hint unless `}` is the last token on the line\n+\n+fn g() {\n+  }\n+//^ fn g\n+\n+fn h<T>(with: T, arguments: u8, ...) {\n+  }\n+//^ fn h\n+\n+trait Tr {\n+    fn f();\n+    fn g() {\n+    }\n+  //^ fn g\n+  }\n+//^ trait Tr\n+impl Tr for () {\n+  }\n+//^ impl Tr for ()\n+impl dyn Tr {\n+  }\n+//^ impl dyn Tr\n+\n+static S0: () = 0;\n+static S1: () = {};\n+static S2: () = {\n+ };\n+//^ static S2\n+const _: () = {\n+ };\n+//^ const _\n+\n+mod m {\n+  }\n+//^ mod m\n+\n+m! {}\n+m!();\n+m!(\n+ );\n+//^ m!\n+\n+m! {\n+  }\n+//^ m!\n+\n+fn f() {\n+    let v = vec![\n+    ];\n+  }\n+//^ fn f\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "de04f3ac7516952e429f91324f81c2eb31e5c1e3", "filename": "crates/ide/src/inlay_hints/closure_ret.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,51 @@\n+//! Implementation of \"closure return type\" inlay hints.\n+use hir::{HirDisplay, Semantics};\n+use ide_db::{base_db::FileId, famous_defs::FamousDefs, RootDatabase};\n+use syntax::ast::{self, AstNode};\n+\n+use crate::{\n+    inlay_hints::{closure_has_block_body, hint_iterator},\n+    ClosureReturnTypeHints, InlayHint, InlayHintsConfig, InlayKind, InlayTooltip,\n+};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    famous_defs: &FamousDefs<'_, '_>,\n+    config: &InlayHintsConfig,\n+    file_id: FileId,\n+    closure: ast::ClosureExpr,\n+) -> Option<()> {\n+    if config.closure_return_type_hints == ClosureReturnTypeHints::Never {\n+        return None;\n+    }\n+\n+    if closure.ret_type().is_some() {\n+        return None;\n+    }\n+\n+    if !closure_has_block_body(&closure)\n+        && config.closure_return_type_hints == ClosureReturnTypeHints::WithBlock\n+    {\n+        return None;\n+    }\n+\n+    let param_list = closure.param_list()?;\n+\n+    let closure = sema.descend_node_into_attributes(closure.clone()).pop()?;\n+    let ty = sema.type_of_expr(&ast::Expr::ClosureExpr(closure))?.adjusted();\n+    let callable = ty.as_callable(sema.db)?;\n+    let ty = callable.return_type();\n+    if ty.is_unit() {\n+        return None;\n+    }\n+    acc.push(InlayHint {\n+        range: param_list.syntax().text_range(),\n+        kind: InlayKind::ClosureReturnTypeHint,\n+        label: hint_iterator(sema, &famous_defs, config, &ty)\n+            .unwrap_or_else(|| ty.display_truncated(sema.db, config.max_length).to_string())\n+            .into(),\n+        tooltip: Some(InlayTooltip::HoverRanged(file_id, param_list.syntax().text_range())),\n+    });\n+    Some(())\n+}"}, {"sha": "1f5bcea63a209001264672f39547dc0d2b672256", "filename": "crates/ide/src/inlay_hints/fn_lifetime_fn.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,301 @@\n+//! Implementation of \"lifetime elision\" inlay hints:\n+//! ```no_run\n+//! fn example/* <'0> */(a: &/* '0 */()) {}\n+//! ```\n+use ide_db::{syntax_helpers::node_ext::walk_ty, FxHashMap};\n+use itertools::Itertools;\n+use syntax::SmolStr;\n+use syntax::{\n+    ast::{self, AstNode, HasGenericParams, HasName},\n+    SyntaxToken,\n+};\n+\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip, LifetimeElisionHints};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    config: &InlayHintsConfig,\n+    func: ast::Fn,\n+) -> Option<()> {\n+    if config.lifetime_elision_hints == LifetimeElisionHints::Never {\n+        return None;\n+    }\n+\n+    let mk_lt_hint = |t: SyntaxToken, label: String| InlayHint {\n+        range: t.text_range(),\n+        kind: InlayKind::LifetimeHint,\n+        label: label.into(),\n+        tooltip: Some(InlayTooltip::String(\"Elided lifetime\".into())),\n+    };\n+\n+    let param_list = func.param_list()?;\n+    let generic_param_list = func.generic_param_list();\n+    let ret_type = func.ret_type();\n+    let self_param = param_list.self_param().filter(|it| it.amp_token().is_some());\n+\n+    let is_elided = |lt: &Option<ast::Lifetime>| match lt {\n+        Some(lt) => matches!(lt.text().as_str(), \"'_\"),\n+        None => true,\n+    };\n+\n+    let potential_lt_refs = {\n+        let mut acc: Vec<_> = vec![];\n+        if let Some(self_param) = &self_param {\n+            let lifetime = self_param.lifetime();\n+            let is_elided = is_elided(&lifetime);\n+            acc.push((None, self_param.amp_token(), lifetime, is_elided));\n+        }\n+        param_list.params().filter_map(|it| Some((it.pat(), it.ty()?))).for_each(|(pat, ty)| {\n+            // FIXME: check path types\n+            walk_ty(&ty, &mut |ty| match ty {\n+                ast::Type::RefType(r) => {\n+                    let lifetime = r.lifetime();\n+                    let is_elided = is_elided(&lifetime);\n+                    acc.push((\n+                        pat.as_ref().and_then(|it| match it {\n+                            ast::Pat::IdentPat(p) => p.name(),\n+                            _ => None,\n+                        }),\n+                        r.amp_token(),\n+                        lifetime,\n+                        is_elided,\n+                    ))\n+                }\n+                _ => (),\n+            })\n+        });\n+        acc\n+    };\n+\n+    // allocate names\n+    let mut gen_idx_name = {\n+        let mut gen = (0u8..).map(|idx| match idx {\n+            idx if idx < 10 => SmolStr::from_iter(['\\'', (idx + 48) as char]),\n+            idx => format!(\"'{idx}\").into(),\n+        });\n+        move || gen.next().unwrap_or_default()\n+    };\n+    let mut allocated_lifetimes = vec![];\n+\n+    let mut used_names: FxHashMap<SmolStr, usize> =\n+        match config.param_names_for_lifetime_elision_hints {\n+            true => generic_param_list\n+                .iter()\n+                .flat_map(|gpl| gpl.lifetime_params())\n+                .filter_map(|param| param.lifetime())\n+                .filter_map(|lt| Some((SmolStr::from(lt.text().as_str().get(1..)?), 0)))\n+                .collect(),\n+            false => Default::default(),\n+        };\n+    {\n+        let mut potential_lt_refs = potential_lt_refs.iter().filter(|&&(.., is_elided)| is_elided);\n+        if let Some(_) = &self_param {\n+            if let Some(_) = potential_lt_refs.next() {\n+                allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n+                    // self can't be used as a lifetime, so no need to check for collisions\n+                    \"'self\".into()\n+                } else {\n+                    gen_idx_name()\n+                });\n+            }\n+        }\n+        potential_lt_refs.for_each(|(name, ..)| {\n+            let name = match name {\n+                Some(it) if config.param_names_for_lifetime_elision_hints => {\n+                    if let Some(c) = used_names.get_mut(it.text().as_str()) {\n+                        *c += 1;\n+                        SmolStr::from(format!(\"'{text}{c}\", text = it.text().as_str()))\n+                    } else {\n+                        used_names.insert(it.text().as_str().into(), 0);\n+                        SmolStr::from_iter([\"\\'\", it.text().as_str()])\n+                    }\n+                }\n+                _ => gen_idx_name(),\n+            };\n+            allocated_lifetimes.push(name);\n+        });\n+    }\n+\n+    // fetch output lifetime if elision rule applies\n+    let output = match potential_lt_refs.as_slice() {\n+        [(_, _, lifetime, _), ..] if self_param.is_some() || potential_lt_refs.len() == 1 => {\n+            match lifetime {\n+                Some(lt) => match lt.text().as_str() {\n+                    \"'_\" => allocated_lifetimes.get(0).cloned(),\n+                    \"'static\" => None,\n+                    name => Some(name.into()),\n+                },\n+                None => allocated_lifetimes.get(0).cloned(),\n+            }\n+        }\n+        [..] => None,\n+    };\n+\n+    if allocated_lifetimes.is_empty() && output.is_none() {\n+        return None;\n+    }\n+\n+    // apply hints\n+    // apply output if required\n+    let mut is_trivial = true;\n+    if let (Some(output_lt), Some(r)) = (&output, ret_type) {\n+        if let Some(ty) = r.ty() {\n+            walk_ty(&ty, &mut |ty| match ty {\n+                ast::Type::RefType(ty) if ty.lifetime().is_none() => {\n+                    if let Some(amp) = ty.amp_token() {\n+                        is_trivial = false;\n+                        acc.push(mk_lt_hint(amp, output_lt.to_string()));\n+                    }\n+                }\n+                _ => (),\n+            })\n+        }\n+    }\n+\n+    if config.lifetime_elision_hints == LifetimeElisionHints::SkipTrivial && is_trivial {\n+        return None;\n+    }\n+\n+    let mut a = allocated_lifetimes.iter();\n+    for (_, amp_token, _, is_elided) in potential_lt_refs {\n+        if is_elided {\n+            let t = amp_token?;\n+            let lt = a.next()?;\n+            acc.push(mk_lt_hint(t, lt.to_string()));\n+        }\n+    }\n+\n+    // generate generic param list things\n+    match (generic_param_list, allocated_lifetimes.as_slice()) {\n+        (_, []) => (),\n+        (Some(gpl), allocated_lifetimes) => {\n+            let angle_tok = gpl.l_angle_token()?;\n+            let is_empty = gpl.generic_params().next().is_none();\n+            acc.push(InlayHint {\n+                range: angle_tok.text_range(),\n+                kind: InlayKind::LifetimeHint,\n+                label: format!(\n+                    \"{}{}\",\n+                    allocated_lifetimes.iter().format(\", \"),\n+                    if is_empty { \"\" } else { \", \" }\n+                )\n+                .into(),\n+                tooltip: Some(InlayTooltip::String(\"Elided lifetimes\".into())),\n+            });\n+        }\n+        (None, allocated_lifetimes) => acc.push(InlayHint {\n+            range: func.name()?.syntax().text_range(),\n+            kind: InlayKind::GenericParamListHint,\n+            label: format!(\"<{}>\", allocated_lifetimes.iter().format(\", \"),).into(),\n+            tooltip: Some(InlayTooltip::String(\"Elided lifetimes\".into())),\n+        }),\n+    }\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check, check_with_config, TEST_CONFIG},\n+        InlayHintsConfig, LifetimeElisionHints,\n+    };\n+\n+    #[test]\n+    fn hints_lifetimes() {\n+        check(\n+            r#\"\n+fn empty() {}\n+\n+fn no_gpl(a: &()) {}\n+ //^^^^^^<'0>\n+          // ^'0\n+fn empty_gpl<>(a: &()) {}\n+      //    ^'0   ^'0\n+fn partial<'b>(a: &(), b: &'b ()) {}\n+//        ^'0, $  ^'0\n+fn partial<'a>(a: &'a (), b: &()) {}\n+//        ^'0, $             ^'0\n+\n+fn single_ret(a: &()) -> &() {}\n+// ^^^^^^^^^^<'0>\n+              // ^'0     ^'0\n+fn full_mul(a: &(), b: &()) {}\n+// ^^^^^^^^<'0, '1>\n+            // ^'0     ^'1\n+\n+fn foo<'c>(a: &'c ()) -> &() {}\n+                      // ^'c\n+\n+fn nested_in(a: &   &X< &()>) {}\n+// ^^^^^^^^^<'0, '1, '2>\n+              //^'0 ^'1 ^'2\n+fn nested_out(a: &()) -> &   &X< &()>{}\n+// ^^^^^^^^^^<'0>\n+               //^'0     ^'0 ^'0 ^'0\n+\n+impl () {\n+    fn foo(&self) {}\n+    // ^^^<'0>\n+        // ^'0\n+    fn foo(&self) -> &() {}\n+    // ^^^<'0>\n+        // ^'0       ^'0\n+    fn foo(&self, a: &()) -> &() {}\n+    // ^^^<'0, '1>\n+        // ^'0       ^'1     ^'0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_lifetimes_named() {\n+        check_with_config(\n+            InlayHintsConfig { param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG },\n+            r#\"\n+fn nested_in<'named>(named: &        &X<      &()>) {}\n+//          ^'named1, 'named2, 'named3, $\n+                          //^'named1 ^'named2 ^'named3\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_lifetimes_trivial_skip() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                lifetime_elision_hints: LifetimeElisionHints::SkipTrivial,\n+                ..TEST_CONFIG\n+            },\n+            r#\"\n+fn no_gpl(a: &()) {}\n+fn empty_gpl<>(a: &()) {}\n+fn partial<'b>(a: &(), b: &'b ()) {}\n+fn partial<'a>(a: &'a (), b: &()) {}\n+\n+fn single_ret(a: &()) -> &() {}\n+// ^^^^^^^^^^<'0>\n+              // ^'0     ^'0\n+fn full_mul(a: &(), b: &()) {}\n+\n+fn foo<'c>(a: &'c ()) -> &() {}\n+                      // ^'c\n+\n+fn nested_in(a: &   &X< &()>) {}\n+fn nested_out(a: &()) -> &   &X< &()>{}\n+// ^^^^^^^^^^<'0>\n+               //^'0     ^'0 ^'0 ^'0\n+\n+impl () {\n+    fn foo(&self) {}\n+    fn foo(&self) -> &() {}\n+    // ^^^<'0>\n+        // ^'0       ^'0\n+    fn foo(&self, a: &()) -> &() {}\n+    // ^^^<'0, '1>\n+        // ^'0       ^'1     ^'0\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "588a0e3b6a4b6c0f0756377ca358556ceae3a2c0", "filename": "crates/ide/src/inlay_hints/implicit_static.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,75 @@\n+//! Implementation of \"implicit static\" inlay hints:\n+//! ```no_run\n+//! static S: &/* 'static */str = \"\";\n+//! ```\n+use either::Either;\n+use syntax::{\n+    ast::{self, AstNode},\n+    SyntaxKind,\n+};\n+\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip, LifetimeElisionHints};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    config: &InlayHintsConfig,\n+    statik_or_const: Either<ast::Static, ast::Const>,\n+) -> Option<()> {\n+    if config.lifetime_elision_hints != LifetimeElisionHints::Always {\n+        return None;\n+    }\n+\n+    if let Either::Right(it) = &statik_or_const {\n+        if ast::AssocItemList::can_cast(\n+            it.syntax().parent().map_or(SyntaxKind::EOF, |it| it.kind()),\n+        ) {\n+            return None;\n+        }\n+    }\n+\n+    if let Some(ast::Type::RefType(ty)) = statik_or_const.either(|it| it.ty(), |it| it.ty()) {\n+        if ty.lifetime().is_none() {\n+            let t = ty.amp_token()?;\n+            acc.push(InlayHint {\n+                range: t.text_range(),\n+                kind: InlayKind::LifetimeHint,\n+                label: \"'static\".to_owned().into(),\n+                tooltip: Some(InlayTooltip::String(\"Elided static lifetime\".into())),\n+            });\n+        }\n+    }\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, TEST_CONFIG},\n+        InlayHintsConfig, LifetimeElisionHints,\n+    };\n+\n+    #[test]\n+    fn hints_lifetimes_static() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                lifetime_elision_hints: LifetimeElisionHints::Always,\n+                ..TEST_CONFIG\n+            },\n+            r#\"\n+trait Trait {}\n+static S: &str = \"\";\n+//        ^'static\n+const C: &str = \"\";\n+//       ^'static\n+const C: &dyn Trait = panic!();\n+//       ^'static\n+\n+impl () {\n+    const C: &str = \"\";\n+    const C: &dyn Trait = panic!();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "ecee67632e35e929b1b7d9cdfb838879b97d72c0", "filename": "crates/ide/src/inlay_hints/param_name.rs", "status": "added", "additions": 546, "deletions": 0, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb9df4c527a5226754add94a65b52a9940cd80/crates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs?ref=9dfb9df4c527a5226754add94a65b52a9940cd80", "patch": "@@ -0,0 +1,546 @@\n+//! Implementation of \"param name\" inlay hints:\n+//! ```no_run\n+//! fn max(x: i32, y: i32) -> i32 { x + y }\n+//! _ = max(/*x*/4, /*y*/4);\n+//! ```\n+use either::Either;\n+use hir::{Callable, Semantics};\n+use ide_db::{base_db::FileRange, RootDatabase};\n+\n+use stdx::to_lower_snake_case;\n+use syntax::ast::{self, AstNode, HasArgList, HasName, UnaryOp};\n+\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    expr: ast::Expr,\n+) -> Option<()> {\n+    if !config.parameter_hints {\n+        return None;\n+    }\n+\n+    let (callable, arg_list) = get_callable(sema, &expr)?;\n+    let hints = callable\n+        .params(sema.db)\n+        .into_iter()\n+        .zip(arg_list.args())\n+        .filter_map(|((param, _ty), arg)| {\n+            // Only annotate hints for expressions that exist in the original file\n+            let range = sema.original_range_opt(arg.syntax())?;\n+            let (param_name, name_syntax) = match param.as_ref()? {\n+                Either::Left(pat) => (\"self\".to_string(), pat.name()),\n+                Either::Right(pat) => match pat {\n+                    ast::Pat::IdentPat(it) => (it.name()?.to_string(), it.name()),\n+                    _ => return None,\n+                },\n+            };\n+            Some((name_syntax, param_name, arg, range))\n+        })\n+        .filter(|(_, param_name, arg, _)| {\n+            !should_hide_param_name_hint(sema, &callable, param_name, arg)\n+        })\n+        .map(|(param, param_name, _, FileRange { range, .. })| {\n+            let mut tooltip = None;\n+            if let Some(name) = param {\n+                if let hir::CallableKind::Function(f) = callable.kind() {\n+                    // assert the file is cached so we can map out of macros\n+                    if let Some(_) = sema.source(f) {\n+                        tooltip = sema.original_range_opt(name.syntax());\n+                    }\n+                }\n+            }\n+\n+            InlayHint {\n+                range,\n+                kind: InlayKind::ParameterHint,\n+                label: param_name.into(),\n+                tooltip: tooltip.map(|it| InlayTooltip::HoverOffset(it.file_id, it.range.start())),\n+            }\n+        });\n+\n+    acc.extend(hints);\n+    Some(())\n+}\n+\n+fn get_callable(\n+    sema: &Semantics<'_, RootDatabase>,\n+    expr: &ast::Expr,\n+) -> Option<(hir::Callable, ast::ArgList)> {\n+    match expr {\n+        ast::Expr::CallExpr(expr) => {\n+            let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+            let expr = descended.as_ref().unwrap_or(expr);\n+            sema.type_of_expr(&expr.expr()?)?.original.as_callable(sema.db).zip(expr.arg_list())\n+        }\n+        ast::Expr::MethodCallExpr(expr) => {\n+            let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+            let expr = descended.as_ref().unwrap_or(expr);\n+            sema.resolve_method_call_as_callable(expr).zip(expr.arg_list())\n+        }\n+        _ => None,\n+    }\n+}\n+\n+fn should_hide_param_name_hint(\n+    sema: &Semantics<'_, RootDatabase>,\n+    callable: &hir::Callable,\n+    param_name: &str,\n+    argument: &ast::Expr,\n+) -> bool {\n+    // These are to be tested in the `parameter_hint_heuristics` test\n+    // hide when:\n+    // - the parameter name is a suffix of the function's name\n+    // - the argument is a qualified constructing or call expression where the qualifier is an ADT\n+    // - exact argument<->parameter match(ignoring leading underscore) or parameter is a prefix/suffix\n+    //   of argument with _ splitting it off\n+    // - param starts with `ra_fixture`\n+    // - param is a well known name in a unary function\n+\n+    let param_name = param_name.trim_start_matches('_');\n+    if param_name.is_empty() {\n+        return true;\n+    }\n+\n+    if matches!(argument, ast::Expr::PrefixExpr(prefix) if prefix.op_kind() == Some(UnaryOp::Not)) {\n+        return false;\n+    }\n+\n+    let fn_name = match callable.kind() {\n+        hir::CallableKind::Function(it) => Some(it.name(sema.db).to_smol_str()),\n+        _ => None,\n+    };\n+    let fn_name = fn_name.as_deref();\n+    is_param_name_suffix_of_fn_name(param_name, callable, fn_name)\n+        || is_argument_similar_to_param_name(argument, param_name)\n+        || param_name.starts_with(\"ra_fixture\")\n+        || (callable.n_params() == 1 && is_obvious_param(param_name))\n+        || is_adt_constructor_similar_to_param_name(sema, argument, param_name)\n+}\n+\n+/// Hide the parameter name of a unary function if it is a `_` - prefixed suffix of the function's name, or equal.\n+///\n+/// `fn strip_suffix(suffix)` will be hidden.\n+/// `fn stripsuffix(suffix)` will not be hidden.\n+fn is_param_name_suffix_of_fn_name(\n+    param_name: &str,\n+    callable: &Callable,\n+    fn_name: Option<&str>,\n+) -> bool {\n+    match (callable.n_params(), fn_name) {\n+        (1, Some(function)) => {\n+            function == param_name\n+                || function\n+                    .len()\n+                    .checked_sub(param_name.len())\n+                    .and_then(|at| function.is_char_boundary(at).then(|| function.split_at(at)))\n+                    .map_or(false, |(prefix, suffix)| {\n+                        suffix.eq_ignore_ascii_case(param_name) && prefix.ends_with('_')\n+                    })\n+        }\n+        _ => false,\n+    }\n+}\n+\n+fn is_argument_similar_to_param_name(argument: &ast::Expr, param_name: &str) -> bool {\n+    // check whether param_name and argument are the same or\n+    // whether param_name is a prefix/suffix of argument(split at `_`)\n+    let argument = match get_string_representation(argument) {\n+        Some(argument) => argument,\n+        None => return false,\n+    };\n+\n+    // std is honestly too panic happy...\n+    let str_split_at = |str: &str, at| str.is_char_boundary(at).then(|| argument.split_at(at));\n+\n+    let param_name = param_name.trim_start_matches('_');\n+    let argument = argument.trim_start_matches('_');\n+\n+    match str_split_at(argument, param_name.len()) {\n+        Some((prefix, rest)) if prefix.eq_ignore_ascii_case(param_name) => {\n+            return rest.is_empty() || rest.starts_with('_');\n+        }\n+        _ => (),\n+    }\n+    match argument.len().checked_sub(param_name.len()).and_then(|at| str_split_at(argument, at)) {\n+        Some((rest, suffix)) if param_name.eq_ignore_ascii_case(suffix) => {\n+            return rest.is_empty() || rest.ends_with('_');\n+        }\n+        _ => (),\n+    }\n+    false\n+}\n+\n+fn get_string_representation(expr: &ast::Expr) -> Option<String> {\n+    match expr {\n+        ast::Expr::MethodCallExpr(method_call_expr) => {\n+            let name_ref = method_call_expr.name_ref()?;\n+            match name_ref.text().as_str() {\n+                \"clone\" | \"as_ref\" => method_call_expr.receiver().map(|rec| rec.to_string()),\n+                name_ref => Some(name_ref.to_owned()),\n+            }\n+        }\n+        ast::Expr::MacroExpr(macro_expr) => {\n+            Some(macro_expr.macro_call()?.path()?.segment()?.to_string())\n+        }\n+        ast::Expr::FieldExpr(field_expr) => Some(field_expr.name_ref()?.to_string()),\n+        ast::Expr::PathExpr(path_expr) => Some(path_expr.path()?.segment()?.to_string()),\n+        ast::Expr::PrefixExpr(prefix_expr) => get_string_representation(&prefix_expr.expr()?),\n+        ast::Expr::RefExpr(ref_expr) => get_string_representation(&ref_expr.expr()?),\n+        ast::Expr::CastExpr(cast_expr) => get_string_representation(&cast_expr.expr()?),\n+        _ => None,\n+    }\n+}\n+\n+fn is_obvious_param(param_name: &str) -> bool {\n+    // avoid displaying hints for common functions like map, filter, etc.\n+    // or other obvious words used in std\n+    let is_obvious_param_name =\n+        matches!(param_name, \"predicate\" | \"value\" | \"pat\" | \"rhs\" | \"other\");\n+    param_name.len() == 1 || is_obvious_param_name\n+}\n+\n+fn is_adt_constructor_similar_to_param_name(\n+    sema: &Semantics<'_, RootDatabase>,\n+    argument: &ast::Expr,\n+    param_name: &str,\n+) -> bool {\n+    let path = match argument {\n+        ast::Expr::CallExpr(c) => c.expr().and_then(|e| match e {\n+            ast::Expr::PathExpr(p) => p.path(),\n+            _ => None,\n+        }),\n+        ast::Expr::PathExpr(p) => p.path(),\n+        ast::Expr::RecordExpr(r) => r.path(),\n+        _ => return false,\n+    };\n+    let path = match path {\n+        Some(it) => it,\n+        None => return false,\n+    };\n+    (|| match sema.resolve_path(&path)? {\n+        hir::PathResolution::Def(hir::ModuleDef::Adt(_)) => {\n+            Some(to_lower_snake_case(&path.segment()?.name_ref()?.text()) == param_name)\n+        }\n+        hir::PathResolution::Def(hir::ModuleDef::Function(_) | hir::ModuleDef::Variant(_)) => {\n+            if to_lower_snake_case(&path.segment()?.name_ref()?.text()) == param_name {\n+                return Some(true);\n+            }\n+            let qual = path.qualifier()?;\n+            match sema.resolve_path(&qual)? {\n+                hir::PathResolution::Def(hir::ModuleDef::Adt(_)) => {\n+                    Some(to_lower_snake_case(&qual.segment()?.name_ref()?.text()) == param_name)\n+                }\n+                _ => None,\n+            }\n+        }\n+        _ => None,\n+    })()\n+    .unwrap_or(false)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},\n+        InlayHintsConfig,\n+    };\n+\n+    #[track_caller]\n+    fn check_params(ra_fixture: &str) {\n+        check_with_config(\n+            InlayHintsConfig { parameter_hints: true, ..DISABLED_CONFIG },\n+            ra_fixture,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_hints_only() {\n+        check_params(\n+            r#\"\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn main() {\n+    let _x = foo(\n+        4,\n+      //^ a\n+        4,\n+      //^ b\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_hints_on_closure() {\n+        check_params(\n+            r#\"\n+fn main() {\n+    let clo = |a: u8, b: u8| a + b;\n+    clo(\n+        1,\n+      //^ a\n+        2,\n+      //^ b\n+    );\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_name_similar_to_fn_name_still_hints() {\n+        check_params(\n+            r#\"\n+fn max(x: i32, y: i32) -> i32 { x + y }\n+fn main() {\n+    let _x = max(\n+        4,\n+      //^ x\n+        4,\n+      //^ y\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_name_similar_to_fn_name() {\n+        check_params(\n+            r#\"\n+fn param_with_underscore(with_underscore: i32) -> i32 { with_underscore }\n+fn main() {\n+    let _x = param_with_underscore(\n+        4,\n+    );\n+}\"#,\n+        );\n+        check_params(\n+            r#\"\n+fn param_with_underscore(underscore: i32) -> i32 { underscore }\n+fn main() {\n+    let _x = param_with_underscore(\n+        4,\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_name_same_as_fn_name() {\n+        check_params(\n+            r#\"\n+fn foo(foo: i32) -> i32 { foo }\n+fn main() {\n+    let _x = foo(\n+        4,\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn never_hide_param_when_multiple_params() {\n+        check_params(\n+            r#\"\n+fn foo(foo: i32, bar: i32) -> i32 { bar + baz }\n+fn main() {\n+    let _x = foo(\n+        4,\n+      //^ foo\n+        8,\n+      //^ bar\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_hints_look_through_as_ref_and_clone() {\n+        check_params(\n+            r#\"\n+fn foo(bar: i32, baz: f32) {}\n+\n+fn main() {\n+    let bar = 3;\n+    let baz = &\"baz\";\n+    let fez = 1.0;\n+    foo(bar.clone(), bar.clone());\n+                   //^^^^^^^^^^^ baz\n+    foo(bar.as_ref(), bar.as_ref());\n+                    //^^^^^^^^^^^^ baz\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn self_param_hints() {\n+        check_params(\n+            r#\"\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(self: Self) {}\n+    fn bar(self: &Self) {}\n+}\n+\n+fn main() {\n+    Foo::foo(Foo);\n+           //^^^ self\n+    Foo::bar(&Foo);\n+           //^^^^ self\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn param_name_hints_show_for_literals() {\n+        check_params(\n+            r#\"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }\n+fn main() {\n+    test(\n+        0xa_b,\n+      //^^^^^ a\n+        0xa_b,\n+      //^^^^^ b\n+    );\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn function_call_parameter_hint() {\n+        check_params(\n+            r#\"\n+//- minicore: option\n+struct FileId {}\n+struct SmolStr {}\n+\n+struct TextRange {}\n+struct SyntaxKind {}\n+struct NavigationTarget {}\n+\n+struct Test {}\n+\n+impl Test {\n+    fn method(&self, mut param: i32) -> i32 { param * 2 }\n+\n+    fn from_syntax(\n+        file_id: FileId,\n+        name: SmolStr,\n+        focus_range: Option<TextRange>,\n+        full_range: TextRange,\n+        kind: SyntaxKind,\n+        docs: Option<String>,\n+    ) -> NavigationTarget {\n+        NavigationTarget {}\n+    }\n+}\n+\n+fn test_func(mut foo: i32, bar: i32, msg: &str, _: i32, last: i32) -> i32 {\n+    foo + bar\n+}\n+\n+fn main() {\n+    let not_literal = 1;\n+    let _: i32 = test_func(1,    2,      \"hello\", 3,  not_literal);\n+                         //^ foo ^ bar   ^^^^^^^ msg  ^^^^^^^^^^^ last\n+    let t: Test = Test {};\n+    t.method(123);\n+           //^^^ param\n+    Test::method(&t,      3456);\n+               //^^ self  ^^^^ param\n+    Test::from_syntax(\n+        FileId {},\n+        \"impl\".into(),\n+      //^^^^^^^^^^^^^ name\n+        None,\n+      //^^^^ focus_range\n+        TextRange {},\n+      //^^^^^^^^^^^^ full_range\n+        SyntaxKind {},\n+      //^^^^^^^^^^^^^ kind\n+        None,\n+      //^^^^ docs\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn parameter_hint_heuristics() {\n+        check_params(\n+            r#\"\n+fn check(ra_fixture_thing: &str) {}\n+\n+fn map(f: i32) {}\n+fn filter(predicate: i32) {}\n+\n+fn strip_suffix(suffix: &str) {}\n+fn stripsuffix(suffix: &str) {}\n+fn same(same: u32) {}\n+fn same2(_same2: u32) {}\n+\n+fn enum_matches_param_name(completion_kind: CompletionKind) {}\n+\n+fn foo(param: u32) {}\n+fn bar(param_eter: u32) {}\n+\n+enum CompletionKind {\n+    Keyword,\n+}\n+\n+fn non_ident_pat((a, b): (u32, u32)) {}\n+\n+fn main() {\n+    const PARAM: u32 = 0;\n+    foo(PARAM);\n+    foo(!PARAM);\n+     // ^^^^^^ param\n+    check(\"\");\n+\n+    map(0);\n+    filter(0);\n+\n+    strip_suffix(\"\");\n+    stripsuffix(\"\");\n+              //^^ suffix\n+    same(0);\n+    same2(0);\n+\n+    enum_matches_param_name(CompletionKind::Keyword);\n+\n+    let param = 0;\n+    foo(param);\n+    foo(param as _);\n+    let param_end = 0;\n+    foo(param_end);\n+    let start_param = 0;\n+    foo(start_param);\n+    let param2 = 0;\n+    foo(param2);\n+      //^^^^^^ param\n+\n+    macro_rules! param {\n+        () => {};\n+    };\n+    foo(param!());\n+\n+    let param_eter = 0;\n+    bar(param_eter);\n+    let param_eter_end = 0;\n+    bar(param_eter_end);\n+    let start_param_eter = 0;\n+    bar(start_param_eter);\n+    let param_eter2 = 0;\n+    bar(param_eter2);\n+      //^^^^^^^^^^^ param_eter\n+\n+    non_ident_pat((0, 0));\n+}\"#,\n+        );\n+    }\n+}"}]}