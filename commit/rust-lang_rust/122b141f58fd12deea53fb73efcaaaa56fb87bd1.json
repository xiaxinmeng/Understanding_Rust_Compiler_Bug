{"sha": "122b141f58fd12deea53fb73efcaaaa56fb87bd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMmIxNDFmNThmZDEyZGVlYTUzZmI3M2VmY2FhYWE1NmZiODdiZDE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-12-19T14:04:42Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-01-02T15:55:12Z"}, "message": "End of rework of Attributes struct", "tree": {"sha": "fd19c293a0c7c313ddeb385b9316567e633d7747", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd19c293a0c7c313ddeb385b9316567e633d7747"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/122b141f58fd12deea53fb73efcaaaa56fb87bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/122b141f58fd12deea53fb73efcaaaa56fb87bd1", "html_url": "https://github.com/rust-lang/rust/commit/122b141f58fd12deea53fb73efcaaaa56fb87bd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/122b141f58fd12deea53fb73efcaaaa56fb87bd1/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4739bc920a192b852ceb48fb500831594d5ff96", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4739bc920a192b852ceb48fb500831594d5ff96", "html_url": "https://github.com/rust-lang/rust/commit/c4739bc920a192b852ceb48fb500831594d5ff96"}], "stats": {"total": 281, "additions": 145, "deletions": 136}, "files": [{"sha": "48d720fa77fa03f0db7e772844b3d2231d20f243", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 97, "deletions": 19, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -122,7 +122,7 @@ impl Item {\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    crate fn doc_value(&self) -> Option<&str> {\n+    crate fn doc_value(&self) -> Option<String> {\n         self.attrs.doc_value()\n     }\n \n@@ -469,11 +469,13 @@ crate struct DocFragment {\n     /// This allows distinguishing between the original documentation and a pub re-export.\n     /// If it is `None`, the item was not re-exported.\n     crate parent_module: Option<DefId>,\n-    crate doc: String,\n+    crate doc: Symbol,\n     crate kind: DocFragmentKind,\n+    crate need_backline: bool,\n+    crate indent: usize,\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n crate enum DocFragmentKind {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n     SugaredDoc,\n@@ -484,16 +486,42 @@ crate enum DocFragmentKind {\n     Include { filename: Symbol },\n }\n \n+fn add_doc_fragment(out: &mut String, frag: &DocFragment) {\n+    let s = frag.doc.as_str();\n+    let mut iter = s.lines().peekable();\n+    while let Some(line) = iter.next() {\n+        if line.chars().any(|c| !c.is_whitespace()) {\n+            assert!(line.len() >= frag.indent);\n+            out.push_str(&line[frag.indent..]);\n+        } else {\n+            out.push_str(line);\n+        }\n+        if iter.peek().is_some() {\n+            out.push('\\n');\n+        }\n+    }\n+    if frag.need_backline {\n+        out.push('\\n');\n+    }\n+}\n+\n impl<'a> FromIterator<&'a DocFragment> for String {\n     fn from_iter<T>(iter: T) -> Self\n     where\n         T: IntoIterator<Item = &'a DocFragment>,\n     {\n+        let mut prev_kind: Option<DocFragmentKind> = None;\n         iter.into_iter().fold(String::new(), |mut acc, frag| {\n-            if !acc.is_empty() {\n+            if !acc.is_empty()\n+                && prev_kind\n+                    .take()\n+                    .map(|p| matches!(p, DocFragmentKind::Include { .. }) && p != frag.kind)\n+                    .unwrap_or(false)\n+            {\n                 acc.push('\\n');\n             }\n-            acc.push_str(&frag.doc);\n+            add_doc_fragment(&mut acc, &frag);\n+            prev_kind = Some(frag.kind);\n             acc\n         })\n     }\n@@ -565,7 +593,7 @@ impl Attributes {\n     /// Reads a `MetaItem` from within an attribute, looks for whether it is a\n     /// `#[doc(include=\"file\")]`, and returns the filename and contents of the file as loaded from\n     /// its expansion.\n-    crate fn extract_include(mi: &ast::MetaItem) -> Option<(Symbol, String)> {\n+    crate fn extract_include(mi: &ast::MetaItem) -> Option<(Symbol, Symbol)> {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n                 if meta.has_name(sym::include) {\n@@ -574,7 +602,7 @@ impl Attributes {\n                     // look for that instead\n                     return meta.meta_item_list().and_then(|list| {\n                         let mut filename: Option<Symbol> = None;\n-                        let mut contents: Option<String> = None;\n+                        let mut contents: Option<Symbol> = None;\n \n                         for it in list {\n                             if it.has_name(sym::file) {\n@@ -583,7 +611,7 @@ impl Attributes {\n                                 }\n                             } else if it.has_name(sym::contents) {\n                                 if let Some(docs) = it.value_str() {\n-                                    contents = Some(docs.to_string());\n+                                    contents = Some(docs);\n                                 }\n                             }\n                         }\n@@ -622,30 +650,51 @@ impl Attributes {\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n-        let mut doc_strings = vec![];\n+        let mut doc_strings: Vec<DocFragment> = vec![];\n         let mut sp = None;\n         let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n+        fn update_need_backline(doc_strings: &mut Vec<DocFragment>, frag: &DocFragment) {\n+            if let Some(prev) = doc_strings.last_mut() {\n+                if matches!(prev.kind, DocFragmentKind::Include { .. })\n+                    || prev.kind != frag.kind\n+                    || prev.parent_module != frag.parent_module\n+                {\n+                    // add a newline for extra padding between segments\n+                    prev.need_backline = prev.kind == DocFragmentKind::SugaredDoc\n+                        || prev.kind == DocFragmentKind::RawDoc\n+                } else {\n+                    prev.need_backline = true;\n+                }\n+            }\n+        }\n+\n         let clean_attr = |(attr, parent_module): (&ast::Attribute, _)| {\n             if let Some(value) = attr.doc_str() {\n                 trace!(\"got doc_str={:?}\", value);\n-                let value = beautify_doc_string(value).to_string();\n+                let value = beautify_doc_string(value);\n                 let kind = if attr.is_doc_comment() {\n                     DocFragmentKind::SugaredDoc\n                 } else {\n                     DocFragmentKind::RawDoc\n                 };\n \n                 let line = doc_line;\n-                doc_line += value.lines().count();\n-                doc_strings.push(DocFragment {\n+                doc_line += value.as_str().lines().count();\n+                let frag = DocFragment {\n                     line,\n                     span: attr.span,\n                     doc: value,\n                     kind,\n                     parent_module,\n-                });\n+                    need_backline: false,\n+                    indent: 0,\n+                };\n+\n+                update_need_backline(&mut doc_strings, &frag);\n+\n+                doc_strings.push(frag);\n \n                 if sp.is_none() {\n                     sp = Some(attr.span);\n@@ -663,14 +712,18 @@ impl Attributes {\n                         } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n                         {\n                             let line = doc_line;\n-                            doc_line += contents.lines().count();\n-                            doc_strings.push(DocFragment {\n+                            doc_line += contents.as_str().lines().count();\n+                            let frag = DocFragment {\n                                 line,\n                                 span: attr.span,\n                                 doc: contents,\n                                 kind: DocFragmentKind::Include { filename },\n                                 parent_module,\n-                            });\n+                                need_backline: false,\n+                                indent: 0,\n+                            };\n+                            update_need_backline(&mut doc_strings, &frag);\n+                            doc_strings.push(frag);\n                         }\n                     }\n                 }\n@@ -721,14 +774,39 @@ impl Attributes {\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    crate fn doc_value(&self) -> Option<&str> {\n-        self.doc_strings.first().map(|s| s.doc.as_str())\n+    crate fn doc_value(&self) -> Option<String> {\n+        let mut iter = self.doc_strings.iter();\n+\n+        let ori = iter.next()?;\n+        let mut out = String::new();\n+        add_doc_fragment(&mut out, &ori);\n+        while let Some(new_frag) = iter.next() {\n+            if matches!(ori.kind, DocFragmentKind::Include { .. })\n+                || new_frag.kind != ori.kind\n+                || new_frag.parent_module != ori.parent_module\n+            {\n+                break;\n+            }\n+            add_doc_fragment(&mut out, &new_frag);\n+        }\n+        if out.is_empty() { None } else { Some(out) }\n+    }\n+\n+    crate fn collapsed_doc_value_by_module_level(&self) -> FxHashMap<Option<DefId>, String> {\n+        let mut ret = FxHashMap::default();\n+\n+        for new_frag in self.doc_strings.iter() {\n+            let out = ret.entry(new_frag.parent_module).or_insert_with(|| String::new());\n+            add_doc_fragment(out, &new_frag);\n+        }\n+        ret\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n     crate fn collapsed_doc_value(&self) -> Option<String> {\n-        if !self.doc_strings.is_empty() { Some(self.doc_strings.iter().collect()) } else { None }\n+        let s: String = self.doc_strings.iter().collect();\n+        if s.is_empty() { None } else { Some(s) }\n     }\n \n     /// Gets links as a vector"}, {"sha": "053eaac01696241ffac93dfffd61b94730a2588b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -525,7 +525,7 @@ crate fn run_global_ctxt(\n     let mut krate = tcx.sess.time(\"clean_crate\", || clean::krate(&mut ctxt));\n \n     if let Some(ref m) = krate.module {\n-        if let None | Some(\"\") = m.doc_value() {\n+        if m.doc_value().map(|d| d.is_empty()).unwrap_or(true) {\n             let help = \"The following guide may be of use:\\n\\\n                 https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation.html\";\n             tcx.struct_lint_node("}, {"sha": "09627be9701c9f9c0f25f52af504acb1fe49a5cc", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -987,7 +987,6 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n             self.collector.names.push(name);\n         }\n \n-        attrs.collapse_doc_comments();\n         attrs.unindent_doc_comments();\n         // The collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n         // anything else, this will combine them for us."}, {"sha": "df892d15b7b9b637bc955bcb54d087e79598f5d8", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -314,9 +314,10 @@ impl DocFolder for Cache {\n                             ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\"),\n-                            desc: item\n-                                .doc_value()\n-                                .map_or_else(|| String::new(), short_markdown_summary),\n+                            desc: item.doc_value().map_or_else(\n+                                || String::new(),\n+                                |x| short_markdown_summary(&x.as_str()),\n+                            ),\n                             parent,\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item),"}, {"sha": "497cbbb4250a6f62ea68d84acb284a70f5241464", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -78,7 +78,7 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 ty: item.type_(),\n                 name: item.name.unwrap().to_string(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n-                desc: item.doc_value().map_or_else(|| String::new(), short_markdown_summary),\n+                desc: item.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)),\n                 parent: Some(did),\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item),\n@@ -127,7 +127,7 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let crate_doc = krate\n         .module\n         .as_ref()\n-        .map(|module| module.doc_value().map_or_else(|| String::new(), short_markdown_summary))\n+        .map(|module| module.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)))\n         .unwrap_or_default();\n \n     #[derive(Serialize)]"}, {"sha": "4339fa077e52f20a1fcf114af2a28ee706194deb", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -30,7 +30,6 @@ crate mod cache;\n #[cfg(test)]\n mod tests;\n \n-use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n@@ -198,11 +197,11 @@ impl SharedContext<'_> {\n \n     /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n     /// `collapsed_doc_value` of the given item.\n-    crate fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n+    crate fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<String> {\n         if self.collapsed {\n-            item.collapsed_doc_value().map(|s| s.into())\n+            item.collapsed_doc_value().map(|s| s.to_string())\n         } else {\n-            item.doc_value().map(|s| s.into())\n+            item.doc_value().map(|s| s.to_string())\n         }\n     }\n }\n@@ -1622,7 +1621,7 @@ impl Context<'_> {\n             let short = short.to_string();\n             map.entry(short).or_default().push((\n                 myname,\n-                Some(item.doc_value().map_or_else(|| String::new(), plain_text_summary)),\n+                Some(item.doc_value().map_or_else(String::new, |s| plain_text_summary(&s))),\n             ));\n         }\n \n@@ -1880,7 +1879,7 @@ fn document_short(\n         return;\n     }\n     if let Some(s) = item.doc_value() {\n-        let mut summary_html = MarkdownSummaryLine(s, &item.links()).into_string();\n+        let mut summary_html = MarkdownSummaryLine(&s, &item.links()).into_string();\n \n         if s.contains('\\n') {\n             let link = format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link));\n@@ -2197,7 +2196,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 let stab = myitem.stability_class(cx.tcx());\n                 let add = if stab.is_some() { \" \" } else { \"\" };\n \n-                let doc_value = myitem.doc_value().unwrap_or(\"\");\n+                let doc_value = myitem.doc_value().unwrap_or_else(String::new);\n                 write!(\n                     w,\n                     \"<tr class=\\\"{stab}{add}module-item\\\">\\\n@@ -2207,7 +2206,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                      </tr>\",\n                     name = *myitem.name.as_ref().unwrap(),\n                     stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n-                    docs = MarkdownSummaryLine(doc_value, &myitem.links()).into_string(),\n+                    docs = MarkdownSummaryLine(&doc_value, &myitem.links()).into_string(),\n                     class = myitem.type_(),\n                     add = add,\n                     stab = stab.unwrap_or_else(String::new),"}, {"sha": "c8c725456691076f93c8ac303087c18bf39bf2a0", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                     &i.attrs\n                         .doc_strings\n                         .iter()\n-                        .map(|d| d.doc.as_str())\n+                        .map(|d| d.doc.to_string())\n                         .collect::<Vec<_>>()\n                         .join(\"\\n\"),\n                     &mut tests,"}, {"sha": "4994765dfe52e06446bb270bf417bc01642d8c9e", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -1,72 +1,14 @@\n-use crate::clean::{self, DocFragment, DocFragmentKind, Item};\n+use crate::clean;\n use crate::core::DocContext;\n-use crate::fold;\n-use crate::fold::DocFolder;\n use crate::passes::Pass;\n \n-use std::mem::take;\n-\n crate const COLLAPSE_DOCS: Pass = Pass {\n     name: \"collapse-docs\",\n     run: collapse_docs,\n     description: \"concatenates all document attributes into one document attribute\",\n };\n \n-crate fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n-    let mut krate = Collapser.fold_crate(krate);\n+crate fn collapse_docs(mut krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     krate.collapsed = true;\n     krate\n }\n-\n-struct Collapser;\n-\n-impl fold::DocFolder for Collapser {\n-    fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-        i.attrs.collapse_doc_comments();\n-        Some(self.fold_item_recur(i))\n-    }\n-}\n-\n-fn collapse(doc_strings: &mut Vec<DocFragment>) {\n-    let mut docs = vec![];\n-    let mut last_frag: Option<DocFragment> = None;\n-\n-    for frag in take(doc_strings) {\n-        if let Some(mut curr_frag) = last_frag.take() {\n-            let curr_kind = &curr_frag.kind;\n-            let new_kind = &frag.kind;\n-\n-            if matches!(*curr_kind, DocFragmentKind::Include { .. })\n-                || curr_kind != new_kind\n-                || curr_frag.parent_module != frag.parent_module\n-            {\n-                if *curr_kind == DocFragmentKind::SugaredDoc\n-                    || *curr_kind == DocFragmentKind::RawDoc\n-                {\n-                    // add a newline for extra padding between segments\n-                    curr_frag.doc.push('\\n');\n-                }\n-                docs.push(curr_frag);\n-                last_frag = Some(frag);\n-            } else {\n-                curr_frag.doc.push('\\n');\n-                curr_frag.doc.push_str(&frag.doc);\n-                curr_frag.span = curr_frag.span.to(frag.span);\n-                last_frag = Some(curr_frag);\n-            }\n-        } else {\n-            last_frag = Some(frag);\n-        }\n-    }\n-\n-    if let Some(frag) = last_frag.take() {\n-        docs.push(frag);\n-    }\n-    *doc_strings = docs;\n-}\n-\n-impl clean::Attributes {\n-    crate fn collapse_doc_comments(&mut self) {\n-        collapse(&mut self.doc_strings);\n-    }\n-}"}, {"sha": "d539c14b12aed9795f39ea3d12f89fdae887f116", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -891,37 +891,20 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         // In the presence of re-exports, this is not the same as the module of the item.\n         // Rather than merging all documentation into one, resolve it one attribute at a time\n         // so we know which module it came from.\n-        let mut attrs = item.attrs.doc_strings.iter().peekable();\n-        while let Some(attr) = attrs.next() {\n-            // `collapse_docs` does not have the behavior we want:\n-            // we want `///` and `#[doc]` to count as the same attribute,\n-            // but currently it will treat them as separate.\n-            // As a workaround, combine all attributes with the same parent module into the same attribute.\n-            let mut combined_docs = attr.doc.clone();\n-            loop {\n-                match attrs.peek() {\n-                    Some(next) if next.parent_module == attr.parent_module => {\n-                        combined_docs.push('\\n');\n-                        combined_docs.push_str(&attrs.next().unwrap().doc);\n-                    }\n-                    _ => break,\n-                }\n-            }\n-            debug!(\"combined_docs={}\", combined_docs);\n+        for (parent_module, doc) in item.attrs.collapsed_doc_value_by_module_level() {\n+            debug!(\"combined_docs={}\", doc);\n \n-            let (krate, parent_node) = if let Some(id) = attr.parent_module {\n-                trace!(\"docs {:?} came from {:?}\", attr.doc, id);\n+            let (krate, parent_node) = if let Some(id) = parent_module {\n                 (id.krate, Some(id))\n             } else {\n-                trace!(\"no parent found for {:?}\", attr.doc);\n                 (item.def_id.krate, parent_node)\n             };\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n-            for (ori_link, link_range) in markdown_links(&combined_docs) {\n+            for (ori_link, link_range) in markdown_links(&doc) {\n                 let link = self.resolve_link(\n                     &item,\n-                    &combined_docs,\n+                    &doc,\n                     &self_name,\n                     parent_node,\n                     krate,"}, {"sha": "1cad480d4e84705dcb4172b3ba57ec03861a3d95", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -68,7 +68,7 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n     let min_indent = match docs\n         .iter()\n         .map(|fragment| {\n-            fragment.doc.lines().fold(usize::MAX, |min_indent, line| {\n+            fragment.doc.as_str().lines().fold(usize::MAX, |min_indent, line| {\n                 if line.chars().all(|c| c.is_whitespace()) {\n                     min_indent\n                 } else {\n@@ -87,7 +87,7 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n     };\n \n     for fragment in docs {\n-        if fragment.doc.lines().count() == 0 {\n+        if fragment.doc.as_str().lines().count() == 0 {\n             continue;\n         }\n \n@@ -97,18 +97,6 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n             min_indent\n         };\n \n-        fragment.doc = fragment\n-            .doc\n-            .lines()\n-            .map(|line| {\n-                if line.chars().all(|c| c.is_whitespace()) {\n-                    line.to_string()\n-                } else {\n-                    assert!(line.len() >= min_indent);\n-                    line[min_indent..].to_string()\n-                }\n-            })\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n+        fragment.indent = min_indent;\n     }\n }"}, {"sha": "ca8f6921fdc2a434f75e204213dc674b80592075", "filename": "src/librustdoc/passes/unindent_comments/tests.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122b141f58fd12deea53fb73efcaaaa56fb87bd1/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs?ref=122b141f58fd12deea53fb73efcaaaa56fb87bd1", "patch": "@@ -1,21 +1,40 @@\n use super::*;\n use rustc_span::source_map::DUMMY_SP;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::with_default_session_globals;\n \n fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n     vec![DocFragment {\n         line: 0,\n         span: DUMMY_SP,\n         parent_module: None,\n-        doc: s.to_string(),\n+        doc: Symbol::intern(s),\n         kind: DocFragmentKind::SugaredDoc,\n+        need_backline: false,\n+        indent: 0,\n     }]\n }\n \n #[track_caller]\n fn run_test(input: &str, expected: &str) {\n-    let mut s = create_doc_fragment(input);\n-    unindent_fragments(&mut s);\n-    assert_eq!(s[0].doc, expected);\n+    with_default_session_globals(|| {\n+        let mut s = create_doc_fragment(input);\n+        unindent_fragments(&mut s);\n+        assert_eq!(\n+            &s[0]\n+                .doc\n+                .as_str()\n+                .lines()\n+                .map(|l| if l.len() > s[0].indent {\n+                    l[s[0].indent..].to_string()\n+                } else {\n+                    String::new()\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\"),\n+            expected\n+        );\n+    });\n }\n \n #[test]"}]}