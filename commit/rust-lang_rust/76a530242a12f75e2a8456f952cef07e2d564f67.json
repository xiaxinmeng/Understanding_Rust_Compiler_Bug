{"sha": "76a530242a12f75e2a8456f952cef07e2d564f67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YTUzMDI0MmExMmY3NWUyYTg0NTZmOTUyY2VmMDdlMmQ1NjRmNjc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T05:56:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T05:56:47Z"}, "message": "Merge branch 'Veetaha-feat/sync-branch'", "tree": {"sha": "c172661c9be87bea10b796bffd32f4c32c65ab7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c172661c9be87bea10b796bffd32f4c32c65ab7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76a530242a12f75e2a8456f952cef07e2d564f67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76a530242a12f75e2a8456f952cef07e2d564f67", "html_url": "https://github.com/rust-lang/rust/commit/76a530242a12f75e2a8456f952cef07e2d564f67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76a530242a12f75e2a8456f952cef07e2d564f67/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "html_url": "https://github.com/rust-lang/rust/commit/78e94e4570f09c8cbe1f8c6802df9b112ca37f08"}, {"sha": "6e81c9a921b975be7f2efb927dab4f3cfd505ebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e81c9a921b975be7f2efb927dab4f3cfd505ebc", "html_url": "https://github.com/rust-lang/rust/commit/6e81c9a921b975be7f2efb927dab4f3cfd505ebc"}], "stats": {"total": 432, "additions": 299, "deletions": 133}, "files": [{"sha": "bed9acf8fc54c8b667182b7d618e072d3bce7569", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -967,6 +967,7 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"log\",\n+ \"ra_progress\",\n  \"ra_toolchain\",\n  \"serde_json\",\n ]\n@@ -1080,7 +1081,11 @@ dependencies = [\n  \"ra_hir\",\n  \"ra_ide_db\",\n  \"ra_prof\",\n+<<<<<<< HEAD\n  \"ra_ssr\",\n+=======\n+ \"ra_progress\",\n+>>>>>>> Veetaha-feat/sync-branch\n  \"ra_syntax\",\n  \"ra_text_edit\",\n  \"rand\",\n@@ -1168,6 +1173,13 @@ dependencies = [\n  \"ra_arena\",\n ]\n \n+[[package]]\n+name = \"ra_progress\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"crossbeam-channel\",\n+]\n+\n [[package]]\n name = \"ra_project_model\"\n version = \"0.1.0\"\n@@ -1392,6 +1404,7 @@ dependencies = [\n  \"ra_mbe\",\n  \"ra_proc_macro_srv\",\n  \"ra_prof\",\n+ \"ra_progress\",\n  \"ra_project_model\",\n  \"ra_syntax\",\n  \"ra_text_edit\","}, {"sha": "838973963b9694ba84ca623ba015d826ce7f6249", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -14,3 +14,4 @@ cargo_metadata = \"0.10.0\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n ra_toolchain = { path = \"../ra_toolchain\" }\n+ra_progress = { path = \"../ra_progress\" }"}, {"sha": "7b9f48eb025b0c801f085390397f34c933c5465f", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -3,6 +3,7 @@\n //! LSP diagnostics based on the output of the command.\n \n use std::{\n+    fmt,\n     io::{self, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n@@ -16,6 +17,9 @@ pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n };\n \n+type Progress = ra_progress::Progress<(), String>;\n+type ProgressSource = ra_progress::ProgressSource<(), String>;\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n     CargoCommand {\n@@ -31,6 +35,17 @@ pub enum FlycheckConfig {\n     },\n }\n \n+impl fmt::Display for FlycheckConfig {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            FlycheckConfig::CargoCommand { command, .. } => write!(f, \"cargo {}\", command),\n+            FlycheckConfig::CustomCommand { command, args } => {\n+                write!(f, \"{} {}\", command, args.join(\" \"))\n+            }\n+        }\n+    }\n+}\n+\n /// Flycheck wraps the shared state and communication machinery used for\n /// running `cargo check` (or other compatible command) and providing\n /// diagnostics based on the output.\n@@ -44,11 +59,15 @@ pub struct Flycheck {\n }\n \n impl Flycheck {\n-    pub fn new(config: FlycheckConfig, workspace_root: PathBuf) -> Flycheck {\n+    pub fn new(\n+        config: FlycheckConfig,\n+        workspace_root: PathBuf,\n+        progress_src: ProgressSource,\n+    ) -> Flycheck {\n         let (task_send, task_recv) = unbounded::<CheckTask>();\n         let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n         let handle = jod_thread::spawn(move || {\n-            FlycheckThread::new(config, workspace_root).run(&task_send, &cmd_recv);\n+            FlycheckThread::new(config, workspace_root, progress_src).run(&task_send, &cmd_recv);\n         });\n         Flycheck { task_recv, cmd_send, handle }\n     }\n@@ -66,16 +85,6 @@ pub enum CheckTask {\n \n     /// Request adding a diagnostic with fixes included to a file\n     AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n-\n-    /// Request check progress notification to client\n-    Status(Status),\n-}\n-\n-#[derive(Debug)]\n-pub enum Status {\n-    Being,\n-    Progress(String),\n-    End,\n }\n \n pub enum CheckCommand {\n@@ -87,6 +96,8 @@ struct FlycheckThread {\n     config: FlycheckConfig,\n     workspace_root: PathBuf,\n     last_update_req: Option<Instant>,\n+    progress_src: ProgressSource,\n+    progress: Option<Progress>,\n     // XXX: drop order is significant\n     message_recv: Receiver<CheckEvent>,\n     /// WatchThread exists to wrap around the communication needed to be able to\n@@ -98,11 +109,17 @@ struct FlycheckThread {\n }\n \n impl FlycheckThread {\n-    fn new(config: FlycheckConfig, workspace_root: PathBuf) -> FlycheckThread {\n+    fn new(\n+        config: FlycheckConfig,\n+        workspace_root: PathBuf,\n+        progress_src: ProgressSource,\n+    ) -> FlycheckThread {\n         FlycheckThread {\n             config,\n             workspace_root,\n+            progress_src,\n             last_update_req: None,\n+            progress: None,\n             message_recv: never(),\n             check_process: None,\n         }\n@@ -140,9 +157,9 @@ impl FlycheckThread {\n         }\n     }\n \n-    fn clean_previous_results(&self, task_send: &Sender<CheckTask>) {\n+    fn clean_previous_results(&mut self, task_send: &Sender<CheckTask>) {\n         task_send.send(CheckTask::ClearDiagnostics).unwrap();\n-        task_send.send(CheckTask::Status(Status::End)).unwrap();\n+        self.progress = None;\n     }\n \n     fn should_recheck(&mut self) -> bool {\n@@ -161,18 +178,17 @@ impl FlycheckThread {\n         }\n     }\n \n-    fn handle_message(&self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n+    fn handle_message(&mut self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n         match msg {\n             CheckEvent::Begin => {\n-                task_send.send(CheckTask::Status(Status::Being)).unwrap();\n+                self.progress = Some(self.progress_src.begin(()));\n             }\n-\n-            CheckEvent::End => {\n-                task_send.send(CheckTask::Status(Status::End)).unwrap();\n-            }\n-\n+            CheckEvent::End => self.progress = None,\n             CheckEvent::Msg(Message::CompilerArtifact(msg)) => {\n-                task_send.send(CheckTask::Status(Status::Progress(msg.target.name))).unwrap();\n+                self.progress\n+                    .as_mut()\n+                    .expect(\"check process reported progress without the 'Begin' notification\")\n+                    .report(msg.target.name);\n             }\n \n             CheckEvent::Msg(Message::CompilerMessage(msg)) => {"}, {"sha": "c7f7c6dd3421e452f74fdddfb873d945f6cc2da0", "filename": "crates/ra_progress/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_progress%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_progress%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_progress%2FCargo.toml?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"ra_progress\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+crossbeam-channel = { version = \"0.4\" }"}, {"sha": "0ff1f846ca1b9726362b029e62f45288b5b7d102", "filename": "crates/ra_progress/src/lib.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_progress%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_progress%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_progress%2Fsrc%2Flib.rs?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -0,0 +1,129 @@\n+//! General-purpose instrumentation for progress reporting.\n+//!\n+//! Note:\n+//! Most of the methods accept `&mut self` just to be more restrictive (for forward compat)\n+//! even tho for some of them we can weaken this requirement to shared reference (`&self`).\n+\n+use crossbeam_channel::Receiver;\n+use std::fmt;\n+\n+#[derive(Debug)]\n+pub enum ProgressStatus<B, P> {\n+    Begin(B),\n+    Progress(P),\n+    End,\n+}\n+\n+pub struct Progress<B, P>(Option<crossbeam_channel::Sender<ProgressStatus<B, P>>>);\n+impl<B, P> Progress<B, P> {\n+    pub fn report(&mut self, payload: P) {\n+        self.report_with(|| payload);\n+    }\n+\n+    pub fn report_with(&mut self, payload: impl FnOnce() -> P) {\n+        self.send_status(|| ProgressStatus::Progress(payload()));\n+    }\n+\n+    fn send_status(&self, status: impl FnOnce() -> ProgressStatus<B, P>) {\n+        if let Some(sender) = &self.0 {\n+            sender.try_send(status()).expect(\"progress report must not block\");\n+        }\n+    }\n+}\n+\n+impl<B, P> Drop for Progress<B, P> {\n+    fn drop(&mut self) {\n+        self.send_status(|| ProgressStatus::End);\n+    }\n+}\n+\n+pub struct ProgressSource<B, P>(Option<crossbeam_channel::Sender<ProgressStatus<B, P>>>);\n+impl<B, P> ProgressSource<B, P> {\n+    pub fn real_if(real: bool) -> (Receiver<ProgressStatus<B, P>>, Self) {\n+        if real {\n+            let (sender, receiver) = crossbeam_channel::unbounded();\n+            (receiver, Self(Some(sender)))\n+        } else {\n+            (crossbeam_channel::never(), Self(None))\n+        }\n+    }\n+\n+    pub fn begin(&mut self, payload: B) -> Progress<B, P> {\n+        self.begin_with(|| payload)\n+    }\n+\n+    pub fn begin_with(&mut self, payload: impl FnOnce() -> B) -> Progress<B, P> {\n+        let progress = Progress(self.0.clone());\n+        progress.send_status(|| ProgressStatus::Begin(payload()));\n+        progress\n+    }\n+}\n+\n+impl<B, P> Clone for ProgressSource<B, P> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+\n+impl<B, P> fmt::Debug for ProgressSource<B, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"ProgressSource\").field(&self.0).finish()\n+    }\n+}\n+\n+pub type U32ProgressStatus = ProgressStatus<U32ProgressReport, U32ProgressReport>;\n+\n+#[derive(Debug)]\n+pub struct U32ProgressReport {\n+    pub processed: u32,\n+    pub total: u32,\n+}\n+impl U32ProgressReport {\n+    pub fn percentage(&self) -> f64 {\n+        f64::from(100 * self.processed) / f64::from(self.total)\n+    }\n+    pub fn to_message(&self, prefix: &str, unit: &str) -> String {\n+        format!(\"{} ({}/{} {})\", prefix, self.processed, self.total, unit)\n+    }\n+}\n+\n+pub struct U32Progress {\n+    inner: Progress<U32ProgressReport, U32ProgressReport>,\n+    processed: u32,\n+    total: u32,\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct IsDone(pub bool);\n+\n+impl U32Progress {\n+    pub fn report(&mut self, new_processed: u32) -> IsDone {\n+        if self.processed < new_processed {\n+            self.processed = new_processed;\n+            self.inner.report(U32ProgressReport { processed: new_processed, total: self.total });\n+        }\n+        IsDone(self.processed >= self.total)\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct U32ProgressSource {\n+    inner: ProgressSource<U32ProgressReport, U32ProgressReport>,\n+}\n+\n+impl U32ProgressSource {\n+    pub fn real_if(\n+        real: bool,\n+    ) -> (Receiver<ProgressStatus<U32ProgressReport, U32ProgressReport>>, Self) {\n+        let (recv, inner) = ProgressSource::real_if(real);\n+        (recv, Self { inner })\n+    }\n+\n+    pub fn begin(&mut self, initial: u32, total: u32) -> U32Progress {\n+        U32Progress {\n+            inner: self.inner.begin(U32ProgressReport { processed: initial, total }),\n+            processed: initial,\n+            total,\n+        }\n+    }\n+}"}, {"sha": "2bbed395f71f95c05868d63f92635abcdd67c469", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -48,6 +48,7 @@ hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }\n ra_proc_macro_srv = { path = \"../ra_proc_macro_srv\" }\n+ra_progress = { path = \"../ra_progress\" }\n \n [target.'cfg(windows)'.dependencies]\n winapi = \"0.3.8\""}, {"sha": "7759c0ae309f9e0a38eb16ec3f0da1c4c2b3cb41", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -27,9 +27,13 @@ use crate::{\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) -> Option<Flycheck> {\n+fn create_flycheck(\n+    workspaces: &[ProjectWorkspace],\n+    config: &FlycheckConfig,\n+    progress_src: &ProgressSource<(), String>,\n+) -> Option<Flycheck> {\n     // FIXME: Figure out the multi-workspace situation\n-    workspaces.iter().find_map(|w| match w {\n+    workspaces.iter().find_map(move |w| match w {\n         ProjectWorkspace::Cargo { cargo, .. } => {\n             let cargo_project_root = cargo.workspace_root().to_path_buf();\n             Some(Flycheck::new(config.clone(), cargo_project_root.into()))\n@@ -143,7 +147,12 @@ impl GlobalState {\n         }\n         change.set_crate_graph(crate_graph);\n \n-        let flycheck = config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n+        let (flycheck_progress_receiver, flycheck_progress_src) =\n+            ProgressSource::real_if(config.client_caps.work_done_progress);\n+        let flycheck = config\n+            .check\n+            .as_ref()\n+            .and_then(|c| create_flycheck(&workspaces, c, &flycheck_progress_src));\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n@@ -153,6 +162,8 @@ impl GlobalState {\n             loader,\n             task_receiver,\n             flycheck,\n+            flycheck_progress_src,\n+            flycheck_progress_receiver,\n             diagnostics: Default::default(),\n             mem_docs: FxHashSet::default(),\n             vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n@@ -170,8 +181,10 @@ impl GlobalState {\n     pub(crate) fn update_configuration(&mut self, config: Config) {\n         self.analysis_host.update_lru_capacity(config.lru_capacity);\n         if config.check != self.config.check {\n-            self.flycheck =\n-                config.check.as_ref().and_then(|it| create_flycheck(&self.workspaces, it));\n+            self.flycheck = config\n+                .check\n+                .as_ref()\n+                .and_then(|it| create_flycheck(&self.workspaces, it, &self.flycheck_progress_src));\n         }\n \n         self.config = config;"}, {"sha": "c790227972bb346fd8a79d4d6d20f9a378122c97", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -0,0 +1,52 @@\n+//! Utilities for LSP-related boilerplate code.\n+\n+use crossbeam_channel::Sender;\n+use lsp_server::{Message, Notification, Request, RequestId};\n+use ra_db::Canceled;\n+use serde::{de::DeserializeOwned, Serialize};\n+use std::error::Error;\n+\n+pub fn show_message(\n+    typ: lsp_types::MessageType,\n+    message: impl Into<String>,\n+    sender: &Sender<Message>,\n+) {\n+    let message = message.into();\n+    let params = lsp_types::ShowMessageParams { typ, message };\n+    let not = notification_new::<lsp_types::notification::ShowMessage>(params);\n+    sender.send(not.into()).unwrap();\n+}\n+\n+pub(crate) fn is_canceled(e: &(dyn Error + 'static)) -> bool {\n+    e.downcast_ref::<Canceled>().is_some()\n+}\n+\n+pub(crate) fn notification_is<N: lsp_types::notification::Notification>(\n+    notification: &Notification,\n+) -> bool {\n+    notification.method == N::METHOD\n+}\n+\n+pub(crate) fn notification_cast<N>(notification: Notification) -> Result<N::Params, Notification>\n+where\n+    N: lsp_types::notification::Notification,\n+    N::Params: DeserializeOwned,\n+{\n+    notification.extract(N::METHOD)\n+}\n+\n+pub(crate) fn notification_new<N>(params: N::Params) -> Notification\n+where\n+    N: lsp_types::notification::Notification,\n+    N::Params: Serialize,\n+{\n+    Notification::new(N::METHOD.to_string(), params)\n+}\n+\n+pub(crate) fn request_new<R>(id: RequestId, params: R::Params) -> Request\n+where\n+    R: lsp_types::request::Request,\n+    R::Params: Serialize,\n+{\n+    Request::new(id, R::METHOD.to_string(), params)\n+}"}, {"sha": "7ccdbd29cf568a8875d2d12ce6dbd772f7bd1057", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -28,6 +28,14 @@ use crate::{\n     request_metrics::RequestMetrics,\n     LspError, Result,\n };\n+pub use lsp_utils::show_message;\n+use lsp_utils::{is_canceled, notification_cast, notification_is, notification_new, request_new};\n+use ra_progress::{\n+    IsDone, ProgressStatus, U32Progress, U32ProgressReport, U32ProgressSource, U32ProgressStatus,\n+};\n+\n+const FLYCHECK_PROGRESS_TOKEN: &str = \"rustAnalyzer/flycheck\";\n+const ROOTS_SCANNED_PROGRESS_TOKEN: &str = \"rustAnalyzer/rootsScanned\";\n \n pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     log::info!(\"initial config: {:#?}\", config);\n@@ -138,6 +146,18 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n                     Ok(task) => Event::CheckWatcher(task),\n                     Err(RecvError) => return Err(\"check watcher died\".into()),\n+                },\n+                recv(global_state.flycheck_progress_receiver) -> status => match status {\n+                    Ok(status) => Event::ProgressReport(ProgressReport::Flycheck(status)),\n+                    Err(RecvError) => return Err(\"check watcher died\".into()),\n+                },\n+                recv(roots_scanned_progress_receiver) -> status => match status {\n+                    Ok(status) => Event::ProgressReport(ProgressReport::RootsScanned(status)),\n+                    Err(RecvError) => {\n+                        // Roots analysis has finished, we no longer need this receiver\n+                        roots_scanned_progress_receiver = never();\n+                        continue;\n+                    }\n                 }\n             };\n             if let Event::Msg(Message::Request(req)) = &event {\n@@ -169,6 +189,7 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n enum Task {\n     Respond(Response),\n     Notify(Notification),\n+    SendRequest(Request),\n     Diagnostic(DiagnosticTask),\n }\n \n@@ -177,6 +198,13 @@ enum Event {\n     Task(Task),\n     Vfs(vfs::loader::Message),\n     CheckWatcher(CheckTask),\n+    ProgressReport(ProgressReport),\n+}\n+\n+#[derive(Debug)]\n+enum ProgressReport {\n+    Flycheck(ProgressStatus<(), String>),\n+    RootsScanned(U32ProgressStatus),\n }\n \n impl fmt::Debug for Event {\n@@ -212,6 +240,7 @@ impl fmt::Debug for Event {\n             Event::Task(it) => fmt::Debug::fmt(it, f),\n             Event::Vfs(it) => fmt::Debug::fmt(it, f),\n             Event::CheckWatcher(it) => fmt::Debug::fmt(it, f),\n+            Event::ProgressReport(it) => fmt::Debug::fmt(it, f),\n         }\n     }\n }\n@@ -262,6 +291,9 @@ fn loop_turn(\n             }\n         },\n         Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n+        Event::ProgressReport(report) => {\n+            on_progress_report(report, task_sender, loop_state, global_state)\n+        }\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => {\n                 on_request(global_state, pool, task_sender, &connection.sender, loop_start, req)?\n@@ -826,7 +858,7 @@ where\n         Err(e) => match e.downcast::<LspError>() {\n             Ok(lsp_error) => Response::new_err(id, lsp_error.code, lsp_error.message),\n             Err(e) => {\n-                if is_canceled(&e) {\n+                if is_canceled(&*e) {\n                     Response::new_err(\n                         id,\n                         ErrorCode::ContentModified as i32,\n@@ -853,7 +885,7 @@ fn update_file_notifications_on_threadpool(\n             for file_id in subscriptions {\n                 match handlers::publish_diagnostics(&world, file_id) {\n                     Err(e) => {\n-                        if !is_canceled(&e) {\n+                        if !is_canceled(&*e) {\n                             log::error!(\"failed to compute diagnostics: {:?}\", e);\n                         }\n                     }"}, {"sha": "15d2a05a41961896395c6abdae4d85548bb0439e", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -202,7 +202,11 @@ impl Server {\n                     ProgressParams {\n                         token: lsp_types::ProgressToken::String(ref token),\n                         value: ProgressParamsValue::WorkDone(WorkDoneProgress::End(_)),\n+<<<<<<< HEAD\n                     } if token == \"rustAnalyzer/roots scanned\" => true,\n+=======\n+                    } if token == \"rustAnalyzer/rootsScanned\" => true,\n+>>>>>>> Veetaha-feat/sync-branch\n                     _ => false,\n                 }\n             }"}, {"sha": "cdb63b46f92f04b7d493b005783d6d14a14316de", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -5,7 +5,6 @@ import { promises as fs, PathLike } from \"fs\";\n \n import * as commands from './commands';\n import { activateInlayHints } from './inlay_hints';\n-import { activateStatusDisplay } from './status_display';\n import { Ctx } from './ctx';\n import { Config, NIGHTLY_TAG } from './config';\n import { log, assert, isValidExecutable } from './util';\n@@ -117,8 +116,6 @@ export async function activate(context: vscode.ExtensionContext) {\n \n     ctx.pushCleanup(activateTaskProvider(workspaceFolder));\n \n-    activateStatusDisplay(ctx);\n-\n     activateInlayHints(ctx);\n \n     vscode.workspace.onDidChangeConfiguration("}, {"sha": "f9cadc8a2258c0834f3fa6a74a5efb935bcecdaf", "filename": "editors/code/src/status_display.ts", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/editors%2Fcode%2Fsrc%2Fstatus_display.ts", "raw_url": "https://github.com/rust-lang/rust/raw/78e94e4570f09c8cbe1f8c6802df9b112ca37f08/editors%2Fcode%2Fsrc%2Fstatus_display.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fstatus_display.ts?ref=78e94e4570f09c8cbe1f8c6802df9b112ca37f08", "patch": "@@ -1,100 +0,0 @@\n-import * as vscode from 'vscode';\n-\n-import { WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressReport, WorkDoneProgressEnd, Disposable } from 'vscode-languageclient';\n-\n-import { Ctx } from './ctx';\n-\n-const spinnerFrames = ['\u280b', '\u2819', '\u2839', '\u2838', '\u283c', '\u2834', '\u2826', '\u2827', '\u2807', '\u280f'];\n-\n-export function activateStatusDisplay(ctx: Ctx) {\n-    const statusDisplay = new StatusDisplay(ctx.config.checkOnSave.command);\n-    ctx.pushCleanup(statusDisplay);\n-    const client = ctx.client;\n-    if (client != null) {\n-        ctx.pushCleanup(client.onProgress(\n-            WorkDoneProgress.type,\n-            'rustAnalyzer/cargoWatcher',\n-            params => statusDisplay.handleProgressNotification(params)\n-        ));\n-    }\n-}\n-\n-class StatusDisplay implements Disposable {\n-    packageName?: string;\n-\n-    private i: number = 0;\n-    private statusBarItem: vscode.StatusBarItem;\n-    private command: string;\n-    private timer?: NodeJS.Timeout;\n-\n-    constructor(command: string) {\n-        this.statusBarItem = vscode.window.createStatusBarItem(\n-            vscode.StatusBarAlignment.Left,\n-            10,\n-        );\n-        this.command = command;\n-        this.statusBarItem.hide();\n-    }\n-\n-    show() {\n-        this.packageName = undefined;\n-\n-        this.timer =\n-            this.timer ||\n-            setInterval(() => {\n-                this.tick();\n-                this.refreshLabel();\n-            }, 300);\n-\n-        this.statusBarItem.show();\n-    }\n-\n-    hide() {\n-        if (this.timer) {\n-            clearInterval(this.timer);\n-            this.timer = undefined;\n-        }\n-\n-        this.statusBarItem.hide();\n-    }\n-\n-    dispose() {\n-        if (this.timer) {\n-            clearInterval(this.timer);\n-            this.timer = undefined;\n-        }\n-\n-        this.statusBarItem.dispose();\n-    }\n-\n-    refreshLabel() {\n-        if (this.packageName) {\n-            this.statusBarItem.text = `${spinnerFrames[this.i]} cargo ${this.command} [${this.packageName}]`;\n-        } else {\n-            this.statusBarItem.text = `${spinnerFrames[this.i]} cargo ${this.command}`;\n-        }\n-    }\n-\n-    handleProgressNotification(params: WorkDoneProgressBegin | WorkDoneProgressReport | WorkDoneProgressEnd) {\n-        switch (params.kind) {\n-            case 'begin':\n-                this.show();\n-                break;\n-\n-            case 'report':\n-                if (params.message) {\n-                    this.packageName = params.message;\n-                    this.refreshLabel();\n-                }\n-                break;\n-\n-            case 'end':\n-                this.hide();\n-                break;\n-        }\n-    }\n-\n-    private tick() {\n-        this.i = (this.i + 1) % spinnerFrames.length;\n-    }\n-}"}]}