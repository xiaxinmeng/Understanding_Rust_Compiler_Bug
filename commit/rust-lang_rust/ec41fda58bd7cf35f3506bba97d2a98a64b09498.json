{"sha": "ec41fda58bd7cf35f3506bba97d2a98a64b09498", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNDFmZGE1OGJkN2NmMzVmMzUwNmJiYTk3ZDJhOThhNjRiMDk0OTg=", "commit": {"author": {"name": "David Haig", "email": "david@ninjasource.com", "date": "2019-11-25T12:58:40Z"}, "committer": {"name": "David Haig", "email": "david@ninjasource.com", "date": "2019-11-28T07:43:53Z"}, "message": "Squash", "tree": {"sha": "e940933fc6de2210d1144d90004be32a4ce65e3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e940933fc6de2210d1144d90004be32a4ce65e3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec41fda58bd7cf35f3506bba97d2a98a64b09498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec41fda58bd7cf35f3506bba97d2a98a64b09498", "html_url": "https://github.com/rust-lang/rust/commit/ec41fda58bd7cf35f3506bba97d2a98a64b09498", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec41fda58bd7cf35f3506bba97d2a98a64b09498/comments", "author": null, "committer": null, "parents": [{"sha": "96ad8e5fbcf00afc1ccde386b031919b4d01aa33", "url": "https://api.github.com/repos/rust-lang/rust/commits/96ad8e5fbcf00afc1ccde386b031919b4d01aa33", "html_url": "https://github.com/rust-lang/rust/commit/96ad8e5fbcf00afc1ccde386b031919b4d01aa33"}], "stats": {"total": 225, "additions": 192, "deletions": 33}, "files": [{"sha": "93543bc361643587f39cace61ac8bdbc79354a6b", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -266,6 +266,8 @@ pub enum PanicInfo<O> {\n     RemainderByZero,\n     GeneratorResumedAfterReturn,\n     GeneratorResumedAfterPanic,\n+    AsyncResumedAfterReturn,\n+    AsyncResumedAfterPanic,\n }\n \n /// Type for MIR `Assert` terminator error messages.\n@@ -304,6 +306,10 @@ impl<O> PanicInfo<O> {\n                 \"generator resumed after completion\",\n             GeneratorResumedAfterPanic =>\n                 \"generator resumed after panicking\",\n+            AsyncResumedAfterReturn =>\n+                \"`async fn` resumed after completion\",\n+            AsyncResumedAfterPanic =>\n+                \"`async fn` resumed after panic\",\n             Panic { .. } | BoundsCheck { .. } =>\n                 bug!(\"Unexpected PanicInfo\"),\n         }"}, {"sha": "d6048a1b394a278c71eb5e418af79a9b6226b99a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -6,7 +6,7 @@\n \n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n-use crate::hir;\n+use crate::hir::GeneratorKind;\n use crate::mir::interpret::{GlobalAlloc, PanicInfo, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n@@ -117,6 +117,10 @@ pub struct Body<'tcx> {\n     /// The layout of a generator. Produced by the state transformation.\n     pub generator_layout: Option<GeneratorLayout<'tcx>>,\n \n+    /// If this is a generator then record the type of source expression that caused this generator\n+    /// to be created.\n+    pub generator_kind: Option<GeneratorKind>,\n+\n     /// Declarations of locals.\n     ///\n     /// The first local is the return value pointer, followed by `arg_count`\n@@ -170,6 +174,7 @@ impl<'tcx> Body<'tcx> {\n         var_debug_info: Vec<VarDebugInfo<'tcx>>,\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n+        generator_kind : Option<GeneratorKind>,\n     ) -> Self {\n         // We need `arg_count` locals, and one for the return place.\n         assert!(\n@@ -187,6 +192,7 @@ impl<'tcx> Body<'tcx> {\n             yield_ty: None,\n             generator_drop: None,\n             generator_layout: None,\n+            generator_kind,\n             local_decls,\n             user_type_annotations,\n             arg_count,\n@@ -2975,7 +2981,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                             index: index.fold_with(folder),\n                         },\n                     Panic { .. } | Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n-                    GeneratorResumedAfterReturn | GeneratorResumedAfterPanic =>\n+                    GeneratorResumedAfterReturn | GeneratorResumedAfterPanic |\n+                    AsyncResumedAfterReturn | AsyncResumedAfterPanic =>\n                         msg.clone(),\n                 };\n                 Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n@@ -3021,7 +3028,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                             len.visit_with(visitor) || index.visit_with(visitor),\n                         Panic { .. } | Overflow(_) | OverflowNeg |\n                         DivisionByZero | RemainderByZero |\n-                        GeneratorResumedAfterReturn | GeneratorResumedAfterPanic =>\n+                        GeneratorResumedAfterReturn | GeneratorResumedAfterPanic |\n+                        AsyncResumedAfterReturn | AsyncResumedAfterPanic =>\n                             false\n                     }\n                 } else {"}, {"sha": "cce1ef9eb8be88f5b9e1fdfbcc23972ac32b00ba", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -517,7 +517,8 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(index, location);\n                     }\n                     Panic { .. } | Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n-                    GeneratorResumedAfterReturn | GeneratorResumedAfterPanic => {\n+                    GeneratorResumedAfterReturn | GeneratorResumedAfterPanic |\n+                    AsyncResumedAfterReturn | AsyncResumedAfterPanic => {\n                         // Nothing to visit\n                     }\n                 }"}, {"sha": "91ddd5a5623c0e48946ec9e4301af3aefa04c367", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -5,7 +5,7 @@ use crate::hair::{LintLevel, BindingMode, PatKind};\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use rustc::hir;\n-use rustc::hir::Node;\n+use rustc::hir::{Node, GeneratorKind};\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items;\n use rustc::middle::region;\n@@ -279,7 +279,7 @@ struct Builder<'a, 'tcx> {\n \n     fn_span: Span,\n     arg_count: usize,\n-    is_generator: bool,\n+    generator_kind: Option<GeneratorKind>,\n \n     /// The current set of scopes, updated as we traverse;\n     /// see the `scope` module for more details.\n@@ -570,7 +570,7 @@ where\n         safety,\n         return_ty,\n         return_ty_span,\n-        body.generator_kind.is_some());\n+        body.generator_kind);\n \n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,\n@@ -647,7 +647,7 @@ fn construct_const<'a, 'tcx>(\n         Safety::Safe,\n         const_ty,\n         const_ty_span,\n-        false,\n+        None,\n     );\n \n     let mut block = START_BLOCK;\n@@ -678,7 +678,7 @@ fn construct_error<'a, 'tcx>(\n     let owner_id = hir.tcx().hir().body_owner(body_id);\n     let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, false);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, None);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish()\n@@ -691,15 +691,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n            safety: Safety,\n            return_ty: Ty<'tcx>,\n            return_span: Span,\n-           is_generator: bool)\n+           generator_kind: Option<GeneratorKind>)\n            -> Builder<'a, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n             hir,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             arg_count,\n-            is_generator,\n+            generator_kind,\n             scopes: Default::default(),\n             block_context: BlockContext::new(),\n             source_scopes: IndexVec::new(),\n@@ -748,6 +748,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.var_debug_info,\n             self.fn_span,\n             self.hir.control_flow_destroyed(),\n+            self.generator_kind\n         )\n     }\n "}, {"sha": "bb25b28526960190446b4ced7ef36f0a6ee0f5c4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -91,6 +91,7 @@ use syntax_pos::{DUMMY_SP, Span};\n use rustc_data_structures::fx::FxHashMap;\n use std::collections::hash_map::Entry;\n use std::mem;\n+use rustc::hir::GeneratorKind;\n \n #[derive(Debug)]\n struct Scope {\n@@ -219,7 +220,12 @@ impl Scope {\n     /// `storage_only` controls whether to invalidate only drop paths that run `StorageDead`.\n     /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n     /// top-of-scope (as opposed to dependent scopes).\n-    fn invalidate_cache(&mut self, storage_only: bool, is_generator: bool, this_scope_only: bool) {\n+    fn invalidate_cache(\n+        &mut self,\n+        storage_only: bool,\n+        generator_kind: Option<GeneratorKind>,\n+        this_scope_only: bool\n+    ) {\n         // FIXME: maybe do shared caching of `cached_exits` etc. to handle functions\n         // with lots of `try!`?\n \n@@ -229,7 +235,7 @@ impl Scope {\n         // the current generator drop and unwind refer to top-of-scope\n         self.cached_generator_drop = None;\n \n-        let ignore_unwinds = storage_only && !is_generator;\n+        let ignore_unwinds = storage_only && generator_kind.is_none();\n         if !ignore_unwinds {\n             self.cached_unwind.invalidate();\n         }\n@@ -481,7 +487,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         unpack!(block = build_scope_drops(\n             &mut self.cfg,\n-            self.is_generator,\n+            self.generator_kind,\n             &scope,\n             block,\n             unwind_to,\n@@ -574,7 +580,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             unpack!(block = build_scope_drops(\n                 &mut self.cfg,\n-                self.is_generator,\n+                self.generator_kind,\n                 scope,\n                 block,\n                 unwind_to,\n@@ -625,7 +631,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             unpack!(block = build_scope_drops(\n                 &mut self.cfg,\n-                self.is_generator,\n+                self.generator_kind,\n                 scope,\n                 block,\n                 unwind_to,\n@@ -809,7 +815,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n             // cache of outer scope stays intact.\n-            scope.invalidate_cache(!needs_drop, self.is_generator, this_scope);\n+            scope.invalidate_cache(!needs_drop, self.generator_kind, this_scope);\n             if this_scope {\n                 let region_scope_span = region_scope.span(self.hir.tcx(),\n                                                           &self.hir.region_scope_tree);\n@@ -958,7 +964,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     }\n \n-                    top_scope.invalidate_cache(true, self.is_generator, true);\n+                    top_scope.invalidate_cache(true, self.generator_kind, true);\n                 } else {\n                     bug!(\"Expected as_local_operand to produce a temporary\");\n                 }\n@@ -1016,7 +1022,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         for scope in self.scopes.top_scopes(first_uncached) {\n             target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n-                                         scope, target, generator_drop, self.is_generator);\n+                                         scope, target, generator_drop, self.generator_kind);\n         }\n \n         target\n@@ -1079,14 +1085,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         assert_eq!(top_scope.region_scope, region_scope);\n \n         top_scope.drops.clear();\n-        top_scope.invalidate_cache(false, self.is_generator, true);\n+        top_scope.invalidate_cache(false, self.generator_kind, true);\n     }\n }\n \n /// Builds drops for pop_scope and exit_scope.\n fn build_scope_drops<'tcx>(\n     cfg: &mut CFG<'tcx>,\n-    is_generator: bool,\n+    generator_kind: Option<GeneratorKind>,\n     scope: &Scope,\n     mut block: BasicBlock,\n     last_unwind_to: BasicBlock,\n@@ -1130,7 +1136,7 @@ fn build_scope_drops<'tcx>(\n                     continue;\n                 }\n \n-                let unwind_to = get_unwind_to(scope, is_generator, drop_idx, generator_drop)\n+                let unwind_to = get_unwind_to(scope, generator_kind, drop_idx, generator_drop)\n                     .unwrap_or(last_unwind_to);\n \n                 let next = cfg.start_new_block();\n@@ -1156,19 +1162,19 @@ fn build_scope_drops<'tcx>(\n \n fn get_unwind_to(\n     scope: &Scope,\n-    is_generator: bool,\n+    generator_kind: Option<GeneratorKind>,\n     unwind_from: usize,\n     generator_drop: bool,\n ) -> Option<BasicBlock> {\n     for drop_idx in (0..unwind_from).rev() {\n         let drop_data = &scope.drops[drop_idx];\n-        match (is_generator, &drop_data.kind) {\n-            (true, DropKind::Storage) => {\n+        match (generator_kind, &drop_data.kind) {\n+            (Some(_), DropKind::Storage) => {\n                 return Some(drop_data.cached_block.get(generator_drop).unwrap_or_else(|| {\n                     span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n                 }));\n             }\n-            (false, DropKind::Value) => {\n+            (None, DropKind::Value) => {\n                 return Some(drop_data.cached_block.get(generator_drop).unwrap_or_else(|| {\n                     span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n                 }));\n@@ -1184,7 +1190,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                              scope: &mut Scope,\n                              mut target: BasicBlock,\n                              generator_drop: bool,\n-                             is_generator: bool)\n+                             generator_kind: Option<GeneratorKind>)\n                              -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n@@ -1224,7 +1230,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n         // match the behavior of clang, but on inspection eddyb says\n         // this is not what clang does.\n         match drop_data.kind {\n-            DropKind::Storage if is_generator => {\n+            DropKind::Storage if generator_kind.is_some() => {\n                 storage_deads.push(Statement {\n                     source_info: source_info(drop_data.span),\n                     kind: StatementKind::StorageDead(drop_data.local)"}, {"sha": "59b721b73b5f22f9119d37911127b3de019d91ec", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -144,6 +144,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         RemainderByZero => err_panic!(RemainderByZero),\n                         GeneratorResumedAfterReturn => err_panic!(GeneratorResumedAfterReturn),\n                         GeneratorResumedAfterPanic => err_panic!(GeneratorResumedAfterPanic),\n+                        AsyncResumedAfterReturn => err_panic!(AsyncResumedAfterReturn),\n+                        AsyncResumedAfterPanic => err_panic!(AsyncResumedAfterPanic),\n                         Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n                     }\n                     .into());"}, {"sha": "d623e7870e19e6f3d5b9f1f15e4c2a73c1adc6d8", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -208,6 +208,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n         vec![],\n         span,\n         vec![],\n+        None,\n     );\n \n     if let Some(..) = ty {\n@@ -374,6 +375,7 @@ impl CloneShimBuilder<'tcx> {\n             vec![],\n             self.span,\n             vec![],\n+            None,\n         )\n     }\n \n@@ -834,6 +836,7 @@ fn build_call_shim<'tcx>(\n         vec![],\n         span,\n         vec![],\n+        None,\n     );\n     if let Abi::RustCall = sig.abi {\n         body.spread_arg = Some(Local::new(sig.inputs().len()));\n@@ -920,6 +923,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n         vec![],\n         span,\n         vec![],\n+        None,\n     );\n \n     crate::util::dump_mir("}, {"sha": "d2740cf3771a8780cc0ebca19e725e5121fb5f77", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -91,6 +91,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n                 Default::default(),\n                 tcx.def_span(source.def_id()),\n                 Default::default(),\n+                body.generator_kind,\n             );\n \n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold"}, {"sha": "c6fe877ec59e7a2a9eac26ac00924aa7f6912989", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -50,7 +50,7 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::{def_id::DefId, GeneratorKind};\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n@@ -1058,14 +1058,27 @@ fn create_generator_resume_function<'tcx>(\n     use rustc::mir::interpret::PanicInfo::{\n         GeneratorResumedAfterPanic,\n         GeneratorResumedAfterReturn,\n+        AsyncResumedAfterReturn,\n+        AsyncResumedAfterPanic,\n     };\n \n     // Jump to the entry point on the unresumed\n     cases.insert(0, (UNRESUMED, BasicBlock::new(0)));\n-    // Panic when resumed on the returned state\n-    cases.insert(1, (RETURNED, insert_panic_block(tcx, body, GeneratorResumedAfterReturn)));\n-    // Panic when resumed on the poisoned state\n-    cases.insert(2, (POISONED, insert_panic_block(tcx, body, GeneratorResumedAfterPanic)));\n+\n+    // Panic when resumed on the returned or poisoned state\n+    match body.generator_kind {\n+        Some(GeneratorKind::Async(_)) => {\n+            cases.insert(1, (RETURNED, insert_panic_block(tcx, body, AsyncResumedAfterReturn)));\n+            cases.insert(2, (POISONED, insert_panic_block(tcx, body, AsyncResumedAfterPanic)));\n+        },\n+        Some(GeneratorKind::Gen) => {\n+            cases.insert(1, (RETURNED, insert_panic_block(tcx, body, GeneratorResumedAfterReturn)));\n+            cases.insert(2, (POISONED, insert_panic_block(tcx, body, GeneratorResumedAfterPanic)));\n+        },\n+        None => {\n+            // N/A because we would never create a resume function if there was no generator_kind\n+        }\n+    };\n \n     insert_switch(body, cases, &transform, TerminatorKind::Unreachable);\n "}, {"sha": "309b863bc0c67ea59ada20b511e4fa3a96a643fc", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -1104,6 +1104,7 @@ pub fn promote_candidates<'tcx>(\n                 vec![],\n                 body.span,\n                 vec![],\n+                body.generator_kind,\n             ),\n             tcx,\n             source: body,"}, {"sha": "54df1a5664edaab150a7260111919c139ce7efec", "filename": "src/test/ui/issues/issue-65419/issue-65419-async-fn-resume-after-completion.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-completion.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -0,0 +1,44 @@\n+// issue 65419 - Attempting to run an async fn after completion mentions generators when it should\n+// be talking about `async fn`s instead.\n+\n+// run-fail\n+// error-pattern: thread 'main' panicked at '`async fn` resumed after completion'\n+// compile-flags: --edition 2018\n+\n+#![feature(generators, generator_trait)]\n+\n+async fn foo() {\n+}\n+\n+fn main() {\n+    let mut future = Box::pin(foo());\n+    executor::block_on(future.as_mut());\n+    executor::block_on(future.as_mut());\n+}\n+\n+mod executor {\n+    use core::{\n+        future::Future,\n+        pin::Pin,\n+        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    };\n+\n+    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+\n+        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+            |_| unimplemented!(\"clone\"),\n+            |_| unimplemented!(\"wake\"),\n+            |_| unimplemented!(\"wake_by_ref\"),\n+            |_| (),\n+        );\n+        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+        let mut context = Context::from_waker(&waker);\n+\n+        loop {\n+            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+                break val;\n+            }\n+        }\n+    }\n+}"}, {"sha": "f5d7af2c87e1e2644e80fcf2b8c007feae5447e2", "filename": "src/test/ui/issues/issue-65419/issue-65419-async-fn-resume-after-panic.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-panic.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -0,0 +1,50 @@\n+// issue 65419 - Attempting to run an async fn after completion mentions generators when it should\n+// be talking about `async fn`s instead. Should also test what happens when it panics.\n+\n+// run-fail\n+// error-pattern: thread 'main' panicked at '`async fn` resumed after panic'\n+// compile-flags: --edition 2018\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::panic;\n+\n+async fn foo() {\n+    panic!();\n+}\n+\n+fn main() {\n+    let mut future = Box::pin(foo());\n+    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        executor::block_on(future.as_mut());\n+    }));\n+\n+    executor::block_on(future.as_mut());\n+}\n+\n+mod executor {\n+    use core::{\n+        future::Future,\n+        pin::Pin,\n+        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    };\n+\n+    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+\n+        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+            |_| unimplemented!(\"clone\"),\n+            |_| unimplemented!(\"wake\"),\n+            |_| unimplemented!(\"wake_by_ref\"),\n+            |_| (),\n+        );\n+        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+        let mut context = Context::from_waker(&waker);\n+\n+        loop {\n+            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+                break val;\n+            }\n+        }\n+    }\n+}"}, {"sha": "456c1d38e8c491b37a2f99549d5794776a6f6ac1", "filename": "src/test/ui/issues/issue-65419/issue-65419-generator-resume-after-completion.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec41fda58bd7cf35f3506bba97d2a98a64b09498/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs?ref=ec41fda58bd7cf35f3506bba97d2a98a64b09498", "patch": "@@ -0,0 +1,22 @@\n+// issue 65419 - Attempting to run an `async fn` after completion mentions generators when it should\n+// be talking about `async fn`s instead. Regression test added to make sure generators still\n+// panic when resumed after completion.\n+\n+// run-fail\n+// error-pattern:generator resumed after completion\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::{\n+    ops::Generator,\n+    pin::Pin,\n+};\n+\n+fn main() {\n+    let mut g = || {\n+        yield;\n+    };\n+    Pin::new(&mut g).resume(); // Yields once.\n+    Pin::new(&mut g).resume(); // Completes here.\n+    Pin::new(&mut g).resume(); // Panics here.\n+}"}]}