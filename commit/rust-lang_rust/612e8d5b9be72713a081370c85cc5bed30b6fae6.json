{"sha": "612e8d5b9be72713a081370c85cc5bed30b6fae6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMmU4ZDViOWJlNzI3MTNhMDgxMzcwYzg1Y2M1YmVkMzBiNmZhZTY=", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2021-03-28T21:25:30Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2021-04-03T04:21:06Z"}, "message": "refactor: apply rustc mod parsing changes", "tree": {"sha": "1caba40e1509844239e05b8efd86de1caeeff7b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1caba40e1509844239e05b8efd86de1caeeff7b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/612e8d5b9be72713a081370c85cc5bed30b6fae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/612e8d5b9be72713a081370c85cc5bed30b6fae6", "html_url": "https://github.com/rust-lang/rust/commit/612e8d5b9be72713a081370c85cc5bed30b6fae6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/612e8d5b9be72713a081370c85cc5bed30b6fae6/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c6339571bfc97c5eb0516e20ab0d3b9543f87e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6339571bfc97c5eb0516e20ab0d3b9543f87e5", "html_url": "https://github.com/rust-lang/rust/commit/2c6339571bfc97c5eb0516e20ab0d3b9543f87e5"}], "stats": {"total": 200, "additions": 130, "deletions": 70}, "files": [{"sha": "2c38de04797038d48f395b9ac2f8b7da840f6d0c", "filename": "src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=612e8d5b9be72713a081370c85cc5bed30b6fae6", "patch": "@@ -145,7 +145,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n         module: &Module<'_>,\n         is_macro_def: bool,\n     ) -> Result<(), ErrorKind> {\n-        let snippet_provider = self.parse_session.snippet_provider(module.as_ref().inner);\n+        let snippet_provider = self.parse_session.snippet_provider(module.span);\n         let mut visitor = FmtVisitor::from_parse_sess(\n             &self.parse_session,\n             &self.config,"}, {"sha": "00757210ce54f62891017156e61da1946664fc17", "filename": "src/items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=612e8d5b9be72713a081370c85cc5bed30b6fae6", "patch": "@@ -3271,8 +3271,8 @@ pub(crate) fn rewrite_extern_crate(\n /// Returns `true` for `mod foo;`, false for `mod foo { .. }`.\n pub(crate) fn is_mod_decl(item: &ast::Item) -> bool {\n     match item.kind {\n-        ast::ItemKind::Mod(ref m) => m.inner.hi() != item.span.hi(),\n-        _ => false,\n+        ast::ItemKind::Mod(_, ast::ModKind::Loaded(_, ast::Inline::Yes, _)) => false,\n+        _ => true,\n     }\n }\n "}, {"sha": "2ee3639ffb1a4fa56e05519800208736f50aea6c", "filename": "src/modules.rs", "status": "modified", "additions": 110, "deletions": 49, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=612e8d5b9be72713a081370c85cc5bed30b6fae6", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::ast;\n use rustc_ast::attr::HasAttrs;\n use rustc_ast::visit::Visitor;\n use rustc_span::symbol::{self, sym, Symbol};\n+use rustc_span::Span;\n use thiserror::Error;\n \n use crate::attr::MetaVisitor;\n@@ -24,20 +25,31 @@ type FileModMap<'ast> = BTreeMap<FileName, Module<'ast>>;\n /// Represents module with its inner attributes.\n #[derive(Debug, Clone)]\n pub(crate) struct Module<'a> {\n-    ast_mod: Cow<'a, ast::Mod>,\n+    ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n+    pub(crate) items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n+    attrs: Cow<'a, Vec<ast::Attribute>>,\n     inner_attr: Vec<ast::Attribute>,\n+    pub(crate) span: Span,\n }\n \n impl<'a> Module<'a> {\n-    pub(crate) fn new(ast_mod: Cow<'a, ast::Mod>, attrs: &[ast::Attribute]) -> Self {\n-        let inner_attr = attrs\n+    pub(crate) fn new(\n+        mod_span: Span,\n+        ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n+        mod_items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n+        mod_attrs: Cow<'a, Vec<ast::Attribute>>,\n+    ) -> Self {\n+        let inner_attr = mod_attrs\n             .iter()\n             .filter(|attr| attr.style == ast::AttrStyle::Inner)\n             .cloned()\n             .collect();\n         Module {\n-            ast_mod,\n+            items: mod_items,\n+            attrs: mod_attrs,\n             inner_attr,\n+            span: mod_span,\n+            ast_mod_kind,\n         }\n     }\n }\n@@ -51,12 +63,6 @@ impl<'a> HasAttrs for Module<'a> {\n     }\n }\n \n-impl<'a> AsRef<ast::Mod> for Module<'a> {\n-    fn as_ref(&self) -> &ast::Mod {\n-        &self.ast_mod\n-    }\n-}\n-\n /// Maps each module to the corresponding file.\n pub(crate) struct ModResolver<'ast, 'sess> {\n     parse_sess: &'sess ParseSess,\n@@ -124,12 +130,17 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n \n         // Skip visiting sub modules when the input is from stdin.\n         if self.recursive {\n-            self.visit_mod_from_ast(&krate.module)?;\n+            self.visit_mod_from_ast(&krate.items)?;\n         }\n \n         self.file_map.insert(\n             root_filename,\n-            Module::new(Cow::Borrowed(&krate.module), &krate.attrs),\n+            Module::new(\n+                krate.span,\n+                None,\n+                Cow::Borrowed(&krate.items),\n+                Cow::Borrowed(&krate.attrs),\n+            ),\n         );\n         Ok(self.file_map)\n     }\n@@ -139,40 +150,69 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         let mut visitor = visitor::CfgIfVisitor::new(self.parse_sess);\n         visitor.visit_item(&item);\n         for module_item in visitor.mods() {\n-            if let ast::ItemKind::Mod(ref sub_mod) = module_item.item.kind {\n+            if let ast::ItemKind::Mod(_, ref sub_mod_kind) = module_item.item.kind {\n                 self.visit_sub_mod(\n                     &module_item.item,\n-                    Module::new(Cow::Owned(sub_mod.clone()), &module_item.item.attrs),\n+                    Module::new(\n+                        module_item.item.span,\n+                        Some(Cow::Owned(sub_mod_kind.clone())),\n+                        Cow::Owned(vec![]),\n+                        Cow::Owned(vec![]),\n+                    ),\n                 )?;\n             }\n         }\n         Ok(())\n     }\n \n     /// Visit modules defined inside macro calls.\n-    fn visit_mod_outside_ast(&mut self, module: ast::Mod) -> Result<(), ModuleResolutionError> {\n-        for item in module.items {\n+    fn visit_mod_outside_ast(\n+        &mut self,\n+        items: Vec<rustc_ast::ptr::P<ast::Item>>,\n+    ) -> Result<(), ModuleResolutionError> {\n+        for item in items {\n             if is_cfg_if(&item) {\n                 self.visit_cfg_if(Cow::Owned(item.into_inner()))?;\n                 continue;\n             }\n \n-            if let ast::ItemKind::Mod(ref sub_mod) = item.kind {\n-                self.visit_sub_mod(&item, Module::new(Cow::Owned(sub_mod.clone()), &item.attrs))?;\n+            if let ast::ItemKind::Mod(_, ref sub_mod_kind) = item.kind {\n+                let span = item.span;\n+                self.visit_sub_mod(\n+                    &item,\n+                    Module::new(\n+                        span,\n+                        Some(Cow::Owned(sub_mod_kind.clone())),\n+                        Cow::Owned(vec![]),\n+                        Cow::Owned(vec![]),\n+                    ),\n+                )?;\n             }\n         }\n         Ok(())\n     }\n \n     /// Visit modules from AST.\n-    fn visit_mod_from_ast(&mut self, module: &'ast ast::Mod) -> Result<(), ModuleResolutionError> {\n-        for item in &module.items {\n+    fn visit_mod_from_ast(\n+        &mut self,\n+        items: &'ast Vec<rustc_ast::ptr::P<ast::Item>>,\n+    ) -> Result<(), ModuleResolutionError> {\n+        for item in items {\n             if is_cfg_if(item) {\n                 self.visit_cfg_if(Cow::Borrowed(item))?;\n             }\n \n-            if let ast::ItemKind::Mod(ref sub_mod) = item.kind {\n-                self.visit_sub_mod(item, Module::new(Cow::Borrowed(sub_mod), &item.attrs))?;\n+            if let ast::ItemKind::Mod(_, ref sub_mod_kind) = item.kind {\n+                let span = item.span;\n+                self.visit_sub_mod(\n+                    item,\n+                    Module::new(\n+                        span,\n+                        Some(Cow::Borrowed(sub_mod_kind)),\n+                        Cow::Owned(vec![]),\n+                        Cow::Borrowed(&item.attrs),\n+                    ),\n+                )?;\n             }\n         }\n         Ok(())\n@@ -273,9 +313,12 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         if let Some(directory) = directory {\n             self.directory = directory;\n         }\n-        match sub_mod.ast_mod {\n-            Cow::Borrowed(sub_mod) => self.visit_mod_from_ast(sub_mod),\n-            Cow::Owned(sub_mod) => self.visit_mod_outside_ast(sub_mod),\n+        match (sub_mod.ast_mod_kind, sub_mod.items) {\n+            (Some(Cow::Borrowed(ast::ModKind::Loaded(items, ast::Inline::No, _))), _) => {\n+                self.visit_mod_from_ast(&items)\n+            }\n+            (Some(Cow::Owned(..)), Cow::Owned(items)) => self.visit_mod_outside_ast(items),\n+            (_, _) => Ok(()),\n         }\n     }\n \n@@ -294,13 +337,17 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             if self.parse_sess.is_file_parsed(&path) {\n                 return Ok(None);\n             }\n-            return match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.ast_mod.inner)\n-            {\n-                Ok((_, ref attrs)) if contains_skip(attrs) => Ok(None),\n-                Ok(m) => Ok(Some(SubModKind::External(\n+            return match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.span) {\n+                Ok((ref attrs, _, _)) if contains_skip(attrs) => Ok(None),\n+                Ok((attrs, items, span)) => Ok(Some(SubModKind::External(\n                     path,\n                     DirectoryOwnership::Owned { relative: None },\n-                    Module::new(Cow::Owned(m.0), &m.1),\n+                    Module::new(\n+                        span,\n+                        Some(Cow::Owned(ast::ModKind::Unloaded)),\n+                        Cow::Owned(items),\n+                        Cow::Owned(attrs),\n+                    ),\n                 ))),\n                 Err(ParserError::ParseError) => Err(ModuleResolutionError {\n                     module: mod_name.to_string(),\n@@ -338,18 +385,30 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                         return Ok(Some(SubModKind::MultiExternal(mods_outside_ast)));\n                     }\n                 }\n-                match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.ast_mod.inner) {\n-                    Ok((_, ref attrs)) if contains_skip(attrs) => Ok(None),\n-                    Ok(m) if outside_mods_empty => Ok(Some(SubModKind::External(\n-                        path,\n-                        ownership,\n-                        Module::new(Cow::Owned(m.0), &m.1),\n-                    ))),\n-                    Ok(m) => {\n+                match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.span) {\n+                    Ok((ref attrs, _, _)) if contains_skip(attrs) => Ok(None),\n+                    Ok((attrs, items, span)) if outside_mods_empty => {\n+                        Ok(Some(SubModKind::External(\n+                            path,\n+                            ownership,\n+                            Module::new(\n+                                span,\n+                                Some(Cow::Owned(ast::ModKind::Unloaded)),\n+                                Cow::Owned(items),\n+                                Cow::Owned(attrs),\n+                            ),\n+                        )))\n+                    }\n+                    Ok((attrs, items, span)) => {\n                         mods_outside_ast.push((\n                             path.clone(),\n                             ownership,\n-                            Module::new(Cow::Owned(m.0), &m.1),\n+                            Module::new(\n+                                span,\n+                                Some(Cow::Owned(ast::ModKind::Unloaded)),\n+                                Cow::Owned(items),\n+                                Cow::Owned(attrs),\n+                            ),\n                         ));\n                         if should_insert {\n                             mods_outside_ast.push((path, ownership, sub_mod.clone()));\n@@ -437,20 +496,22 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                 ));\n                 continue;\n             }\n-            let m = match Parser::parse_file_as_module(\n-                self.parse_sess,\n-                &actual_path,\n-                sub_mod.ast_mod.inner,\n-            ) {\n-                Ok((_, ref attrs)) if contains_skip(attrs) => continue,\n-                Ok(m) => m,\n-                Err(..) => continue,\n-            };\n+            let (attrs, items, span) =\n+                match Parser::parse_file_as_module(self.parse_sess, &actual_path, sub_mod.span) {\n+                    Ok((ref attrs, _, _)) if contains_skip(attrs) => continue,\n+                    Ok(m) => m,\n+                    Err(..) => continue,\n+                };\n \n             result.push((\n                 actual_path,\n                 DirectoryOwnership::Owned { relative: None },\n-                Module::new(Cow::Owned(m.0), &m.1),\n+                Module::new(\n+                    span,\n+                    Some(Cow::Owned(ast::ModKind::Unloaded)),\n+                    Cow::Owned(items),\n+                    Cow::Owned(attrs),\n+                ),\n             ))\n         }\n         result"}, {"sha": "29248ced2ff07eb18fe1d80564b1bf8a8ff5d472", "filename": "src/syntux/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fsyntux%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fsyntux%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fparser.rs?ref=612e8d5b9be72713a081370c85cc5bed30b6fae6", "patch": "@@ -1,8 +1,8 @@\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::path::{Path, PathBuf};\n \n-use rustc_ast::ast;\n use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_ast::{ast, ptr};\n use rustc_errors::Diagnostic;\n use rustc_parse::{\n     new_parser_from_file,\n@@ -109,10 +109,10 @@ impl<'a> Parser<'a> {\n         sess: &'a ParseSess,\n         path: &Path,\n         span: Span,\n-    ) -> Result<(ast::Mod, Vec<ast::Attribute>), ParserError> {\n+    ) -> Result<(Vec<ast::Attribute>, Vec<ptr::P<ast::Item>>, Span), ParserError> {\n         let result = catch_unwind(AssertUnwindSafe(|| {\n             let mut parser = new_parser_from_file(sess.inner(), &path, Some(span));\n-            match parser.parse_mod(&TokenKind::Eof, ast::Unsafe::No) {\n+            match parser.parse_mod(&TokenKind::Eof) {\n                 Ok(result) => Some(result),\n                 Err(mut e) => {\n                     sess.emit_or_cancel_diagnostic(&mut e);"}, {"sha": "4cd6b8d56d111c1a6391869d77d084d62504263c", "filename": "src/visitor.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612e8d5b9be72713a081370c85cc5bed30b6fae6/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=612e8d5b9be72713a081370c85cc5bed30b6fae6", "patch": "@@ -524,10 +524,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     self.visit_enum(item.ident, &item.vis, def, generics, item.span);\n                     self.last_pos = source!(self, item.span).hi();\n                 }\n-                ast::ItemKind::Mod(ref module) => {\n-                    let is_inline = !is_mod_decl(item);\n+                ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n                     self.format_missing_with_indent(source!(self, item.span).lo());\n-                    self.format_mod(module, &item.vis, item.span, item.ident, attrs, is_inline);\n+                    self.format_mod(mod_kind, unsafety, &item.vis, item.span, item.ident, attrs);\n                 }\n                 ast::ItemKind::MacCall(ref mac) => {\n                     self.visit_mac(mac, Some(item.ident), MacroPosition::Item);\n@@ -921,8 +920,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         !is_skip_attr(segments)\n     }\n \n-    fn walk_mod_items(&mut self, m: &ast::Mod) {\n-        self.visit_items_with_reordering(&ptr_vec_to_ref_vec(&m.items));\n+    fn walk_mod_items(&mut self, items: &Vec<rustc_ast::ptr::P<ast::Item>>) {\n+        self.visit_items_with_reordering(&ptr_vec_to_ref_vec(&items));\n     }\n \n     fn walk_stmts(&mut self, stmts: &[Stmt<'_>], include_current_empty_semi: bool) {\n@@ -974,22 +973,22 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     fn format_mod(\n         &mut self,\n-        m: &ast::Mod,\n+        mod_kind: &ast::ModKind,\n+        unsafety: ast::Unsafe,\n         vis: &ast::Visibility,\n         s: Span,\n         ident: symbol::Ident,\n         attrs: &[ast::Attribute],\n-        is_internal: bool,\n     ) {\n         let vis_str = utils::format_visibility(&self.get_context(), vis);\n         self.push_str(&*vis_str);\n-        self.push_str(format_unsafety(m.unsafety));\n+        self.push_str(format_unsafety(unsafety));\n         self.push_str(\"mod \");\n         // Calling `to_owned()` to work around borrow checker.\n         let ident_str = rewrite_ident(&self.get_context(), ident).to_owned();\n         self.push_str(&ident_str);\n \n-        if is_internal {\n+        if let ast::ModKind::Loaded(ref items, ast::Inline::Yes, inner_span) = mod_kind {\n             match self.config.brace_style() {\n                 BraceStyle::AlwaysNextLine => {\n                     let indent_str = self.block_indent.to_string_with_newline(self.config);\n@@ -1001,19 +1000,19 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             // Hackery to account for the closing }.\n             let mod_lo = self.snippet_provider.span_after(source!(self, s), \"{\");\n             let body_snippet =\n-                self.snippet(mk_sp(mod_lo, source!(self, m.inner).hi() - BytePos(1)));\n+                self.snippet(mk_sp(mod_lo, source!(self, inner_span).hi() - BytePos(1)));\n             let body_snippet = body_snippet.trim();\n             if body_snippet.is_empty() {\n                 self.push_str(\"}\");\n             } else {\n                 self.last_pos = mod_lo;\n                 self.block_indent = self.block_indent.block_indent(self.config);\n                 self.visit_attrs(attrs, ast::AttrStyle::Inner);\n-                self.walk_mod_items(m);\n-                let missing_span = self.next_span(m.inner.hi() - BytePos(1));\n+                self.walk_mod_items(items);\n+                let missing_span = self.next_span(inner_span.hi() - BytePos(1));\n                 self.close_block(missing_span, false);\n             }\n-            self.last_pos = source!(self, m.inner).hi();\n+            self.last_pos = source!(self, inner_span).hi();\n         } else {\n             self.push_str(\";\");\n             self.last_pos = source!(self, s).hi();\n@@ -1023,9 +1022,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     pub(crate) fn format_separate_mod(&mut self, m: &Module<'_>, end_pos: BytePos) {\n         self.block_indent = Indent::empty();\n         if self.visit_attrs(m.attrs(), ast::AttrStyle::Inner) {\n-            self.push_skipped_with_span(m.attrs(), m.as_ref().inner, m.as_ref().inner);\n+            self.push_skipped_with_span(m.attrs(), m.span, m.span);\n         } else {\n-            self.walk_mod_items(m.as_ref());\n+            self.walk_mod_items(&m.items);\n             self.format_missing_with_indent(end_pos);\n         }\n     }"}]}