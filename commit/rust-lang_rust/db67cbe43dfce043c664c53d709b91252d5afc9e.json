{"sha": "db67cbe43dfce043c664c53d709b91252d5afc9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNjdjYmU0M2RmY2UwNDNjNjY0YzUzZDcwOWI5MTI1MmQ1YWZjOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-24T10:03:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-24T10:03:48Z"}, "message": "Auto merge of #27856 - nikomatsakis:move-def-id-to-rustc, r=eddyb\n\nIt doesn't really make sense for DefId to be in libsyntax -- it is concerned with a single crate only. It is the compiler that understands the idea of many crates. (At some point, there might be a useful intermediate point here.) This is a refactoring in support of incr. compilation, which will be adjusting the notion of a DefId to make it more durable across compilations.\r\n\r\nThis will probably be a [breaking-change] for every plugin ever. You need to adjust things as follows:\r\n\r\n    use rustc::middle::def_id::{DefId, LOCAL_CRATE}; // two most common definitions\r\n    ast_util::is_local(def_id) => def_id.is_local()\r\n    ast_util::local_def(node_id) => DefId::local(node_id)", "tree": {"sha": "89d0b566e67b3c00fcccd292dcb9f26e723767c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89d0b566e67b3c00fcccd292dcb9f26e723767c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db67cbe43dfce043c664c53d709b91252d5afc9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db67cbe43dfce043c664c53d709b91252d5afc9e", "html_url": "https://github.com/rust-lang/rust/commit/db67cbe43dfce043c664c53d709b91252d5afc9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db67cbe43dfce043c664c53d709b91252d5afc9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63ba780fd7ab506bfd0f92d34a39172b412cfbe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/63ba780fd7ab506bfd0f92d34a39172b412cfbe1", "html_url": "https://github.com/rust-lang/rust/commit/63ba780fd7ab506bfd0f92d34a39172b412cfbe1"}, {"sha": "19948751bd5487b4f7e8ba6943915a288a9be785", "url": "https://api.github.com/repos/rust-lang/rust/commits/19948751bd5487b4f7e8ba6943915a288a9be785", "html_url": "https://github.com/rust-lang/rust/commit/19948751bd5487b4f7e8ba6943915a288a9be785"}], "stats": {"total": 2162, "additions": 1109, "deletions": 1053}, "files": [{"sha": "f7f926d9d971afa5be26fad044a89ae5b5c873ae", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -14,6 +14,7 @@ use self::MapEntry::*;\n \n use metadata::inline::InlinedItem;\n use metadata::inline::InlinedItem as II;\n+use middle::def_id::DefId;\n use syntax::abi;\n use syntax::ast::*;\n use syntax::ast_util;\n@@ -378,7 +379,7 @@ impl<'ast> Map<'ast> {\n         match self.find_entry(parent) {\n             Some(RootInlinedParent(&InlinedParent {ii: II::TraitItem(did, _), ..})) => did,\n             Some(RootInlinedParent(&InlinedParent {ii: II::ImplItem(did, _), ..})) => did,\n-            _ => ast_util::local_def(parent)\n+            _ => DefId::local(parent)\n         }\n     }\n \n@@ -591,7 +592,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n-        if def_id.krate == LOCAL_CRATE {\n+        if def_id.is_local() {\n             self.opt_span(def_id.node).unwrap_or(fallback)\n         } else {\n             fallback"}, {"sha": "07ca6129505a6ceb9210016a213702726846205e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -118,6 +118,7 @@ pub mod middle {\n     pub mod dataflow;\n     pub mod dead;\n     pub mod def;\n+    pub mod def_id;\n     pub mod dependency_format;\n     pub mod effect;\n     pub mod entry;"}, {"sha": "79d98880164db9bea1ccd5c4915e2cd254173fe7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -15,6 +15,7 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::inline::InlinedItem;\n+use middle::def_id::DefId;\n use middle::lang_items;\n use middle::ty;\n \n@@ -30,11 +31,11 @@ use std::collections::hash_map::HashMap;\n #[derive(Copy, Clone)]\n pub struct MethodInfo {\n     pub name: ast::Name,\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub vis: ast::Visibility,\n }\n \n-pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> String {\n+pub fn get_symbol(cstore: &cstore::CStore, def: DefId) -> String {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_symbol(cdata.data(), def.node)\n }\n@@ -52,7 +53,7 @@ pub fn each_lang_item<F>(cstore: &cstore::CStore,\n \n /// Iterates over each child of the given item.\n pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n-                             def_id: ast::DefId,\n+                             def_id: DefId,\n                              callback: F) where\n     F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n {\n@@ -83,7 +84,7 @@ pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n                                           callback)\n }\n \n-pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n+pub fn get_item_path(tcx: &ty::ctxt, def: DefId) -> Vec<ast_map::PathElem> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     let path = decoder::get_item_path(&*cdata, def.node);\n@@ -96,22 +97,22 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n     })\n }\n \n-pub fn get_item_name(tcx: &ty::ctxt, def: ast::DefId) -> ast::Name {\n+pub fn get_item_name(tcx: &ty::ctxt, def: DefId) -> ast::Name {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_item_name(&cstore.intr, &cdata, def.node)\n }\n \n pub enum FoundAst<'ast> {\n     Found(&'ast InlinedItem),\n-    FoundParent(ast::DefId, &'ast InlinedItem),\n+    FoundParent(DefId, &'ast InlinedItem),\n     NotFound,\n }\n \n // Finds the AST for this item in the crate metadata, if any.  If the item was\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n-pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId,\n+pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId,\n                                 decode_inlined_item: decoder::DecodeInlinedItem)\n                                 -> FoundAst<'tcx> {\n     let cstore = &tcx.sess.cstore;\n@@ -120,13 +121,13 @@ pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId,\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n+pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: DefId)\n                       -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(impl_def_id.krate);\n     decoder::get_impl_items(&*cdata, impl_def_id.node)\n }\n \n-pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                     -> ty::ImplOrTraitItem<'tcx> {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n     decoder::get_impl_or_trait_item(tcx.sess.cstore.intr.clone(),\n@@ -135,114 +136,114 @@ pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n                                     tcx)\n }\n \n-pub fn get_trait_name(cstore: &cstore::CStore, def: ast::DefId) -> ast::Name {\n+pub fn get_trait_name(cstore: &cstore::CStore, def: DefId) -> ast::Name {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_name(cstore.intr.clone(),\n                             &*cdata,\n                             def.node)\n }\n \n-pub fn is_static_method(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n+pub fn is_static_method(cstore: &cstore::CStore, def: DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::is_static_method(&*cdata, def.node)\n }\n \n-pub fn get_trait_item_def_ids(cstore: &cstore::CStore, def: ast::DefId)\n+pub fn get_trait_item_def_ids(cstore: &cstore::CStore, def: DefId)\n                               -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_item_def_ids(&*cdata, def.node)\n }\n \n pub fn get_item_variances(cstore: &cstore::CStore,\n-                          def: ast::DefId) -> ty::ItemVariances {\n+                          def: DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_item_variances(&*cdata, def.node)\n }\n \n pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                        def: ast::DefId)\n+                                        def: DefId)\n                                         -> Vec<Rc<ty::Method<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n-pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                    -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n-pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n+pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: DefId)\n                           -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type_name_if_impl(&*cdata, def.node)\n }\n \n pub fn get_methods_if_impl(cstore: &cstore::CStore,\n-                                  def: ast::DefId)\n+                                  def: DefId)\n                                -> Option<Vec<MethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n-                      def_id: ast::DefId)\n+                      def_id: DefId)\n                       -> Vec<ast::Attribute> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node)\n }\n \n-pub fn get_struct_field_names(cstore: &cstore::CStore, def: ast::DefId) -> Vec<ast::Name> {\n+pub fn get_struct_field_names(cstore: &cstore::CStore, def: DefId) -> Vec<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_field_names(&cstore.intr, &*cdata, def.node)\n }\n \n-pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: ast::DefId) -> HashMap<ast::NodeId,\n+pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId) -> HashMap<ast::NodeId,\n         Vec<ast::Attribute>> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_field_attrs(&*cdata)\n }\n \n pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      def: ast::DefId)\n+                      def: DefId)\n                       -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(&*cdata, def.node, tcx)\n }\n \n-pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDef<'tcx> {\n+pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n-pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::AdtDefMaster<'tcx> {\n+pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_adt_def(&cstore.intr, &*cdata, def.node, tcx)\n }\n \n-pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                             -> ty::GenericPredicates<'tcx>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_predicates(&*cdata, def.node, tcx)\n }\n \n-pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_super_predicates(&*cdata, def.node, tcx)\n }\n \n-pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n-                            def: ast::DefId) -> ty::TypeScheme<'tcx> {\n+pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: DefId,\n+                            def: DefId) -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n@@ -267,7 +268,7 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n }\n \n pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                               def: ast::DefId)\n+                               def: DefId)\n                                -> Option<ast::ImplPolarity>\n {\n     let cstore = &tcx.sess.cstore;\n@@ -276,7 +277,7 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n pub fn get_custom_coerce_unsized_kind<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                            def: ast::DefId)\n+                                            def: DefId)\n                                             -> Option<ty::CustomCoerceUnsized> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n@@ -286,7 +287,7 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(tcx: &ty::ctxt<'tcx>,\n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            def: ast::DefId)\n+                            def: DefId)\n                             -> Option<ty::TraitRef<'tcx>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n@@ -300,18 +301,18 @@ pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n }\n \n pub fn each_inherent_implementation_for_type<F>(cstore: &cstore::CStore,\n-                                                def_id: ast::DefId,\n+                                                def_id: DefId,\n                                                 callback: F) where\n-    F: FnMut(ast::DefId),\n+    F: FnMut(DefId),\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_inherent_implementation_for_type(&*cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n-                                        def_id: ast::DefId,\n+                                        def_id: DefId,\n                                         mut callback: F) where\n-    F: FnMut(ast::DefId),\n+    F: FnMut(DefId),\n {\n     cstore.iter_crate_data(|_, cdata| {\n         decoder::each_implementation_for_trait(cdata, def_id, &mut callback)\n@@ -322,16 +323,16 @@ pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n /// default method or an implementation of a trait method), returns the ID of\n /// the trait that the method belongs to. Otherwise, returns `None`.\n pub fn get_trait_of_item(cstore: &cstore::CStore,\n-                         def_id: ast::DefId,\n+                         def_id: DefId,\n                          tcx: &ty::ctxt)\n-                         -> Option<ast::DefId> {\n+                         -> Option<DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_trait_of_item(&*cdata, def_id.node, tcx)\n }\n \n pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n-                                           def_id: ast::DefId)\n-    -> Option<ast::DefId>\n+                                           def_id: DefId)\n+    -> Option<DefId>\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.node)\n@@ -352,37 +353,37 @@ pub fn get_missing_lang_items(cstore: &cstore::CStore, cnum: ast::CrateNum)\n     decoder::get_missing_lang_items(&*cdata)\n }\n \n-pub fn get_method_arg_names(cstore: &cstore::CStore, did: ast::DefId)\n+pub fn get_method_arg_names(cstore: &cstore::CStore, did: DefId)\n     -> Vec<String>\n {\n     let cdata = cstore.get_crate_data(did.krate);\n     decoder::get_method_arg_names(&*cdata, did.node)\n }\n \n pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n-    -> Vec<ast::DefId>\n+    -> Vec<DefId>\n {\n     let cdata = cstore.get_crate_data(cnum);\n     decoder::get_reachable_ids(&*cdata)\n }\n \n-pub fn is_typedef(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n+pub fn is_typedef(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n     decoder::is_typedef(&*cdata, did.node)\n }\n \n-pub fn is_const_fn(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n+pub fn is_const_fn(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n     decoder::is_const_fn(&*cdata, did.node)\n }\n \n-pub fn is_impl(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n+pub fn is_impl(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n     decoder::is_impl(&*cdata, did.node)\n }\n \n pub fn get_stability(cstore: &cstore::CStore,\n-                     def: ast::DefId)\n+                     def: DefId)\n                      -> Option<attr::Stability> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_stability(&*cdata, def.node)\n@@ -392,23 +393,23 @@ pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n     cstore.get_crate_data(krate).staged_api\n }\n \n-pub fn get_repr_attrs(cstore: &cstore::CStore, def: ast::DefId)\n+pub fn get_repr_attrs(cstore: &cstore::CStore, def: DefId)\n                       -> Vec<attr::ReprAttr> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_repr_attrs(&*cdata, def.node)\n }\n \n-pub fn is_defaulted_trait(cstore: &cstore::CStore, trait_def_id: ast::DefId) -> bool {\n+pub fn is_defaulted_trait(cstore: &cstore::CStore, trait_def_id: DefId) -> bool {\n     let cdata = cstore.get_crate_data(trait_def_id.krate);\n     decoder::is_defaulted_trait(&*cdata, trait_def_id.node)\n }\n \n-pub fn is_default_impl(cstore: &cstore::CStore, impl_did: ast::DefId) -> bool {\n+pub fn is_default_impl(cstore: &cstore::CStore, impl_did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(impl_did.krate);\n     decoder::is_default_impl(&*cdata, impl_did.node)\n }\n \n-pub fn is_extern_fn(cstore: &cstore::CStore, did: ast::DefId,\n+pub fn is_extern_fn(cstore: &cstore::CStore, did: DefId,\n                     tcx: &ty::ctxt) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n     decoder::is_extern_fn(&*cdata, did.node, tcx)"}, {"sha": "bceccc622af32b68691290abf516c79c8e6fb53d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -26,6 +26,7 @@ use metadata::encoder::def_to_u64;\n use metadata::inline::InlinedItem;\n use metadata::tydecode::TyDecoder;\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n@@ -193,27 +194,27 @@ fn item_symbol(item: rbml::Doc) -> String {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n }\n \n-fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n+fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n     let id = reader::doc_as_u64(d);\n-    let def_id = ast::DefId { krate: (id >> 32) as u32, node: id as u32 };\n+    let def_id = DefId { krate: (id >> 32) as u32, node: id as u32 };\n     translate_def_id(cdata, def_id)\n }\n \n-fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<ast::DefId> {\n+fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<DefId> {\n     reader::tagged_docs(d, tag_items_data_parent_item).nth(0).map(|did| {\n         translated_def_id(cdata, did)\n     })\n }\n \n-fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n+fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> DefId {\n     translated_def_id(cdata, reader::get_doc(d, tag_items_data_parent_item))\n }\n \n-fn item_def_id(d: rbml::Doc, cdata: Cmd) -> ast::DefId {\n+fn item_def_id(d: rbml::Doc, cdata: Cmd) -> DefId {\n     translated_def_id(cdata, reader::get_doc(d, tag_def_id))\n }\n \n-fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n+fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<DefId> {\n     reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n         translated_def_id(cdata, doc)\n     })\n@@ -254,7 +255,7 @@ fn doc_method_fty<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>,\n         .parse_bare_fn_ty()\n }\n \n-pub fn item_type<'tcx>(_item_id: ast::DefId, item: rbml::Doc,\n+pub fn item_type<'tcx>(_item_id: DefId, item: rbml::Doc,\n                        tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     doc_type(item, tcx, cdata)\n }\n@@ -297,7 +298,7 @@ fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     }\n }\n \n-fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: ast::DefId) -> DefLike {\n+fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: DefId) -> DefLike {\n     let fam = item_family(item);\n     match fam {\n         Constant  => {\n@@ -445,7 +446,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     fn get_struct_variant<'tcx>(intr: &IdentInterner,\n                                 cdata: Cmd,\n                                 doc: rbml::Doc,\n-                                did: ast::DefId,\n+                                did: DefId,\n                                 tcx: &ty::ctxt<'tcx>) -> ty::VariantDefData<'tcx, 'tcx> {\n         ty::VariantDefData {\n             did: did,\n@@ -456,7 +457,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     }\n \n     let doc = lookup_item(item_id, cdata.data());\n-    let did = ast::DefId { krate: cdata.cnum, node: item_id };\n+    let did = DefId { krate: cdata.cnum, node: item_id };\n     let (kind, variants) = match item_family(doc) {\n         Enum => (ty::AdtKind::Enum,\n                  get_enum_variants(intr, cdata, doc, tcx)),\n@@ -529,7 +530,7 @@ pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n                       -> ty::TypeScheme<'tcx>\n {\n     let item_doc = lookup_item(id, cdata.data());\n-    let t = item_type(ast::DefId { krate: cdata.cnum, node: id }, item_doc, tcx,\n+    let t = item_type(DefId { krate: cdata.cnum, node: id }, item_doc, tcx,\n                       cdata);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n     ty::TypeScheme {\n@@ -606,7 +607,7 @@ pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n #[derive(Copy, Clone, Debug)]\n pub enum DefLike {\n     DlDef(def::Def),\n-    DlImpl(ast::DefId),\n+    DlImpl(DefId),\n     DlField\n }\n \n@@ -1063,7 +1064,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n /// the actual type definition, otherwise, return None\n pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n                                            node_id: ast::NodeId)\n-    -> Option<ast::DefId>\n+    -> Option<DefId>\n {\n     let item = lookup_item(node_id, cdata.data());\n     reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor).next().map(|_| {\n@@ -1258,14 +1259,14 @@ pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()>\n // external crates - if those types further refer to types in other crates\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n-pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n-    if did.krate == ast::LOCAL_CRATE {\n-        return ast::DefId { krate: cdata.cnum, node: did.node };\n+pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n+    if did.is_local() {\n+        return DefId { krate: cdata.cnum, node: did.node };\n     }\n \n     match cdata.cnum_map.borrow().get(&did.krate) {\n         Some(&n) => {\n-            ast::DefId {\n+            DefId {\n                 krate: n,\n                 node: did.node,\n             }\n@@ -1276,14 +1277,14 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n \n // Translate a DefId from the current compilation environment to a DefId\n // for an external crate.\n-fn reverse_translate_def_id(cdata: Cmd, did: ast::DefId) -> Option<ast::DefId> {\n+fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n     if did.krate == cdata.cnum {\n-        return Some(ast::DefId { krate: ast::LOCAL_CRATE, node: did.node });\n+        return Some(DefId { krate: LOCAL_CRATE, node: did.node });\n     }\n \n     for (&local, &global) in cdata.cnum_map.borrow().iter() {\n         if global == did.krate {\n-            return Some(ast::DefId { krate: local, node: did.node });\n+            return Some(DefId { krate: local, node: did.node });\n         }\n     }\n \n@@ -1293,7 +1294,7 @@ fn reverse_translate_def_id(cdata: Cmd, did: ast::DefId) -> Option<ast::DefId> {\n pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n                                                 id: ast::NodeId,\n                                                 mut callback: F)\n-    where F: FnMut(ast::DefId),\n+    where F: FnMut(DefId),\n {\n     let item_doc = lookup_item(id, cdata.data());\n     for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl) {\n@@ -1304,9 +1305,9 @@ pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n }\n \n pub fn each_implementation_for_trait<F>(cdata: Cmd,\n-                                        def_id: ast::DefId,\n+                                        def_id: DefId,\n                                         mut callback: F) where\n-    F: FnMut(ast::DefId),\n+    F: FnMut(DefId),\n {\n     if cdata.cnum == def_id.krate {\n         let item_doc = lookup_item(def_id.node, cdata.data());\n@@ -1332,7 +1333,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n }\n \n pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-                         -> Option<ast::DefId> {\n+                         -> Option<DefId> {\n     let item_doc = lookup_item(id, cdata.data());\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n@@ -1430,11 +1431,11 @@ pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n     }\n }\n \n-pub fn get_reachable_ids(cdata: Cmd) -> Vec<ast::DefId> {\n+pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n     let items = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                 tag_reachable_ids);\n     reader::tagged_docs(items, tag_reachable_id).map(|doc| {\n-        ast::DefId {\n+        DefId {\n             krate: cdata.cnum,\n             node: reader::doc_as_u32(doc),\n         }"}, {"sha": "3f59d70642d8d5c48bad13fde31325a3832d7752", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -22,6 +22,7 @@ use metadata::decoder;\n use metadata::tyencode;\n use metadata::inline::InlinedItemRef;\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::dependency_format::Linkage;\n use middle::stability;\n use middle::ty::{self, Ty};\n@@ -34,9 +35,7 @@ use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ast::{self, DefId, NodeId};\n-use syntax::ast_util::*;\n-use syntax::ast_util;\n+use syntax::ast::{self, NodeId};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n@@ -123,7 +122,7 @@ pub fn def_to_string(did: DefId) -> String {\n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: NodeId) {\n-    let v = ecx.tcx.item_variances(ast_util::local_def(id));\n+    let v = ecx.tcx.item_variances(DefId::local(id));\n     rbml_w.start_tag(tag_item_variances);\n     v.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -134,8 +133,8 @@ fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              id: ast::NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n-                           &ecx.tcx.lookup_item_type(local_def(id)),\n-                           &ecx.tcx.lookup_predicates(local_def(id)));\n+                           &ecx.tcx.lookup_item_type(DefId::local(id)),\n+                           &ecx.tcx.lookup_predicates(DefId::local(id)));\n }\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n@@ -282,10 +281,10 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n-    let def = ecx.tcx.lookup_adt_def(local_def(id));\n+    let def = ecx.tcx.lookup_adt_def(DefId::local(id));\n     for variant in &def.variants {\n         let vid = variant.did;\n-        assert!(is_local(vid));\n+        assert!(vid.is_local());\n         index.push(entry {\n             val: vid.node as i64,\n             pos: rbml_w.mark_stable_position(),\n@@ -297,7 +296,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             ty::VariantKind::Dict => 'V'\n         });\n         encode_name(rbml_w, variant.name);\n-        encode_parent_item(rbml_w, local_def(id));\n+        encode_parent_item(rbml_w, DefId::local(id));\n         encode_visibility(rbml_w, vis);\n \n         let attrs = ecx.tcx.get_attrs(vid);\n@@ -504,19 +503,19 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        name: ast::Name,\n                        vis: ast::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, local_def(id));\n+    encode_def_id(rbml_w, DefId::local(id));\n     encode_family(rbml_w, 'm');\n     encode_name(rbml_w, name);\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n     for item in &md.items {\n         rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(local_def(item.id)));\n+                             def_to_u64(DefId::local(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(local_def(auxiliary_node_id)));\n+                                 def_to_u64(DefId::local(auxiliary_node_id)));\n             true\n         });\n \n@@ -526,14 +525,14 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    ident,\n                    did, ecx.tcx.map.node_to_string(did));\n \n-            rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(local_def(did)));\n+            rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(DefId::local(did)));\n         }\n     }\n \n     encode_path(rbml_w, path.clone());\n     encode_visibility(rbml_w, vis);\n \n-    let stab = stability::lookup(ecx.tcx, ast_util::local_def(id));\n+    let stab = stability::lookup(ecx.tcx, DefId::local(id));\n     encode_stability(rbml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n@@ -644,7 +643,7 @@ fn encode_info_for_struct<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_struct_field_family(rbml_w, field.vis);\n         encode_name(rbml_w, nm);\n         encode_bounds_and_type_for_item(rbml_w, ecx, id);\n-        encode_def_id(rbml_w, local_def(id));\n+        encode_def_id(rbml_w, DefId::local(id));\n \n         let stab = stability::lookup(ecx.tcx, field.did);\n         encode_stability(rbml_w, stab);\n@@ -666,18 +665,18 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     });\n \n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, local_def(ctor_id));\n+    encode_def_id(rbml_w, DefId::local(ctor_id));\n     encode_family(rbml_w, 'o');\n     encode_bounds_and_type_for_item(rbml_w, ecx, ctor_id);\n     encode_name(rbml_w, name);\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n-    encode_parent_item(rbml_w, local_def(struct_id));\n+    encode_parent_item(rbml_w, DefId::local(struct_id));\n \n     if ecx.item_symbols.borrow().contains_key(&ctor_id) {\n         encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n-    let stab = stability::lookup(ecx.tcx, ast_util::local_def(ctor_id));\n+    let stab = stability::lookup(ecx.tcx, DefId::local(ctor_id));\n     encode_stability(rbml_w, stab);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n@@ -810,7 +809,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n     encode_family(rbml_w, 'C');\n     encode_provided_source(rbml_w, associated_const.default);\n \n-    encode_parent_item(rbml_w, local_def(parent_id));\n+    encode_parent_item(rbml_w, DefId::local(parent_id));\n     encode_item_sort(rbml_w, 'C');\n \n     encode_bounds_and_type_for_item(rbml_w, ecx, associated_const.def_id.local_id());\n@@ -823,7 +822,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(local_def(parent_id), ii));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(DefId::local(parent_id), ii));\n     }\n \n     rbml_w.end_tag();\n@@ -842,7 +841,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_method_ty_fields(ecx, rbml_w, m);\n-    encode_parent_item(rbml_w, local_def(parent_id));\n+    encode_parent_item(rbml_w, DefId::local(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n     let stab = stability::lookup(ecx.tcx, m.def_id);\n@@ -861,7 +860,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n             if needs_inline || sig.constness == ast::Constness::Const {\n-                encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(local_def(parent_id),\n+                encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(DefId::local(parent_id),\n                                                                impl_item));\n             }\n             encode_constness(rbml_w, sig.constness);\n@@ -891,7 +890,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_name(rbml_w, associated_type.name);\n     encode_visibility(rbml_w, associated_type.vis);\n     encode_family(rbml_w, 'y');\n-    encode_parent_item(rbml_w, local_def(parent_id));\n+    encode_parent_item(rbml_w, DefId::local(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n     let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n@@ -975,7 +974,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n-    assert!(ast_util::is_local(trait_def_id));\n+    assert!(trait_def_id.is_local());\n     let def = ecx.tcx.lookup_trait_def(trait_def_id);\n \n     def.for_each_impl(ecx.tcx, |impl_def_id| {\n@@ -1012,8 +1011,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n-    let def_id = local_def(item.id);\n-    let stab = stability::lookup(tcx, ast_util::local_def(item.id));\n+    let def_id = DefId::local(item.id);\n+    let stab = stability::lookup(tcx, DefId::local(item.id));\n \n     match item.node {\n       ast::ItemStatic(_, m, _) => {\n@@ -1093,7 +1092,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(local_def(foreign_item.id)));\n+                                 def_to_u64(DefId::local(foreign_item.id)));\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1123,7 +1122,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n         for v in &enum_definition.variants {\n-            encode_variant_id(rbml_w, local_def(v.node.id));\n+            encode_variant_id(rbml_w, DefId::local(v.node.id));\n         }\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_path(rbml_w, path);\n@@ -1199,7 +1198,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_name(rbml_w, item.ident.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = tcx.impl_trait_ref(local_def(item.id)).unwrap();\n+          let trait_ref = tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n@@ -1219,7 +1218,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n \n-        match tcx.custom_coerce_unsized_kinds.borrow().get(&local_def(item.id)) {\n+        match tcx.custom_coerce_unsized_kinds.borrow().get(&DefId::local(item.id)) {\n             Some(&kind) => {\n                 rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n                 kind.encode(rbml_w);\n@@ -1253,7 +1252,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(trait_ref) = tcx.impl_trait_ref(local_def(item.id)) {\n+        if let Some(trait_ref) = tcx.impl_trait_ref(DefId::local(item.id)) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1361,7 +1360,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Now output the trait item info for each trait item.\n         let r = tcx.trait_item_def_ids(def_id);\n         for (i, &item_def_id) in r.iter().enumerate() {\n-            assert_eq!(item_def_id.def_id().krate, ast::LOCAL_CRATE);\n+            assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n             index.push(entry {\n                 val: item_def_id.def_id().node as i64,\n@@ -1494,7 +1493,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     });\n \n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, local_def(nitem.id));\n+    encode_def_id(rbml_w, DefId::local(nitem.id));\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n       ast::ForeignItemFn(ref fndecl, _) => {\n@@ -1505,7 +1504,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, ast_util::local_def(nitem.id));\n+        let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_method_argument_names(rbml_w, &*fndecl);\n@@ -1518,7 +1517,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, ast_util::local_def(nitem.id));\n+        let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n@@ -1782,7 +1781,7 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n     for (i, &def_id) in ecx.tcx.lang_items.items() {\n         if let Some(id) = def_id {\n-            if id.krate == ast::LOCAL_CRATE {\n+            if id.is_local() {\n                 rbml_w.start_tag(tag_lang_items_item);\n                 rbml_w.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n                 rbml_w.wr_tagged_u32(tag_lang_items_item_node_id, id.node as u32);\n@@ -1900,9 +1899,9 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n             // Load eagerly if this is an implementation of the Drop trait\n             // or if the trait is not defined in this crate.\n             if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n-                    def_id.krate != ast::LOCAL_CRATE {\n+                    def_id.krate != LOCAL_CRATE {\n                 self.rbml_w.start_tag(tag_impls_impl);\n-                encode_def_id(self.rbml_w, local_def(item.id));\n+                encode_def_id(self.rbml_w, DefId::local(item.id));\n                 self.rbml_w.wr_tagged_u64(tag_impls_impl_trait_def_id, def_to_u64(def_id));\n                 self.rbml_w.end_tag();\n             }\n@@ -1944,11 +1943,11 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n         rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(local_def(item.id)));\n+                             def_to_u64(DefId::local(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(local_def(auxiliary_node_id)));\n+                                 def_to_u64(DefId::local(auxiliary_node_id)));\n             true\n         });\n     }"}, {"sha": "b311784def8b6e7fd4d335f19e907f07e34d0beb", "filename": "src/librustc/metadata/inline.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Finline.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::def_id::DefId;\n use syntax::ast;\n use syntax::ast_util::{IdRange, IdRangeComputingVisitor,\n                        IdVisitor, IdVisitingOperation};\n@@ -21,16 +22,16 @@ use self::InlinedItem::*;\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum InlinedItem {\n     Item(P<ast::Item>),\n-    TraitItem(ast::DefId /* impl id */, P<ast::TraitItem>),\n-    ImplItem(ast::DefId /* impl id */, P<ast::ImplItem>),\n+    TraitItem(DefId /* impl id */, P<ast::TraitItem>),\n+    ImplItem(DefId /* impl id */, P<ast::ImplItem>),\n     Foreign(P<ast::ForeignItem>),\n }\n \n /// A borrowed version of `ast::InlinedItem`.\n pub enum InlinedItemRef<'a> {\n     Item(&'a ast::Item),\n-    TraitItem(ast::DefId, &'a ast::TraitItem),\n-    ImplItem(ast::DefId, &'a ast::ImplItem),\n+    TraitItem(DefId, &'a ast::TraitItem),\n+    ImplItem(DefId, &'a ast::ImplItem),\n     Foreign(&'a ast::ForeignItem)\n }\n "}, {"sha": "59f938d9489a7f76c156bfd1e5e434700c51691e", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -18,6 +18,7 @@\n \n pub use self::DefIdSource::*;\n \n+use middle::def_id::DefId;\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n@@ -58,7 +59,7 @@ pub enum DefIdSource {\n     ClosureSource\n }\n \n-pub type DefIdConvert<'a> = &'a mut FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n+pub type DefIdConvert<'a> = &'a mut FnMut(DefIdSource, DefId) -> DefId;\n \n pub struct TyDecoder<'a, 'tcx: 'a> {\n     data: &'a [u8],\n@@ -473,7 +474,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::TypeAndMut { ty: self.parse_ty(), mutbl: m }\n     }\n \n-    fn parse_def(&mut self, source: DefIdSource) -> ast::DefId {\n+    fn parse_def(&mut self, source: DefIdSource) -> DefId {\n         let def_id = parse_defid(self.scan(|c| c == '|'));\n         return (self.conv_def_id)(source, def_id);\n     }\n@@ -680,7 +681,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n }\n \n // Rust metadata parsing\n-fn parse_defid(buf: &[u8]) -> ast::DefId {\n+fn parse_defid(buf: &[u8]) -> DefId {\n     let mut colon_idx = 0;\n     let len = buf.len();\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1; }\n@@ -706,7 +707,7 @@ fn parse_defid(buf: &[u8]) -> ast::DefId {\n         None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n                        def_part)\n     };\n-    ast::DefId { krate: crate_num, node: def_num }\n+    DefId { krate: crate_num, node: def_num }\n }\n \n fn parse_unsafety(c: char) -> ast::Unsafety {"}, {"sha": "65bb04309d07500ee9a1f4323d1e0f6cd9f51e52", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -16,6 +16,7 @@\n use std::cell::RefCell;\n use std::io::prelude::*;\n \n+use middle::def_id::DefId;\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n@@ -34,7 +35,7 @@ macro_rules! mywrite { ($w:expr, $($arg:tt)*) => ({ write!($w.writer, $($arg)*);\n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n     // Def -> str Callback:\n-    pub ds: fn(ast::DefId) -> String,\n+    pub ds: fn(DefId) -> String,\n     // The type context.\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub abbrevs: &'a abbrev_map<'tcx>"}, {"sha": "d7fe8e95ae7b37f57c18e31e0232f6c320a10a72", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -26,6 +26,7 @@ use metadata::tyencode;\n use middle::cast;\n use middle::check_const::ConstQualif;\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::privacy::{AllPublic, LastMod};\n use middle::region;\n use middle::subst;\n@@ -68,7 +69,7 @@ trait tr {\n }\n \n trait tr_intern {\n-    fn tr_intern(&self, dcx: &DecodeContext) -> ast::DefId;\n+    fn tr_intern(&self, dcx: &DecodeContext) -> DefId;\n }\n \n // ______________________________________________________________________\n@@ -111,7 +112,7 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n             self.tr_id(id)\n         }\n     }\n-    fn new_def_id(&self, def_id: ast::DefId) -> ast::DefId {\n+    fn new_def_id(&self, def_id: DefId) -> DefId {\n         self.tr_def_id(def_id)\n     }\n     fn new_span(&self, span: Span) -> Span {\n@@ -212,7 +213,7 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     /// However, there are a *few* cases where def-ids are used but we know that the thing being\n     /// referenced is in fact *internal* to the item being inlined.  In those cases, you should use\n     /// `tr_intern_def_id()` below.\n-    pub fn tr_def_id(&self, did: ast::DefId) -> ast::DefId {\n+    pub fn tr_def_id(&self, did: DefId) -> DefId {\n \n         decoder::translate_def_id(self.cdata, did)\n     }\n@@ -221,9 +222,9 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     /// known to refer to some part of the item currently being\n     /// inlined.  In that case, we want to convert the def-id to\n     /// refer to the current crate and to the new, inlined node-id.\n-    pub fn tr_intern_def_id(&self, did: ast::DefId) -> ast::DefId {\n-        assert_eq!(did.krate, ast::LOCAL_CRATE);\n-        ast::DefId { krate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n+    pub fn tr_intern_def_id(&self, did: DefId) -> DefId {\n+        assert_eq!(did.krate, LOCAL_CRATE);\n+        DefId { krate: LOCAL_CRATE, node: self.tr_id(did.node) }\n     }\n \n     /// Translates a `Span` from an extern crate to the corresponding `Span`\n@@ -284,20 +285,20 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     }\n }\n \n-impl tr_intern for ast::DefId {\n-    fn tr_intern(&self, dcx: &DecodeContext) -> ast::DefId {\n+impl tr_intern for DefId {\n+    fn tr_intern(&self, dcx: &DecodeContext) -> DefId {\n         dcx.tr_intern_def_id(*self)\n     }\n }\n \n-impl tr for ast::DefId {\n-    fn tr(&self, dcx: &DecodeContext) -> ast::DefId {\n+impl tr for DefId {\n+    fn tr(&self, dcx: &DecodeContext) -> DefId {\n         dcx.tr_def_id(*self)\n     }\n }\n \n-impl tr for Option<ast::DefId> {\n-    fn tr(&self, dcx: &DecodeContext) -> Option<ast::DefId> {\n+impl tr for Option<DefId> {\n+    fn tr(&self, dcx: &DecodeContext) -> Option<DefId> {\n         self.map(|d| dcx.tr_def_id(d))\n     }\n }\n@@ -309,35 +310,35 @@ impl tr for Span {\n }\n \n trait def_id_encoder_helpers {\n-    fn emit_def_id(&mut self, did: ast::DefId);\n+    fn emit_def_id(&mut self, did: DefId);\n }\n \n impl<S:serialize::Encoder> def_id_encoder_helpers for S\n     where <S as serialize::serialize::Encoder>::Error: Debug\n {\n-    fn emit_def_id(&mut self, did: ast::DefId) {\n+    fn emit_def_id(&mut self, did: DefId) {\n         did.encode(self).unwrap()\n     }\n }\n \n trait def_id_decoder_helpers {\n-    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId;\n+    fn read_def_id(&mut self, dcx: &DecodeContext) -> DefId;\n     fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata) -> ast::DefId;\n+                         cdata: &cstore::crate_metadata) -> DefId;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D\n     where <D as serialize::serialize::Decoder>::Error: Debug\n {\n-    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n-        let did: ast::DefId = Decodable::decode(self).unwrap();\n+    fn read_def_id(&mut self, dcx: &DecodeContext) -> DefId {\n+        let did: DefId = Decodable::decode(self).unwrap();\n         did.tr(dcx)\n     }\n \n     fn read_def_id_nodcx(&mut self,\n                          cdata: &cstore::crate_metadata)\n-                         -> ast::DefId {\n-        let did: ast::DefId = Decodable::decode(self).unwrap();\n+                         -> DefId {\n+        let did: DefId = Decodable::decode(self).unwrap();\n         decoder::translate_def_id(cdata, did)\n     }\n }\n@@ -987,7 +988,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n+    let lid = DefId { krate: LOCAL_CRATE, node: id };\n     if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n@@ -1033,14 +1034,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&ast_util::local_def(id)) {\n+    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&DefId::local(id)) {\n         rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_closure_type(ecx, closure_type);\n         })\n     }\n \n-    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&ast_util::local_def(id)) {\n+    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&DefId::local(id)) {\n         rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n             encode_closure_kind(rbml_w, *closure_kind)\n@@ -1110,8 +1111,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n                       source: DefIdSource,\n-                      did: ast::DefId)\n-                      -> ast::DefId;\n+                      did: DefId)\n+                      -> DefId;\n \n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n@@ -1384,8 +1385,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n                       source: tydecode::DefIdSource,\n-                      did: ast::DefId)\n-                      -> ast::DefId {\n+                      did: DefId)\n+                      -> DefId {\n         let r = match source {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n             ClosureSource => dcx.tr_intern_def_id(did)\n@@ -1457,7 +1458,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);\n-                        let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n+                        let lid = DefId { krate: LOCAL_CRATE, node: id };\n                         dcx.tcx.register_item_type(lid, type_scheme);\n                     }\n                     c::tag_table_param_defs => {\n@@ -1479,13 +1480,13 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     c::tag_table_closure_tys => {\n                         let closure_ty =\n                             val_dsr.read_closure_ty(dcx);\n-                        dcx.tcx.tables.borrow_mut().closure_tys.insert(ast_util::local_def(id),\n+                        dcx.tcx.tables.borrow_mut().closure_tys.insert(DefId::local(id),\n                                                                 closure_ty);\n                     }\n                     c::tag_table_closure_kinds => {\n                         let closure_kind =\n                             val_dsr.read_closure_kind(dcx);\n-                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(ast_util::local_def(id),\n+                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(DefId::local(id),\n                                                                   closure_kind);\n                     }\n                     c::tag_table_cast_kinds => {"}, {"sha": "1ed43a570410c4366db76e60018f60971c7ba6e7", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -28,6 +28,7 @@ use middle::cast::{CastKind};\n use middle::const_eval;\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::def;\n+use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::mem_categorization as mc;\n@@ -204,7 +205,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     /// Returns true if the call is to a const fn or method.\n     fn handle_const_fn_call(&mut self,\n                             expr: &ast::Expr,\n-                            def_id: ast::DefId,\n+                            def_id: DefId,\n                             ret_ty: Ty<'tcx>)\n                             -> bool {\n         if let Some(fn_like) = const_eval::lookup_const_fn_by_id(self.tcx, def_id) {"}, {"sha": "abc4d786f867f9f0a35448c590e299ea237df93b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -17,6 +17,7 @@ use middle::const_eval::{eval_const_expr, eval_const_expr_partial};\n use middle::const_eval::{const_expr_to_pat, lookup_const_by_id};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::def::*;\n+use middle::def_id::{DefId};\n use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n use middle::expr_use_visitor::WriteAndRead;\n@@ -111,7 +112,7 @@ pub enum Constructor {\n     /// e.g. struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n-    Variant(ast::DefId),\n+    Variant(DefId),\n     /// Literal values.\n     ConstantValue(ConstVal),\n     /// Ranges of literal values (2..5)."}, {"sha": "41a9fea3e9ae85891c7255696527afa29d60fc5e", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -16,7 +16,7 @@ use session::Session;\n use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefVariant, DefMap};\n use util::nodemap::NodeMap;\n \n-use syntax::{ast, ast_util};\n+use syntax::{ast};\n use syntax::codemap::Span;\n use syntax::feature_gate::emit_feature_err;\n use syntax::visit::Visitor;\n@@ -239,8 +239,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n                     Some(DefAssociatedConst(def_id)) |\n-                    Some(DefConst(def_id))\n-                           if ast_util::is_local(def_id) => {\n+                    Some(DefConst(def_id)) if def_id.is_local() => {\n                         match self.ast_map.get(def_id.node) {\n                           ast_map::NodeItem(item) =>\n                             self.visit_item(item),\n@@ -261,8 +260,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(DefVariant(enum_id, variant_id, false))\n-                           if ast_util::is_local(enum_id) => {\n+                    Some(DefVariant(enum_id, variant_id, false)) if enum_id.is_local() => {\n                         if let ast::ItemEnum(ref enum_def, ref generics) =\n                                self.ast_map.expect_item(enum_id.local_id()).node {\n                             self.populate_enum_discriminants(enum_def);"}, {"sha": "98a1e07adfb7431e4d9f4341998aadea4fd6f098", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -19,13 +19,13 @@ use ast_map::blocks::FnLikeNode;\n use metadata::csearch;\n use metadata::inline::InlinedItem;\n use middle::{astencode, def, infer, subst, traits};\n+use middle::def_id::{DefId};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n \n use syntax::ast::{self, Expr};\n-use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -53,8 +53,8 @@ fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n }\n \n fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n-                            enum_def: ast::DefId,\n-                            variant_def: ast::DefId)\n+                            enum_def: DefId,\n+                            variant_def: DefId)\n                             -> Option<&'a Expr> {\n     fn variant_expr<'a>(variants: &'a [P<ast::Variant>], id: ast::NodeId)\n                         -> Option<&'a Expr> {\n@@ -66,7 +66,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         None\n     }\n \n-    if ast_util::is_local(enum_def) {\n+    if enum_def.is_local() {\n         match tcx.map.find(enum_def.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n@@ -105,10 +105,10 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n }\n \n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n-                                        def_id: ast::DefId,\n+                                        def_id: DefId,\n                                         maybe_ref_id: Option<ast::NodeId>)\n                                         -> Option<&'tcx Expr> {\n-    if ast_util::is_local(def_id) {\n+    if def_id.is_local() {\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n@@ -203,7 +203,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     }\n }\n \n-fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: ast::DefId)\n+fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: DefId)\n                                        -> Option<ast::NodeId> {\n     match tcx.extern_const_fns.borrow().get(&def_id) {\n         Some(&ast::DUMMY_NODE_ID) => return None,\n@@ -227,10 +227,10 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: ast::DefId)\n     fn_id\n }\n \n-pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: ast::DefId)\n+pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId)\n                                    -> Option<FnLikeNode<'tcx>>\n {\n-    let fn_id = if !ast_util::is_local(def_id) {\n+    let fn_id = if !def_id.is_local() {\n         if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n             fn_id\n         } else {\n@@ -916,7 +916,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n           let (const_expr, const_ty) = match opt_def {\n               Some(def::DefConst(def_id)) => {\n-                  if ast_util::is_local(def_id) {\n+                  if def_id.is_local() {\n                       match tcx.map.find(def_id.node) {\n                           Some(ast_map::NodeItem(it)) => match it.node {\n                               ast::ItemConst(ref ty, ref expr) => {\n@@ -931,7 +931,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   }\n               }\n               Some(def::DefAssociatedConst(def_id)) => {\n-                  if ast_util::is_local(def_id) {\n+                  if def_id.is_local() {\n                       match tcx.impl_or_trait_item(def_id).container() {\n                           ty::TraitContainer(trait_id) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n@@ -1062,7 +1062,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                                 ti: &'tcx ast::TraitItem,\n-                                                trait_id: ast::DefId,\n+                                                trait_id: DefId,\n                                                 rcvr_substs: subst::Substs<'tcx>)\n                                                 -> Option<&'tcx Expr>\n {"}, {"sha": "ca82427477bfe156889ef3f59d1c053c1ebe81c2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -14,21 +14,21 @@\n \n use ast_map;\n use middle::{def, pat_util, privacy, ty};\n+use middle::def_id::{DefId};\n use lint;\n use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n use syntax::{ast, codemap};\n-use syntax::ast_util::{local_def, is_local};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::visit::{self, Visitor};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n-    if !is_local(def_id) {\n+fn should_explore(tcx: &ty::ctxt, def_id: DefId) -> bool {\n+    if !def_id.is_local() {\n         return false;\n     }\n \n@@ -65,7 +65,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_def_id(&mut self, def_id: ast::DefId) {\n+    fn check_def_id(&mut self, def_id: DefId) {\n         if should_explore(self.tcx, def_id) {\n             self.worklist.push(def_id.node);\n         }\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         let impl_items = self.tcx.impl_items.borrow();\n-        match self.tcx.inherent_impls.borrow().get(&local_def(id)) {\n+        match self.tcx.inherent_impls.borrow().get(&DefId::local(id)) {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in impl_list.iter() {"}, {"sha": "ca08a97e811e3e800889f068ae5e4580032c97c4", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -10,47 +10,47 @@\n \n pub use self::Def::*;\n \n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n use util::nodemap::NodeMap;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n \n use std::cell::RefCell;\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n-    DefFn(ast::DefId, bool /* is_ctor */),\n-    DefSelfTy(Option<ast::DefId>,                    // trait id\n+    DefFn(DefId, bool /* is_ctor */),\n+    DefSelfTy(Option<DefId>,                    // trait id\n               Option<(ast::NodeId, ast::NodeId)>),   // (impl id, self type id)\n-    DefMod(ast::DefId),\n-    DefForeignMod(ast::DefId),\n-    DefStatic(ast::DefId, bool /* is_mutbl */),\n-    DefConst(ast::DefId),\n-    DefAssociatedConst(ast::DefId),\n+    DefMod(DefId),\n+    DefForeignMod(DefId),\n+    DefStatic(DefId, bool /* is_mutbl */),\n+    DefConst(DefId),\n+    DefAssociatedConst(DefId),\n     DefLocal(ast::NodeId),\n-    DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n-    DefTy(ast::DefId, bool /* is_enum */),\n-    DefAssociatedTy(ast::DefId /* trait */, ast::DefId),\n-    DefTrait(ast::DefId),\n+    DefVariant(DefId /* enum */, DefId /* variant */, bool /* is_structure */),\n+    DefTy(DefId, bool /* is_enum */),\n+    DefAssociatedTy(DefId /* trait */, DefId),\n+    DefTrait(DefId),\n     DefPrimTy(ast::PrimTy),\n-    DefTyParam(ParamSpace, u32, ast::DefId, ast::Name),\n-    DefUse(ast::DefId),\n+    DefTyParam(ParamSpace, u32, DefId, ast::Name),\n+    DefUse(DefId),\n     DefUpvar(ast::NodeId,  // id of closed over local\n              ast::NodeId), // expr node that creates the closure\n \n-    /// Note that if it's a tuple struct's definition, the node id of the ast::DefId\n+    /// Note that if it's a tuple struct's definition, the node id of the DefId\n     /// may either refer to the item definition's id or the StructDef.ctor_id.\n     ///\n     /// The cases that I have encountered so far are (this is not exhaustive):\n     /// - If it's a ty_path referring to some tuple struct, then DefMap maps\n     ///   it to a def whose id is the item definition's id.\n     /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n     ///   it to a def whose id is the StructDef.ctor_id.\n-    DefStruct(ast::DefId),\n+    DefStruct(DefId),\n     DefRegion(ast::NodeId),\n     DefLabel(ast::NodeId),\n-    DefMethod(ast::DefId),\n+    DefMethod(DefId),\n }\n \n /// The result of resolving a path.\n@@ -83,7 +83,7 @@ impl PathResolution {\n     }\n \n     /// Get the DefId, if fully resolved, otherwise panic.\n-    pub fn def_id(&self) -> ast::DefId {\n+    pub fn def_id(&self) -> DefId {\n         self.full_def().def_id()\n     }\n \n@@ -108,17 +108,17 @@ pub type ExportMap = NodeMap<Vec<Export>>;\n #[derive(Copy, Clone)]\n pub struct Export {\n     pub name: ast::Name,    // The name of the target.\n-    pub def_id: ast::DefId, // The definition of the target.\n+    pub def_id: DefId, // The definition of the target.\n }\n \n impl Def {\n     pub fn local_node_id(&self) -> ast::NodeId {\n         let def_id = self.def_id();\n-        assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+        assert_eq!(def_id.krate, LOCAL_CRATE);\n         def_id.node\n     }\n \n-    pub fn def_id(&self) -> ast::DefId {\n+    pub fn def_id(&self) -> DefId {\n         match *self {\n             DefFn(id, _) | DefMod(id) | DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n@@ -132,15 +132,15 @@ impl Def {\n             DefRegion(id) |\n             DefLabel(id)  |\n             DefSelfTy(_, Some((_, id))) => {\n-                local_def(id)\n+                DefId::local(id)\n             }\n \n             DefPrimTy(_) => panic!(\"attempted .def_id() on DefPrimTy\"),\n             DefSelfTy(..) => panic!(\"attempted .def_id() on invalid DefSelfTy\"),\n         }\n     }\n \n-    pub fn variant_def_ids(&self) -> Option<(ast::DefId, ast::DefId)> {\n+    pub fn variant_def_ids(&self) -> Option<(DefId, DefId)> {\n         match *self {\n             DefVariant(enum_id, var_id, _) => {\n                 Some((enum_id, var_id))"}, {"sha": "2966339f0a4fff4f105de0523545a3856c007448", "filename": "src/librustc/middle/def_id.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty;\n+use syntax::ast::{CrateNum, NodeId};\n+use std::fmt;\n+\n+#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n+           RustcDecodable, Hash, Copy)]\n+pub struct DefId {\n+    pub krate: CrateNum,\n+    pub node: NodeId,\n+}\n+\n+impl fmt::Debug for DefId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"DefId {{ krate: {}, node: {}\",\n+                    self.krate, self.node));\n+\n+        // Unfortunately, there seems to be no way to attempt to print\n+        // a path for a def-id, so I'll just make a best effort for now\n+        // and otherwise fallback to just printing the crate/node pair\n+        try!(ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                try!(write!(f, \" => {}\", tcx.item_path_str(*self)));\n+            }\n+            Ok(())\n+        }));\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+\n+impl DefId {\n+    pub fn local(id: NodeId) -> DefId {\n+        DefId { krate: LOCAL_CRATE, node: id }\n+    }\n+\n+    /// Read the node id, asserting that this def-id is krate-local.\n+    pub fn local_id(&self) -> NodeId {\n+        assert_eq!(self.krate, LOCAL_CRATE);\n+        self.node\n+    }\n+\n+    pub fn is_local(&self) -> bool {\n+        self.krate == LOCAL_CRATE\n+    }\n+}\n+\n+\n+/// Item definitions in the currently-compiled crate would have the CrateNum\n+/// LOCAL_CRATE in their DefId.\n+pub const LOCAL_CRATE: CrateNum = 0;\n+"}, {"sha": "30e8dfb293d1de4a95a2e091666c2825ad8a3248", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -21,6 +21,7 @@ use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n use middle::{def, region, pat_util};\n+use middle::def_id::{DefId};\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::ty;\n@@ -206,7 +207,7 @@ enum OverloadedCallType {\n }\n \n impl OverloadedCallType {\n-    fn from_trait_id(tcx: &ty::ctxt, trait_id: ast::DefId)\n+    fn from_trait_id(tcx: &ty::ctxt, trait_id: DefId)\n                      -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n             (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n@@ -224,7 +225,7 @@ impl OverloadedCallType {\n         tcx.sess.bug(\"overloaded call didn't map to known function trait\")\n     }\n \n-    fn from_method_id(tcx: &ty::ctxt, method_id: ast::DefId)\n+    fn from_method_id(tcx: &ty::ctxt, method_id: DefId)\n                       -> OverloadedCallType {\n         let method = tcx.impl_or_trait_item(method_id);\n         OverloadedCallType::from_trait_id(tcx, method.container().id())"}, {"sha": "77608f4012845d687c7054bc0fc4562202d83f8f", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::def_id::DefId;\n use middle::ty::{self, Ty};\n use syntax::ast;\n \n@@ -21,14 +22,14 @@ pub enum SimplifiedType {\n     IntSimplifiedType(ast::IntTy),\n     UintSimplifiedType(ast::UintTy),\n     FloatSimplifiedType(ast::FloatTy),\n-    EnumSimplifiedType(ast::DefId),\n+    EnumSimplifiedType(DefId),\n     StrSimplifiedType,\n     VecSimplifiedType,\n     PtrSimplifiedType,\n     TupleSimplifiedType(usize),\n-    TraitSimplifiedType(ast::DefId),\n-    StructSimplifiedType(ast::DefId),\n-    ClosureSimplifiedType(ast::DefId),\n+    TraitSimplifiedType(DefId),\n+    StructSimplifiedType(DefId),\n+    ClosureSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n }"}, {"sha": "b1a4e0270c2f9dd0da892d829eccd9d5b9c50d6f", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -10,6 +10,7 @@\n \n // #![warn(deprecated_mode)]\n \n+use middle::def_id::DefId;\n use middle::infer::{InferCtxt, GenericKind};\n use middle::subst::Substs;\n use middle::traits;\n@@ -28,7 +29,7 @@ use util::nodemap::FnvHashSet;\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n-    Predicate(ast::DefId, ty::Predicate<'tcx>),\n+    Predicate(DefId, ty::Predicate<'tcx>),\n }\n \n struct Implicator<'a, 'tcx: 'a> {\n@@ -265,7 +266,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n     fn accumulate_from_adt(&mut self,\n                            ty: Ty<'tcx>,\n-                           def_id: ast::DefId,\n+                           def_id: DefId,\n                            _generics: &ty::Generics<'tcx>,\n                            substs: &Substs<'tcx>)\n     {"}, {"sha": "4d558ed5663d8df7513d369dc2d9dd8284a59347", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -19,6 +19,7 @@ pub use middle::ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n pub use self::region_inference::{GenericKind, VerifyBound};\n \n+use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n@@ -1483,7 +1484,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn node_method_id(&self, method_call: ty::MethodCall)\n-                          -> Option<ast::DefId> {\n+                          -> Option<DefId> {\n         self.tables\n             .borrow()\n             .method_map\n@@ -1517,14 +1518,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn closure_kind(&self,\n-                        def_id: ast::DefId)\n+                        def_id: DefId)\n                         -> Option<ty::ClosureKind>\n     {\n         self.tables.borrow().closure_kinds.get(&def_id).cloned()\n     }\n \n     pub fn closure_type(&self,\n-                        def_id: ast::DefId,\n+                        def_id: DefId,\n                         substs: &ty::ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {"}, {"sha": "e4af098c2a42d7bce9fdb869243f996570afad6e", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -11,8 +11,8 @@\n pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n+use middle::def_id::{DefId};\n use middle::ty::{self, Ty};\n-use syntax::ast::DefId;\n use syntax::codemap::Span;\n \n use std::cmp::min;"}, {"sha": "29d140004f8aa6abb0b4a424b400a00ec25cb8a0", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n use middle::def::DefFn;\n+use middle::def_id::DefId;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n use middle::ty::{self, Ty, HasTypeFlags};\n \n use std::fmt;\n \n use syntax::abi::RustIntrinsic;\n-use syntax::ast::DefId;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit::Visitor;"}, {"sha": "d7f40c1f6fdfdb46d03a3a5742fc72c00ab67d8a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -23,12 +23,12 @@ pub use self::LangItem::*;\n \n use session::Session;\n use metadata::csearch::each_lang_item;\n+use middle::def_id::DefId;\n use middle::ty;\n use middle::weak_lang_items;\n use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n@@ -54,21 +54,21 @@ enum_from_u32! {\n }\n \n pub struct LanguageItems {\n-    pub items: Vec<Option<ast::DefId>>,\n+    pub items: Vec<Option<DefId>>,\n     pub missing: Vec<LangItem>,\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n-        fn foo(_: LangItem) -> Option<ast::DefId> { None }\n+        fn foo(_: LangItem) -> Option<DefId> { None }\n \n         LanguageItems {\n             items: vec!($(foo($variant)),*),\n             missing: Vec::new(),\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<slice::Iter<'a, Option<ast::DefId>>> {\n+    pub fn items<'a>(&'a self) -> Enumerate<slice::Iter<'a, Option<DefId>>> {\n         self.items.iter().enumerate()\n     }\n \n@@ -80,7 +80,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn require(&self, it: LangItem) -> Result<ast::DefId, String> {\n+    pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n         match self.items[it as usize] {\n             Some(id) => Ok(id),\n             None => {\n@@ -90,12 +90,12 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn require_owned_box(&self) -> Result<ast::DefId, String> {\n+    pub fn require_owned_box(&self) -> Result<DefId, String> {\n         self.require(OwnedBoxLangItem)\n     }\n \n     pub fn from_builtin_kind(&self, bound: ty::BuiltinBound)\n-                             -> Result<ast::DefId, String>\n+                             -> Result<DefId, String>\n     {\n         match bound {\n             ty::BoundSend => self.require(SendTraitLangItem),\n@@ -105,7 +105,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn to_builtin_kind(&self, id: ast::DefId) -> Option<ty::BuiltinBound> {\n+    pub fn to_builtin_kind(&self, id: DefId) -> Option<ty::BuiltinBound> {\n         if Some(id) == self.send_trait() {\n             Some(ty::BoundSend)\n         } else if Some(id) == self.sized_trait() {\n@@ -119,7 +119,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn fn_trait_kind(&self, id: ast::DefId) -> Option<ty::ClosureKind> {\n+    pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n         let def_id_kinds = [\n             (self.fn_trait(), ty::FnClosureKind),\n             (self.fn_mut_trait(), ty::FnMutClosureKind),\n@@ -137,7 +137,7 @@ impl LanguageItems {\n \n     $(\n         #[allow(dead_code)]\n-        pub fn $method(&self) -> Option<ast::DefId> {\n+        pub fn $method(&self) -> Option<DefId> {\n             self.items[$variant as usize]\n         }\n     )*\n@@ -157,7 +157,7 @@ impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n             let item_index = self.item_refs.get(&value[..]).cloned();\n \n             if let Some(item_index) = item_index {\n-                self.collect_item(item_index, local_def(item.id), item.span)\n+                self.collect_item(item_index, DefId::local(item.id), item.span)\n             }\n         }\n \n@@ -179,7 +179,7 @@ impl<'a> LanguageItemCollector<'a> {\n     }\n \n     pub fn collect_item(&mut self, item_index: usize,\n-                        item_def_id: ast::DefId, span: Span) {\n+                        item_def_id: DefId, span: Span) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n@@ -203,7 +203,7 @@ impl<'a> LanguageItemCollector<'a> {\n         let crate_store = &self.session.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_lang_item(crate_store, crate_number, |node_id, item_index| {\n-                let def_id = ast::DefId { krate: crate_number, node: node_id };\n+                let def_id = DefId { krate: crate_number, node: node_id };\n                 self.collect_item(item_index, def_id, DUMMY_SP);\n                 true\n             });"}, {"sha": "0cab4b610be720ec14659f19c3bfa1846d50862f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -73,6 +73,7 @@ pub use self::categorization::*;\n use self::Aliasability::*;\n \n use ast_map;\n+use middle::def_id::DefId;\n use middle::infer;\n use middle::check_const;\n use middle::def;\n@@ -94,7 +95,7 @@ pub enum categorization<'tcx> {\n     cat_local(ast::NodeId),                    // local variable\n     cat_deref(cmt<'tcx>, usize, PointerKind),   // deref of a ptr\n     cat_interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n-    cat_downcast(cmt<'tcx>, ast::DefId),       // selects a particular enum variant (*1)\n+    cat_downcast(cmt<'tcx>, DefId),       // selects a particular enum variant (*1)\n \n     // (*1) downcast is only required if the enum has more than one variant\n }\n@@ -1132,7 +1133,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                                     node: &N,\n                                     base_cmt: cmt<'tcx>,\n                                     downcast_ty: Ty<'tcx>,\n-                                    variant_did: ast::DefId)\n+                                    variant_did: DefId)\n                                     -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id: node.id(),"}, {"sha": "7aac1a376e41a7f55e61483f87caaa0678185b16", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use middle::def::*;\n+use middle::def_id::DefId;\n use middle::ty;\n use util::nodemap::FnvHashMap;\n \n@@ -191,7 +192,7 @@ pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n     }\n }\n \n-pub fn def_to_path(tcx: &ty::ctxt, id: ast::DefId) -> ast::Path {\n+pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> ast::Path {\n     tcx.with_path(id, |path| ast::Path {\n         global: false,\n         segments: path.last().map(|elem| ast::PathSegment {"}, {"sha": "4a1be3bba7bc1403479de9ee1dbc2786cdd4914f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -16,10 +16,9 @@ pub use self::PrivateDep::*;\n pub use self::ImportUse::*;\n pub use self::LastPrivate::*;\n \n+use middle::def_id::DefId;\n use util::nodemap::{DefIdSet, NodeSet};\n \n-use syntax::ast;\n-\n /// A set of AST nodes exported by the crate.\n pub type ExportedItems = NodeSet;\n \n@@ -49,7 +48,7 @@ pub enum LastPrivate {\n #[derive(Copy, Clone, Debug)]\n pub enum PrivateDep {\n     AllPublic,\n-    DependsOn(ast::DefId),\n+    DependsOn(DefId),\n }\n \n // How an import is used."}, {"sha": "206e1f2ba641bf54acac2be4eddf2ba4981c06c5", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -17,6 +17,7 @@\n \n use ast_map;\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::ty;\n use middle::privacy;\n use session::config;\n@@ -25,7 +26,6 @@ use util::nodemap::NodeSet;\n use std::collections::HashSet;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_util::is_local;\n use syntax::attr;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -55,12 +55,12 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, sig: &ast::MethodSig,\n                            impl_item: &ast::ImplItem,\n-                           impl_src: ast::DefId) -> bool {\n+                           impl_src: DefId) -> bool {\n     if attr::requests_inline(&impl_item.attrs) ||\n         generics_require_inlining(&sig.generics) {\n         return true\n     }\n-    if is_local(impl_src) {\n+    if impl_src.is_local() {\n         {\n             match tcx.map.find(impl_src.node) {\n                 Some(ast_map::NodeItem(item)) => {\n@@ -105,7 +105,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                 };\n \n                 let def_id = def.def_id();\n-                if is_local(def_id) {\n+                if def_id.is_local() {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n                         self.worklist.push(def_id.node)\n                     } else {\n@@ -131,7 +131,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                 let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n                 match self.tcx.impl_or_trait_item(def_id).container() {\n                     ty::ImplContainer(_) => {\n-                        if is_local(def_id) {\n+                        if def_id.is_local() {\n                             if self.def_id_represents_local_inlined_item(def_id) {\n                                 self.worklist.push(def_id.node)\n                             }\n@@ -169,8 +169,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n-    fn def_id_represents_local_inlined_item(&self, def_id: ast::DefId) -> bool {\n-        if def_id.krate != ast::LOCAL_CRATE {\n+    fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n+        if def_id.krate != LOCAL_CRATE {\n             return false\n         }\n \n@@ -203,7 +203,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            assert!(impl_did.krate == ast::LOCAL_CRATE);\n+                            assert!(impl_did.is_local());\n                             match self.tcx\n                                       .map\n                                       .expect_item(impl_did.node)\n@@ -356,7 +356,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&mut self) {\n         for (_, destructor_def_id) in self.tcx.destructor_for_type.borrow().iter() {\n-            if destructor_def_id.krate == ast::LOCAL_CRATE {\n+            if destructor_def_id.is_local() {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }\n         }\n@@ -378,7 +378,7 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     }\n     for (_, item) in tcx.lang_items.items() {\n         match *item {\n-            Some(did) if is_local(did) => {\n+            Some(did) if did.is_local() => {\n                 reachable_context.worklist.push(did.node);\n             }\n             _ => {}"}, {"sha": "d841f9617c8c9ec6b201f5e0b1ac46cfd984547c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -14,16 +14,16 @@\n use session::Session;\n use lint;\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::ty;\n use middle::privacy::PublicItems;\n use metadata::csearch;\n use syntax::parse::token::InternedString;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::{attr, visit};\n use syntax::ast;\n-use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n+use syntax::ast::{Attribute, Block, Crate, FnDecl, NodeId, Variant};\n use syntax::ast::{Item, Generics, StructField};\n-use syntax::ast_util::{is_local, local_def};\n use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, Visitor};\n use syntax::feature_gate::emit_feature_err;\n@@ -57,7 +57,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                    attrs: &Vec<Attribute>, item_sp: Span, f: F, required: bool) where\n         F: FnOnce(&mut Annotator),\n     {\n-        if self.index.staged_api[&ast::LOCAL_CRATE] {\n+        if self.index.staged_api[&LOCAL_CRATE] {\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n             match attr::find_stability(self.tcx.sess.diagnostic(), attrs, item_sp) {\n                 Some(mut stab) => {\n@@ -111,7 +111,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                             \"An API can't be stabilized after it is deprecated\");\n                     }\n \n-                    self.index.map.insert(local_def(id), Some(stab));\n+                    self.index.map.insert(DefId::local(id), Some(stab));\n \n                     // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                     if stab.level != attr::Stable {\n@@ -127,8 +127,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                            use_parent, self.parent);\n                     if use_parent {\n                         if let Some(stab) = self.parent {\n-                            self.index.map.insert(local_def(id), Some(stab));\n-                        } else if self.index.staged_api[&ast::LOCAL_CRATE] && required\n+                            self.index.map.insert(DefId::local(id), Some(stab));\n+                        } else if self.index.staged_api[&LOCAL_CRATE] && required\n                             && self.export_map.contains(&id)\n                             && !self.tcx.sess.opts.test {\n                                 self.tcx.sess.span_err(item_sp,\n@@ -245,7 +245,7 @@ impl<'tcx> Index<'tcx> {\n             }\n         }\n         let mut staged_api = FnvHashMap();\n-        staged_api.insert(ast::LOCAL_CRATE, is_staged_api);\n+        staged_api.insert(LOCAL_CRATE, is_staged_api);\n         Index {\n             staged_api: staged_api,\n             map: DefIdMap(),\n@@ -283,9 +283,9 @@ struct Checker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn check(&mut self, id: ast::DefId, span: Span, stab: &Option<&Stability>) {\n+    fn check(&mut self, id: DefId, span: Span, stab: &Option<&Stability>) {\n         // Only the cross-crate scenario matters when checking unstable APIs\n-        let cross_crate = !is_local(id);\n+        let cross_crate = !id.is_local();\n         if !cross_crate { return }\n \n         match *stab {\n@@ -367,7 +367,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n \n /// Helper for discovering nodes to check for stability\n pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n-                  cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     match item.node {\n         ast::ItemExternCrate(_) => {\n             // compiler-generated `extern crate` items have a dummy span.\n@@ -377,7 +377,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n                 Some(cnum) => cnum,\n                 None => return,\n             };\n-            let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+            let id = DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n \n@@ -404,7 +404,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n \n /// Helper for discovering nodes to check for stability\n pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n-                  cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     let span;\n     let id = match e.node {\n         ast::ExprMethodCall(i, _, _) => {\n@@ -465,7 +465,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n }\n \n pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n-                  cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(def::DefPrimTy(..)) => {}\n         Some(def) => {\n@@ -477,7 +477,7 @@ pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n }\n \n pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n-                 cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n+                 cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n@@ -509,8 +509,8 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     }\n }\n \n-fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n-                            cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n+fn maybe_do_stability_check(tcx: &ty::ctxt, id: DefId, span: Span,\n+                            cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     if !is_staged_api(tcx, id) {\n         debug!(\"maybe_do_stability_check: \\\n                 skipping id={:?} since it is not staged_api\", id);\n@@ -568,7 +568,7 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n         _ => {}\n     }\n \n-    let item_stab = if is_local(id) {\n+    let item_stab = if id.is_local() {\n         None // The stability cache is filled partially lazily\n     } else {\n         csearch::get_stability(&tcx.sess.cstore, id).map(|st| tcx.intern_stability(st))"}, {"sha": "87939c45d67c54081afd27254c22ac14c77f557e", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -17,19 +17,19 @@ use super::PredicateObligation;\n use super::project;\n use super::util;\n \n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};\n-use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n /// True if there exist types that satisfy both of the two given impls.\n pub fn overlapping_impls(infcx: &InferCtxt,\n-                         impl1_def_id: ast::DefId,\n-                         impl2_def_id: ast::DefId)\n+                         impl1_def_id: DefId,\n+                         impl2_def_id: DefId)\n                          -> bool\n {\n     debug!(\"impl_can_satisfy(\\\n@@ -47,8 +47,8 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n /// Can the types from impl `a` be used to satisfy impl `b`?\n /// (Including all conditions)\n fn overlap(selcx: &mut SelectionContext,\n-           a_def_id: ast::DefId,\n-           b_def_id: ast::DefId)\n+           a_def_id: DefId,\n+           b_def_id: DefId)\n            -> bool\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n@@ -109,7 +109,7 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRe\n     // an ancestor crate will impl this in the future, if they haven't\n     // already\n     if\n-        trait_ref.def_id.krate != ast::LOCAL_CRATE &&\n+        trait_ref.def_id.krate != LOCAL_CRATE &&\n         !tcx.has_attr(trait_ref.def_id, \"fundamental\")\n     {\n         debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n@@ -127,13 +127,13 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRe\n \n type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n                                 span: Span,\n-                                impl_def_id: ast::DefId)\n+                                impl_def_id: DefId)\n                                 -> Substs<'tcx>;\n \n /// Instantiate fresh variables for all bound parameters of the impl\n /// and return the impl trait ref with those variables substituted.\n fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                                     impl_def_id: ast::DefId,\n+                                     impl_def_id: DefId,\n                                      substs_fn: SubstsFn)\n                                      -> (ty::TraitRef<'tcx>,\n                                          Vec<PredicateObligation<'tcx>>)\n@@ -175,7 +175,7 @@ pub enum OrphanCheckErr<'tcx> {\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                          impl_def_id: ast::DefId)\n+                          impl_def_id: DefId)\n                           -> Result<(), OrphanCheckErr<'tcx>>\n {\n     debug!(\"orphan_check({:?})\", impl_def_id);\n@@ -186,7 +186,7 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n \n     // If the *trait* is local to the crate, ok.\n-    if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n+    if trait_ref.def_id.is_local() {\n         debug!(\"trait {:?} is local to current crate\",\n                trait_ref.def_id);\n         return Ok(());\n@@ -318,16 +318,16 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         ty::TyEnum(def, _) |\n         ty::TyStruct(def, _) => {\n-            def.did.krate == ast::LOCAL_CRATE\n+            def.did.is_local()\n         }\n \n         ty::TyBox(_) => { // Box<T>\n             let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n-            krate == Some(ast::LOCAL_CRATE)\n+            krate == Some(LOCAL_CRATE)\n         }\n \n         ty::TyTrait(ref tt) => {\n-            tt.principal_def_id().krate == ast::LOCAL_CRATE\n+            tt.principal_def_id().is_local()\n         }\n \n         ty::TyClosure(..) |"}, {"sha": "40f1e9d64f73d76c98bfd57f08efecfb898babbd", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -24,13 +24,13 @@ use super::{\n };\n \n use fmt_macros::{Parser, Piece, Position};\n+use middle::def_id::DefId;\n use middle::infer::InferCtxt;\n use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef, Ty};\n use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use std::fmt;\n use syntax::codemap::Span;\n-use syntax::ast;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -294,7 +294,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                         span: Span,\n-                                        trait_def_id: ast::DefId,\n+                                        trait_def_id: DefId,\n                                         is_warning: bool)\n {\n     span_err_or_warn!("}, {"sha": "667cad8fc88ae9a7f8c9b3a5d4506018dcd3d931", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -15,6 +15,7 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::ty::{self, HasTypeFlags, Ty};\n@@ -112,7 +113,7 @@ pub enum ObligationCauseCode<'tcx> {\n \n     /// In an impl of trait X for type Y, type Y must\n     /// also implement all supertraits of X.\n-    ItemObligation(ast::DefId),\n+    ItemObligation(DefId),\n \n     /// A type like `&'a T` is WF only if `T: 'a`.\n     ReferenceOutlivesReferent(Ty<'tcx>),\n@@ -168,7 +169,7 @@ pub enum SelectionError<'tcx> {\n     OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n                                 ty::PolyTraitRef<'tcx>,\n                                 ty::TypeError<'tcx>),\n-    TraitNotObjectSafe(ast::DefId),\n+    TraitNotObjectSafe(DefId),\n }\n \n pub struct FulfillmentError<'tcx> {\n@@ -274,14 +275,14 @@ pub enum Vtable<'tcx, N> {\n /// impl, and nested obligations are satisfied later.\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableImplData<'tcx, N> {\n-    pub impl_def_id: ast::DefId,\n+    pub impl_def_id: DefId,\n     pub substs: subst::Substs<'tcx>,\n     pub nested: Vec<N>\n }\n \n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableClosureData<'tcx, N> {\n-    pub closure_def_id: ast::DefId,\n+    pub closure_def_id: DefId,\n     pub substs: ty::ClosureSubsts<'tcx>,\n     /// Nested obligations. This can be non-empty if the closure\n     /// signature contains associated types.\n@@ -290,7 +291,7 @@ pub struct VtableClosureData<'tcx, N> {\n \n #[derive(Clone)]\n pub struct VtableDefaultImplData<N> {\n-    pub trait_def_id: ast::DefId,\n+    pub trait_def_id: DefId,\n     pub nested: Vec<N>\n }\n "}, {"sha": "3c6e939833fffdfc4d202981b840a29c6633d62e", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -20,6 +20,7 @@\n use super::supertraits;\n use super::elaborate_predicates;\n \n+use middle::def_id::DefId;\n use middle::subst::{self, SelfSpace, TypeSpace};\n use middle::traits;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n@@ -53,7 +54,7 @@ pub enum MethodViolationCode {\n }\n \n pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            trait_def_id: ast::DefId)\n+                            trait_def_id: DefId)\n                             -> bool\n {\n     // Because we query yes/no results frequently, we keep a cache:\n@@ -76,7 +77,7 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n pub fn object_safety_violations<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      trait_def_id: ast::DefId)\n+                                      trait_def_id: DefId)\n                                       -> Vec<ObjectSafetyViolation<'tcx>>\n {\n     traits::supertrait_def_ids(tcx, trait_def_id)\n@@ -85,7 +86,7 @@ pub fn object_safety_violations<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                            trait_def_id: ast::DefId)\n+                                            trait_def_id: DefId)\n                                             -> Vec<ObjectSafetyViolation<'tcx>>\n {\n     // Check methods for violations.\n@@ -119,7 +120,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                    trait_def_id: ast::DefId)\n+                                    trait_def_id: DefId)\n                                     -> bool\n {\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n@@ -152,7 +153,7 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              trait_def_id: ast::DefId)\n+                              trait_def_id: DefId)\n                               -> bool\n {\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n@@ -194,7 +195,7 @@ fn generics_require_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n /// Returns `Some(_)` if this method makes the containing trait not object safe.\n fn object_safety_violation_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                            trait_def_id: ast::DefId,\n+                                            trait_def_id: DefId,\n                                             method: &ty::Method<'tcx>)\n                                             -> Option<MethodViolationCode>\n {\n@@ -212,7 +213,7 @@ fn object_safety_violation_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// non-vtable-safe methods, so long as they require `Self:Sized` or\n /// otherwise ensure that they cannot be used when `Self=Trait`.\n pub fn is_vtable_safe_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                   trait_def_id: ast::DefId,\n+                                   trait_def_id: DefId,\n                                    method: &ty::Method<'tcx>)\n                                    -> bool\n {\n@@ -224,7 +225,7 @@ pub fn is_vtable_safe_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// is not object safe, because the method might have a where clause\n /// `Self:Sized`.\n fn virtual_call_violation_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                           trait_def_id: ast::DefId,\n+                                           trait_def_id: DefId,\n                                            method: &ty::Method<'tcx>)\n                                            -> Option<MethodViolationCode>\n {\n@@ -265,7 +266,7 @@ fn virtual_call_violation_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                              trait_def_id: ast::DefId,\n+                                              trait_def_id: DefId,\n                                               ty: Ty<'tcx>)\n                                               -> bool\n {"}, {"sha": "a4d36c1fda8e7ebb7e2a0d752f7f106e9820b2c3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -37,6 +37,7 @@ use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n use super::object_safety;\n use super::util;\n \n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::fast_reject;\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPredicate, RegionEscape, ToPolyTraitRef, Ty, HasTypeFlags};\n@@ -101,7 +102,7 @@ pub struct SelectionCache<'tcx> {\n \n pub enum MethodMatchResult {\n     MethodMatched(MethodMatchedData),\n-    MethodAmbiguous(/* list of impls that could apply */ Vec<ast::DefId>),\n+    MethodAmbiguous(/* list of impls that could apply */ Vec<DefId>),\n     MethodDidNotMatch,\n }\n \n@@ -113,7 +114,7 @@ pub enum MethodMatchedData {\n \n     // In the case of a coercion, we need to know the precise impl so\n     // that we can determine the type to which things were coerced.\n-    CoerciveMethodMatch(/* impl we matched */ ast::DefId)\n+    CoerciveMethodMatch(/* impl we matched */ DefId)\n }\n \n /// The selection process begins by considering all impls, where\n@@ -193,17 +194,17 @@ enum SelectionCandidate<'tcx> {\n     PhantomFnCandidate,\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n-    ImplCandidate(ast::DefId),\n-    DefaultImplCandidate(ast::DefId),\n-    DefaultImplObjectCandidate(ast::DefId),\n+    ImplCandidate(DefId),\n+    DefaultImplCandidate(DefId),\n+    DefaultImplObjectCandidate(DefId),\n \n     /// This is a trait matching with a projected type as `Self`, and\n     /// we found an applicable bound in the trait definition.\n     ProjectionCandidate,\n \n     /// Implementation of a `Fn`-family trait by one of the\n     /// anonymous types generated for a `||` expression.\n-    ClosureCandidate(/* closure */ ast::DefId, &'tcx ty::ClosureSubsts<'tcx>),\n+    ClosureCandidate(/* closure */ DefId, &'tcx ty::ClosureSubsts<'tcx>),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -610,7 +611,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Evaluates whether the impl with id `impl_def_id` could be applied to the self type\n     /// `obligation_self_ty`. This can be used either for trait or inherent impls.\n     pub fn evaluate_impl(&mut self,\n-                         impl_def_id: ast::DefId,\n+                         impl_def_id: DefId,\n                          obligation: &TraitObligation<'tcx>)\n                          -> bool\n     {\n@@ -1724,7 +1725,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // captures are by value. Really what we ought to do\n                 // is reserve judgement and then intertwine this\n                 // analysis with closure inference.\n-                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+                assert_eq!(def_id.krate, LOCAL_CRATE);\n \n                 // Unboxed closures shouldn't be\n                 // implicitly copyable\n@@ -1867,7 +1868,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // OIBIT interact? That is, there is no way to say\n                 // \"make me invariant with respect to this TYPE, but\n                 // do not act as though I can reach it\"\n-                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+                assert_eq!(def_id.krate, LOCAL_CRATE);\n                 substs.upvar_tys.clone()\n             }\n \n@@ -1886,7 +1887,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn collect_predicates_for_types(&mut self,\n                                     obligation: &TraitObligation<'tcx>,\n-                                    trait_def_id: ast::DefId,\n+                                    trait_def_id: DefId,\n                                     types: ty::Binder<Vec<Ty<'tcx>>>)\n                                     -> Vec<PredicateObligation<'tcx>>\n     {\n@@ -2120,7 +2121,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n     fn confirm_default_impl_candidate(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      trait_def_id: ast::DefId)\n+                                      trait_def_id: DefId)\n                                       -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_default_impl_candidate({:?}, {:?})\",\n@@ -2135,7 +2136,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_default_impl_object_candidate(&mut self,\n                                              obligation: &TraitObligation<'tcx>,\n-                                             trait_def_id: ast::DefId)\n+                                             trait_def_id: DefId)\n                                              -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_default_impl_object_candidate({:?}, {:?})\",\n@@ -2175,7 +2176,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// See `confirm_default_impl_candidate`\n     fn vtable_default_impl(&mut self,\n                            obligation: &TraitObligation<'tcx>,\n-                           trait_def_id: ast::DefId,\n+                           trait_def_id: DefId,\n                            nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n@@ -2210,7 +2211,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_impl_candidate(&mut self,\n                               obligation: &TraitObligation<'tcx>,\n-                              impl_def_id: ast::DefId)\n+                              impl_def_id: DefId)\n                               -> Result<VtableImplData<'tcx, PredicateObligation<'tcx>>,\n                                         SelectionError<'tcx>>\n     {\n@@ -2231,7 +2232,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn vtable_impl(&mut self,\n-                   impl_def_id: ast::DefId,\n+                   impl_def_id: DefId,\n                    mut substs: Normalized<'tcx, Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: usize,\n@@ -2350,7 +2351,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_closure_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n-                                 closure_def_id: ast::DefId,\n+                                 closure_def_id: DefId,\n                                  substs: &ty::ClosureSubsts<'tcx>)\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n@@ -2605,7 +2606,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // contained.\n \n     fn rematch_impl(&mut self,\n-                    impl_def_id: ast::DefId,\n+                    impl_def_id: DefId,\n                     obligation: &TraitObligation<'tcx>,\n                     snapshot: &infer::CombinedSnapshot)\n                     -> (Normalized<'tcx, Substs<'tcx>>, infer::SkolemizationMap)\n@@ -2622,7 +2623,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_impl(&mut self,\n-                  impl_def_id: ast::DefId,\n+                  impl_def_id: DefId,\n                   obligation: &TraitObligation<'tcx>,\n                   snapshot: &infer::CombinedSnapshot)\n                   -> Result<(Normalized<'tcx, Substs<'tcx>>,\n@@ -2753,7 +2754,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// result. But if `obligation_self_ty` were `Box<int>`, we'd get\n     /// back `Ok(T=int)`.\n     fn match_inherent_impl(&mut self,\n-                           impl_def_id: ast::DefId,\n+                           impl_def_id: DefId,\n                            obligation_cause: &ObligationCause,\n                            obligation_self_ty: Ty<'tcx>)\n                            -> Result<Substs<'tcx>,()>\n@@ -2838,7 +2839,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn closure_trait_ref_unnormalized(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      closure_def_id: ast::DefId,\n+                                      closure_def_id: DefId,\n                                       substs: &ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n@@ -2860,7 +2861,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn closure_trait_ref(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n-                         closure_def_id: ast::DefId,\n+                         closure_def_id: DefId,\n                          substs: &ty::ClosureSubsts<'tcx>)\n                          -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n     {\n@@ -2882,7 +2883,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn impl_or_trait_obligations(&mut self,\n                                  cause: ObligationCause<'tcx>,\n                                  recursion_depth: usize,\n-                                 def_id: ast::DefId, // of impl or trait\n+                                 def_id: DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n                                  skol_map: infer::SkolemizationMap,\n                                  snapshot: &infer::CombinedSnapshot)"}, {"sha": "40d767d8c5f17deed287d4b783fe2eda3d464acc", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::subst::Substs;\n+use middle::def_id::DefId;\n use middle::infer::InferCtxt;\n+use middle::subst::Substs;\n use middle::ty::{self, HasTypeFlags, Ty, ToPredicate, ToPolyTraitRef};\n use std::fmt;\n-use syntax::ast;\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n@@ -226,12 +226,12 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n \n pub struct SupertraitDefIds<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n-    stack: Vec<ast::DefId>,\n-    visited: FnvHashSet<ast::DefId>,\n+    stack: Vec<DefId>,\n+    visited: FnvHashSet<DefId>,\n }\n \n pub fn supertrait_def_ids<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                     trait_def_id: ast::DefId)\n+                                     trait_def_id: DefId)\n                                      -> SupertraitDefIds<'cx, 'tcx>\n {\n     SupertraitDefIds {\n@@ -242,9 +242,9 @@ pub fn supertrait_def_ids<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n }\n \n impl<'cx, 'tcx> Iterator for SupertraitDefIds<'cx, 'tcx> {\n-    type Item = ast::DefId;\n+    type Item = DefId;\n \n-    fn next(&mut self) -> Option<ast::DefId> {\n+    fn next(&mut self) -> Option<DefId> {\n         let def_id = match self.stack.pop() {\n             Some(def_id) => def_id,\n             None => { return None; }\n@@ -307,7 +307,7 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n // variables.\n pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                           span: Span,\n-                                          impl_def_id: ast::DefId)\n+                                          impl_def_id: DefId)\n                                           -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n@@ -368,7 +368,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n pub fn predicate_for_trait_def<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    trait_def_id: ast::DefId,\n+    trait_def_id: DefId,\n     recursion_depth: usize,\n     param_ty: Ty<'tcx>,\n     ty_params: Vec<Ty<'tcx>>)\n@@ -398,7 +398,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n /// supertrait.\n pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     source_trait_ref: ty::PolyTraitRef<'tcx>,\n-                    target_trait_def_id: ast::DefId)\n+                    target_trait_def_id: DefId)\n                     -> Vec<ty::PolyTraitRef<'tcx>>\n {\n     if source_trait_ref.def_id() == target_trait_def_id {\n@@ -432,7 +432,7 @@ pub fn count_own_vtable_entries<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// `object.upcast_trait_ref`) within the vtable for `object`.\n pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                object: &super::VtableObjectData<'tcx>,\n-                                               method_def_id: ast::DefId) -> usize {\n+                                               method_def_id: DefId) -> usize {\n     // Count number of methods preceding the one we are selecting and\n     // add them to the total offset.\n     // Skip over associated types and constants.\n@@ -460,7 +460,7 @@ pub enum TupleArgumentsFlag { Yes, No }\n \n pub fn closure_trait_ref_and_return_type<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n-    fn_trait_def_id: ast::DefId,\n+    fn_trait_def_id: DefId,\n     self_ty: Ty<'tcx>,\n     sig: &ty::PolyFnSig<'tcx>,\n     tuple_arguments: TupleArgumentsFlag)"}, {"sha": "7418d81ed3dce1eae0c6787286a25d79c7807f23", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 119, "deletions": 140, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -47,6 +47,7 @@ use middle::check_const;\n use middle::const_eval::{self, ConstVal, ErrKind};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def::{self, DefMap, ExportMap};\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::fast_reject;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -85,9 +86,8 @@ use core::nonzero::NonZero;\n use std::collections::{HashMap, HashSet};\n use rustc_data_structures::ivar;\n use syntax::abi;\n-use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n+use syntax::ast::{CrateNum, ItemImpl, ItemTrait};\n use syntax::ast::{MutImmutable, MutMutable, Name, NodeId, Visibility};\n-use syntax::ast_util::{self, is_local, local_def};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n@@ -254,12 +254,12 @@ impl IntTypeExt for attr::IntType {\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum ImplOrTraitItemContainer {\n-    TraitContainer(ast::DefId),\n-    ImplContainer(ast::DefId),\n+    TraitContainer(DefId),\n+    ImplContainer(DefId),\n }\n \n impl ImplOrTraitItemContainer {\n-    pub fn id(&self) -> ast::DefId {\n+    pub fn id(&self) -> DefId {\n         match *self {\n             TraitContainer(id) => id,\n             ImplContainer(id) => id,\n@@ -287,7 +287,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n         }\n     }\n \n-    pub fn def_id(&self) -> ast::DefId {\n+    pub fn def_id(&self) -> DefId {\n         match *self {\n             ConstTraitItem(ref associated_const) => associated_const.def_id,\n             MethodTraitItem(ref method) => method.def_id,\n@@ -329,13 +329,13 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n \n #[derive(Clone, Copy, Debug)]\n pub enum ImplOrTraitItemId {\n-    ConstTraitItemId(ast::DefId),\n-    MethodTraitItemId(ast::DefId),\n-    TypeTraitItemId(ast::DefId),\n+    ConstTraitItemId(DefId),\n+    MethodTraitItemId(DefId),\n+    TypeTraitItemId(DefId),\n }\n \n impl ImplOrTraitItemId {\n-    pub fn def_id(&self) -> ast::DefId {\n+    pub fn def_id(&self) -> DefId {\n         match *self {\n             ConstTraitItemId(def_id) => def_id,\n             MethodTraitItemId(def_id) => def_id,\n@@ -352,11 +352,11 @@ pub struct Method<'tcx> {\n     pub fty: BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n     pub vis: ast::Visibility,\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n \n     // If this method is provided, we need to know where it came from\n-    pub provided_source: Option<ast::DefId>\n+    pub provided_source: Option<DefId>\n }\n \n impl<'tcx> Method<'tcx> {\n@@ -366,9 +366,9 @@ impl<'tcx> Method<'tcx> {\n                fty: BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n                vis: ast::Visibility,\n-               def_id: ast::DefId,\n+               def_id: DefId,\n                container: ImplOrTraitItemContainer,\n-               provided_source: Option<ast::DefId>)\n+               provided_source: Option<DefId>)\n                -> Method<'tcx> {\n        Method {\n             name: name,\n@@ -383,7 +383,7 @@ impl<'tcx> Method<'tcx> {\n         }\n     }\n \n-    pub fn container_id(&self) -> ast::DefId {\n+    pub fn container_id(&self) -> DefId {\n         match self.container {\n             TraitContainer(id) => id,\n             ImplContainer(id) => id,\n@@ -396,17 +396,17 @@ pub struct AssociatedConst<'tcx> {\n     pub name: ast::Name,\n     pub ty: Ty<'tcx>,\n     pub vis: ast::Visibility,\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n-    pub default: Option<ast::DefId>,\n+    pub default: Option<DefId>,\n }\n \n #[derive(Clone, Copy, Debug)]\n pub struct AssociatedType<'tcx> {\n     pub name: ast::Name,\n     pub ty: Option<Ty<'tcx>>,\n     pub vis: ast::Visibility,\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n \n@@ -543,7 +543,7 @@ pub enum CustomCoerceUnsized {\n #[derive(Clone, Copy, Debug)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n     pub substs: &'tcx subst::Substs<'tcx>\n }\n@@ -789,7 +789,7 @@ pub struct ctxt<'tcx> {\n     pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n-    pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n+    pub provided_method_sources: RefCell<DefIdMap<DefId>>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n@@ -802,15 +802,15 @@ pub struct ctxt<'tcx> {\n     /// of the method that implements its destructor. If the type is not\n     /// present in this map, it does not have a destructor. This map is\n     /// populated during the coherence phase of typechecking.\n-    pub destructor_for_type: RefCell<DefIdMap<ast::DefId>>,\n+    pub destructor_for_type: RefCell<DefIdMap<DefId>>,\n \n     /// A method will be in this list if and only if it is a destructor.\n     pub destructors: RefCell<DefIdSet>,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<Rc<Vec<ast::DefId>>>>,\n+    pub inherent_impls: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n \n     /// Maps a DefId of an impl to a list of its items.\n     /// Note that this contains all of the impls that we know about,\n@@ -1093,12 +1093,10 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Binder<T> {\n }\n \n pub mod tls {\n-    use ast_map;\n     use middle::ty;\n     use session::Session;\n \n     use std::fmt;\n-    use syntax::ast;\n     use syntax::codemap;\n \n     /// Marker type used for the scoped TLS slot.\n@@ -1108,28 +1106,6 @@ pub mod tls {\n \n     scoped_thread_local!(static TLS_TCX: ThreadLocalTyCx);\n \n-    fn def_id_debug(def_id: ast::DefId, f: &mut fmt::Formatter) -> fmt::Result {\n-        // Unfortunately, there seems to be no way to attempt to print\n-        // a path for a def-id, so I'll just make a best effort for now\n-        // and otherwise fallback to just printing the crate/node pair\n-        with(|tcx| {\n-            if def_id.krate == ast::LOCAL_CRATE {\n-                match tcx.map.find(def_id.node) {\n-                    Some(ast_map::NodeItem(..)) |\n-                    Some(ast_map::NodeForeignItem(..)) |\n-                    Some(ast_map::NodeImplItem(..)) |\n-                    Some(ast_map::NodeTraitItem(..)) |\n-                    Some(ast_map::NodeVariant(..)) |\n-                    Some(ast_map::NodeStructCtor(..)) => {\n-                        return write!(f, \"{}\", tcx.item_path_str(def_id));\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            Ok(())\n-        })\n-    }\n-\n     fn span_debug(span: codemap::Span, f: &mut fmt::Formatter) -> fmt::Result {\n         with(|tcx| {\n             write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n@@ -1138,25 +1114,28 @@ pub mod tls {\n \n     pub fn enter<'tcx, F: FnOnce(&ty::ctxt<'tcx>) -> R, R>(tcx: ty::ctxt<'tcx>, f: F)\n                                                            -> (Session, R) {\n-        let result = ast::DEF_ID_DEBUG.with(|def_id_dbg| {\n-            codemap::SPAN_DEBUG.with(|span_dbg| {\n-                let original_def_id_debug = def_id_dbg.get();\n-                def_id_dbg.set(def_id_debug);\n-                let original_span_debug = span_dbg.get();\n-                span_dbg.set(span_debug);\n-                let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n-                let result = TLS_TCX.set(unsafe { &*tls_ptr }, || f(&tcx));\n-                def_id_dbg.set(original_def_id_debug);\n-                span_dbg.set(original_span_debug);\n-                result\n-            })\n+        let result = codemap::SPAN_DEBUG.with(|span_dbg| {\n+            let original_span_debug = span_dbg.get();\n+            span_dbg.set(span_debug);\n+            let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n+            let result = TLS_TCX.set(unsafe { &*tls_ptr }, || f(&tcx));\n+            span_dbg.set(original_span_debug);\n+            result\n         });\n         (tcx.sess, result)\n     }\n \n     pub fn with<F: FnOnce(&ty::ctxt) -> R, R>(f: F) -> R {\n         TLS_TCX.with(|tcx| f(unsafe { &*(tcx as *const _ as *const ty::ctxt) }))\n     }\n+\n+    pub fn with_opt<F: FnOnce(Option<&ty::ctxt>) -> R, R>(f: F) -> R {\n+        if TLS_TCX.is_set() {\n+            with(|v| f(Some(v)))\n+        } else {\n+            f(None)\n+        }\n+    }\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -1711,7 +1690,7 @@ pub enum BoundRegion {\n     ///\n     /// The def-id is needed to distinguish free regions in\n     /// the event of shadowing.\n-    BrNamed(ast::DefId, ast::Name),\n+    BrNamed(DefId, ast::Name),\n \n     /// Fresh bound identifiers created during GLB computations.\n     BrFresh(u32),\n@@ -1907,7 +1886,7 @@ pub struct TraitTy<'tcx> {\n }\n \n impl<'tcx> TraitTy<'tcx> {\n-    pub fn principal_def_id(&self) -> ast::DefId {\n+    pub fn principal_def_id(&self) -> DefId {\n         self.principal.0.def_id\n     }\n \n@@ -1984,7 +1963,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n         self.0.self_ty()\n     }\n \n-    pub fn def_id(&self) -> ast::DefId {\n+    pub fn def_id(&self) -> DefId {\n         self.0.def_id\n     }\n \n@@ -2087,7 +2066,7 @@ pub enum TypeError<'tcx> {\n     IntegerAsChar,\n     IntMismatch(ExpectedFound<IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n-    Traits(ExpectedFound<ast::DefId>),\n+    Traits(ExpectedFound<DefId>),\n     BuiltinBoundsMismatch(ExpectedFound<BuiltinBounds>),\n     VariadicMismatch(ExpectedFound<bool>),\n     CyclicTy,\n@@ -2304,7 +2283,7 @@ pub enum ObjectLifetimeDefault {\n #[derive(Clone)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: ast::Name,\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n     pub default_def_id: DefId, // for use in error reporing about defaults\n@@ -2315,7 +2294,7 @@ pub struct TypeParameterDef<'tcx> {\n #[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n pub struct RegionParameterDef {\n     pub name: ast::Name,\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n     pub bounds: Vec<ty::Region>,\n@@ -2419,7 +2398,7 @@ pub enum Predicate<'tcx> {\n     WellFormed(Ty<'tcx>),\n \n     /// trait must be object-safe\n-    ObjectSafe(ast::DefId),\n+    ObjectSafe(DefId),\n }\n \n impl<'tcx> Predicate<'tcx> {\n@@ -2520,7 +2499,7 @@ pub struct TraitPredicate<'tcx> {\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n-    pub fn def_id(&self) -> ast::DefId {\n+    pub fn def_id(&self) -> DefId {\n         self.trait_ref.def_id\n     }\n \n@@ -2534,7 +2513,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n }\n \n impl<'tcx> PolyTraitPredicate<'tcx> {\n-    pub fn def_id(&self) -> ast::DefId {\n+    pub fn def_id(&self) -> DefId {\n         self.0.def_id()\n     }\n }\n@@ -2574,7 +2553,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.0.projection_ty.item_name // safe to skip the binder to access a name\n     }\n \n-    pub fn sort_key(&self) -> (ast::DefId, ast::Name) {\n+    pub fn sort_key(&self) -> (DefId, ast::Name) {\n         self.0.projection_ty.sort_key()\n     }\n }\n@@ -2591,7 +2570,7 @@ pub struct ProjectionTy<'tcx> {\n }\n \n impl<'tcx> ProjectionTy<'tcx> {\n-    pub fn sort_key(&self) -> (ast::DefId, ast::Name) {\n+    pub fn sort_key(&self) -> (DefId, ast::Name) {\n         (self.trait_ref.def_id, self.item_name)\n     }\n }\n@@ -2780,7 +2759,7 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n }\n \n impl<'tcx> TraitRef<'tcx> {\n-    pub fn new(def_id: ast::DefId, substs: &'tcx Substs<'tcx>) -> TraitRef<'tcx> {\n+    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>) -> TraitRef<'tcx> {\n         TraitRef { def_id: def_id, substs: substs }\n     }\n \n@@ -2864,7 +2843,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n                         let impl_id = cx.map.get_parent(id);\n-                        let impl_def_id = ast_util::local_def(impl_id);\n+                        let impl_def_id = DefId::local(impl_id);\n                         let scheme = cx.lookup_item_type(impl_def_id);\n                         let predicates = cx.lookup_predicates(impl_def_id);\n                         cx.construct_parameter_environment(impl_item.span,\n@@ -2873,7 +2852,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     ast::ConstImplItem(_, _) => {\n-                        let def_id = ast_util::local_def(id);\n+                        let def_id = DefId::local(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(impl_item.span,\n@@ -2882,7 +2861,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     ast::MethodImplItem(_, ref body) => {\n-                        let method_def_id = ast_util::local_def(id);\n+                        let method_def_id = DefId::local(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n@@ -2909,7 +2888,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n                         let trait_id = cx.map.get_parent(id);\n-                        let trait_def_id = ast_util::local_def(trait_id);\n+                        let trait_def_id = DefId::local(trait_id);\n                         let trait_def = cx.lookup_trait_def(trait_def_id);\n                         let predicates = cx.lookup_predicates(trait_def_id);\n                         cx.construct_parameter_environment(trait_item.span,\n@@ -2918,7 +2897,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     ast::ConstTraitItem(..) => {\n-                        let def_id = ast_util::local_def(id);\n+                        let def_id = DefId::local(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(trait_item.span,\n@@ -2931,7 +2910,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // block, unless this is a trait method with\n                         // no default, then fallback to the method id.\n                         let body_id = body.as_ref().map(|b| b.id).unwrap_or(id);\n-                        let method_def_id = ast_util::local_def(id);\n+                        let method_def_id = DefId::local(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n@@ -2956,7 +2935,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 match item.node {\n                     ast::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n-                        let fn_def_id = ast_util::local_def(id);\n+                        let fn_def_id = DefId::local(id);\n                         let fn_scheme = cx.lookup_item_type(fn_def_id);\n                         let fn_predicates = cx.lookup_predicates(fn_def_id);\n \n@@ -2970,7 +2949,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     ast::ItemImpl(..) |\n                     ast::ItemConst(..) |\n                     ast::ItemStatic(..) => {\n-                        let def_id = ast_util::local_def(id);\n+                        let def_id = DefId::local(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(item.span,\n@@ -2979,7 +2958,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     ast::ItemTrait(..) => {\n-                        let def_id = ast_util::local_def(id);\n+                        let def_id = DefId::local(id);\n                         let trait_def = cx.lookup_trait_def(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(item.span,\n@@ -3532,7 +3511,7 @@ pub enum ClosureKind {\n }\n \n impl ClosureKind {\n-    pub fn trait_did(&self, cx: &ctxt) -> ast::DefId {\n+    pub fn trait_did(&self, cx: &ctxt) -> DefId {\n         let result = match *self {\n             FnClosureKind => cx.lang_items.require(FnTraitLangItem),\n             FnMutClosureKind => {\n@@ -3902,12 +3881,12 @@ impl<'tcx> ctxt<'tcx> {\n         region\n     }\n \n-    pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n         *self.tables.borrow().closure_kinds.get(&def_id).unwrap()\n     }\n \n     pub fn closure_type(&self,\n-                        def_id: ast::DefId,\n+                        def_id: DefId,\n                         substs: &ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n@@ -4056,13 +4035,13 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn mk_fn(&self,\n-                 opt_def_id: Option<ast::DefId>,\n+                 opt_def_id: Option<DefId>,\n                  fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyBareFn(opt_def_id, fty))\n     }\n \n     pub fn mk_ctor_fn(&self,\n-                      def_id: ast::DefId,\n+                      def_id: DefId,\n                       input_tys: &[Ty<'tcx>],\n                       output: Ty<'tcx>) -> Ty<'tcx> {\n         let input_args = input_tys.iter().cloned().collect();\n@@ -4106,7 +4085,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn mk_closure(&self,\n-                      closure_id: ast::DefId,\n+                      closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>,\n                       tys: Vec<Ty<'tcx>>)\n                       -> Ty<'tcx> {\n@@ -4117,7 +4096,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn mk_closure_from_closure_substs(&self,\n-                                          closure_id: ast::DefId,\n+                                          closure_id: DefId,\n                                           closure_substs: Box<ClosureSubsts<'tcx>>)\n                                           -> Ty<'tcx> {\n         self.mk_ty(TyClosure(closure_id, closure_substs))\n@@ -4424,7 +4403,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn ty_to_def_id(&self) -> Option<ast::DefId> {\n+    pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n             TyTrait(ref tt) => Some(tt.principal_def_id()),\n             TyStruct(def, _) |\n@@ -4681,7 +4660,7 @@ impl<'tcx> TyS<'tcx> {\n             result\n         }\n \n-        fn apply_lang_items(cx: &ctxt, did: ast::DefId, tc: TypeContents)\n+        fn apply_lang_items(cx: &ctxt, did: DefId, tc: TypeContents)\n                             -> TypeContents {\n             if Some(did) == cx.lang_items.unsafe_cell_type() {\n                 tc | TC::InteriorUnsafe\n@@ -5457,7 +5436,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n /// then we have to go consult the crate loading code (and cache the result for\n /// the future).\n fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n-                                          def_id: ast::DefId,\n+                                          def_id: DefId,\n                                           map: &RefCell<DefIdMap<V>>,\n                                           load_external: F) -> V where\n     V: Clone,\n@@ -5468,7 +5447,7 @@ fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n         None => { }\n     }\n \n-    if def_id.krate == ast::LOCAL_CRATE {\n+    if def_id.is_local() {\n         panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n@@ -5515,7 +5494,7 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn positional_element_ty(&self,\n                                  ty: Ty<'tcx>,\n                                  i: usize,\n-                                 variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n+                                 variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n             (&TyStruct(def, substs), None) => {\n                 def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n@@ -5537,7 +5516,7 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn named_element_ty(&self,\n                             ty: Ty<'tcx>,\n                             n: ast::Name,\n-                            variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n+                            variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n             (&TyStruct(def, substs), None) => {\n                 def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n@@ -5776,7 +5755,7 @@ impl<'tcx> ctxt<'tcx> {\n                                              expected.ty,\n                                              found.ty));\n \n-                match (expected.def_id.krate == ast::LOCAL_CRATE,\n+                match (expected.def_id.is_local(),\n                        self.map.opt_span(expected.def_id.node)) {\n                     (true, Some(span)) => {\n                         self.sess.span_note(span,\n@@ -5793,7 +5772,7 @@ impl<'tcx> ctxt<'tcx> {\n                     expected.origin_span,\n                     &format!(\"...that was applied to an unconstrained type variable here\"));\n \n-                match (found.def_id.krate == ast::LOCAL_CRATE,\n+                match (found.def_id.is_local(),\n                        self.map.opt_span(found.def_id.node)) {\n                     (true, Some(span)) => {\n                         self.sess.span_note(span,\n@@ -5814,16 +5793,16 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn provided_source(&self, id: ast::DefId) -> Option<ast::DefId> {\n+    pub fn provided_source(&self, id: DefId) -> Option<DefId> {\n         self.provided_method_sources.borrow().get(&id).cloned()\n     }\n \n-    pub fn provided_trait_methods(&self, id: ast::DefId) -> Vec<Rc<Method<'tcx>>> {\n-        if is_local(id) {\n+    pub fn provided_trait_methods(&self, id: DefId) -> Vec<Rc<Method<'tcx>>> {\n+        if id.is_local() {\n             if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id.node).node {\n                 ms.iter().filter_map(|ti| {\n                     if let ast::MethodTraitItem(_, Some(_)) = ti.node {\n-                        match self.impl_or_trait_item(ast_util::local_def(ti.id)) {\n+                        match self.impl_or_trait_item(DefId::local(ti.id)) {\n                             MethodTraitItem(m) => Some(m),\n                             _ => {\n                                 self.sess.bug(\"provided_trait_methods(): \\\n@@ -5843,13 +5822,13 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn associated_consts(&self, id: ast::DefId) -> Vec<Rc<AssociatedConst<'tcx>>> {\n-        if is_local(id) {\n+    pub fn associated_consts(&self, id: DefId) -> Vec<Rc<AssociatedConst<'tcx>>> {\n+        if id.is_local() {\n             match self.map.expect_item(id.node).node {\n                 ItemTrait(_, _, _, ref tis) => {\n                     tis.iter().filter_map(|ti| {\n                         if let ast::ConstTraitItem(_, _) = ti.node {\n-                            match self.impl_or_trait_item(ast_util::local_def(ti.id)) {\n+                            match self.impl_or_trait_item(DefId::local(ti.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n                                     self.sess.bug(\"associated_consts(): \\\n@@ -5865,7 +5844,7 @@ impl<'tcx> ctxt<'tcx> {\n                 ItemImpl(_, _, _, _, _, ref iis) => {\n                     iis.iter().filter_map(|ii| {\n                         if let ast::ConstImplItem(_, _) = ii.node {\n-                            match self.impl_or_trait_item(ast_util::local_def(ii.id)) {\n+                            match self.impl_or_trait_item(DefId::local(ii.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n                                     self.sess.bug(\"associated_consts(): \\\n@@ -5888,7 +5867,7 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_items(&self, trait_did: ast::DefId) -> Rc<Vec<ImplOrTraitItem<'tcx>>> {\n+    pub fn trait_items(&self, trait_did: DefId) -> Rc<Vec<ImplOrTraitItem<'tcx>>> {\n         let mut trait_items = self.trait_items_cache.borrow_mut();\n         match trait_items.get(&trait_did).cloned() {\n             Some(trait_items) => trait_items,\n@@ -5904,8 +5883,8 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_impl_polarity(&self, id: ast::DefId) -> Option<ast::ImplPolarity> {\n-        if id.krate == ast::LOCAL_CRATE {\n+    pub fn trait_impl_polarity(&self, id: DefId) -> Option<ast::ImplPolarity> {\n+        if id.is_local() {\n             match self.map.find(id.node) {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n@@ -5920,9 +5899,9 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn custom_coerce_unsized_kind(&self, did: ast::DefId) -> CustomCoerceUnsized {\n+    pub fn custom_coerce_unsized_kind(&self, did: DefId) -> CustomCoerceUnsized {\n         memoized(&self.custom_coerce_unsized_kinds, did, |did: DefId| {\n-            let (kind, src) = if did.krate != ast::LOCAL_CRATE {\n+            let (kind, src) = if did.krate != LOCAL_CRATE {\n                 (csearch::get_custom_coerce_unsized_kind(self, did), \"external\")\n             } else {\n                 (None, \"local\")\n@@ -5939,29 +5918,29 @@ impl<'tcx> ctxt<'tcx> {\n         })\n     }\n \n-    pub fn impl_or_trait_item(&self, id: ast::DefId) -> ImplOrTraitItem<'tcx> {\n+    pub fn impl_or_trait_item(&self, id: DefId) -> ImplOrTraitItem<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n             || csearch::get_impl_or_trait_item(self, id))\n     }\n \n-    pub fn trait_item_def_ids(&self, id: ast::DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n+    pub fn trait_item_def_ids(&self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n         lookup_locally_or_in_crate_store(\n             \"trait_item_def_ids\", id, &self.trait_item_def_ids,\n             || Rc::new(csearch::get_trait_item_def_ids(&self.sess.cstore, id)))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n-    pub fn impl_trait_ref(&self, id: ast::DefId) -> Option<TraitRef<'tcx>> {\n+    pub fn impl_trait_ref(&self, id: DefId) -> Option<TraitRef<'tcx>> {\n         lookup_locally_or_in_crate_store(\n             \"impl_trait_refs\", id, &self.impl_trait_refs,\n             || csearch::get_impl_trait(self, id))\n     }\n \n     /// Returns whether this DefId refers to an impl\n-    pub fn is_impl(&self, id: ast::DefId) -> bool {\n-        if id.krate == ast::LOCAL_CRATE {\n+    pub fn is_impl(&self, id: DefId) -> bool {\n+        if id.is_local() {\n             if let Some(ast_map::NodeItem(\n                 &ast::Item { node: ast::ItemImpl(..), .. })) = self.map.find(id.node) {\n                 true\n@@ -5973,12 +5952,12 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_ref_to_def_id(&self, tr: &ast::TraitRef) -> ast::DefId {\n+    pub fn trait_ref_to_def_id(&self, tr: &ast::TraitRef) -> DefId {\n         self.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n     }\n \n     pub fn try_add_builtin_trait(&self,\n-                                 trait_def_id: ast::DefId,\n+                                 trait_def_id: DefId,\n                                  builtin_bounds: &mut EnumSet<BuiltinBound>)\n                                  -> bool\n     {\n@@ -5993,7 +5972,7 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn item_path_str(&self, id: ast::DefId) -> String {\n+    pub fn item_path_str(&self, id: DefId) -> String {\n         self.with_path(id, |path| ast_map::path_to_string(path))\n     }\n \n@@ -6009,18 +5988,18 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn with_path<T, F>(&self, id: ast::DefId, f: F) -> T where\n+    pub fn with_path<T, F>(&self, id: DefId, f: F) -> T where\n         F: FnOnce(ast_map::PathElems) -> T,\n     {\n-        if id.krate == ast::LOCAL_CRATE {\n+        if id.is_local() {\n             self.map.with_path(id.node, f)\n         } else {\n             f(csearch::get_item_path(self, id).iter().cloned().chain(LinkedPath::empty()))\n         }\n     }\n \n-    pub fn item_name(&self, id: ast::DefId) -> ast::Name {\n-        if id.krate == ast::LOCAL_CRATE {\n+    pub fn item_name(&self, id: DefId) -> ast::Name {\n+        if id.is_local() {\n             self.map.get_path_elem(id.node).name()\n         } else {\n             csearch::get_item_name(self, id)\n@@ -6056,20 +6035,20 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     // Register a given item type\n-    pub fn register_item_type(&self, did: ast::DefId, ty: TypeScheme<'tcx>) {\n+    pub fn register_item_type(&self, did: DefId, ty: TypeScheme<'tcx>) {\n         self.tcache.borrow_mut().insert(did, ty);\n     }\n \n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n-    pub fn lookup_item_type(&self, did: ast::DefId) -> TypeScheme<'tcx> {\n+    pub fn lookup_item_type(&self, did: DefId) -> TypeScheme<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"tcache\", did, &self.tcache,\n             || csearch::get_type(self, did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_trait_def(&self, did: ast::DefId) -> &'tcx TraitDef<'tcx> {\n+    pub fn lookup_trait_def(&self, did: DefId) -> &'tcx TraitDef<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n             || self.arenas.trait_defs.alloc(csearch::get_trait_def(self, did))\n@@ -6079,37 +6058,37 @@ impl<'tcx> ctxt<'tcx> {\n     /// Given the did of an ADT, return a master reference to its\n     /// definition. Unless you are planning on fulfilling the ADT's fields,\n     /// use lookup_adt_def instead.\n-    pub fn lookup_adt_def_master(&self, did: ast::DefId) -> AdtDefMaster<'tcx> {\n+    pub fn lookup_adt_def_master(&self, did: DefId) -> AdtDefMaster<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n             || csearch::get_adt_def(self, did)\n         )\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n-    pub fn lookup_adt_def(&self, did: ast::DefId) -> AdtDef<'tcx> {\n+    pub fn lookup_adt_def(&self, did: DefId) -> AdtDef<'tcx> {\n         // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n         // woud be needed here.\n         self.lookup_adt_def_master(did)\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n-    pub fn lookup_predicates(&self, did: ast::DefId) -> GenericPredicates<'tcx> {\n+    pub fn lookup_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n             || csearch::get_predicates(self, did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n-    pub fn lookup_super_predicates(&self, did: ast::DefId) -> GenericPredicates<'tcx> {\n+    pub fn lookup_super_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n             || csearch::get_super_predicates(self, did))\n     }\n \n     /// Get the attributes of a definition.\n     pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n-        if is_local(did) {\n+        if did.is_local() {\n             Cow::Borrowed(self.map.attrs(did.node))\n         } else {\n             Cow::Owned(csearch::get_item_attrs(&self.sess.cstore, did))\n@@ -6135,7 +6114,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         memoized(&self.repr_hint_cache, did, |did: DefId| {\n-            Rc::new(if did.krate == LOCAL_CRATE {\n+            Rc::new(if did.is_local() {\n                 self.get_attrs(did).iter().flat_map(|meta| {\n                     attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n                 }).collect()\n@@ -6293,7 +6272,7 @@ impl<'tcx> ctxt<'tcx> {\n             .collect()\n     }\n \n-    pub fn item_variances(&self, item_id: ast::DefId) -> Rc<ItemVariances> {\n+    pub fn item_variances(&self, item_id: DefId) -> Rc<ItemVariances> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n             || Rc::new(csearch::get_item_variances(&self.sess.cstore, item_id)))\n@@ -6314,8 +6293,8 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Load primitive inherent implementations if necessary\n     pub fn populate_implementations_for_primitive_if_necessary(&self,\n-                                                               primitive_def_id: ast::DefId) {\n-        if primitive_def_id.krate == LOCAL_CRATE {\n+                                                               primitive_def_id: DefId) {\n+        if primitive_def_id.is_local() {\n             return\n         }\n \n@@ -6336,8 +6315,8 @@ impl<'tcx> ctxt<'tcx> {\n     /// Populates the type context with all the inherent implementations for\n     /// the given type if necessary.\n     pub fn populate_inherent_implementations_for_type_if_necessary(&self,\n-                                                                   type_id: ast::DefId) {\n-        if type_id.krate == LOCAL_CRATE {\n+                                                                   type_id: DefId) {\n+        if type_id.is_local() {\n             return\n         }\n \n@@ -6364,8 +6343,8 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Populates the type context with all the implementations for the given\n     /// trait if necessary.\n-    pub fn populate_implementations_for_trait_if_necessary(&self, trait_id: ast::DefId) {\n-        if trait_id.krate == LOCAL_CRATE {\n+    pub fn populate_implementations_for_trait_if_necessary(&self, trait_id: DefId) {\n+        if trait_id.is_local() {\n             return\n         }\n \n@@ -6411,13 +6390,13 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n-    pub fn trait_id_of_impl(&self, def_id: ast::DefId) -> Option<ast::DefId> {\n+    pub fn trait_id_of_impl(&self, def_id: DefId) -> Option<DefId> {\n         self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n     }\n \n     /// If the given def ID describes a method belonging to an impl, return the\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n-    pub fn impl_of_method(&self, def_id: ast::DefId) -> Option<ast::DefId> {\n+    pub fn impl_of_method(&self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n             return match csearch::get_impl_or_trait_item(self,\n                                                          def_id).container() {\n@@ -6439,7 +6418,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// If the given def ID describes an item belonging to a trait (either a\n     /// default method or an implementation of a trait method), return the ID of\n     /// the trait that the method belongs to. Otherwise, return `None`.\n-    pub fn trait_of_item(&self, def_id: ast::DefId) -> Option<ast::DefId> {\n+    pub fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n             return csearch::get_trait_of_item(&self.sess.cstore, def_id, self);\n         }\n@@ -6460,7 +6439,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// is already that of the original trait method, then the return value is\n     /// the same).\n     /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(&self, def_id: ast::DefId) -> Option<ImplOrTraitItemId> {\n+    pub fn trait_item_of_item(&self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n         let impl_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(m) => m.clone(),\n             None => return None,\n@@ -6506,7 +6485,7 @@ impl<'tcx> ctxt<'tcx> {\n                 }\n             };\n             let did = |state: &mut SipHasher, did: DefId| {\n-                let h = if ast_util::is_local(did) {\n+                let h = if did.is_local() {\n                     svh.clone()\n                 } else {\n                     tcx.sess.cstore.get_crate_hash(did.krate)"}, {"sha": "5d9535dc3dd547b8058a1abcc384fd821cb655b3", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -13,6 +13,7 @@\n //! can be other things. Examples of type relations are subtyping,\n //! type equality, etc.\n \n+use middle::def_id::DefId;\n use middle::subst::{ErasedRegions, NonerasedRegions, ParamSpace, Substs};\n use middle::ty::{self, HasTypeFlags, Ty, TypeError};\n use middle::ty_fold::TypeFoldable;\n@@ -117,7 +118,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TypeAndMut<'tcx> {\n // but they is an important subroutine for things that ARE relatable,\n // like traits etc.\n fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n-                                    item_def_id: ast::DefId,\n+                                    item_def_id: DefId,\n                                     a_subst: &Substs<'tcx>,\n                                     b_subst: &Substs<'tcx>)\n                                     -> RelateResult<'tcx, Substs<'tcx>>"}, {"sha": "96942756b9882f4318f80d787c952bf45b19b8c9", "filename": "src/librustc/middle/wf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Fmiddle%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fwf.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::def_id::DefId;\n use middle::infer::InferCtxt;\n use middle::outlives::{self, Component};\n use middle::subst::Substs;\n@@ -451,7 +452,7 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n     }\n \n     fn nominal_obligations(&mut self,\n-                           def_id: ast::DefId,\n+                           def_id: DefId,\n                            substs: &Substs<'tcx>)\n                            -> Vec<traits::PredicateObligation<'tcx>>\n     {"}, {"sha": "75ccca82ad4101b0e3899c0249b340bbbc8ade63", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,6 +12,7 @@\n \n #![allow(non_snake_case)]\n \n+use middle::def_id::DefId;\n use std::collections::hash_state::DefaultState;\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n@@ -22,10 +23,10 @@ pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n pub type FnvHashSet<V> = HashSet<V, DefaultState<FnvHasher>>;\n \n pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n-pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n+pub type DefIdMap<T> = FnvHashMap<DefId, T>;\n \n pub type NodeSet = FnvHashSet<ast::NodeId>;\n-pub type DefIdSet = FnvHashSet<ast::DefId>;\n+pub type DefIdSet = FnvHashSet<DefId>;\n \n pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n     Default::default()"}, {"sha": "b94711065dfd45d731d137a04d0944939f81296f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n \n+use middle::def_id::DefId;\n use middle::subst::{self, Subst};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n@@ -64,7 +65,7 @@ fn fn_sig(f: &mut fmt::Formatter,\n \n fn parameterized<GG>(f: &mut fmt::Formatter,\n                      substs: &subst::Substs,\n-                     did: ast::DefId,\n+                     did: DefId,\n                      projections: &[ty::ProjectionPredicate],\n                      get_generics: GG)\n                      -> fmt::Result\n@@ -229,7 +230,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrEnv => {\n                 let name = token::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n+                ty::BrNamed(DefId::local(ast::DUMMY_NODE_ID), name)\n             }\n         })\n     }).0;\n@@ -658,7 +659,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n             TyEnum(def, substs) | TyStruct(def, substs) => {\n                 ty::tls::with(|tcx| {\n-                    if def.did.krate == ast::LOCAL_CRATE &&\n+                    if def.did.is_local() &&\n                           !tcx.tcache.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n@@ -673,7 +674,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyClosure(ref did, ref substs) => ty::tls::with(|tcx| {\n                 try!(write!(f, \"[closure\"));\n \n-                if did.krate == ast::LOCAL_CRATE {\n+                if did.is_local() {\n                     try!(write!(f, \"@{:?}\", tcx.map.span(did.node)));\n                     let mut sep = \" \";\n                     try!(tcx.with_freevars(did.node, |freevars| {"}, {"sha": "d10108e3dadbaa1b91d76ba286d07f65a2f78ea1", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -20,6 +20,7 @@ use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n use borrowck::LoanPathElem::{LpDeref, LpInterior};\n use borrowck::move_data::InvalidMovePathIndex;\n use borrowck::move_data::{MoveData, MovePathIndex};\n+use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::ty;\n use rustc::middle::mem_categorization as mc;\n \n@@ -132,7 +133,7 @@ pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n     }\n \n     let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n-    let fn_did = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n+    let fn_did = DefId { krate: LOCAL_CRATE, node: id };\n     let prev = fraginfo_map.insert(fn_did, fragment_infos);\n     assert!(prev.is_none());\n }\n@@ -412,7 +413,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n                                              origin_field_name: &mc::FieldName,\n                                              origin_lp: &Rc<LoanPath<'tcx>>,\n                                              origin_id: Option<ast::NodeId>,\n-                                             enum_variant_info: Option<(ast::DefId,\n+                                             enum_variant_info: Option<(DefId,\n                                                                         Rc<LoanPath<'tcx>>)>) {\n     let parent_ty = parent_lp.to_type();\n \n@@ -509,7 +510,7 @@ fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n                                    mc: mc::MutabilityCategory,\n                                    new_field_name: mc::FieldName,\n                                    origin_lp: &Rc<LoanPath<'tcx>>,\n-                                   enum_variant_did: Option<ast::DefId>) -> MovePathIndex {\n+                                   enum_variant_did: Option<DefId>) -> MovePathIndex {\n     let opt_variant_did = match parent.kind {\n         LpDowncast(_, variant_did) => Some(variant_did),\n         LpVar(..) | LpUpvar(..) | LpExtend(..) => enum_variant_did,"}, {"sha": "4fd8481f3b78ee56e3138bf32c5c5c91dc4f8865", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -27,6 +27,7 @@ use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n+use rustc::middle::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::mem_categorization as mc;\n@@ -349,7 +350,7 @@ impl<'tcx> PartialEq for LoanPath<'tcx> {\n pub enum LoanPathKind<'tcx> {\n     LpVar(ast::NodeId),                         // `x` in README.md\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n-    LpDowncast(Rc<LoanPath<'tcx>>, ast::DefId), // `x` downcast to particular enum variant\n+    LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n     LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem)\n }\n \n@@ -1192,7 +1193,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n-                let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n+                let variant_str = if variant_def_id.is_local() {\n                     ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n@@ -1224,7 +1225,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n-                let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n+                let variant_str = if variant_def_id.is_local() {\n                     ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)"}, {"sha": "d6aaa2a9050514ef312c2cb74f523240ced7b9c9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -30,6 +30,7 @@\n \n use metadata::{csearch, decoder};\n use middle::{cfg, def, infer, pat_util, stability, traits};\n+use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n@@ -44,7 +45,7 @@ use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast};\n-use syntax::ast_util::{self, is_shift_binop, local_def};\n+use syntax::ast_util::is_shift_binop;\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n@@ -400,8 +401,8 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n enum FfiResult {\n     FfiSafe,\n     FfiUnsafe(&'static str),\n-    FfiBadStruct(ast::DefId, &'static str),\n-    FfiBadEnum(ast::DefId, &'static str)\n+    FfiBadStruct(DefId, &'static str),\n+    FfiBadEnum(DefId, &'static str)\n }\n \n /// Check if this enum can be safely exported based on the\n@@ -850,7 +851,7 @@ impl LintPass for RawPointerDerive {\n             }\n             _ => return,\n         };\n-        if !ast_util::is_local(did) {\n+        if !did.is_local() {\n             return;\n         }\n         let item = match cx.tcx.map.find(did.node) {\n@@ -992,7 +993,7 @@ impl LintPass for UnusedResults {\n             ty::TyBool => return,\n             ty::TyStruct(def, _) |\n             ty::TyEnum(def, _) => {\n-                if ast_util::is_local(def.did) {\n+                if def.did.is_local() {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n                         check_must_use(cx, &it.attrs, s.span)\n                     } else {\n@@ -1128,7 +1129,7 @@ enum MethodContext {\n }\n \n fn method_context(cx: &Context, id: ast::NodeId, span: Span) -> MethodContext {\n-    match cx.tcx.impl_or_trait_items.borrow().get(&local_def(id)) {\n+    match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n         None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n         Some(item) => match item.container() {\n             ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n@@ -1951,22 +1952,22 @@ impl LintPass for MissingCopyImplementations {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n-        if cx.tcx.destructor_for_type.borrow().contains_key(&local_def(item.id)) {\n+        if cx.tcx.destructor_for_type.borrow().contains_key(&DefId::local(item.id)) {\n             return;\n         }\n         let ty = match item.node {\n             ast::ItemStruct(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                cx.tcx.mk_struct(cx.tcx.lookup_adt_def(local_def(item.id)),\n+                cx.tcx.mk_struct(cx.tcx.lookup_adt_def(DefId::local(item.id)),\n                                  cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                cx.tcx.mk_enum(cx.tcx.lookup_adt_def(local_def(item.id)),\n+                cx.tcx.mk_enum(cx.tcx.lookup_adt_def(DefId::local(item.id)),\n                                cx.tcx.mk_substs(Substs::empty()))\n             }\n             _ => return,\n@@ -2028,7 +2029,7 @@ impl LintPass for MissingDebugImplementations {\n             let debug_def = cx.tcx.lookup_trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n-                if d.krate == ast::LOCAL_CRATE {\n+                if d.is_local() {\n                     if let Some(ty_def) = cx.tcx.node_id_to_type(d.node).ty_to_def_id() {\n                         impls.insert(ty_def.node);\n                     }\n@@ -2059,7 +2060,7 @@ declare_lint! {\n pub struct Stability;\n \n impl Stability {\n-    fn lint(&self, cx: &Context, _id: ast::DefId,\n+    fn lint(&self, cx: &Context, _id: DefId,\n             span: Span, stability: &Option<&attr::Stability>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n         let (lint, label) = match *stability {\n@@ -2133,7 +2134,7 @@ impl LintPass for UnconditionalRecursion {\n         let method = match fn_kind {\n             visit::FkItemFn(..) => None,\n             visit::FkMethod(..) => {\n-                cx.tcx.impl_or_trait_item(local_def(id)).as_opt_method()\n+                cx.tcx.impl_or_trait_item(DefId::local(id)).as_opt_method()\n             }\n             // closures can't recur, so they don't matter.\n             visit::FkFnBlock => return\n@@ -2247,7 +2248,7 @@ impl LintPass for UnconditionalRecursion {\n             match tcx.map.get(id) {\n                 ast_map::NodeExpr(&ast::Expr { node: ast::ExprCall(ref callee, _), .. }) => {\n                     tcx.def_map.borrow().get(&callee.id)\n-                        .map_or(false, |def| def.def_id() == local_def(fn_id))\n+                        .map_or(false, |def| def.def_id() == DefId::local(fn_id))\n                 }\n                 _ => false\n             }\n@@ -2298,7 +2299,7 @@ impl LintPass for UnconditionalRecursion {\n         // and instantiated with `callee_substs` refers to method `method`.\n         fn method_call_refers_to_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                               method: &ty::Method,\n-                                              callee_id: ast::DefId,\n+                                              callee_id: DefId,\n                                               callee_substs: &Substs<'tcx>,\n                                               expr_id: ast::NodeId) -> bool {\n             let callee_item = tcx.impl_or_trait_item(callee_id);\n@@ -2475,7 +2476,6 @@ impl LintPass for MutableTransmutes {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &ast::Expr) {\n-        use syntax::ast::DefId;\n         use syntax::abi::RustIntrinsic;\n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n                    consider instead using an UnsafeCell\";\n@@ -2569,7 +2569,7 @@ impl LintPass for DropWithReprExtern {\n     fn check_crate(&mut self, ctx: &Context, _: &ast::Crate) {\n         for dtor_did in ctx.tcx.destructors.borrow().iter() {\n             let (drop_impl_did, dtor_self_type) =\n-                if dtor_did.krate == ast::LOCAL_CRATE {\n+                if dtor_did.is_local() {\n                     let impl_did = ctx.tcx.map.get_parent_did(dtor_did.node);\n                     let ty = ctx.tcx.lookup_item_type(impl_did).ty;\n                     (impl_did, ty)"}, {"sha": "ff278f75951469649f90b519219e82a29ec44be4", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -35,6 +35,7 @@ use std::mem::replace;\n \n use rustc::ast_map;\n use rustc::middle::def;\n+use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::ImportUse::*;\n use rustc::middle::privacy::LastPrivate::*;\n use rustc::middle::privacy::PrivateDep::*;\n@@ -43,7 +44,6 @@ use rustc::middle::ty::{self, Ty};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n-use syntax::ast_util::{is_local, local_def};\n use syntax::codemap::Span;\n use syntax::visit::{self, Visitor};\n \n@@ -260,16 +260,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n-                                !is_local(did) ||\n+                                !did.is_local() ||\n                                  self.exported_items.contains(&did.node)\n                             }\n                         }\n                     }\n                     _ => true,\n                 };\n-                let tr = self.tcx.impl_trait_ref(local_def(item.id));\n+                let tr = self.tcx.impl_trait_ref(DefId::local(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n-                    !is_local(tr.def_id) ||\n+                    !tr.def_id.is_local() ||\n                      self.exported_items.contains(&tr.def_id.node)\n                 });\n \n@@ -330,7 +330,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             let did = def.def_id();\n-                            if is_local(did) {\n+                            if did.is_local() {\n                                 self.exported_items.insert(did.node);\n                             }\n                         }\n@@ -359,7 +359,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         if self.prev_exported {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n             for export in self.export_map.get(&id).unwrap() {\n-                if is_local(export.def_id) {\n+                if export.def_id.is_local() {\n                     self.reexports.insert(export.def_id.node);\n                 }\n             }\n@@ -400,8 +400,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n     // Determines whether the given definition is public from the point of view\n     // of the current item.\n-    fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n-        if !is_local(did) {\n+    fn def_privacy(&self, did: DefId) -> PrivacyResult {\n+        if !did.is_local() {\n             if self.external_exports.contains(&did) {\n                 debug!(\"privacy - {:?} was externally exported\", did);\n                 return Allowable;\n@@ -627,8 +627,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     /// Guarantee that a particular definition is public. Returns a CheckResult\n     /// which contains any errors found. These can be reported using `report_error`.\n     /// If the result is `None`, no errors were found.\n-    fn ensure_public(&self, span: Span, to_check: ast::DefId,\n-                     source_did: Option<ast::DefId>, msg: &str) -> CheckResult {\n+    fn ensure_public(&self, span: Span, to_check: DefId,\n+                     source_did: Option<DefId>, msg: &str) -> CheckResult {\n         let id = match self.def_privacy(to_check) {\n             ExternallyDenied => {\n                 return Some((span, format!(\"{} is private\", msg), None))\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                         };\n                         let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n                         let did = def.def_id();\n-                        assert!(is_local(did));\n+                        assert!(did.is_local());\n                         match self.tcx.map.get(did.node) {\n                             ast_map::NodeItem(item) => item,\n                             _ => self.tcx.sess.span_bug(item.span,\n@@ -698,7 +698,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => &v.fields[idx]\n         };\n         if field.vis == ast::Public ||\n-            (is_local(field.did) && self.private_accessible(field.did.node)) {\n+            (field.did.is_local() && self.private_accessible(field.did.node)) {\n             return\n         }\n \n@@ -720,7 +720,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Given the ID of a method, checks to ensure it's in scope.\n     fn check_static_method(&mut self,\n                            span: Span,\n-                           method_id: ast::DefId,\n+                           method_id: DefId,\n                            name: ast::Name) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n@@ -747,7 +747,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n         let path_res = *self.tcx.def_map.borrow().get(&path_id).unwrap();\n         let ck = |tyname: &str| {\n-            let ck_public = |def: ast::DefId| {\n+            let ck_public = |def: DefId| {\n                 debug!(\"privacy - ck_public {:?}\", def);\n                 let origdid = path_res.def_id();\n                 self.ensure_public(span,\n@@ -837,7 +837,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, method_def_id: ast::DefId,\n+    fn check_method(&mut self, span: Span, method_def_id: DefId,\n                     name: ast::Name) {\n         match self.tcx.impl_or_trait_item(method_def_id).container() {\n             ty::ImplContainer(_) => {\n@@ -923,7 +923,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n                         f.vis != ast::Public && (\n-                            !is_local(f.did) ||\n+                            !f.did.is_local() ||\n                                     !self.private_accessible(f.did.node))\n                         });\n                     if any_priv {\n@@ -1168,7 +1168,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n         };\n         // A path can only be private if:\n         // it's in this crate...\n-        if !is_local(did) {\n+        if !did.is_local() {\n             return false\n         }\n \n@@ -1277,7 +1277,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                               |tr| {\n                         let did = self.tcx.trait_ref_to_def_id(tr);\n \n-                        !is_local(did) || self.trait_is_public(did.node)\n+                        !did.is_local() || self.trait_is_public(did.node)\n                     });\n \n                 // `true` iff this is a trait impl or at least one method is public."}, {"sha": "934ae16aeabb971f3608ebd3b1e3b42b40d73d7e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -34,9 +34,10 @@ use self::NamespaceError::*;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n+use rustc::middle::def_id::DefId;\n \n use syntax::ast::{Block, Crate};\n-use syntax::ast::{DeclItem, DefId};\n+use syntax::ast::{DeclItem};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n@@ -50,7 +51,6 @@ use syntax::ast::UnnamedField;\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::Visibility;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::special_idents;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -428,18 +428,18 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n                 let mutbl = m == ast::MutMutable;\n \n-                name_bindings.define_value(DefStatic(local_def(item.id), mutbl), sp, modifiers);\n+                name_bindings.define_value(DefStatic(DefId::local(item.id), mutbl), sp, modifiers);\n                 parent.clone()\n             }\n             ItemConst(_, _) => {\n                 self.add_child(name, parent, ForbidDuplicateValues, sp)\n-                    .define_value(DefConst(local_def(item.id)), sp, modifiers);\n+                    .define_value(DefConst(DefId::local(item.id)), sp, modifiers);\n                 parent.clone()\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n \n-                let def = DefFn(local_def(item.id), false);\n+                let def = DefFn(DefId::local(item.id), false);\n                 name_bindings.define_value(def, sp, modifiers);\n                 parent.clone()\n             }\n@@ -449,12 +449,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings =\n                     self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n-                name_bindings.define_type(DefTy(local_def(item.id), false), sp,\n+                name_bindings.define_type(DefTy(DefId::local(item.id), false), sp,\n                                           modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.set_module_kind(parent_link,\n-                                              Some(local_def(item.id)),\n+                                              Some(DefId::local(item.id)),\n                                               TypeModuleKind,\n                                               false,\n                                               is_public,\n@@ -466,11 +466,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings =\n                     self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n-                name_bindings.define_type(DefTy(local_def(item.id), true), sp, modifiers);\n+                name_bindings.define_type(DefTy(DefId::local(item.id), true), sp, modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.set_module_kind(parent_link,\n-                                              Some(local_def(item.id)),\n+                                              Some(DefId::local(item.id)),\n                                               EnumModuleKind,\n                                               false,\n                                               is_public,\n@@ -481,7 +481,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(\n                         &**variant,\n-                        local_def(item.id),\n+                        DefId::local(item.id),\n                         &module);\n                 }\n                 parent.clone()\n@@ -498,12 +498,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, forbid, sp);\n \n                 // Define a name in the type namespace.\n-                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n+                name_bindings.define_type(DefTy(DefId::local(item.id), false), sp, modifiers);\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if let Some(cid) = ctor_id {\n-                    name_bindings.define_value(DefStruct(local_def(cid)), sp, modifiers);\n+                    name_bindings.define_value(DefStruct(DefId::local(cid)), sp, modifiers);\n                 }\n \n                 // Record the def ID and fields of this struct.\n@@ -513,7 +513,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         UnnamedField(_) => None\n                     }\n                 }).collect();\n-                self.structs.insert(local_def(item.id), named_fields);\n+                self.structs.insert(DefId::local(item.id), named_fields);\n \n                 parent.clone()\n             }\n@@ -528,14 +528,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 // Add all the items within to a new module.\n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.define_module(parent_link,\n-                                            Some(local_def(item.id)),\n+                                            Some(DefId::local(item.id)),\n                                             TraitModuleKind,\n                                             false,\n                                             is_public,\n                                             sp);\n                 let module_parent = name_bindings.get_module();\n \n-                let def_id = local_def(item.id);\n+                let def_id = DefId::local(item.id);\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n@@ -546,25 +546,25 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                     match trait_item.node {\n                         ast::ConstTraitItem(..) => {\n-                            let def = DefAssociatedConst(local_def(trait_item.id));\n+                            let def = DefAssociatedConst(DefId::local(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         ast::MethodTraitItem(..) => {\n-                            let def = DefMethod(local_def(trait_item.id));\n+                            let def = DefMethod(DefId::local(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         ast::TypeTraitItem(..) => {\n-                            let def = DefAssociatedTy(local_def(item.id),\n-                                                      local_def(trait_item.id));\n+                            let def = DefAssociatedTy(DefId::local(item.id),\n+                                                      DefId::local(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_type(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                     }\n \n                     self.trait_item_map.insert((trait_item.ident.name, def_id),\n-                                               local_def(trait_item.id));\n+                                               DefId::local(trait_item.id));\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n@@ -585,7 +585,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             TupleVariantKind(_) => false,\n             StructVariantKind(_) => {\n                 // Not adding fields for variants as they are not accessed with a self receiver\n-                self.structs.insert(local_def(variant.node.id), Vec::new());\n+                self.structs.insert(DefId::local(variant.node.id), Vec::new());\n                 true\n             }\n         };\n@@ -596,10 +596,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // variants are always treated as importable to allow them to be glob\n         // used\n         child.define_value(DefVariant(item_id,\n-                                      local_def(variant.node.id), is_exported),\n+                                      DefId::local(variant.node.id), is_exported),\n                            variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n         child.define_type(DefVariant(item_id,\n-                                     local_def(variant.node.id), is_exported),\n+                                     DefId::local(variant.node.id), is_exported),\n                           variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n     }\n \n@@ -620,10 +620,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n-                DefFn(local_def(foreign_item.id), false)\n+                DefFn(DefId::local(foreign_item.id), false)\n             }\n             ForeignItemStatic(_, m) => {\n-                DefStatic(local_def(foreign_item.id), m)\n+                DefStatic(DefId::local(foreign_item.id), m)\n             }\n         };\n         name_bindings.define_value(def, foreign_item.span, modifiers);"}, {"sha": "69f1c9f2ff30c4ef07f4414aa11f36d6877dc884", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -56,6 +56,7 @@ use rustc::lint;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n+use rustc::middle::def_id::DefId;\n use rustc::middle::pat_util::pat_bindings;\n use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n@@ -65,7 +66,7 @@ use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block};\n use syntax::ast::{ConstImplItem, Crate, CrateNum};\n-use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n+use syntax::ast::{Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n@@ -81,7 +82,7 @@ use syntax::ast::{TyPath, TyPtr};\n use syntax::ast::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::TypeImplItem;\n use syntax::ast;\n-use syntax::ast_util::{local_def, walk_pat};\n+use syntax::ast_util::{walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{self, special_names, special_idents};\n@@ -1255,7 +1256,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n-        if did.krate == ast::LOCAL_CRATE {\n+        if did.is_local() {\n             self.ast_map.expect_item(did.node).ident.name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n@@ -2154,7 +2155,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                TypeSpace,\n                                                                ItemRibKind),\n                                              |this| {\n-                    this.with_self_rib(DefSelfTy(Some(local_def(item.id)), None), |this| {\n+                    this.with_self_rib(DefSelfTy(Some(DefId::local(item.id)), None), |this| {\n                         this.visit_generics(generics);\n                         visit::walk_ty_param_bounds_helper(this, bounds);\n \n@@ -2248,7 +2249,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     function_type_rib.bindings.insert(name,\n                         DlDef(DefTyParam(space,\n                                          index as u32,\n-                                         local_def(type_parameter.id),\n+                                         DefId::local(type_parameter.id),\n                                          name)));\n                 }\n                 self.type_ribs.push(function_type_rib);\n@@ -3466,7 +3467,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         fn is_static_method(this: &Resolver, did: DefId) -> bool {\n-            if did.krate == ast::LOCAL_CRATE {\n+            if did.is_local() {\n                 let sig = match this.ast_map.get(did.node) {\n                     ast_map::NodeTraitItem(trait_item) => match trait_item.node {\n                         ast::MethodTraitItem(ref sig, _) => sig,"}, {"sha": "36ed2c1457954dc665a806915ec3ed1ff7068acc", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         // exports for nonlocal crates.\n \n         match module_.def_id.get() {\n-            Some(def_id) if def_id.krate == ast::LOCAL_CRATE => {\n+            Some(def_id) if def_id.is_local() => {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for local module `{}`\","}, {"sha": "3c2612a1348559f8fec49c96bc60eefddc00e832", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -27,9 +27,10 @@ use {resolve_error, ResolutionError};\n use build_reduced_graph;\n \n use rustc::middle::def::*;\n+use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::*;\n \n-use syntax::ast::{DefId, NodeId, Name};\n+use syntax::ast::{NodeId, Name};\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n "}, {"sha": "6a1517fc39ac63925fcf76979722ea000bca326e", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -33,12 +33,13 @@ use super::{escape, generated_code, recorder, SaveContext, PathCollector, Data};\n use session::Session;\n \n use middle::def;\n+use middle::def_id::DefId;\n use middle::ty::{self, Ty};\n \n use std::fs::File;\n use std::path::Path;\n \n-use syntax::ast::{self, NodeId, DefId};\n+use syntax::ast::{self, NodeId};\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::owned_slice::OwnedSlice;"}, {"sha": "11edcc2272840d8dc3dc3ce58caf3105a22c21f8", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -10,6 +10,7 @@\n \n use middle::ty;\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n \n use std::env;\n use std::fs::{self, File};\n@@ -18,7 +19,7 @@ use std::path::{Path, PathBuf};\n use rustc::ast_map::NodeItem;\n \n use syntax::{attr};\n-use syntax::ast::{self, NodeId, DefId};\n+use syntax::ast::{self, NodeId};\n use syntax::ast_util;\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n@@ -351,15 +352,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                            span: Span) -> FunctionData {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let qualname = match self.tcx.impl_of_method(ast_util::local_def(id)) {\n+        let qualname = match self.tcx.impl_of_method(DefId::local(id)) {\n             Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&ty_to_string(&**ty));\n \n-                            match self.tcx.trait_of_item(ast_util::local_def(id)) {\n+                            match self.tcx.trait_of_item(DefId::local(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n@@ -383,7 +384,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                  impl_id.node, id, self.tcx.map.get(impl_id.node)));\n                 },\n             },\n-            None => match self.tcx.trait_of_item(ast_util::local_def(id)) {\n+            None => match self.tcx.trait_of_item(DefId::local(id)) {\n                 Some(def_id) => {\n                     match self.tcx.map.get(def_id.node) {\n                         NodeItem(_) => {\n@@ -405,10 +406,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let qualname = format!(\"{}::{}\", qualname, name);\n \n-        let decl_id = self.tcx.trait_item_of_item(ast_util::local_def(id))\n+        let decl_id = self.tcx.trait_item_of_item(DefId::local(id))\n             .and_then(|new_id| {\n                 let def_id = new_id.def_id();\n-                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n+                if def_id.node != 0 && def_id != DefId::local(id) {\n                     Some(def_id)\n                 } else {\n                     None\n@@ -545,7 +546,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             def::DefMethod(decl_id) => {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n-                let def_id = if decl_id.krate == ast::LOCAL_CRATE {\n+                let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.impl_or_trait_item(decl_id);\n                     match ti.container() {\n                         ty::TraitContainer(def_id) => {\n@@ -599,7 +600,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     fn trait_method_has_body(&self, mr: &ty::ImplOrTraitItem) -> bool {\n         let def_id = mr.def_id();\n-        if def_id.krate != ast::LOCAL_CRATE {\n+        if def_id.krate != LOCAL_CRATE {\n             return false;\n         }\n "}, {"sha": "f9c3bf0694b1ec64fd48ebf7b06269c1fa0be62c", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -13,10 +13,12 @@ pub use self::Row::*;\n use super::escape;\n use super::span_utils::SpanUtils;\n \n+use middle::def_id::DefId;\n+\n use std::io::Write;\n \n use syntax::ast;\n-use syntax::ast::{NodeId,DefId};\n+use syntax::ast::{NodeId};\n use syntax::codemap::*;\n \n const ZERO_DEF_ID: DefId = DefId { node: 0, krate: 0 };"}, {"sha": "352075dc3db4abe1b6a17f6a0eae53c008e6a437", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -194,6 +194,7 @@ use middle::check_match::StaticInliner;\n use middle::check_match;\n use middle::const_eval;\n use middle::def::{self, DefMap};\n+use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::lang_items::StrEqFnLangItem;\n@@ -247,7 +248,7 @@ impl<'a> ConstantExpr<'a> {\n enum Opt<'a, 'tcx> {\n     ConstantValue(ConstantExpr<'a>, DebugLoc),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>, DebugLoc),\n-    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId, DebugLoc),\n+    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, DefId, DebugLoc),\n     SliceLengthEqual(usize, DebugLoc),\n     SliceLengthGreaterOrEqual(/* prefix length */ usize,\n                               /* suffix length */ usize,"}, {"sha": "2adc4e1944ea67668fa3214bf78e002d3d23afe9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -37,6 +37,7 @@ use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::pat_util::simple_identifier;\n@@ -92,7 +93,6 @@ use std::mem;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, PlatformIntrinsic, Abi};\n-use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -179,7 +179,7 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n }\n \n fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n-                                name: &str, did: ast::DefId) -> ValueRef {\n+                                name: &str, did: DefId) -> ValueRef {\n     match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n         None => ()\n@@ -195,7 +195,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n }\n \n pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       closure_id: ast::DefId,\n+                                       closure_id: DefId,\n                                        fn_ty: Ty<'tcx>)\n                                        -> Ty<'tcx>\n {\n@@ -211,11 +211,11 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n+pub fn kind_for_closure(ccx: &CrateContext, closure_id: DefId) -> ty::ClosureKind {\n     *ccx.tcx().tables.borrow().closure_kinds.get(&closure_id).unwrap()\n }\n \n-pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n+pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: DefId,\n                                   t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     let ty = type_of(ccx, t);\n@@ -245,7 +245,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n }\n \n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                info_ty: Ty<'tcx>, it: LangItem) -> ast::DefId {\n+                                info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n@@ -663,7 +663,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n }\n \n pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     did: ast::DefId, t: Ty<'tcx>) -> ValueRef {\n+                                     did: DefId, t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match t.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n@@ -1294,7 +1294,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n \n     // Create the drop-flag hints for every unfragmented path in the function.\n     let tcx = fcx.ccx.tcx();\n-    let fn_did = ast::DefId { krate: ast::LOCAL_CRATE, node: fcx.id };\n+    let fn_did = DefId { krate: LOCAL_CRATE, node: fcx.id };\n     let mut hints = fcx.lldropflag_hints.borrow_mut();\n     let fragment_infos = tcx.fragment_infos.borrow();\n \n@@ -2080,7 +2080,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     // error in trans. This is used to write compile-fail tests\n                     // that actually test that compilation succeeds without\n                     // reporting an error.\n-                    if ccx.tcx().has_attr(local_def(item.id), \"rustc_error\") {\n+                    if ccx.tcx().has_attr(DefId::local(item.id), \"rustc_error\") {\n                         ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n                     }\n                 }\n@@ -2247,7 +2247,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                     Ok(id) => id,\n                     Err(s) => { ccx.sess().fatal(&s[..]); }\n                 };\n-                let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n+                let start_fn = if start_def_id.is_local() {\n                     get_item_val(ccx, start_def_id.node)\n                 } else {\n                     let start_fn_type = csearch::get_type(ccx.tcx(),"}, {"sha": "f5dead996fb3e36f672c5e37254da7fa9d907ec1", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -23,6 +23,7 @@ use back::link;\n use session;\n use llvm::{self, ValueRef, get_params};\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use trans::adt;\n@@ -222,7 +223,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n /// Translates a reference (with id `ref_id`) to the fn/method with id `def_id` into a function\n /// pointer. This may require monomorphization or inlining.\n pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              def_id: ast::DefId,\n+                              def_id: DefId,\n                               node: ExprOrMethodCall,\n                               param_substs: &'tcx subst::Substs<'tcx>)\n                               -> Datum<'tcx, Rvalue> {\n@@ -375,7 +376,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n /// - `substs`: values for each of the fn/method's parameters\n pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n-    def_id: ast::DefId,\n+    def_id: DefId,\n     node: ExprOrMethodCall,\n     param_substs: &'tcx subst::Substs<'tcx>,\n     substs: subst::Substs<'tcx>)\n@@ -463,7 +464,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // or is a named tuple constructor.\n     let must_monomorphise = if !substs.types.is_empty() || is_default {\n         true\n-    } else if def_id.krate == ast::LOCAL_CRATE {\n+    } else if def_id.is_local() {\n         let map_node = session::expect(\n             ccx.sess(),\n             tcx.map.find(def_id.node),\n@@ -487,7 +488,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // Create a monomorphic version of generic functions\n     if must_monomorphise {\n         // Should be either intra-crate or inlined.\n-        assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+        assert_eq!(def_id.krate, LOCAL_CRATE);\n \n         let opt_ref_id = match node {\n             ExprId(id) => if id != 0 { Some(id) } else { None },\n@@ -523,7 +524,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n     // Find the actual function pointer.\n     let mut val = {\n-        if def_id.krate == ast::LOCAL_CRATE {\n+        if def_id.is_local() {\n             // Internal reference.\n             get_item_val(ccx, def_id.node)\n         } else {\n@@ -604,7 +605,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   did: ast::DefId,\n+                                   did: DefId,\n                                    args: &[ValueRef],\n                                    dest: Option<expr::Dest>,\n                                    debug_loc: DebugLoc)"}, {"sha": "ef40c8a099c165f90c4225e80453f508d11516b5", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -11,6 +11,7 @@\n use arena::TypedArena;\n use back::link::{self, mangle_internal_name_by_path_and_seq};\n use llvm::{ValueRef, get_params};\n+use middle::def_id::DefId;\n use middle::infer;\n use trans::adt;\n use trans::attributes;\n@@ -30,7 +31,6 @@ use session::config::FullDebugInfo;\n \n use syntax::abi::RustCall;\n use syntax::ast;\n-use syntax::ast_util;\n \n \n fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -41,7 +41,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n \n     // Special case for small by-value selfs.\n-    let closure_id = ast_util::local_def(bcx.fcx.id);\n+    let closure_id = DefId::local(bcx.fcx.id);\n     let self_type = self_type_for_closure(bcx.ccx(), closure_id,\n                                                   node_id_type(bcx, closure_id.node));\n     let kind = kind_for_closure(bcx.ccx(), closure_id);\n@@ -128,7 +128,7 @@ impl<'a> ClosureEnv<'a> {\n /// Returns the LLVM function declaration for a closure, creating it if\n /// necessary. If the ID does not correspond to a closure ID, returns None.\n pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                   closure_id: ast::DefId,\n+                                                   closure_id: DefId,\n                                                    substs: &ty::ClosureSubsts<'tcx>)\n                                                    -> ValueRef {\n     // Normalize type so differences in regions and typedefs don't cause\n@@ -188,7 +188,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n     debug!(\"trans_closure_expr()\");\n \n-    let closure_id = ast_util::local_def(id);\n+    let closure_id = DefId::local(id);\n     let llfn = get_or_create_closure_declaration(ccx, closure_id, closure_substs);\n \n     // Get the type of this closure. Use the current `param_substs` as\n@@ -250,7 +250,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n }\n \n pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                      closure_def_id: ast::DefId,\n+                                      closure_def_id: DefId,\n                                       substs: ty::ClosureSubsts<'tcx>,\n                                       trait_closure_kind: ty::ClosureKind)\n                                       -> ValueRef\n@@ -271,7 +271,7 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n \n fn trans_closure_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n-    closure_def_id: ast::DefId,\n+    closure_def_id: DefId,\n     substs: ty::ClosureSubsts<'tcx>,\n     llfn_closure_kind: ty::ClosureKind,\n     trait_closure_kind: ty::ClosureKind,\n@@ -323,7 +323,7 @@ fn trans_closure_adapter_shim<'a, 'tcx>(\n \n fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n-    closure_def_id: ast::DefId,\n+    closure_def_id: DefId,\n     substs: ty::ClosureSubsts<'tcx>,\n     llreffn: ValueRef)\n     -> ValueRef"}, {"sha": "0ae518fea2bd37ea4c3d162d29e2babdb9f63018", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -20,6 +20,7 @@ use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n use middle::cfg;\n use middle::def;\n+use middle::def_id::DefId;\n use middle::infer;\n use middle::lang_items::LangItem;\n use middle::subst::{self, Substs};\n@@ -49,7 +50,6 @@ use std::cell::{Cell, RefCell};\n use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -1228,7 +1228,7 @@ pub fn langcall(bcx: Block,\n                 span: Option<Span>,\n                 msg: &str,\n                 li: LangItem)\n-                -> ast::DefId {\n+                -> DefId {\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,\n         Err(s) => {\n@@ -1257,7 +1257,7 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n     adt_def.variants.iter().find(|v| {\n-        local_def(inlined_vid) == v.did ||\n+        DefId::local(inlined_vid) == v.did ||\n             ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n     }).unwrap_or_else(|| {\n         ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))"}, {"sha": "5b6da5dadd580fcb3755b0f30ba547ed8c1f554f", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -25,6 +25,7 @@ use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::const_eval::eval_const_expr_partial;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n@@ -39,7 +40,7 @@ use util::nodemap::NodeMap;\n \n use std::ffi::{CStr, CString};\n use libc::c_uint;\n-use syntax::{ast, ast_util, attr};\n+use syntax::{ast, attr};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -170,7 +171,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            node: ExprOrMethodCall,\n-                           def_id: ast::DefId,\n+                           def_id: DefId,\n                            arg_vals: &[ValueRef],\n                            param_substs: &'tcx Substs<'tcx>) -> ValueRef {\n     let fn_like = const_eval::lookup_const_fn_by_id(ccx.tcx(), def_id);\n@@ -192,12 +193,12 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                def_id: ast::DefId,\n+                                def_id: DefId,\n                                 ref_expr: &ast::Expr)\n                                 -> &'tcx ast::Expr {\n     let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n \n-    if def_id.krate != ast::LOCAL_CRATE {\n+    if def_id.krate != LOCAL_CRATE {\n         ccx.sess().span_bug(ref_expr.span,\n                             \"cross crate constant could not be inlined\");\n     }\n@@ -211,7 +212,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n fn get_const_val(ccx: &CrateContext,\n-                 def_id: ast::DefId,\n+                 def_id: DefId,\n                  ref_expr: &ast::Expr) -> ValueRef {\n     let expr = get_const_expr(ccx, def_id, ref_expr);\n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n@@ -963,8 +964,10 @@ pub fn trans_static(ccx: &CrateContext,\n }\n \n \n-fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n-                            ty: Ty<'tcx>) -> ValueRef {\n-    if ast_util::is_local(did) { return base::get_item_val(ccx, did.node) }\n+fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                            did: DefId,\n+                            ty: Ty<'tcx>)\n+                            -> ValueRef {\n+    if did.is_local() { return base::get_item_val(ccx, did.node) }\n     base::trans_external_path(ccx, did, ty)\n }"}, {"sha": "fd8dbe83add8bac5172b7afea742d0fbd31cc5af", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,6 +12,7 @@ use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n use metadata::common::LinkMeta;\n use middle::def::ExportMap;\n+use middle::def_id::DefId;\n use middle::traits;\n use trans::adt;\n use trans::base;\n@@ -91,7 +92,7 @@ pub struct LocalCrateContext<'tcx> {\n     external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n     /// came from)\n-    external_srcs: RefCell<NodeMap<ast::DefId>>,\n+    external_srcs: RefCell<NodeMap<DefId>>,\n     /// Cache instances of monomorphized functions\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<usize>>,\n@@ -120,7 +121,7 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n-    impl_method_cache: RefCell<FnvHashMap<(ast::DefId, ast::Name), ast::DefId>>,\n+    impl_method_cache: RefCell<FnvHashMap<(DefId, ast::Name), DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n     closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n@@ -626,7 +627,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.external\n     }\n \n-    pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<ast::DefId>> {\n+    pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<DefId>> {\n         &self.local.external_srcs\n     }\n \n@@ -664,7 +665,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn impl_method_cache<'a>(&'a self)\n-            -> &'a RefCell<FnvHashMap<(ast::DefId, ast::Name), ast::DefId>> {\n+            -> &'a RefCell<FnvHashMap<(DefId, ast::Name), DefId>> {\n         &self.local.impl_method_cache\n     }\n "}, {"sha": "37d3009a34b7e44c9e68df9a352e57b36909edb5", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -23,6 +23,7 @@ use super::{declare_local, VariableKind, VariableAccess};\n use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n \n+use middle::def_id::DefId;\n use middle::pat_util;\n use middle::subst::{self, Substs};\n use rustc::ast_map;\n@@ -42,7 +43,7 @@ use std::ptr;\n use std::rc::Rc;\n use syntax::util::interner::Interner;\n use syntax::codemap::Span;\n-use syntax::{ast, codemap, ast_util};\n+use syntax::{ast, codemap};\n use syntax::parse::token;\n \n \n@@ -316,12 +317,12 @@ impl<'tcx> TypeMap<'tcx> {\n \n         fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n                                             cx: &CrateContext<'a, 'tcx>,\n-                                            def_id: ast::DefId,\n+                                            def_id: DefId,\n                                             substs: &subst::Substs<'tcx>,\n                                             output: &mut String) {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n-            let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n+            let source_def_id = if def_id.is_local() {\n                 match cx.external_srcs().borrow().get(&def_id.node).cloned() {\n                     Some(source_def_id) => {\n                         // The given def_id identifies the inlined copy of a\n@@ -335,7 +336,7 @@ impl<'tcx> TypeMap<'tcx> {\n             };\n \n             // Get the crate hash as first part of the identifier.\n-            let crate_hash = if source_def_id.krate == ast::LOCAL_CRATE {\n+            let crate_hash = if source_def_id.is_local() {\n                 cx.link_meta().crate_hash.clone()\n             } else {\n                 cx.sess().cstore.get_crate_hash(source_def_id.krate)\n@@ -1574,7 +1575,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n-                                   enum_def_id: ast::DefId,\n+                                   enum_def_id: DefId,\n                                    unique_type_id: UniqueTypeId,\n                                    span: Span)\n                                    -> RecursiveTypeDescription<'tcx> {\n@@ -1699,7 +1700,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     );\n \n     fn get_enum_discriminant_name(cx: &CrateContext,\n-                                  def_id: ast::DefId)\n+                                  def_id: DefId)\n                                   -> token::InternedString {\n         cx.tcx().item_name(def_id).as_str()\n     }\n@@ -1884,7 +1885,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n     let variable_type = cx.tcx().node_id_to_type(node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n+    let namespace_node = namespace_for_item(cx, DefId::local(node_id));\n     let var_name = name.to_string();\n     let linkage_name =\n         namespace_node.mangled_name_of_contained_item(&var_name[..]);"}, {"sha": "1882bfd3eb63e3d3dac26b282e3ceae2d2189269", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -26,6 +26,7 @@ use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n                       DIDescriptor, FlagPrototyped};\n+use middle::def_id::DefId;\n use middle::subst::{self, Substs};\n use rustc::ast_map;\n use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n@@ -75,7 +76,7 @@ pub struct CrateDebugContext<'tcx> {\n     builder: DIBuilderRef,\n     current_debug_location: Cell<InternalDebugLocation>,\n     created_files: RefCell<FnvHashMap<String, DIFile>>,\n-    created_enum_disr_types: RefCell<FnvHashMap<(ast::DefId, IntType), DIType>>,\n+    created_enum_disr_types: RefCell<FnvHashMap<(DefId, IntType), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n     namespace_map: RefCell<FnvHashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n@@ -345,7 +346,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // somehow (storing a path in the ast_map, or construct a path using the\n     // enclosing function).\n     let (linkage_name, containing_scope) = if has_path {\n-        let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n+        let namespace_node = namespace_for_item(cx, DefId::local(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n             &function_name[..]);\n         let containing_scope = namespace_node.scope;"}, {"sha": "7125a890d4c34626b1e5ef447fca7bff51bcb94f", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -15,6 +15,7 @@ use super::utils::{DIB, debug_context};\n use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::ast_map;\n+use rustc::middle::def_id::DefId;\n use trans::common::CrateContext;\n \n use std::ffi::CString;\n@@ -54,10 +55,10 @@ pub fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n     &cx.link_meta().crate_name\n }\n \n-pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n+pub fn namespace_for_item(cx: &CrateContext, def_id: DefId) -> Rc<NamespaceTreeNode> {\n     cx.tcx().with_path(def_id, |path| {\n         // prepend crate name if not already present\n-        let krate = if def_id.krate == ast::LOCAL_CRATE {\n+        let krate = if def_id.is_local() {\n             let crate_namespace_name = token::intern(crate_root_namespace(cx));\n             Some(ast_map::PathMod(crate_namespace_name))\n         } else {"}, {"sha": "0535e9986f5b9de257b90395fb69a8516f12374d", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -13,6 +13,7 @@\n use super::namespace::crate_root_namespace;\n \n use trans::common::CrateContext;\n+use middle::def_id::DefId;\n use middle::subst::{self, Substs};\n use middle::ty::{self, Ty};\n \n@@ -166,12 +167,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     fn push_item_name(cx: &CrateContext,\n-                      def_id: ast::DefId,\n+                      def_id: DefId,\n                       qualified: bool,\n                       output: &mut String) {\n         cx.tcx().with_path(def_id, |path| {\n             if qualified {\n-                if def_id.krate == ast::LOCAL_CRATE {\n+                if def_id.is_local() {\n                     output.push_str(crate_root_namespace(cx));\n                     output.push_str(\"::\");\n                 }"}, {"sha": "09d014a33823eeb80efc7d4e721625373eac636d", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -13,6 +13,8 @@\n use super::{FunctionDebugContext, CrateDebugContext};\n use super::namespace::namespace_for_item;\n \n+use middle::def_id::DefId;\n+\n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n use trans::machine;\n@@ -94,10 +96,10 @@ pub fn assert_type_for_node_id(cx: &CrateContext,\n     }\n }\n \n-pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n+pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n                                    -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id).scope;\n-    let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n+    let definition_span = if def_id.is_local() {\n         cx.tcx().map.span(def_id.node)\n     } else {\n         // For external items there is no span information"}, {"sha": "aea010e7d97b7f955f648fdcd1fd0c8f7b037244", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -900,7 +900,7 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             // For external constants, we don't inline.\n-            let val = if did.krate == ast::LOCAL_CRATE {\n+            let val = if did.is_local() {\n                 // Case 1.\n \n                 // The LLVM global has the type of its initializer,"}, {"sha": "5a1988d3fc74c719401b7bc12db02f59e353ba9c", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -18,6 +18,7 @@ use back::link::*;\n use llvm;\n use llvm::{ValueRef, get_param};\n use metadata::csearch;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n@@ -288,8 +289,8 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       t: Ty<'tcx>,\n                                       struct_data: ValueRef,\n-                                      dtor_did: ast::DefId,\n-                                      class_did: ast::DefId,\n+                                      dtor_did: DefId,\n+                                      class_did: DefId,\n                                       substs: &subst::Substs<'tcx>)\n                                       -> Block<'blk, 'tcx> {\n     assert!(type_is_sized(bcx.tcx(), t), \"Precondition: caller must ensure t is sized\");\n@@ -323,23 +324,23 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n }\n \n pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              did: ast::DefId,\n-                              parent_id: ast::DefId,\n+                              did: DefId,\n+                              parent_id: DefId,\n                               substs: &Substs<'tcx>)\n                               -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n     let did = inline::maybe_instantiate_inline(ccx, did);\n \n     if !substs.types.is_empty() {\n-        assert_eq!(did.krate, ast::LOCAL_CRATE);\n+        assert_eq!(did.krate, LOCAL_CRATE);\n \n         // Since we're in trans we don't care for any region parameters\n         let substs = ccx.tcx().mk_substs(Substs::erased(substs.types.clone()));\n \n         let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n \n         val\n-    } else if did.krate == ast::LOCAL_CRATE {\n+    } else if did.is_local() {\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx();\n@@ -354,8 +355,8 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  t: Ty<'tcx>,\n                                  v0: ValueRef,\n-                                 dtor_did: ast::DefId,\n-                                 class_did: ast::DefId,\n+                                 dtor_did: DefId,\n+                                 class_did: DefId,\n                                  substs: &subst::Substs<'tcx>)\n                                  -> Block<'blk, 'tcx>\n {"}, {"sha": "8c20b85b7c35dcee0b49f2b2e0483e9f7a3edb38", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,15 +12,15 @@ use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use metadata::csearch;\n use metadata::inline::InlinedItem;\n use middle::astencode;\n+use middle::def_id::DefId;\n use middle::subst::Substs;\n use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use trans::common::*;\n \n use syntax::ast;\n-use syntax::ast_util::local_def;\n \n-fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n-    -> Option<ast::DefId> {\n+fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n+    -> Option<DefId> {\n     debug!(\"instantiate_inline({:?})\", fn_id);\n     let _icx = push_ctxt(\"instantiate_inline\");\n \n@@ -29,7 +29,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             // Already inline\n             debug!(\"instantiate_inline({}): already inline as node id {}\",\n                    ccx.tcx().item_path_str(fn_id), node_id);\n-            return Some(local_def(node_id));\n+            return Some(DefId::local(node_id));\n         }\n         Some(&None) => {\n             return None; // Not inlinable\n@@ -144,7 +144,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             // inlined items.\n             let ty_trait_item = ccx.tcx().impl_or_trait_item(fn_id).clone();\n             ccx.tcx().impl_or_trait_items.borrow_mut()\n-                     .insert(local_def(trait_item.id), ty_trait_item);\n+                     .insert(DefId::local(trait_item.id), ty_trait_item);\n \n             // If this is a default method, we can't look up the\n             // impl type. But we aren't going to translate anyways, so\n@@ -184,18 +184,18 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n         }\n     };\n \n-    Some(local_def(inline_id))\n+    Some(DefId::local(inline_id))\n }\n \n-pub fn get_local_instance(ccx: &CrateContext, fn_id: ast::DefId)\n-    -> Option<ast::DefId> {\n-    if fn_id.krate == ast::LOCAL_CRATE {\n+pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)\n+    -> Option<DefId> {\n+    if fn_id.is_local() {\n         Some(fn_id)\n     } else {\n         instantiate_inline(ccx, fn_id)\n     }\n }\n \n-pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId) -> ast::DefId {\n+pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> DefId {\n     get_local_instance(ccx, fn_id).unwrap_or(fn_id)\n }"}, {"sha": "9d0cd3422727582fba2d5c8ef0d4290d5b143cf0", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,6 +12,7 @@ use arena::TypedArena;\n use back::abi;\n use back::link;\n use llvm::{ValueRef, get_params};\n+use middle::def_id::DefId;\n use middle::subst::{Subst, Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n@@ -148,8 +149,8 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                            method_id: ast::DefId,\n-                                            trait_id: ast::DefId,\n+                                            method_id: DefId,\n+                                            trait_id: DefId,\n                                             expr_id: ast::NodeId,\n                                             param_substs: &'tcx subst::Substs<'tcx>)\n                                             -> Datum<'tcx, Rvalue>\n@@ -265,8 +266,8 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n-                    -> ast::DefId {\n+fn method_with_name(ccx: &CrateContext, impl_id: DefId, name: ast::Name)\n+                    -> DefId {\n     match ccx.impl_method_cache().borrow().get(&(impl_id, name)).cloned() {\n         Some(m) => return m,\n         None => {}\n@@ -290,8 +291,8 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n                                           self_expr: Option<&ast::Expr>,\n-                                          trait_id: ast::DefId,\n-                                          method_id: ast::DefId,\n+                                          trait_id: DefId,\n+                                          method_id: DefId,\n                                           method_ty: Ty<'tcx>,\n                                           vtable: traits::Vtable<'tcx, ()>,\n                                           arg_cleanup_scope: cleanup::ScopeId)\n@@ -507,7 +508,7 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-    method_id: ast::DefId,\n+    method_id: DefId,\n     vtable_index: usize)\n     -> Datum<'tcx, Rvalue>\n {\n@@ -677,7 +678,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 impl_id: ast::DefId,\n+                                 impl_id: DefId,\n                                  substs: subst::Substs<'tcx>,\n                                  param_substs: &'tcx subst::Substs<'tcx>)\n                                  -> Vec<ValueRef>"}, {"sha": "c671f2c91f65e207e5388f6679696e77ecbbcf71", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,6 +12,7 @@ use back::link::exported_name;\n use session;\n use llvm::ValueRef;\n use llvm;\n+use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n@@ -34,7 +35,7 @@ use syntax::codemap::DUMMY_SP;\n use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                fn_id: ast::DefId,\n+                                fn_id: DefId,\n                                 psubsts: &'tcx subst::Substs<'tcx>,\n                                 ref_id: Option<ast::NodeId>)\n     -> (ValueRef, Ty<'tcx>, bool) {\n@@ -272,7 +273,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct MonoId<'tcx> {\n-    pub def: ast::DefId,\n+    pub def: DefId,\n     pub params: &'tcx subst::VecPerParamSpace<Ty<'tcx>>\n }\n "}, {"sha": "c8ea6e6ec427138d56798b27d87f96e3cc2d079f", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::def_id::DefId;\n use middle::subst;\n use trans::adt;\n use trans::common::*;\n@@ -469,7 +470,7 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n }\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                            did: ast::DefId,\n+                            did: DefId,\n                             tps: &[Ty<'tcx>])\n                             -> String {\n     let base = cx.tcx().item_path_str(did);"}, {"sha": "f14f196f1aebb67ff522447e0fe13cfefd37ac72", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -52,6 +52,7 @@ use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::wf::object_region_bounds;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n@@ -67,7 +68,7 @@ use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n \n use std::slice;\n-use syntax::{abi, ast, ast_util};\n+use syntax::{abi, ast};\n use syntax::codemap::{Span, Pos};\n use syntax::feature_gate::emit_feature_err;\n use syntax::parse::token;\n@@ -79,18 +80,18 @@ pub trait AstConv<'tcx> {\n     /// Identify the type scheme for an item with a type, like a type\n     /// alias, fn, or struct. This allows you to figure out the set of\n     /// type parameters defined on the item.\n-    fn get_item_type_scheme(&self, span: Span, id: ast::DefId)\n+    fn get_item_type_scheme(&self, span: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>;\n \n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n-    fn get_trait_def(&self, span: Span, id: ast::DefId)\n+    fn get_trait_def(&self, span: Span, id: DefId)\n                      -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>;\n \n     /// Ensure that the super-predicates for the trait with the given\n     /// id are available and also for the transitive set of\n     /// super-predicates.\n-    fn ensure_super_predicates(&self, span: Span, id: ast::DefId)\n+    fn ensure_super_predicates(&self, span: Span, id: DefId)\n                                -> Result<(), ErrorReported>;\n \n     /// Returns the set of bounds in scope for the type parameter with\n@@ -100,7 +101,7 @@ pub trait AstConv<'tcx> {\n \n     /// Returns true if the trait with id `trait_def_id` defines an\n     /// associated type with the name `name`.\n-    fn trait_defines_associated_type_named(&self, trait_def_id: ast::DefId, name: ast::Name)\n+    fn trait_defines_associated_type_named(&self, trait_def_id: DefId, name: ast::Name)\n                                            -> bool;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n@@ -164,7 +165,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n         }\n \n         Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n-            ty::ReLateBound(debruijn, ty::BrNamed(ast_util::local_def(id), lifetime.name))\n+            ty::ReLateBound(debruijn, ty::BrNamed(DefId::local(id), lifetime.name))\n         }\n \n         Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n@@ -179,7 +180,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n         Some(&rl::DefFreeRegion(scope, id)) => {\n             ty::ReFree(ty::FreeRegion {\n                     scope: scope,\n-                    bound_region: ty::BrNamed(ast_util::local_def(id),\n+                    bound_region: ty::BrNamed(DefId::local(id),\n                                               lifetime.name)\n                 })\n         }\n@@ -667,7 +668,7 @@ pub fn instantiate_mono_trait_ref<'tcx>(\n                                trait_ref.path.segments.last().unwrap())\n }\n \n-fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &ast::TraitRef) -> ast::DefId {\n+fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &ast::TraitRef) -> DefId {\n     let path = &trait_ref.path;\n     match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => trait_def_id,\n@@ -683,7 +684,7 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n-    trait_def_id: ast::DefId,\n+    trait_def_id: DefId,\n     trait_segment: &ast::PathSegment,\n     mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n@@ -703,7 +704,7 @@ fn ast_path_to_poly_trait_ref<'a,'tcx>(\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n-    trait_def_id: ast::DefId,\n+    trait_def_id: DefId,\n     self_ty: Option<Ty<'tcx>>,\n     trait_segment: &ast::PathSegment,\n     poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n@@ -749,7 +750,7 @@ fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n                                        rscope: &RegionScope,\n                                        span: Span,\n                                        param_mode: PathParamMode,\n-                                       trait_def_id: ast::DefId,\n+                                       trait_def_id: DefId,\n                                        self_ty: Option<Ty<'tcx>>,\n                                        trait_segment: &ast::PathSegment)\n                                        -> ty::TraitRef<'tcx>\n@@ -770,7 +771,7 @@ fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n                                             rscope: &RegionScope,\n                                             span: Span,\n                                             param_mode: PathParamMode,\n-                                            trait_def_id: ast::DefId,\n+                                            trait_def_id: DefId,\n                                             self_ty: Option<Ty<'tcx>>,\n                                             trait_segment: &ast::PathSegment)\n                                             -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n@@ -918,7 +919,7 @@ fn ast_path_to_ty<'tcx>(\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n-    did: ast::DefId,\n+    did: DefId,\n     item_segment: &ast::PathSegment)\n     -> Ty<'tcx>\n {\n@@ -1075,7 +1076,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n         return tcx.types.err;\n     }\n \n-    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> =\n+    let mut associated_types: FnvHashSet<(DefId, ast::Name)> =\n         traits::supertraits(tcx, object_trait_ref)\n         .flat_map(|tr| {\n             let trait_def = tcx.lookup_trait_def(tr.def_id());\n@@ -1214,7 +1215,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         (_, def::DefSelfTy(Some(trait_did), Some((impl_id, _)))) => {\n             // `Self` in an impl of a trait - we have a concrete self type and a\n             // trait reference.\n-            let trait_ref = tcx.impl_trait_ref(ast_util::local_def(impl_id)).unwrap();\n+            let trait_ref = tcx.impl_trait_ref(DefId::local(impl_id)).unwrap();\n             let trait_ref = if let Some(free_substs) = this.get_free_substs() {\n                 trait_ref.subst(tcx, free_substs)\n             } else {\n@@ -1241,7 +1242,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         (&ty::TyParam(_), def::DefSelfTy(Some(trait_did), None)) => {\n-            assert_eq!(trait_did.krate, ast::LOCAL_CRATE);\n+            assert_eq!(trait_did.krate, LOCAL_CRATE);\n             match find_bound_for_assoc_item(this,\n                                             trait_did.node,\n                                             token::special_idents::type_self.name,\n@@ -1252,7 +1253,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         (&ty::TyParam(_), def::DefTyParam(_, _, param_did, param_name)) => {\n-            assert_eq!(param_did.krate, ast::LOCAL_CRATE);\n+            assert_eq!(param_did.krate, LOCAL_CRATE);\n             match find_bound_for_assoc_item(this,\n                                             param_did.node,\n                                             param_name,\n@@ -1275,15 +1276,15 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let trait_did = bound.0.def_id;\n     let ty = this.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n \n-    let item_did = if trait_did.krate == ast::LOCAL_CRATE {\n+    let item_did = if trait_did.is_local() {\n         // `ty::trait_items` used below requires information generated\n         // by type collection, which may be in progress at this point.\n         match tcx.map.expect_item(trait_did.node).node {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n                 let item = trait_items.iter()\n                                       .find(|i| i.ident.name == assoc_name)\n                                       .expect(\"missing associated type\");\n-                ast_util::local_def(item.id)\n+                DefId::local(item.id)\n             }\n             _ => unreachable!()\n         }\n@@ -1301,7 +1302,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                      span: Span,\n                      param_mode: PathParamMode,\n                      opt_self_ty: Option<Ty<'tcx>>,\n-                     trait_def_id: ast::DefId,\n+                     trait_def_id: DefId,\n                      trait_segment: &ast::PathSegment,\n                      item_segment: &ast::PathSegment)\n                      -> Ty<'tcx>\n@@ -1589,7 +1590,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             } else if let Some(ast::QSelf { position: 0, .. }) = *maybe_qself {\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n-                    base_def: def::DefMod(ast_util::local_def(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }"}, {"sha": "3ea175b0a202a678af535af2deb575a9822691a3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use middle::def;\n+use middle::def_id::DefId;\n use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n@@ -201,7 +202,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             } else if qself.position == 0 {\n                 def::PathResolution {\n                     // This is just a sentinel for finish_resolving_def_to_ty.\n-                    base_def: def::DefMod(ast_util::local_def(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }"}, {"sha": "91db2530f3ab9e47c1e7ad2c1aab08fad25d74ef", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -26,6 +26,7 @@ use super::UnresolvedTypeAction;\n use super::write_call;\n \n use CrateCtxt;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::infer;\n use middle::ty::{self, Ty};\n use syntax::ast;\n@@ -36,7 +37,7 @@ use syntax::ptr::P;\n /// Check that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called)\n-pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id: ast::DefId) {\n+pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id: DefId) {\n     let tcx = ccx.tcx;\n     let did = Some(trait_id);\n     let li = &tcx.lang_items;\n@@ -132,7 +133,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         ty::TyClosure(def_id, ref substs) => {\n-            assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+            assert_eq!(def_id.krate, LOCAL_CRATE);\n \n             // Check whether this is a call to a closure where we\n             // haven't yet decided on whether the closure is fn vs\n@@ -334,7 +335,7 @@ struct CallResolution<'tcx> {\n     adjusted_ty: Ty<'tcx>,\n     autoderefs: usize,\n     fn_sig: ty::FnSig<'tcx>,\n-    closure_def_id: ast::DefId,\n+    closure_def_id: DefId,\n }\n \n impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {"}, {"sha": "4f896ac76a7ea9216569bfe912414a04d4218f32", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -45,6 +45,7 @@ use super::structurally_resolved_type;\n \n use lint;\n use middle::cast::{CastKind, CastTy};\n+use middle::def_id::DefId;\n use middle::ty::{self, Ty, HasTypeFlags};\n use syntax::ast;\n use syntax::ast::UintTy::{TyU8};\n@@ -63,7 +64,7 @@ pub struct CastCheck<'tcx> {\n /// fat pointers if their unsize-infos have the same kind.\n #[derive(Copy, Clone, PartialEq, Eq)]\n enum UnsizeKind<'tcx> {\n-    Vtable(ast::DefId),\n+    Vtable(DefId),\n     Length,\n     /// The unsize info of this projection\n     OfProjection(&'tcx ty::ProjectionTy<'tcx>),"}, {"sha": "6d7919a84efb5e30a1f5363b38daf94298ef9e6d", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -13,13 +13,13 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv;\n+use middle::def_id::DefId;\n use middle::region;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_util;\n \n pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n@@ -47,7 +47,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                           decl: &'tcx ast::FnDecl,\n                           body: &'tcx ast::Block,\n                           expected_sig: Option<ty::FnSig<'tcx>>) {\n-    let expr_def_id = ast_util::local_def(expr.id);\n+    let expr_def_id = DefId::local(expr.id);\n \n     debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n            opt_kind,"}, {"sha": "b6a91ce8a64e34d0e3c83d87e764a9180497f93a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -10,6 +10,7 @@\n \n use check::regionck::{self, Rcx};\n \n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::infer;\n use middle::region;\n use middle::subst::{self, Subst};\n@@ -37,7 +38,7 @@ use syntax::parse::token::special_idents;\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(), ()> {\n+pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: DefId) -> Result<(), ()> {\n     let ty::TypeScheme { generics: ref dtor_generics,\n                          ty: dtor_self_type } = tcx.lookup_item_type(drop_impl_did);\n     let dtor_predicates = tcx.lookup_predicates(drop_impl_did);\n@@ -69,10 +70,10 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n \n fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n-    drop_impl_did: ast::DefId,\n+    drop_impl_did: DefId,\n     drop_impl_generics: &ty::Generics<'tcx>,\n     drop_impl_ty: &ty::Ty<'tcx>,\n-    self_type_did: ast::DefId) -> Result<(), ()>\n+    self_type_did: DefId) -> Result<(), ()>\n {\n     // New strategy based on review suggestion from nikomatsakis.\n     //\n@@ -135,9 +136,9 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n /// implied by assuming the predicates attached to self_type_did.\n fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n-    drop_impl_did: ast::DefId,\n+    drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n-    self_type_did: ast::DefId,\n+    self_type_did: DefId,\n     self_to_impl_substs: &subst::Substs<'tcx>) -> Result<(), ()> {\n \n     // Here is an example, analogous to that from\n@@ -175,7 +176,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    assert_eq!(self_type_did.krate, ast::LOCAL_CRATE);\n+    assert_eq!(self_type_did.krate, LOCAL_CRATE);\n \n     let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n \n@@ -321,7 +322,7 @@ enum Error<'tcx> {\n enum TypeContext {\n     Root,\n     ADT {\n-        def_id: ast::DefId,\n+        def_id: DefId,\n         variant: ast::Name,\n         field: ast::Name,\n         field_index: usize"}, {"sha": "83ac406119ee4393c857a6a66ea16702b99d705a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -13,6 +13,7 @@\n \n use astconv::AstConv;\n use intrinsics;\n+use middle::def_id::DefId;\n use middle::subst;\n use middle::ty::FnSig;\n use middle::ty::{self, Ty};\n@@ -23,7 +24,6 @@ use std::collections::{HashMap};\n use syntax::abi;\n use syntax::attr::AttrMetaMethods;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::codemap::Span;\n use syntax::parse::token;\n \n@@ -41,7 +41,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: &ty::ctxt<'tcx>, it: &ast::ForeignItem,\n             variadic: false,\n         }),\n     }));\n-    let i_ty = tcx.lookup_item_type(local_def(it.id));\n+    let i_ty = tcx.lookup_item_type(DefId::local(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n         span_err!(tcx.sess, it.span, E0094,\n@@ -363,7 +363,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     let tcx = ccx.tcx;\n-    let i_ty = tcx.lookup_item_type(local_def(it.id));\n+    let i_ty = tcx.lookup_item_type(DefId::local(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     let name = it.ident.name.as_str();\n "}, {"sha": "4d61da24fa62e1366d0078cd30e27954956c885c", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,6 +12,7 @@ use super::probe;\n \n use check::{self, FnCtxt, NoPreference, PreferMutLvalue, callee, demand};\n use check::UnresolvedTypeAction;\n+use middle::def_id::DefId;\n use middle::subst::{self};\n use middle::traits;\n use middle::ty::{self, Ty};\n@@ -631,7 +632,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn upcast(&mut self,\n               source_trait_ref: ty::PolyTraitRef<'tcx>,\n-              target_trait_def_id: ast::DefId)\n+              target_trait_def_id: DefId)\n               -> ty::PolyTraitRef<'tcx>\n     {\n         let upcast_trait_refs = traits::upcast(self.tcx(),"}, {"sha": "bc495219f1156b9b021cfd436ab343b717a89bf1", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -13,13 +13,13 @@\n use astconv::AstConv;\n use check::FnCtxt;\n use middle::def;\n+use middle::def_id::DefId;\n use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n use middle::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef};\n use middle::infer;\n \n-use syntax::ast::DefId;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -40,22 +40,22 @@ pub enum MethodError<'tcx> {\n     Ambiguity(Vec<CandidateSource>),\n \n     // Using a `Fn`/`FnMut`/etc method on a raw closure type before we have inferred its kind.\n-    ClosureAmbiguity(/* DefId of fn trait */ ast::DefId),\n+    ClosureAmbiguity(/* DefId of fn trait */ DefId),\n }\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n // could lead to matches if satisfied, and a list of not-in-scope traits which may work.\n pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n     pub unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n-    pub out_of_scope_traits: Vec<ast::DefId>,\n+    pub out_of_scope_traits: Vec<DefId>,\n     pub mode: probe::Mode\n }\n \n impl<'tcx> NoMatchData<'tcx> {\n     pub fn new(static_candidates: Vec<CandidateSource>,\n                unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n-               out_of_scope_traits: Vec<ast::DefId>,\n+               out_of_scope_traits: Vec<DefId>,\n                mode: probe::Mode) -> Self {\n         NoMatchData {\n             static_candidates: static_candidates,\n@@ -70,8 +70,8 @@ impl<'tcx> NoMatchData<'tcx> {\n // candidate can arise. Used for error reporting only.\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum CandidateSource {\n-    ImplSource(ast::DefId),\n-    TraitSource(/* trait id */ ast::DefId),\n+    ImplSource(DefId),\n+    TraitSource(/* trait id */ DefId),\n }\n \n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n@@ -353,7 +353,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// Find item with name `item_name` defined in `trait_def_id`\n /// and return it, or `None`, if no such item.\n fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                    trait_def_id: ast::DefId,\n+                    trait_def_id: DefId,\n                     item_name: ast::Name)\n                     -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n@@ -364,7 +364,7 @@ fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                   impl_def_id: ast::DefId,\n+                   impl_def_id: DefId,\n                    item_name: ast::Name)\n                    -> Option<ty::ImplOrTraitItem<'tcx>>\n {"}, {"sha": "8a76268e2cda085da4f70300dcc3dd460513ad77", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -15,6 +15,7 @@ use super::suggest;\n \n use check;\n use check::{FnCtxt, NoPreference, UnresolvedTypeAction};\n+use middle::def_id::DefId;\n use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n@@ -42,7 +43,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n-    impl_dups: HashSet<ast::DefId>,\n+    impl_dups: HashSet<DefId>,\n \n     /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n     /// used for error reporting\n@@ -71,7 +72,7 @@ struct Candidate<'tcx> {\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(subst::Substs<'tcx>,\n                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>,\n+    ExtensionImplCandidate(/* Impl */ DefId, subst::Substs<'tcx>,\n                            /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n     ObjectCandidate,\n     TraitCandidate,\n@@ -104,7 +105,7 @@ pub struct Pick<'tcx> {\n #[derive(Clone,Debug)]\n pub enum PickKind<'tcx> {\n     InherentImplPick,\n-    ExtensionImplPick(/* Impl */ ast::DefId),\n+    ExtensionImplPick(/* Impl */ DefId),\n     ObjectPick,\n     TraitPick,\n     WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>),\n@@ -371,15 +372,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<ast::DefId>) {\n+    fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<DefId>) {\n         if let Some(impl_def_id) = lang_def_id {\n             self.tcx().populate_implementations_for_primitive_if_necessary(impl_def_id);\n \n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n     }\n \n-    fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: ast::DefId) {\n+    fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n         self.tcx().populate_inherent_implementations_for_type_if_necessary(def_id);\n@@ -391,7 +392,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn assemble_inherent_impl_probe(&mut self, impl_def_id: ast::DefId) {\n+    fn assemble_inherent_impl_probe(&mut self, impl_def_id: DefId) {\n         if !self.impl_dups.insert(impl_def_id) {\n             return; // already visited\n         }\n@@ -587,7 +588,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_trait(&mut self,\n-                                               trait_def_id: ast::DefId)\n+                                               trait_def_id: DefId)\n                                                -> Result<(), MethodError<'tcx>>\n     {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n@@ -623,7 +624,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n-                                                     trait_def_id: ast::DefId,\n+                                                     trait_def_id: DefId,\n                                                      item: ty::ImplOrTraitItem<'tcx>)\n     {\n         let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n@@ -674,7 +675,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         });\n     }\n \n-    fn impl_can_possibly_match(&self, impl_def_id: ast::DefId) -> bool {\n+    fn impl_can_possibly_match(&self, impl_def_id: DefId) -> bool {\n         let simplified_steps = match self.opt_simplified_steps {\n             Some(ref simplified_steps) => simplified_steps,\n             None => { return true; }\n@@ -691,7 +692,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_closure_candidates(&mut self,\n-                                   trait_def_id: ast::DefId,\n+                                   trait_def_id: DefId,\n                                    item: ty::ImplOrTraitItem<'tcx>)\n                                    -> Result<(), MethodError<'tcx>>\n     {\n@@ -752,7 +753,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_projection_candidates(&mut self,\n-                                      trait_def_id: ast::DefId,\n+                                      trait_def_id: DefId,\n                                       item: ty::ImplOrTraitItem<'tcx>)\n     {\n         debug!(\"assemble_projection_candidates(\\\n@@ -809,7 +810,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_where_clause_candidates(&mut self,\n-                                        trait_def_id: ast::DefId,\n+                                        trait_def_id: DefId,\n                                         item: ty::ImplOrTraitItem<'tcx>)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n@@ -1237,7 +1238,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self,\n-                          impl_def_id: ast::DefId)\n+                          impl_def_id: DefId)\n                           -> (Ty<'tcx>, subst::Substs<'tcx>)\n     {\n         let impl_pty = self.tcx().lookup_item_type(impl_def_id);\n@@ -1280,7 +1281,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n }\n \n fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                   impl_def_id: ast::DefId,\n+                   impl_def_id: DefId,\n                    item_name: ast::Name)\n                    -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n@@ -1295,7 +1296,7 @@ fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// Find item with name `item_name` defined in `trait_def_id`\n /// and return it, or `None`, if no such item.\n fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                    trait_def_id: ast::DefId,\n+                    trait_def_id: DefId,\n                     item_name: ast::Name)\n                     -> Option<ty::ImplOrTraitItem<'tcx>>\n {"}, {"sha": "01abf45bdabd81767e3de04c8822abdf4c8b5eba", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -17,12 +17,13 @@ use astconv::AstConv;\n use check::{self, FnCtxt};\n use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate, HasTypeFlags};\n use middle::def;\n+use middle::def_id::DefId;\n use middle::lang_items::FnOnceTraitLangItem;\n use middle::subst::Substs;\n use middle::traits::{Obligation, SelectionContext};\n use metadata::{csearch, cstore, decoder};\n \n-use syntax::{ast, ast_util};\n+use syntax::ast;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n \n@@ -221,7 +222,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       rcvr_ty: Ty<'tcx>,\n                                       item_name: ast::Name,\n                                       rcvr_expr: Option<&ast::Expr>,\n-                                      valid_out_of_scope_traits: Vec<ast::DefId>)\n+                                      valid_out_of_scope_traits: Vec<DefId>)\n {\n     let tcx = fcx.tcx();\n \n@@ -261,7 +262,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // this isn't perfect (that is, there are cases when\n             // implementing a trait would be legal but is rejected\n             // here).\n-            (type_is_local || ast_util::is_local(info.def_id))\n+            (type_is_local || info.def_id.is_local())\n                 && trait_item(tcx, info.def_id, item_name).is_some()\n         })\n         .collect::<Vec<_>>();\n@@ -301,9 +302,9 @@ fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   rcvr_expr: Option<&ast::Expr>) -> bool {\n     fn is_local(ty: Ty) -> bool {\n         match ty.sty {\n-            ty::TyEnum(def, _) | ty::TyStruct(def, _) => ast_util::is_local(def.did),\n+            ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.did.is_local(),\n \n-            ty::TyTrait(ref tr) => ast_util::is_local(tr.principal_def_id()),\n+            ty::TyTrait(ref tr) => tr.principal_def_id().is_local(),\n \n             ty::TyParam(_) => true,\n \n@@ -334,11 +335,11 @@ fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n #[derive(Copy, Clone)]\n pub struct TraitInfo {\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n }\n \n impl TraitInfo {\n-    fn new(def_id: ast::DefId) -> TraitInfo {\n+    fn new(def_id: DefId) -> TraitInfo {\n         TraitInfo {\n             def_id: def_id,\n         }\n@@ -383,7 +384,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n             fn visit_item(&mut self, i: &'v ast::Item) {\n                 match i.node {\n                     ast::ItemTrait(..) => {\n-                        self.traits.push(TraitInfo::new(ast_util::local_def(i.id)));\n+                        self.traits.push(TraitInfo::new(DefId::local(i.id)));\n                     }\n                     _ => {}\n                 }"}, {"sha": "bbea25525738a1ffdd32d634d166e4f29976da18", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -86,6 +86,7 @@ use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::infer;\n use middle::infer::type_variable;\n use middle::pat_util::{self, pat_id_map};\n@@ -114,8 +115,8 @@ use std::mem::replace;\n use std::slice;\n use syntax::{self, abi, attr};\n use syntax::attr::AttrMetaMethods;\n-use syntax::ast::{self, DefId, Visibility};\n-use syntax::ast_util::{self, local_def};\n+use syntax::ast::{self, Visibility};\n+use syntax::ast_util;\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::emit_feature_err;\n use syntax::owned_slice::OwnedSlice;\n@@ -426,7 +427,7 @@ pub fn check_item_bodies(ccx: &CrateCtxt) {\n \n pub fn check_drop_impls(ccx: &CrateCtxt) {\n     for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n-        if drop_method_did.krate == ast::LOCAL_CRATE {\n+        if drop_method_did.is_local() {\n             let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n             match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n                 Ok(()) => {}\n@@ -671,15 +672,15 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     check_representable(tcx, span, id, \"struct\");\n     check_instantiable(tcx, span, id);\n \n-    if tcx.lookup_simd(local_def(id)) {\n+    if tcx.lookup_simd(DefId::local(id)) {\n         check_simd(tcx, span, id);\n     }\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     debug!(\"check_item_type(it.id={}, it.ident={})\",\n            it.id,\n-           ccx.tcx.item_path_str(local_def(it.id)));\n+           ccx.tcx.item_path_str(DefId::local(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n@@ -694,7 +695,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemFn(..) => {} // entirely within check_item_body\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", it.ident, it.id);\n-          match ccx.tcx.impl_trait_ref(local_def(it.id)) {\n+          match ccx.tcx.impl_trait_ref(DefId::local(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n@@ -725,7 +726,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let pty = ccx.tcx.lookup_item_type(local_def(item.id));\n+                let pty = ccx.tcx.lookup_item_type(DefId::local(item.id));\n                 if !pty.generics.types.is_empty() {\n                     span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n@@ -744,18 +745,18 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     debug!(\"check_item_body(it.id={}, it.ident={})\",\n            it.id,\n-           ccx.tcx.item_path_str(local_def(it.id)));\n+           ccx.tcx.item_path_str(DefId::local(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       ast::ItemFn(ref decl, _, _, _, _, ref body) => {\n-        let fn_pty = ccx.tcx.lookup_item_type(ast_util::local_def(it.id));\n+        let fn_pty = ccx.tcx.lookup_item_type(DefId::local(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", it.ident, it.id);\n \n-        let impl_pty = ccx.tcx.lookup_item_type(ast_util::local_def(it.id));\n+        let impl_pty = ccx.tcx.lookup_item_type(DefId::local(it.id));\n \n         for impl_item in impl_items {\n             match impl_item.node {\n@@ -774,7 +775,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         }\n       }\n       ast::ItemTrait(_, _, _, ref trait_items) => {\n-        let trait_def = ccx.tcx.lookup_trait_def(local_def(it.id));\n+        let trait_def = ccx.tcx.lookup_trait_def(DefId::local(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n                 ast::ConstTraitItem(_, Some(ref expr)) => {\n@@ -893,7 +894,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let ty_impl_item = ccx.tcx.impl_or_trait_item(local_def(impl_item.id));\n+        let ty_impl_item = ccx.tcx.impl_or_trait_item(DefId::local(impl_item.id));\n         let ty_trait_item = trait_items.iter()\n             .find(|ac| ac.name() == ty_impl_item.name())\n             .unwrap_or_else(|| {\n@@ -1117,19 +1118,19 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_type_scheme(&self, _: Span, id: ast::DefId)\n+    fn get_item_type_scheme(&self, _: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n         Ok(self.tcx().lookup_item_type(id))\n     }\n \n-    fn get_trait_def(&self, _: Span, id: ast::DefId)\n+    fn get_trait_def(&self, _: Span, id: DefId)\n                      -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n     {\n         Ok(self.tcx().lookup_trait_def(id))\n     }\n \n-    fn ensure_super_predicates(&self, _: Span, _: ast::DefId) -> Result<(), ErrorReported> {\n+    fn ensure_super_predicates(&self, _: Span, _: DefId) -> Result<(), ErrorReported> {\n         // all super predicates are ensured during collect pass\n         Ok(())\n     }\n@@ -1166,7 +1167,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn trait_defines_associated_type_named(&self,\n-                                           trait_def_id: ast::DefId,\n+                                           trait_def_id: DefId,\n                                            assoc_name: ast::Name)\n                                            -> bool\n     {\n@@ -1280,14 +1281,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn record_deferred_call_resolution(&self,\n-                                       closure_def_id: ast::DefId,\n+                                       closure_def_id: DefId,\n                                        r: DeferredCallResolutionHandler<'tcx>) {\n         let mut deferred_call_resolutions = self.inh.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.entry(closure_def_id).or_insert(vec![]).push(r);\n     }\n \n     fn remove_deferred_call_resolutions(&self,\n-                                        closure_def_id: ast::DefId)\n+                                        closure_def_id: DefId)\n                                         -> Vec<DeferredCallResolutionHandler<'tcx>>\n     {\n         let mut deferred_call_resolutions = self.inh.deferred_call_resolutions.borrow_mut();\n@@ -1420,7 +1421,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that this function is only intended to be used with type-paths,\n     /// not with value-paths.\n     pub fn instantiate_type(&self,\n-                            did: ast::DefId,\n+                            did: DefId,\n                             path: &ast::Path)\n                             -> Ty<'tcx>\n     {\n@@ -1937,7 +1938,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .unwrap_or(type_variable::Default {\n                                 ty: self.infcx().next_ty_var(),\n                                 origin_span: codemap::DUMMY_SP,\n-                                def_id: local_def(0) // what do I put here?\n+                                def_id: DefId::local(0) // what do I put here?\n                             });\n \n                     // This is to ensure that we elimnate any non-determinism from the error\n@@ -2721,7 +2722,7 @@ fn check_expr_with_lvalue_pref<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx ast::\n // variables.\n pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span, // (potential) receiver for this impl\n-                              did: ast::DefId)\n+                              did: DefId)\n                               -> TypeAndSubsts<'tcx> {\n     let tcx = fcx.tcx();\n \n@@ -3002,7 +3003,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 continue;\n             }\n             // ignore private fields from non-local crates\n-            if variant.did.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n+            if variant.did.krate != LOCAL_CRATE && elem.vis != Visibility::Public {\n                 continue;\n             }\n             let dist = lev_distance(&n, &name);\n@@ -3382,7 +3383,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           } else if let Some(ast::QSelf { position: 0, .. }) = *maybe_qself {\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n-                    base_def: def::DefMod(local_def(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n@@ -4152,7 +4153,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let inh = static_inherited_fields(ccx, &tables);\n     let rty = ccx.tcx.node_id_to_type(id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-    let declty = fcx.ccx.tcx.lookup_item_type(local_def(id)).ty;\n+    let declty = fcx.ccx.tcx.lookup_item_type(DefId::local(id)).ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n@@ -4295,7 +4296,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             }\n         }\n \n-        let def_id = local_def(id);\n+        let def_id = DefId::local(id);\n \n         let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n         for (v, variant) in vs.iter().zip(variants.iter()) {\n@@ -4333,7 +4334,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    let hint = *ccx.tcx.lookup_repr_hints(ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n+    let hint = *ccx.tcx.lookup_repr_hints(DefId { krate: LOCAL_CRATE, node: id })\n         .get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {"}, {"sha": "d26ce278b27d54c0106b7533684b89139adac337", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -20,6 +20,7 @@ use super::{\n     PreferMutLvalue,\n     structurally_resolved_type,\n };\n+use middle::def_id::DefId;\n use middle::traits;\n use middle::ty::{Ty, HasTypeFlags};\n use syntax::ast;\n@@ -208,7 +209,7 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  op_str: &str,\n                                  mname: &str,\n-                                 trait_did: Option<ast::DefId>,\n+                                 trait_did: Option<DefId>,\n                                  ex: &'tcx ast::Expr,\n                                  operand_expr: &'tcx ast::Expr,\n                                  operand_ty: Ty<'tcx>,\n@@ -230,7 +231,7 @@ pub fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-fn name_and_trait_def_id(fcx: &FnCtxt, op: ast::BinOp) -> (&'static str, Option<ast::DefId>) {\n+fn name_and_trait_def_id(fcx: &FnCtxt, op: ast::BinOp) -> (&'static str, Option<DefId>) {\n     let lang = &fcx.tcx().lang_items;\n     match op.node {\n         ast::BiAdd => (\"add\", lang.add_trait()),\n@@ -260,7 +261,7 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                               lhs_ty: Ty<'tcx>,\n                               other_tys: Vec<Ty<'tcx>>,\n                               opname: ast::Name,\n-                              trait_did: Option<ast::DefId>,\n+                              trait_did: Option<DefId>,\n                               lhs_expr: &'a ast::Expr)\n                               -> Result<Ty<'tcx>,()>\n {"}, {"sha": "c5e1faaf97c28c0208c4503e6c377c14e84fdd61", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -43,13 +43,13 @@\n use super::FnCtxt;\n \n use check::demand;\n+use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty::{self, Ty};\n use middle::infer::{InferCtxt, UpvarRegion};\n use std::collections::HashSet;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit::{self, Visitor};\n \n@@ -115,7 +115,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      capture_clause: ast::CaptureClause,\n                      _body: &ast::Block)\n     {\n-        let closure_def_id = ast_util::local_def(expr.id);\n+        let closure_def_id = DefId::local(expr.id);\n         if !self.fcx.inh.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n             self.closures_with_inferred_kinds.insert(expr.id);\n             self.fcx.inh.tables.borrow_mut().closure_kinds\n@@ -214,7 +214,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n         // Now we must process and remove any deferred resolutions,\n         // since we have a concrete closure kind.\n-        let closure_def_id = ast_util::local_def(id);\n+        let closure_def_id = DefId::local(id);\n         if self.closures_with_inferred_kinds.contains(&id) {\n             let mut deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n@@ -468,7 +468,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n             return;\n         }\n \n-        let closure_def_id = ast_util::local_def(closure_id);\n+        let closure_def_id = DefId::local(closure_id);\n         let closure_kinds = &mut self.fcx.inh.tables.borrow_mut().closure_kinds;\n         let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n "}, {"sha": "bc94132f2a327f2f178575beac562366d8e0ab18", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,6 +12,7 @@ use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck, wfcheck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n+use middle::def_id::DefId;\n use middle::region;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n@@ -21,7 +22,6 @@ use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n use std::cell::RefCell;\n use std::collections::HashSet;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::{special_idents};\n use syntax::visit;\n@@ -56,7 +56,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n                item.id,\n-               ccx.tcx.item_path_str(local_def(item.id)));\n+               ccx.tcx.item_path_str(DefId::local(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -80,7 +80,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_impl(item);\n             }\n             ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n-                let trait_ref = ccx.tcx.impl_trait_ref(local_def(item.id)).unwrap();\n+                let trait_ref = ccx.tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n                 ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n@@ -116,9 +116,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n             ast::ItemTrait(_, _, _, ref items) => {\n                 let trait_predicates =\n-                    ccx.tcx.lookup_predicates(local_def(item.id));\n+                    ccx.tcx.lookup_predicates(DefId::local(item.id));\n                 reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n-                if ccx.tcx.trait_has_default_impl(local_def(item.id)) {\n+                if ccx.tcx.trait_has_default_impl(DefId::local(item.id)) {\n                     if !items.is_empty() {\n                         wfcheck::error_380(ccx, item.span);\n                     }\n@@ -132,7 +132,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         F: for<'fcx> FnMut(&mut CheckTypeWellFormedVisitor<'ccx, 'tcx>, &FnCtxt<'fcx, 'tcx>),\n     {\n         let ccx = self.ccx;\n-        let item_def_id = local_def(item.id);\n+        let item_def_id = DefId::local(item.id);\n         let type_scheme = ccx.tcx.lookup_item_type(item_def_id);\n         let type_predicates = ccx.tcx.lookup_predicates(item_def_id);\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n@@ -193,7 +193,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         Some(&mut this.cache));\n             debug!(\"check_item_type at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n-            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh\n                                                           .infcx\n@@ -229,7 +229,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Similarly, obtain an \"inside\" reference to the trait\n             // that the impl implements.\n-            let trait_ref = match fcx.tcx().impl_trait_ref(local_def(item.id)) {\n+            let trait_ref = match fcx.tcx().impl_trait_ref(DefId::local(item.id)) {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n@@ -278,7 +278,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      item: &ast::Item,\n                                      ast_generics: &ast::Generics)\n     {\n-        let item_def_id = local_def(item.id);\n+        let item_def_id = DefId::local(item.id);\n         let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n         let variances = self.tcx().item_variances(item_def_id);\n \n@@ -430,7 +430,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match fk {\n             visit::FkFnBlock | visit::FkItemFn(..) => {}\n             visit::FkMethod(..) => {\n-                match self.tcx().impl_or_trait_item(local_def(id)) {\n+                match self.tcx().impl_or_trait_item(DefId::local(id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                         reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n                     }\n@@ -443,7 +443,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'v ast::TraitItem) {\n         if let ast::MethodTraitItem(_, None) = trait_item.node {\n-            match self.tcx().impl_or_trait_item(local_def(trait_item.id)) {\n+            match self.tcx().impl_or_trait_item(DefId::local(trait_item.id)) {\n                 ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                     reject_non_type_param_bounds(\n                         self.tcx(),"}, {"sha": "cdad1257533cb04ea4f73f28eb58bea694d9e9f2", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,6 +12,7 @@ use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n+use middle::def_id::DefId;\n use middle::region::DestructionScopeData;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n@@ -23,7 +24,6 @@ use std::cell::RefCell;\n use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::codemap::{Span};\n use syntax::parse::token::{special_idents};\n use syntax::ptr::P;\n@@ -64,7 +64,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n                item.id,\n-               ccx.tcx.item_path_str(local_def(item.id)));\n+               ccx.tcx.item_path_str(DefId::local(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -91,7 +91,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n \n-                let trait_ref = ccx.tcx.impl_trait_ref(local_def(item.id)).unwrap();\n+                let trait_ref = ccx.tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n                 ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n@@ -138,7 +138,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n             let free_id = fcx.inh.infcx.parameter_environment.free_id;\n \n-            let item = fcx.tcx().impl_or_trait_item(local_def(item_id));\n+            let item = fcx.tcx().impl_or_trait_item(DefId::local(item_id));\n \n             let mut implied_bounds = match item.container() {\n                 ty::TraitContainer(_) => vec![],\n@@ -217,7 +217,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n \n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx().lookup_predicates(local_def(item.id));\n+            let predicates = fcx.tcx().lookup_predicates(DefId::local(item.id));\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n@@ -229,7 +229,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                    item: &ast::Item,\n                    items: &[P<ast::TraitItem>])\n     {\n-        let trait_def_id = local_def(item.id);\n+        let trait_def_id = DefId::local(item.id);\n \n         if self.ccx.tcx.trait_has_default_impl(trait_def_id) {\n             if !items.is_empty() {\n@@ -252,7 +252,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         self.with_item_fcx(item, |fcx, this| {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyBareFn(_, ref bare_fn_ty) => bare_fn_ty,\n@@ -261,7 +261,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             };\n \n-            let predicates = fcx.tcx().lookup_predicates(local_def(item.id));\n+            let predicates = fcx.tcx().lookup_predicates(DefId::local(item.id));\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n \n             let mut implied_bounds = vec![];\n@@ -277,7 +277,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.with_item_fcx(item, |fcx, this| {\n-            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh\n                                                           .infcx\n@@ -300,7 +300,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         self.with_item_fcx(item, |fcx, this| {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let item_def_id = local_def(item.id);\n+            let item_def_id = DefId::local(item.id);\n \n             match *ast_trait_ref {\n                 Some(ref ast_trait_ref) => {\n@@ -329,7 +329,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n-            impl_implied_bounds(fcx, local_def(item.id), item.span)\n+            impl_implied_bounds(fcx, DefId::local(item.id), item.span)\n         });\n     }\n \n@@ -387,7 +387,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      item: &ast::Item,\n                                      ast_generics: &ast::Generics)\n     {\n-        let item_def_id = local_def(item.id);\n+        let item_def_id = DefId::local(item.id);\n         let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n         let variances = self.tcx().item_variances(item_def_id);\n \n@@ -584,7 +584,7 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n fn impl_implied_bounds<'fcx,'tcx>(fcx: &FnCtxt<'fcx, 'tcx>,\n-                                  impl_def_id: ast::DefId,\n+                                  impl_def_id: DefId,\n                                   span: Span)\n                                   -> Vec<Ty<'tcx>>\n {"}, {"sha": "be24c771b944af103dbadd1575eef886581b337a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -15,6 +15,7 @@ use self::ResolveReason::*;\n \n use astconv::AstConv;\n use check::FnCtxt;\n+use middle::def_id::DefId;\n use middle::pat_util;\n use middle::ty::{self, Ty, MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n@@ -337,7 +338,7 @@ enum ResolveReason {\n     ResolvingLocal(Span),\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n-    ResolvingClosure(ast::DefId),\n+    ResolvingClosure(DefId),\n }\n \n impl ResolveReason {\n@@ -350,7 +351,7 @@ impl ResolveReason {\n                 tcx.expr_span(upvar_id.closure_expr_id)\n             }\n             ResolvingClosure(did) => {\n-                if did.krate == ast::LOCAL_CRATE {\n+                if did.is_local() {\n                     tcx.expr_span(did.node)\n                 } else {\n                     DUMMY_SP"}, {"sha": "aadd74708abc47924d7a926d784688561f9b92f7", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -16,6 +16,7 @@\n // mappings. That mapping code resides here.\n \n \n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n use middle::traits;\n@@ -35,11 +36,9 @@ use middle::infer::{self, InferCtxt, new_infer_ctxt};\n use rustc::ast_map::{self, NodeItem};\n use std::cell::RefCell;\n use std::rc::Rc;\n-use syntax::ast::{Crate, DefId};\n+use syntax::ast::{Crate};\n use syntax::ast::{Item, ItemImpl};\n-use syntax::ast::{LOCAL_CRATE};\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n@@ -89,7 +88,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n struct CoherenceChecker<'a, 'tcx: 'a> {\n     crate_context: &'a CrateCtxt<'a, 'tcx>,\n     inference_context: InferCtxt<'a, 'tcx>,\n-    inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n+    inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<DefId>>>>>,\n }\n \n struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n@@ -138,7 +137,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n-        let impl_did = local_def(item.id);\n+        let impl_did = DefId::local(item.id);\n         let self_type = tcx.lookup_item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n@@ -186,7 +185,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         for trait_method in &prov {\n             // Synthesize an ID.\n             let new_id = tcx.sess.next_node_id();\n-            let new_did = local_def(new_id);\n+            let new_did = DefId::local(new_id);\n \n             debug!(\"new_did={:?} trait_method={:?}\", new_did, trait_method);\n \n@@ -256,13 +255,13 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                         impl_items.iter().map(|impl_item| {\n                     match impl_item.node {\n                         ast::ConstImplItem(..) => {\n-                            ConstTraitItemId(local_def(impl_item.id))\n+                            ConstTraitItemId(DefId::local(impl_item.id))\n                         }\n                         ast::MethodImplItem(..) => {\n-                            MethodTraitItemId(local_def(impl_item.id))\n+                            MethodTraitItemId(DefId::local(impl_item.id))\n                         }\n                         ast::TypeImplItem(_) => {\n-                            TypeTraitItemId(local_def(impl_item.id))\n+                            TypeTraitItemId(DefId::local(impl_item.id))\n                         }\n                         ast::MacImplItem(_) => {\n                             self.crate_context.tcx.sess.span_bug(impl_item.span,\n@@ -271,7 +270,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n                 }).collect();\n \n-                let def_id = local_def(item.id);\n+                let def_id = DefId::local(item.id);\n                 if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(def_id) {\n                     self.instantiate_default_methods(def_id, &trait_ref, &mut items);\n                 }\n@@ -321,7 +320,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 }\n                 _ => {\n                     // Destructors only work on nominal types.\n-                    if impl_did.krate == ast::LOCAL_CRATE {\n+                    if impl_did.is_local() {\n                         {\n                             match tcx.map.find(impl_did.node) {\n                                 Some(ast_map::NodeItem(item)) => {\n@@ -357,7 +356,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_copy: impl_did={:?}\",\n                    impl_did);\n \n-            if impl_did.krate != ast::LOCAL_CRATE {\n+            if impl_did.krate != LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n                 return\n@@ -426,7 +425,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n                    impl_did);\n \n-            if impl_did.krate != ast::LOCAL_CRATE {\n+            if impl_did.krate != LOCAL_CRATE {\n                 debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n                         in this crate\");\n                 return;\n@@ -555,7 +554,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n }\n \n-fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id: ast::DefId) {\n+fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id: DefId) {\n     if tcx.sess.features.borrow().unboxed_closures {\n         // the feature gate allows all of them\n         return\n@@ -578,12 +577,12 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n }\n \n fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                           impl_id: ast::DefId,\n+                                           impl_id: DefId,\n                                            impl_type_scheme: &ty::TypeScheme<'tcx>,\n                                            trait_ref: &ty::TraitRef<'tcx>,\n-                                           new_def_id: ast::DefId,\n+                                           new_def_id: DefId,\n                                            method: &ty::Method<'tcx>,\n-                                           provided_source: Option<ast::DefId>)\n+                                           provided_source: Option<DefId>)\n                                            -> ty::Method<'tcx>\n {\n     let combined_substs = tcx.make_substs_for_receiver_types(trait_ref, method);"}, {"sha": "0b7758f4796b4dfbeb6826928130ac911cc23381", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -11,11 +11,11 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::traits;\n use middle::ty;\n use syntax::ast::{Item, ItemImpl};\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n \n@@ -29,8 +29,8 @@ struct OrphanChecker<'cx, 'tcx:'cx> {\n }\n \n impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n-    fn check_def_id(&self, item: &ast::Item, def_id: ast::DefId) {\n-        if def_id.krate != ast::LOCAL_CRATE {\n+    fn check_def_id(&self, item: &ast::Item, def_id: DefId) {\n+        if def_id.krate != LOCAL_CRATE {\n             span_err!(self.tcx.sess, item.span, E0116,\n                       \"cannot define inherent `impl` for a type outside of the \\\n                        crate where the type is defined; define and implement \\\n@@ -39,8 +39,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     }\n \n     fn check_primitive_impl(&self,\n-                            impl_def_id: ast::DefId,\n-                            lang_def_id: Option<ast::DefId>,\n+                            impl_def_id: DefId,\n+                            lang_def_id: Option<DefId>,\n                             lang: &str,\n                             ty: &str,\n                             span: Span) {\n@@ -62,7 +62,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn check_item(&self, item: &ast::Item) {\n-        let def_id = ast_util::local_def(item.id);\n+        let def_id = DefId::local(item.id);\n         match item.node {\n             ast::ItemImpl(_, _, _, None, _, _) => {\n                 // For inherent impls, self type must be a nominal type\n@@ -277,7 +277,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        self.tcx.trait_has_default_impl(trait_def_id));\n                 if\n                     self.tcx.trait_has_default_impl(trait_def_id) &&\n-                    trait_def_id.krate != ast::LOCAL_CRATE\n+                    trait_def_id.krate != LOCAL_CRATE\n                 {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n@@ -295,7 +295,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                         // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n                         // `impl !Send for Box<SomethingLocalAndSend>`.\n                         Some(self_def_id) => {\n-                            if self_def_id.krate == ast::LOCAL_CRATE {\n+                            if self_def_id.is_local() {\n                                 None\n                             } else {\n                                 Some(format!(\n@@ -338,7 +338,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 debug!(\"coherence2::orphan check: default trait impl {}\",\n                        self.tcx.map.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n-                if trait_ref.def_id.krate != ast::LOCAL_CRATE {\n+                if trait_ref.def_id.krate != LOCAL_CRATE {\n                     span_err!(self.tcx.sess, item.span, E0318,\n                               \"cannot create default implementations for traits outside the \\\n                                crate they're defined in; define a new trait instead\");"}, {"sha": "f442189ea99f65a517aa821d5f5f8d52d6307e4b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -11,13 +11,11 @@\n //! Overlap: No two impls for the same trait are implemented for the\n //! same type.\n \n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::traits;\n use middle::ty;\n use middle::infer::{self, new_infer_ctxt};\n-use syntax::ast::DefId;\n-use syntax::ast::LOCAL_CRATE;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::visit;\n use syntax::codemap::Span;\n use util::nodemap::DefIdMap;\n@@ -100,17 +98,17 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     // We need to coherently pick which impl will be displayed\n     // as causing the error message, and it must be the in the current\n     // crate. Just pick the smaller impl in the file.\n-    fn order_impls(&self, impl1_def_id: ast::DefId, impl2_def_id: ast::DefId)\n-            -> Option<(ast::DefId, ast::DefId)> {\n-        if impl1_def_id.krate != ast::LOCAL_CRATE {\n-            if impl2_def_id.krate != ast::LOCAL_CRATE {\n+    fn order_impls(&self, impl1_def_id: DefId, impl2_def_id: DefId)\n+            -> Option<(DefId, DefId)> {\n+        if impl1_def_id.krate != LOCAL_CRATE {\n+            if impl2_def_id.krate != LOCAL_CRATE {\n                 // we don't need to check impls if both are external;\n                 // that's the other crate's job.\n                 None\n             } else {\n                 Some((impl2_def_id, impl1_def_id))\n             }\n-        } else if impl2_def_id.krate != ast::LOCAL_CRATE {\n+        } else if impl2_def_id.krate != LOCAL_CRATE {\n             Some((impl1_def_id, impl2_def_id))\n         } else if impl1_def_id.node < impl2_def_id.node {\n             Some((impl1_def_id, impl2_def_id))\n@@ -121,9 +119,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n \n     fn check_if_impls_overlap(&self,\n-                              trait_def_id: ast::DefId,\n-                              impl1_def_id: ast::DefId,\n-                              impl2_def_id: ast::DefId)\n+                              trait_def_id: DefId,\n+                              impl1_def_id: DefId,\n+                              impl2_def_id: DefId)\n     {\n         if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n             impl1_def_id, impl2_def_id)\n@@ -140,8 +138,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         }\n     }\n \n-    fn report_overlap_error(&self, trait_def_id: ast::DefId,\n-                            impl1: ast::DefId, impl2: ast::DefId) {\n+    fn report_overlap_error(&self, trait_def_id: DefId,\n+                            impl1: DefId, impl2: DefId) {\n \n         span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n                   \"conflicting implementations for trait `{}`\",\n@@ -150,9 +148,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         self.report_overlap_note(impl1, impl2);\n     }\n \n-    fn report_overlap_note(&self, impl1: ast::DefId, impl2: ast::DefId) {\n+    fn report_overlap_note(&self, impl1: DefId, impl2: DefId) {\n \n-        if impl2.krate == ast::LOCAL_CRATE {\n+        if impl2.is_local() {\n             span_note!(self.tcx.sess, self.span_of_impl(impl2),\n                        \"note conflicting implementation here\");\n         } else {\n@@ -164,8 +162,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         }\n     }\n \n-    fn span_of_impl(&self, impl_did: ast::DefId) -> Span {\n-        assert_eq!(impl_did.krate, ast::LOCAL_CRATE);\n+    fn span_of_impl(&self, impl_did: DefId) -> Span {\n+        assert_eq!(impl_did.krate, LOCAL_CRATE);\n         self.tcx.map.span(impl_did.node)\n     }\n }\n@@ -178,20 +176,20 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n-                let impl_def_id = ast_util::local_def(item.id);\n+                let impl_def_id = DefId::local(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 match prev_default_impl {\n                     Some(prev_id) => {\n                         self.report_overlap_error(trait_ref.def_id,\n                                                   impl_def_id,\n-                                                  ast_util::local_def(prev_id));\n+                                                  DefId::local(prev_id));\n                     }\n                     None => { }\n                 }\n             }\n             ast::ItemImpl(_, _, _, Some(_), ref self_ty, _) => {\n-                let impl_def_id = ast_util::local_def(item.id);\n+                let impl_def_id = DefId::local(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match trait_ref.self_ty().sty {"}, {"sha": "2187d71cc0c4b539a18b068b841256fcf3af7b96", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -11,10 +11,10 @@\n //! Unsafety checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n+use middle::def_id::DefId;\n use middle::ty;\n use syntax::ast::{Item, ItemImpl};\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::visit;\n \n pub fn check(tcx: &ty::ctxt) {\n@@ -30,7 +30,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     fn check_unsafety_coherence(&mut self, item: &'v ast::Item,\n                                 unsafety: ast::Unsafety,\n                                 polarity: ast::ImplPolarity) {\n-        match self.tcx.impl_trait_ref(ast_util::local_def(item.id)) {\n+        match self.tcx.impl_trait_ref(DefId::local(item.id)) {\n             None => {\n                 // Inherent impl.\n                 match unsafety {"}, {"sha": "d3e414fd9c0e475d25bc9daf44c0bfc55df6f8ea", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -66,6 +66,7 @@ There are some shortcomings in this design:\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use middle::def;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::free_region::FreeRegionMap;\n@@ -91,7 +92,6 @@ use std::rc::Rc;\n \n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n@@ -140,9 +140,9 @@ struct ItemCtxt<'a,'tcx:'a> {\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n enum AstConvRequest {\n-    GetItemTypeScheme(ast::DefId),\n-    GetTraitDef(ast::DefId),\n-    EnsureSuperPredicates(ast::DefId),\n+    GetItemTypeScheme(DefId),\n+    GetTraitDef(DefId),\n+    EnsureSuperPredicates(DefId),\n     GetTypeParameterBounds(ast::NodeId),\n }\n \n@@ -196,7 +196,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     }\n \n     fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n-        let def_id = local_def(method_id);\n+        let def_id = DefId::local(method_id);\n         match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n             _ => {\n@@ -309,12 +309,12 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     }\n \n     /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n-    fn get_trait_def(&self, trait_id: ast::DefId)\n+    fn get_trait_def(&self, trait_id: DefId)\n                      -> &'tcx ty::TraitDef<'tcx>\n     {\n         let tcx = self.tcx;\n \n-        if trait_id.krate != ast::LOCAL_CRATE {\n+        if trait_id.krate != LOCAL_CRATE {\n             return tcx.lookup_trait_def(trait_id)\n         }\n \n@@ -329,7 +329,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     /// Ensure that the (transitive) super predicates for\n     /// `trait_def_id` are available. This will report a cycle error\n     /// if a trait `X` (transitively) extends itself in some form.\n-    fn ensure_super_predicates(&self, span: Span, trait_def_id: ast::DefId)\n+    fn ensure_super_predicates(&self, span: Span, trait_def_id: DefId)\n                                -> Result<(), ErrorReported>\n     {\n         self.cycle_check(span, AstConvRequest::EnsureSuperPredicates(trait_def_id), || {\n@@ -353,15 +353,15 @@ impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_type_scheme(&self, span: Span, id: ast::DefId)\n+    fn get_item_type_scheme(&self, span: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetItemTypeScheme(id), || {\n             Ok(type_scheme_of_def_id(self.ccx, id))\n         })\n     }\n \n-    fn get_trait_def(&self, span: Span, id: ast::DefId)\n+    fn get_trait_def(&self, span: Span, id: DefId)\n                      -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n@@ -371,7 +371,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n \n     fn ensure_super_predicates(&self,\n                                span: Span,\n-                               trait_def_id: ast::DefId)\n+                               trait_def_id: DefId)\n                                -> Result<(), ErrorReported>\n     {\n         debug!(\"ensure_super_predicates(trait_def_id={:?})\",\n@@ -396,11 +396,11 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn trait_defines_associated_type_named(&self,\n-                                           trait_def_id: ast::DefId,\n+                                           trait_def_id: DefId,\n                                            assoc_name: ast::Name)\n                                            -> bool\n     {\n-        if trait_def_id.krate == ast::LOCAL_CRATE {\n+        if trait_def_id.is_local() {\n             trait_defines_associated_type_named(self.ccx, trait_def_id.node, assoc_name)\n         } else {\n             let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n@@ -559,7 +559,7 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 path_res.depth == 0 && def_id.node == param_id\n             }\n             def::DefTyParam(_, _, def_id, _) => {\n-                path_res.depth == 0 && def_id == local_def(param_id)\n+                path_res.depth == 0 && def_id == DefId::local(param_id)\n             }\n             _ => {\n                 false\n@@ -588,7 +588,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                               sig, untransformed_rcvr_ty);\n \n-    let def_id = local_def(id);\n+    let def_id = DefId::local(id);\n     let ty_method = ty::Method::new(ident.name,\n                                     ty_generics,\n                                     ty_generic_predicates,\n@@ -629,12 +629,12 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n-    ccx.tcx.register_item_type(local_def(v.node.id),\n+    ccx.tcx.register_item_type(DefId::local(v.node.id),\n                                ty::TypeScheme {\n                                    generics: struct_generics.clone(),\n                                    ty: tt\n                                });\n-    ccx.tcx.predicates.borrow_mut().insert(local_def(v.node.id),\n+    ccx.tcx.predicates.borrow_mut().insert(DefId::local(v.node.id),\n                                            struct_predicates.clone());\n }\n \n@@ -646,22 +646,22 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       ty: ty::Ty<'tcx>,\n                                       default: Option<&ast::Expr>)\n {\n-    ccx.tcx.predicates.borrow_mut().insert(local_def(id),\n+    ccx.tcx.predicates.borrow_mut().insert(DefId::local(id),\n                                            ty::GenericPredicates::empty());\n \n     write_ty_to_tcx(ccx.tcx, id, ty);\n-    let default_id = default.map(|expr| local_def(expr.id));\n+    let default_id = default.map(|expr| DefId::local(expr.id));\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: ident.name,\n         vis: vis,\n-        def_id: local_def(id),\n+        def_id: DefId::local(id),\n         container: container,\n         ty: ty,\n         default: default_id,\n     });\n     ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(local_def(id), ty::ConstTraitItem(associated_const));\n+       .insert(DefId::local(id), ty::ConstTraitItem(associated_const));\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -675,11 +675,11 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         name: ident.name,\n         vis: vis,\n         ty: ty,\n-        def_id: local_def(id),\n+        def_id: DefId::local(id),\n         container: container\n     });\n     ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(local_def(id), ty::TypeTraitItem(associated_type));\n+       .insert(DefId::local(id), ty::TypeTraitItem(associated_type));\n }\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -750,7 +750,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n             convert_enum_variant_types(ccx,\n-                                       tcx.lookup_adt_def_master(local_def(it.id)),\n+                                       tcx.lookup_adt_def_master(DefId::local(it.id)),\n                                        scheme,\n                                        predicates,\n                                        &enum_definition.variants);\n@@ -764,7 +764,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n-            tcx.impl_trait_refs.borrow_mut().insert(local_def(it.id), Some(trait_ref));\n+            tcx.impl_trait_refs.borrow_mut().insert(DefId::local(it.id), Some(trait_ref));\n         }\n         ast::ItemImpl(_, _,\n                       ref generics,\n@@ -781,21 +781,21 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.register_item_type(local_def(it.id),\n+            tcx.register_item_type(DefId::local(it.id),\n                                    TypeScheme { generics: ty_generics.clone(),\n                                                 ty: selfty });\n-            tcx.predicates.borrow_mut().insert(local_def(it.id),\n+            tcx.predicates.borrow_mut().insert(DefId::local(it.id),\n                                                ty_predicates.clone());\n             if let &Some(ref ast_trait_ref) = opt_trait_ref {\n                 tcx.impl_trait_refs.borrow_mut().insert(\n-                    local_def(it.id),\n+                    DefId::local(it.id),\n                     Some(astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                              &ExplicitRscope,\n                                                              ast_trait_ref,\n                                                              Some(selfty)))\n                         );\n             } else {\n-                tcx.impl_trait_refs.borrow_mut().insert(local_def(it.id), None);\n+                tcx.impl_trait_refs.borrow_mut().insert(DefId::local(it.id), None);\n             }\n \n \n@@ -838,12 +838,12 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 if let ast::ConstImplItem(ref ty, ref expr) = impl_item.node {\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &*ty);\n-                    tcx.register_item_type(local_def(impl_item.id),\n+                    tcx.register_item_type(DefId::local(impl_item.id),\n                                            TypeScheme {\n                                                generics: ty_generics.clone(),\n                                                ty: ty,\n                                            });\n-                    convert_associated_const(ccx, ImplContainer(local_def(it.id)),\n+                    convert_associated_const(ccx, ImplContainer(DefId::local(it.id)),\n                                              impl_item.ident, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n                                              ty, Some(&*expr));\n@@ -860,7 +860,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n-                    convert_associated_type(ccx, ImplContainer(local_def(it.id)),\n+                    convert_associated_type(ccx, ImplContainer(DefId::local(it.id)),\n                                             impl_item.ident, impl_item.id, impl_item.vis,\n                                             Some(typ));\n                 }\n@@ -879,7 +879,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n             });\n             convert_methods(ccx,\n-                            ImplContainer(local_def(it.id)),\n+                            ImplContainer(DefId::local(it.id)),\n                             methods,\n                             selfty,\n                             &ty_generics,\n@@ -899,15 +899,15 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             enforce_impl_params_are_constrained(tcx,\n                                                 generics,\n-                                                local_def(it.id),\n+                                                DefId::local(it.id),\n                                                 impl_items);\n         },\n         ast::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n-                ccx.ensure_super_predicates(it.span, local_def(it.id));\n+                ccx.ensure_super_predicates(it.span, DefId::local(it.id));\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = tcx.lookup_predicates(local_def(it.id));\n+            let trait_predicates = tcx.lookup_predicates(DefId::local(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n@@ -917,12 +917,12 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                     ast::ConstTraitItem(ref ty, ref default) => {\n                         let ty = ccx.icx(&trait_predicates)\n                                     .to_ty(&ExplicitRscope, ty);\n-                        tcx.register_item_type(local_def(trait_item.id),\n+                        tcx.register_item_type(DefId::local(trait_item.id),\n                                                TypeScheme {\n                                                    generics: trait_def.generics.clone(),\n                                                    ty: ty,\n                                                });\n-                        convert_associated_const(ccx, TraitContainer(local_def(it.id)),\n+                        convert_associated_const(ccx, TraitContainer(DefId::local(it.id)),\n                                                  trait_item.ident, trait_item.id,\n                                                  ast::Public, ty, default.as_ref().map(|d| &**d));\n                     }\n@@ -938,7 +938,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                             |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n                         });\n \n-                        convert_associated_type(ccx, TraitContainer(local_def(it.id)),\n+                        convert_associated_type(ccx, TraitContainer(DefId::local(it.id)),\n                                                 trait_item.ident, trait_item.id, ast::Public,\n                                                 typ);\n                     }\n@@ -956,15 +956,15 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             // Run convert_methods on the trait methods.\n             convert_methods(ccx,\n-                            TraitContainer(local_def(it.id)),\n+                            TraitContainer(DefId::local(it.id)),\n                             methods,\n                             tcx.mk_self_type(),\n                             &trait_def.generics,\n                             &trait_predicates);\n \n             // Add an entry mapping\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n-                let def_id = local_def(trait_item.id);\n+                let def_id = DefId::local(trait_item.id);\n                 match trait_item.node {\n                     ast::ConstTraitItem(..) => {\n                         ty::ConstTraitItemId(def_id)\n@@ -977,7 +977,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                     }\n                 }\n             }).collect());\n-            tcx.trait_item_def_ids.borrow_mut().insert(local_def(it.id), trait_item_def_ids);\n+            tcx.trait_item_def_ids.borrow_mut().insert(DefId::local(it.id), trait_item_def_ids);\n \n             // This must be done after `collect_trait_methods` so that\n             // we have a method type stored for every method.\n@@ -998,7 +998,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n \n-            let variant = tcx.lookup_adt_def_master(local_def(it.id)).struct_variant();\n+            let variant = tcx.lookup_adt_def_master(DefId::local(it.id)).struct_variant();\n \n             for (f, ty_f) in struct_def.fields.iter().zip(variant.fields.iter()) {\n                 convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n@@ -1036,14 +1036,14 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n                 .iter()\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n-            tcx.mk_ctor_fn(local_def(ctor_id),\n+            tcx.mk_ctor_fn(DefId::local(ctor_id),\n                            &inputs[..],\n                            scheme.ty)\n         }\n     };\n     write_ty_to_tcx(tcx, ctor_id, ctor_ty);\n-    tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n-    tcx.register_item_type(local_def(ctor_id),\n+    tcx.predicates.borrow_mut().insert(DefId::local(ctor_id), predicates);\n+    tcx.register_item_type(DefId::local(ctor_id),\n                            TypeScheme {\n                                generics: scheme.generics,\n                                ty: ctor_ty\n@@ -1089,13 +1089,13 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                did: ast::DefId,\n+                                did: DefId,\n                                 name: ast::Name,\n                                 disr_val: ty::Disr,\n                                 def: &ast::StructDef) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n     let fields = def.fields.iter().map(|f| {\n-        let fid = local_def(f.node.id);\n+        let fid = DefId::local(f.node.id);\n         match f.node.kind {\n             ast::NamedField(ident, vis) => {\n                 let dup_span = seen_fields.get(&ident.name).cloned();\n@@ -1129,7 +1129,7 @@ fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> ty::AdtDefMaster<'tcx>\n {\n \n-    let did = local_def(it.id);\n+    let did = DefId::local(it.id);\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n@@ -1206,7 +1206,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   disr: ty::Disr)\n                                   -> ty::VariantDefData<'tcx, 'tcx>\n     {\n-        let did = local_def(v.node.id);\n+        let did = DefId::local(v.node.id);\n         let name = v.node.name.name;\n         match v.node.kind {\n             ast::TupleVariantKind(ref va) => {\n@@ -1216,7 +1216,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     disr_val: disr,\n                     fields: va.iter().map(|&ast::VariantArg { id, .. }| {\n                         ty::FieldDefData::new(\n-                            local_def(id),\n+                            DefId::local(id),\n                             special_idents::unnamed_field.name,\n                             ast::Visibility::Public\n                         )\n@@ -1228,7 +1228,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         }\n     }\n-    let did = local_def(it.id);\n+    let did = DefId::local(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);\n     let (repr_type, repr_type_ty) = tcx.enum_repr_type(repr_hints.get(0));\n     let mut prev_disr = None;\n@@ -1242,7 +1242,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n         prev_disr = Some(disr);\n         v\n     }).collect();\n-    tcx.intern_adt_def(local_def(it.id), ty::AdtKind::Enum, variants)\n+    tcx.intern_adt_def(DefId::local(it.id), ty::AdtKind::Enum, variants)\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n@@ -1253,14 +1253,14 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// well to guarantee that the transitive superpredicates are\n /// converted.\n fn ensure_super_predicates_step(ccx: &CrateCtxt,\n-                                trait_def_id: ast::DefId)\n-                                -> Vec<ast::DefId>\n+                                trait_def_id: DefId)\n+                                -> Vec<DefId>\n {\n     let tcx = ccx.tcx;\n \n     debug!(\"ensure_super_predicates_step(trait_def_id={:?})\", trait_def_id);\n \n-    if trait_def_id.krate != ast::LOCAL_CRATE {\n+    if trait_def_id.krate != LOCAL_CRATE {\n         // If this trait comes from an external crate, then all of the\n         // supertraits it may depend on also must come from external\n         // crates, and hence all of them already have their\n@@ -1315,7 +1315,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n             predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n         };\n         debug!(\"superpredicates for trait {:?} = {:?}\",\n-               local_def(item.id),\n+               DefId::local(item.id),\n                superpredicates);\n \n         tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n@@ -1338,7 +1338,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                it: &ast::Item)\n                                -> &'tcx ty::TraitDef<'tcx>\n {\n-    let def_id = local_def(it.id);\n+    let def_id = DefId::local(it.id);\n     let tcx = ccx.tcx;\n \n     if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n@@ -1452,7 +1452,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n     let tcx = ccx.tcx;\n     let trait_def = trait_def_of_item(ccx, it);\n \n-    let def_id = local_def(it.id);\n+    let def_id = DefId::local(it.id);\n \n     let (generics, items) = match it.node {\n         ast::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n@@ -1523,10 +1523,10 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n }\n \n fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                  def_id: ast::DefId)\n+                                  def_id: DefId)\n                                   -> ty::TypeScheme<'tcx>\n {\n-    if def_id.krate != ast::LOCAL_CRATE {\n+    if def_id.krate != LOCAL_CRATE {\n         return ccx.tcx.lookup_item_type(def_id);\n     }\n \n@@ -1551,7 +1551,7 @@ fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 -> ty::TypeScheme<'tcx>\n {\n     memoized(&ccx.tcx.tcache,\n-             local_def(it.id),\n+             DefId::local(it.id),\n              |_| compute_type_scheme_of_item(ccx, it))\n }\n \n@@ -1568,7 +1568,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         ast::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n-            let ty = tcx.mk_fn(Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n+            let ty = tcx.mk_fn(Some(DefId::local(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemTy(ref t, ref generics) => {\n@@ -1645,12 +1645,12 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(local_def(it.id),\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(DefId::local(it.id),\n                                                              predicates.clone());\n     assert!(prev_predicates.is_none());\n \n     // Debugging aid.\n-    if tcx.has_attr(local_def(it.id), \"rustc_object_lifetime_default\") {\n+    if tcx.has_attr(DefId::local(it.id), \"rustc_object_lifetime_default\") {\n         let object_lifetime_default_reprs: String =\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n@@ -1673,7 +1673,7 @@ fn type_scheme_of_foreign_item<'a, 'tcx>(\n     -> ty::TypeScheme<'tcx>\n {\n     memoized(&ccx.tcx.tcache,\n-             local_def(it.id),\n+             DefId::local(it.id),\n              |_| compute_type_scheme_of_foreign_item(ccx, it, abi))\n }\n \n@@ -1718,7 +1718,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(local_def(it.id), predicates);\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(DefId::local(it.id), predicates);\n     assert!(prev_predicates.is_none());\n }\n \n@@ -1742,7 +1742,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    -> ty::Generics<'tcx>\n {\n     debug!(\"ty_generics_for_trait(trait_id={:?}, substs={:?})\",\n-           local_def(trait_id), substs);\n+           DefId::local(trait_id), substs);\n \n     let mut generics = ty_generics_for_type_or_impl(ccx, ast_generics);\n \n@@ -1758,8 +1758,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         space: SelfSpace,\n         index: 0,\n         name: special_idents::type_self.name,\n-        def_id: local_def(param_id),\n-        default_def_id: local_def(parent),\n+        def_id: DefId::local(param_id),\n+        default_def_id: DefId::local(parent),\n         default: None,\n         object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n     };\n@@ -1966,7 +1966,7 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n                                            index: i as u32,\n-                                           def_id: local_def(l.lifetime.id),\n+                                           def_id: DefId::local(l.lifetime.id),\n                                            bounds: bounds };\n         result.regions.push(space, def);\n     }\n@@ -2034,8 +2034,8 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         space: space,\n         index: index,\n         name: param.ident.name,\n-        def_id: local_def(param.id),\n-        default_def_id: local_def(parent),\n+        def_id: DefId::local(param.id),\n+        default_def_id: DefId::local(parent),\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n     };\n@@ -2378,7 +2378,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         ty_fold::fold_regions(tcx, value, &mut false, |region, _| {\n             match region {\n                 ty::ReEarlyBound(data) => {\n-                    let def_id = local_def(data.param_id);\n+                    let def_id = DefId::local(data.param_id);\n                     ty::ReFree(ty::FreeRegion { scope: scope,\n                                                 bound_region: ty::BrNamed(def_id, data.name) })\n                 }\n@@ -2391,7 +2391,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n /// Checks that all the type parameters on an impl\n fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                              ast_generics: &ast::Generics,\n-                                             impl_def_id: ast::DefId,\n+                                             impl_def_id: DefId,\n                                              impl_items: &[P<ast::ImplItem>])\n {\n     let impl_scheme = tcx.lookup_item_type(impl_def_id);\n@@ -2425,7 +2425,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let lifetimes_in_associated_types: HashSet<_> =\n         impl_items.iter()\n-                  .map(|item| tcx.impl_or_trait_item(local_def(item.id)))\n+                  .map(|item| tcx.impl_or_trait_item(DefId::local(item.id)))\n                   .filter_map(|item| match item {\n                       ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n                       ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None"}, {"sha": "bb47682d6e6418f6ae135f89cf555e842ea284a9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -105,6 +105,7 @@ pub use rustc::session;\n pub use rustc::util;\n \n use middle::def;\n+use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n use middle::ty::{self, Ty, HasTypeFlags};\n@@ -115,7 +116,6 @@ use util::common::time;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, abi};\n-use syntax::ast_util::local_def;\n \n use std::cell::RefCell;\n \n@@ -238,7 +238,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let se_ty = tcx.mk_fn(Some(local_def(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let se_ty = tcx.mk_fn(Some(DefId::local(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -284,7 +284,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let se_ty = tcx.mk_fn(Some(local_def(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let se_ty = tcx.mk_fn(Some(DefId::local(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {"}, {"sha": "8165da95aedc7498b0cc8464220268d1aebc3ca2", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -266,6 +266,7 @@ use self::ParamKind::*;\n \n use arena;\n use arena::TypedArena;\n+use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::resolve_lifetime as rl;\n use middle::subst;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n@@ -274,7 +275,6 @@ use rustc::ast_map;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::visit;\n use syntax::visit::Visitor;\n use util::nodemap::NodeMap;\n@@ -404,7 +404,7 @@ fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n \n     all.into_iter()\n        .filter(|&(ref d,_)| d.is_some())\n-       .filter(|&(ref d,_)| d.as_ref().unwrap().krate == ast::LOCAL_CRATE)\n+       .filter(|&(ref d,_)| d.as_ref().unwrap().is_local())\n        .map(|(d, v)| (d.unwrap().node, v))\n        .collect()\n }\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         if self.num_inferred() == inferreds_on_entry {\n             let newly_added =\n                 self.tcx.item_variance_map.borrow_mut().insert(\n-                    ast_util::local_def(item_id),\n+                    DefId::local(item_id),\n                     self.empty_variances.clone()).is_none();\n             assert!(newly_added);\n         }\n@@ -485,7 +485,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n-               self.tcx.item_path_str(ast_util::local_def(item_id)),\n+               self.tcx.item_path_str(DefId::local(item_id)),\n                item_id, kind, space, index, param_id, inf_index,\n                initial_variance);\n     }\n@@ -596,7 +596,7 @@ fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        let did = ast_util::local_def(item.id);\n+        let did = DefId::local(item.id);\n         let tcx = self.terms_cx.tcx;\n \n         debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n@@ -732,15 +732,15 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Returns a variance term representing the declared variance of the type/region parameter\n     /// with the given id.\n     fn declared_variance(&self,\n-                         param_def_id: ast::DefId,\n-                         item_def_id: ast::DefId,\n+                         param_def_id: DefId,\n+                         item_def_id: DefId,\n                          kind: ParamKind,\n                          space: ParamSpace,\n                          index: usize)\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n-        if param_def_id.krate == ast::LOCAL_CRATE {\n+        if param_def_id.is_local() {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n@@ -923,7 +923,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyParam(ref data) => {\n                 let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n-                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+                assert_eq!(def_id.krate, LOCAL_CRATE);\n                 match self.terms_cx.inferred_map.get(&def_id.node) {\n                     Some(&index) => {\n                         self.add_constraint(index, variance);\n@@ -958,7 +958,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n                                    generics: &ty::Generics<'tcx>,\n-                                   def_id: ast::DefId,\n+                                   def_id: DefId,\n                                    type_param_defs: &[ty::TypeParameterDef<'tcx>],\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs<'tcx>,\n@@ -1164,7 +1164,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                     item_id,\n                     item_variances);\n \n-            let item_def_id = ast_util::local_def(item_id);\n+            let item_def_id = DefId::local(item_id);\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found."}, {"sha": "b79c35a0963e6583e5ec1d81cf8564eab90a3289", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -13,12 +13,12 @@\n use std::collections::HashSet;\n \n use syntax::ast;\n-use syntax::ast_util;\n use syntax::attr::AttrMetaMethods;\n \n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n+use rustc::middle::def_id::DefId;\n use rustc::middle::ty;\n use rustc::middle::subst;\n use rustc::middle::stability;\n@@ -53,7 +53,7 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n         None => return None,\n     };\n     let did = def.def_id();\n-    if ast_util::is_local(did) { return None }\n+    if did.is_local() { return None }\n     try_inline_def(cx, tcx, def).map(|vec| {\n         vec.into_iter().map(|mut item| {\n             match into {\n@@ -127,7 +127,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n }\n \n pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n-                  did: ast::DefId) -> Vec<clean::Attribute> {\n+                  did: DefId) -> Vec<clean::Attribute> {\n     let attrs = csearch::get_item_attrs(&tcx.sess.cstore, did);\n     attrs.into_iter().map(|a| a.clean(cx)).collect()\n }\n@@ -136,7 +136,7 @@ pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind) {\n+pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     match cx.tcx_opt() {\n         Some(tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n@@ -148,7 +148,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind\n }\n \n pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n-                            did: ast::DefId) -> clean::Trait {\n+                            did: DefId) -> clean::Trait {\n     let def = tcx.lookup_trait_def(did);\n     let trait_items = tcx.trait_items(did).clean(cx);\n     let predicates = tcx.lookup_predicates(did);\n@@ -163,7 +163,7 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n     }\n }\n \n-fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Function {\n+fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: DefId) -> clean::Function {\n     let t = tcx.lookup_item_type(did);\n     let (decl, style, abi) = match t.ty.sty {\n         ty::TyBareFn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n@@ -179,7 +179,7 @@ fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) ->\n     }\n }\n \n-fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n+fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: DefId) -> clean::Struct {\n     use syntax::parse::token::special_idents::unnamed_field;\n \n     let t = tcx.lookup_item_type(did);\n@@ -199,7 +199,7 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n     }\n }\n \n-fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n+fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: DefId) -> clean::ItemEnum {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n@@ -220,7 +220,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n }\n \n pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n-                   did: ast::DefId) -> Vec<clean::Item> {\n+                   did: DefId) -> Vec<clean::Item> {\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n@@ -270,7 +270,7 @@ pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n \n pub fn build_impl(cx: &DocContext,\n                   tcx: &ty::ctxt,\n-                  did: ast::DefId,\n+                  did: DefId,\n                   ret: &mut Vec<clean::Item>) {\n     if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n         return\n@@ -428,15 +428,15 @@ pub fn build_impl(cx: &DocContext,\n }\n \n fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n-                did: ast::DefId) -> clean::Module {\n+                did: DefId) -> clean::Module {\n     let mut items = Vec::new();\n     fill_in(cx, tcx, did, &mut items);\n     return clean::Module {\n         items: items,\n         is_crate: false,\n     };\n \n-    fn fill_in(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId,\n+    fn fill_in(cx: &DocContext, tcx: &ty::ctxt, did: DefId,\n                items: &mut Vec<clean::Item>) {\n         // If we're reexporting a reexport it may actually reexport something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n@@ -464,7 +464,7 @@ fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n }\n \n fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n-               did: ast::DefId) -> clean::Constant {\n+               did: DefId) -> clean::Constant {\n     use rustc::middle::const_eval;\n     use syntax::print::pprust;\n \n@@ -482,7 +482,7 @@ fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n }\n \n fn build_static(cx: &DocContext, tcx: &ty::ctxt,\n-                did: ast::DefId,\n+                did: DefId,\n                 mutable: bool) -> clean::Static {\n     clean::Static {\n         type_: tcx.lookup_item_type(did).ty.clean(cx),\n@@ -498,7 +498,7 @@ fn build_static(cx: &DocContext, tcx: &ty::ctxt,\n ///\n /// The inverse of this filtering logic can be found in the `Clean`\n /// implementation for `AssociatedType`\n-fn filter_non_trait_generics(trait_did: ast::DefId, mut g: clean::Generics)\n+fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics)\n                              -> clean::Generics {\n     g.where_predicates.retain(|pred| {\n         match *pred {"}, {"sha": "6a2d0b46ad420652e2e2993795b71f231bc9b232", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -27,7 +27,6 @@ pub use self::FunctionRetTy::*;\n use syntax;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap;\n@@ -40,6 +39,7 @@ use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n+use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::middle::ty;\n use rustc::middle::stability;\n@@ -61,7 +61,7 @@ mod inline;\n mod simplify;\n \n // extract the stability index for a node from tcx, if possible\n-fn get_stability(cx: &DocContext, def_id: ast::DefId) -> Option<Stability> {\n+fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n     cx.tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id)).clean(cx)\n }\n \n@@ -121,7 +121,7 @@ pub struct Crate {\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n     pub primitives: Vec<PrimitiveType>,\n-    pub external_traits: HashMap<ast::DefId, Trait>,\n+    pub external_traits: HashMap<DefId, Trait>,\n }\n \n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n@@ -186,7 +186,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     attrs: child.attrs.clone(),\n                     visibility: Some(ast::Public),\n                     stability: None,\n-                    def_id: ast_util::local_def(prim.to_node_id()),\n+                    def_id: DefId::local(prim.to_node_id()),\n                     inner: PrimitiveItem(prim),\n                 });\n             }\n@@ -252,7 +252,7 @@ pub struct Item {\n     pub attrs: Vec<Attribute> ,\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub stability: Option<Stability>,\n }\n \n@@ -417,7 +417,7 @@ impl Clean<Item> for doctree::Module {\n             source: whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items: items\n@@ -484,7 +484,7 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct TyParam {\n     pub name: String,\n-    pub did: ast::DefId,\n+    pub did: DefId,\n     pub bounds: Vec<TyParamBound>,\n     pub default: Option<Type>,\n }\n@@ -493,7 +493,7 @@ impl Clean<TyParam> for ast::TyParam {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n             name: self.ident.clean(cx),\n-            did: ast::DefId { krate: ast::LOCAL_CRATE, node: self.id },\n+            did: DefId { krate: LOCAL_CRATE, node: self.id },\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx),\n         }\n@@ -577,7 +577,7 @@ impl<'tcx> Clean<(Vec<TyParamBound>, Vec<TypeBinding>)> for ty::ExistentialBound\n     }\n }\n \n-fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n+fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n                         bindings: Vec<TypeBinding>, substs: &subst::Substs) -> PathParameters {\n     let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n                     .iter()\n@@ -622,7 +622,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n \n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext, name: &str, trait_did: Option<ast::DefId>,\n+fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>,\n                  bindings: Vec<TypeBinding>, substs: &subst::Substs) -> Path {\n     Path {\n         global: false,\n@@ -1084,7 +1084,7 @@ impl Clean<Item> for doctree::Function {\n             source: self.whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(cx),\n                 generics: self.generics.clean(cx),\n@@ -1131,7 +1131,7 @@ impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::PolyFnSig<'tcx>) {\n+impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n@@ -1207,7 +1207,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: TraitItem(Trait {\n@@ -1257,9 +1257,9 @@ impl Clean<Item> for ast::TraitItem {\n             name: Some(self.ident.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: None,\n-            stability: get_stability(cx, ast_util::local_def(self.id)),\n+            stability: get_stability(cx, DefId::local(self.id)),\n             inner: inner\n         }\n     }\n@@ -1296,9 +1296,9 @@ impl Clean<Item> for ast::ImplItem {\n             name: Some(self.ident.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, ast_util::local_def(self.id)),\n+            stability: get_stability(cx, DefId::local(self.id)),\n             inner: inner\n         }\n     }\n@@ -1403,7 +1403,7 @@ pub enum Type {\n     ResolvedPath {\n         path: Path,\n         typarams: Option<Vec<TyParamBound>>,\n-        did: ast::DefId,\n+        did: DefId,\n         /// true if is a `T::Name` path for associated types\n         is_generic: bool,\n     },\n@@ -1665,7 +1665,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n+                decl: (DefId::local(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n             }),\n             ty::TyStruct(def, substs) |\n@@ -1733,8 +1733,8 @@ impl Clean<Item> for ast::StructField {\n             attrs: self.node.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: Some(vis),\n-            stability: get_stability(cx, ast_util::local_def(self.node.id)),\n-            def_id: ast_util::local_def(self.node.id),\n+            stability: get_stability(cx, DefId::local(self.node.id)),\n+            def_id: DefId::local(self.node.id),\n             inner: StructFieldItem(TypedStructField(self.node.ty.clean(cx))),\n         }\n     }\n@@ -1787,7 +1787,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: StructItem(Struct {\n@@ -1833,7 +1833,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: EnumItem(Enum {\n@@ -1858,7 +1858,7 @@ impl Clean<Item> for doctree::Variant {\n             source: self.whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.kind.clean(cx),\n             }),\n@@ -2094,7 +2094,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(self.id.clone()),\n+            def_id: DefId::local(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: TypedefItem(Typedef {\n@@ -2145,7 +2145,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: StaticItem(Static {\n@@ -2169,7 +2169,7 @@ impl Clean<Item> for doctree::Constant {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: ConstantItem(Constant {\n@@ -2243,7 +2243,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: ImplItem(Impl {\n@@ -2274,7 +2274,7 @@ fn build_deref_target_impls(cx: &DocContext,\n             _ => continue,\n         };\n         let primitive = match *target {\n-            ResolvedPath { did, .. } if ast_util::is_local(did) => continue,\n+            ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n                 ret.extend(inline::build_impls(cx, tcx, did));\n                 continue\n@@ -2306,7 +2306,7 @@ fn build_deref_target_impls(cx: &DocContext,\n             PrimitiveRawPointer => tcx.lang_items.const_ptr_impl(),\n         };\n         if let Some(did) = did {\n-            if !ast_util::is_local(did) {\n+            if !did.is_local() {\n                 inline::build_impl(cx, tcx, did, ret);\n             }\n         }\n@@ -2325,7 +2325,7 @@ impl Clean<Item> for doctree::DefaultImpl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: Some(ast::Public),\n             stability: None,\n             inner: DefaultImplItem(DefaultImpl {\n@@ -2342,7 +2342,7 @@ impl Clean<Item> for doctree::ExternCrate {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(0),\n+            def_id: DefId::local(0),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             inner: ExternCrateItem(self.name.clean(cx), self.path.clone())\n@@ -2407,7 +2407,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: ast_util::local_def(0),\n+            def_id: DefId::local(0),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             inner: ImportItem(inner)\n@@ -2429,14 +2429,14 @@ pub enum Import {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImportSource {\n     pub path: Path,\n-    pub did: Option<ast::DefId>,\n+    pub did: Option<DefId>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ViewListIdent {\n     pub name: String,\n     pub rename: Option<String>,\n-    pub source: Option<ast::DefId>,\n+    pub source: Option<DefId>,\n }\n \n impl Clean<ViewListIdent> for ast::PathListItem {\n@@ -2493,9 +2493,9 @@ impl Clean<Item> for ast::ForeignItem {\n             name: Some(self.ident.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, ast_util::local_def(self.id)),\n+            stability: get_stability(cx, DefId::local(self.id)),\n             inner: inner,\n         }\n     }\n@@ -2626,7 +2626,7 @@ fn resolve_type(cx: &DocContext,\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n-fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n+fn register_def(cx: &DocContext, def: def::Def) -> DefId {\n     let (did, kind) = match def {\n         def::DefFn(i, _) => (i, TypeFunction),\n         def::DefTy(i, false) => (i, TypeTypedef),\n@@ -2638,7 +2638,7 @@ fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n         def::DefVariant(i, _, _) => (i, TypeEnum),\n         _ => return def.def_id()\n     };\n-    if ast_util::is_local(did) { return did }\n+    if did.is_local() { return did }\n     let tcx = match cx.tcx_opt() {\n         Some(tcx) => tcx,\n         None => return did\n@@ -2658,7 +2658,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n     }\n }\n \n-fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n+fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<DefId> {\n     cx.tcx_opt().and_then(|tcx| {\n         tcx.def_map.borrow().get(&id).map(|d| register_def(cx, d.full_def()))\n     })\n@@ -2678,7 +2678,7 @@ impl Clean<Item> for doctree::Macro {\n             source: self.whence.clean(cx),\n             visibility: ast::Public.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n+            def_id: DefId::local(self.id),\n             inner: MacroItem(Macro {\n                 source: self.whence.to_src(cx),\n                 imported_from: self.imported_from.clean(cx),\n@@ -2811,7 +2811,7 @@ impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>,\n     }\n }\n \n-fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n+fn lang_struct(cx: &DocContext, did: Option<DefId>,\n                t: ty::Ty, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {\n     let did = match did {"}, {"sha": "716b88d5534ae865795f7f502ce61103ac9295db", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -29,8 +29,8 @@\n use std::mem;\n use std::collections::HashMap;\n \n+use rustc::middle::def_id::DefId;\n use rustc::middle::subst;\n-use syntax::ast;\n \n use clean::PathParameters as PP;\n use clean::WherePredicate as WP;\n@@ -148,8 +148,8 @@ fn ty_bounds(bounds: Vec<clean::TyParamBound>) -> Vec<clean::TyParamBound> {\n     bounds\n }\n \n-fn trait_is_same_or_supertrait(cx: &DocContext, child: ast::DefId,\n-                               trait_: ast::DefId) -> bool {\n+fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n+                               trait_: DefId) -> bool {\n     if child == trait_ {\n         return true\n     }"}, {"sha": "89b87eb73d62142ec26faa5bfa9acf07c1f64dde", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -12,6 +12,7 @@ pub use self::MaybeTyped::*;\n use rustc_lint;\n use rustc_driver::{driver, target_features};\n use rustc::session::{self, config};\n+use rustc::middle::def_id::DefId;\n use rustc::middle::{privacy, ty};\n use rustc::ast_map;\n use rustc::lint;\n@@ -37,19 +38,19 @@ pub enum MaybeTyped<'a, 'tcx: 'a> {\n     NotTyped(session::Session)\n }\n \n-pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n+pub type ExternalPaths = RefCell<Option<HashMap<DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n     pub krate: &'tcx ast::Crate,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n     pub external_paths: ExternalPaths,\n-    pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n-    pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n-    pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n+    pub external_traits: RefCell<Option<HashMap<DefId, clean::Trait>>>,\n+    pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n+    pub inlined: RefCell<Option<HashSet<DefId>>>,\n     pub populated_crate_impls: RefCell<HashSet<ast::CrateNum>>,\n-    pub deref_trait_did: Cell<Option<ast::DefId>>,\n+    pub deref_trait_did: Cell<Option<DefId>>,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -77,9 +78,9 @@ pub struct CrateAnalysis {\n     pub exported_items: privacy::ExportedItems,\n     pub public_items: privacy::PublicItems,\n     pub external_paths: ExternalPaths,\n-    pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n-    pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n-    pub deref_trait_did: Option<ast::DefId>,\n+    pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n+    pub inlined: RefCell<Option<HashSet<DefId>>>,\n+    pub deref_trait_did: Option<DefId>,\n }\n \n pub type Externs = HashMap<String, Vec<String>>;"}, {"sha": "bad36ecd0548c1c8332d798512be85d618c95582", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -18,9 +18,9 @@\n use std::fmt;\n use std::iter::repeat;\n \n+use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::ast_util;\n \n use clean;\n use html::item_type::ItemType;\n@@ -287,14 +287,14 @@ impl fmt::Display for clean::Path {\n     }\n }\n \n-pub fn href(did: ast::DefId) -> Option<(String, ItemType, Vec<String>)> {\n+pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n     let cache = cache();\n     let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n     let &(ref fqp, shortty) = match cache.paths.get(&did) {\n         Some(p) => p,\n         None => return None,\n     };\n-    let mut url = if ast_util::is_local(did) || cache.inlined.contains(&did) {\n+    let mut url = if did.is_local() || cache.inlined.contains(&did) {\n         repeat(\"../\").take(loc.len()).collect::<String>()\n     } else {\n         match cache.extern_locations[&did.krate] {\n@@ -324,7 +324,7 @@ pub fn href(did: ast::DefId) -> Option<(String, ItemType, Vec<String>)> {\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, path: &clean::Path,\n+fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                  print_all: bool) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n     let rel_root = match &*path.segments[0].name {\n@@ -374,7 +374,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n     let m = cache();\n     let mut needs_termination = false;\n     match m.primitive_locations.get(&prim) {\n-        Some(&ast::LOCAL_CRATE) => {\n+        Some(&LOCAL_CRATE) => {\n             let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n             let len = if len == 0 {0} else {len - 1};\n             try!(write!(f, \"<a href='{}primitive.{}.html'>\",\n@@ -383,7 +383,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n-            let path = &m.paths[&ast::DefId {\n+            let path = &m.paths[&DefId {\n                 krate: cnum,\n                 node: ast::CRATE_NODE_ID,\n             }];"}, {"sha": "e2248b1204e203f400b7eccc4685a7d46aab6f77", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -52,7 +52,8 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json::{self, ToJson};\n-use syntax::{abi, ast, ast_util, attr};\n+use syntax::{abi, ast, attr};\n+use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n use rustc::util::nodemap::NodeSet;\n \n use clean::{self, SelfTy};\n@@ -120,7 +121,7 @@ pub enum ExternalLocation {\n \n /// Metadata about an implementor of a trait.\n pub struct Implementor {\n-    pub def_id: ast::DefId,\n+    pub def_id: DefId,\n     pub stability: Option<clean::Stability>,\n     pub impl_: clean::Impl,\n }\n@@ -134,7 +135,7 @@ pub struct Impl {\n }\n \n impl Impl {\n-    fn trait_did(&self) -> Option<ast::DefId> {\n+    fn trait_did(&self) -> Option<DefId> {\n         self.impl_.trait_.as_ref().and_then(|tr| {\n             if let clean::ResolvedPath { did, .. } = *tr {Some(did)} else {None}\n         })\n@@ -155,37 +156,37 @@ pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n     /// painfully maintain a context like this)\n-    pub typarams: HashMap<ast::DefId, String>,\n+    pub typarams: HashMap<DefId, String>,\n \n     /// Maps a type id to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<ast::DefId, Vec<Impl>>,\n+    pub impls: HashMap<DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: HashMap<ast::DefId, (Vec<String>, ItemType)>,\n+    pub paths: HashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: HashMap<ast::DefId, Vec<String>>,\n+    pub external_paths: HashMap<DefId, Vec<String>>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    pub traits: HashMap<ast::DefId, clean::Trait>,\n+    pub traits: HashMap<DefId, clean::Trait>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: HashMap<ast::DefId, Vec<Implementor>>,\n+    pub implementors: HashMap<DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n     pub extern_locations: HashMap<ast::CrateNum, (String, ExternalLocation)>,\n@@ -194,17 +195,17 @@ pub struct Cache {\n     pub primitive_locations: HashMap<clean::PrimitiveType, ast::CrateNum>,\n \n     /// Set of definitions which have been inlined from external crates.\n-    pub inlined: HashSet<ast::DefId>,\n+    pub inlined: HashSet<DefId>,\n \n     // Private fields only used when initially crawling a crate to build a cache\n \n     stack: Vec<String>,\n-    parent_stack: Vec<ast::DefId>,\n+    parent_stack: Vec<DefId>,\n     search_index: Vec<IndexItem>,\n     privmod: bool,\n     remove_priv: bool,\n     public_items: NodeSet,\n-    deref_trait_did: Option<ast::DefId>,\n+    deref_trait_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n@@ -246,7 +247,7 @@ struct IndexItem {\n     name: String,\n     path: String,\n     desc: String,\n-    parent: Option<ast::DefId>,\n+    parent: Option<DefId>,\n     search_type: Option<IndexItemFunctionType>,\n }\n \n@@ -376,7 +377,7 @@ pub fn run(mut krate: clean::Crate,\n     let analysis = analysis.borrow();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n     let public_items = public_items.unwrap_or(NodeSet());\n-    let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n+    let paths: HashMap<DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();\n         paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t)))).collect()\n@@ -410,7 +411,7 @@ pub fn run(mut krate: clean::Crate,\n     for &(n, ref e) in &krate.externs {\n         cache.extern_locations.insert(n, (e.name.clone(),\n                                           extern_location(e, &cx.dst)));\n-        let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n+        let did = DefId { krate: n, node: ast::CRATE_NODE_ID };\n         cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n@@ -424,7 +425,7 @@ pub fn run(mut krate: clean::Crate,\n         }\n     }\n     for &prim in &krate.primitives {\n-        cache.primitive_locations.insert(prim, ast::LOCAL_CRATE);\n+        cache.primitive_locations.insert(prim, LOCAL_CRATE);\n     }\n \n     cache.stack.push(krate.name.clone());\n@@ -458,7 +459,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n         for &(pid, ref item) in orphan_methods {\n-            let did = ast_util::local_def(pid);\n+            let did = DefId::local(pid);\n             match paths.get(&did) {\n                 Some(&(ref fqp, _)) => {\n                     // Needed to determine `self` type.\n@@ -963,7 +964,7 @@ impl DocFolder for Cache {\n                     });\n                 }\n                 (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n-                    if ast_util::is_local(parent) {\n+                    if parent.is_local() {\n                         // We have a parent, but we don't know where they're\n                         // defined yet. Wait for later to index this item.\n                         self.orphan_methods.push((parent.node, item.clone()))\n@@ -994,7 +995,7 @@ impl DocFolder for Cache {\n                 // not a public item.\n                 let id = item.def_id.node;\n                 if !self.paths.contains_key(&item.def_id) ||\n-                   !ast_util::is_local(item.def_id) ||\n+                   !item.def_id.is_local() ||\n                    self.public_items.contains(&id) {\n                     self.paths.insert(item.def_id,\n                                       (self.stack.clone(), shortty(&item)));\n@@ -1031,7 +1032,7 @@ impl DocFolder for Cache {\n                     ref t => {\n                         match t.primitive_type() {\n                             Some(prim) => {\n-                                let did = ast_util::local_def(prim.to_node_id());\n+                                let did = DefId::local(prim.to_node_id());\n                                 self.parent_stack.push(did);\n                                 true\n                             }\n@@ -1077,7 +1078,7 @@ impl DocFolder for Cache {\n                                 t.primitive_type().and_then(|t| {\n                                     self.primitive_locations.get(&t).map(|n| {\n                                         let id = t.to_node_id();\n-                                        ast::DefId { krate: *n, node: id }\n+                                        DefId { krate: *n, node: id }\n                                     })\n                                 })\n                             }\n@@ -1383,7 +1384,7 @@ impl<'a> Item<'a> {\n         // If this item is part of the local crate, then we're guaranteed to\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n-        } else if ast_util::is_local(self.item.def_id) {\n+        } else if self.item.def_id.is_local() {\n             let mut path = Vec::new();\n             clean_srcpath(&cx.src_root, Path::new(&self.item.source.filename),\n                           true, |component| {\n@@ -1934,7 +1935,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                               src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n                       </script>\"#,\n                 root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n-                path = if ast_util::is_local(it.def_id) {\n+                path = if it.def_id.is_local() {\n                     cx.current.join(\"/\")\n                 } else {\n                     let path = &cache.external_paths[&it.def_id];\n@@ -2247,7 +2248,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n #[derive(Copy, Clone)]\n enum AssocItemLink {\n     Anchor,\n-    GotoSource(ast::DefId),\n+    GotoSource(DefId),\n }\n \n enum AssocItemRender<'a> {\n@@ -2257,7 +2258,7 @@ enum AssocItemRender<'a> {\n \n fn render_assoc_items(w: &mut fmt::Formatter,\n                       cx: &Context,\n-                      it: ast::DefId,\n+                      it: DefId,\n                       what: AssocItemRender) -> fmt::Result {\n     let c = cache();\n     let v = match c.impls.get(&it) {\n@@ -2334,7 +2335,7 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl) -> f\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n-                    let did = ast::DefId { krate: *c, node: prim.to_node_id() };\n+                    let did = DefId { krate: *c, node: prim.to_node_id() };\n                     try!(render_assoc_items(w, cx, did, what));\n                 }\n             }\n@@ -2427,7 +2428,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n     fn render_default_items(w: &mut fmt::Formatter,\n                             cx: &Context,\n-                            did: ast::DefId,\n+                            did: DefId,\n                             t: &clean::Trait,\n                               i: &clean::Impl,\n                               render_static: bool) -> fmt::Result {"}, {"sha": "3d255977cb57e73897238284eae85fbc595ab284", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -14,7 +14,6 @@ use std::cmp;\n use std::string::String;\n use std::usize;\n use syntax::ast;\n-use syntax::ast_util;\n \n use clean;\n use clean::Item;\n@@ -131,7 +130,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::TraitItem(..) | clean::FunctionItem(..) |\n             clean::VariantItem(..) | clean::MethodItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n-                if ast_util::is_local(i.def_id) {\n+                if i.def_id.is_local() {\n                     if !self.exported_items.contains(&i.def_id.node) {\n                         return None;\n                     }\n@@ -143,7 +142,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             }\n \n             clean::ConstantItem(..) => {\n-                if ast_util::is_local(i.def_id) &&\n+                if i.def_id.is_local() &&\n                    !self.exported_items.contains(&i.def_id.node) {\n                     return None;\n                 }\n@@ -171,7 +170,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::ImplItem(clean::Impl{\n                 for_: clean::ResolvedPath{ did, .. }, ..\n             }) => {\n-                if ast_util::is_local(did) &&\n+                if did.is_local() &&\n                    !self.exported_items.contains(&did.node) {\n                     return None;\n                 }\n@@ -238,7 +237,7 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n             match imp.trait_ {\n                 Some(clean::ResolvedPath{ did, .. }) => {\n                     let ImplStripper(s) = *self;\n-                    if ast_util::is_local(did) && !s.contains(&did.node) {\n+                    if did.is_local() && !s.contains(&did.node) {\n                         return None;\n                     }\n                 }"}, {"sha": "e7bbe943952ac1d6aeed18b6ab4c50941a321f2b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -16,12 +16,12 @@ use std::mem;\n \n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n use rustc::ast_map;\n+use rustc::middle::def_id::DefId;\n use rustc::middle::stability;\n \n use core;\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n         self.cx.tcx_opt().and_then(\n-            |tcx| stability::lookup(tcx, ast_util::local_def(id)).map(|x| x.clone()))\n+            |tcx| stability::lookup(tcx, DefId::local(id)).map(|x| x.clone()))\n     }\n \n     pub fn visit(&mut self, krate: &ast::Crate) {\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false\n         };\n         let def = tcx.def_map.borrow()[&id].def_id();\n-        if !ast_util::is_local(def) { return false }\n+        if !def.is_local() { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false\n         };"}, {"sha": "66faa1227e6d6914707513d6dc5168c101fd17b1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -65,7 +65,6 @@ use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use print::pprust;\n use ptr::P;\n \n-use std::cell::Cell;\n use std::fmt;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -371,37 +370,7 @@ pub type CrateNum = u32;\n \n pub type NodeId = u32;\n \n-#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n-           RustcDecodable, Hash, Copy)]\n-pub struct DefId {\n-    pub krate: CrateNum,\n-    pub node: NodeId,\n-}\n-\n-fn default_def_id_debug(_: DefId, _: &mut fmt::Formatter) -> fmt::Result { Ok(()) }\n-\n-thread_local!(pub static DEF_ID_DEBUG: Cell<fn(DefId, &mut fmt::Formatter) -> fmt::Result> =\n-                Cell::new(default_def_id_debug));\n-\n-impl fmt::Debug for DefId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"DefId {{ krate: {}, node: {} }}\",\n-                    self.krate, self.node));\n-        DEF_ID_DEBUG.with(|def_id_debug| def_id_debug.get()(*self, f))\n-    }\n-}\n-\n-impl DefId {\n-    /// Read the node id, asserting that this def-id is krate-local.\n-    pub fn local_id(&self) -> NodeId {\n-        assert_eq!(self.krate, LOCAL_CRATE);\n-        self.node\n-    }\n-}\n-\n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n-pub const LOCAL_CRATE: CrateNum = 0;\n+/// Node id used to represent the root of the crate.\n pub const CRATE_NODE_ID: NodeId = 0;\n \n /// When parsing and doing expansions, we initially give all AST nodes this AST"}, {"sha": "45a41edae6c3744fe31ff38912168b5e520657a3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db67cbe43dfce043c664c53d709b91252d5afc9e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=db67cbe43dfce043c664c53d709b91252d5afc9e", "patch": "@@ -28,12 +28,6 @@ pub fn path_name_i(idents: &[Ident]) -> String {\n     idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n }\n \n-pub fn local_def(id: NodeId) -> DefId {\n-    ast::DefId { krate: LOCAL_CRATE, node: id }\n-}\n-\n-pub fn is_local(did: ast::DefId) -> bool { did.krate == LOCAL_CRATE }\n-\n pub fn stmt_id(s: &Stmt) -> NodeId {\n     match s.node {\n       StmtDecl(_, id) => id,"}]}