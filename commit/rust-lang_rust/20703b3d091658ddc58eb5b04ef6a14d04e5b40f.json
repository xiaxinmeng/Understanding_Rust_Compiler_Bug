{"sha": "20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNzAzYjNkMDkxNjU4ZGRjNThlYjViMDRlZjZhMTRkMDRlNWI0MGY=", "commit": {"author": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-03-11T02:29:22Z"}, "committer": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-03-23T01:21:29Z"}, "message": "introduce trait engine mod", "tree": {"sha": "99bdcbe609bedcb051532ad6928d9dee856ddf51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99bdcbe609bedcb051532ad6928d9dee856ddf51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "html_url": "https://github.com/rust-lang/rust/commit/20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52f7e8836cc2e6c0edfaf402ee40ca724a8c0989", "url": "https://api.github.com/repos/rust-lang/rust/commits/52f7e8836cc2e6c0edfaf402ee40ca724a8c0989", "html_url": "https://github.com/rust-lang/rust/commit/52f7e8836cc2e6c0edfaf402ee40ca724a8c0989"}], "stats": {"total": 246, "additions": 160, "deletions": 86}, "files": [{"sha": "eb693ea3c6a53bec94a3adf948e1a24580911fd9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -27,7 +27,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n use ty::relate::RelateResult;\n-use traits::{self, ObligationCause, PredicateObligations};\n+use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use rustc_data_structures::unify as ut;\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::BTreeMap;"}, {"sha": "17cd7d8d9c7cece918b4d3b1c56d9b431acee3ec", "filename": "src/librustc/traits/engine.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use ty::{self, Ty, TyCtxt};\n+use hir::def_id::DefId;\n+\n+use super::{FulfillmentContext, FulfillmentError};\n+use super::{ObligationCause, PredicateObligation, PendingPredicateObligation};\n+\n+pub trait TraitEngine<'tcx> {\n+    /// \"Normalize\" a projection type `<SomeType as SomeTrait>::X` by\n+    /// creating a fresh type variable `$0` as well as a projection\n+    /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n+    /// inference engine runs, it will attempt to find an impl of\n+    /// `SomeTrait` or a where clause that lets us unify `$0` with\n+    /// something concrete. If this fails, we'll unify `$0` with\n+    /// `projection_ty` again.\n+    fn normalize_projection_type<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx>;\n+\n+    /// Requires that `ty` must implement the trait with `def_id` in\n+    /// the given environment. This trait must not have any type\n+    /// parameters (except for `Self`).\n+    fn register_bound<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        cause: ObligationCause<'tcx>,\n+    );\n+\n+    fn register_predicate_obligation<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    );\n+\n+    fn select_all_or_error<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn select_where_possible<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>>;\n+}\n+\n+impl<'tcx> dyn TraitEngine<'tcx> {\n+    pub fn new(_tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+        Box::new(FulfillmentContext::new())\n+    }\n+}"}, {"sha": "3e4c4b2cae05b6ea9593a2005ef8d502cf48072e", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -21,6 +21,7 @@ use middle::const_val::{ConstEvalErr, ErrKind};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n+use super::engine::TraitEngine;\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n@@ -84,20 +85,73 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             register_region_obligations: false\n         }\n     }\n+    \n+    pub fn register_predicate_obligations<I>(&mut self,\n+                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             obligations: I)\n+        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n+    {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+\n+    /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n+    /// only attempts to select obligations that haven't been seen before.\n+    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n+              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n+        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n+\n+        let mut errors = Vec::new();\n+\n+        loop {\n+            debug!(\"select: starting another iteration\");\n+\n+            // Process pending obligations.\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n+                selcx,\n+                register_region_obligations: self.register_region_obligations\n+            });\n+            debug!(\"select: outcome={:?}\", outcome);\n+\n+            // FIXME: if we kept the original cache key, we could mark projection\n+            // obligations as complete for the projection cache here.\n+\n+            errors.extend(\n+                outcome.errors.into_iter()\n+                              .map(|e| to_fulfillment_error(e)));\n+\n+            // If nothing new was added, no need to keep looping.\n+            if outcome.stalled {\n+                break;\n+            }\n+        }\n+\n+        debug!(\"select({} predicates remaining, {} errors) done\",\n+               self.predicates.len(), errors.len());\n \n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+}\n+\n+impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// \"Normalize\" a projection type `<SomeType as SomeTrait>::X` by\n     /// creating a fresh type variable `$0` as well as a projection\n     /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n     /// inference engine runs, it will attempt to find an impl of\n     /// `SomeTrait` or a where clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n-    pub fn normalize_projection_type(&mut self,\n-                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                     param_env: ty::ParamEnv<'tcx>,\n-                                     projection_ty: ty::ProjectionTy<'tcx>,\n-                                     cause: ObligationCause<'tcx>)\n-                                     -> Ty<'tcx>\n+    fn normalize_projection_type<'a, 'gcx>(&mut self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                 param_env: ty::ParamEnv<'tcx>,\n+                                 projection_ty: ty::ProjectionTy<'tcx>,\n+                                 cause: ObligationCause<'tcx>)\n+                                 -> Ty<'tcx>\n     {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n@@ -125,12 +179,12 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Requires that `ty` must implement the trait with `def_id` in\n     /// the given environment. This trait must not have any type\n     /// parameters (except for `Self`).\n-    pub fn register_bound(&mut self,\n-                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: Ty<'tcx>,\n-                          def_id: DefId,\n-                          cause: ObligationCause<'tcx>)\n+    fn register_bound<'a, 'gcx>(&mut self,\n+                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      ty: Ty<'tcx>,\n+                      def_id: DefId,\n+                      cause: ObligationCause<'tcx>)\n     {\n         let trait_ref = ty::TraitRef {\n             def_id,\n@@ -144,9 +198,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligation(&mut self,\n-                                         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                         obligation: PredicateObligation<'tcx>)\n+    fn register_predicate_obligation<'a, 'gcx>(&mut self,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                     obligation: PredicateObligation<'tcx>)\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n@@ -162,19 +216,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligations<I>(&mut self,\n-                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             obligations: I)\n-        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n-    {\n-        for obligation in obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-    }\n-\n-    pub fn select_all_or_error(&mut self,\n-                               infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                               -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_all_or_error<'a, 'gcx>(&mut self,\n+                           infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                           -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n \n@@ -190,58 +234,17 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_where_possible(&mut self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                                 -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_where_possible<'a, 'gcx>(&mut self,\n+                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                             -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n     }\n \n-    pub fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n+    fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n         self.predicates.pending_obligations()\n     }\n-\n-    /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n-    /// only attempts to select obligations that haven't been seen before.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n-              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n-        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n-\n-        let mut errors = Vec::new();\n-\n-        loop {\n-            debug!(\"select: starting another iteration\");\n-\n-            // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n-                selcx,\n-                register_region_obligations: self.register_region_obligations\n-            });\n-            debug!(\"select: outcome={:?}\", outcome);\n-\n-            // FIXME: if we kept the original cache key, we could mark projection\n-            // obligations as complete for the projection cache here.\n-\n-            errors.extend(\n-                outcome.errors.into_iter()\n-                              .map(|e| to_fulfillment_error(e)));\n-\n-            // If nothing new was added, no need to keep looping.\n-            if outcome.stalled {\n-                break;\n-            }\n-        }\n-\n-        debug!(\"select({} predicates remaining, {} errors) done\",\n-               self.predicates.len(), errors.len());\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(errors)\n-        }\n-    }\n }\n \n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {"}, {"sha": "64b939dddc98db73d50b47e5ebf75ea3f8baeb18", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -34,7 +34,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n-pub use self::fulfill::FulfillmentContext;\n+pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal, Normalized};\n@@ -54,6 +54,7 @@ pub use self::util::transitive_bounds;\n \n mod coherence;\n pub mod error_reporting;\n+mod engine;\n mod fulfill;\n mod project;\n mod object_safety;"}, {"sha": "ba39d7961470933671ddd3135a5a2666766b3c47", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -18,7 +18,7 @@ use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n use infer::InferCtxt;\n use syntax_pos::Span;\n-use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n+use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, TraitEngine, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n use ty::fold::TypeFoldable;"}, {"sha": "3a13e2fe2944dedeee40dee202c394727f0ca794", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ObligationCause};\n+use rustc::traits::{self, ObligationCause, TraitEngine};\n use util::common::ErrorReported;\n \n use syntax::ast;\n@@ -84,7 +84,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let impl_param_env = tcx.param_env(self_type_did);\n         let tcx = infcx.tcx;\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let mut fulfillment_cx = TraitEngine::new();\n \n         let named_type = tcx.type_of(self_type_did);\n "}, {"sha": "3ecdb4e5cece75ba557bd947eae0868b0012eb15", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -95,7 +95,8 @@ use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc::traits::engine::TraitEngine;\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n@@ -195,7 +196,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n-    fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+    fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n@@ -634,7 +635,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n                 maybe_tables: infcx.in_progress_tables,\n             },\n             infcx,\n-            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            fulfillment_cx: RefCell::new(TraitEngine::new()),\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n@@ -2893,7 +2894,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // out unconstrained or ambiguous, as we're\n                         // just trying to get hints here.\n                         self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = FulfillmentContext::new();\n+                            let mut fulfill = TraitEngine::new();\n                             for obligation in ok.obligations {\n                                 fulfill.register_predicate_obligation(self, obligation);\n                             }"}, {"sha": "9700aa6bc54a03d27787057e0a8c8b84c09dceea", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -15,7 +15,7 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n-use rustc::traits::{self, ObligationCause};\n+use rustc::traits::{self, TraitEngine, ObligationCause};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::TypeFoldable;\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n@@ -372,7 +372,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let mut fulfill_cx = TraitEngine::new();\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_node_id);"}, {"sha": "7f61ecb83dbbc4f57843f2c20a1eb288faa7a734", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20703b3d091658ddc58eb5b04ef6a14d04e5b40f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=20703b3d091658ddc58eb5b04ef6a14d04e5b40f", "patch": "@@ -111,7 +111,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::traits::{FulfillmentContext, ObligationCause, ObligationCauseCode};\n+use rustc::traits::{FulfillmentContext, ObligationCause, ObligationCauseCode, TraitEngine};\n use session::{CompileIncomplete, config};\n use util::common::time;\n \n@@ -160,7 +160,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 -> bool {\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty();\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut fulfill_cx = TraitEngine::new();\n         match infcx.at(&cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfill_cx.register_predicate_obligations(infcx, obligations);"}]}