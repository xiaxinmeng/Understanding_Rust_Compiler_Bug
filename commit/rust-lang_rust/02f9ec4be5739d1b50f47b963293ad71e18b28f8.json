{"sha": "02f9ec4be5739d1b50f47b963293ad71e18b28f8", "node_id": "C_kwDOAAsO6NoAKDAyZjllYzRiZTU3MzlkMWI1MGY0N2I5NjMyOTNhZDcxZTE4YjI4Zjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-28T08:06:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-28T08:06:58Z"}, "message": "Auto merge of #12895 - Veykril:compl-anchor, r=Veykril\n\nfix: Calculate completions after type anchors\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/12892", "tree": {"sha": "5d8c486ef099bc1fb36feb67b9f292b553e1b1ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d8c486ef099bc1fb36feb67b9f292b553e1b1ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02f9ec4be5739d1b50f47b963293ad71e18b28f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02f9ec4be5739d1b50f47b963293ad71e18b28f8", "html_url": "https://github.com/rust-lang/rust/commit/02f9ec4be5739d1b50f47b963293ad71e18b28f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02f9ec4be5739d1b50f47b963293ad71e18b28f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40875353a59ea0be83c711e2223f20e6fe283a47", "url": "https://api.github.com/repos/rust-lang/rust/commits/40875353a59ea0be83c711e2223f20e6fe283a47", "html_url": "https://github.com/rust-lang/rust/commit/40875353a59ea0be83c711e2223f20e6fe283a47"}, {"sha": "e782e59d3de3d4a58cbc8005fd9521502b8d9a61", "url": "https://api.github.com/repos/rust-lang/rust/commits/e782e59d3de3d4a58cbc8005fd9521502b8d9a61", "html_url": "https://github.com/rust-lang/rust/commit/e782e59d3de3d4a58cbc8005fd9521502b8d9a61"}], "stats": {"total": 187, "additions": 151, "deletions": 36}, "files": [{"sha": "c84318b2fb8774123dbe91b69df2aae53da34547", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -324,6 +324,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_type(ty)\n     }\n \n+    pub fn resolve_trait(&self, trait_: &ast::Path) -> Option<Trait> {\n+        self.imp.resolve_trait(trait_)\n+    }\n+\n     // FIXME: Figure out a nice interface to inspect adjustments\n     pub fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n         self.imp.is_implicit_reborrow(expr)\n@@ -1014,6 +1018,20 @@ impl<'db> SemanticsImpl<'db> {\n         Some(Type::new_with_resolver(self.db, &analyze.resolver, ty))\n     }\n \n+    fn resolve_trait(&self, path: &ast::Path) -> Option<Trait> {\n+        let analyze = self.analyze(path.syntax())?;\n+        let hygiene = hir_expand::hygiene::Hygiene::new(self.db.upcast(), analyze.file_id);\n+        let ctx = body::LowerCtx::with_hygiene(self.db.upcast(), &hygiene);\n+        let hir_path = Path::from_src(path.clone(), &ctx)?;\n+        match analyze\n+            .resolver\n+            .resolve_path_in_type_ns_fully(self.db.upcast(), hir_path.mod_path())?\n+        {\n+            TypeNs::TraitId(id) => Some(Trait { id }),\n+            _ => None,\n+        }\n+    }\n+\n     fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n         self.analyze(expr.syntax())?.is_implicit_reborrow(self.db, expr)\n     }"}, {"sha": "d9fe94cb44ee1d3d5e3d4573d5d6e696f411c67b", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -115,7 +115,7 @@ pub(crate) fn complete_attribute_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n \n     let attributes = annotated_item_kind.and_then(|kind| {"}, {"sha": "793c22630bf8959039856f2ecd9ddd126565cc1a", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn complete_derive_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n }\n "}, {"sha": "d4f2766602fbf95c809e8ae8dba160f2ea664349", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -46,11 +46,32 @@ pub(crate) fn complete_expr_path(\n     };\n \n     match qualified {\n-        Qualified::Infer => ctx\n+        Qualified::TypeAnchor { ty: None, trait_: None } => ctx\n             .traits_in_scope()\n             .iter()\n             .flat_map(|&it| hir::Trait::from(it).items(ctx.sema.db))\n             .for_each(|item| add_assoc_item(acc, item)),\n+        Qualified::TypeAnchor { trait_: Some(trait_), .. } => {\n+            trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))\n+        }\n+        Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {\n+            if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                cov_mark::hit!(completes_variant_through_alias);\n+                acc.add_enum_variants(ctx, path_ctx, e);\n+            }\n+\n+            ctx.iterate_path_candidates(&ty, |item| {\n+                add_assoc_item(acc, item);\n+            });\n+\n+            // Iterate assoc types separately\n+            ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                if let hir::AssocItem::TypeAlias(ty) = item {\n+                    acc.add_type_alias(ctx, ty)\n+                }\n+                None::<()>\n+            });\n+        }\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n             // Add associated types on type parameters and `Self`."}, {"sha": "60d05ae46b9168181d7823f660867a1b3ad36462", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -66,7 +66,7 @@ pub(crate) fn complete_item_list(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::No | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::No | Qualified::With { .. } => {}\n     }\n }\n "}, {"sha": "af8a0853313b46593881cf99734b0894265fb3c4", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -180,6 +180,6 @@ pub(crate) fn complete_pattern_path(\n \n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n }"}, {"sha": "8f9db2f94c204c5e78bd962c0de7e07b3a08e3f0", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -49,11 +49,27 @@ pub(crate) fn complete_type_path(\n     };\n \n     match qualified {\n-        Qualified::Infer => ctx\n+        Qualified::TypeAnchor { ty: None, trait_: None } => ctx\n             .traits_in_scope()\n             .iter()\n             .flat_map(|&it| hir::Trait::from(it).items(ctx.sema.db))\n             .for_each(|item| add_assoc_item(acc, item)),\n+        Qualified::TypeAnchor { trait_: Some(trait_), .. } => {\n+            trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))\n+        }\n+        Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {\n+            ctx.iterate_path_candidates(&ty, |item| {\n+                add_assoc_item(acc, item);\n+            });\n+\n+            // Iterate assoc types separately\n+            ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                if let hir::AssocItem::TypeAlias(ty) = item {\n+                    acc.add_type_alias(ctx, ty)\n+                }\n+                None::<()>\n+            });\n+        }\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n             // Add associated types on type parameters and `Self`."}, {"sha": "2555c34aa7477090bc7f588ae66a908990f9db34", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -115,6 +115,6 @@ pub(crate) fn complete_use_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { resolution: None, .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { resolution: None, .. } => {}\n     }\n }"}, {"sha": "5e6cf4bf9a52142d572924a5f280d5625f88f2a1", "filename": "crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn complete_vis_path(\n \n             acc.add_super_keyword(ctx, *super_chain_len);\n         }\n-        Qualified::Absolute | Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::Absolute | Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n         Qualified::No => {\n             if !has_in_token {\n                 cov_mark::hit!(kw_completion_in);"}, {"sha": "e35f79d2b6951e05a57c943af8eba44bb60e7f57", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -193,7 +193,10 @@ pub(super) enum Qualified {\n         super_chain_len: Option<usize>,\n     },\n     /// <_>::\n-    Infer,\n+    TypeAnchor {\n+        ty: Option<hir::Type>,\n+        trait_: Option<hir::Trait>,\n+    },\n     /// Whether the path is an absolute path\n     Absolute,\n }"}, {"sha": "3e7e637dd9ed520698f80416bf6662895e19a4a1", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -920,49 +920,53 @@ impl<'a> CompletionContext<'a> {\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n         // calculate the qualifier context\n-        if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n+        if let Some((qualifier, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n             path_ctx.use_tree_parent = use_tree_parent;\n             if !use_tree_parent && segment.coloncolon_token().is_some() {\n                 path_ctx.qualified = Qualified::Absolute;\n             } else {\n-                let path = path\n+                let qualifier = qualifier\n                     .segment()\n                     .and_then(|it| find_node_in_file(original_file, &it))\n                     .map(|it| it.parent_path());\n-                if let Some(path) = path {\n-                    // `<_>::$0`\n-                    let is_infer_qualifier = path.qualifier().is_none()\n-                        && matches!(\n-                            path.segment().and_then(|it| it.kind()),\n-                            Some(ast::PathSegmentKind::Type {\n-                                type_ref: Some(ast::Type::InferType(_)),\n-                                trait_ref: None,\n-                            })\n-                        );\n+                if let Some(qualifier) = qualifier {\n+                    let type_anchor = match qualifier.segment().and_then(|it| it.kind()) {\n+                        Some(ast::PathSegmentKind::Type {\n+                            type_ref: Some(type_ref),\n+                            trait_ref,\n+                        }) if qualifier.qualifier().is_none() => Some((type_ref, trait_ref)),\n+                        _ => None,\n+                    };\n \n-                    path_ctx.qualified = if is_infer_qualifier {\n-                        Qualified::Infer\n+                    path_ctx.qualified = if let Some((ty, trait_ref)) = type_anchor {\n+                        let ty = match ty {\n+                            ast::Type::InferType(_) => None,\n+                            ty => sema.resolve_type(&ty),\n+                        };\n+                        let trait_ = trait_ref.and_then(|it| sema.resolve_trait(&it.path()?));\n+                        Qualified::TypeAnchor { ty, trait_ }\n                     } else {\n-                        let res = sema.resolve_path(&path);\n+                        let res = sema.resolve_path(&qualifier);\n \n                         // For understanding how and why super_chain_len is calculated the way it\n                         // is check the documentation at it's definition\n                         let mut segment_count = 0;\n-                        let super_count = iter::successors(Some(path.clone()), |p| p.qualifier())\n-                            .take_while(|p| {\n-                                p.segment()\n-                                    .and_then(|s| {\n-                                        segment_count += 1;\n-                                        s.super_token()\n-                                    })\n-                                    .is_some()\n-                            })\n-                            .count();\n+                        let super_count =\n+                            iter::successors(Some(qualifier.clone()), |p| p.qualifier())\n+                                .take_while(|p| {\n+                                    p.segment()\n+                                        .and_then(|s| {\n+                                            segment_count += 1;\n+                                            s.super_token()\n+                                        })\n+                                        .is_some()\n+                                })\n+                                .count();\n \n                         let super_chain_len =\n                             if segment_count > super_count { None } else { Some(super_count) };\n \n-                        Qualified::With { path, resolution: res, super_chain_len }\n+                        Qualified::With { path: qualifier, resolution: res, super_chain_len }\n                     }\n                 };\n             }"}, {"sha": "033dc99c26cf0c09acfdb2efb52a073b95b2a2f2", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9ec4be5739d1b50f47b963293ad71e18b28f8/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=02f9ec4be5739d1b50f47b963293ad71e18b28f8", "patch": "@@ -674,7 +674,60 @@ fn bar() -> Bar {\n         expect![[r#\"\n                 fn foo() (as Foo) fn() -> Self\n             \"#]],\n-    )\n+    );\n+}\n+\n+#[test]\n+fn type_anchor_type() {\n+    check(\n+        r#\"\n+trait Foo {\n+    fn foo() -> Self;\n+}\n+struct Bar;\n+impl Bar {\n+    fn bar() {}\n+}\n+impl Foo for Bar {\n+    fn foo() -> {\n+        Bar\n+    }\n+}\n+fn bar() -> Bar {\n+    <Bar>::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            fn bar()          fn()\n+            fn foo() (as Foo) fn() -> Self\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn type_anchor_type_trait() {\n+    check(\n+        r#\"\n+trait Foo {\n+    fn foo() -> Self;\n+}\n+struct Bar;\n+impl Bar {\n+    fn bar() {}\n+}\n+impl Foo for Bar {\n+    fn foo() -> {\n+        Bar\n+    }\n+}\n+fn bar() -> Bar {\n+    <Bar as Foo>::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            fn foo() (as Foo) fn() -> Self\n+        \"#]],\n+    );\n }\n \n #[test]"}]}