{"sha": "45a908cad04b10fea8446fbd2589a499f7fa7617", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1YTkwOGNhZDA0YjEwZmVhODQ0NmZiZDI1ODlhNDk5ZjdmYTc2MTc=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-11-04T20:51:34Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-11-04T20:51:34Z"}, "message": "Merge pull request #3916 from Dretch/iofix\n\nMore methods/docs/tests for core::io", "tree": {"sha": "1f46d0b553e707c0f07791bc341c4239f0b9166b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f46d0b553e707c0f07791bc341c4239f0b9166b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45a908cad04b10fea8446fbd2589a499f7fa7617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45a908cad04b10fea8446fbd2589a499f7fa7617", "html_url": "https://github.com/rust-lang/rust/commit/45a908cad04b10fea8446fbd2589a499f7fa7617", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45a908cad04b10fea8446fbd2589a499f7fa7617/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff07e687588d6a449d959c73326aa0147083af62", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff07e687588d6a449d959c73326aa0147083af62", "html_url": "https://github.com/rust-lang/rust/commit/ff07e687588d6a449d959c73326aa0147083af62"}, {"sha": "fd6f62f9c71722282eb71ae040290e1addab8282", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6f62f9c71722282eb71ae040290e1addab8282", "html_url": "https://github.com/rust-lang/rust/commit/fd6f62f9c71722282eb71ae040290e1addab8282"}], "stats": {"total": 380, "additions": 343, "deletions": 37}, "files": [{"sha": "4629878b4b7eae76ab81f65b9d1c756a1396ecc8", "filename": "src/libcore/io.rs", "status": "modified", "additions": 343, "deletions": 37, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/45a908cad04b10fea8446fbd2589a499f7fa7617/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45a908cad04b10fea8446fbd2589a499f7fa7617/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=45a908cad04b10fea8446fbd2589a499f7fa7617", "patch": "@@ -32,38 +32,131 @@ extern mod rustrt {\n pub enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n \n \n-// The raw underlying reader trait. All readers must implement this.\n+/// The raw underlying reader trait. All readers must implement this.\n pub trait Reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n \n+    /// Read up to len bytes (or EOF) and put them into bytes (which\n+    /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n     fn read(bytes: &[mut u8], len: uint) -> uint;\n+\n+    /// Read a single byte, returning a negative value for EOF or read error.\n     fn read_byte() -> int;\n+\n+    /// Behaves like the libc function ungetc.\n     fn unread_byte(int);\n+\n+    /// Return whether the stream is currently at EOF position.\n     fn eof() -> bool;\n-    fn seek(int, SeekStyle);\n+\n+    /// Move the current position within the stream. The second parameter\n+    /// determines the position that the first parameter is relative to.\n+    fn seek(position: int, style: SeekStyle);\n+\n+    /// Return the current position within the stream.\n     fn tell() -> uint;\n }\n \n-// Generic utility functions defined on readers\n-\n+/// Generic utility functions defined on readers.\n pub trait ReaderUtil {\n+\n+    /// Read len bytes into a new vec.\n     fn read_bytes(len: uint) -> ~[u8];\n+\n+    /// Read up until the first '\\n' char (which is not returned), or EOF.\n     fn read_line() -> ~str;\n \n+    /// Read n utf-8 encoded chars.\n     fn read_chars(n: uint) -> ~[char];\n+\n+    /// Read a single utf-8 encoded char.\n     fn read_char() -> char;\n+\n+    /// Read up until the first null byte (which is not returned), or EOF.\n     fn read_c_str() -> ~str;\n-    fn read_le_uint(size: uint) -> uint;\n-    fn read_le_int(size: uint) -> int;\n-    fn read_be_uint(size: uint) -> uint;\n+\n+    /// Read all the data remaining in the stream in one go.\n     fn read_whole_stream() -> ~[u8];\n+\n+    /// Iterate over every byte until the iterator breaks or EOF.\n     fn each_byte(it: fn(int) -> bool);\n+\n+    /// Iterate over every char until the iterator breaks or EOF.\n     fn each_char(it: fn(char) -> bool);\n-    fn each_line(it: fn((&str)) -> bool);\n+\n+    /// Iterate over every line until the iterator breaks or EOF.\n+    fn each_line(it: fn(&str) -> bool);\n+\n+    /// Read n (between 1 and 8) little-endian unsigned integer bytes.\n+    fn read_le_uint_n(nbytes: uint) -> u64;\n+\n+    /// Read n (between 1 and 8) little-endian signed integer bytes.\n+    fn read_le_int_n(nbytes: uint) -> i64;\n+\n+    /// Read n (between 1 and 8) big-endian unsigned integer bytes.\n+    fn read_be_uint_n(nbytes: uint) -> u64;\n+\n+    /// Read n (between 1 and 8) big-endian signed integer bytes.\n+    fn read_be_int_n(nbytes: uint) -> i64;\n+\n+    /// Read a little-endian uint (number of bytes depends on system).\n+    fn read_le_uint() -> uint;\n+\n+    /// Read a little-endian int (number of bytes depends on system).\n+    fn read_le_int() -> int;\n+\n+    /// Read a big-endian uint (number of bytes depends on system).\n+    fn read_be_uint() -> uint;\n+\n+    /// Read a big-endian int (number of bytes depends on system).\n+    fn read_be_int() -> int;\n+\n+    /// Read a big-endian u64 (8 bytes).\n+    fn read_be_u64() -> u64;\n+\n+    /// Read a big-endian u32 (4 bytes).\n+    fn read_be_u32() -> u32;\n+\n+    /// Read a big-endian u16 (2 bytes).\n+    fn read_be_u16() -> u16;\n+\n+    /// Read a big-endian i64 (8 bytes).\n+    fn read_be_i64() -> i64;\n+\n+    /// Read a big-endian i32 (4 bytes).\n+    fn read_be_i32() -> i32;\n+\n+    /// Read a big-endian i16 (2 bytes).\n+    fn read_be_i16() -> i16;\n+\n+    /// Read a little-endian u64 (8 bytes).\n+    fn read_le_u64() -> u64;\n+\n+    /// Read a little-endian u32 (4 bytes).\n+    fn read_le_u32() -> u32;\n+\n+    /// Read a little-endian u16 (2 bytes).\n+    fn read_le_u16() -> u16;\n+\n+    /// Read a litle-endian i64 (8 bytes).\n+    fn read_le_i64() -> i64;\n+\n+    /// Read a litle-endian i32 (4 bytes).\n+    fn read_le_i32() -> i32;\n+\n+    /// Read a litle-endian i16 (2 bytes).\n+    fn read_le_i16() -> i16;\n+\n+    /// Read a u8 (1 byte).\n+    fn read_u8() -> u8;\n+\n+    /// Read a i8 (1 byte).\n+    fn read_i8() -> i8;\n }\n \n impl<T: Reader> T : ReaderUtil {\n+\n     fn read_bytes(len: uint) -> ~[u8] {\n         let mut bytes = vec::with_capacity(len);\n         unsafe { vec::raw::set_len(&mut bytes, len); }\n@@ -73,6 +166,7 @@ impl<T: Reader> T : ReaderUtil {\n         unsafe { vec::raw::set_len(&mut bytes, count); }\n         move bytes\n     }\n+\n     fn read_line() -> ~str {\n         let mut bytes = ~[];\n         loop {\n@@ -162,34 +256,6 @@ impl<T: Reader> T : ReaderUtil {\n         str::from_bytes(bytes)\n     }\n \n-    // FIXME deal with eof? // #2004\n-    fn read_le_uint(size: uint) -> uint {\n-        let mut val = 0u, pos = 0u, i = size;\n-        while i > 0u {\n-            val += (self.read_byte() as uint) << pos;\n-            pos += 8u;\n-            i -= 1u;\n-        }\n-        val\n-    }\n-    fn read_le_int(size: uint) -> int {\n-        let mut val = 0u, pos = 0u, i = size;\n-        while i > 0u {\n-            val += (self.read_byte() as uint) << pos;\n-            pos += 8u;\n-            i -= 1u;\n-        }\n-        val as int\n-    }\n-    fn read_be_uint(size: uint) -> uint {\n-        let mut val = 0u, i = size;\n-        while i > 0u {\n-            i -= 1u;\n-            val += (self.read_byte() as uint) << i * 8u;\n-        }\n-        val\n-    }\n-\n     fn read_whole_stream() -> ~[u8] {\n         let mut bytes: ~[u8] = ~[];\n         while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n@@ -213,6 +279,116 @@ impl<T: Reader> T : ReaderUtil {\n             if !it(self.read_line()) { break; }\n         }\n     }\n+\n+    // FIXME int reading methods need to deal with eof - issue #2004\n+\n+    fn read_le_uint_n(nbytes: uint) -> u64 {\n+        assert nbytes > 0 && nbytes <= 8;\n+\n+        let mut val = 0u64, pos = 0, i = nbytes;\n+        while i > 0 {\n+            val += (self.read_u8() as u64) << pos;\n+            pos += 8;\n+            i -= 1;\n+        }\n+        val\n+    }\n+\n+    fn read_le_int_n(nbytes: uint) -> i64 {\n+        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_be_uint_n(nbytes: uint) -> u64 {\n+        assert nbytes > 0 && nbytes <= 8;\n+\n+        let mut val = 0u64, i = nbytes;\n+        while i > 0 {\n+            i -= 1;\n+            val += (self.read_u8() as u64) << i * 8;\n+        }\n+        val\n+    }\n+\n+    fn read_be_int_n(nbytes: uint) -> i64 {\n+        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_le_uint() -> uint {\n+        self.read_le_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_le_int() -> int {\n+        self.read_le_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_uint() -> uint {\n+        self.read_be_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_be_int() -> int {\n+        self.read_be_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_u64() -> u64 {\n+        self.read_be_uint_n(8) as u64\n+    }\n+\n+    fn read_be_u32() -> u32 {\n+        self.read_be_uint_n(4) as u32\n+    }\n+\n+    fn read_be_u16() -> u16 {\n+        self.read_be_uint_n(2) as u16\n+    }\n+\n+    fn read_be_i64() -> i64 {\n+        self.read_be_int_n(8) as i64\n+    }\n+\n+    fn read_be_i32() -> i32 {\n+        self.read_be_int_n(4) as i32\n+    }\n+\n+    fn read_be_i16() -> i16 {\n+        self.read_be_int_n(2) as i16\n+    }\n+\n+    fn read_le_u64() -> u64 {\n+        self.read_le_uint_n(8) as u64\n+    }\n+\n+    fn read_le_u32() -> u32 {\n+        self.read_le_uint_n(4) as u32\n+    }\n+\n+    fn read_le_u16() -> u16 {\n+        self.read_le_uint_n(2) as u16\n+    }\n+\n+    fn read_le_i64() -> i64 {\n+        self.read_le_int_n(8) as i64\n+    }\n+\n+    fn read_le_i32() -> i32 {\n+        self.read_le_int_n(4) as i32\n+    }\n+\n+    fn read_le_i16() -> i16 {\n+        self.read_le_int_n(2) as i16\n+    }\n+\n+    fn read_u8() -> u8 {\n+        self.read_byte() as u8\n+    }\n+\n+    fn read_i8() -> i8 {\n+        self.read_byte() as i8\n+    }\n+}\n+\n+fn extend_sign(val: u64, nbytes: uint) -> i64 {\n+    let shift = (8 - nbytes) * 8;\n+    (val << shift) as i64 >> shift\n }\n \n // Reader implementations\n@@ -358,11 +534,23 @@ pub impl WriterType : Eq {\n \n // FIXME (#2004): Seekable really should be orthogonal.\n // FIXME (#2004): eventually u64\n+/// The raw underlying writer trait. All writers must implement this.\n pub trait Writer {\n+\n+    /// Write all of the given bytes.\n     fn write(v: &[const u8]);\n+\n+    /// Move the current position within the stream. The second parameter\n+    /// determines the position that the first parameter is relative to.\n     fn seek(int, SeekStyle);\n+\n+    /// Return the current position within the stream.\n     fn tell() -> uint;\n+\n+    /// Flush the output buffer for this stream (if there is one).\n     fn flush() -> int;\n+\n+    /// Determine if this Writer is writing to a file or not.\n     fn get_type() -> WriterType;\n }\n \n@@ -566,29 +754,77 @@ pub fn u64_from_be_bytes(data: &[const u8],\n \n // FIXME: #3048 combine trait+impl (or just move these to\n // default methods on writer)\n+/// Generic utility functions defined on writers.\n pub trait WriterUtil {\n+\n+    /// Write a single utf-8 encoded char.\n     fn write_char(ch: char);\n+\n+    /// Write every char in the given str, encoded as utf-8.\n     fn write_str(s: &str);\n+\n+    /// Write the given str, as utf-8, followed by '\\n'.\n     fn write_line(s: &str);\n+\n+    /// Write the result of passing n through `int::to_str_bytes`.\n     fn write_int(n: int);\n+\n+    /// Write the result of passing n through `uint::to_str_bytes`.\n     fn write_uint(n: uint);\n+\n+    /// Write a little-endian uint (number of bytes depends on system).\n     fn write_le_uint(n: uint);\n+\n+    /// Write a little-endian int (number of bytes depends on system).\n     fn write_le_int(n: int);\n+\n+    /// Write a big-endian uint (number of bytes depends on system).\n     fn write_be_uint(n: uint);\n+\n+    /// Write a big-endian int (number of bytes depends on system).\n     fn write_be_int(n: int);\n+\n+    /// Write a big-endian u64 (8 bytes).\n     fn write_be_u64(n: u64);\n+\n+    /// Write a big-endian u32 (4 bytes).\n     fn write_be_u32(n: u32);\n+\n+    /// Write a big-endian u16 (2 bytes).\n     fn write_be_u16(n: u16);\n+\n+    /// Write a big-endian i64 (8 bytes).\n     fn write_be_i64(n: i64);\n+\n+    /// Write a big-endian i32 (4 bytes).\n     fn write_be_i32(n: i32);\n+\n+    /// Write a big-endian i16 (2 bytes).\n     fn write_be_i16(n: i16);\n+\n+    /// Write a little-endian u64 (8 bytes).\n     fn write_le_u64(n: u64);\n+\n+    /// Write a little-endian u32 (4 bytes).\n     fn write_le_u32(n: u32);\n+\n+    /// Write a little-endian u16 (2 bytes).\n     fn write_le_u16(n: u16);\n+\n+    /// Write a little-endian i64 (8 bytes).\n     fn write_le_i64(n: i64);\n+\n+    /// Write a little-endian i32 (4 bytes).\n     fn write_le_i32(n: i32);\n+\n+    /// Write a little-endian i16 (2 bytes).\n     fn write_le_i16(n: i16);\n+\n+    /// Write a u8 (1 byte).\n     fn write_u8(n: u8);\n+\n+    /// Write a i8 (1 byte).\n+    fn write_i8(n: i8);\n }\n \n impl<T: Writer> T : WriterUtil {\n@@ -659,7 +895,8 @@ impl<T: Writer> T : WriterUtil {\n         u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n-    fn write_u8(n: u8) { self.write(&[n]) }\n+    fn write_u8(n: u8) { self.write([n]) }\n+    fn write_i8(n: i8) { self.write([n as u8]) }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n@@ -1001,6 +1238,75 @@ mod tests {\n         assert wr.bytes.borrow(|bytes| bytes ==\n             ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n+\n+    #[test]\n+    fn test_read_write_le() {\n+        let path = Path(\"tmp/lib-io-test-read-write-le.tmp\");\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        // write the ints to the file\n+        {\n+            let file = io::file_writer(&path, [io::Create]).get();\n+            for uints.each |i| {\n+                file.write_le_u64(*i);\n+            }\n+        }\n+\n+        // then read them back and check that they are the same\n+        {\n+            let file = io::file_reader(&path).get();\n+            for uints.each |i| {\n+                assert file.read_le_u64() == *i;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_write_be() {\n+        let path = Path(\"tmp/lib-io-test-read-write-be.tmp\");\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        // write the ints to the file\n+        {\n+            let file = io::file_writer(&path, [io::Create]).get();\n+            for uints.each |i| {\n+                file.write_be_u64(*i);\n+            }\n+        }\n+\n+        // then read them back and check that they are the same\n+        {\n+            let file = io::file_reader(&path).get();\n+            for uints.each |i| {\n+                assert file.read_be_u64() == *i;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_be_int_n() {\n+        let path = Path(\"tmp/lib-io-test-read-be-int-n.tmp\");\n+        let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n+\n+        // write the ints to the file\n+        {\n+            let file = io::file_writer(&path, [io::Create]).get();\n+            for ints.each |i| {\n+                file.write_be_i32(*i);\n+            }\n+        }\n+\n+        // then read them back and check that they are the same\n+        {\n+            let file = io::file_reader(&path).get();\n+            for ints.each |i| {\n+                // this tests that the sign extension is working\n+                // (comparing the values as i32 would not test this)\n+                assert file.read_be_int_n(4) == *i as i64;\n+            }\n+        }\n+    }\n+\n }\n \n //"}]}