{"sha": "7af0c678559ef75e9ec6359ec3e05d76dfc355f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZjBjNjc4NTU5ZWY3NWU5ZWM2MzU5ZWMzZTA1ZDc2ZGZjMzU1ZjU=", "commit": {"author": {"name": "Shea Newton", "email": "shnewto@gmail.com", "date": "2018-05-23T04:56:02Z"}, "committer": {"name": "Shea Newton", "email": "shnewto@gmail.com", "date": "2018-06-19T16:27:08Z"}, "message": "    Extend `indexing_slicing` lint\n\n    Hey there clippy team! I've made some assumptions in this PR and I'm not at all certain they'll look like the right approach to you. I'm looking forward to any feedback or revision requests you have, thanks!\n\n    Prior to this commit the `indexing_slicing` lint was limited to indexing/slicing operations on arrays. This meant that the scope of a really useful lint didn't include vectors. In order to include vectors in the `indexing_slicing` lint a few steps were taken.\n\n    The `array_indexing.rs` source file in `clippy_lints` was renamed to `indexing_slicing.rs` to more accurately reflect the lint's new scope. The `OUT_OF_BOUNDS_INDEXING` lint persists through these changes so if we can know that a constant index or slice on an array is in bounds no lint is triggered.\n\n    The `array_indexing` tests in the `tests/ui` directory were also extended and moved to `indexing_slicing.rs` and `indexing_slicing.stderr`.\n\n    The `indexing_slicing` lint was moved to the `clippy_pedantic` lint group.\n\n    A specific \"Consider using\" string was added to each of the `indexing_slicing` lint reports.\n\n    At least one of the test scenarios might look peculiar and I'll leave it up to y'all to decide if it's palatable. It's the result of indexing the array `x` after `let x = [1, 2, 3, 4];`\n\n    ```\n    error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)`instead\n      --> $DIR/indexing_slicing.rs:23:6\n       |\n    23 |     &x[0..][..3];\n       |      ^^^^^^^^^^^\n    ```\n\n    The error string reports only on the second half's range-to, because the range-from is in bounds!\n\n    Again, thanks for taking a look.\n\n    Closes #2536", "tree": {"sha": "f935f3c4968633636ff74f64258bf3a07115a2ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f935f3c4968633636ff74f64258bf3a07115a2ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7af0c678559ef75e9ec6359ec3e05d76dfc355f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJbKS7cAAoJEBfrkSLclYZDwmMP/2TfrBBxDdVywEi6htWsj/Nw\nGsVqLCiQG0T3mPmt+4uXrA9LYB4Ja1/5Mx3euJaeKK+adIK65UIVns6laQSdFMI5\nVzNBTVW2EA0ZZ5j7i/6rGCqojNuP/kT53HQktzg/QAuyw5oBjePmRYHTxi3N0l4I\naqZD++zo7siBlNdKO7wszopdJILzAveip+kIHyI+jUh6H7hkbuVlP3mSD5wXLB3K\nl7R0XkiONCJBG/nYni0824oPSml5TkTLPGLiUJ81zydAGmGQx+/3LllSviAW6aDE\nw0hAHwzXk8fUumR6NugeDBzeyv4I1SEB024HPS50h8QX9qC/S1H9yQy0oamRtVhi\nJrtQU/zoo03Mx7QaxReuW1aMvUxJpEU9zOYffhOGhc1sYYUEvYH9SxQMQzC3M+oi\nPqI6Z3sumHVPChBnGD8PQGS2ckY6SZ+aMpViWCntVYqUc63bVQ6uTB0cn644ldox\nHFVr2bE5ww8r58Ieb95XgGvmp3LoIaSPwf8S+XMy21TKvIwixxgRGfB6H//7zvZB\nny+hXD0t5GGpqhYbejq1mI6NA1AtGDntT5YJAnXrolyo5NFoTwnbI68d7c1tUDzD\nXvY1JEnibdiX2NTnLDY2uBrm+X8jaxGeZS36My4poqU/w5wN5upiSuUzqjkWnzzG\n1X89rx3ZLT1xsx0Ddygc\n=30x4\n-----END PGP SIGNATURE-----", "payload": "tree f935f3c4968633636ff74f64258bf3a07115a2ea\nparent c573186245a66205959f0075f72f4a4f4821c33e\nauthor Shea Newton <shnewto@gmail.com> 1527051362 -0700\ncommitter Shea Newton <shnewto@gmail.com> 1529425628 +0000\n\n    Extend `indexing_slicing` lint\n\n    Hey there clippy team! I've made some assumptions in this PR and I'm not at all certain they'll look like the right approach to you. I'm looking forward to any feedback or revision requests you have, thanks!\n\n    Prior to this commit the `indexing_slicing` lint was limited to indexing/slicing operations on arrays. This meant that the scope of a really useful lint didn't include vectors. In order to include vectors in the `indexing_slicing` lint a few steps were taken.\n\n    The `array_indexing.rs` source file in `clippy_lints` was renamed to `indexing_slicing.rs` to more accurately reflect the lint's new scope. The `OUT_OF_BOUNDS_INDEXING` lint persists through these changes so if we can know that a constant index or slice on an array is in bounds no lint is triggered.\n\n    The `array_indexing` tests in the `tests/ui` directory were also extended and moved to `indexing_slicing.rs` and `indexing_slicing.stderr`.\n\n    The `indexing_slicing` lint was moved to the `clippy_pedantic` lint group.\n\n    A specific \"Consider using\" string was added to each of the `indexing_slicing` lint reports.\n\n    At least one of the test scenarios might look peculiar and I'll leave it up to y'all to decide if it's palatable. It's the result of indexing the array `x` after `let x = [1, 2, 3, 4];`\n\n    ```\n    error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)`instead\n      --> $DIR/indexing_slicing.rs:23:6\n       |\n    23 |     &x[0..][..3];\n       |      ^^^^^^^^^^^\n    ```\n\n    The error string reports only on the second half's range-to, because the range-from is in bounds!\n\n    Again, thanks for taking a look.\n\n    Closes #2536\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7af0c678559ef75e9ec6359ec3e05d76dfc355f5", "html_url": "https://github.com/rust-lang/rust/commit/7af0c678559ef75e9ec6359ec3e05d76dfc355f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/comments", "author": {"login": "shnewto", "id": 5607902, "node_id": "MDQ6VXNlcjU2MDc5MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/5607902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shnewto", "html_url": "https://github.com/shnewto", "followers_url": "https://api.github.com/users/shnewto/followers", "following_url": "https://api.github.com/users/shnewto/following{/other_user}", "gists_url": "https://api.github.com/users/shnewto/gists{/gist_id}", "starred_url": "https://api.github.com/users/shnewto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shnewto/subscriptions", "organizations_url": "https://api.github.com/users/shnewto/orgs", "repos_url": "https://api.github.com/users/shnewto/repos", "events_url": "https://api.github.com/users/shnewto/events{/privacy}", "received_events_url": "https://api.github.com/users/shnewto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shnewto", "id": 5607902, "node_id": "MDQ6VXNlcjU2MDc5MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/5607902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shnewto", "html_url": "https://github.com/shnewto", "followers_url": "https://api.github.com/users/shnewto/followers", "following_url": "https://api.github.com/users/shnewto/following{/other_user}", "gists_url": "https://api.github.com/users/shnewto/gists{/gist_id}", "starred_url": "https://api.github.com/users/shnewto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shnewto/subscriptions", "organizations_url": "https://api.github.com/users/shnewto/orgs", "repos_url": "https://api.github.com/users/shnewto/repos", "events_url": "https://api.github.com/users/shnewto/events{/privacy}", "received_events_url": "https://api.github.com/users/shnewto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c573186245a66205959f0075f72f4a4f4821c33e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c573186245a66205959f0075f72f4a4f4821c33e", "html_url": "https://github.com/rust-lang/rust/commit/c573186245a66205959f0075f72f4a4f4821c33e"}], "stats": {"total": 409, "additions": 302, "deletions": 107}, "files": [{"sha": "e7bb590e60df3ad4d5ef4d0cb861ef9aadd4bef1", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 123, "deletions": 45, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=7af0c678559ef75e9ec6359ec3e05d76dfc355f5", "patch": "@@ -1,3 +1,5 @@\n+//! lint on indexing and slicing operations\n+\n use crate::consts::{constant, Constant};\n use crate::utils::higher::Range;\n use crate::utils::{self, higher};\n@@ -16,29 +18,44 @@ use syntax::ast::RangeLimits;\n /// **Example:**\n /// ```rust\n /// let x = [1,2,3,4];\n-/// ...\n+///\n+/// // Bad\n /// x[9];\n /// &x[2..9];\n+///\n+/// // Good\n+/// x[0];\n+/// x[3];\n /// ```\n declare_clippy_lint! {\n     pub OUT_OF_BOUNDS_INDEXING,\n     correctness,\n     \"out of bounds constant indexing\"\n }\n \n-/// **What it does:** Checks for usage of indexing or slicing.\n+/// **What it does:** Checks for usage of indexing or slicing. Does not report\n+/// if we can tell that the indexing or slicing operations on an array are in\n+/// bounds.\n ///\n-/// **Why is this bad?** Usually, this can be safely allowed. However, in some\n-/// domains such as kernel development, a panic can cause the whole operating\n-/// system to crash.\n+/// **Why is this bad?** Indexing and slicing can panic at runtime and there are\n+/// safe alternatives.\n ///\n /// **Known problems:** Hopefully none.\n ///\n /// **Example:**\n /// ```rust\n-/// ...\n+/// let x = vec![0; 5];\n+/// // Bad\n /// x[2];\n-/// &x[0..2];\n+/// &x[2..100];\n+/// &x[2..];\n+/// &x[..100];\n+///\n+/// // Good\n+/// x.get(2)\n+/// x.get(2..100)\n+/// x.get(2..)\n+/// x.get(..100)\n /// ```\n declare_clippy_lint! {\n     pub INDEXING_SLICING,\n@@ -47,68 +64,129 @@ declare_clippy_lint! {\n }\n \n #[derive(Copy, Clone)]\n-pub struct ArrayIndexing;\n+pub struct IndexingSlicingPass;\n \n-impl LintPass for ArrayIndexing {\n+impl LintPass for IndexingSlicingPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING)\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n-        if let hir::ExprIndex(ref array, ref index) = e.node {\n-            // Array with known size can be checked statically\n-            let ty = cx.tables.expr_ty(array);\n-            if let ty::TyArray(_, size) = ty.sty {\n-                let size = size.assert_usize(cx.tcx).unwrap().into();\n-\n-                // Index is a constant uint\n-                if let Some((Constant::Int(const_index), _)) = constant(cx, cx.tables, index) {\n-                    if size <= const_index {\n-                        utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicingPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if let ExprIndex(ref a, ref b) = &expr.node {\n+            match &b.node {\n+                // Both ExprStruct and ExprPath require this approach's checks\n+                // on the `range` returned by `higher::range(cx, b)`.\n+                // ExprStruct handles &x[n..m], &x[n..] and &x[..n].\n+                // ExprPath handles &x[..] and x[var]\n+                ExprStruct(_, _, _) | ExprPath(_) => {\n+                    if let Some(range) = higher::range(cx, b) {\n+                        let ty = cx.tables.expr_ty(a);\n+                        if let ty::TyArray(_, s) = ty.sty {\n+                            let size: u128 = s.assert_usize(cx.tcx).unwrap().into();\n+                            // Index is a constant range.\n+                            if let Some((start, end)) = to_const_range(cx, range, size) {\n+                                if start > size || end > size {\n+                                    utils::span_lint(\n+                                        cx,\n+                                        OUT_OF_BOUNDS_INDEXING,\n+                                        expr.span,\n+                                        \"range is out of bounds\",\n+                                    );\n+                                } else {\n+                                    // Range is in bounds, ok.\n+                                    return;\n+                                }\n+                            }\n+                        }\n+                        match (range.start, range.end) {\n+                            (None, Some(_)) => {\n+                                cx.span_lint(\n+                                    INDEXING_SLICING,\n+                                    expr.span,\n+                                    \"slicing may panic. Consider using \\\n+                                     `.get(..n)`or `.get_mut(..n)` instead\",\n+                                );\n+                            }\n+                            (Some(_), None) => {\n+                                cx.span_lint(\n+                                    INDEXING_SLICING,\n+                                    expr.span,\n+                                    \"slicing may panic. Consider using \\\n+                                     `.get(n..)` or .get_mut(n..)` instead\",\n+                                );\n+                            }\n+                            (Some(_), Some(_)) => {\n+                                cx.span_lint(\n+                                    INDEXING_SLICING,\n+                                    expr.span,\n+                                    \"slicing may panic. Consider using \\\n+                                     `.get(n..m)` or `.get_mut(n..m)` instead\",\n+                                );\n+                            }\n+                            (None, None) => (),\n+                        }\n+                    } else {\n+                        cx.span_lint(\n+                            INDEXING_SLICING,\n+                            expr.span,\n+                            \"indexing may panic. Consider using `.get(n)` or \\\n+                             `.get_mut(n)` instead\",\n+                        );\n                     }\n-\n-                    return;\n                 }\n-\n-                // Index is a constant range\n-                if let Some(range) = higher::range(cx, index) {\n-                    if let Some((start, end)) = to_const_range(cx, range, size) {\n-                        if start > size || end > size {\n-                            utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"range is out of bounds\");\n+                ExprLit(_) => {\n+                    // [n]\n+                    let ty = cx.tables.expr_ty(a);\n+                    if let ty::TyArray(_, s) = ty.sty {\n+                        let size: u128 = s.assert_usize(cx.tcx).unwrap().into();\n+                        // Index is a constant uint.\n+                        if let Some((Constant::Int(const_index), _)) = constant(cx, cx.tables, b) {\n+                            if size <= const_index {\n+                                utils::span_lint(\n+                                    cx,\n+                                    OUT_OF_BOUNDS_INDEXING,\n+                                    expr.span,\n+                                    \"const index is out of bounds\",\n+                                );\n+                            }\n+                            // Else index is in bounds, ok.\n                         }\n-                        return;\n+                    } else {\n+                        cx.span_lint(\n+                            INDEXING_SLICING,\n+                            expr.span,\n+                            \"indexing may panic. Consider using `.get(n)` or \\\n+                             `.get_mut(n)` instead\",\n+                        );\n                     }\n                 }\n-            }\n-\n-            if let Some(range) = higher::range(cx, index) {\n-                // Full ranges are always valid\n-                if range.start.is_none() && range.end.is_none() {\n-                    return;\n-                }\n-\n-                // Impossible to know if indexing or slicing is correct\n-                utils::span_lint(cx, INDEXING_SLICING, e.span, \"slicing may panic\");\n-            } else {\n-                utils::span_lint(cx, INDEXING_SLICING, e.span, \"indexing may panic\");\n+                _ => (),\n             }\n         }\n     }\n }\n \n /// Returns an option containing a tuple with the start and end (exclusive) of\n /// the range.\n-fn to_const_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, range: Range, array_size: u128) -> Option<(u128, u128)> {\n-    let s = range.start.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+fn to_const_range<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    range: Range,\n+    array_size: u128,\n+) -> Option<(u128, u128)> {\n+    let s = range\n+        .start\n+        .map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n     let start = match s {\n         Some(Some(Constant::Int(x))) => x,\n         Some(_) => return None,\n         None => 0,\n     };\n \n-    let e = range.end.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let e = range\n+        .end\n+        .map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n     let end = match e {\n         Some(Some(Constant::Int(x))) => if range.limits == RangeLimits::Closed {\n             x + 1"}, {"sha": "bd89b37dc3ae4a5a841f190646b058183a1540ba", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7af0c678559ef75e9ec6359ec3e05d76dfc355f5", "patch": "@@ -355,8 +355,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     );\n     reg.register_late_lint_pass(box escape::Pass{too_large_for_stack: conf.too_large_for_stack});\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n-    reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n-    reg.register_late_lint_pass(box panic_unimplemented::Pass);\n+    reg.register_late_lint_pass(box array_indexing::IndexingSlicingPass);\n+    reg.register_late_lint_pass(box panic::Pass);\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n     reg.register_late_lint_pass(box derive::Derive);\n     reg.register_late_lint_pass(box types::CharLitAsU8);"}, {"sha": "2437df96bd10c9993fc312c0dc3dc6a6aa0063c4", "filename": "tests/ui/array_indexing.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/tests%2Fui%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/tests%2Fui%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farray_indexing.rs?ref=7af0c678559ef75e9ec6359ec3e05d76dfc355f5", "patch": "@@ -1,18 +1,26 @@\n #![feature(plugin)]\n-\n-\n #![warn(indexing_slicing)]\n #![warn(out_of_bounds_indexing)]\n #![allow(no_effect, unnecessary_operation)]\n \n fn main() {\n-    let x = [1,2,3,4];\n+    let x = [1, 2, 3, 4];\n+    let index: usize = 1;\n+    let index_from: usize = 2;\n+    let index_to: usize = 3;\n+    x[index];\n+    &x[index_from..index_to];\n+    &x[index_from..][..index_to];\n+    &x[index..];\n+    &x[..index];\n     x[0];\n     x[3];\n     x[4];\n     x[1 << 3];\n     &x[1..5];\n+    &x[1..][..5];\n     &x[0..3];\n+    &x[0..][..3];\n     &x[0..=4];\n     &x[..=4];\n     &x[..];\n@@ -42,4 +50,11 @@ fn main() {\n     &empty[..0];\n     &empty[1..];\n     &empty[..4];\n+\n+    let v = vec![0; 5];\n+    v[0];\n+    v[10];\n+    &v[10..100];\n+    &v[10..];\n+    &v[..100];\n }"}, {"sha": "14ef73155a0d5dcc8f41945a846798060cd665b7", "filename": "tests/ui/array_indexing.stderr", "status": "modified", "additions": 159, "deletions": 57, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/tests%2Fui%2Farray_indexing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7af0c678559ef75e9ec6359ec3e05d76dfc355f5/tests%2Fui%2Farray_indexing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farray_indexing.stderr?ref=7af0c678559ef75e9ec6359ec3e05d76dfc355f5", "patch": "@@ -1,120 +1,222 @@\n+error: indexing may panic. Consider using `.get(n)` or `.get_mut(n)` instead\n+  --> $DIR/array_indexing.rs:11:5\n+   |\n+11 |     x[index];\n+   |     ^^^^^^^^\n+   |\n+   = note: `-D indexing-slicing` implied by `-D warnings`\n+\n+error: slicing may panic. Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+  --> $DIR/array_indexing.rs:12:6\n+   |\n+12 |     &x[index_from..index_to];\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:13:6\n+   |\n+13 |     &x[index_from..][..index_to];\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(n..)` or .get_mut(n..)` instead\n+  --> $DIR/array_indexing.rs:13:6\n+   |\n+13 |     &x[index_from..][..index_to];\n+   |      ^^^^^^^^^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(n..)` or .get_mut(n..)` instead\n+  --> $DIR/array_indexing.rs:14:6\n+   |\n+14 |     &x[index..];\n+   |      ^^^^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:15:6\n+   |\n+15 |     &x[..index];\n+   |      ^^^^^^^^^^\n+\n error: const index is out of bounds\n-  --> $DIR/array_indexing.rs:12:5\n+  --> $DIR/array_indexing.rs:18:5\n    |\n-12 |     x[4];\n+18 |     x[4];\n    |     ^^^^\n    |\n    = note: `-D out-of-bounds-indexing` implied by `-D warnings`\n \n-error: const index is out of bounds\n-  --> $DIR/array_indexing.rs:13:5\n+error: range is out of bounds\n+  --> $DIR/array_indexing.rs:20:6\n    |\n-13 |     x[1 << 3];\n-   |     ^^^^^^^^^\n+20 |     &x[1..5];\n+   |      ^^^^^^^\n \n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:14:6\n+error: slicing may panic. Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+  --> $DIR/array_indexing.rs:20:6\n    |\n-14 |     &x[1..5];\n+20 |     &x[1..5];\n    |      ^^^^^^^\n \n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:16:6\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:21:6\n    |\n-16 |     &x[0..=4];\n-   |      ^^^^^^^^\n+21 |     &x[1..][..5];\n+   |      ^^^^^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:23:6\n+   |\n+23 |     &x[0..][..3];\n+   |      ^^^^^^^^^^^\n \n error: range is out of bounds\n-  --> $DIR/array_indexing.rs:17:6\n+  --> $DIR/array_indexing.rs:25:6\n    |\n-17 |     &x[..=4];\n+25 |     &x[..=4];\n+   |      ^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:25:6\n+   |\n+25 |     &x[..=4];\n    |      ^^^^^^^\n \n error: range is out of bounds\n-  --> $DIR/array_indexing.rs:21:6\n+  --> $DIR/array_indexing.rs:29:6\n    |\n-21 |     &x[5..];\n+29 |     &x[5..];\n    |      ^^^^^^\n \n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:23:6\n+error: slicing may panic. Consider using `.get(n..)` or .get_mut(n..)` instead\n+  --> $DIR/array_indexing.rs:29:6\n    |\n-23 |     &x[..5];\n+29 |     &x[5..];\n    |      ^^^^^^\n \n-error: indexing may panic\n-  --> $DIR/array_indexing.rs:26:5\n+error: range is out of bounds\n+  --> $DIR/array_indexing.rs:31:6\n    |\n-26 |     y[0];\n-   |     ^^^^\n+31 |     &x[..5];\n+   |      ^^^^^^\n+\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:31:6\n    |\n-   = note: `-D indexing-slicing` implied by `-D warnings`\n+31 |     &x[..5];\n+   |      ^^^^^^\n \n-error: slicing may panic\n-  --> $DIR/array_indexing.rs:27:6\n+error: indexing may panic. Consider using `.get(n)` or `.get_mut(n)` instead\n+  --> $DIR/array_indexing.rs:34:5\n    |\n-27 |     &y[1..2];\n-   |      ^^^^^^^\n+34 |     y[0];\n+   |     ^^^^\n \n-error: slicing may panic\n-  --> $DIR/array_indexing.rs:29:6\n+error: slicing may panic. Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+  --> $DIR/array_indexing.rs:35:6\n    |\n-29 |     &y[0..=4];\n-   |      ^^^^^^^^\n+35 |     &y[1..2];\n+   |      ^^^^^^^\n \n-error: slicing may panic\n-  --> $DIR/array_indexing.rs:30:6\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:38:6\n    |\n-30 |     &y[..=4];\n+38 |     &y[..=4];\n    |      ^^^^^^^\n \n error: const index is out of bounds\n-  --> $DIR/array_indexing.rs:33:5\n+  --> $DIR/array_indexing.rs:41:5\n    |\n-33 |     empty[0];\n+41 |     empty[0];\n    |     ^^^^^^^^\n \n error: range is out of bounds\n-  --> $DIR/array_indexing.rs:34:6\n+  --> $DIR/array_indexing.rs:42:6\n    |\n-34 |     &empty[1..5];\n+42 |     &empty[1..5];\n    |      ^^^^^^^^^^^\n \n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:35:6\n+error: slicing may panic. Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+  --> $DIR/array_indexing.rs:42:6\n    |\n-35 |     &empty[0..=4];\n-   |      ^^^^^^^^^^^^\n+42 |     &empty[1..5];\n+   |      ^^^^^^^^^^^\n \n error: range is out of bounds\n-  --> $DIR/array_indexing.rs:36:6\n+  --> $DIR/array_indexing.rs:44:6\n    |\n-36 |     &empty[..=4];\n+44 |     &empty[..=4];\n    |      ^^^^^^^^^^^\n \n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:40:6\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:44:6\n    |\n-40 |     &empty[0..=0];\n-   |      ^^^^^^^^^^^^\n+44 |     &empty[..=4];\n+   |      ^^^^^^^^^^^\n \n error: range is out of bounds\n-  --> $DIR/array_indexing.rs:41:6\n+  --> $DIR/array_indexing.rs:49:6\n    |\n-41 |     &empty[..=0];\n+49 |     &empty[..=0];\n+   |      ^^^^^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:49:6\n+   |\n+49 |     &empty[..=0];\n    |      ^^^^^^^^^^^\n \n error: range is out of bounds\n-  --> $DIR/array_indexing.rs:43:6\n+  --> $DIR/array_indexing.rs:51:6\n    |\n-43 |     &empty[1..];\n+51 |     &empty[1..];\n+   |      ^^^^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(n..)` or .get_mut(n..)` instead\n+  --> $DIR/array_indexing.rs:51:6\n+   |\n+51 |     &empty[1..];\n    |      ^^^^^^^^^^\n \n error: range is out of bounds\n-  --> $DIR/array_indexing.rs:44:6\n+  --> $DIR/array_indexing.rs:52:6\n+   |\n+52 |     &empty[..4];\n+   |      ^^^^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:52:6\n+   |\n+52 |     &empty[..4];\n+   |      ^^^^^^^^^^\n+\n+error: indexing may panic. Consider using `.get(n)` or `.get_mut(n)` instead\n+  --> $DIR/array_indexing.rs:55:5\n+   |\n+55 |     v[0];\n+   |     ^^^^\n+\n+error: indexing may panic. Consider using `.get(n)` or `.get_mut(n)` instead\n+  --> $DIR/array_indexing.rs:56:5\n    |\n-44 |     &empty[..4];\n+56 |     v[10];\n+   |     ^^^^^\n+\n+error: slicing may panic. Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+  --> $DIR/array_indexing.rs:57:6\n+   |\n+57 |     &v[10..100];\n    |      ^^^^^^^^^^\n \n-error: aborting due to 19 previous errors\n+error: slicing may panic. Consider using `.get(n..)` or .get_mut(n..)` instead\n+  --> $DIR/array_indexing.rs:58:6\n+   |\n+58 |     &v[10..];\n+   |      ^^^^^^^\n+\n+error: slicing may panic. Consider using `.get(..n)`or `.get_mut(..n)` instead\n+  --> $DIR/array_indexing.rs:59:6\n+   |\n+59 |     &v[..100];\n+   |      ^^^^^^^^\n+\n+error: aborting due to 36 previous errors\n "}]}