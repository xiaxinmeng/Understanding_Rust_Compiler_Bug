{"sha": "d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YWVlMzFhNjAwYThhOGE1NmRkZWUwZWUyZmYxYzVkNWJhMjMyMGI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-07T10:18:25Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-15T18:19:49Z"}, "message": "start salsa migration", "tree": {"sha": "2610e72a444870434fcca6f1d69751800b957543", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2610e72a444870434fcca6f1d69751800b957543"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "html_url": "https://github.com/rust-lang/rust/commit/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93d77e9b22c38a3587f3b7d5c3c6d517b66f3314", "url": "https://api.github.com/repos/rust-lang/rust/commits/93d77e9b22c38a3587f3b7d5c3c6d517b66f3314", "html_url": "https://github.com/rust-lang/rust/commit/93d77e9b22c38a3587f3b7d5c3c6d517b66f3314"}], "stats": {"total": 321, "additions": 221, "deletions": 100}, "files": [{"sha": "98f06f53ad074fc7407631c4cb870e0974af2559", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "patch": "@@ -842,14 +842,6 @@ name = \"safemem\"\n version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"salsa\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"im 12.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"salsa\"\n version = \"0.4.1\""}, {"sha": "4b3e0fc900420862c78ec4853bcc2a0e200744d8", "filename": "crates/ra_analysis/src/db/mod.rs", "status": "modified", "additions": 167, "deletions": 59, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb%2Fmod.rs?ref=d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "patch": "@@ -1,85 +1,193 @@\n-mod imp;\n-\n use std::{\n+    fmt,\n     sync::Arc,\n+    hash::{Hash, Hasher},\n+    collections::HashSet,\n };\n-use im;\n use salsa;\n-use crate::{FileId, imp::FileResolverImp};\n+use ra_syntax::File;\n+use ra_editor::{LineIndex};\n+use crate::{\n+    symbol_index::SymbolIndex,\n+    FileId, FileResolverImp\n+};\n \n-#[derive(Debug, Default, Clone)]\n-pub(crate) struct State {\n-    pub(crate) file_map: im::HashMap<FileId, Arc<String>>,\n-    pub(crate) file_resolver: FileResolverImp\n+#[derive(Default)]\n+pub(crate) struct RootDatabase {\n+    runtime: salsa::runtime::Runtime<RootDatabase>,\n }\n \n-#[derive(Debug)]\n-pub(crate) struct Db {\n-    imp: imp::Db,\n+impl fmt::Debug for RootDatabase {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.write_str(\"RootDatabase { ... }\")\n+    }\n }\n \n-#[derive(Clone, Copy)]\n-pub(crate) struct QueryCtx<'a> {\n-    imp: &'a salsa::QueryCtx<State, imp::Data>,\n+impl salsa::Database for RootDatabase {\n+    fn salsa_runtime(&self) -> &salsa::runtime::Runtime<RootDatabase> {\n+        &self.runtime\n+    }\n }\n \n-pub(crate) struct Query<T, R>(pub(crate) u16, pub(crate) fn(QueryCtx, &T) -> R);\n-\n-pub(crate) struct QueryRegistry {\n-    imp: imp::QueryRegistry,\n+salsa::database_storage! {\n+    pub(crate) struct RootDatabaseStorage for RootDatabase {\n+        impl FilesDatabase {\n+            fn file_text() for FileTextQuery;\n+            fn file_set() for FileSetQuery;\n+        }\n+        impl SyntaxDatabase {\n+            fn file_syntax() for FileSyntaxQuery;\n+            fn file_lines() for FileLinesQuery;\n+            fn file_symbols() for FileSymbolsQuery;\n+        }\n+    }\n }\n \n-impl Default for Db {\n-    fn default() -> Db {\n-        Db::new()\n+salsa::query_group! {\n+    pub(crate) trait FilesDatabase: salsa::Database {\n+        fn file_text(file_id: FileId) -> Arc<String> {\n+            type FileTextQuery;\n+            storage input;\n+        }\n+        fn file_set(key: ()) -> Arc<FileSet> {\n+            type FileSetQuery;\n+            storage input;\n+        }\n     }\n }\n \n-impl Db {\n-    pub(crate) fn new() -> Db {\n-        let reg = QueryRegistry::new();\n-        Db { imp: imp::Db::new(reg.imp) }\n-    }\n-    pub(crate) fn state(&self) -> &State {\n-        self.imp.imp.ground_data()\n-    }\n-    pub(crate) fn with_changes(&self, new_state: State, changed_files: &[FileId], resolver_changed: bool) -> Db {\n-        Db { imp: self.imp.with_changes(new_state, changed_files, resolver_changed) }\n-    }\n-    pub(crate) fn make_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> R {\n-        let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n-        f(ctx)\n-    }\n-    #[allow(unused)]\n-    pub(crate) fn trace_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> (R, Vec<&'static str>) {\n-        let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n-        let res = f(ctx);\n-        let trace = self.imp.extract_trace(ctx.imp);\n-        (res, trace)\n-    }\n+#[derive(Default, Debug)]\n+pub(crate) struct FileSet {\n+    pub(crate) files: HashSet<FileId>,\n+    pub(crate) resolver: FileResolverImp,\n }\n \n-impl<'a> QueryCtx<'a> {\n-    pub(crate) fn get<Q: imp::EvalQuery>(&self, q: Q, params: Q::Params) -> Arc<Q::Output> {\n-        q.get(self, params)\n+impl PartialEq for FileSet {\n+    fn eq(&self, other: &FileSet) -> bool {\n+        self.files == other.files\n     }\n }\n \n-pub(crate) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n-    imp::file_text(ctx, file_id)\n+impl Eq for FileSet {\n }\n \n-pub(crate) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n-    imp::file_set(ctx)\n-}\n-impl QueryRegistry {\n-    fn new() -> QueryRegistry {\n-        let mut reg = QueryRegistry { imp: imp::QueryRegistry::new() };\n-        crate::queries::register_queries(&mut reg);\n-        crate::module_map::register_queries(&mut reg);\n-        reg\n+impl Hash for FileSet {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        let mut files = self.files.iter().cloned().collect::<Vec<_>>();\n+        files.sort();\n+        files.hash(hasher);\n     }\n-    pub(crate) fn add<Q: imp::EvalQuery>(&mut self, q: Q, name: &'static str) {\n-        self.imp.add(q, name)\n+}\n+\n+salsa::query_group! {\n+    pub(crate) trait SyntaxDatabase: FilesDatabase {\n+        fn file_syntax(file_id: FileId) -> File {\n+            type FileSyntaxQuery;\n+        }\n+        fn file_lines(file_id: FileId) -> Arc<LineIndex> {\n+            type FileLinesQuery;\n+        }\n+        fn file_symbols(file_id: FileId) -> Arc<SymbolIndex> {\n+            type FileSymbolsQuery;\n+        }\n     }\n }\n+\n+fn file_syntax(db: &impl SyntaxDatabase, file_id: FileId) -> File {\n+    let text = db.file_text(file_id);\n+    File::parse(&*text)\n+}\n+fn file_lines(db: &impl SyntaxDatabase, file_id: FileId) -> Arc<LineIndex> {\n+    let text = db.file_text(file_id);\n+    Arc::new(LineIndex::new(&*text))\n+}\n+fn file_symbols(db: &impl SyntaxDatabase, file_id: FileId) -> Arc<SymbolIndex> {\n+    let syntax = db.file_syntax(file_id);\n+    Arc::new(SymbolIndex::for_file(file_id, syntax))\n+}\n+\n+// mod imp;\n+\n+// use std::{\n+//     sync::Arc,\n+// };\n+// use im;\n+// use salsa;\n+// use {FileId, imp::FileResolverImp};\n+\n+// #[derive(Debug, Default, Clone)]\n+// pub(crate) struct State {\n+//     pub(crate) file_map: im::HashMap<FileId, Arc<String>>,\n+//     pub(crate) file_resolver: FileResolverImp\n+// }\n+\n+// #[derive(Debug)]\n+// pub(crate) struct Db {\n+//     imp: imp::Db,\n+// }\n+\n+// #[derive(Clone, Copy)]\n+// pub(crate) struct QueryCtx<'a> {\n+//     imp: &'a salsa::QueryCtx<State, imp::Data>,\n+// }\n+\n+// pub(crate) struct Query<T, R>(pub(crate) u16, pub(crate) fn(QueryCtx, &T) -> R);\n+\n+// pub(crate) struct QueryRegistry {\n+//     imp: imp::QueryRegistry,\n+// }\n+\n+// impl Default for Db {\n+//     fn default() -> Db {\n+//         Db::new()\n+//     }\n+// }\n+\n+// impl Db {\n+//     pub(crate) fn new() -> Db {\n+//         let reg = QueryRegistry::new();\n+//         Db { imp: imp::Db::new(reg.imp) }\n+//     }\n+//     pub(crate) fn state(&self) -> &State {\n+//         self.imp.imp.ground_data()\n+//     }\n+//     pub(crate) fn with_changes(&self, new_state: State, changed_files: &[FileId], resolver_changed: bool) -> Db {\n+//         Db { imp: self.imp.with_changes(new_state, changed_files, resolver_changed) }\n+//     }\n+//     pub(crate) fn make_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> R {\n+//         let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n+//         f(ctx)\n+//     }\n+//     #[allow(unused)]\n+//     pub(crate) fn trace_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> (R, Vec<&'static str>) {\n+//         let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n+//         let res = f(ctx);\n+//         let trace = self.imp.extract_trace(ctx.imp);\n+//         (res, trace)\n+//     }\n+// }\n+\n+// impl<'a> QueryCtx<'a> {\n+//     pub(crate) fn get<Q: imp::EvalQuery>(&self, q: Q, params: Q::Params) -> Arc<Q::Output> {\n+//         q.get(self, params)\n+//     }\n+// }\n+\n+// pub(crate) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n+//     imp::file_text(ctx, file_id)\n+// }\n+\n+// pub(crate) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n+//     imp::file_set(ctx)\n+// }\n+// impl QueryRegistry {\n+//     fn new() -> QueryRegistry {\n+//         let mut reg = QueryRegistry { imp: imp::QueryRegistry::new() };\n+//         ::queries::register_queries(&mut reg);\n+//         ::module_map::register_queries(&mut reg);\n+//         reg\n+//     }\n+//     pub(crate) fn add<Q: imp::EvalQuery>(&mut self, q: Q, name: &'static str) {\n+//         self.imp.add(q, name)\n+//     }\n+// }"}, {"sha": "4c1ccdeaf13e4affc53d88c8984dce0e18af9bff", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "patch": "@@ -14,12 +14,12 @@ extern crate salsa;\n extern crate rustc_hash;\n \n mod symbol_index;\n-mod module_map;\n+// mod module_map;\n mod imp;\n mod job;\n mod roots;\n mod db;\n-mod queries;\n+// mod queries;\n mod descriptors;\n \n use std::{"}, {"sha": "7a7d1169ee3f5a2404f980174dd324a7ab8a8720", "filename": "crates/ra_analysis/src/roots.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_analysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_analysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Froots.rs?ref=d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "patch": "@@ -1,11 +1,13 @@\n use std::{\n+    collections::{HashMap, HashSet},\n     sync::Arc,\n     panic,\n };\n+use parking_lot::RwLock;\n \n use once_cell::sync::OnceCell;\n use rayon::prelude::*;\n-use rustc_hash::FxHashMap;\n+use salsa::Database;\n use ra_editor::LineIndex;\n use ra_syntax::File;\n \n@@ -14,7 +16,7 @@ use crate::{\n     imp::FileResolverImp,\n     symbol_index::SymbolIndex,\n     descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n-    db::Db,\n+    db::{self, FilesDatabase, SyntaxDatabase}\n };\n \n pub(crate) trait SourceRoot {\n@@ -25,9 +27,9 @@ pub(crate) trait SourceRoot {\n     fn symbols(&self, acc: &mut Vec<Arc<SymbolIndex>>);\n }\n \n-#[derive(Default, Debug)]\n+#[derive(Default, Debug, Clone)]\n pub(crate) struct WritableSourceRoot {\n-    db: Db,\n+    db: Arc<RwLock<db::RootDatabase>>,\n }\n \n impl WritableSourceRoot {\n@@ -36,51 +38,61 @@ impl WritableSourceRoot {\n         changes: &mut dyn Iterator<Item=(FileId, Option<String>)>,\n         file_resolver: Option<FileResolverImp>,\n     ) -> WritableSourceRoot {\n-        let resolver_changed = file_resolver.is_some();\n-        let mut changed_files = Vec::new();\n-        let mut new_state = self.db.state().clone();\n-\n+        let db = self.db.write();\n+        let mut changed = HashSet::new();\n+        let mut removed = HashSet::new();\n         for (file_id, text) in changes {\n-            changed_files.push(file_id);\n             match text {\n-                Some(text) => {\n-                    new_state.file_map.insert(file_id, Arc::new(text));\n-                },\n                 None => {\n-                    new_state.file_map.remove(&file_id);\n+                    removed.insert(file_id);\n+                }\n+                Some(text) => {\n+                    db.query(db::FileTextQuery)\n+                        .set(file_id, Arc::new(text));\n+                    changed.insert(file_id);\n                 }\n             }\n         }\n-        if let Some(file_resolver) = file_resolver {\n-            new_state.file_resolver = file_resolver\n-        }\n-        WritableSourceRoot {\n-            db: self.db.with_changes(new_state, &changed_files, resolver_changed)\n+        if let Some(resolver) = file_resolver {\n+            let mut files: HashSet<FileId> = db.file_set(())\n+                .files\n+                .clone();\n+            for file_id in removed {\n+                files.remove(&file_id);\n+            }\n+            files.extend(changed);\n+            db.query(db::FileSetQuery)\n+                .set((), Arc::new(db::FileSet { files, resolver }))\n         }\n+        // TODO: reconcile sasla's API with our needs\n+        // https://github.com/salsa-rs/salsa/issues/12\n+        self.clone()\n     }\n }\n \n impl SourceRoot for WritableSourceRoot {\n     fn module_tree(&self) -> Arc<ModuleTreeDescriptor> {\n-        self.db.make_query(crate::module_map::module_tree)\n+        unimplemented!()\n+        //self.db.make_query(::module_map::module_tree)\n     }\n \n     fn contains(&self, file_id: FileId) -> bool {\n-        self.db.state().file_map.contains_key(&file_id)\n+        self.db.read().file_set(()).files.contains(&file_id)\n     }\n     fn lines(&self, file_id: FileId) -> Arc<LineIndex> {\n-        self.db.make_query(|ctx| crate::queries::file_lines(ctx, file_id))\n+        self.db.read().file_lines(file_id)\n     }\n     fn syntax(&self, file_id: FileId) -> File {\n-        self.db.make_query(|ctx| crate::queries::file_syntax(ctx, file_id))\n+        self.db.read().file_syntax(file_id)\n     }\n     fn symbols<'a>(&'a self, acc: &mut Vec<Arc<SymbolIndex>>) {\n-        self.db.make_query(|ctx| {\n-            let file_set = crate::queries::file_set(ctx);\n-            let syms = file_set.0.iter()\n-                .map(|file_id| crate::queries::file_symbols(ctx, *file_id));\n-            acc.extend(syms);\n-        });\n+        let db = self.db.read();\n+        let symbols =  db.file_set(());\n+        let symbols = symbols\n+            .files\n+            .iter()\n+            .map(|&file_id| db.file_symbols(file_id));\n+        acc.extend(symbols);\n     }\n }\n "}, {"sha": "54672fde42d2067bc9afcdce241de43268f9846e", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "patch": "@@ -17,6 +17,15 @@ pub(crate) struct SymbolIndex {\n     map: fst::Map,\n }\n \n+impl PartialEq for SymbolIndex {\n+    fn eq(&self, other: &SymbolIndex) -> bool {\n+        self.symbols == other.symbols\n+    }\n+}\n+\n+impl Eq for SymbolIndex {\n+}\n+\n impl Hash for SymbolIndex {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n         self.symbols.hash(hasher)"}, {"sha": "95d64b8a8072013165a1004f69728e2af842510e", "filename": "crates/ra_editor/src/line_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index.rs?ref=d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "patch": "@@ -1,7 +1,7 @@\n use superslice::Ext;\n use crate::TextUnit;\n \n-#[derive(Clone, Debug, Hash)]\n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub struct LineIndex {\n     newlines: Vec<TextUnit>,\n }"}, {"sha": "d9e4b2df7a4eef3ef130b5054b5d87982e07671c", "filename": "crates/ra_editor/src/symbols.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_editor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_editor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fsymbols.rs?ref=d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "patch": "@@ -17,7 +17,7 @@ pub struct StructureNode {\n     pub kind: SyntaxKind,\n }\n \n-#[derive(Debug, Clone, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FileSymbol {\n     pub name: SmolStr,\n     pub node_range: TextRange,"}, {"sha": "7eba5ee614fb92b7dbe66458c307db5ab22fb849", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=d8aee31a600a8a8a56ddee0ee2ff1c5d5ba2320b", "patch": "@@ -59,7 +59,7 @@ use crate::{\n     yellow::{GreenNode},\n };\n \n-#[derive(Clone, Debug, Hash)]\n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub struct File {\n     root: SyntaxNode\n }"}]}