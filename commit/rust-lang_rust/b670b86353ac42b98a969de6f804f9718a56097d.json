{"sha": "b670b86353ac42b98a969de6f804f9718a56097d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NzBiODYzNTNhYzQyYjk4YTk2OWRlNmY4MDRmOTcxOGE1NjA5N2Q=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-21T08:40:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-21T08:40:37Z"}, "message": "Rollup merge of #76936 - danielhenrymantilla:unsafecell_get_mut, r=RalfJung\n\nAdd non-`unsafe` `.get_mut()` for `Unsafecell`\n\n  - Tracking issue: https://github.com/rust-lang/rust/issues/76943\n\nAs discussed in: https://internals.rust-lang.org/t/add-non-unsafe-get-mut-for-unsafecell/12407\n\n  - ### [Rendered documentation](https://modest-dubinsky-1f9f47.netlify.app/core/cell/struct.unsafecell)\n\nThis PR tries to move the sound `&mut UnsafeCell<T> -> &mut T` projection that all the \"downstream\" constructions were already relying on, up to the root abstraction, where it rightfully belongs, and officially blessing it.\n\n  - this **helps reduce the amount of `unsafe` snippets out there** (_c.f._, the second commit of this PR: https://github.com/rust-lang/rust/pull/76936/commits/09503fd1b30c83ca605546fa3f899721e41e68c6)\n\nThe fact that this getter is now expose for `UnsafeCell<T>` itself, will also help convey the idea that **`UnsafeCell` is not magical _w.r.t._ `&mut` accesses**, contrary to what some people incorrectly think.\n\n  - Even the standard library itself at some point had such a confusion, _c.f._ this comment where there is a mention of multi-threaded (and thus _shared_) access despite dealing with exclusive references over unique ownership: https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library/core/src/cell.rs#L498-L499\n\nr? @RalfJung", "tree": {"sha": "84818eb43148419de2499a7c98da525d66d7d883", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84818eb43148419de2499a7c98da525d66d7d883"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b670b86353ac42b98a969de6f804f9718a56097d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfaGcGCRBK7hj4Ov3rIwAAdHIIABTe9LbH/8ufTYagf93QPmHE\nSOqahQ+uroJ/0lI5DSwpw+Yy2WtkQTfGItdM3ns/8CRIr42+1vbymanX6+O5h4OO\n4Y3lOhO87PbWPg0spkidXhdGO5hAag2W1uMURye0GcyEXQ8ftG8KHzEGPUFIrEDN\nhYW4P3R6b4u1ireM2JttftjVQEQJK7sRNO73wImi5FtYKYku4pXWDHE1Zep+MJHs\ngU505d+EBID+VQb0Np79PBy++TIPh0sJM5YRY+m1SqtPjngemdcF/noKyo0sjfpe\nyPumpR+yXp7nbfUWQqWn+oNTl2xVW/qlnONVWlzOh1BBscA6DYvN01RmSZIqclg=\n=QVsv\n-----END PGP SIGNATURE-----\n", "payload": "tree 84818eb43148419de2499a7c98da525d66d7d883\nparent 02d787bef8b6b12523253cf24f79df5c1428959c\nparent 5886c38112c8bb347b1cbd46c28b1ca6f8bac88d\nauthor Ralf Jung <post@ralfj.de> 1600677637 +0200\ncommitter GitHub <noreply@github.com> 1600677637 +0200\n\nRollup merge of #76936 - danielhenrymantilla:unsafecell_get_mut, r=RalfJung\n\nAdd non-`unsafe` `.get_mut()` for `Unsafecell`\n\n  - Tracking issue: https://github.com/rust-lang/rust/issues/76943\n\nAs discussed in: https://internals.rust-lang.org/t/add-non-unsafe-get-mut-for-unsafecell/12407\n\n  - ### [Rendered documentation](https://modest-dubinsky-1f9f47.netlify.app/core/cell/struct.unsafecell)\n\nThis PR tries to move the sound `&mut UnsafeCell<T> -> &mut T` projection that all the \"downstream\" constructions were already relying on, up to the root abstraction, where it rightfully belongs, and officially blessing it.\n\n  - this **helps reduce the amount of `unsafe` snippets out there** (_c.f._, the second commit of this PR: https://github.com/rust-lang/rust/pull/76936/commits/09503fd1b30c83ca605546fa3f899721e41e68c6)\n\nThe fact that this getter is now expose for `UnsafeCell<T>` itself, will also help convey the idea that **`UnsafeCell` is not magical _w.r.t._ `&mut` accesses**, contrary to what some people incorrectly think.\n\n  - Even the standard library itself at some point had such a confusion, _c.f._ this comment where there is a mention of multi-threaded (and thus _shared_) access despite dealing with exclusive references over unique ownership: https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library/core/src/cell.rs#L498-L499\n\nr? @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b670b86353ac42b98a969de6f804f9718a56097d", "html_url": "https://github.com/rust-lang/rust/commit/b670b86353ac42b98a969de6f804f9718a56097d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b670b86353ac42b98a969de6f804f9718a56097d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02d787bef8b6b12523253cf24f79df5c1428959c", "url": "https://api.github.com/repos/rust-lang/rust/commits/02d787bef8b6b12523253cf24f79df5c1428959c", "html_url": "https://github.com/rust-lang/rust/commit/02d787bef8b6b12523253cf24f79df5c1428959c"}, {"sha": "5886c38112c8bb347b1cbd46c28b1ca6f8bac88d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5886c38112c8bb347b1cbd46c28b1ca6f8bac88d", "html_url": "https://github.com/rust-lang/rust/commit/5886c38112c8bb347b1cbd46c28b1ca6f8bac88d"}], "stats": {"total": 116, "additions": 91, "deletions": 25}, "files": [{"sha": "f60aa2d24c5cafd0599f933cd758f63f9dddf0dc", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 86, "deletions": 15, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=b670b86353ac42b98a969de6f804f9718a56097d", "patch": "@@ -496,10 +496,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n-        // SAFETY: This can cause data races if called from a separate thread,\n-        // but `Cell` is `!Sync` so this won't happen, and `&mut` guarantees\n-        // unique access.\n-        unsafe { &mut *self.value.get() }\n+        self.value.get_mut()\n     }\n \n     /// Returns a `&Cell<T>` from a `&mut T`\n@@ -945,8 +942,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n-        // SAFETY: `&mut` guarantees unique access.\n-        unsafe { &mut *self.value.get() }\n+        self.value.get_mut()\n     }\n \n     /// Undo the effect of leaked guards on the borrow state of the `RefCell`.\n@@ -1543,8 +1539,11 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// allow internal mutability, such as `Cell<T>` and `RefCell<T>`, use `UnsafeCell` to wrap their\n /// internal data. There is *no* legal way to obtain aliasing `&mut`, not even with `UnsafeCell<T>`.\n ///\n-/// The `UnsafeCell` API itself is technically very simple: it gives you a raw pointer `*mut T` to\n-/// its contents. It is up to _you_ as the abstraction designer to use that raw pointer correctly.\n+/// The `UnsafeCell` API itself is technically very simple: [`.get()`] gives you a raw pointer\n+/// `*mut T` to its contents. It is up to _you_ as the abstraction designer to use that raw pointer\n+/// correctly.\n+///\n+/// [`.get()`]: `UnsafeCell::get`\n ///\n /// The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:\n ///\n@@ -1571,21 +1570,70 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// 2. A `&mut T` reference may be released to safe code provided neither other `&mut T` nor `&T`\n /// co-exist with it. A `&mut T` must always be unique.\n ///\n-/// Note that while mutating or mutably aliasing the contents of an `&UnsafeCell<T>` is\n-/// ok (provided you enforce the invariants some other way), it is still undefined behavior\n-/// to have multiple `&mut UnsafeCell<T>` aliases.\n+/// Note that whilst mutating the contents of an `&UnsafeCell<T>` (even while other\n+/// `&UnsafeCell<T>` references alias the cell) is\n+/// ok (provided you enforce the above invariants some other way), it is still undefined behavior\n+/// to have multiple `&mut UnsafeCell<T>` aliases. That is, `UnsafeCell` is a wrapper\n+/// designed to have a special interaction with _shared_ accesses (_i.e._, through an\n+/// `&UnsafeCell<_>` reference); there is no magic whatsoever when dealing with _exclusive_\n+/// accesses (_e.g._, through an `&mut UnsafeCell<_>`): neither the cell nor the wrapped value\n+/// may be aliased for the duration of that `&mut` borrow.\n+/// This is showcased by the [`.get_mut()`] accessor, which is a non-`unsafe` getter that yields\n+/// a `&mut T`.\n+///\n+/// [`.get_mut()`]: `UnsafeCell::get_mut`\n ///\n /// # Examples\n ///\n+/// Here is an example showcasing how to soundly mutate the contents of an `UnsafeCell<_>` despite\n+/// there being multiple references aliasing the cell:\n+///\n /// ```\n /// use std::cell::UnsafeCell;\n ///\n-/// # #[allow(dead_code)]\n-/// struct NotThreadSafe<T> {\n-///     value: UnsafeCell<T>,\n+/// let x: UnsafeCell<i32> = 42.into();\n+/// // Get multiple / concurrent / shared references to the same `x`.\n+/// let (p1, p2): (&UnsafeCell<i32>, &UnsafeCell<i32>) = (&x, &x);\n+///\n+/// unsafe {\n+///     // SAFETY: within this scope there are no other references to `x`'s contents,\n+///     // so ours is effectively unique.\n+///     let p1_exclusive: &mut i32 = &mut *p1.get(); // -- borrow --+\n+///     *p1_exclusive += 27; //                                     |\n+/// } // <---------- cannot go beyond this point -------------------+\n+///\n+/// unsafe {\n+///     // SAFETY: within this scope nobody expects to have exclusive access to `x`'s contents,\n+///     // so we can have multiple shared accesses concurrently.\n+///     let p2_shared: &i32 = &*p2.get();\n+///     assert_eq!(*p2_shared, 42 + 27);\n+///     let p1_shared: &i32 = &*p1.get();\n+///     assert_eq!(*p1_shared, *p2_shared);\n /// }\n+/// ```\n ///\n-/// unsafe impl<T> Sync for NotThreadSafe<T> {}\n+/// The following example showcases the fact that exclusive access to an `UnsafeCell<T>`\n+/// implies exclusive access to its `T`:\n+///\n+/// ```rust\n+/// #![feature(unsafe_cell_get_mut)]\n+/// #![forbid(unsafe_code)] // with exclusive accesses,\n+///                         // `UnsafeCell` is a transparent no-op wrapper,\n+///                         // so no need for `unsafe` here.\n+/// use std::cell::UnsafeCell;\n+///\n+/// let mut x: UnsafeCell<i32> = 42.into();\n+///\n+/// // Get a compile-time-checked unique reference to `x`.\n+/// let p_unique: &mut UnsafeCell<i32> = &mut x;\n+/// // With an exclusive reference, we can mutate the contents for free.\n+/// *p_unique.get_mut() = 0;\n+/// // Or, equivalently:\n+/// x = UnsafeCell::new(0);\n+///\n+/// // When we own the value, we can extract the contents for free.\n+/// let contents: i32 = x.into_inner();\n+/// assert_eq!(contents, 0);\n /// ```\n #[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1663,6 +1711,29 @@ impl<T: ?Sized> UnsafeCell<T> {\n         self as *const UnsafeCell<T> as *const T as *mut T\n     }\n \n+    /// Returns a mutable reference to the underlying data.\n+    ///\n+    /// This call borrows the `UnsafeCell` mutably (at compile-time) which\n+    /// guarantees that we possess the only reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unsafe_cell_get_mut)]\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let mut c = UnsafeCell::new(5);\n+    /// *c.get_mut() += 1;\n+    ///\n+    /// assert_eq!(*c.get_mut(), 6);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"unsafe_cell_get_mut\", issue = \"76943\")]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: (outer) `&mut` guarantees unique access.\n+        unsafe { &mut *self.get() }\n+    }\n+\n     /// Gets a mutable pointer to the wrapped value.\n     /// The difference to [`get`] is that this function accepts a raw pointer,\n     /// which is useful to avoid the creation of temporary references."}, {"sha": "c67d6422c01ec9f6dc107eae1b821eb35a7537d1", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=b670b86353ac42b98a969de6f804f9718a56097d", "patch": "@@ -838,8 +838,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut *mut T {\n-        // SAFETY: the mutable reference guarantees unique ownership.\n-        unsafe { &mut *self.p.get() }\n+        self.p.get_mut()\n     }\n \n     /// Get atomic access to a pointer.\n@@ -1275,8 +1274,7 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 #[inline]\n                 #[$stable_access]\n                 pub fn get_mut(&mut self) -> &mut $int_type {\n-                    // SAFETY: the mutable reference guarantees unique ownership.\n-                    unsafe { &mut *self.v.get() }\n+                    self.v.get_mut()\n                 }\n             }\n "}, {"sha": "70533189d8e0b9de487121c31d82bcdfe3b8791c", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=b670b86353ac42b98a969de6f804f9718a56097d", "patch": "@@ -312,6 +312,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![feature(unsafe_cell_get_mut)]\n #![feature(unsafe_cell_raw_get)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]"}, {"sha": "a1703c731d44d3b0fbd5f673ddc37bccc37807c6", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=b670b86353ac42b98a969de6f804f9718a56097d", "patch": "@@ -406,9 +406,7 @@ impl<T: ?Sized> Mutex<T> {\n     /// ```\n     #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n-        // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner mutex.\n-        let data = unsafe { &mut *self.data.get() };\n+        let data = self.data.get_mut();\n         poison::map_result(self.poison.borrow(), |_| data)\n     }\n }"}, {"sha": "d967779ce361de0bf1da126434cf518a7d02963b", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b670b86353ac42b98a969de6f804f9718a56097d/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=b670b86353ac42b98a969de6f804f9718a56097d", "patch": "@@ -404,9 +404,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// ```\n     #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n-        // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner lock.\n-        let data = unsafe { &mut *self.data.get() };\n+        let data = self.data.get_mut();\n         poison::map_result(self.poison.borrow(), |_| data)\n     }\n }"}]}