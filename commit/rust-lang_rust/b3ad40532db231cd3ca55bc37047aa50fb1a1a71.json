{"sha": "b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "node_id": "C_kwDOAAsO6NoAKGIzYWQ0MDUzMmRiMjMxY2QzY2E1NWJjMzcwNDdhYTUwZmIxYTFhNzE", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2021-12-15T11:51:26Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2022-01-21T08:33:43Z"}, "message": "allow excluding paths only from a single module\n\nx.py has support for excluding some steps from the invocation, but\nunfortunately that's not granular enough: some steps have the same name\nin different modules, and that prevents excluding only *some* of them.\n\nAs a practical example, let's say you need to run everything in `./x.py\ntest` except for the standard library tests, as those tests require IPv6\nand need to be executed on a separate machine. Before this commit, if\nyou were to just run this:\n\n    ./x.py test --exclude library/std\n\n...the execution would fail, as that would not only exclude running the\ntests for the standard library, it would also exclude generating its\ndocumentation (breaking linkchecker).\n\nThis commit adds support for an optional module annotation in --exclude\npaths, allowing the user to choose which module to exclude from:\n\n    ./x.py test --exclude test::library/std\n\nThis maintains backward compatibility, but also allows for more ganular\nexclusion. More examples on how this works:\n\n| `--exclude`         | Docs    | Tests   |\n| ------------------- | ------- | ------- |\n| `library/std`       | Skipped | Skipped |\n| `doc::library/std`  | Skipped | Run     |\n| `test::library/std` | Run     | Skipped |\n\nNote that the new behavior only works in the `--exclude` flag, and not\nin other x.py arguments or flags yet.", "tree": {"sha": "747b1919c4b8ea4444ec4d58bbf761732c0138d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/747b1919c4b8ea4444ec4d58bbf761732c0138d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmHqb+cACgkQzXazX3c0\ndp6O9w//U53Ya4UDfgzTYlnUxEW3azsC61U4PDEBbCCkh95DGVj13HW+4n28Pdox\nfZTU5286LIYcT81nlYqTAHCK0n6ZX9vcQsCNEdD4srqTD/7KGWiN1U9YQ3sfrqOD\nM66MaT7Ps/Cmu5u50RLdixGaGAS9jGEppUzfx3uK8NOciSgZhNgnwvms/K/A8YIO\nhi9VUtOJO8hz1Bb2GqmNt6fB25XCaqX2yFwV5ARPRG57J260BBXqLQp2xUcEznWP\nu2yhyztQx4UAgGkWL40e5Qb33pIR5GHIPoamW61tR0vzrhO+z17jnSOZIkZNUIbK\nc3G5FWm+Xa/t4LOy0SyBLUtK92DvUEbU8noXemYazt8vgxw1HmII4k0hD0uoP2Jr\nOmwQv6lidwAOpGQzvaf+cDDPBKtm7sG+/F3/cag8MYoFOX873hBUAvU7wm7SSCpc\nLuqd+V2EsDSY92VFEHchq3b1axVjv8obo9fITkottKtFDauhfrOJzERXV6yM6U9Y\nzyKpZsdJa6PYcO9VxIFKAY7yvqg7cvmec3hgnPnvDkUUb0X5/Y4ZK/lBPSTAJ6/i\n9XrN4f3BPR5Ed+S7ZOq+NHcPGM8fMzeqVJMr2G7hTBFbySZxn2VWTpnV/NsLnc2v\nSNckXuvqYmIExAUU7KLYuuI3zdEF+ByQD1zYmBt6ETVNUrWzRcU=\n=4NJ+\n-----END PGP SIGNATURE-----", "payload": "tree 747b1919c4b8ea4444ec4d58bbf761732c0138d2\nparent b27d59d083a97e7253bcc8a040bc606ae0725fc4\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1639569086 +0100\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1642754023 +0100\n\nallow excluding paths only from a single module\n\nx.py has support for excluding some steps from the invocation, but\nunfortunately that's not granular enough: some steps have the same name\nin different modules, and that prevents excluding only *some* of them.\n\nAs a practical example, let's say you need to run everything in `./x.py\ntest` except for the standard library tests, as those tests require IPv6\nand need to be executed on a separate machine. Before this commit, if\nyou were to just run this:\n\n    ./x.py test --exclude library/std\n\n...the execution would fail, as that would not only exclude running the\ntests for the standard library, it would also exclude generating its\ndocumentation (breaking linkchecker).\n\nThis commit adds support for an optional module annotation in --exclude\npaths, allowing the user to choose which module to exclude from:\n\n    ./x.py test --exclude test::library/std\n\nThis maintains backward compatibility, but also allows for more ganular\nexclusion. More examples on how this works:\n\n| `--exclude`         | Docs    | Tests   |\n| ------------------- | ------- | ------- |\n| `library/std`       | Skipped | Skipped |\n| `doc::library/std`  | Skipped | Run     |\n| `test::library/std` | Run     | Skipped |\n\nNote that the new behavior only works in the `--exclude` flag, and not\nin other x.py arguments or flags yet.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "html_url": "https://github.com/rust-lang/rust/commit/b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b27d59d083a97e7253bcc8a040bc606ae0725fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b27d59d083a97e7253bcc8a040bc606ae0725fc4", "html_url": "https://github.com/rust-lang/rust/commit/b27d59d083a97e7253bcc8a040bc606ae0725fc4"}], "stats": {"total": 169, "additions": 128, "deletions": 41}, "files": [{"sha": "5cab3e8be1039f9917d609c5c0e9498d0ffe5ca8", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 117, "deletions": 31, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "patch": "@@ -7,7 +7,7 @@ use std::fmt::Debug;\n use std::fs;\n use std::hash::Hash;\n use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n+use std::path::{Component, Path, PathBuf};\n use std::process::Command;\n use std::time::{Duration, Instant};\n \n@@ -105,17 +105,43 @@ struct StepDescription {\n     should_run: fn(ShouldRun<'_>) -> ShouldRun<'_>,\n     make_run: fn(RunConfig<'_>),\n     name: &'static str,\n+    kind: Kind,\n }\n \n-#[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n+#[derive(Clone, PartialOrd, Ord, PartialEq, Eq)]\n pub struct TaskPath {\n     pub path: PathBuf,\n-    pub module: Option<String>,\n+    pub kind: Option<Kind>,\n }\n \n impl TaskPath {\n     pub fn parse(path: impl Into<PathBuf>) -> TaskPath {\n-        TaskPath { path: path.into(), module: None }\n+        let mut kind = None;\n+        let mut path = path.into();\n+\n+        let mut components = path.components();\n+        if let Some(Component::Normal(os_str)) = components.next() {\n+            if let Some(str) = os_str.to_str() {\n+                if let Some((found_kind, found_prefix)) = str.split_once(\"::\") {\n+                    if found_kind.is_empty() {\n+                        panic!(\"empty kind in task path {}\", path.display());\n+                    }\n+                    kind = Some(Kind::parse(found_kind));\n+                    path = Path::new(found_prefix).join(components.as_path());\n+                }\n+            }\n+        }\n+\n+        TaskPath { path, kind }\n+    }\n+}\n+\n+impl Debug for TaskPath {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        if let Some(kind) = &self.kind {\n+            write!(f, \"{}::\", kind.as_str())?;\n+        }\n+        write!(f, \"{}\", self.path.display())\n     }\n }\n \n@@ -142,16 +168,24 @@ impl PathSet {\n         PathSet::Set(BTreeSet::new())\n     }\n \n-    fn one<P: Into<PathBuf>>(path: P) -> PathSet {\n+    fn one<P: Into<PathBuf>>(path: P, kind: Kind) -> PathSet {\n         let mut set = BTreeSet::new();\n-        set.insert(TaskPath::parse(path));\n+        set.insert(TaskPath { path: path.into(), kind: Some(kind.into()) });\n         PathSet::Set(set)\n     }\n \n-    fn has(&self, needle: &Path) -> bool {\n+    fn has(&self, needle: &Path, module: Option<Kind>) -> bool {\n+        let check = |p: &TaskPath| {\n+            if let (Some(p_kind), Some(kind)) = (&p.kind, module) {\n+                p.path.ends_with(needle) && *p_kind == kind\n+            } else {\n+                p.path.ends_with(needle)\n+            }\n+        };\n+\n         match self {\n-            PathSet::Set(set) => set.iter().any(|p| p.path.ends_with(needle)),\n-            PathSet::Suite(suite) => suite.path.ends_with(needle),\n+            PathSet::Set(set) => set.iter().any(check),\n+            PathSet::Suite(suite) => check(suite),\n         }\n     }\n \n@@ -166,13 +200,14 @@ impl PathSet {\n }\n \n impl StepDescription {\n-    fn from<S: Step>() -> StepDescription {\n+    fn from<S: Step>(kind: Kind) -> StepDescription {\n         StepDescription {\n             default: S::DEFAULT,\n             only_hosts: S::ONLY_HOSTS,\n             should_run: S::should_run,\n             make_run: S::make_run,\n             name: std::any::type_name::<S>(),\n+            kind,\n         }\n     }\n \n@@ -191,7 +226,7 @@ impl StepDescription {\n     }\n \n     fn is_excluded(&self, builder: &Builder<'_>, pathset: &PathSet) -> bool {\n-        if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n+        if builder.config.exclude.iter().any(|e| pathset.has(&e.path, e.kind)) {\n             eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n             return true;\n         }\n@@ -206,8 +241,10 @@ impl StepDescription {\n     }\n \n     fn run(v: &[StepDescription], builder: &Builder<'_>, paths: &[PathBuf]) {\n-        let should_runs =\n-            v.iter().map(|desc| (desc.should_run)(ShouldRun::new(builder))).collect::<Vec<_>>();\n+        let should_runs = v\n+            .iter()\n+            .map(|desc| (desc.should_run)(ShouldRun::new(builder, desc.kind)))\n+            .collect::<Vec<_>>();\n \n         // sanity checks on rules\n         for (desc, should_run) in v.iter().zip(&should_runs) {\n@@ -240,7 +277,7 @@ impl StepDescription {\n                 if let Some(suite) = should_run.is_suite_path(path) {\n                     attempted_run = true;\n                     desc.maybe_run(builder, suite);\n-                } else if let Some(pathset) = should_run.pathset_for_path(path) {\n+                } else if let Some(pathset) = should_run.pathset_for_path(path, desc.kind) {\n                     attempted_run = true;\n                     desc.maybe_run(builder, pathset);\n                 }\n@@ -260,6 +297,8 @@ enum ReallyDefault<'a> {\n \n pub struct ShouldRun<'a> {\n     pub builder: &'a Builder<'a>,\n+    kind: Kind,\n+\n     // use a BTreeSet to maintain sort order\n     paths: BTreeSet<PathSet>,\n \n@@ -269,9 +308,10 @@ pub struct ShouldRun<'a> {\n }\n \n impl<'a> ShouldRun<'a> {\n-    fn new(builder: &'a Builder<'_>) -> ShouldRun<'a> {\n+    fn new(builder: &'a Builder<'_>, kind: Kind) -> ShouldRun<'a> {\n         ShouldRun {\n             builder,\n+            kind,\n             paths: BTreeSet::new(),\n             is_really_default: ReallyDefault::Bool(true), // by default no additional conditions\n         }\n@@ -307,7 +347,7 @@ impl<'a> ShouldRun<'a> {\n         let mut set = BTreeSet::new();\n         for krate in self.builder.in_tree_crates(name, None) {\n             let path = krate.local_path(self.builder);\n-            set.insert(TaskPath::parse(path));\n+            set.insert(TaskPath { path, kind: Some(self.kind) });\n         }\n         self.paths.insert(PathSet::Set(set));\n         self\n@@ -320,7 +360,7 @@ impl<'a> ShouldRun<'a> {\n     pub fn krate(mut self, name: &str) -> Self {\n         for krate in self.builder.in_tree_crates(name, None) {\n             let path = krate.local_path(self.builder);\n-            self.paths.insert(PathSet::one(path));\n+            self.paths.insert(PathSet::one(path, self.kind));\n         }\n         self\n     }\n@@ -332,7 +372,12 @@ impl<'a> ShouldRun<'a> {\n \n     // multiple aliases for the same job\n     pub fn paths(mut self, paths: &[&str]) -> Self {\n-        self.paths.insert(PathSet::Set(paths.iter().map(|p| TaskPath::parse(p)).collect()));\n+        self.paths.insert(PathSet::Set(\n+            paths\n+                .iter()\n+                .map(|p| TaskPath { path: p.into(), kind: Some(self.kind.into()) })\n+                .collect(),\n+        ));\n         self\n     }\n \n@@ -344,7 +389,8 @@ impl<'a> ShouldRun<'a> {\n     }\n \n     pub fn suite_path(mut self, suite: &str) -> Self {\n-        self.paths.insert(PathSet::Suite(TaskPath::parse(suite)));\n+        self.paths\n+            .insert(PathSet::Suite(TaskPath { path: suite.into(), kind: Some(self.kind.into()) }));\n         self\n     }\n \n@@ -354,12 +400,12 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    fn pathset_for_path(&self, path: &Path) -> Option<&PathSet> {\n-        self.paths.iter().find(|pathset| pathset.has(path))\n+    fn pathset_for_path(&self, path: &Path, kind: Kind) -> Option<&PathSet> {\n+        self.paths.iter().find(|pathset| pathset.has(path, Some(kind)))\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub enum Kind {\n     Build,\n     Check,\n@@ -373,11 +419,44 @@ pub enum Kind {\n     Run,\n }\n \n+impl Kind {\n+    fn parse(string: &str) -> Kind {\n+        match string {\n+            \"build\" => Kind::Build,\n+            \"check\" => Kind::Check,\n+            \"clippy\" => Kind::Clippy,\n+            \"fix\" => Kind::Fix,\n+            \"test\" => Kind::Test,\n+            \"bench\" => Kind::Bench,\n+            \"dist\" => Kind::Dist,\n+            \"doc\" => Kind::Doc,\n+            \"install\" => Kind::Install,\n+            \"run\" => Kind::Run,\n+            other => panic!(\"unknown kind: {}\", other),\n+        }\n+    }\n+\n+    fn as_str(&self) -> &'static str {\n+        match self {\n+            Kind::Build => \"build\",\n+            Kind::Check => \"check\",\n+            Kind::Clippy => \"clippy\",\n+            Kind::Fix => \"fix\",\n+            Kind::Test => \"test\",\n+            Kind::Bench => \"bench\",\n+            Kind::Dist => \"dist\",\n+            Kind::Doc => \"doc\",\n+            Kind::Install => \"install\",\n+            Kind::Run => \"run\",\n+        }\n+    }\n+}\n+\n impl<'a> Builder<'a> {\n     fn get_step_descriptions(kind: Kind) -> Vec<StepDescription> {\n         macro_rules! describe {\n             ($($rule:ty),+ $(,)?) => {{\n-                vec![$(StepDescription::from::<$rule>()),+]\n+                vec![$(StepDescription::from::<$rule>(kind)),+]\n             }};\n         }\n         match kind {\n@@ -554,8 +633,11 @@ impl<'a> Builder<'a> {\n \n         let builder = Self::new_internal(build, kind, vec![]);\n         let builder = &builder;\n-        let mut should_run = ShouldRun::new(builder);\n+        // The \"build\" kind here is just a placeholder, it will be replaced with something else in\n+        // the following statement.\n+        let mut should_run = ShouldRun::new(builder, Kind::Build);\n         for desc in Builder::get_step_descriptions(builder.kind) {\n+            should_run.kind = desc.kind;\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n@@ -1640,9 +1722,10 @@ impl<'a> Builder<'a> {\n     pub(crate) fn ensure_if_default<T, S: Step<Output = Option<T>>>(\n         &'a self,\n         step: S,\n+        kind: Kind,\n     ) -> S::Output {\n-        let desc = StepDescription::from::<S>();\n-        let should_run = (desc.should_run)(ShouldRun::new(self));\n+        let desc = StepDescription::from::<S>(kind);\n+        let should_run = (desc.should_run)(ShouldRun::new(self, desc.kind));\n \n         // Avoid running steps contained in --exclude\n         for pathset in &should_run.paths {\n@@ -1656,13 +1739,16 @@ impl<'a> Builder<'a> {\n     }\n \n     /// Checks if any of the \"should_run\" paths is in the `Builder` paths.\n-    pub(crate) fn was_invoked_explicitly<S: Step>(&'a self) -> bool {\n-        let desc = StepDescription::from::<S>();\n-        let should_run = (desc.should_run)(ShouldRun::new(self));\n+    pub(crate) fn was_invoked_explicitly<S: Step>(&'a self, kind: Kind) -> bool {\n+        let desc = StepDescription::from::<S>(kind);\n+        let should_run = (desc.should_run)(ShouldRun::new(self, desc.kind));\n \n         for path in &self.paths {\n-            if should_run.paths.iter().any(|s| s.has(path))\n-                && !desc.is_excluded(self, &PathSet::Suite(TaskPath::parse(path)))\n+            if should_run.paths.iter().any(|s| s.has(path, Some(desc.kind)))\n+                && !desc.is_excluded(\n+                    self,\n+                    &PathSet::Suite(TaskPath { path: path.clone(), kind: Some(desc.kind.into()) }),\n+                )\n             {\n                 return true;\n             }"}, {"sha": "bc71034496968ff3fad5a502309b39e65ae72408", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "patch": "@@ -499,7 +499,7 @@ mod dist {\n         let host = TargetSelection::from_user(\"A\");\n \n         builder.run_step_descriptions(\n-            &[StepDescription::from::<test::Crate>()],\n+            &[StepDescription::from::<test::Crate>(Kind::Test)],\n             &[\"library/std\".into()],\n         );\n \n@@ -520,7 +520,7 @@ mod dist {\n     #[test]\n     fn test_exclude() {\n         let mut config = configure(&[\"A\"], &[\"A\"]);\n-        config.exclude = vec![\"src/tools/tidy\".into()];\n+        config.exclude = vec![TaskPath::parse(\"src/tools/tidy\")];\n         config.cmd = Subcommand::Test {\n             paths: Vec::new(),\n             test_args: Vec::new(),"}, {"sha": "683cfc630e7715f6a8bfef208a3c5f8cd37f0833", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "patch": "@@ -12,6 +12,7 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n+use crate::builder::TaskPath;\n use crate::cache::{Interned, INTERNER};\n use crate::channel::GitInfo;\n pub use crate::flags::Subcommand;\n@@ -62,7 +63,7 @@ pub struct Config {\n     pub sanitizers: bool,\n     pub profiler: bool,\n     pub ignore_git: bool,\n-    pub exclude: Vec<PathBuf>,\n+    pub exclude: Vec<TaskPath>,\n     pub include_default_paths: bool,\n     pub rustc_error_format: Option<String>,\n     pub json_output: bool,\n@@ -635,7 +636,7 @@ impl Config {\n         let flags = Flags::parse(&args);\n \n         let mut config = Config::default_opts();\n-        config.exclude = flags.exclude;\n+        config.exclude = flags.exclude.into_iter().map(|path| TaskPath::parse(path)).collect();\n         config.include_default_paths = flags.include_default_paths;\n         config.rustc_error_format = flags.rustc_error_format;\n         config.json_output = flags.json_output;"}, {"sha": "66b63cd1278c525f98649b45c697b41b79321989", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "patch": "@@ -16,7 +16,7 @@ use std::process::Command;\n \n use build_helper::{output, t};\n \n-use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n use crate::config::TargetSelection;\n@@ -1368,7 +1368,7 @@ impl Step for Extended {\n         let mut built_tools = HashSet::new();\n         macro_rules! add_component {\n             ($name:expr => $step:expr) => {\n-                if let Some(tarball) = builder.ensure_if_default($step) {\n+                if let Some(tarball) = builder.ensure_if_default($step, Kind::Dist) {\n                     tarballs.push(tarball);\n                     built_tools.insert($name);\n                 }"}, {"sha": "23b5ddcd47a0ecbc02ac7760e652684726b5b8cc", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ad40532db231cd3ca55bc37047aa50fb1a1a71/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=b3ad40532db231cd3ca55bc37047aa50fb1a1a71", "patch": "@@ -15,7 +15,7 @@ use std::path::{Path, PathBuf};\n use crate::Mode;\n use build_helper::{t, up_to_date};\n \n-use crate::builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n+use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n use crate::config::{Config, TargetSelection};\n@@ -240,7 +240,7 @@ impl Step for TheBook {\n             invoke_rustdoc(builder, compiler, target, path);\n         }\n \n-        if builder.was_invoked_explicitly::<Self>() {\n+        if builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n             let out = builder.doc_out(target);\n             let index = out.join(\"book\").join(\"index.html\");\n             open(builder, &index);\n@@ -400,7 +400,7 @@ impl Step for Standalone {\n \n         // We open doc/index.html as the default if invoked as `x.py doc --open`\n         // with no particular explicit doc requested (e.g. library/core).\n-        if builder.paths.is_empty() || builder.was_invoked_explicitly::<Self>() {\n+        if builder.paths.is_empty() || builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n             let index = out.join(\"index.html\");\n             open(builder, &index);\n         }\n@@ -902,7 +902,7 @@ impl Step for RustcBook {\n             name: INTERNER.intern_str(\"rustc\"),\n             src: INTERNER.intern_path(out_base),\n         });\n-        if builder.was_invoked_explicitly::<Self>() {\n+        if builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n             let out = builder.doc_out(self.target);\n             let index = out.join(\"rustc\").join(\"index.html\");\n             open(builder, &index);"}]}