{"sha": "0adb3c051805998ab8cabb7654208141ae433ce0", "node_id": "C_kwDOAAsO6NoAKDBhZGIzYzA1MTgwNTk5OGFiOGNhYmI3NjU0MjA4MTQxYWU0MzNjZTA", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-01T03:39:00Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:51:29Z"}, "message": "Move `EqOp` into `Operators` lint pass", "tree": {"sha": "d55ff3522d6f582ba1f3fd8eafb6a1e4f35b5abe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d55ff3522d6f582ba1f3fd8eafb6a1e4f35b5abe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0adb3c051805998ab8cabb7654208141ae433ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0adb3c051805998ab8cabb7654208141ae433ce0", "html_url": "https://github.com/rust-lang/rust/commit/0adb3c051805998ab8cabb7654208141ae433ce0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0adb3c051805998ab8cabb7654208141ae433ce0/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "732d7162ab065c2b399d2a1aec7a8d5794f893d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/732d7162ab065c2b399d2a1aec7a8d5794f893d6", "html_url": "https://github.com/rust-lang/rust/commit/732d7162ab065c2b399d2a1aec7a8d5794f893d6"}], "stats": {"total": 699, "additions": 344, "deletions": 355}, "files": [{"sha": "2f4c90d07cf666c9dede8ea2bbba5b1bddeaf5f2", "filename": "clippy_lints/src/eq_op.rs", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/732d7162ab065c2b399d2a1aec7a8d5794f893d6/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732d7162ab065c2b399d2a1aec7a8d5794f893d6/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=732d7162ab065c2b399d2a1aec7a8d5794f893d6", "patch": "@@ -1,319 +0,0 @@\n-use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n-use clippy_utils::get_enclosing_block;\n-use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n-use clippy_utils::source::snippet;\n-use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for equal operands to comparison, logical and\n-    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n-    /// `||`, `&`, `|`, `^`, `-` and `/`).\n-    ///\n-    /// ### Why is this bad?\n-    /// This is usually just a typo or a copy and paste error.\n-    ///\n-    /// ### Known problems\n-    /// False negatives: We had some false positives regarding\n-    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n-    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n-    /// calls. We may introduce a list of known pure functions in the future.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if x + 1 == x + 1 {}\n-    ///\n-    /// // or\n-    ///\n-    /// # let a = 3;\n-    /// # let b = 4;\n-    /// assert_eq!(a, a);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub EQ_OP,\n-    correctness,\n-    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for arguments to `==` which have their address\n-    /// taken to satisfy a bound\n-    /// and suggests to dereference the other argument instead\n-    ///\n-    /// ### Why is this bad?\n-    /// It is more idiomatic to dereference the other argument.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// &x == y\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// x == *y\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub OP_REF,\n-    style,\n-    \"taking a reference to satisfy the type constraints on `==`\"\n-}\n-\n-declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n-\n-impl<'tcx> LateLintPass<'tcx> for EqOp {\n-    #[expect(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let Some((macro_call, macro_name)) = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n-                let name = cx.tcx.item_name(macro_call.def_id);\n-                matches!(name.as_str(), \"assert_eq\" | \"assert_ne\" | \"debug_assert_eq\" | \"debug_assert_ne\")\n-                    .then(|| (macro_call, name))\n-            });\n-            if let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn);\n-            if eq_expr_value(cx, lhs, rhs);\n-            if macro_call.is_local();\n-            if !is_in_test_function(cx.tcx, e.hir_id);\n-            then {\n-                span_lint(\n-                    cx,\n-                    EQ_OP,\n-                    lhs.span.to(rhs.span),\n-                    &format!(\"identical args used in this `{}!` macro call\", macro_name),\n-                );\n-            }\n-        }\n-        if let ExprKind::Binary(op, left, right) = e.kind {\n-            if e.span.from_expansion() {\n-                return;\n-            }\n-            let macro_with_not_op = |expr_kind: &ExprKind<'_>| {\n-                if let ExprKind::Unary(_, expr) = *expr_kind {\n-                    expr.span.from_expansion()\n-                } else {\n-                    false\n-                }\n-            };\n-            if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n-                return;\n-            }\n-            if is_useless_with_eq_exprs(op.node.into())\n-                && eq_expr_value(cx, left, right)\n-                && !is_in_test_function(cx.tcx, e.hir_id)\n-            {\n-                span_lint(\n-                    cx,\n-                    EQ_OP,\n-                    e.span,\n-                    &format!(\"equal expressions as operands to `{}`\", op.node.as_str()),\n-                );\n-                return;\n-            }\n-            let (trait_id, requires_ref) = match op.node {\n-                BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n-                BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n-                BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n-                BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n-                BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n-                // don't lint short circuiting ops\n-                BinOpKind::And | BinOpKind::Or => return,\n-                BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n-                BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n-                BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n-                BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n-                BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n-                BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n-                BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => {\n-                    (cx.tcx.lang_items().partial_ord_trait(), true)\n-                },\n-            };\n-            if let Some(trait_id) = trait_id {\n-                match (&left.kind, &right.kind) {\n-                    // do not suggest to dereference literals\n-                    (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n-                    // &foo == &bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n-                        let lty = cx.typeck_results().expr_ty(l);\n-                        let rty = cx.typeck_results().expr_ty(r);\n-                        let lcpy = is_copy(cx, lty);\n-                        let rcpy = is_copy(cx, rty);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        // either operator autorefs or both args are copyable\n-                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of both operands\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                    multispan_sugg(\n-                                        diag,\n-                                        \"use the values directly\",\n-                                        vec![(left.span, lsnip), (right.span, rsnip)],\n-                                    );\n-                                },\n-                            );\n-                        } else if lcpy\n-                            && !rcpy\n-                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of left operand\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        left.span,\n-                                        \"use the left value directly\",\n-                                        lsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        } else if !lcpy\n-                            && rcpy\n-                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of right operand\",\n-                                |diag| {\n-                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        right.span,\n-                                        \"use the right value directly\",\n-                                        rsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        }\n-                    },\n-                    // &foo == bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n-                        let lty = cx.typeck_results().expr_ty(l);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            let rty = cx.typeck_results().expr_ty(right);\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        let lcpy = is_copy(cx, lty);\n-                        if (requires_ref || lcpy)\n-                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of left operand\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        left.span,\n-                                        \"use the left value directly\",\n-                                        lsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        }\n-                    },\n-                    // foo == &bar\n-                    (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n-                        let rty = cx.typeck_results().expr_ty(r);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            let lty = cx.typeck_results().expr_ty(left);\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        let rcpy = is_copy(cx, rty);\n-                        if (requires_ref || rcpy)\n-                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n-                        {\n-                            span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n-                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                diag.span_suggestion(\n-                                    right.span,\n-                                    \"use the right value directly\",\n-                                    rsnip,\n-                                    Applicability::MaybeIncorrect, // FIXME #2597\n-                                );\n-                            });\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn in_impl<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    e: &'tcx Expr<'_>,\n-    bin_op: DefId,\n-) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n-    if_chain! {\n-        if let Some(block) = get_enclosing_block(cx, e.hir_id);\n-        if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n-        let item = cx.tcx.hir().expect_item(impl_def_id.expect_local());\n-        if let ItemKind::Impl(item) = &item.kind;\n-        if let Some(of_trait) = &item.of_trait;\n-        if let Some(seg) = of_trait.path.segments.last();\n-        if let Some(Res::Def(_, trait_id)) = seg.res;\n-        if trait_id == bin_op;\n-        if let Some(generic_args) = seg.args;\n-        if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();\n-\n-        then {\n-            Some((item.self_ty, other_ty))\n-        }\n-        else {\n-            None\n-        }\n-    }\n-}\n-\n-fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let ty::Adt(adt_def, _) = middle_ty.kind();\n-        if let Some(local_did) = adt_def.did().as_local();\n-        let item = cx.tcx.hir().expect_item(local_did);\n-        let middle_ty_id = item.def_id.to_def_id();\n-        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n-        if let Res::Def(_, hir_ty_id) = path.res;\n-\n-        then {\n-            hir_ty_id == middle_ty_id\n-        }\n-        else {\n-            false\n-        }\n-    }\n-}"}, {"sha": "634d7f1f69fce7bc0f4f5cd1a49ae66687e54e78", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -61,8 +61,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n     LintId::of(enum_variants::MODULE_INCEPTION),\n-    LintId::of(eq_op::EQ_OP),\n-    LintId::of(eq_op::OP_REF),\n     LintId::of(erasing_op::ERASING_OP),\n     LintId::of(escape::BOXED_LOCAL),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n@@ -258,8 +256,10 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(operators::BAD_BIT_MASK),\n     LintId::of(operators::DOUBLE_COMPARISONS),\n     LintId::of(operators::DURATION_SUBSEC),\n+    LintId::of(operators::EQ_OP),\n     LintId::of(operators::INEFFECTIVE_BIT_MASK),\n     LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n+    LintId::of(operators::OP_REF),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),"}, {"sha": "2b81eee132668f55bb2786cfbf607a16590b7a2c", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -21,7 +21,6 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(drop_forget_ref::FORGET_REF),\n     LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n-    LintId::of(eq_op::EQ_OP),\n     LintId::of(erasing_op::ERASING_OP),\n     LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n@@ -50,6 +49,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(operators::BAD_BIT_MASK),\n+    LintId::of(operators::EQ_OP),\n     LintId::of(operators::INEFFECTIVE_BIT_MASK),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),"}, {"sha": "8b1bb440f084711eddd3a410a1758db135f5fccb", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -140,8 +140,6 @@ store.register_lints(&[\n     enum_variants::ENUM_VARIANT_NAMES,\n     enum_variants::MODULE_INCEPTION,\n     enum_variants::MODULE_NAME_REPETITIONS,\n-    eq_op::EQ_OP,\n-    eq_op::OP_REF,\n     equatable_if_let::EQUATABLE_IF_LET,\n     erasing_op::ERASING_OP,\n     escape::BOXED_LOCAL,\n@@ -432,10 +430,12 @@ store.register_lints(&[\n     operators::BAD_BIT_MASK,\n     operators::DOUBLE_COMPARISONS,\n     operators::DURATION_SUBSEC,\n+    operators::EQ_OP,\n     operators::FLOAT_ARITHMETIC,\n     operators::INEFFECTIVE_BIT_MASK,\n     operators::INTEGER_ARITHMETIC,\n     operators::MISREFACTORED_ASSIGN_OP,\n+    operators::OP_REF,\n     operators::VERBOSE_BIT_MASK,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,"}, {"sha": "a438577d9927d0963d095bc5e289861eef7f1f9a", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -22,7 +22,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n     LintId::of(enum_variants::MODULE_INCEPTION),\n-    LintId::of(eq_op::OP_REF),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n     LintId::of(from_over_into::FROM_OVER_INTO),\n@@ -98,6 +97,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(operators::ASSIGN_OP_PATTERN),\n+    LintId::of(operators::OP_REF),\n     LintId::of(ptr::CMP_NULL),\n     LintId::of(ptr::PTR_ARG),\n     LintId::of(ptr_eq::PTR_EQ),"}, {"sha": "f042d7547c26b720a0455ee1be0447df83a4ce38", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -219,7 +219,6 @@ mod empty_structs_with_brackets;\n mod entry;\n mod enum_clike;\n mod enum_variants;\n-mod eq_op;\n mod equatable_if_let;\n mod erasing_op;\n mod escape;\n@@ -576,7 +575,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     store.register_late_pass(|| Box::new(booleans::NonminimalBool));\n     store.register_late_pass(|| Box::new(needless_bitwise_bool::NeedlessBitwiseBool));\n-    store.register_late_pass(|| Box::new(eq_op::EqOp));\n     store.register_late_pass(|| Box::new(enum_clike::UnportableVariant));\n     store.register_late_pass(|| Box::new(float_literal::FloatLiteral));\n     store.register_late_pass(|| Box::new(ptr::Ptr));"}, {"sha": "44cf0bb06120aba79134dba1ee969294fcdb1e58", "filename": "clippy_lints/src/operators/eq_op.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Foperators%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Foperators%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Feq_op.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -0,0 +1,45 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n+use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+\n+use super::EQ_OP;\n+\n+pub(crate) fn check_assert<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+    if let Some((macro_call, macro_name))\n+        = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n+            let name = cx.tcx.item_name(macro_call.def_id);\n+            matches!(name.as_str(), \"assert_eq\" | \"assert_ne\" | \"debug_assert_eq\" | \"debug_assert_ne\")\n+                .then(|| (macro_call, name))\n+        })\n+        && let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn)\n+        && eq_expr_value(cx, lhs, rhs)\n+        && macro_call.is_local()\n+        && !is_in_test_function(cx.tcx, e.hir_id)\n+    {\n+        span_lint(\n+            cx,\n+            EQ_OP,\n+            lhs.span.to(rhs.span),\n+            &format!(\"identical args used in this `{}!` macro call\", macro_name),\n+        );\n+    }\n+}\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if is_useless_with_eq_exprs(op.into()) && eq_expr_value(cx, left, right) && !is_in_test_function(cx.tcx, e.hir_id) {\n+        span_lint(\n+            cx,\n+            EQ_OP,\n+            e.span,\n+            &format!(\"equal expressions as operands to `{}`\", op.as_str()),\n+        );\n+    }\n+}"}, {"sha": "fd8b55beaed4d1318bd582b5f36853db4c6b2a6d", "filename": "clippy_lints/src/operators/mod.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -7,8 +7,10 @@ mod assign_op_pattern;\n mod bit_mask;\n mod double_comparison;\n mod duration_subsec;\n+mod eq_op;\n mod misrefactored_assign_op;\n mod numeric_arithmetic;\n+mod op_ref;\n mod verbose_bit_mask;\n \n declare_clippy_lint! {\n@@ -302,6 +304,62 @@ declare_clippy_lint! {\n     \"checks for calculation of subsecond microseconds or milliseconds\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for equal operands to comparison, logical and\n+    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+    /// `||`, `&`, `|`, `^`, `-` and `/`).\n+    ///\n+    /// ### Why is this bad?\n+    /// This is usually just a typo or a copy and paste error.\n+    ///\n+    /// ### Known problems\n+    /// False negatives: We had some false positives regarding\n+    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n+    /// calls. We may introduce a list of known pure functions in the future.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if x + 1 == x + 1 {}\n+    ///\n+    /// // or\n+    ///\n+    /// # let a = 3;\n+    /// # let b = 4;\n+    /// assert_eq!(a, a);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub EQ_OP,\n+    correctness,\n+    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arguments to `==` which have their address\n+    /// taken to satisfy a bound\n+    /// and suggests to dereference the other argument instead\n+    ///\n+    /// ### Why is this bad?\n+    /// It is more idiomatic to dereference the other argument.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// &x == y\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// x == *y\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub OP_REF,\n+    style,\n+    \"taking a reference to satisfy the type constraints on `==`\"\n+}\n+\n pub struct Operators {\n     arithmetic_context: numeric_arithmetic::Context,\n     verbose_bit_mask_threshold: u64,\n@@ -317,6 +375,8 @@ impl_lint_pass!(Operators => [\n     VERBOSE_BIT_MASK,\n     DOUBLE_COMPARISONS,\n     DURATION_SUBSEC,\n+    EQ_OP,\n+    OP_REF,\n ]);\n impl Operators {\n     pub fn new(verbose_bit_mask_threshold: u64) -> Self {\n@@ -328,10 +388,15 @@ impl Operators {\n }\n impl<'tcx> LateLintPass<'tcx> for Operators {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        eq_op::check_assert(cx, e);\n         match e.kind {\n             ExprKind::Binary(op, lhs, rhs) => {\n                 if !e.span.from_expansion() {\n                     absurd_extreme_comparisons::check(cx, e, op.node, lhs, rhs);\n+                    if !(macro_with_not_op(lhs) || macro_with_not_op(rhs)) {\n+                        eq_op::check(cx, e, op.node, lhs, rhs);\n+                        op_ref::check(cx, e, op.node, lhs, rhs);\n+                    }\n                 }\n                 self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);\n                 bit_mask::check(cx, e, op.node, lhs, rhs);\n@@ -367,3 +432,11 @@ impl<'tcx> LateLintPass<'tcx> for Operators {\n         self.arithmetic_context.body_post(cx, b);\n     }\n }\n+\n+fn macro_with_not_op(e: &Expr<'_>) -> bool {\n+    if let ExprKind::Unary(_, e) = e.kind {\n+        e.span.from_expansion()\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "1805672e372544d8b34e64548fd7118a67e3c8b9", "filename": "clippy_lints/src/operators/op_ref.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -0,0 +1,218 @@\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::get_enclosing_block;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::{implements_trait, is_copy};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::OP_REF;\n+\n+#[expect(clippy::similar_names, clippy::too_many_lines)]\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    let (trait_id, requires_ref) = match op {\n+        BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n+        BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n+        BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n+        BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n+        BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n+        // don't lint short circuiting ops\n+        BinOpKind::And | BinOpKind::Or => return,\n+        BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n+        BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n+        BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n+        BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n+        BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n+        BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n+        BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => {\n+            (cx.tcx.lang_items().partial_ord_trait(), true)\n+        },\n+    };\n+    if let Some(trait_id) = trait_id {\n+        match (&left.kind, &right.kind) {\n+            // do not suggest to dereference literals\n+            (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n+            // &foo == &bar\n+            (&ExprKind::AddrOf(BorrowKind::Ref, _, l), &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n+                let lty = cx.typeck_results().expr_ty(l);\n+                let rty = cx.typeck_results().expr_ty(r);\n+                let lcpy = is_copy(cx, lty);\n+                let rcpy = is_copy(cx, rty);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                // either operator autorefs or both args are copyable\n+                if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of both operands\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                            multispan_sugg(\n+                                diag,\n+                                \"use the values directly\",\n+                                vec![(left.span, lsnip), (right.span, rsnip)],\n+                            );\n+                        },\n+                    );\n+                } else if lcpy\n+                    && !rcpy\n+                    && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of left operand\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                left.span,\n+                                \"use the left value directly\",\n+                                lsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                } else if !lcpy\n+                    && rcpy\n+                    && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of right operand\",\n+                        |diag| {\n+                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                right.span,\n+                                \"use the right value directly\",\n+                                rsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            // &foo == bar\n+            (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n+                let lty = cx.typeck_results().expr_ty(l);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    let rty = cx.typeck_results().expr_ty(right);\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                let lcpy = is_copy(cx, lty);\n+                if (requires_ref || lcpy)\n+                    && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of left operand\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                left.span,\n+                                \"use the left value directly\",\n+                                lsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            // foo == &bar\n+            (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n+                let rty = cx.typeck_results().expr_ty(r);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    let lty = cx.typeck_results().expr_ty(left);\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                let rcpy = is_copy(cx, rty);\n+                if (requires_ref || rcpy)\n+                    && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n+                {\n+                    span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n+                        let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                        diag.span_suggestion(\n+                            right.span,\n+                            \"use the right value directly\",\n+                            rsnip,\n+                            Applicability::MaybeIncorrect, // FIXME #2597\n+                        );\n+                    });\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn in_impl<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    bin_op: DefId,\n+) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n+    if_chain! {\n+        if let Some(block) = get_enclosing_block(cx, e.hir_id);\n+        if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n+        let item = cx.tcx.hir().expect_item(impl_def_id.expect_local());\n+        if let ItemKind::Impl(item) = &item.kind;\n+        if let Some(of_trait) = &item.of_trait;\n+        if let Some(seg) = of_trait.path.segments.last();\n+        if let Some(Res::Def(_, trait_id)) = seg.res;\n+        if trait_id == bin_op;\n+        if let Some(generic_args) = seg.args;\n+        if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();\n+\n+        then {\n+            Some((item.self_ty, other_ty))\n+        }\n+        else {\n+            None\n+        }\n+    }\n+}\n+\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let ty::Adt(adt_def, _) = middle_ty.kind();\n+        if let Some(local_did) = adt_def.did().as_local();\n+        let item = cx.tcx.hir().expect_item(local_did);\n+        let middle_ty_id = item.def_id.to_def_id();\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+        if let Res::Def(_, hir_ty_id) = path.res;\n+\n+        then {\n+            hir_ty_id == middle_ty_id\n+        }\n+        else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "968c58f40aefa27f3518a66017eb785da09c8129", "filename": "tests/ui/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/tests%2Fui%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/tests%2Fui%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fzero_div_zero.rs?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -1,4 +1,4 @@\n-#[allow(unused_variables)]\n+#[allow(unused_variables, clippy::eq_op)]\n #[warn(clippy::zero_divided_by_zero)]\n fn main() {\n     let nan = 0.0 / 0.0;"}, {"sha": "86563542e0602ef7da031d962fab44ba042d9920", "filename": "tests/ui/zero_div_zero.stderr", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0adb3c051805998ab8cabb7654208141ae433ce0/tests%2Fui%2Fzero_div_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0adb3c051805998ab8cabb7654208141ae433ce0/tests%2Fui%2Fzero_div_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fzero_div_zero.stderr?ref=0adb3c051805998ab8cabb7654208141ae433ce0", "patch": "@@ -1,11 +1,3 @@\n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:4:15\n-   |\n-LL |     let nan = 0.0 / 0.0;\n-   |               ^^^^^^^^^\n-   |\n-   = note: `#[deny(clippy::eq_op)]` on by default\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:4:15\n    |\n@@ -15,12 +7,6 @@ LL |     let nan = 0.0 / 0.0;\n    = note: `-D clippy::zero-divided-by-zero` implied by `-D warnings`\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:5:19\n-   |\n-LL |     let f64_nan = 0.0 / 0.0f64;\n-   |                   ^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:5:19\n    |\n@@ -29,12 +15,6 @@ LL |     let f64_nan = 0.0 / 0.0f64;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:6:25\n-   |\n-LL |     let other_f64_nan = 0.0f64 / 0.0;\n-   |                         ^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:6:25\n    |\n@@ -43,12 +23,6 @@ LL |     let other_f64_nan = 0.0f64 / 0.0;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:7:28\n-   |\n-LL |     let one_more_f64_nan = 0.0f64 / 0.0f64;\n-   |                            ^^^^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:7:28\n    |\n@@ -57,5 +31,5 @@ LL |     let one_more_f64_nan = 0.0f64 / 0.0f64;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 4 previous errors\n "}]}