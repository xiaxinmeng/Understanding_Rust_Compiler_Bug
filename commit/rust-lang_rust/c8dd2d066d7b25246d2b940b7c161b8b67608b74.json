{"sha": "c8dd2d066d7b25246d2b940b7c161b8b67608b74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZGQyZDA2NmQ3YjI1MjQ2ZDJiOTQwYjdjMTYxYjhiNjc2MDhiNzQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-02-19T13:36:58Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-02-19T23:58:15Z"}, "message": "Addressed PR comments", "tree": {"sha": "7b6c4fecc16df3ccfc388d16b46011be49a864ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b6c4fecc16df3ccfc388d16b46011be49a864ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8dd2d066d7b25246d2b940b7c161b8b67608b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8dd2d066d7b25246d2b940b7c161b8b67608b74", "html_url": "https://github.com/rust-lang/rust/commit/c8dd2d066d7b25246d2b940b7c161b8b67608b74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8dd2d066d7b25246d2b940b7c161b8b67608b74/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a641996796f0ab11021671c0ce70a3c975bb4e37", "url": "https://api.github.com/repos/rust-lang/rust/commits/a641996796f0ab11021671c0ce70a3c975bb4e37", "html_url": "https://github.com/rust-lang/rust/commit/a641996796f0ab11021671c0ce70a3c975bb4e37"}], "stats": {"total": 319, "additions": 233, "deletions": 86}, "files": [{"sha": "278ce5565d9fc38d8ce9bec899e5fcf3109d0ab1", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -23,7 +23,7 @@\n #![feature(env)]\n #![feature(core)]\n \n-// #![deny(warnings)]\n+#![deny(warnings)]\n \n extern crate test;\n extern crate getopts;"}, {"sha": "7411a9b48d417e70936dcacfad51c6b10822a5ee", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -58,7 +58,7 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n fn parse_expected(last_nonfollow_error: Option<uint>,\n                   line_num: uint,\n                   line: &str) -> Option<(WhichLine, ExpectedError)> {\n-    let start = match line.find_str(\"//~\") { Some(i) => i, None => return None };\n+    let start = match line.find(\"//~\") { Some(i) => i, None => return None };\n     let (follow, adjusts) = if line.char_at(start + 3) == '|' {\n         (true, 0)\n     } else {"}, {"sha": "9c217651c3edcc1b429b040d6e0b4219ede5983d", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -330,7 +330,7 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n pub fn parse_name_value_directive(line: &str, directive: &str)\n                                   -> Option<String> {\n     let keycolon = format!(\"{}:\", directive);\n-    match line.find_str(&keycolon) {\n+    match line.find(&keycolon) {\n         Some(colon) => {\n             let value = line[(colon + keycolon.len()) .. line.len()].to_string();\n             debug!(\"{}: {}\", directive, value);"}, {"sha": "39ecc323125b734b19b3ad43882cddc9dba1b1c3", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -847,7 +847,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             check_lines.iter().map(|s| {\n                 s\n                  .trim()\n-                 .split_str(\"[...]\")\n+                 .split(\"[...]\")\n                  .map(|x| x.to_string())\n                  .collect()\n             }).collect();\n@@ -866,7 +866,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                         None\n                     }\n                 } else {\n-                    rest.find_str(frag)\n+                    rest.find(frag)\n                 };\n                 match found {\n                     None => {"}, {"sha": "92dc01dc3e4e432c11c682f076433f59735904bd", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -547,8 +547,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```rust\n     /// assert!(\"hello\".contains_char('e'));\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might get removed in favour of a more generic contains()\")]\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `contains()` with a char\")]\n     fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::contains_char(&self[..], pat)\n     }\n@@ -660,7 +660,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    #[unstable(feature = \"collections\", reason = \"might get removed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n         core_str::StrExt::split_terminator(&self[..], pat)\n     }\n@@ -708,6 +708,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n+    // NB: Right now MatchIndices yields `(usize, usize)`,\n+    // but it would be more consistent and useful to return `(usize, &str)`\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n@@ -723,8 +725,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might get removed in the future in favor of a more generic split()\")]\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `split()` with a `&str`\")]\n     fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n         core_str::StrExt::split_str(&self[..], pat)\n     }\n@@ -840,7 +842,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-    where P::Searcher: ReverseSearcher<'a> {\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::ends_with(&self[..], pat)\n     }\n \n@@ -861,7 +864,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-    where P::Searcher: DoubleEndedSearcher<'a> {\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n         core_str::StrExt::trim_matches(&self[..], pat)\n     }\n \n@@ -902,7 +906,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-    where P::Searcher: ReverseSearcher<'a> {\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n@@ -1108,7 +1113,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-    where P::Searcher: ReverseSearcher<'a> {\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::rfind(&self[..], pat)\n     }\n \n@@ -1131,8 +1137,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n     /// assert_eq!(s.find_str(\"muffin man\"), None);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might get removed in favor of a more generic find in the future\")]\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `find()` with a `&str`\")]\n     fn find_str<'a, P: Pattern<'a>>(&'a self, needle: P) -> Option<usize> {\n         core_str::StrExt::find_str(&self[..], needle)\n     }"}, {"sha": "7e51f8e8503b411e4c62ba740aff3d23a0e112a7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -242,8 +242,10 @@ pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n }\n \n /// Something that can be used to compare against a character\n-#[unstable(feature = \"core\",\n-           reason = \"definition may change as pattern-related methods are stabilized\")]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use `Pattern` instead\")]\n+// NB: Rather than removing it, make it private and move it into self::pattern\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n     fn matches(&mut self, char) -> bool;\n@@ -252,6 +254,7 @@ pub trait CharEq {\n     fn only_ascii(&self) -> bool;\n }\n \n+#[allow(deprecated) /* for CharEq */ ]\n impl CharEq for char {\n     #[inline]\n     fn matches(&mut self, c: char) -> bool { *self == c }\n@@ -260,6 +263,7 @@ impl CharEq for char {\n     fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n }\n \n+#[allow(deprecated) /* for CharEq */ ]\n impl<F> CharEq for F where F: FnMut(char) -> bool {\n     #[inline]\n     fn matches(&mut self, c: char) -> bool { (*self)(c) }\n@@ -268,13 +272,16 @@ impl<F> CharEq for F where F: FnMut(char) -> bool {\n     fn only_ascii(&self) -> bool { false }\n }\n \n+#[allow(deprecated) /* for CharEq */ ]\n impl<'a> CharEq for &'a [char] {\n     #[inline]\n+    #[allow(deprecated) /* for CharEq */ ]\n     fn matches(&mut self, c: char) -> bool {\n         self.iter().any(|&m| { let mut m = m; m.matches(c) })\n     }\n \n     #[inline]\n+    #[allow(deprecated) /* for CharEq */ ]\n     fn only_ascii(&self) -> bool {\n         self.iter().all(|m| m.only_ascii())\n     }\n@@ -764,7 +771,7 @@ impl TwoWaySearcher {\n     // that (u, v) is a critical factorization for the needle.\n     #[inline]\n     fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n-    -> Option<(usize, usize)> {\n+            -> Option<(usize, usize)> {\n         'search: loop {\n             // Check that we have room to search in\n             if self.position + needle.len() > haystack.len() {\n@@ -866,6 +873,8 @@ impl TwoWaySearcher {\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using a dynamically chosen search algorithm\n #[derive(Clone)]\n+// NB: This is kept around for convenience because\n+// it is planned to be used again in the future\n enum OldSearcher {\n     TwoWay(TwoWaySearcher),\n     TwoWayLong(TwoWaySearcher),\n@@ -896,6 +905,8 @@ impl OldSearcher {\n }\n \n #[derive(Clone)]\n+// NB: This is kept around for convenience because\n+// it is planned to be used again in the future\n struct OldMatchIndices<'a, 'b> {\n     // constants\n     haystack: &'a str,\n@@ -921,7 +932,8 @@ impl<'a, P: Pattern<'a>> Iterator for MatchIndices<'a, P> {\n \n /// An iterator over the substrings of a string separated by a given\n /// search string\n-#[unstable(feature = \"core\", reason = \"type may be removed\")]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `Split` with a `&str`\")]\n pub struct SplitStr<'a, P: Pattern<'a>>(Split<'a, P>);\n impl<'a, P: Pattern<'a>> Iterator for SplitStr<'a, P> {\n     type Item = &'a str;\n@@ -1282,8 +1294,7 @@ where P::Searcher: DoubleEndedSearcher<'a> {\n }\n \n /// Return type of `StrExt::split_terminator`\n-#[unstable(feature = \"core\",\n-           reason = \"might get removed in favour of a constructor method on Split\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitTerminator<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n@@ -1421,6 +1432,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n+    #[allow(deprecated) /* for SplitStr */ ]\n     fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n         SplitStr(self.split(pat))\n     }\n@@ -1477,18 +1489,20 @@ impl StrExt for str {\n \n     #[inline]\n     fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        pat.match_starts_at(self, 0)\n+        pat.is_prefix_of(self)\n     }\n \n     #[inline]\n     fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-    where P::Searcher: ReverseSearcher<'a> {\n-        pat.match_ends_at(self, self.len())\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        pat.is_suffix_of(self)\n     }\n \n     #[inline]\n     fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-    where P::Searcher: DoubleEndedSearcher<'a> {\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n         let mut i = 0;\n         let mut j = 0;\n         let mut matcher = pat.into_searcher(self);\n@@ -1521,7 +1535,8 @@ impl StrExt for str {\n \n     #[inline]\n     fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-    where P::Searcher: ReverseSearcher<'a> {\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         let mut j = 0;\n         let mut matcher = pat.into_searcher(self);\n         if let Some((_, b)) = matcher.next_reject_back() {\n@@ -1599,7 +1614,8 @@ impl StrExt for str {\n     }\n \n     fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-    where P::Searcher: ReverseSearcher<'a> {\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         pat.into_searcher(self).next_match_back().map(|(i, _)| i)\n     }\n "}, {"sha": "1f669c66eb117aedc2717d8931d987f9de5af518", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 169, "deletions": 44, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -8,66 +8,117 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(missing_docs)]\n+#![allow(deprecated) /* for CharEq */ ]\n \n use prelude::*;\n use super::CharEq;\n \n // Pattern\n \n+/// A string pattern.\n+///\n+/// A `Pattern<'a>` expresses that the implementing type\n+/// can be used as a string pattern for searching in a `&'a str`.\n+///\n+/// For example, both `'a'` and `\"aa\"` are patterns that\n+/// would match at index `1` in the string `\"baaaab\"`.\n+///\n+/// The trait itself acts as a builder for an associated\n+/// `Searcher` type, which does the actual work of finding\n+/// occurences of the pattern in a string.\n pub trait Pattern<'a>: Sized {\n+    /// Associated searcher for this pattern\n     type Searcher: Searcher<'a>;\n+\n+    /// Construct the associated searcher from\n+    /// `self` and the `haystack` to search in.\n     fn into_searcher(self, haystack: &'a str) -> Self::Searcher;\n \n+    /// Check whether the pattern matches anywhere in the haystack\n     #[inline]\n     fn is_contained_in(self, haystack: &'a str) -> bool {\n         self.into_searcher(haystack).next_match().is_some()\n     }\n \n+    /// Check whether the pattern matches at the front of the haystack\n     #[inline]\n-    fn match_starts_at(self, haystack: &'a str, idx: usize) -> bool {\n-        let mut matcher = self.into_searcher(haystack);\n-        loop {\n-            match matcher.next() {\n-                SearchStep::Match(i, _) if i == idx => return true,\n-                SearchStep::Match(i, _)\n-                | SearchStep::Reject(i, _) if i >= idx => break,\n-                SearchStep::Done => break,\n-                _ => continue,\n-            }\n+    fn is_prefix_of(self, haystack: &'a str) -> bool {\n+        match self.into_searcher(haystack).next() {\n+            SearchStep::Match(0, _) => true,\n+            _ => false,\n         }\n-        false\n     }\n \n+    /// Check whether the pattern matches at the back of the haystack\n     #[inline]\n-    fn match_ends_at(self, haystack: &'a str, idx: usize) -> bool\n-    where Self::Searcher: ReverseSearcher<'a> {\n-        let mut matcher = self.into_searcher(haystack);\n-        loop {\n-            match matcher.next_back() {\n-                SearchStep::Match(_, j) if idx == j => return true,\n-                SearchStep::Match(_, j)\n-                | SearchStep::Reject(_, j) if idx >= j => break,\n-                SearchStep::Done => break,\n-                _ => continue,\n-            }\n+    fn is_suffix_of(self, haystack: &'a str) -> bool\n+        where Self::Searcher: ReverseSearcher<'a>\n+    {\n+        match self.into_searcher(haystack).next_back() {\n+            SearchStep::Match(_, j) if haystack.len() == j => true,\n+            _ => false,\n         }\n-        false\n     }\n }\n \n // Searcher\n \n+/// Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n pub enum SearchStep {\n+    /// Expresses that a match of the pattern has been found at\n+    /// `haystack[a..b]`.\n     Match(usize, usize),\n+    /// Expresses that `haystack[a..b]` has been rejected as a possible match\n+    /// of the pattern.\n+    ///\n+    /// Note that there might be more than one `Reject` betwen two `Match`es,\n+    /// there is no requirement for them to be combined into one.\n     Reject(usize, usize),\n+    /// Expresses that every byte of the haystack has been visted, ending\n+    /// the iteration.\n     Done\n }\n \n+/// A searcher for a string pattern.\n+///\n+/// This trait provides methods for searching for non-overlapping\n+/// matches of a pattern starting from the front (left) of a string.\n+///\n+/// It will be implemented by associated `Searcher`\n+/// types of the `Pattern` trait.\n+///\n+/// The trait is marked unsafe because the indices returned by the\n+/// `next()` methods are required to lie on valid utf8 boundaries in\n+/// the haystack. This enables consumers of this trait to\n+/// slice the haystack without additional runtime checks.\n pub unsafe trait Searcher<'a> {\n+    /// Getter for the underlaying string to be searched in\n+    ///\n+    /// Will always return the same `&str`\n     fn haystack(&self) -> &'a str;\n+\n+    /// Performs the next search step starting from the front.\n+    ///\n+    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n+    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n+    ///   pattern, even partially.\n+    /// - Returns `Done` if every byte of the haystack has been visited\n+    ///\n+    /// The stream of `Match` and `Reject` values up to a `Done`\n+    /// will contain index ranges that are adjacent, non-overlapping,\n+    /// covering the whole haystack, and laying on utf8 boundaries.\n+    ///\n+    /// A `Match` result needs to contain the whole matched pattern,\n+    /// however `Reject` results may be split up into arbitrary\n+    /// many adjacent fragments. Both ranges may have zero length.\n+    ///\n+    /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n+    /// might produce the stream\n+    /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n     fn next(&mut self) -> SearchStep;\n+\n+    /// Find the next `Match` result. See `next()`\n     #[inline]\n     fn next_match(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -78,8 +129,10 @@ pub unsafe trait Searcher<'a> {\n             }\n         }\n     }\n+\n+    /// Find the next `Reject` result. See `next()`\n     #[inline]\n-    fn next_reject(&mut self) -> Option<(usize, usize)>{\n+    fn next_reject(&mut self) -> Option<(usize, usize)> {\n         loop {\n             match self.next() {\n                 SearchStep::Reject(a, b) => return Some((a, b)),\n@@ -90,8 +143,42 @@ pub unsafe trait Searcher<'a> {\n     }\n }\n \n+/// A reverse searcher for a string pattern.\n+///\n+/// This trait provides methods for searching for non-overlapping\n+/// matches of a pattern starting from the back (right) of a string.\n+///\n+/// It will be implemented by associated `Searcher`\n+/// types of the `Pattern` trait if the pattern supports searching\n+/// for it from the back.\n+///\n+/// The index ranges returned by this trait are not required\n+/// to exactly match those of the forward search in reverse.\n+///\n+/// For the reason why this trait is marked unsafe, see them\n+/// parent trait `Searcher`.\n pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n+    /// Performs the next search step starting from the back.\n+    ///\n+    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n+    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n+    ///   pattern, even partially.\n+    /// - Returns `Done` if every byte of the haystack has been visited\n+    ///\n+    /// The stream of `Match` and `Reject` values up to a `Done`\n+    /// will contain index ranges that are adjacent, non-overlapping,\n+    /// covering the whole haystack, and laying on utf8 boundaries.\n+    ///\n+    /// A `Match` result needs to contain the whole matched pattern,\n+    /// however `Reject` results may be split up into arbitrary\n+    /// many adjacent fragments. Both ranges may have zero length.\n+    ///\n+    /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n+    /// might produce the stream\n+    /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n     fn next_back(&mut self) -> SearchStep;\n+\n+    /// Find the next `Match` result. See `next_back()`\n     #[inline]\n     fn next_match_back(&mut self) -> Option<(usize, usize)>{\n         loop {\n@@ -102,6 +189,8 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n             }\n         }\n     }\n+\n+    /// Find the next `Reject` result. See `next_back()`\n     #[inline]\n     fn next_reject_back(&mut self) -> Option<(usize, usize)>{\n         loop {\n@@ -114,13 +203,34 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     }\n }\n \n+/// A marker trait to express that a `ReverseSearcher`\n+/// can be used for a `DoubleEndedIterator` implementation.\n+///\n+/// For this, the impl of `Searcher` and `ReverseSearcher` need\n+/// to follow these conditions:\n+///\n+/// - All results of `next()` need to be identical\n+///   to the results of `next_back()` in reverse order.\n+/// - `next()` and `next_back()` need to behave as\n+///   the two ends of a range of values, that is they\n+///   can not \"walk past each other\".\n+///\n+/// # Example\n+///\n+/// `char::Searcher` is a `DoubleEndedSearcher` because searching for a\n+/// `char` only requires looking at one at a time, which behaves the same\n+/// from both ends.\n+///\n+/// `(&str)::Searcher` is not a `DoubleEndedSearcher` because\n+/// the pattern `\"aa\"` in the haystack `\"aaa\"` matches as either\n+/// `\"[aa]a\"` or `\"a[aa]\"`, depending from which side it is searched.\n pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n \n // Impl for a CharEq wrapper\n \n struct CharEqPattern<C: CharEq>(C);\n \n-pub struct CharEqSearcher<'a, C: CharEq> {\n+struct CharEqSearcher<'a, C: CharEq> {\n     char_eq: C,\n     haystack: &'a str,\n     char_indices: super::CharIndices<'a>,\n@@ -194,14 +304,18 @@ impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n // Todo: Optimize the naive implementation here\n \n #[derive(Clone)]\n-pub struct StrSearcher<'a, 'b> {\n+struct StrSearcher<'a, 'b> {\n     haystack: &'a str,\n     needle: &'b str,\n     start: usize,\n     end: usize,\n     done: bool,\n }\n \n+/// Non-allocating substring search.\n+///\n+/// Will handle the pattern `\"\"` as returning empty matches at each utf8\n+/// boundary.\n impl<'a, 'b> Pattern<'a> for &'b str {\n     type Searcher = StrSearcher<'a, 'b>;\n \n@@ -236,9 +350,9 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b>  {\n         },\n         |m: &mut StrSearcher| {\n             // Forward step for nonempty needle\n-            // Compare if bytes are equal\n-            let possible_match = &m.haystack.as_bytes()[m.start .. m.start + m.needle.len()];\n             let current_start = m.start;\n+            // Compare byte window because this might break utf8 boundaries\n+            let possible_match = &m.haystack.as_bytes()[m.start .. m.start + m.needle.len()];\n             if possible_match == m.needle.as_bytes() {\n                 m.start += m.needle.len();\n                 SearchStep::Match(current_start, m.start)\n@@ -266,9 +380,9 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n         },\n         |m: &mut StrSearcher| {\n             // Backward step for nonempty needle\n-            // Compare if bytes are equal\n-            let possible_match = &m.haystack.as_bytes()[m.end - m.needle.len() .. m.end];\n             let current_end = m.end;\n+            // Compare byte window because this might break utf8 boundaries\n+            let possible_match = &m.haystack.as_bytes()[m.end - m.needle.len() .. m.end];\n             if possible_match == m.needle.as_bytes() {\n                 m.end -= m.needle.len();\n                 SearchStep::Match(m.end, current_end)\n@@ -282,9 +396,13 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n     }\n }\n \n-fn str_search_step<F, G>(mut m: &mut StrSearcher, f: F, g: G) -> SearchStep\n-where F: FnOnce(&mut StrSearcher) -> SearchStep,\n-      G: FnOnce(&mut StrSearcher) -> SearchStep\n+// Helper function for encapsulating the common control flow\n+// of doing a search step from the front or doing a search step from the back\n+fn str_search_step<F, G>(mut m: &mut StrSearcher,\n+                         empty_needle_step: F,\n+                         nonempty_needle_step: G) -> SearchStep\n+    where F: FnOnce(&mut StrSearcher) -> SearchStep,\n+          G: FnOnce(&mut StrSearcher) -> SearchStep\n {\n     if m.done {\n         SearchStep::Done\n@@ -293,11 +411,12 @@ where F: FnOnce(&mut StrSearcher) -> SearchStep,\n         if m.start == m.end {\n             m.done = true;\n         }\n-        f(&mut m)\n+        empty_needle_step(&mut m)\n     } else if m.start + m.needle.len() <= m.end {\n         // Case for needle != \"\"\n-        g(&mut m)\n+        nonempty_needle_step(&mut m)\n     } else if m.start < m.end {\n+        // Remaining slice shorter than needle, reject it\n         m.done = true;\n         SearchStep::Reject(m.start, m.end)\n     } else {\n@@ -323,35 +442,39 @@ macro_rules! associated_items {\n         }\n \n         #[inline]\n-        fn match_starts_at(self, haystack: &'a str, idx: usize) -> bool {\n+        fn is_prefix_of(self, haystack: &'a str) -> bool {\n             let $s = self;\n-            $e.match_starts_at(haystack, idx)\n+            $e.is_prefix_of(haystack)\n         }\n \n         // FIXME: #21750\n         /*#[inline]\n-        fn match_ends_at(self, haystack: &'a str, idx: usize) -> bool\n-        where $t: ReverseSearcher<'a> {\n+        fn is_suffix_of(self, haystack: &'a str) -> bool\n+            where $t: ReverseSearcher<'a>\n+        {\n             let $s = self;\n-            $e.match_ends_at(haystack, idx)\n+            $e.is_suffix_of(haystack)\n         }*/\n     }\n }\n \n // CharEq delegation impls\n \n-impl<'a, 'b> Pattern<'a> for &'b [char] {\n+/// Searches for chars that are equal to a given char\n+impl<'a> Pattern<'a> for char {\n     type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n     associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n                       s, CharEqPattern(s));\n }\n \n-impl<'a> Pattern<'a> for char {\n+/// Searches for chars that are equal to any of the chars in the array\n+impl<'a, 'b> Pattern<'a> for &'b [char] {\n     type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n     associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n                       s, CharEqPattern(s));\n }\n \n+/// Searches for chars that match the given predicate\n impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n     type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n     associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n@@ -362,8 +485,10 @@ impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n \n use ops::Deref;\n \n+/// Delegates to the next deref coercion of `Self` that implements `Pattern`\n impl<'a, 'b, P: 'b + ?Sized, T: Deref<Target = P> + ?Sized> Pattern<'a> for &'b T\n-where &'b P: Pattern<'a> {\n+    where &'b P: Pattern<'a>\n+{\n     type Searcher =   <&'b P as Pattern<'a>>::Searcher;\n     associated_items!(<&'b P as Pattern<'a>>::Searcher,\n                       s, (&**s));"}, {"sha": "09fbf4935e4c1e7a86ade0c5bdb543854bb313a8", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -463,7 +463,7 @@ impl<'a> LabelText<'a> {\n     fn pre_escaped_content(self) -> Cow<'a, str> {\n         match self {\n             EscStr(s) => s,\n-            LabelStr(s) => if s.contains_char('\\\\') {\n+            LabelStr(s) => if s.contains('\\\\') {\n                 (&*s).escape_default().into_cow()\n             } else {\n                 s"}, {"sha": "74ae9692abd6193ac1a2af9a1d06e75bd8e8eb2e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -784,7 +784,7 @@ impl NonCamelCaseTypes {\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            ident.len() > 0 && !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n+            ident.len() > 0 && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {"}, {"sha": "d63b3dd60d01d31222ecc4ccc0e15956813ef692", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -219,7 +219,7 @@ pub fn rust_path() -> Vec<Path> {\n     let mut env_rust_path: Vec<Path> = match get_rust_path() {\n         Some(env_path) => {\n             let env_path_components =\n-                env_path.split_str(PATH_ENTRY_SEPARATOR);\n+                env_path.split(PATH_ENTRY_SEPARATOR);\n             env_path_components.map(|s| Path::new(s)).collect()\n         }\n         None => Vec::new()"}, {"sha": "43cd1fc8edbac83b87300390c0678087cb335dee", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -90,7 +90,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n             tcx.sess.bug(\"empty string provided as RUST_REGION_GRAPH\");\n         }\n \n-        if output_template.contains_char('%') {\n+        if output_template.contains('%') {\n             let mut new_str = String::new();\n             for c in output_template.chars() {\n                 if c == '%' {"}, {"sha": "4a3efc861d1a045b52b403f338af72c120af5d74", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -280,9 +280,9 @@ fn split_msg_into_multilines(msg: &str) -> Option<String> {\n     }\n \n     let mut tail = &msg[head..];\n-    let third = tail.find_str(\"(values differ\")\n-                   .or(tail.find_str(\"(lifetime\"))\n-                   .or(tail.find_str(\"(cyclic type of infinite size\"));\n+    let third = tail.find(\"(values differ\")\n+                   .or(tail.find(\"(lifetime\"))\n+                   .or(tail.find(\"(cyclic type of infinite size\"));\n     // Insert `\\n` before any remaining messages which match.\n     if let Some(pos) = third {\n         // The end of the message may just be wrapped in `()` without"}, {"sha": "e349e8d7bb5b4821e572e246fa6e345de3a9a949", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -348,7 +348,7 @@ impl FromStr for UserIdentifiedItem {\n     type Err = ();\n     fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n         Ok(s.parse().map(ItemViaNode).unwrap_or_else(|_| {\n-            ItemViaPath(s.split_str(\"::\").map(|s| s.to_string()).collect())\n+            ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())\n         }))\n     }\n }"}, {"sha": "735487611dc50d522a13a2ae0ebf4b67e0fc50e6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -1469,7 +1469,7 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n \n fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     match s {\n-        Some(s) => match s.find_str(\"\\n\\n\") {\n+        Some(s) => match s.find(\"\\n\\n\") {\n             Some(pos) => &s[..pos],\n             None => s,\n         },"}, {"sha": "80c19816bd506a7ec47d17a5737a3502bde163f4", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -522,7 +522,7 @@ impl GenericPath for Path {\n \n     fn path_relative_from(&self, base: &Path) -> Option<Path> {\n         fn comp_requires_verbatim(s: &str) -> bool {\n-            s == \".\" || s == \"..\" || s.contains_char(SEP2)\n+            s == \".\" || s == \"..\" || s.contains(SEP2)\n         }\n \n         if !self.equiv_prefix(base) {"}, {"sha": "7a5d75581a511447cf5cd4c16950f2c80dadaf38", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -92,7 +92,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut first = true;\n         for line in &lines {\n             for (j, c) in line.chars().enumerate() {\n-                if j > i || !\"* \\t\".contains_char(c) {\n+                if j > i || !\"* \\t\".contains(c) {\n                     can_trim = false;\n                     break;\n                 }\n@@ -264,7 +264,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         if is_block_doc_comment(&curr_line[..]) {\n             return\n         }\n-        assert!(!curr_line.contains_char('\\n'));\n+        assert!(!curr_line.contains('\\n'));\n         lines.push(curr_line);\n     } else {\n         let mut level: isize = 1;"}, {"sha": "eb5688b3ed89adf1db67913946e286b939ceab12", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -2496,7 +2496,7 @@ impl<'a> Parser<'a> {\n                     let fstr = n.as_str();\n                     self.span_err(last_span,\n                                   &format!(\"unexpected token: `{}`\", n.as_str()));\n-                    if fstr.chars().all(|x| \"0123456789.\".contains_char(x)) {\n+                    if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n                             None => continue,"}, {"sha": "38cbe5c7dea16218d1942fc7eef3f9e70406dc18", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8dd2d066d7b25246d2b940b7c161b8b67608b74/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=c8dd2d066d7b25246d2b940b7c161b8b67608b74", "patch": "@@ -84,7 +84,7 @@ impl UnicodeStr for str {\n \n     #[inline]\n     fn trim(&self) -> &str {\n-        self.trim_left().trim_right()\n+        self.trim_matches(|c: char| c.is_whitespace())\n     }\n \n     #[inline]"}]}