{"sha": "c15facb5c092f5d1e5b687111f4dbcd117d567d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNWZhY2I1YzA5MmY1ZDFlNWI2ODcxMTFmNGRiY2QxMTdkNTY3ZDc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-22T16:11:57Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-25T00:24:30Z"}, "message": "Remove \"unsafe\" from run::start_program", "tree": {"sha": "196ef509a6147d3938798405d882636b5432805f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/196ef509a6147d3938798405d882636b5432805f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c15facb5c092f5d1e5b687111f4dbcd117d567d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c15facb5c092f5d1e5b687111f4dbcd117d567d7", "html_url": "https://github.com/rust-lang/rust/commit/c15facb5c092f5d1e5b687111f4dbcd117d567d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c15facb5c092f5d1e5b687111f4dbcd117d567d7/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e22d2bc4bc4ed84c72148bdd00c8da0eb4238c45", "url": "https://api.github.com/repos/rust-lang/rust/commits/e22d2bc4bc4ed84c72148bdd00c8da0eb4238c45", "html_url": "https://github.com/rust-lang/rust/commit/e22d2bc4bc4ed84c72148bdd00c8da0eb4238c45"}], "stats": {"total": 138, "additions": 68, "deletions": 70}, "files": [{"sha": "8960d40b85a24cd100ff9d119c12046d0844ee0d", "filename": "src/libcore/run.rs", "status": "modified", "additions": 68, "deletions": 70, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c15facb5c092f5d1e5b687111f4dbcd117d567d7/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c15facb5c092f5d1e5b687111f4dbcd117d567d7/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=c15facb5c092f5d1e5b687111f4dbcd117d567d7", "patch": "@@ -204,88 +204,86 @@ pub fn run_program(prog: &str, args: &[~str]) -> int {\n  * A class with a <program> field\n  */\n pub fn start_program(prog: &str, args: &[~str]) -> Program {\n-    unsafe {\n-        let pipe_input = os::pipe();\n-        let pipe_output = os::pipe();\n-        let pipe_err = os::pipe();\n-        let pid =\n-            spawn_process(prog, args, &None, &None,\n-                          pipe_input.in, pipe_output.out,\n-                          pipe_err.out);\n+    let pipe_input = os::pipe();\n+    let pipe_output = os::pipe();\n+    let pipe_err = os::pipe();\n+    let pid =\n+        spawn_process(prog, args, &None, &None,\n+                      pipe_input.in, pipe_output.out,\n+                      pipe_err.out);\n \n-        unsafe {\n-            if pid == -1 as pid_t { fail; }\n-            libc::close(pipe_input.in);\n-            libc::close(pipe_output.out);\n-            libc::close(pipe_err.out);\n-        }\n+    unsafe {\n+        if pid == -1 as pid_t { fail; }\n+        libc::close(pipe_input.in);\n+        libc::close(pipe_output.out);\n+        libc::close(pipe_err.out);\n+    }\n \n-        struct ProgRepr {\n-            pid: pid_t,\n-            mut in_fd: c_int,\n-            out_file: *libc::FILE,\n-            err_file: *libc::FILE,\n-            mut finished: bool,\n-        }\n+    struct ProgRepr {\n+        pid: pid_t,\n+        mut in_fd: c_int,\n+        out_file: *libc::FILE,\n+        err_file: *libc::FILE,\n+        mut finished: bool,\n+    }\n \n-        fn close_repr_input(r: &ProgRepr) {\n-            let invalid_fd = -1i32;\n-            if r.in_fd != invalid_fd {\n-                unsafe {\n-                    libc::close(r.in_fd);\n-                }\n-                r.in_fd = invalid_fd;\n-            }\n-        }\n-        fn finish_repr(r: &ProgRepr) -> int {\n-            if r.finished { return 0; }\n-            r.finished = true;\n-            close_repr_input(r);\n-            return waitpid(r.pid);\n-        }\n-        fn destroy_repr(r: &ProgRepr) {\n+    fn close_repr_input(r: &ProgRepr) {\n+        let invalid_fd = -1i32;\n+        if r.in_fd != invalid_fd {\n             unsafe {\n-                finish_repr(r);\n-                libc::fclose(r.out_file);\n-                libc::fclose(r.err_file);\n+                libc::close(r.in_fd);\n             }\n+            r.in_fd = invalid_fd;\n         }\n-        struct ProgRes {\n-            r: ProgRepr,\n-            drop { destroy_repr(&self.r); }\n+    }\n+    fn finish_repr(r: &ProgRepr) -> int {\n+        if r.finished { return 0; }\n+        r.finished = true;\n+        close_repr_input(r);\n+        return waitpid(r.pid);\n+    }\n+    fn destroy_repr(r: &ProgRepr) {\n+        unsafe {\n+            finish_repr(r);\n+            libc::fclose(r.out_file);\n+            libc::fclose(r.err_file);\n         }\n+    }\n+    struct ProgRes {\n+        r: ProgRepr,\n+        drop { destroy_repr(&self.r); }\n+    }\n \n-        fn ProgRes(r: ProgRepr) -> ProgRes {\n-            ProgRes {\n-                r: move r\n-            }\n+    fn ProgRes(r: ProgRepr) -> ProgRes {\n+        ProgRes {\n+            r: move r\n         }\n+    }\n \n-        impl ProgRes: Program {\n-            fn get_id() -> pid_t { return self.r.pid; }\n-            fn input() -> io::Writer {\n-                io::fd_writer(self.r.in_fd, false)\n-            }\n-            fn output() -> io::Reader {\n-                io::FILE_reader(self.r.out_file, false)\n-            }\n-            fn err() -> io::Reader {\n-                io::FILE_reader(self.r.err_file, false)\n-            }\n-            fn close_input() { close_repr_input(&self.r); }\n-            fn finish() -> int { finish_repr(&self.r) }\n-            fn destroy() { destroy_repr(&self.r); }\n+    impl ProgRes: Program {\n+        fn get_id() -> pid_t { return self.r.pid; }\n+        fn input() -> io::Writer {\n+            io::fd_writer(self.r.in_fd, false)\n         }\n-        let repr = ProgRepr {\n-            pid: pid,\n-            in_fd: pipe_input.out,\n-            out_file: os::fdopen(pipe_output.in),\n-            err_file: os::fdopen(pipe_err.in),\n-            finished: false,\n-        };\n-\n-        ProgRes(repr) as Program\n+        fn output() -> io::Reader {\n+            io::FILE_reader(self.r.out_file, false)\n+        }\n+        fn err() -> io::Reader {\n+            io::FILE_reader(self.r.err_file, false)\n+        }\n+        fn close_input() { close_repr_input(&self.r); }\n+        fn finish() -> int { finish_repr(&self.r) }\n+        fn destroy() { destroy_repr(&self.r); }\n     }\n+    let repr = ProgRepr {\n+        pid: pid,\n+        in_fd: pipe_input.out,\n+        out_file: os::fdopen(pipe_output.in),\n+        err_file: os::fdopen(pipe_err.in),\n+        finished: false,\n+    };\n+\n+    ProgRes(repr) as Program\n }\n \n fn read_all(rd: io::Reader) -> ~str {"}]}