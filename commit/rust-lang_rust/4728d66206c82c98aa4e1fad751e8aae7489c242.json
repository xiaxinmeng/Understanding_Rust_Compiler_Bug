{"sha": "4728d66206c82c98aa4e1fad751e8aae7489c242", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MjhkNjYyMDZjODJjOThhYTRlMWZhZDc1MWU4YWFlNzQ4OWMyNDI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-28T03:53:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-28T03:53:06Z"}, "message": "Rollup merge of #65664 - anp:panic-location, r=eddyb\n\n`std::panic::Location` is a lang_item, add `core::intrinsics::caller_location` (RFC 2091 3/N)\n\n[Tracking issue](https://github.com/rust-lang/rust/issues/47809)\n[RFC text](https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md)\n\n@eddyb suggested doing this intrinsic implementation ahead of actually implementing the `#[track_caller]` attribute so that there's an easily tested intermediate step between adding the shim and wiring up the attribute.", "tree": {"sha": "a95e0d577f867d3fba9346478e13bcac3dc793a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a95e0d577f867d3fba9346478e13bcac3dc793a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4728d66206c82c98aa4e1fad751e8aae7489c242", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdtmYiCRBK7hj4Ov3rIwAAdHIIACSNDHDekfqDw58UaK2KoyAw\nSV/TM10Za7vrcCBZm+TSNdEgB7dKPqW9cUIOcWpi0dMlV+JnpvtnJ6mfCx7km0F2\nXtAiwlGdQs2lckAbbku3ufG0GcJZPRUZPhkdHiro1+u4SuJfgdKE2U0YuPJzHD+w\njTABYX99d/iNzHHwFfDBNfRR74S1r6pZ+y6b0m7zH8NLwOXgnMfx1Pe8fRtaG5P9\nBh0XmJm7QPoglXOvDhB0twOYVLylnoAdrcLYmDFA3pKnv85QF4BGHLwyBJmKARf4\nENKEMNt5yU2RW5j08g2LjLWUQkG025RTIrjUXEcZ84w1mA872Ukep/NvD4UgKv0=\n=PVJi\n-----END PGP SIGNATURE-----\n", "payload": "tree a95e0d577f867d3fba9346478e13bcac3dc793a8\nparent c8eefdffe9480bbd84554eab3343f71f04af8f9a\nparent 86e55b1882ac492d6234e5c5f97c7f151a11f5d2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572234786 +0100\ncommitter GitHub <noreply@github.com> 1572234786 +0100\n\nRollup merge of #65664 - anp:panic-location, r=eddyb\n\n`std::panic::Location` is a lang_item, add `core::intrinsics::caller_location` (RFC 2091 3/N)\n\n[Tracking issue](https://github.com/rust-lang/rust/issues/47809)\n[RFC text](https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md)\n\n@eddyb suggested doing this intrinsic implementation ahead of actually implementing the `#[track_caller]` attribute so that there's an easily tested intermediate step between adding the shim and wiring up the attribute.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4728d66206c82c98aa4e1fad751e8aae7489c242", "html_url": "https://github.com/rust-lang/rust/commit/4728d66206c82c98aa4e1fad751e8aae7489c242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4728d66206c82c98aa4e1fad751e8aae7489c242/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8eefdffe9480bbd84554eab3343f71f04af8f9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8eefdffe9480bbd84554eab3343f71f04af8f9a", "html_url": "https://github.com/rust-lang/rust/commit/c8eefdffe9480bbd84554eab3343f71f04af8f9a"}, {"sha": "86e55b1882ac492d6234e5c5f97c7f151a11f5d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/86e55b1882ac492d6234e5c5f97c7f151a11f5d2", "html_url": "https://github.com/rust-lang/rust/commit/86e55b1882ac492d6234e5c5f97c7f151a11f5d2"}], "stats": {"total": 476, "additions": 331, "deletions": 145}, "files": [{"sha": "4e0f18b88fe0a45e256638704c64e7d135ef2d35", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -696,6 +696,10 @@ extern \"rust-intrinsic\" {\n     /// This will statically either panic, or do nothing.\n     pub fn panic_if_uninhabited<T>();\n \n+    /// Gets a reference to a static `Location` indicating where it was called.\n+    #[cfg(not(bootstrap))]\n+    pub fn caller_location() -> &'static crate::panic::Location<'static>;\n+\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "8ccd31c95d51030dd88acd71ffc0bdf662457965", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -1,8 +1,9 @@\n /// Panics the current thread.\n ///\n /// For details, see `std::macros`.\n+#[cfg(bootstrap)]\n #[macro_export]\n-#[allow_internal_unstable(core_panic)]\n+#[allow_internal_unstable(core_panic, panic_internals)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n@@ -20,6 +21,38 @@ macro_rules! panic {\n     });\n }\n \n+/// Panics the current thread.\n+///\n+/// For details, see `std::macros`.\n+#[cfg(not(bootstrap))]\n+#[macro_export]\n+#[allow_internal_unstable(core_panic, panic_internals)]\n+#[stable(feature = \"core\", since = \"1.6.0\")]\n+macro_rules! panic {\n+    () => (\n+        $crate::panic!(\"explicit panic\")\n+    );\n+    ($msg:expr) => ({\n+        const LOC: &$crate::panic::Location<'_> = &$crate::panic::Location::internal_constructor(\n+            $crate::file!(),\n+            $crate::line!(),\n+            $crate::column!(),\n+        );\n+        $crate::panicking::panic($msg, LOC)\n+    });\n+    ($msg:expr,) => (\n+        $crate::panic!($msg)\n+    );\n+    ($fmt:expr, $($arg:tt)+) => ({\n+        const LOC: &$crate::panic::Location<'_> = &$crate::panic::Location::internal_constructor(\n+            $crate::file!(),\n+            $crate::line!(),\n+            $crate::column!(),\n+        );\n+        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+), LOC)\n+    });\n+}\n+\n /// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n ///\n /// On panic, this macro will print the values of the expressions with their"}, {"sha": "51bbf3a8fd221bf4cb2f120a6db4f45a9550433b", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -35,7 +35,7 @@ use crate::fmt;\n pub struct PanicInfo<'a> {\n     payload: &'a (dyn Any + Send),\n     message: Option<&'a fmt::Arguments<'a>>,\n-    location: Location<'a>,\n+    location: &'a Location<'a>,\n }\n \n impl<'a> PanicInfo<'a> {\n@@ -45,11 +45,16 @@ impl<'a> PanicInfo<'a> {\n                 issue = \"0\")]\n     #[doc(hidden)]\n     #[inline]\n-    pub fn internal_constructor(message: Option<&'a fmt::Arguments<'a>>,\n-                                location: Location<'a>)\n-                                -> Self {\n+    pub fn internal_constructor(\n+        message: Option<&'a fmt::Arguments<'a>>,\n+        location: &'a Location<'a>,\n+    ) -> Self {\n         struct NoPayload;\n-        PanicInfo { payload: &NoPayload, location, message }\n+        PanicInfo {\n+            location,\n+            message,\n+            payload: &NoPayload,\n+        }\n     }\n \n     #[doc(hidden)]\n@@ -162,6 +167,7 @@ impl fmt::Display for PanicInfo<'_> {\n ///\n /// panic!(\"Normal panic\");\n /// ```\n+#[cfg_attr(not(bootstrap), lang = \"panic_location\")]\n #[derive(Debug)]\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub struct Location<'a> {\n@@ -176,7 +182,7 @@ impl<'a> Location<'a> {\n                           and related macros\",\n                 issue = \"0\")]\n     #[doc(hidden)]\n-    pub fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n+    pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n         Location { file, line, col }\n     }\n "}, {"sha": "685b749776b1dcca7567903dde3a2083b1f212b9", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -29,6 +29,7 @@\n use crate::fmt;\n use crate::panic::{Location, PanicInfo};\n \n+#[cfg(bootstrap)]\n #[cold]\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n@@ -49,6 +50,27 @@ pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line, col))\n }\n \n+#[cfg(not(bootstrap))]\n+#[cold]\n+// never inline unless panic_immediate_abort to avoid code\n+// bloat at the call sites as much as possible\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[lang = \"panic\"]\n+pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n+    // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n+    // reduce size overhead. The format_args! macro uses str's Display trait to\n+    // write expr, which calls Formatter::pad, which must accommodate string\n+    // truncation and padding (even though none is used here). Using\n+    // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n+    // output binary, saving up to a few kilobytes.\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), location)\n+}\n+\n+#[cfg(bootstrap)]\n #[cold]\n #[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n #[lang = \"panic_bounds_check\"]\n@@ -62,6 +84,22 @@ fn panic_bounds_check(file_line_col: &(&'static str, u32, u32),\n                            len, index), file_line_col)\n }\n \n+#[cfg(not(bootstrap))]\n+#[cold]\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[lang = \"panic_bounds_check\"]\n+fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n+    panic_fmt(\n+        format_args!(\"index out of bounds: the len is {} but the index is {}\", len, index),\n+        location\n+    )\n+}\n+\n+#[cfg(bootstrap)]\n #[cold]\n #[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n #[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n@@ -77,9 +115,26 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u3\n     }\n \n     let (file, line, col) = *file_line_col;\n-    let pi = PanicInfo::internal_constructor(\n-        Some(&fmt),\n-        Location::internal_constructor(file, line, col),\n-    );\n+    let location = Location::internal_constructor(file, line, col);\n+    let pi = PanicInfo::internal_constructor(Some(&fmt), &location);\n+    unsafe { panic_impl(&pi) }\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[cold]\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n+pub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n+    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+    extern \"Rust\" {\n+        #[lang = \"panic_impl\"]\n+        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n+    }\n+\n+    let pi = PanicInfo::internal_constructor(Some(&fmt), location);\n     unsafe { panic_impl(&pi) }\n }"}, {"sha": "72fb1fd3561f01b6f92d446ad505fb03902ad087", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -370,6 +370,7 @@ language_item_table! {\n     PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n     PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n     PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n+    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n     PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n     // Libstd panic entry point. Necessary for const eval to be able to catch it\n     BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;"}, {"sha": "f628e1947487665ac5f53a1f7fb711a08c6b0bcc", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -466,6 +466,12 @@ rustc_queries! {\n             no_force\n             desc { \"extract field of const\" }\n         }\n+\n+        query const_caller_location(key: (syntax_pos::Symbol, u32, u32)) -> &'tcx ty::Const<'tcx> {\n+            eval_always\n+            no_force\n+            desc { \"get a &core::panic::Location referring to a span\" }\n+        }\n     }\n \n     TypeChecking {"}, {"sha": "a9e0a5d6ab564b4a1f8247e4e96cf0b26ef6f9b0", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -208,3 +208,13 @@ impl<'tcx, T> Key for Canonical<'tcx, T> {\n         DUMMY_SP\n     }\n }\n+\n+impl Key for (Symbol, u32, u32) {\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "312c41b88b0924601c3620b121e5ebf648ed7a65", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -23,7 +23,6 @@ use std::ffi::CStr;\n use std::ops::{Deref, Range};\n use std::ptr;\n use std::iter::TrustedLen;\n-use syntax::symbol::Symbol;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n@@ -1067,36 +1066,6 @@ impl StaticBuilderMethods for Builder<'a, 'll, 'tcx> {\n         // Forward to the `get_static` method of `CodegenCx`\n         self.cx().get_static(def_id)\n     }\n-\n-    fn static_panic_msg(\n-        &mut self,\n-        msg: Option<Symbol>,\n-        filename: Symbol,\n-        line: Self::Value,\n-        col: Self::Value,\n-        kind: &str,\n-    ) -> Self::Value {\n-        let align = self.tcx.data_layout.aggregate_align.abi\n-            .max(self.tcx.data_layout.i32_align.abi)\n-            .max(self.tcx.data_layout.pointer_align.abi);\n-\n-        let filename = self.const_str_slice(filename);\n-\n-        let with_msg_components;\n-        let without_msg_components;\n-\n-        let components = if let Some(msg) = msg {\n-            let msg = self.const_str_slice(msg);\n-            with_msg_components = [msg, filename, line, col];\n-            &with_msg_components as &[_]\n-        } else {\n-            without_msg_components = [filename, line, col];\n-            &without_msg_components as &[_]\n-        };\n-\n-        let struct_ = self.const_struct(&components, false);\n-        self.static_addr_of(struct_, align, Some(kind))\n-    }\n }\n \n impl Builder<'a, 'll, 'tcx> {"}, {"sha": "f38f9dfecd38705e63e7b0c418da2ee828b0f8e5", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -3,7 +3,6 @@\n //! Code that is useful in various codegen modules.\n \n use crate::llvm::{self, True, False, Bool, BasicBlock, OperandBundleDef, ConstantInt};\n-use crate::abi;\n use crate::consts;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n@@ -96,16 +95,6 @@ impl BackendTypes for CodegenCx<'ll, 'tcx> {\n }\n \n impl CodegenCx<'ll, 'tcx> {\n-    pub fn const_fat_ptr(\n-        &self,\n-        ptr: &'ll Value,\n-        meta: &'ll Value\n-    ) -> &'ll Value {\n-        assert_eq!(abi::FAT_PTR_ADDR, 0);\n-        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        self.const_struct(&[ptr, meta], false)\n-    }\n-\n     pub fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n@@ -150,13 +139,6 @@ impl CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    pub fn const_str_slice(&self, s: Symbol) -> &'ll Value {\n-        let len = s.as_str().len();\n-        let cs = consts::ptrcast(self.const_cstr(s, false),\n-            self.type_ptr_to(self.layout_of(self.tcx.mk_str()).llvm_type(self)));\n-        self.const_fat_ptr(cs, self.const_usize(len as u64))\n-    }\n-\n     pub fn const_get_elt(&self, v: &'ll Value, idx: u64) -> &'ll Value {\n         unsafe {\n             assert_eq!(idx as c_uint as u64, idx);\n@@ -237,6 +219,13 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         unsafe { llvm::LLVMConstReal(t, val) }\n     }\n \n+    fn const_str(&self, s: Symbol) -> (&'ll Value, &'ll Value) {\n+        let len = s.as_str().len();\n+        let cs = consts::ptrcast(self.const_cstr(s, false),\n+            self.type_ptr_to(self.layout_of(self.tcx.mk_str()).llvm_type(self)));\n+        (cs, self.const_usize(len as u64))\n+    }\n+\n     fn const_struct(\n         &self,\n         elts: &[&'ll Value],"}, {"sha": "79855311f370a9470dbb6ef7fcbd71bbb5c5dde6", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -15,8 +15,7 @@ use crate::traits::*;\n \n use std::borrow::Cow;\n \n-use syntax::symbol::Symbol;\n-use syntax_pos::Pos;\n+use syntax::{source_map::Span, symbol::Symbol};\n \n use super::{FunctionCx, LocalRef};\n use super::place::PlaceRef;\n@@ -421,38 +420,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(&mut bx, terminator.source_info);\n \n         // Get the location information.\n-        let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-        let filename = Symbol::intern(&loc.file.name.to_string());\n-        let line = bx.const_u32(loc.line as u32);\n-        let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n+        let location = self.get_caller_location(&mut bx, span).immediate();\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match msg {\n             PanicInfo::BoundsCheck { ref len, ref index } => {\n                 let len = self.codegen_operand(&mut bx, len).immediate();\n                 let index = self.codegen_operand(&mut bx, index).immediate();\n-\n-                let file_line_col = bx.static_panic_msg(\n-                    None,\n-                    filename,\n-                    line,\n-                    col,\n-                    \"panic_bounds_check_loc\",\n-                );\n-                (lang_items::PanicBoundsCheckFnLangItem,\n-                    vec![file_line_col, index, len])\n+                (lang_items::PanicBoundsCheckFnLangItem, vec![location, index, len])\n             }\n             _ => {\n                 let msg_str = Symbol::intern(msg.description());\n-                let msg_file_line_col = bx.static_panic_msg(\n-                    Some(msg_str),\n-                    filename,\n-                    line,\n-                    col,\n-                    \"panic_loc\",\n-                );\n-                (lang_items::PanicFnLangItem,\n-                    vec![msg_file_line_col])\n+                let msg = bx.const_str(msg_str);\n+                (lang_items::PanicFnLangItem, vec![msg.0, msg.1, location])\n             }\n         };\n \n@@ -553,23 +533,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let ty = instance.unwrap().substs.type_at(0);\n             let layout = bx.layout_of(ty);\n             if layout.abi.is_uninhabited() {\n-                let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-                let filename = Symbol::intern(&loc.file.name.to_string());\n-                let line = bx.const_u32(loc.line as u32);\n-                let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n-\n-                let str = format!(\n-                    \"Attempted to instantiate uninhabited type {}\",\n-                    ty\n-                );\n-                let msg_str = Symbol::intern(&str);\n-                let msg_file_line_col = bx.static_panic_msg(\n-                    Some(msg_str),\n-                    filename,\n-                    line,\n-                    col,\n-                    \"panic_loc\",\n-                );\n+                let msg_str = format!(\"Attempted to instantiate uninhabited type {}\", ty);\n+                let msg = bx.const_str(Symbol::intern(&msg_str));\n+                let location = self.get_caller_location(&mut bx, span).immediate();\n \n                 // Obtain the panic entry point.\n                 let def_id =\n@@ -587,7 +553,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     &mut bx,\n                     fn_ty,\n                     llfn,\n-                    &[msg_file_line_col],\n+                    &[msg.0, msg.1, location],\n                     destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n                     cleanup,\n                 );\n@@ -613,6 +579,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             ReturnDest::Nothing\n         };\n \n+        if intrinsic == Some(\"caller_location\") {\n+            if let Some((_, target)) = destination.as_ref() {\n+                let location = self.get_caller_location(&mut bx, span);\n+\n+                if let ReturnDest::IndirectOperand(tmp, _) = ret_dest {\n+                    location.val.store(&mut bx, tmp);\n+                }\n+                self.store_return(&mut bx, ret_dest, &fn_ty.ret, location.immediate());\n+\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n+                helper.funclet_br(self, &mut bx, *target);\n+            }\n+            return;\n+        }\n+\n         if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n             let dest = match ret_dest {\n                 _ if fn_ty.ret.is_indirect() => llargs[0],\n@@ -1009,6 +990,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n+    fn get_caller_location(\n+        &mut self,\n+        bx: &mut Bx,\n+        span: Span,\n+    ) -> OperandRef<'tcx, Bx::Value> {\n+        let caller = bx.tcx().sess.source_map().lookup_char_pos(span.lo());\n+        let const_loc = bx.tcx().const_caller_location((\n+            Symbol::intern(&caller.file.name.to_string()),\n+            caller.line as u32,\n+            caller.col_display as u32 + 1,\n+        ));\n+        OperandRef::from_const(bx, const_loc)\n+    }\n+\n     fn get_personality_slot(\n         &mut self,\n         bx: &mut Bx"}, {"sha": "8c462e77d5e0533973e08ea82a002128670cfb2d", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -3,6 +3,7 @@ use crate::mir::place::PlaceRef;\n use rustc::mir::interpret::Allocation;\n use rustc::mir::interpret::Scalar;\n use rustc::ty::layout;\n+use syntax_pos::Symbol;\n \n pub trait ConstMethods<'tcx>: BackendTypes {\n     // Constant constructors\n@@ -19,6 +20,7 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_u8(&self, i: u8) -> Self::Value;\n     fn const_real(&self, t: Self::Type, val: f64) -> Self::Value;\n \n+    fn const_str(&self, s: Symbol) -> (Self::Value, Self::Value);\n     fn const_struct(&self, elts: &[Self::Value], packed: bool) -> Self::Value;\n \n     fn const_to_opt_uint(&self, v: Self::Value) -> Option<u64>;"}, {"sha": "5c108f9fa6cc532c39da506f30e6a2c3cdda835c", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -1,5 +1,4 @@\n use super::BackendTypes;\n-use syntax_pos::symbol::Symbol;\n use rustc::hir::def_id::DefId;\n use rustc::ty::layout::Align;\n \n@@ -10,12 +9,4 @@ pub trait StaticMethods: BackendTypes {\n \n pub trait StaticBuilderMethods: BackendTypes {\n     fn get_static(&mut self, def_id: DefId) -> Self::Value;\n-    fn static_panic_msg(\n-        &mut self,\n-        msg: Option<Symbol>,\n-        filename: Symbol,\n-        line: Self::Value,\n-        col: Self::Value,\n-        kind: &str,\n-    ) -> Self::Value;\n }"}, {"sha": "89bdf7391c3e8bd6b6af49064593f71cb1ed3243", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -9,6 +9,7 @@ use std::convert::TryInto;\n \n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::lang_items::PanicLocationLangItem;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n use rustc::ty::{self, Ty, TyCtxt, subst::Subst};\n@@ -17,7 +18,7 @@ use rustc::traits::Reveal;\n use rustc_data_structures::fx::FxHashMap;\n use crate::interpret::eval_nullary_intrinsic;\n \n-use syntax::source_map::{Span, DUMMY_SP};\n+use syntax::{source_map::{Span, DUMMY_SP}, symbol::Symbol};\n \n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar, Pointer,\n@@ -158,11 +159,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n-    intern_const_alloc_recursive(\n-        ecx,\n-        cid.instance.def_id(),\n-        ret,\n-    )?;\n+    intern_const_alloc_recursive(ecx, tcx.static_mutability(cid.instance.def_id()), ret)?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -374,11 +371,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.emulate_intrinsic(instance, args, dest)? {\n+        if ecx.emulate_intrinsic(span, instance, args, dest)? {\n             return Ok(());\n         }\n         // An intrinsic that we do not support\n@@ -505,6 +503,28 @@ pub fn const_field<'tcx>(\n     op_to_const(&ecx, field)\n }\n \n+pub fn const_caller_location<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (file, line, col): (Symbol, u32, u32),\n+) -> &'tcx ty::Const<'tcx> {\n+    trace!(\"const_caller_location: {}:{}:{}\", file, line, col);\n+    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all());\n+\n+    let loc_ty = tcx.mk_imm_ref(\n+        tcx.lifetimes.re_static,\n+        tcx.type_of(tcx.require_lang_item(PanicLocationLangItem, None))\n+            .subst(tcx, tcx.mk_substs([tcx.lifetimes.re_static.into()].iter())),\n+    );\n+    let loc_place = ecx.alloc_caller_location(file, line, col).unwrap();\n+    intern_const_alloc_recursive(&mut ecx, None, loc_place).unwrap();\n+    let loc_const = ty::Const {\n+        ty: loc_ty,\n+        val: ConstValue::Scalar(loc_place.ptr.into()),\n+    };\n+\n+    tcx.mk_const(loc_const)\n+}\n+\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n pub fn const_variant_index<'tcx>("}, {"sha": "924529d7f55794a7fdd6500b0fd727b6c4e2692d", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -6,7 +6,6 @@\n use rustc::ty::{Ty, self};\n use rustc::mir::interpret::{InterpResult, ErrorHandled};\n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n use super::validity::RefTracking;\n use rustc_data_structures::fx::FxHashSet;\n \n@@ -270,12 +269,12 @@ for\n \n pub fn intern_const_alloc_recursive(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n-    def_id: DefId,\n+    // The `mutability` of the place, ignoring the type.\n+    place_mut: Option<hir::Mutability>,\n     ret: MPlaceTy<'tcx>,\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n-    // this `mutability` is the mutability of the place, ignoring the type\n-    let (base_mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n+    let (base_mutability, base_intern_mode) = match place_mut {\n         Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n         Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),"}, {"sha": "519f4f0322228e9474d7c45f674eaec7e09c7496", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -3,6 +3,7 @@\n //! and miri.\n \n use syntax::symbol::Symbol;\n+use syntax_pos::Span;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n use rustc::ty::subst::SubstsRef;\n@@ -15,6 +16,7 @@ use super::{\n     Machine, PlaceTy, OpTy, InterpCx,\n };\n \n+mod caller_location;\n mod type_name;\n \n fn numeric_intrinsic<'tcx, Tag>(\n@@ -86,6 +88,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: PlaceTy<'tcx, M::PointerTag>,\n@@ -94,6 +97,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n+            \"caller_location\" => {\n+                let caller = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n+                let location = self.alloc_caller_location(\n+                    Symbol::intern(&caller.file.name.to_string()),\n+                    caller.line as u32,\n+                    caller.col_display as u32 + 1,\n+                )?;\n+                self.write_scalar(location.ptr, dest)?;\n+            }\n+\n             \"min_align_of\" |\n             \"pref_align_of\" |\n             \"needs_drop\" |\n@@ -301,18 +314,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, bool> {\n         let def_id = instance.def_id();\n         if Some(def_id) == self.tcx.lang_items().panic_fn() {\n-            assert!(args.len() == 1);\n-            // &(&'static str, &'static str, u32, u32)\n-            let place = self.deref_operand(args[0])?;\n-            let (msg, file, line, col) = (\n-                self.mplace_field(place, 0)?,\n-                self.mplace_field(place, 1)?,\n-                self.mplace_field(place, 2)?,\n-                self.mplace_field(place, 3)?,\n-            );\n+            // &'static str, &core::panic::Location { &'static str, u32, u32 }\n+            assert!(args.len() == 2);\n \n-            let msg_place = self.deref_operand(msg.into())?;\n+            let msg_place = self.deref_operand(args[0])?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n+\n+            let location = self.deref_operand(args[1])?;\n+            let (file, line, col) = (\n+                self.mplace_field(location, 0)?,\n+                self.mplace_field(location, 1)?,\n+                self.mplace_field(location, 2)?,\n+            );\n+\n             let file_place = self.deref_operand(file.into())?;\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;"}, {"sha": "249d2f9ff536a510ef6c0a9867172ee9eb0953ac", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -0,0 +1,49 @@\n+use rustc::middle::lang_items::PanicLocationLangItem;\n+use rustc::mir::interpret::{Pointer, PointerArithmetic, Scalar};\n+use rustc::ty::subst::Subst;\n+use rustc_target::abi::{LayoutOf, Size};\n+use syntax_pos::Symbol;\n+\n+use crate::interpret::{MemoryKind, MPlaceTy, intrinsics::{InterpCx, InterpResult, Machine}};\n+\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    pub fn alloc_caller_location(\n+        &mut self,\n+        filename: Symbol,\n+        line: u32,\n+        col: u32,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let line = Scalar::from_u32(line);\n+        let col = Scalar::from_u32(col);\n+\n+        let ptr_size = self.pointer_size();\n+        let u32_size = Size::from_bits(32);\n+\n+        let loc_ty = self.tcx.type_of(self.tcx.require_lang_item(PanicLocationLangItem, None))\n+            .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_static.into()].iter()));\n+        let loc_layout = self.layout_of(loc_ty)?;\n+\n+        let file_alloc = self.tcx.allocate_bytes(filename.as_str().as_bytes());\n+        let file_ptr = Pointer::new(file_alloc, Size::ZERO);\n+        let file = Scalar::Ptr(self.tag_static_base_pointer(file_ptr));\n+        let file_len = Scalar::from_uint(filename.as_str().len() as u128, ptr_size);\n+\n+        let location = self.allocate(loc_layout, MemoryKind::Stack);\n+\n+        let file_out = self.mplace_field(location, 0)?;\n+        let file_ptr_out = self.force_ptr(self.mplace_field(file_out, 0)?.ptr)?;\n+        let file_len_out = self.force_ptr(self.mplace_field(file_out, 1)?.ptr)?;\n+        let line_out = self.force_ptr(self.mplace_field(location, 1)?.ptr)?;\n+        let col_out = self.force_ptr(self.mplace_field(location, 2)?.ptr)?;\n+\n+        let layout = &self.tcx.data_layout;\n+        let alloc = self.memory.get_mut(file_ptr_out.alloc_id)?;\n+\n+        alloc.write_scalar(layout, file_ptr_out, file.into(), ptr_size)?;\n+        alloc.write_scalar(layout, file_len_out, file_len.into(), ptr_size)?;\n+        alloc.write_scalar(layout, line_out, line.into(), u32_size)?;\n+        alloc.write_scalar(layout, col_out, col.into(), u32_size)?;\n+\n+        Ok(location)\n+    }\n+}"}, {"sha": "870e50a3cbb9a19a03c7ebff982d5c2490c8680c", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -8,6 +8,7 @@ use std::hash::Hash;\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::{self, Ty, TyCtxt};\n+use syntax_pos::Span;\n \n use super::{\n     Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n@@ -152,6 +153,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: PlaceTy<'tcx, Self::PointerTag>,"}, {"sha": "d90f2058aa74fe15311e9932df201c0d1fc8cb53", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -255,7 +255,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Some(dest) => dest,\n                     None => throw_ub!(Unreachable)\n                 };\n-                M::call_intrinsic(self, instance, args, dest)?;\n+                M::call_intrinsic(self, span, instance, args, dest)?;\n                 // No stack frame gets pushed, the main loop will just act as if the\n                 // call completed.\n                 self.goto_block(ret)?;"}, {"sha": "4d604cb025c8e66592e32825254d12fb080fed5f", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -58,6 +58,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.const_eval = const_eval::const_eval_provider;\n     providers.const_eval_raw = const_eval::const_eval_raw_provider;\n     providers.check_match = hair::pattern::check_match;\n+    providers.const_caller_location = const_eval::const_caller_location;\n     providers.const_field = |tcx, param_env_and_value| {\n         let (param_env, (value, field)) = param_env_and_value.into_parts();\n         const_eval::const_field(tcx, param_env, None, field, value)"}, {"sha": "e7095101f465dd3f68ada30031505a8543cacd67", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -158,6 +158,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     fn call_intrinsic(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n         _dest: PlaceTy<'tcx>,"}, {"sha": "76cc7062d3b8792145f1eb08e434b12d72ff10e0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -1,6 +1,7 @@\n //! Type-checking for the rust-intrinsic and platform-intrinsic\n //! intrinsics that the compiler exposes.\n \n+use rustc::middle::lang_items::PanicLocationLangItem;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::subst::Subst;\n@@ -65,7 +66,7 @@ fn equate_intrinsic_type<'tcx>(\n /// Returns `true` if the given intrinsic is unsafe to call or not.\n pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n     match intrinsic {\n-        \"size_of\" | \"min_align_of\" | \"needs_drop\" |\n+        \"size_of\" | \"min_align_of\" | \"needs_drop\" | \"caller_location\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" |\n         \"saturating_add\" | \"saturating_sub\" |\n@@ -143,6 +144,15 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                  ], tcx.types.usize)\n             }\n             \"rustc_peek\" => (1, vec![param(0)], param(0)),\n+            \"caller_location\" => (\n+                0,\n+                vec![],\n+                tcx.mk_imm_ref(\n+                    tcx.lifetimes.re_static,\n+                    tcx.type_of(tcx.require_lang_item(PanicLocationLangItem, None))\n+                        .subst(tcx, tcx.mk_substs([tcx.lifetimes.re_static.into()].iter())),\n+                ),\n+            ),\n             \"panic_if_uninhabited\" => (1, Vec::new(), tcx.mk_unit()),\n             \"init\" => (1, Vec::new(), param(0)),\n             \"uninit\" => (1, Vec::new(), param(0)),"}, {"sha": "f76969146fdd2318688e549ad6ba19093f1658ae", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -323,10 +323,8 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>,\n     }\n \n     let (file, line, col) = *file_line_col;\n-    let info = PanicInfo::internal_constructor(\n-        Some(msg),\n-        Location::internal_constructor(file, line, col),\n-    );\n+    let location = Location::internal_constructor(file, line, col);\n+    let info = PanicInfo::internal_constructor(Some(msg), &location);\n     continue_panic_fmt(&info)\n }\n \n@@ -453,10 +451,8 @@ fn rust_panic_with_hook(payload: &mut dyn BoxMeUp,\n     }\n \n     unsafe {\n-        let mut info = PanicInfo::internal_constructor(\n-            message,\n-            Location::internal_constructor(file, line, col),\n-        );\n+        let location = Location::internal_constructor(file, line, col);\n+        let mut info = PanicInfo::internal_constructor(message, &location);\n         HOOK_LOCK.read();\n         match HOOK {\n             // Some platforms know that printing to stderr won't ever actually"}, {"sha": "c63822f052b2fbe20762ac69ec5dd85cbebb8881", "filename": "src/test/ui/consts/const-eval/const_caller_location.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_caller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_caller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_caller_location.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+\n+#![feature(const_fn, core_intrinsics)]\n+\n+use std::{intrinsics::caller_location, panic::Location};\n+\n+const LOCATION: &Location = caller_location();\n+const NESTED: &Location = {\n+    const fn nested_location() -> &'static Location<'static> {\n+        caller_location()\n+    };\n+    nested_location()\n+};\n+\n+fn main() {\n+    assert_eq!(LOCATION.file(), file!());\n+    assert_eq!(LOCATION.line(), 7);\n+    assert_eq!(LOCATION.column(), 29);\n+\n+    assert_eq!(NESTED.file(), file!());\n+    assert_eq!(NESTED.line(), 10);\n+    assert_eq!(NESTED.column(), 9);\n+}"}, {"sha": "8727c9d1ca6551e20163665562ac59b398dc3830", "filename": "src/test/ui/extern/issue-64655-allow-unwind-when-calling-panic-directly.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -22,7 +22,7 @@\n //[thin]compile-flags: -C lto=thin\n //[fat]compile-flags: -C lto=fat\n \n-#![feature(core_panic)]\n+#![feature(core_panic, panic_internals)]\n \n // (For some reason, reproducing the LTO issue requires pulling in std\n // explicitly this way.)\n@@ -51,7 +51,8 @@ fn main() {\n \n         let _guard = Droppable;\n         let s = \"issue-64655-allow-unwind-when-calling-panic-directly.rs\";\n-        core::panicking::panic(&(\"???\", s, 17, 4));\n+        let location = core::panic::Location::internal_constructor(s, 17, 4);\n+        core::panicking::panic(\"???\", &location);\n     });\n \n     let wait = handle.join();"}, {"sha": "ab6c59384c43bf4161347f180361d9baceba0347", "filename": "src/test/ui/rfc-2091-track-caller/caller-location-intrinsic.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4728d66206c82c98aa4e1fad751e8aae7489c242/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs?ref=4728d66206c82c98aa4e1fad751e8aae7489c242", "patch": "@@ -0,0 +1,9 @@\n+// run-pass\n+\n+#![feature(core_intrinsics)]\n+fn main() {\n+    let loc = core::intrinsics::caller_location();\n+    assert_eq!(loc.file(), file!());\n+    assert_eq!(loc.line(), 5);\n+    assert_eq!(loc.column(), 15);\n+}"}]}