{"sha": "9aa78e34e47074db22777c35bbf6cf2b3f973c40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYTc4ZTM0ZTQ3MDc0ZGIyMjc3N2MzNWJiZjZjZjJiM2Y5NzNjNDA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-09T09:47:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T08:40:52Z"}, "message": "Never pass tydesc to functions\n\nMy assumption that native generics needed them was wrong, so tydescs\ncan be eliminated from function signatures completely.", "tree": {"sha": "a738e174efafb02553c810d783293d3b22bc7490", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a738e174efafb02553c810d783293d3b22bc7490"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aa78e34e47074db22777c35bbf6cf2b3f973c40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa78e34e47074db22777c35bbf6cf2b3f973c40", "html_url": "https://github.com/rust-lang/rust/commit/9aa78e34e47074db22777c35bbf6cf2b3f973c40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aa78e34e47074db22777c35bbf6cf2b3f973c40/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47f35c9d34b55d143e5368bd917c013afabeb5a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/47f35c9d34b55d143e5368bd917c013afabeb5a8", "html_url": "https://github.com/rust-lang/rust/commit/47f35c9d34b55d143e5368bd917c013afabeb5a8"}], "stats": {"total": 444, "additions": 93, "deletions": 351}, "files": [{"sha": "b20c502013b3779242a241bd5b50b3ba8a5f8833", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 58, "deletions": 101, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9aa78e34e47074db22777c35bbf6cf2b3f973c40", "patch": "@@ -865,7 +865,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, substs: [ty::t])\n         maybe_instantiate_inline(ccx, did)\n     } else { did };\n     assert did.crate == ast::local_crate;\n-    option::get(monomorphic_fn(ccx, did, substs, none))\n+    monomorphic_fn(ccx, did, substs, none)\n }\n \n fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n@@ -1951,8 +1951,7 @@ enum callee_env {\n type lval_maybe_callee = {bcx: block,\n                           val: ValueRef,\n                           kind: lval_kind,\n-                          env: callee_env,\n-                          tds: option<[ValueRef]>};\n+                          env: callee_env};\n \n fn null_env_ptr(bcx: block) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx.ccx()))\n@@ -1971,20 +1970,21 @@ fn lval_temp(bcx: block, val: ValueRef) -> lval_result {\n \n fn lval_no_env(bcx: block, val: ValueRef, kind: lval_kind)\n     -> lval_maybe_callee {\n-    ret {bcx: bcx, val: val, kind: kind, env: is_closure, tds: none};\n+    ret {bcx: bcx, val: val, kind: kind, env: is_closure};\n }\n \n-fn trans_external_path(cx: block, did: ast::def_id,\n-                       tpt: ty::ty_param_bounds_and_ty) -> ValueRef {\n-    let ccx = cx.fcx.ccx;\n+fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n+    -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n-    ret get_extern_const(ccx.externs, ccx.llmod, name,\n-                         type_of_ty_param_bounds_and_ty(ccx, tpt));\n+    let llty = alt ty::get(t).struct {\n+      ty::ty_fn(_) { type_of_fn_from_ty(ccx, t) }\n+      _ { type_of(ccx, t) }\n+    };\n+    ret get_extern_const(ccx.externs, ccx.llmod, name, llty);\n }\n \n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n-                  vtables: option<typeck::vtable_res>)\n-    -> option<ValueRef> {\n+                  vtables: option<typeck::vtable_res>) -> ValueRef {\n     let substs = vec::map(substs, {|t|\n         alt ty::get(t).struct {\n           ty::ty_box(mt) { ty::mk_opaque_box(ccx.tcx) }\n@@ -1996,7 +1996,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       none { no_vts }\n     }};\n     alt ccx.monomorphized.find(hash_id) {\n-      some(val) { ret some(val); }\n+      some(val) { ret val; }\n       none {}\n     }\n \n@@ -2017,8 +2017,10 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       }\n       ast_map::node_variant(v, _, pt) { (pt, v.node.name) }\n       ast_map::node_method(m, _, pt) { (pt, m.ident) }\n-      // We can't monomorphize native functions\n-      ast_map::node_native_item(_, _, _) { ret none; }\n+      ast_map::node_native_item(_, _, _) {\n+        // Natives don't have to be monomorphized.\n+        ret get_item_val(ccx, fn_id.node);\n+      }\n       ast_map::node_ctor(i) {\n         alt check ccx.tcx.items.get(i.id) {\n           ast_map::node_item(i, pt) { (pt, i.ident) }\n@@ -2027,7 +2029,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       _ { fail \"unexpected node type\"; }\n     };\n     let mono_ty = ty::substitute_type_params(ccx.tcx, substs, item_ty);\n-    let llfty = type_of_fn_from_ty(ccx, mono_ty, 0u);\n+    let llfty = type_of_fn_from_ty(ccx, mono_ty);\n \n     let pt = *pt + [path_name(ccx.names(name))];\n     let s = mangle_exported_name(ccx, pt, mono_ty);\n@@ -2071,7 +2073,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         }\n       }\n     }\n-    some(lldecl)\n+    lldecl\n }\n \n fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n@@ -2142,39 +2144,18 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         maybe_instantiate_inline(ccx, fn_id)\n     } else { fn_id };\n \n-    // The awkwardness below mostly stems from the fact that we're mixing\n-    // monomorphized and non-monomorphized functions at the moment. If\n-    // monomorphizing becomes the only approach, this'll be much simpler.\n     if fn_id.crate == ast::local_crate {\n-        let mono = alt substs {\n-          some((stys, vtables)) {\n-            if stys.len() > 0u {\n-                monomorphic_fn(ccx, fn_id, stys, some(vtables))\n-            } else { none }\n-          }\n-          none {\n-            alt ccx.maps.vtable_map.find(id) {\n-              some(vtables) {\n-                let rvtables = impl::resolve_vtables_in_fn_ctxt(\n-                    bcx.fcx, vtables);\n-                monomorphic_fn(ccx, fn_id, tys, some(rvtables))\n-              }\n-              none {\n-                if tys.len() == 0u { none }\n-                else { monomorphic_fn(ccx, fn_id, tys, none) }\n-              }\n-            }\n-          }\n+        let (tys, vtables) = alt substs {\n+          some((tys, vts)) { (tys, some(vts)) }\n+          none { (tys, option::map(ccx.maps.vtable_map.find(id), {|vts|\n+                           impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts)})) }\n         };\n-        alt mono {\n-          some(llfn) {\n-            let cast = PointerCast(bcx, llfn, T_ptr(type_of_fn_from_ty(\n-                ccx, node_id_type(bcx, id), 0u)));\n+        if tys.len() > 0u {\n+            let val = monomorphic_fn(ccx, fn_id, tys, vtables);\n+            let cast = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n+                ccx, node_id_type(bcx, id))));\n             ret {bcx: bcx, val: cast,\n-                 kind: owned, env: null_env,\n-                 tds: none};\n-          }\n-          none {}\n+                 kind: owned, env: null_env};\n         }\n     }\n \n@@ -2183,8 +2164,14 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         get_item_val(ccx, fn_id.node)\n     } else {\n         // External reference.\n-        trans_external_path(bcx, fn_id, tpt)\n+        trans_external_path(ccx, fn_id, tpt.ty)\n     };\n+    if tys.len() > 0u {\n+        // This is supposed to be an external native function.\n+        // Unfortunately, I found no easy/cheap way to assert that.\n+        val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n+            ccx, node_id_type(bcx, id))));\n+    }\n \n     // FIXME: Need to support external crust functions\n     if fn_id.crate == ast::local_crate {\n@@ -2198,22 +2185,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         }\n     }\n \n-    let tds = none, bcx = bcx;\n-    // FIXME[mono] ensure this is a native function\n-    if tys.len() > 0u {\n-        val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n-            ccx, node_id_type(bcx, id), tys.len())));\n-        let tydescs = [];\n-        for t in tys {\n-            let ti = none;\n-            let td = get_tydesc(bcx, t, ti);\n-            lazily_emit_all_tydesc_glue(ccx, ti);\n-            bcx = td.bcx;\n-            tydescs += [td.val];\n-        }\n-        tds = some(tydescs);\n-    }\n-    ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: tds};\n+    ret {bcx: bcx, val: val, kind: owned, env: null_env};\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -2313,7 +2285,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id, path: @ast::path)\n             ret lval_no_env(cx, get_item_val(ccx, did.node), owned);\n         } else {\n             let tp = node_id_type(cx, id);\n-            let val = trans_external_path(cx, did, {bounds: @[], ty: tp});\n+            let val = trans_external_path(ccx, did, tp);\n             ret lval_no_env(cx, load_if_immediate(cx, val, tp), owned_imm);\n         }\n       }\n@@ -2466,8 +2438,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n }\n \n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n-    let must_bind = option::is_some(c.tds) ||\n-        alt c.env { self_env(_, _) { true } _ { false } };\n+    let must_bind = alt c.env { self_env(_, _) { true } _ { false } };\n     if must_bind {\n         let n_args = ty::ty_fn_args(ty).len();\n         let args = vec::from_elem(n_args, none);\n@@ -2662,12 +2633,10 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn trans_args(cx: block, llenv: ValueRef,\n-              tds: option<[ValueRef]>, es: [@ast::expr], fn_ty: ty::t,\n-              dest: dest)\n-   -> {bcx: block,\n-       args: [ValueRef],\n-       retslot: ValueRef} {\n+fn trans_args(cx: block, llenv: ValueRef, es: [@ast::expr], fn_ty: ty::t,\n+              dest: dest) -> {bcx: block,\n+                              args: [ValueRef],\n+                              retslot: ValueRef} {\n \n     let temp_cleanups = [];\n     let args = ty::ty_fn_args(fn_ty);\n@@ -2701,12 +2670,6 @@ fn trans_args(cx: block, llenv: ValueRef,\n     // Arg 1: Env (closure-bindings / self value)\n     llargs += [llenv];\n \n-    // Args >2: ty_params ...\n-    alt tds {\n-      some(tds) { llargs += tds; }\n-      none {}\n-    }\n-\n     // ... then explicit args.\n \n     // First we figure out the caller's view of the types of the arguments.\n@@ -2770,8 +2733,7 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n         };\n \n         let ret_ty = node_id_type(bcx, id);\n-        let args_res =\n-            trans_args(bcx, llenv, f_res.tds, args, fn_expr_ty, dest);\n+        let args_res = trans_args(bcx, llenv, args, fn_expr_ty, dest);\n         bcx = args_res.bcx;\n         let llargs = args_res.args;\n         let llretslot = args_res.retslot;\n@@ -3883,7 +3845,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n                              args: [ast::arg],\n                              tps_bounds: [ty::param_bounds]) {\n     // Skip the implicit arguments 0, and 1.\n-    let arg_n = first_tp_arg;\n+    let arg_n = first_real_arg;\n     alt ty_self {\n       impl_self(tt) {\n         cx.llself = some({v: cx.llenv, t: tt});\n@@ -4417,11 +4379,9 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n }\n \n fn register_fn(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n-               ty_params: [ast::ty_param], node_id: ast::node_id)\n-    -> ValueRef {\n+               node_id: ast::node_id) -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n-    let bnds = param_bounds(ccx, ty_params);\n-    register_fn_full(ccx, sp, path, flav, bnds, node_id, t)\n+    register_fn_full(ccx, sp, path, flav, node_id, t)\n }\n \n fn param_bounds(ccx: @crate_ctxt, tps: [ast::ty_param])\n@@ -4430,9 +4390,8 @@ fn param_bounds(ccx: @crate_ctxt, tps: [ast::ty_param])\n }\n \n fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n-                    bnds: [ty::param_bounds], node_id: ast::node_id,\n-                    node_type: ty::t) -> ValueRef {\n-    let llfty = type_of_fn_from_ty(ccx, node_type, bnds.len());\n+                    node_id: ast::node_id, node_type: ty::t) -> ValueRef {\n+    let llfty = type_of_fn_from_ty(ccx, node_type);\n     register_fn_fuller(ccx, sp, path, flav, node_id, node_type,\n                        lib::llvm::CCallConv, llfty)\n }\n@@ -4479,7 +4438,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n             {mode: ast::expl(ast::by_val),\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mutbl: ast::m_imm})};\n         let nt = ty::mk_nil(ccx.tcx);\n-        let llfty = type_of_fn(ccx, [vecarg_ty], nt, 0u);\n+        let llfty = type_of_fn(ccx, [vecarg_ty], nt);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n@@ -4575,34 +4534,32 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 ccx.item_symbols.insert(i.id, s);\n                 g\n               }\n-              ast::item_fn(decl, tps, _) {\n+              ast::item_fn(decl, _, _) {\n                 let llfn = if decl.purity != ast::crust_fn {\n-                    register_fn(ccx, i.span, my_path, \"fn\", tps, i.id)\n+                    register_fn(ccx, i.span, my_path, \"fn\", i.id)\n                 } else {\n                     native::register_crust_fn(ccx, i.span, my_path, i.id)\n                 };\n                 set_inline_hint_if_appr(i.attrs, llfn);\n                 llfn\n               }\n-              ast::item_res(_, tps, _, dtor_id, _) {\n+              ast::item_res(_, _, _, dtor_id, _) {\n                 // Note that the destructor is associated with the item's id,\n                 // not the dtor_id. This is a bit counter-intuitive, but\n                 // simplifies ty_res, which would have to carry around two\n                 // def_ids otherwise -- one to identify the type, and one to\n                 // find the dtor symbol.\n                 let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n                 register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n-                                 \"res_dtor\", param_bounds(ccx, tps), i.id, t)\n+                                 \"res_dtor\", i.id, t)\n               }\n             }\n           }\n           ast_map::node_method(m, impl_id, pth) {\n             let mty = ty::node_id_to_type(ccx.tcx, id);\n-            let impl_tps = *ty::lookup_item_type(ccx.tcx, impl_id).bounds;\n             let pth = *pth + [path_name(int::str(impl_id.node)),\n                               path_name(m.ident)];\n             let llfn = register_fn_full(ccx, m.span, pth, \"impl_method\",\n-                                        impl_tps + param_bounds(ccx, m.tps),\n                                         id, mty);\n             set_inline_hint_if_appr(m.attrs, llfn);\n             llfn\n@@ -4612,24 +4569,24 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n           }\n           ast_map::node_ctor(i) {\n             alt check i.node {\n-              ast::item_res(_, tps, _, _, _) {\n+              ast::item_res(_, _, _, _, _) {\n                 let my_path = item_path(ccx, i);\n                 let llctor = register_fn(ccx, i.span, my_path, \"res_ctor\",\n-                                         tps, id);\n+                                         id);\n                 set_inline_hint(llctor);\n                 llctor\n               }\n-              ast::item_class(tps, _, ctor) {\n-                register_fn(ccx, i.span, item_path(ccx, i), \"ctor\", tps, id)\n+              ast::item_class(_, _, ctor) {\n+                register_fn(ccx, i.span, item_path(ccx, i), \"ctor\", id)\n               }\n             }\n           }\n           ast_map::node_variant(v, enm, pth) {\n             assert v.node.args.len() != 0u;\n             let pth = *pth + [path_name(enm.ident), path_name(v.node.name)];\n             let llfn = alt check enm.node {\n-              ast::item_enum(_, tps) {\n-                register_fn(ccx, v.span, pth, \"enum\", tps, id)\n+              ast::item_enum(_, _) {\n+                register_fn(ccx, v.span, pth, \"enum\", id)\n               }\n             };\n             set_inline_hint(llfn);"}, {"sha": "c67c3f1d4563924df8aaf80e8aba6c35361cccc9", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 15, "deletions": 51, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=9aa78e34e47074db22777c35bbf6cf2b3f973c40", "patch": "@@ -130,17 +130,10 @@ fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n \n // Given a closure ty, emits a corresponding tuple ty\n fn mk_closure_tys(tcx: ty::ctxt,\n-                  ck: ty::closure_kind,\n-                  ty_params: option<[ValueRef]>,\n                   bound_values: [environment_value])\n     -> (ty::t, [ty::t]) {\n     let bound_tys = [];\n \n-    // Compute the closed over tydescs\n-    let n_param_ptrs = alt ty_params {\n-      some(tds) { tds.len() } none { 0u }\n-    };\n-\n     // Compute the closed over data\n     for bv in bound_values {\n         bound_tys += [alt bv {\n@@ -151,9 +144,8 @@ fn mk_closure_tys(tcx: ty::ctxt,\n         }];\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n-\n-    let typtrs = vec::from_elem(n_param_ptrs, mk_tydesc_ty(tcx, ck));\n-    let cdata_ty = ty::mk_tup(tcx, [ty::mk_tup(tcx, typtrs),\n+    // FIXME[mono] remove tuple of tydescs from closure types\n+    let cdata_ty = ty::mk_tup(tcx, [ty::mk_tup(tcx, []),\n                                     bound_data_ty]);\n     #debug[\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)];\n     ret (cdata_ty, bound_tys);\n@@ -237,11 +229,9 @@ fn cast_if_we_can(bcx: block, llbox: ValueRef, t: ty::t) -> ValueRef {\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-fn store_environment(\n-    bcx: block, lltyparams: option<[ValueRef]>,\n-    bound_values: [environment_value],\n-    ck: ty::closure_kind)\n-    -> closure_result {\n+fn store_environment(bcx: block,\n+                     bound_values: [environment_value],\n+                     ck: ty::closure_kind) -> closure_result {\n \n     fn maybe_clone_tydesc(bcx: block,\n                           ck: ty::closure_kind,\n@@ -260,7 +250,7 @@ fn store_environment(\n \n     // compute the shape of the closure\n     let (cdata_ty, bound_tys) =\n-        mk_closure_tys(tcx, ck, lltyparams, bound_values);\n+        mk_closure_tys(tcx, bound_values);\n \n     // allocate closure in the heap\n     let (bcx, llbox, temp_cleanups) =\n@@ -274,18 +264,6 @@ fn store_environment(\n     let llbox = cast_if_we_can(bcx, llbox, cboxptr_ty);\n     #debug[\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty)];\n \n-    // If necessary, copy tydescs describing type parameters into the\n-    // appropriate slot in the closure.\n-    let {bcx:bcx, val:ty_params_slot} =\n-        GEP_tup_like(bcx, cbox_ty, llbox,\n-                     [0, abi::box_field_body, abi::closure_body_ty_params]);\n-    option::may(lltyparams) {|tds|\n-        vec::iteri(tds) {|i, td|\n-            let cloned_td = maybe_clone_tydesc(bcx, ck, td);\n-            Store(bcx, cloned_td, GEPi(bcx, ty_params_slot, [0, i as int]));\n-        }\n-    }\n-\n     // Copy expr values into boxed bindings.\n     vec::iteri(bound_values) { |i, bv|\n         #debug[\"Copy %s into closure\", ev_to_str(ccx, bv)];\n@@ -377,7 +355,7 @@ fn build_closure(bcx0: block,\n           }\n         }\n     }\n-    ret store_environment(bcx, none, env_vals, ck);\n+    ret store_environment(bcx, env_vals, ck);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -426,11 +404,11 @@ fn trans_expr_fn(bcx: block,\n     if dest == ignore { ret bcx; }\n     let ccx = bcx.ccx(), bcx = bcx;\n     let fty = node_id_type(bcx, id);\n-    let llfnty = type_of_fn_from_ty(ccx, fty, 0u);\n+    let llfnty = type_of_fn_from_ty(ccx, fty);\n     let sub_path = bcx.fcx.path + [path_name(\"anon\")];\n     let s = mangle_internal_name_by_path(ccx, sub_path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n-    register_fn(ccx, sp, sub_path, \"anon fn\", [], id);\n+    register_fn(ccx, sp, sub_path, \"anon fn\", id);\n \n     let trans_closure_env = fn@(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n@@ -479,7 +457,7 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n         ret bcx;\n     }\n \n-    if bound.len() == 0u && option::is_none(f_res.tds) &&\n+    if bound.len() == 0u &&\n        (f_res.env == null_env || f_res.env == is_closure) {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n@@ -505,15 +483,13 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n \n     // Actually construct the closure\n     let {llbox, cdata_ty, bcx} = store_environment(\n-        bcx, f_res.tds,\n-        env_vals + vec::map(bound, {|x| env_expr(x, expr_ty(bcx, x))}),\n+        bcx, env_vals + vec::map(bound, {|x| env_expr(x, expr_ty(bcx, x))}),\n         ty::ck_box);\n \n     // Make thunk\n     let llthunk = trans_bind_thunk(\n         cx.fcx.ccx, cx.fcx.path, pair_ty, outgoing_fty, args,\n-        cdata_ty, target_info,\n-        alt f_res.tds { some(x) { x.len() } _ { 0u } });\n+        cdata_ty, target_info);\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n@@ -665,8 +641,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                     outgoing_fty: ty::t,\n                     args: [option<@ast::expr>],\n                     cdata_ty: ty::t,\n-                    target_info: target_info,\n-                    n_tps: uint)\n+                    target_info: target_info)\n     -> {val: ValueRef, ty: TypeRef} {\n     let tcx = ccx.tcx;\n     #debug[\"trans_bind_thunk[incoming_fty=%s,outgoing_fty=%s,\\\n@@ -769,18 +744,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // Set up the three implicit arguments to the thunk.\n     let llargs: [ValueRef] = [llretptr, lltargetenv];\n \n-    // Copy in the type parameters.\n-    let {bcx: l_bcx, val: param_record} =\n-        GEP_tup_like(l_bcx, cdata_ty, llcdata,\n-                     [0, abi::closure_body_ty_params]);\n-    let i = 0u;\n-    while i < n_tps {\n-        let dsc = Load(l_bcx, GEPi(l_bcx, param_record, [0, i as int]));\n-        llargs += [dsc];\n-        fcx.lltyparams += [{desc: dsc, vtables: none}];\n-    }\n-\n-    let a: uint = first_tp_arg; // retptr, env come first\n+    let a: uint = first_real_arg; // retptr, env come first\n     let b: int = starting_idx;\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] =\n@@ -838,7 +802,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // in the closure does not know how many type descriptors the function\n     // needs to take.\n     let lltargetty =\n-        type_of_fn_from_ty(ccx, outgoing_fty, 0u);\n+        type_of_fn_from_ty(ccx, outgoing_fty);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n     Call(bcx, lltargetfn, llargs);\n     build_return(bcx);"}, {"sha": "f1fc722879175f241d0c3566d1e41287aabfc12b", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9aa78e34e47074db22777c35bbf6cf2b3f973c40", "patch": "@@ -352,7 +352,7 @@ type block = @{\n };\n \n // First two args are retptr, env\n-const first_tp_arg: uint = 2u;\n+const first_real_arg: uint = 2u;\n \n // FIXME move blocks to a class once those are finished, and simply use\n // option<block> for this."}, {"sha": "1a459f717c76f5f044ea8d059f99bacd29a23f69", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 6, "deletions": 160, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=9aa78e34e47074db22777c35bbf6cf2b3f973c40", "patch": "@@ -74,23 +74,16 @@ fn trans_static_callee(bcx: block, callee_id: ast::node_id,\n      with lval_static_fn(bcx, did, callee_id, substs)}\n }\n \n-fn wrapper_fn_ty(ccx: @crate_ctxt, vtable_ty: TypeRef, fty: ty::t,\n-                 tps: @[ty::param_bounds]) -> {ty: ty::t, llty: TypeRef} {\n-    let bare_fn_ty = type_of_fn_from_ty(ccx, fty, (*tps).len());\n-    let {inputs, output} = llfn_arg_tys(bare_fn_ty);\n-    {ty: fty, llty: T_fn([vtable_ty] + inputs, output)}\n-}\n-\n fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n                        callee_id: ast::node_id, n_method: uint)\n     -> lval_maybe_callee {\n     let bcx = bcx, ccx = bcx.ccx();\n     let fty = node_id_type(bcx, callee_id);\n-    let llfty = type_of::type_of_fn_from_ty(ccx, fty, 0u);\n+    let llfty = type_of::type_of_fn_from_ty(ccx, fty);\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n-    {bcx: bcx, val: mptr, kind: owned, env: env, tds: none}\n+    {bcx: bcx, val: mptr, kind: owned, env: env}\n }\n \n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n@@ -106,7 +99,7 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n     }\n }\n \n-fn method_ty_param_count(ccx: crate_ctxt, m_id: ast::def_id) -> uint {\n+fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id) -> uint {\n     if m_id.crate == ast::local_crate {\n         alt check ccx.tcx.items.get(m_id.node) {\n           ast_map::node_method(m, _, _) { vec::len(m.tps) }\n@@ -128,7 +121,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n         let n_m_tps = method_ty_param_count(ccx, mth_id);\n         let node_substs = node_id_type_params(bcx, callee_id);\n         let ty_substs = impl_substs +\n-            vec::tail_n(node_substs, node_substs.len() - n_m_tps);\n+            vec::tailn(node_substs, node_substs.len() - n_m_tps);\n         ret trans_static_callee(bcx, callee_id, base, mth_id,\n                                 some((ty_substs, sub_origins)));\n       }\n@@ -255,161 +248,14 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n         let fty = ty::substitute_type_params(tcx, substs,\n                                              ty::mk_fn(tcx, im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_vars(fty) {\n-            C_null(type_of_fn_from_ty(ccx, fty, 0u))\n+            C_null(type_of_fn_from_ty(ccx, fty))\n         } else {\n             let m_id = method_with_name(ccx, impl_id, im.ident);\n-            option::get(monomorphic_fn(ccx, m_id, substs, some(vtables)))\n+            monomorphic_fn(ccx, m_id, substs, some(vtables))\n         }\n     }))\n }\n \n-/*\n-fn make_iface_vtable(ccx: @crate_ctxt, pt: path, it: @ast::item) {\n-    let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id))];\n-    let i_did = local_def(it.id), i = 0u;\n-    let ptrs = vec::map(*ty::iface_methods(ccx.tcx, i_did), {|m|\n-        let w = trans_iface_wrapper(ccx, new_pt + [path_name(m.ident)], m, i);\n-        i += 1u;\n-        w\n-    });\n-    let s = link::mangle_internal_name_by_path(\n-        ccx, new_pt + [path_name(\"!vtable\")]);\n-    trans_vtable(ccx, it.id, s, ptrs);\n-}\n-\n-fn dict_is_static(tcx: ty::ctxt, origin: typeck::dict_origin) -> bool {\n-    alt origin {\n-      typeck::dict_static(_, ts, origs) {\n-        vec::all(ts, {|t| !ty::type_has_params(t)}) &&\n-        vec::all(*origs, {|o| dict_is_static(tcx, o)})\n-      }\n-      typeck::dict_iface(_) { true }\n-      _ { false }\n-    }\n-}\n-\n-fn get_dict(bcx: block, origin: typeck::dict_origin) -> result {\n-    let ccx = bcx.ccx();\n-    alt origin {\n-      typeck::dict_static(impl_did, tys, sub_origins) {\n-        if dict_is_static(ccx.tcx, origin) {\n-            ret rslt(bcx, get_static_dict(bcx, origin));\n-        }\n-        let {bcx, ptrs} = get_dict_ptrs(bcx, origin);\n-        let pty = T_ptr(T_i8()), dict_ty = T_array(pty, ptrs.len());\n-        let dict = alloca(bcx, dict_ty), i = 0;\n-        for ptr in ptrs {\n-            Store(bcx, PointerCast(bcx, ptr, pty), GEPi(bcx, dict, [0, i]));\n-            i += 1;\n-        }\n-        dict = Call(bcx, ccx.upcalls.intern_dict,\n-                    [C_uint(ccx, ptrs.len()),\n-                     PointerCast(bcx, dict, T_ptr(T_dict()))]);\n-        rslt(bcx, dict)\n-      }\n-      typeck::dict_param(n_param, n_bound) {\n-        rslt(bcx, option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound])\n-      }\n-      typeck::dict_iface(did) {\n-        ret rslt(bcx, get_static_dict(bcx, origin));\n-      }\n-    }\n-}\n-\n-fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n-    alt origin {\n-      typeck::dict_static(did, ts, origs) {\n-        let d_params = [], orig = 0u;\n-        if ts.len() == 0u { ret @{def: did, params: d_params}; }\n-        let impl_params = ty::lookup_item_type(tcx, did).bounds;\n-        vec::iter2(ts, *impl_params) {|t, bounds|\n-            d_params += [dict_param_ty(t)];\n-            for bound in *bounds {\n-                alt bound {\n-                  ty::bound_iface(_) {\n-                    d_params += [dict_param_dict(dict_id(tcx, origs[orig]))];\n-                    orig += 1u;\n-                  }\n-                  _ {}\n-                }\n-            }\n-        }\n-        @{def: did, params: d_params}\n-      }\n-      typeck::dict_iface(did) {\n-        @{def: did, params: []}\n-      }\n-      _ {\n-        tcx.sess.bug(\"unexpected dict_param in dict_id\");\n-      }\n-    }\n-}\n-\n-fn get_static_dict(bcx: block, origin: typeck::dict_origin)\n-    -> ValueRef {\n-    let ccx = bcx.ccx();\n-    let id = dict_id(ccx.tcx, origin);\n-    alt ccx.dicts.find(id) {\n-      some(d) { ret d; }\n-      none {}\n-    }\n-    let ptrs = C_struct(get_dict_ptrs(bcx, origin).ptrs);\n-    let name = ccx.names(\"dict\");\n-    let gvar = str::as_c_str(name, {|buf|\n-        llvm::LLVMAddGlobal(ccx.llmod, val_ty(ptrs), buf)\n-    });\n-    llvm::LLVMSetGlobalConstant(gvar, lib::llvm::True);\n-    llvm::LLVMSetInitializer(gvar, ptrs);\n-    lib::llvm::SetLinkage(gvar, lib::llvm::InternalLinkage);\n-    let cast = llvm::LLVMConstPointerCast(gvar, T_ptr(T_dict()));\n-    ccx.dicts.insert(id, cast);\n-    cast\n-}\n-\n-fn get_dict_ptrs(bcx: block, origin: typeck::dict_origin)\n-    -> {bcx: block, ptrs: [ValueRef]} {\n-    let ccx = bcx.ccx();\n-    fn get_vtable(ccx: @crate_ctxt, did: ast::def_id) -> ValueRef {\n-        if did.crate == ast::local_crate {\n-            get_item_val(ccx, did.node)\n-        } else {\n-            let name = csearch::get_symbol(ccx.sess.cstore, did);\n-            get_extern_const(ccx.externs, ccx.llmod, name, T_ptr(T_i8()))\n-        }\n-    }\n-    alt origin {\n-      typeck::dict_static(impl_did, tys, sub_origins) {\n-        let impl_params = ty::lookup_item_type(ccx.tcx, impl_did).bounds;\n-        let ptrs = [get_vtable(ccx, impl_did)];\n-        let origin = 0u, bcx = bcx;\n-        vec::iter2(*impl_params, tys) {|param, ty|\n-            let rslt = get_tydesc_simple(bcx, ty, true);\n-            ptrs += [rslt.val];\n-            bcx = rslt.bcx;\n-            for bound in *param {\n-                alt bound {\n-                  ty::bound_iface(_) {\n-                    let res = get_dict(bcx, sub_origins[origin]);\n-                    ptrs += [res.val];\n-                    bcx = res.bcx;\n-                    origin += 1u;\n-                  }\n-                  _ {}\n-                }\n-            }\n-        }\n-        {bcx: bcx, ptrs: ptrs}\n-      }\n-      typeck::dict_iface(did) {\n-        {bcx: bcx, ptrs: [get_vtable(ccx, did)]}\n-      }\n-      _ {\n-        bcx.tcx().sess.bug(\"unexpected dict_param in get_dict_ptrs\");\n-      }\n-    }\n-}\n-}*/\n-\n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> block {\n     if dest == ignore { ret trans_expr(bcx, val, ignore); }"}, {"sha": "55c5ef679a3104b61210fc4d876c8aca45c5c322", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=9aa78e34e47074db22777c35bbf6cf2b3f973c40", "patch": "@@ -206,15 +206,13 @@ fn trans_native_mod(ccx: @crate_ctxt,\n \n     fn build_wrap_fn(ccx: @crate_ctxt,\n                      tys: @c_stack_tys,\n-                     num_tps: uint,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n-                      llwrapfn: ValueRef, llargbundle: ValueRef,\n-                      num_tps: uint) {\n+                      llwrapfn: ValueRef, llargbundle: ValueRef) {\n             let i = 0u, n = vec::len(tys.arg_tys);\n-            let implicit_args = first_tp_arg + num_tps; // ret + env\n+            let implicit_args = first_real_arg; // ret + env\n             while i < n {\n                 let llargval = llvm::LLVMGetParam(\n                     llwrapfn,\n@@ -233,8 +231,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n \n         build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n                        ccx.upcalls.call_shim_on_c_stack,\n-                       bind build_args(_, _ ,_ , _, num_tps),\n-                       build_ret);\n+                       build_args, build_ret);\n     }\n \n     let cc = lib::llvm::CCallConv;\n@@ -249,12 +246,12 @@ fn trans_native_mod(ccx: @crate_ctxt,\n \n     for native_item in native_mod.items {\n       alt native_item.node {\n-        ast::native_item_fn(fn_decl, tps) {\n+        ast::native_item_fn(fn_decl, _) {\n           let id = native_item.id;\n           let tys = c_stack_tys(ccx, id);\n           let llwrapfn = get_item_val(ccx, id);\n           let llshimfn = build_shim_fn(ccx, native_item, tys, cc);\n-          build_wrap_fn(ccx, tys, vec::len(tps), llshimfn, llwrapfn);\n+          build_wrap_fn(ccx, tys, llshimfn, llwrapfn);\n         }\n       }\n     }\n@@ -269,7 +266,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n             ccx, path + [ast_map::path_name(\"__rust_abi\")]);\n-        let llty = type_of_fn_from_ty(ccx, t, 0u);\n+        let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n         trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id,\n                  none);\n@@ -377,13 +374,13 @@ fn abi_of_native_fn(ccx: @crate_ctxt, i: @ast::native_item)\n fn decl_native_fn(ccx: @crate_ctxt, i: @ast::native_item,\n                   pth: ast_map::path) -> ValueRef {\n     alt i.node {\n-      ast::native_item_fn(_, tps) {\n+      ast::native_item_fn(_, _) {\n         let node_type = ty::node_id_to_type(ccx.tcx, i.id);\n         alt abi_of_native_fn(ccx, i) {\n           ast::native_abi_rust_intrinsic {\n             // For intrinsics: link the function directly to the intrinsic\n             // function itself.\n-            let fn_type = type_of_fn_from_ty(ccx, node_type, tps.len());\n+            let fn_type = type_of_fn_from_ty(ccx, node_type);\n             let ri_name = \"rust_intrinsic_\" + native::link_name(i);\n             ccx.item_symbols.insert(i.id, ri_name);\n             get_extern_fn(ccx.externs, ccx.llmod, ri_name,\n@@ -394,7 +391,7 @@ fn decl_native_fn(ccx: @crate_ctxt, i: @ast::native_item,\n             // For true external functions: create a rust wrapper\n             // and link to that.  The rust wrapper will handle\n             // switching to the C stack.\n-            register_fn(ccx, i.span, pth, \"native fn\", tps, i.id)\n+            register_fn(ccx, i.span, pth, \"native fn\", i.id)\n           }\n         }\n       }"}, {"sha": "6d4149fa78ca4e88b1769648b9b5a53257b2d906", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa78e34e47074db22777c35bbf6cf2b3f973c40/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=9aa78e34e47074db22777c35bbf6cf2b3f973c40", "patch": "@@ -18,8 +18,7 @@ fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n     }\n }\n \n-fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n-              output: ty::t, n_ty_params: uint) -> TypeRef {\n+fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg], output: ty::t) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n@@ -28,21 +27,14 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n     // Arg 1: Environment\n     atys += [T_opaque_box_ptr(cx)];\n \n-    // Args >2: ty params, if not acquired via capture...\n-    let i = 0u;\n-    while i < n_ty_params {\n-        atys += [T_ptr(cx.tydesc_type)];\n-        i += 1u;\n-    }\n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, inputs);\n     ret T_fn(atys, llvm::LLVMVoidType());\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t, n_ty_params: uint)\n-    -> TypeRef {\n-    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), n_ty_params)\n+fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n+    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty))\n }\n \n fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n@@ -89,7 +81,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         T_struct(tys)\n       }\n       ty::ty_fn(_) {\n-        T_fn_pair(cx, type_of_fn_from_ty(cx, t, 0u))\n+        T_fn_pair(cx, type_of_fn_from_ty(cx, t))\n       }\n       ty::ty_iface(_, _) { T_opaque_iface(cx) }\n       ty::ty_res(_, sub, tps) {\n@@ -146,20 +138,6 @@ fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     }\n }\n \n-fn type_of_ty_param_bounds_and_ty\n-    (ccx: @crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n-    let t = tpt.ty;\n-    alt ty::get(t).struct {\n-      ty::ty_fn(_) {\n-        ret type_of_fn_from_ty(ccx, t, (*tpt.bounds).len());\n-      }\n-      _ {\n-        // fall through\n-      }\n-    }\n-    type_of(ccx, t)\n-}\n-\n fn type_of_or_i8(ccx: @crate_ctxt, typ: ty::t) -> TypeRef {\n     if check type_has_static_size(ccx, typ) {\n         type_of(ccx, typ)"}]}