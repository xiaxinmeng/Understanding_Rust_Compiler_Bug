{"sha": "386d59dc893375e4386d4f52b79b6c65a593be00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NmQ1OWRjODkzMzc1ZTQzODZkNGY1MmI3OWI2YzY1YTU5M2JlMDA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-18T13:59:51Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:28Z"}, "message": "rustc_trans: use a predictable layout for constant ADTs.", "tree": {"sha": "f14e413dfbe97714ebcfdc9a3fa8d9f31b316d57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f14e413dfbe97714ebcfdc9a3fa8d9f31b316d57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/386d59dc893375e4386d4f52b79b6c65a593be00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/386d59dc893375e4386d4f52b79b6c65a593be00", "html_url": "https://github.com/rust-lang/rust/commit/386d59dc893375e4386d4f52b79b6c65a593be00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/386d59dc893375e4386d4f52b79b6c65a593be00/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f44b0991879f5e379573d3f2fa1d702c923729f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f44b0991879f5e379573d3f2fa1d702c923729f9", "html_url": "https://github.com/rust-lang/rust/commit/f44b0991879f5e379573d3f2fa1d702c923729f9"}], "stats": {"total": 168, "additions": 68, "deletions": 100}, "files": [{"sha": "d800129b0c07fbcf96a3923a1b3afee39407e8dd", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -611,10 +611,7 @@ extern \"C\" {\n     pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n     pub fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n     pub fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n-    // only for isize/vector\n     pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n-    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n \n     // Operations on metadata\n     pub fn LLVMMDStringInContext(C: ContextRef, Str: *const c_char, SLen: c_uint) -> ValueRef;"}, {"sha": "9d693e098cff04dcfd6dab9583438f86a23c1df8", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -198,9 +198,14 @@ fn union_fill(cx: &CrateContext, size: Size, align: Align) -> Type {\n     Type::array(&elem_ty, size / abi_align)\n }\n \n-// Lookup `Struct::memory_index` and double it to account for padding\n+/// Double an index to account for padding.\n+pub fn memory_index_to_gep(index: usize) -> usize {\n+    index * 2\n+}\n+\n+/// Lookup `Struct::memory_index`, double it to account for padding.\n pub fn struct_llfields_index(variant: &layout::Struct, index: usize) -> usize {\n-    (variant.memory_index[index] as usize) << 1\n+    memory_index_to_gep(variant.memory_index[index] as usize)\n }\n \n pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,"}, {"sha": "2b632ba6f26037ffef74d69a373f50e0f25d5c34", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -1150,14 +1150,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub fn add_case(&self, s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n         unsafe {\n-            if llvm::LLVMIsUndef(s) == llvm::True { return; }\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n     pub fn add_incoming_to_phi(&self, phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n         unsafe {\n-            if llvm::LLVMIsUndef(phi) == llvm::True { return; }\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }"}, {"sha": "659ce0f7f9f436199ed805306a3fcd0c67d9c046", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -356,13 +356,13 @@ pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(v: ValueRef, us: &[c_uint])\n-              -> ValueRef {\n+pub fn const_get_elt(v: ValueRef, i: usize) -> ValueRef {\n     unsafe {\n+        let us = &[i as c_uint];\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        debug!(\"const_get_elt(v={:?}, us={:?}, r={:?})\",\n-               Value(v), us, Value(r));\n+        debug!(\"const_get_elt(v={:?}, i={}, r={:?})\",\n+               Value(v), i, Value(r));\n \n         r\n     }\n@@ -402,19 +402,6 @@ pub fn const_to_opt_u128(v: ValueRef, sign_ext: bool) -> Option<u128> {\n     }\n }\n \n-pub fn is_undef(val: ValueRef) -> bool {\n-    unsafe {\n-        llvm::LLVMIsUndef(val) != False\n-    }\n-}\n-\n-#[allow(dead_code)] // potentially useful\n-pub fn is_null(val: ValueRef) -> bool {\n-    unsafe {\n-        llvm::LLVMIsNull(val) != False\n-    }\n-}\n-\n pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,"}, {"sha": "711854e28a899e8c0417782091ae696f7d4a86a1", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -11,7 +11,6 @@\n #![allow(non_upper_case_globals)]\n \n use intrinsics::{self, Intrinsic};\n-use libc;\n use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType};\n@@ -1072,7 +1071,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = const_get_elt(vector, &[i as libc::c_uint]);\n+                let val = const_get_elt(vector, i);\n                 match const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);"}, {"sha": "fa0558faad2574ea2d997bf9d6f6af85e6c23c9b", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 44, "deletions": 60, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -29,7 +29,7 @@ use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u64};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, is_undef};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector};\n use common::const_to_opt_u128;\n use consts;\n use type_of;\n@@ -55,16 +55,15 @@ pub struct Const<'tcx> {\n     pub ty: Ty<'tcx>\n }\n \n-impl<'tcx> Const<'tcx> {\n+impl<'a, 'tcx> Const<'tcx> {\n     pub fn new(llval: ValueRef, ty: Ty<'tcx>) -> Const<'tcx> {\n         Const {\n             llval,\n             ty,\n         }\n     }\n \n-    pub fn from_constint<'a>(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt)\n-    -> Const<'tcx> {\n+    pub fn from_constint(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n         let tcx = ccx.tcx();\n         let (llval, ty) = match *ci {\n             I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n@@ -84,10 +83,10 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     /// Translate ConstVal into a LLVM constant value.\n-    pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                             cv: &ConstVal,\n-                             ty: Ty<'tcx>)\n-                             -> Const<'tcx> {\n+    pub fn from_constval(ccx: &CrateContext<'a, 'tcx>,\n+                         cv: &ConstVal,\n+                         ty: Ty<'tcx>)\n+                         -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n         let val = match *cv {\n             ConstVal::Float(v) => {\n@@ -104,7 +103,7 @@ impl<'tcx> Const<'tcx> {\n                 consts::addr_of(ccx, C_bytes(ccx, v.data), ccx.align_of(ty), \"byte_str\")\n             }\n             ConstVal::Char(c) => C_uint(Type::char(ccx), c as u64),\n-            ConstVal::Function(..) => C_null(llty),\n+            ConstVal::Function(..) => C_undef(llty),\n             ConstVal::Variant(_) |\n             ConstVal::Aggregate(..) |\n             ConstVal::Unevaluated(..) => {\n@@ -117,15 +116,25 @@ impl<'tcx> Const<'tcx> {\n         Const::new(val, ty)\n     }\n \n-    fn get_pair(&self) -> (ValueRef, ValueRef) {\n-        (const_get_elt(self.llval, &[0]),\n-         const_get_elt(self.llval, &[1]))\n+    fn get_field(&self, ccx: &CrateContext<'a, 'tcx>, i: usize) -> ValueRef {\n+        let layout = ccx.layout_of(self.ty);\n+        let ix = if let layout::Univariant { ref variant, .. } = *layout {\n+            adt::struct_llfields_index(variant, i)\n+        } else {\n+            i\n+        };\n+\n+        const_get_elt(self.llval, ix)\n+    }\n+\n+    fn get_pair(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n+        (self.get_field(ccx, 0), self.get_field(ccx, 1))\n     }\n \n-    fn get_fat_ptr(&self) -> (ValueRef, ValueRef) {\n+    fn get_fat_ptr(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n         assert_eq!(abi::FAT_PTR_ADDR, 0);\n         assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        self.get_pair()\n+        self.get_pair(ccx)\n     }\n \n     fn as_lvalue(&self) -> ConstLvalue<'tcx> {\n@@ -136,12 +145,12 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn to_operand<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n+    pub fn to_operand(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n         let llty = type_of::immediate_type_of(ccx, self.ty);\n         let llvalty = val_ty(self.llval);\n \n         let val = if llty == llvalty && common::type_is_imm_pair(ccx, self.ty) {\n-            let (a, b) = self.get_pair();\n+            let (a, b) = self.get_pair(ccx);\n             OperandValue::Pair(a, b)\n         } else if llty == llvalty && common::type_is_immediate(ccx, self.ty) {\n             // If the types match, we can use the value directly.\n@@ -438,7 +447,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let (base, extra) = if !has_metadata {\n                             (base.llval, ptr::null_mut())\n                         } else {\n-                            base.get_fat_ptr()\n+                            base.get_fat_ptr(self.ccx)\n                         };\n                         if self.ccx.statics().borrow().contains_key(&base) {\n                             (Base::Static(base), extra)\n@@ -464,32 +473,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        // Extract field of struct-like const, skipping our alignment padding.\n-                        let mut ix = field.index();\n-                        let layout = self.ccx.layout_of(tr_base.ty);\n-                        if let layout::Univariant { ref variant, .. } = *layout {\n-                            ix = variant.memory_index[ix] as usize;\n-                        }\n-\n-                        // Get the ix-th non-undef element of the struct.\n-                        let mut real_ix = 0; // actual position in the struct\n-                        let mut ix = ix; // logical index relative to real_ix\n-                        let mut llprojected;\n-                        loop {\n-                            loop {\n-                                llprojected = const_get_elt(base.llval, &[real_ix]);\n-                                if !is_undef(llprojected) {\n-                                    break;\n-                                }\n-                                real_ix = real_ix + 1;\n-                            }\n-                            if ix == 0 {\n-                                break;\n-                            }\n-                            ix = ix - 1;\n-                            real_ix = real_ix + 1;\n-                        }\n-\n+                        let llprojected = base.get_field(self.ccx, field.index());\n                         let llextra = if !has_metadata {\n                             ptr::null_mut()\n                         } else {\n@@ -510,7 +494,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         // Produce an undef instead of a LLVM assertion on OOB.\n                         let len = common::const_to_uint(tr_base.len(self.ccx));\n                         let llelem = if iv < len as u128 {\n-                            const_get_elt(base.llval, &[iv as u32])\n+                            const_get_elt(base.llval, iv as usize)\n                         } else {\n                             C_undef(type_of::type_of(self.ccx, projected_ty))\n                         };\n@@ -680,7 +664,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             // to use a different vtable. In that case, we want to\n                             // load out the original data pointer so we can repackage\n                             // it.\n-                            let (base, extra) = operand.get_fat_ptr();\n+                            let (base, extra) = operand.get_fat_ptr(self.ccx);\n                             (base, Some(extra))\n                         } else {\n                             (operand.llval, None)\n@@ -755,7 +739,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let ll_cast_ty = type_of::immediate_type_of(self.ccx, cast_ty);\n                         let ll_from_ty = type_of::immediate_type_of(self.ccx, operand.ty);\n                         if common::type_is_fat_ptr(self.ccx, operand.ty) {\n-                            let (data_ptr, meta_ptr) = operand.get_fat_ptr();\n+                            let (data_ptr, meta_ptr) = operand.get_fat_ptr(self.ccx);\n                             if common::type_is_fat_ptr(self.ccx, cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();\n                                 let ll_fft = ll_from_ty.field_types();\n@@ -833,8 +817,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                 match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n                     Some((llval, of)) => {\n-                        let llof = C_bool(self.ccx, of);\n-                        Const::new(C_struct(self.ccx, &[llval, llof], false), binop_ty)\n+                        trans_const_adt(self.ccx, binop_ty, &mir::AggregateKind::Tuple, &[\n+                            Const::new(llval, val_ty),\n+                            Const::new(C_bool(self.ccx, of), tcx.types.bool)\n+                        ])\n                     }\n                     None => {\n                         span_bug!(span, \"{:?} got non-integer operands: {:?} and {:?}\",\n@@ -1142,13 +1128,10 @@ fn trans_const_adt<'a, 'tcx>(\n         }\n         layout::UntaggedUnion { ref variants, .. }=> {\n             assert_eq!(variant_index, 0);\n-            let mut contents = vec![vals[0].llval];\n-\n-            let offset = ccx.size_of(vals[0].ty);\n-            let size = variants.stride();\n-            if offset != size {\n-                contents.push(padding(ccx, size - offset));\n-            }\n+            let contents = [\n+                vals[0].llval,\n+                padding(ccx, variants.stride() - ccx.size_of(vals[0].ty))\n+            ];\n \n             Const::new(C_struct(ccx, &contents, variants.packed), t)\n         }\n@@ -1203,19 +1186,20 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let parts = st.field_index_by_increasing_offset().map(|i| {\n         (vals[i], st.offsets[i])\n     });\n+    let mut first_field = true;\n     for (val, target_offset) in parts {\n-        if offset < target_offset {\n+        if first_field {\n+            first_field = false;\n+            assert_eq!(target_offset.bytes(), 0);\n+        } else {\n             cfields.push(padding(ccx, target_offset - offset));\n         }\n-        assert!(!is_undef(val.llval));\n         cfields.push(val.llval);\n         offset = target_offset + ccx.size_of(val.ty);\n     }\n \n     let size = layout.size(ccx);\n-    if offset < size {\n-        cfields.push(padding(ccx, size - offset));\n-    }\n+    cfields.push(padding(ccx, size - offset));\n \n     Const::new(C_struct(ccx, &cfields, st.packed), layout.ty)\n }"}, {"sha": "a0cab01b007d2ca7f4e0300ab0b2a5bec1a90224", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -252,7 +252,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n     // Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n     fn gepi_struct_llfields_path(self, bcx: &Builder, discrfield: &layout::FieldPath) -> ValueRef {\n-        let path = discrfield.iter().map(|&i| (i as usize) << 1).collect::<Vec<_>>();\n+        let path = discrfield.iter().map(|&i| {\n+            adt::memory_index_to_gep(i as usize)\n+        }).collect::<Vec<_>>();\n         bcx.gepi(self.llval, &path)\n     }\n "}, {"sha": "60f585f4bd9278b5102c7e8fc57d946e8a8ec0c9", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use adt;\n use base;\n-use common::{self, CrateContext, C_null};\n+use common::{self, CrateContext, C_undef};\n use builder::Builder;\n use value::Value;\n use type_of;\n@@ -93,9 +93,9 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 (0, 1)\n             };\n             let fields = llty.field_types();\n-            OperandValue::Pair(C_null(fields[ix0]), C_null(fields[ix1]))\n+            OperandValue::Pair(C_undef(fields[ix0]), C_undef(fields[ix1]))\n         } else {\n-            OperandValue::Immediate(C_null(llty))\n+            OperandValue::Immediate(C_undef(llty))\n         };\n         OperandRef {\n             val,\n@@ -134,14 +134,10 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n             // Reconstruct the immediate aggregate.\n             let llty = type_of::type_of(bcx.ccx, self.ty);\n-            let mut llpair = common::C_undef(llty);\n+            let mut llpair = C_undef(llty);\n             let elems = [a, b];\n             for i in 0..2 {\n-                let mut elem = elems[i];\n-                // Extend boolean i1's to i8.\n-                if common::val_ty(elem) == Type::i1(bcx.ccx) {\n-                    elem = bcx.zext(elem, Type::i8(bcx.ccx));\n-                }\n+                let elem = base::from_immediate(bcx, elems[i]);\n                 let layout = bcx.ccx.layout_of(self.ty);\n                 let i = if let Layout::Univariant { ref variant, .. } = *layout {\n                     adt::struct_llfields_index(variant, i)"}, {"sha": "a75b8f3992d0795ea76697d761dd7f596dfbf80e", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -54,14 +54,14 @@ pub fn inline_enum_const() -> E<i8, i16> {\n #[no_mangle]\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: load {{.*}} bitcast ({ i16, i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+// CHECK: load {{.*}} bitcast ({ i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n     *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n pub fn high_align_const() -> E<i16, i32> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: load {{.*}} bitcast ({ i16, i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+// CHECK: load {{.*}} bitcast ({ i16, [0 x i8], i16, [4 x i8] }** [[LOW_HIGH_REF]]\n     *&E::A(0)\n }"}, {"sha": "1879002e7f3d7cb2750ca73b9aad7aedda4a8347", "filename": "src/test/codegen/link_section.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Ftest%2Fcodegen%2Flink_section.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386d59dc893375e4386d4f52b79b6c65a593be00/src%2Ftest%2Fcodegen%2Flink_section.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flink_section.rs?ref=386d59dc893375e4386d4f52b79b6c65a593be00", "patch": "@@ -22,12 +22,12 @@ pub enum E {\n     B(f32)\n }\n \n-// CHECK: @VAR2 = constant {{.*}} { i32 0, i32 666 }, section \".test_two\"\n+// CHECK: @VAR2 = constant {{.*}}, section \".test_two\"\n #[no_mangle]\n #[link_section = \".test_two\"]\n pub static VAR2: E = E::A(666);\n \n-// CHECK: @VAR3 = constant {{.*}} { i32 1, float 1.000000e+00 }, section \".test_three\"\n+// CHECK: @VAR3 = constant {{.*}}, section \".test_three\"\n #[no_mangle]\n #[link_section = \".test_three\"]\n pub static VAR3: E = E::B(1.);"}]}