{"sha": "4ff8e15128f90d4e9e57897c48280c6f82bb8343", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZjhlMTUxMjhmOTBkNGU5ZTU3ODk3YzQ4MjgwYzZmODJiYjgzNDM=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-07-28T23:24:50Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-29T03:30:29Z"}, "message": "Move notification-messages out into their own file and unify into notify_message, make them use proxies, cache task proxies in dom.", "tree": {"sha": "86c3808e729b4f596c3c23e228738d3d25b108bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86c3808e729b4f596c3c23e228738d3d25b108bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ff8e15128f90d4e9e57897c48280c6f82bb8343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff8e15128f90d4e9e57897c48280c6f82bb8343", "html_url": "https://github.com/rust-lang/rust/commit/4ff8e15128f90d4e9e57897c48280c6f82bb8343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ff8e15128f90d4e9e57897c48280c6f82bb8343/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "defd8a66eade4cb11960cf6de2b45c2f42ec3388", "url": "https://api.github.com/repos/rust-lang/rust/commits/defd8a66eade4cb11960cf6de2b45c2f42ec3388", "html_url": "https://github.com/rust-lang/rust/commit/defd8a66eade4cb11960cf6de2b45c2f42ec3388"}], "stats": {"total": 311, "additions": 246, "deletions": 65}, "files": [{"sha": "9bd6ed3cffa0369c9f6c188d6530f11cf1dcb6ac", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=4ff8e15128f90d4e9e57897c48280c6f82bb8343", "patch": "@@ -259,6 +259,7 @@ RUNTIME_CS := rt/sync/spin_lock.cpp \\\n               rt/rust_chan.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_log.cpp \\\n+              rt/rust_message.cpp \\\n               rt/rust_timer.cpp \\\n               rt/circular_buffer.cpp \\\n               rt/isaac/randport.cpp\n@@ -272,6 +273,7 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/rust_dom.h \\\n                rt/rust_task.h \\\n                rt/rust_proxy.h \\\n+               rt/rust_message.h \\\n                rt/circular_buffer.h\n \n RUNTIME_INCS := -Irt/isaac -Irt/uthash"}, {"sha": "4d1917f4b51ee47b38891b5e9c0208d1bf0e2367", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=4ff8e15128f90d4e9e57897c48280c6f82bb8343", "patch": "@@ -4,23 +4,6 @@\n \n template class ptr_vec<rust_task>;\n \n-rust_message::rust_message(rust_dom *dom) : dom(dom) {\n-\n-}\n-\n-void rust_message::process() {\n-\n-}\n-\n-kill_task_message::kill_task_message(rust_dom *dom, rust_task *task) :\n-        rust_message(dom), _task(task) {\n-\n-}\n-\n-void kill_task_message::process() {\n-    _task->ref_count--;\n-    _task->kill();\n-}\n \n rust_dom::rust_dom(rust_srv *srv, rust_crate const *root_crate) :\n     interrupt_flag(0),\n@@ -54,7 +37,23 @@ del_all_tasks(rust_dom *dom, ptr_vec<rust_task> *v) {\n     }\n }\n \n+void\n+rust_dom::delete_proxies() {\n+    rust_task *task;\n+    rust_proxy<rust_task> *task_proxy;\n+    while (_task_proxies.pop(&task, &task_proxy)) {\n+        log(rust_log::TASK, \"deleting proxy %\" PRIxPTR\n+                            \" in dom %\" PRIxPTR, task_proxy, task_proxy->dom);\n+        delete task_proxy;\n+    }\n+}\n+\n rust_dom::~rust_dom() {\n+    log(rust_log::MEM | rust_log::DOM,\n+             \"~rust_dom 0x%\" PRIxPTR, (uintptr_t)this);\n+\n+    log(rust_log::TASK, \"deleting all proxies\");\n+    delete_proxies();\n     log(rust_log::TASK, \"deleting all running tasks\");\n     del_all_tasks(this, &running_tasks);\n     log(rust_log::TASK, \"deleting all blocked tasks\");\n@@ -126,8 +125,8 @@ void *\n rust_dom::malloc(size_t sz) {\n     void *p = srv->malloc(sz);\n     I(this, p);\n-    log(rust_log::MEM, \"rust_dom::malloc(%d) -> 0x%\" PRIxPTR,\n-        sz, p);\n+    log(rust_log::MEM, \"0x%\" PRIxPTR \" rust_dom::malloc(%d) -> 0x%\" PRIxPTR,\n+        (uintptr_t) this, sz, p);\n     return p;\n }\n \n@@ -219,6 +218,8 @@ rust_dom::reap_dead_tasks() {\n         rust_task *task = dead_tasks[i];\n         if (task->ref_count == 0) {\n             I(this, !task->waiting_tasks.length());\n+            I(this, task->tasks_waiting_to_join.is_empty());\n+\n             dead_tasks.swap_delete(task);\n             log(rust_log::TASK,\n                 \"deleting unreferenced dead task 0x%\" PRIxPTR, task);\n@@ -229,18 +230,20 @@ rust_dom::reap_dead_tasks() {\n     }\n }\n \n-\n /**\n  * Enqueues a message in this domain's incoming message queue. It's the\n  * responsibility of the receiver to free the message once it's processed.\n  */\n void rust_dom::send_message(rust_message *message) {\n-    log(rust_log::COMM, \"enqueueing message 0x%\" PRIxPTR\n+    log(rust_log::COMM, \"==> enqueueing \\\"%s\\\" 0x%\" PRIxPTR\n                         \" in queue 0x%\" PRIxPTR,\n+                        message->label,\n                         message,\n                         &_incoming_message_queue);\n+    A(this, message->dom == this, \"Message owned by non-local domain.\");\n     _incoming_message_queue.enqueue(message);\n     _incoming_message_pending.signal();\n+    _progress.signal();\n }\n \n /**\n@@ -249,17 +252,24 @@ void rust_dom::send_message(rust_message *message) {\n void rust_dom::drain_incoming_message_queue() {\n     rust_message *message;\n     while ((message = (rust_message *) _incoming_message_queue.dequeue())) {\n-        log(rust_log::COMM, \"read 0x%\" PRIxPTR\n-                            \" from queue 0x%\" PRIxPTR,\n-                            message,\n-                            &_incoming_message_queue);\n-        log(rust_log::COMM, \"processing incoming message 0x%\" PRIxPTR,\n-                            message);\n+        log(rust_log::COMM, \"<== processing incoming message \\\"%s\\\" 0x%\"\n+            PRIxPTR, message->label, message);\n         message->process();\n         delete message;\n     }\n }\n \n+rust_proxy<rust_task> *\n+rust_dom::get_task_proxy(rust_task *task) {\n+    rust_proxy<rust_task> *proxy = NULL;\n+    if (_task_proxies.get(task, &proxy)) {\n+        return proxy;\n+    }\n+    log(rust_log::COMM, \"no proxy for 0x%\" PRIxPTR, task);\n+    proxy = new (this) rust_proxy<rust_task> (this, task, false);\n+    _task_proxies.put(task, proxy);\n+    return proxy;\n+}\n /**\n  * Schedules a running task for execution. Only running tasks can be\n  * activated.  Blocked tasks have to be unblocked before they can be\n@@ -324,6 +334,8 @@ rust_dom::start_main_loop()\n     logptr(\"exit-task glue\", root_crate->get_exit_task_glue());\n \n     while (n_live_tasks() > 0) {\n+        drain_incoming_message_queue();\n+\n         rust_task *scheduled_task = schedule_task();\n \n         // If we cannot schedule a task because all other live tasks\n@@ -362,8 +374,6 @@ rust_dom::start_main_loop()\n           (uintptr_t) &scheduled_task->stk->data[0]);\n         I(this, scheduled_task->rust_sp < scheduled_task->stk->limit);\n \n-        drain_incoming_message_queue();\n-\n         reap_dead_tasks();\n     }\n "}, {"sha": "2f16297238caa465c0392daa7c227acf1991b39a", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=4ff8e15128f90d4e9e57897c48280c6f82bb8343", "patch": "@@ -6,22 +6,10 @@\n #define RUST_DOM_H\n \n #include \"sync/lock_free_queue.h\"\n+#include \"util/hash_map.h\"\n \n-class rust_message : public lock_free_queue_node,\n-                     public dom_owned<rust_message> {\n-public:\n-    rust_dom *dom;\n-    rust_message(rust_dom *dom);\n-    virtual ~rust_message() {}\n-    virtual void process();\n-};\n-\n-class kill_task_message : public rust_message {\n-    rust_task *_task;\n-public:\n-    kill_task_message(rust_dom *dom, rust_task *task);\n-    void process();\n-};\n+#include \"rust_proxy.h\"\n+#include \"rust_message.h\"\n \n struct rust_dom\n {\n@@ -48,6 +36,8 @@ struct rust_dom\n \n     condition_variable _progress;\n \n+    hash_map<rust_task *, rust_proxy<rust_task> *> _task_proxies;\n+\n     // Incoming messages from other domains.\n     condition_variable _incoming_message_pending;\n     lock_free_queue _incoming_message_queue;\n@@ -74,6 +64,8 @@ struct rust_dom\n \n     void send_message(rust_message *message);\n     void drain_incoming_message_queue();\n+    rust_proxy<rust_task> *get_task_proxy(rust_task *task);\n+    void delete_proxies();\n \n #ifdef __WIN32__\n     void win32_require(LPCTSTR fn, BOOL ok);"}, {"sha": "22f8ffe51b15e08c03faf607916ca7d45c228bb0", "filename": "src/rt/rust_message.cpp", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=4ff8e15128f90d4e9e57897c48280c6f82bb8343", "patch": "@@ -0,0 +1,75 @@\n+#include \"rust_internal.h\"\n+#include \"rust_message.h\"\n+\n+rust_message::\n+rust_message(const char* label, rust_task *source, rust_task *target) :\n+             dom(target->dom), label(label),\n+             _source(source),\n+             _target(target) {\n+}\n+\n+rust_message::~rust_message() {\n+}\n+\n+void rust_message::process() {\n+    I(dom, false);\n+}\n+\n+rust_proxy<rust_task> *\n+rust_message::get_source_proxy() {\n+    return dom->get_task_proxy(_source);\n+}\n+\n+notify_message::\n+notify_message(notification_type type, const char* label,\n+               rust_task *source,\n+               rust_task *target) :\n+               rust_message(label, source, target), type(type) {\n+}\n+\n+/**\n+ * Sends a message to the target task via a proxy. The message is allocated\n+ * in the target task domain along with a proxy which points back to the\n+ * source task.\n+ */\n+void notify_message::\n+send(notification_type type, const char* label, rust_task *source,\n+     rust_proxy<rust_task> *target) {\n+    rust_task *target_task = target->delegate();\n+    rust_dom *target_domain = target_task->dom;\n+    notify_message *message = new (target_domain)\n+        notify_message(type, label, source, target_task);\n+    target_domain->send_message(message);\n+}\n+\n+void notify_message::process() {\n+    rust_task *task = _target;\n+    switch (type) {\n+    case KILL:\n+        task->ref_count--;\n+        task->kill();\n+        break;\n+    case JOIN: {\n+        if (task->dead() == false) {\n+            task->tasks_waiting_to_join.append(get_source_proxy());\n+        } else {\n+            send(WAKEUP, \"wakeup\", task, get_source_proxy());\n+        }\n+        break;\n+    }\n+    case WAKEUP:\n+        task->wakeup(get_source_proxy()->delegate());\n+        break;\n+    }\n+}\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "f0c6bc0ab4b5b11f8acf95fde88d19f97887329a", "filename": "src/rt/rust_message.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_message.h", "raw_url": "https://github.com/rust-lang/rust/raw/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_message.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.h?ref=4ff8e15128f90d4e9e57897c48280c6f82bb8343", "patch": "@@ -0,0 +1,72 @@\n+#ifndef RUST_MESSAGE_H\n+#define RUST_MESSAGE_H\n+\n+/**\n+ * Rust messages are used for inter-thread communication. They are enqueued\n+ * and allocated in the target domain.\n+ */\n+\n+/**\n+ * Abstract base class for all message types.\n+ */\n+class rust_message : public lock_free_queue_node,\n+                     public dom_owned<rust_message> {\n+public:\n+    rust_dom *dom;\n+    const char* label;\n+private:\n+    rust_task *_source;\n+protected:\n+    rust_task *_target;\n+public:\n+    rust_message(const char* label, rust_task *source, rust_task *target);\n+    virtual ~rust_message();\n+\n+    /**\n+     * We can only access the source task through a proxy, so create one\n+     * on demand if we need it.\n+     */\n+    rust_proxy<rust_task> *get_source_proxy();\n+\n+    /**\n+     * Processes the message in the target domain thread.\n+     */\n+    virtual void process();\n+};\n+\n+/**\n+ * Notify messages are simple argument-less messages.\n+ */\n+class notify_message : public rust_message {\n+public:\n+    enum notification_type {\n+        KILL, JOIN, WAKEUP\n+    };\n+\n+    const notification_type type;\n+\n+    notify_message(notification_type type, const char* label,\n+                   rust_task *source, rust_task *target);\n+\n+    void process();\n+\n+    /**\n+     * This code executes in the sending domain's thread.\n+     */\n+    static void\n+    send(notification_type type, const char* label, rust_task *source,\n+         rust_proxy<rust_task> *target);\n+};\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//\n+\n+#endif /* RUST_MESSAGE_H */"}, {"sha": "b3caac252b95666ebc88a039d5057bd83fc909e7", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=4ff8e15128f90d4e9e57897c48280c6f82bb8343", "patch": "@@ -385,6 +385,24 @@ rust_task::notify_waiting_tasks()\n     }\n }\n \n+void\n+rust_task::notify_tasks_waiting_to_join() {\n+    while (tasks_waiting_to_join.is_empty() == false) {\n+        log(rust_log::ALL, \"notify_tasks_waiting_to_join: %d\",\n+            tasks_waiting_to_join.size());\n+        maybe_proxy<rust_task> *waiting_task = tasks_waiting_to_join.pop();\n+        if (waiting_task->is_proxy()) {\n+            notify_message::send(notify_message::WAKEUP, \"wakeup\",\n+                                 this, waiting_task->as_proxy());\n+        } else {\n+            rust_task *task = waiting_task->delegate();\n+            if (task->dead() == false) {\n+                task->wakeup(this);\n+            }\n+        }\n+    }\n+}\n+\n uintptr_t\n rust_task::get_fp() {\n     // sp in any suspended task points to the last callee-saved reg on"}, {"sha": "34553b6c1043d4b1690c7b488db7b34425993346", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=4ff8e15128f90d4e9e57897c48280c6f82bb8343", "patch": "@@ -4,6 +4,10 @@\n \n #ifndef RUST_TASK_H\n #define RUST_TASK_H\n+\n+#include \"util/array_list.h\"\n+\n+\n struct\n rust_task : public maybe_proxy<rust_task>,\n             public dom_owned<rust_task>\n@@ -35,6 +39,9 @@ rust_task : public maybe_proxy<rust_task>,\n     // that location before waking us up.\n     uintptr_t* rendezvous_ptr;\n \n+    // List of tasks waiting for this task to finish.\n+    array_list<maybe_proxy<rust_task> *> tasks_waiting_to_join;\n+\n     rust_alarm alarm;\n \n     rust_task(rust_dom *dom,\n@@ -95,6 +102,7 @@ rust_task : public maybe_proxy<rust_task>,\n \n     // Notify tasks waiting for us that we are about to die.\n     void notify_waiting_tasks();\n+    void notify_tasks_waiting_to_join();\n \n     uintptr_t get_fp();\n     uintptr_t get_previous_fp(uintptr_t fp);"}, {"sha": "42203becb5803e4c1c78c445b6856b13289687e2", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4ff8e15128f90d4e9e57897c48280c6f82bb8343/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=4ff8e15128f90d4e9e57897c48280c6f82bb8343", "patch": "@@ -122,19 +122,25 @@ extern \"C\" CDECL void upcall_yield(rust_task *task) {\n }\n \n extern \"C\" CDECL void\n-upcall_join(rust_task *task, maybe_proxy<rust_task> *proxy) {\n+upcall_join(rust_task *task, maybe_proxy<rust_task> *target) {\n     LOG_UPCALL_ENTRY(task);\n     task->log(rust_log::UPCALL | rust_log::COMM,\n-                  \"join proxy 0x%\" PRIxPTR \" -> task = 0x%\" PRIxPTR,\n-                  proxy, proxy->delegate());\n-\n-    rust_task *other = proxy->delegate();\n-\n-    // If the other task is already dying, we don't have to wait for it.\n-    if (!other->dead()) {\n-        other->waiting_tasks.push(&task->alarm);\n-        task->block(other);\n+              \"target: 0x%\" PRIxPTR \", task: 0x%\" PRIxPTR,\n+              target, target->delegate());\n+\n+    rust_task *target_task = target->delegate();\n+    if (target->is_proxy()) {\n+        notify_message::\n+        send(notify_message::JOIN, \"join\", task, target->as_proxy());\n+        task->block(target_task);\n         task->yield(2);\n+    } else {\n+        // If the other task is already dying, we don't have to wait for it.\n+        if (target_task->dead() == false) {\n+            target_task->tasks_waiting_to_join.push(task);\n+            task->block(target_task);\n+            task->yield(2);\n+        }\n     }\n }\n \n@@ -194,22 +200,20 @@ extern \"C\" CDECL void upcall_fail(rust_task *task, char const *expr,\n  * Called whenever a task's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_kill(rust_task *task, maybe_proxy<rust_task> *target_proxy) {\n+upcall_kill(rust_task *task, maybe_proxy<rust_task> *target) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_task *target_task = target_proxy->delegate();\n-    if (target_proxy != target_task) {\n-        task->dom->free(target_proxy);\n-    }\n+    rust_task *target_task = target->delegate();\n+\n     task->log(rust_log::UPCALL | rust_log::TASK,\n               \"kill task 0x%\" PRIxPTR \", ref count %d\",\n               target_task,\n               target_task->ref_count);\n \n-    if (requires_message_passing(task, target_task)) {\n-        rust_dom *target_domain = target_task->dom;\n-        target_domain->send_message(\n-                new (target_domain)\n-                kill_task_message(target_domain, target_task));\n+    if (target->is_proxy()) {\n+        notify_message::\n+        send(notify_message::KILL, \"kill\", task, target->as_proxy());\n+        // The proxy ref_count dropped to zero, delete it here.\n+        delete target->as_proxy();\n     } else {\n         target_task->kill();\n     }\n@@ -224,7 +228,7 @@ upcall_exit(rust_task *task) {\n     task->log(rust_log::UPCALL | rust_log::TASK,\n               \"task ref_count: %d\", task->ref_count);\n     task->die();\n-    task->notify_waiting_tasks();\n+    task->notify_tasks_waiting_to_join();\n     task->yield(1);\n }\n "}]}