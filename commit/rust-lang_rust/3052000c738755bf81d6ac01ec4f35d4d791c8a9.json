{"sha": "3052000c738755bf81d6ac01ec4f35d4d791c8a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNTIwMDBjNzM4NzU1YmY4MWQ2YWMwMWVjNGYzNWQ0ZDc5MWM4YTk=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-04-07T09:13:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-07T09:13:44Z"}, "message": "Merge pull request #1649 from ensch/master\n\nFix for rustc 1.18.0-nightly (5c94997b6 2017-03-30)", "tree": {"sha": "44928f571e53b88146f8745594dec47d2c4c64cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44928f571e53b88146f8745594dec47d2c4c64cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3052000c738755bf81d6ac01ec4f35d4d791c8a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3052000c738755bf81d6ac01ec4f35d4d791c8a9", "html_url": "https://github.com/rust-lang/rust/commit/3052000c738755bf81d6ac01ec4f35d4d791c8a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3052000c738755bf81d6ac01ec4f35d4d791c8a9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60f4863cbeb33c05eb5d85b95572d2fe9143c0ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/60f4863cbeb33c05eb5d85b95572d2fe9143c0ce", "html_url": "https://github.com/rust-lang/rust/commit/60f4863cbeb33c05eb5d85b95572d2fe9143c0ce"}, {"sha": "13408e2ac8a528c091f23cd692e6755d96dccdfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/13408e2ac8a528c091f23cd692e6755d96dccdfa", "html_url": "https://github.com/rust-lang/rust/commit/13408e2ac8a528c091f23cd692e6755d96dccdfa"}], "stats": {"total": 308, "additions": 143, "deletions": 165}, "files": [{"sha": "1c4ac3c6261c40128e942e21687be1e291a6a53e", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -215,7 +215,7 @@ fn is_relevant_expr(tcx: ty::TyCtxt, tables: &ty::TypeckTables, expr: &Expr) ->\n }\n \n fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n-    if in_macro(cx, span) {\n+    if in_macro(span) {\n         return;\n     }\n "}, {"sha": "cabffa8e9697578e4954b336138f2826d896d39f", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                         if let Some(ref ex) = block.expr {\n                             // don't dig into the expression here, just suggest that they remove\n                             // the block\n-                            if in_macro(cx, expr.span) || differing_macro_contexts(expr.span, ex.span) {\n+                            if in_macro(expr.span) || differing_macro_contexts(expr.span, ex.span) {\n                                 return;\n                             }\n                             span_help_and_lint(cx,\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                         }\n                     } else {\n                         let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n-                        if in_macro(cx, span) || differing_macro_contexts(expr.span, span) {\n+                        if in_macro(span) || differing_macro_contexts(expr.span, span) {\n                             return;\n                         }\n                         // move block higher"}, {"sha": "fd357feab6b7e713f1e6914b01885d8108f52c1d", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n \n     fn run(&mut self, e: &'v Expr) -> Result<Bool, String> {\n         // prevent folding of `cfg!` macros and the like\n-        if !in_macro(self.cx, e.span) {\n+        if !in_macro(e.span) {\n             match e.node {\n                 ExprUnary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n                 ExprBinary(binop, ref lhs, ref rhs) => {\n@@ -394,7 +394,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n-        if in_macro(self.cx, e.span) {\n+        if in_macro(e.span) {\n             return;\n         }\n         match e.node {"}, {"sha": "06db5319d214df3ce04871e763b4565426e350a2", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -78,7 +78,7 @@ impl LintPass for CollapsibleIf {\n \n impl EarlyLintPass for CollapsibleIf {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n-        if !in_macro(cx, expr.span) {\n+        if !in_macro(expr.span) {\n             check_if(cx, expr)\n         }\n     }\n@@ -103,8 +103,8 @@ fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n     if_let_chain! {[\n         let ast::ExprKind::Block(ref block) = else_.node,\n-        let Some(ref else_) = expr_block(block),\n-        !in_macro(cx, else_.span),\n+        let Some(else_) = expr_block(block),\n+        !in_macro(else_.span),\n     ], {\n         match else_.node {\n             ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => {\n@@ -125,7 +125,7 @@ fn check_collapsible_no_if_let(cx: &EarlyContext, expr: &ast::Expr, check: &ast:\n         let Some(inner) = expr_block(then),\n         let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node,\n     ], {\n-        if expr.span.expn_id != inner.span.expn_id {\n+        if expr.span.ctxt != inner.span.ctxt {\n             return;\n         }\n         span_lint_and_then(cx, COLLAPSIBLE_IF, expr.span, \"this if statement can be collapsed\", |db| {"}, {"sha": "316a7afdc3afc838efb8f6862f12bf8bbc042533", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -313,10 +313,10 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn ifthenelse(&mut self, cond: &Expr, then: &Block, otherwise: &Option<P<Expr>>) -> Option<Constant> {\n+    fn ifthenelse(&mut self, cond: &Expr, then: &P<Expr>, otherwise: &Option<P<Expr>>) -> Option<Constant> {\n         if let Some(Constant::Bool(b)) = self.expr(cond) {\n             if b {\n-                self.block(then)\n+                self.expr(&**then)\n             } else {\n                 otherwise.as_ref().and_then(|expr| self.expr(expr))\n             }"}, {"sha": "ea7bbfe81e02b4c6ebc83fb24dca5bba2c75389c", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -111,7 +111,7 @@ impl LintPass for CopyAndPaste {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if !in_macro(cx, expr.span) {\n+        if !in_macro(expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(&Expr { node: ExprIf(_, _, Some(ref else_expr)), .. }) = get_parent_expr(cx, expr) {\n                 if else_expr.id == expr.id {\n@@ -223,11 +223,15 @@ fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n /// `if a { c } else if b { d } else { e }`.\n fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n     let mut conds = SmallVector::new();\n-    let mut blocks = SmallVector::new();\n+    let mut blocks : SmallVector<&Block> = SmallVector::new();\n \n-    while let ExprIf(ref cond, ref then_block, ref else_expr) = expr.node {\n+    while let ExprIf(ref cond, ref then_expr, ref else_expr) = expr.node {\n         conds.push(&**cond);\n-        blocks.push(&**then_block);\n+        if let ExprBlock(ref block) = then_expr.node {\n+            blocks.push(block);\n+        } else {\n+            panic!(\"ExprIf node is not an ExprBlock\");\n+        }\n \n         if let Some(ref else_expr) = *else_expr {\n             expr = else_expr;\n@@ -311,10 +315,10 @@ fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Option<(&T, &T)>\n         return None;\n     } else if exprs.len() == 2 {\n         return if eq(&exprs[0], &exprs[1]) {\n-            Some((&exprs[0], &exprs[1]))\n-        } else {\n-            None\n-        };\n+                   Some((&exprs[0], &exprs[1]))\n+               } else {\n+                   None\n+               };\n     }\n \n     let mut map: HashMap<_, Vec<&_>> = HashMap::with_capacity(exprs.len());"}, {"sha": "ed836af4403bb07b1545c7fb0e17630878bd2ead", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -42,7 +42,7 @@ impl LintPass for CyclomaticComplexity {\n \n impl CyclomaticComplexity {\n     fn check<'a, 'tcx: 'a>(&mut self, cx: &'a LateContext<'a, 'tcx>, body: &'tcx Body, span: Span) {\n-        if in_macro(cx, span) {\n+        if in_macro(span) {\n             return;\n         }\n "}, {"sha": "06e9268d22a183337e84fa8ada56e522c0b8ba2c", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, NestedVisitorMap};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use rustc::lint::*;\n use syntax::codemap::Span;\n use utils::SpanlessEq;\n@@ -46,8 +46,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n-                    let sole_expr = else_block.is_none() &&\n-                                    ((then_block.expr.is_some() as usize) + then_block.stmts.len() == 1);\n+                    let sole_expr =  {\n+                        else_block.is_none() &&\n+                        if let ExprBlock(ref then_block) = then_block.node {\n+                            (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n+                        }  else {\n+                            true\n+                        }\n+                    };\n \n                     let mut visitor = InsertVisitor {\n                         cx: cx,\n@@ -58,7 +64,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n                         sole_expr: sole_expr,\n                     };\n \n-                    walk_block(&mut visitor, then_block);\n+                    walk_expr(&mut visitor, &**then_block);\n                 }\n             } else if let Some(ref else_block) = *else_block {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {"}, {"sha": "16a2e0217239ff76492ea4183796092c1a156401", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -228,7 +228,7 @@ impl EarlyLintPass for EnumVariantNames {\n         let item_name = item.ident.name.as_str();\n         let item_name_chars = item_name.chars().count();\n         let item_camel = to_camel_case(&item_name);\n-        if !in_macro(cx, item.span) {\n+        if !in_macro(item.span) {\n             if let Some(&(ref mod_name, ref mod_camel)) = self.modules.last() {\n                 // constants don't have surrounding modules\n                 if !mod_camel.is_empty() {"}, {"sha": "bcbb8b1cccd2a75a275394e927ca56409f3a72a4", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -40,7 +40,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let Some(span) = is_expn_of(cx, expr.span, \"format\") {\n+        if let Some(span) = is_expn_of(expr.span, \"format\") {\n             match expr.node {\n                 // `format!(\"{}\", foo)` expansion\n                 ExprCall(ref fun, ref args) => {"}, {"sha": "7fa8c3deb99eec917adc3c03528941a3a857c82c", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n-use syntax::codemap::mk_sp;\n use syntax::ast;\n+use syntax_pos::{Span, NO_EXPANSION};\n use utils::{differing_macro_contexts, in_macro, snippet_opt, span_note_and_lint};\n use syntax::ptr::P;\n \n@@ -99,13 +99,12 @@ impl EarlyLintPass for Formatting {\n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n     if let ast::ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n-        if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro(cx, lhs.span) {\n-            let eq_span = mk_sp(lhs.span.hi, rhs.span.lo);\n-\n+        if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro(lhs.span) {\n+            let eq_span = Span { lo: lhs.span.hi, hi: rhs.span.lo, ctxt: NO_EXPANSION };\n             if let ast::ExprKind::Unary(op, ref sub_rhs) = rhs.node {\n                 if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n                     let op = ast::UnOp::to_string(op);\n-                    let eqop_span = mk_sp(lhs.span.hi, sub_rhs.span.lo);\n+                    let eqop_span= Span { lo: lhs.span.hi, hi: sub_rhs.span.lo, ctxt: NO_EXPANSION };\n                     if eq_snippet.ends_with('=') {\n                         span_note_and_lint(cx,\n                                            SUSPICIOUS_ASSIGNMENT_FORMATTING,\n@@ -125,10 +124,10 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for weird `else if`.\n fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n     if let Some((then, &Some(ref else_))) = unsugar_if(expr) {\n-        if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(cx, then.span) {\n+        if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(then.span) {\n             // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to the\n             // \u201cif\u201d of the \u201celse if\u201d block (excluding)\n-            let else_span = mk_sp(then.span.hi, else_.span.lo);\n+            let else_span = Span { lo: then.span.hi, hi: else_.span.lo, ctxt: NO_EXPANSION };\n \n             // the snippet should look like \" else \\n    \" with maybe comments anywhere\n             // it\u2019s bad when there is a \u2018\\n\u2019 after the \u201celse\u201d\n@@ -155,9 +154,9 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n         for element in array {\n             if let ast::ExprKind::Binary(ref op, ref lhs, _) = element.node {\n                 if !differing_macro_contexts(lhs.span, op.span) {\n-                    let space_span = mk_sp(lhs.span.hi, op.span.lo);\n+                    let space_span = Span { lo: lhs.span.hi, hi: op.span.lo, ctxt: NO_EXPANSION };\n                     if let Some(space_snippet) = snippet_opt(cx, space_span) {\n-                        let lint_span = mk_sp(lhs.span.hi, lhs.span.hi);\n+                        let lint_span = Span { lo: lhs.span.hi, hi: lhs.span.hi, ctxt: NO_EXPANSION };\n                         if space_snippet.contains('\\n') {\n                             span_note_and_lint(cx,\n                                                POSSIBLE_MISSING_COMMA,\n@@ -175,10 +174,10 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n-    if !differing_macro_contexts(first.span, second.span) && !in_macro(cx, first.span) &&\n+    if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) &&\n        unsugar_if(first).is_some() && unsugar_if(second).is_some() {\n         // where the else would be\n-        let else_span = mk_sp(first.span.hi, second.span.lo);\n+        let else_span = Span { lo: first.span.hi, hi: second.span.lo, ctxt: NO_EXPANSION };\n \n         if let Some(else_snippet) = snippet_opt(cx, else_span) {\n             if !else_snippet.contains('\\n') {"}, {"sha": "e57feaa5937c36a4b2ddf9163f46b2291411261e", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -33,7 +33,7 @@ impl LintPass for IdentityOp {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if in_macro(cx, e.span) {\n+        if in_macro(e.span) {\n             return;\n         }\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {"}, {"sha": "8d6a28e62dbc0f34ba95cd4873d6ac9e3fa65726", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     let span = Span {\n                         lo: expr.span.lo,\n                         hi: op.span.hi,\n-                        expn_id: expr.span.expn_id,\n+                        ctxt: expr.span.ctxt,\n                     };\n                     db.span_suggestion(span, \"try this\", format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method));\n                 });"}, {"sha": "b3561720cc70db18c502e6a329ff93ed4ac0aa00", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -42,7 +42,7 @@ impl LintPass for ItemsAfterStatements {\n \n impl EarlyLintPass for ItemsAfterStatements {\n     fn check_block(&mut self, cx: &EarlyContext, item: &Block) {\n-        if in_macro(cx, item.span) {\n+        if in_macro(item.span) {\n             return;\n         }\n \n@@ -55,7 +55,7 @@ impl EarlyLintPass for ItemsAfterStatements {\n         // lint on all further items\n         for stmt in stmts {\n             if let StmtKind::Item(ref it) = *stmt {\n-                if in_macro(cx, it.span) {\n+                if in_macro(it.span) {\n                     return;\n                 }\n                 if let ItemKind::MacroDef(..) = it.node {"}, {"sha": "92fa1324324e53c6270dec36a3c69eaa59ade037", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -61,7 +61,7 @@ impl LintPass for LenZero {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if in_macro(cx, item.span) {\n+        if in_macro(item.span) {\n             return;\n         }\n \n@@ -73,7 +73,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if in_macro(cx, expr.span) {\n+        if in_macro(expr.span) {\n             return;\n         }\n "}, {"sha": "6fbe47c9e65f64e9fa62d667d98c65ea771b05ba", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir;\n-use syntax::codemap;\n+use syntax_pos::{Span, NO_EXPANSION};\n use utils::{snippet, span_lint_and_then};\n \n /// **What it does:** Checks for variable declarations immediately followed by a\n@@ -69,10 +69,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                 let hir::StmtExpr(ref if_, _) = expr.node,\n                 let hir::ExprIf(ref cond, ref then, ref else_) = if_.node,\n                 !used_in_expr(cx, def_id, cond),\n-                let Some(value) = check_assign(cx, def_id, then),\n+                let hir::ExprBlock(ref then) = then.node,\n+                let Some(value) = check_assign(cx, def_id, &*then),\n                 !used_in_expr(cx, def_id, value),\n             ], {\n-                let span = codemap::mk_sp(stmt.span.lo, if_.span.hi);\n+                let span = Span { lo: stmt.span.lo, hi: if_.span.hi, ctxt: NO_EXPANSION };\n \n                 let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n                     if let hir::ExprBlock(ref else_) = else_.node {"}, {"sha": "d7760a30622df839dbbe26cdaab90c80d089ae76", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -894,7 +894,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                         match def {\n                             Def::Local(..) | Def::Upvar(..) => {\n                                 let def_id = def.def_id();\n-                                let node_id = self.cx.tcx.hir.as_local_node_id(def_id).unwrap();\n+                                let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n \n                                 let extent = self.cx.tcx.region_maps.var_scope(node_id);\n                                 self.indexed.insert(seqvar.segments[0].name, Some(extent));"}, {"sha": "f8f50bfb8536711c77839812013e1c0b7f380f36", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -342,7 +342,7 @@ fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n                     path_str == \"Err\",\n                     inner.iter().any(|pat| pat.node == PatKind::Wild),\n                     let ExprBlock(ref block) = arm.body.node,\n-                    is_panic_block(cx, block)\n+                    is_panic_block(block)\n                 ], {\n                     // `Err(_)` arm with `panic!` found\n                     span_note_and_lint(cx,\n@@ -359,13 +359,13 @@ fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n }\n \n // If the block contains only a `panic!` macro (as expression or statement)\n-fn is_panic_block(cx: &LateContext, block: &Block) -> bool {\n+fn is_panic_block(block: &Block) -> bool {\n     match (&block.expr, block.stmts.len(), block.stmts.first()) {\n         (&Some(ref exp), 0, _) => {\n-            is_expn_of(cx, exp.span, \"panic\").is_some() && is_expn_of(cx, exp.span, \"unreachable\").is_none()\n+            is_expn_of(exp.span, \"panic\").is_some() && is_expn_of(exp.span, \"unreachable\").is_none()\n         },\n         (&None, 1, Some(stmt)) => {\n-            is_expn_of(cx, stmt.span, \"panic\").is_some() && is_expn_of(cx, stmt.span, \"unreachable\").is_none()\n+            is_expn_of(stmt.span, \"panic\").is_some() && is_expn_of(stmt.span, \"unreachable\").is_none()\n         },\n         _ => false,\n     }"}, {"sha": "53b9b1b83ec47f2ba68c8a1a1488196f47e989e3", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -554,7 +554,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     // ^ required because `cyclomatic_complexity` attribute shows up as unused\n     #[cyclomatic_complexity = \"30\"]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        if in_macro(cx, expr.span) {\n+        if in_macro(expr.span) {\n             return;\n         }\n \n@@ -649,7 +649,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if name == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(&first_arg_ty, &first_arg, &self_ty, false) {\n+                   self_kind.matches(first_arg_ty, first_arg, self_ty, false) {\n                     span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                         \"defining a method called `{}` on this type; consider implementing \\\n                          the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -662,7 +662,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n-                    !self_kinds.iter().any(|k| k.matches(&first_arg_ty, &first_arg, &self_ty, is_copy)),\n+                    !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy)),\n                 ], {\n                     let lint = if item.vis == hir::Visibility::Public {\n                         WRONG_PUB_SELF_CONVENTION\n@@ -1065,7 +1065,7 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr]\n         // lint, with note if neither arg is > 1 line and both map() and\n         // unwrap_or() have the same span\n         let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n+        let same_span = map_args[1].span.ctxt == unwrap_args[1].span.ctxt;\n         if same_span && !multiline {\n             span_note_and_lint(cx,\n                                OPTION_MAP_UNWRAP_OR,\n@@ -1094,7 +1094,7 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::\n         // lint, with note if neither arg is > 1 line and both map() and\n         // unwrap_or_else() have the same span\n         let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n+        let same_span = map_args[1].span.ctxt == unwrap_args[1].span.ctxt;\n         if same_span && !multiline {\n             span_note_and_lint(cx,\n                                OPTION_MAP_UNWRAP_OR_ELSE,"}, {"sha": "e84fd196874c50d623ead3482b836aadb22c133d", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             },\n             _ => {},\n         }\n-        if in_attributes_expansion(cx, expr) {\n+        if in_attributes_expansion(expr) {\n             // Don't lint things expanded by #[derive(...)], etc\n             return;\n         }\n@@ -498,9 +498,9 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n \n /// Test whether an expression is in a macro expansion (e.g. something generated by\n /// `#[derive(...)`] or the like).\n-fn in_attributes_expansion(cx: &LateContext, expr: &Expr) -> bool {\n-    cx.sess().codemap().with_expn_info(expr.span.expn_id, |info_opt| {\n-        info_opt.map_or(false, |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)))\n+fn in_attributes_expansion(expr: &Expr) -> bool {\n+    expr.span.ctxt.outer().expn_info().map_or(false, |info| {\n+        matches!(info.callee.format, ExpnFormat::MacroAttribute(_))\n     })\n }\n \n@@ -510,7 +510,7 @@ fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n         def::Def::Local(id) |\n         def::Def::Upvar(id, _, _) => {\n             if let Some(span) = cx.tcx.hir.span_if_local(id) {\n-                !in_macro(cx, span)\n+                !in_macro(span)\n             } else {\n                 true\n             }"}, {"sha": "1249b638a0815c0077739f61fd0d5b655b9e816a", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -73,7 +73,7 @@ impl MissingDoc {\n             return;\n         }\n \n-        if in_macro(cx, sp) {\n+        if in_macro(sp) {\n             return;\n         }\n "}, {"sha": "53b26fc1276955f7fd131586ab9ed7896f66d288", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -76,6 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                                    \"this if-then-else expression returns a bool literal\",\n                                    |db| { db.span_suggestion(e.span, \"you can reduce it to\", hint); });\n             };\n+            if let ExprBlock(ref then_block) = then_block.node {\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                 (RetBool(true), RetBool(true)) |\n                 (Bool(true), Bool(true)) => {\n@@ -97,6 +98,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                 (Bool(false), Bool(true)) => reduce(false, true),\n                 _ => (),\n             }\n+            } else {\n+                panic!(\"IfExpr 'then' node is not an ExprBlock\");\n+            }\n         }\n     }\n }"}, {"sha": "740dd2bcb3fcf225c336689ba57667ffffa5ef6b", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -36,7 +36,7 @@ impl LintPass for NeedlessBorrow {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if in_macro(cx, e.span) {\n+        if in_macro(e.span) {\n             return;\n         }\n         if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n@@ -55,7 +55,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n     }\n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n-        if in_macro(cx, pat.span) {\n+        if in_macro(pat.span) {\n             return;\n         }\n         if_let_chain! {["}, {"sha": "28129484a3789a9663f0c348bfb1b60e7cad9cdf", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         span: Span,\n         node_id: NodeId\n     ) {\n-        if in_macro(cx, span) {\n+        if in_macro(span) {\n             return;\n         }\n "}, {"sha": "4796243770c79995fc913b44ff9b585b09d723bf", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -41,7 +41,7 @@ declare_lint! {\n }\n \n fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n-    if in_macro(cx, expr.span) {\n+    if in_macro(expr.span) {\n         return false;\n     }\n     match expr.node {\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n                 let mut snippet = String::new();\n                 for e in reduced {\n-                    if in_macro(cx, e.span) {\n+                    if in_macro(e.span) {\n                         return;\n                     }\n                     if let Some(snip) = snippet_opt(cx, e.span) {\n@@ -132,7 +132,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n \n fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n-    if in_macro(cx, expr.span) {\n+    if in_macro(expr.span) {\n         return None;\n     }\n     match expr.node {"}, {"sha": "67f1aaa27abee0d6db62c55f265ed28d871764f3", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n         }\n     }\n     fn check_name(&mut self, span: Span, name: Name) {\n-        if in_macro(self.0.cx, span) {\n+        if in_macro(span) {\n             return;\n         }\n         let interned_name = name.as_str();"}, {"sha": "8db7de30f7c2e96fd996920afbee03c2eea5bf04", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ExprPath(ref qpath) = fun.node,\n             match_def_path(cx.tcx, resolve_node(cx, qpath, fun.id).def_id(), &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n-            is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n+            is_direct_expn_of(params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,\n             let Some(par) = string.as_str().find('{'),\n             string.as_str()[par..].contains('}')"}, {"sha": "5fee08a0c498ddf4cfd6fdee981d87edfee509ab", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -40,7 +40,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_let_chain! {[\n             let ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) = item.node,\n             !is_automatically_derived(&*item.attrs),\n-            trait_ref.path.def.def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n+            let Some(eq_trait) = cx.tcx.lang_items.eq_trait(),\n+            trait_ref.path.def.def_id() == eq_trait\n         ], {\n             for impl_item in impl_items {\n                 if impl_item.name == \"ne\" {"}, {"sha": "a6eb5c5dfda92748c6928ce540642a1d1080bb90", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -77,9 +77,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // Search for `std::io::_print(..)` which is unique in a\n             // `print!` expansion.\n             if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n-                if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n+                if let Some(span) = is_expn_of(expr.span, \"print\") {\n                     // `println!` uses `print!`.\n-                    let (span, name) = match is_expn_of(cx, span, \"println\") {\n+                    let (span, name) = match is_expn_of(span, \"println\") {\n                         Some(span) => (span, \"println\"),\n                         None => (span, \"print\"),\n                     };\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if let ExprPath(ref qpath) = args[1].node {\n                     let def_id = cx.tables.qpath_def(qpath, args[1].id).def_id();\n                     if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n-                       is_expn_of(cx, expr.span, \"panic\").is_none() {\n+                       is_expn_of(expr.span, \"panic\").is_none() {\n                         span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n                     }\n                 }"}, {"sha": "5b7cb9aa86fa11d28521757e5ec8478accbee007", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n                     let ExprMethodCall( Spanned { node: iter_name, .. }, _, ref iter_args ) = *iter,\n                     iter_name == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n-                    let Some(higher::Range { start: Some(ref start), end: Some(ref end), .. }) = higher::range(zip_arg),\n+                    let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n                     let ExprMethodCall(Spanned { node: len_name, .. }, _, ref len_args) = end.node,"}, {"sha": "cdaf51d6646c6bd66dc23f3968445c5ffc213b09", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             self.last.is_none(),\n             let Some(ref expr) = block.expr,\n             match_type(cx, cx.tables.expr_ty(expr), &paths::REGEX),\n-            let Some(span) = is_expn_of(cx, expr.span, \"regex\"),\n+            let Some(span) = is_expn_of(expr.span, \"regex\"),\n         ], {\n             if !self.spans.contains(&span) {\n                 span_lint(cx,"}, {"sha": "16f582c77c97fe7a880b546e327868513d067630", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -107,7 +107,7 @@ impl ReturnPass {\n \n         // we need both a let-binding stmt and an expr\n         if_let_chain! {[\n-            let Some(ref retexpr) = it.next_back(),\n+            let Some(retexpr) = it.next_back(),\n             let ast::StmtKind::Expr(ref retexpr) = retexpr.node,\n             let Some(stmt) = it.next_back(),\n             let ast::StmtKind::Local(ref local) = stmt.node,"}, {"sha": "58eb4aafa2be8cc3c398265515cb2318185e9243", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -305,7 +305,7 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n         },\n         ExprIf(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n-            check_block(cx, then, bindings);\n+            check_expr(cx, &**then, bindings);\n             if let Some(ref o) = *otherwise {\n                 check_expr(cx, o, bindings);\n             }"}, {"sha": "59532f3d440834522883954f24bb2dae1f0f6c52", "filename": "clippy_lints/src/should_assert_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshould_assert_eq.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ShouldAssertEq {\n             let ExprIf(ref cond, ..) = e.node,\n             let ExprUnary(UnOp::UnNot, ref cond) = cond.node,\n             let ExprBinary(ref binop, ref expr1, ref expr2) = cond.node,\n-            is_direct_expn_of(cx, e.span, \"assert\").is_some(),\n+            is_direct_expn_of(e.span, \"assert\").is_some(),\n             let Some(debug_trait) = cx.tcx.lang_items.debug_trait(),\n         ], {\n             let sugg = match binop.node {"}, {"sha": "646ba598f8182703b1b1de2bd5824e72ef68ed0c", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n             if name.node == \"as_bytes\" {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n-                        if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(cx, args[0].span) {\n+                        if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {\n                             span_lint_and_then(cx,\n                                                STRING_LIT_AS_BYTES,\n                                                e.span,"}, {"sha": "b2c56fe8bf31614914f9035374227a3d081b0e2d", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -1,9 +1,9 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty;\n-use syntax::codemap::mk_sp;\n use utils::{differing_macro_contexts, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use utils::sugg::Sugg;\n+use syntax_pos::{Span, NO_EXPANSION};\n \n /// **What it does:** Checks for manual swapping.\n ///\n@@ -115,16 +115,14 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                 } else {\n                     (false, \"\".to_owned(), \"\".to_owned())\n                 }\n+            } else if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n+                (true, format!(\" `{}` and `{}`\", first, second),\n+                    format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()))\n             } else {\n-                 if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n-                    (true, format!(\" `{}` and `{}`\", first, second),\n-                     format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()))\n-                } else {\n-                    (true, \"\".to_owned(), \"\".to_owned())\n-                }\n+                (true, \"\".to_owned(), \"\".to_owned())\n             };\n \n-            let span = mk_sp(w[0].span.lo, second.span.hi);\n+            let span = Span { lo: w[0].span.lo, hi: second.span.hi, ctxt: NO_EXPANSION};\n \n             span_lint_and_then(cx,\n                                MANUAL_SWAP,\n@@ -163,7 +161,7 @@ fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n                 (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())\n             };\n \n-            let span = mk_sp(first.span.lo, second.span.hi);\n+            let span = Span{ lo: first.span.lo, hi: second.span.hi, ctxt: NO_EXPANSION};\n \n             span_lint_and_then(cx,\n                                ALMOST_SWAPPED,"}, {"sha": "005c508f123e5595d7388547bf6eca4991e0224f", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -107,7 +107,7 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n }\n \n fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n-    if in_macro(cx, ast_ty.span) {\n+    if in_macro(ast_ty.span) {\n         return;\n     }\n     match ast_ty.node {\n@@ -118,7 +118,7 @@ fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n                     let last = last_path_segment(qpath);\n                     if_let_chain! {[\n                         let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n-                        let Some(ref vec) = ag.types.get(0),\n+                        let Some(vec) = ag.types.get(0),\n                         let TyPath(ref qpath) = vec.node,\n                         let def::Def::Struct(..) = cx.tables.qpath_def(qpath, vec.id),\n                         let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, vec.id)),\n@@ -199,7 +199,7 @@ fn check_let_unit(cx: &LateContext, decl: &Decl) {\n         let bindtype = &cx.tables.pat_ty(&local.pat).sty;\n         match *bindtype {\n             ty::TyTuple(slice, _) if slice.is_empty() => {\n-                if in_external_macro(cx, decl.span) || in_macro(cx, local.pat.span) {\n+                if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n                     return;\n                 }\n                 if higher::is_from_for_desugar(decl) {\n@@ -261,7 +261,7 @@ impl LintPass for UnitCmp {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if in_macro(cx, expr.span) {\n+        if in_macro(expr.span) {\n             return;\n         }\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n@@ -694,7 +694,7 @@ impl<'a, 'tcx> TypeComplexityPass {\n     }\n \n     fn check_type(&self, cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty) {\n-        if in_macro(cx, ty.span) {\n+        if in_macro(ty.span) {\n             return;\n         }\n         let score = {\n@@ -797,7 +797,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n         if let ExprCast(ref e, _) = expr.node {\n             if let ExprLit(ref l) = e.node {\n                 if let LitKind::Char(_) = l.node {\n-                    if ty::TyUint(UintTy::U8) == cx.tables.expr_ty(expr).sty && !in_macro(cx, expr.span) {\n+                    if ty::TyUint(UintTy::U8) == cx.tables.expr_ty(expr).sty && !in_macro(expr.span) {\n                         let msg = \"casting character literal to u8. `char`s \\\n                                    are 4 bytes wide in rust, so casting to u8 \\\n                                    truncates them\";\n@@ -971,7 +971,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n \n         if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n             if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n-                if !in_macro(cx, expr.span) {\n+                if !in_macro(expr.span) {\n                     let msg = \"this comparison involving the minimum or maximum element for this \\\n                                type contains a case that is always true or always false\";\n "}, {"sha": "15f327fb5c2f183442a0d8c24ece013ccf916b94", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n         span: Span,\n         fn_id: ast::NodeId\n     ) {\n-        if in_macro(cx, span) {\n+        if in_macro(span) {\n             return;\n         }\n "}, {"sha": "10a1c18e1823a5f4f12ea73acf7be1a6cdce0f72", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -156,7 +156,7 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = expr.node,\n         let hir::ExprPath(ref path) = fun.node,\n-        is_expn_of(cx, fun.span, \"vec\").is_some(),\n+        is_expn_of(fun.span, \"vec\").is_some(),\n     ], {\n         let fun_def = resolve_node(cx, path, fun.id);\n         return if match_def_path(cx.tcx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {"}, {"sha": "a818f99fec4154b4789d660f702feeac35589ce1", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n             (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n-                self.eq_expr(lc, rc) && self.eq_block(lt, rt) && both(le, re, |l, r| self.eq_expr(l, r))\n+                    self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n@@ -395,7 +395,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _, _) -> _ = ExprIf;\n                 c.hash(&mut self.s);\n                 self.hash_expr(cond);\n-                self.hash_block(t);\n+                self.hash_expr(&**t);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }"}, {"sha": "038dfc01d134275b93179749f74def99e9319a22", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n             // not able to capture the error.\n             // Therefore, we need to climb the macro expansion tree and find the\n             // actual span that invoked `declare_lint!`:\n-            let lint_span = cx.sess().codemap().source_callsite(lint_span);\n+            let lint_span = lint_span.ctxt.outer().expn_info().map(|ei| ei.call_site).expect(\"unable to get call_site\");\n \n             if !self.registered_lints.contains(lint_name) {\n                 span_lint(cx,"}, {"sha": "db595b079699396eb744c039aa8f9e42f4d590be", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -97,7 +97,7 @@ pub mod higher;\n /// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one\n /// isn't).\n pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n-    rhs.expn_id != lhs.expn_id\n+    rhs.ctxt != lhs.ctxt\n }\n \n pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n@@ -111,17 +111,11 @@ pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n }\n \n /// Returns true if this `expn_info` was expanded by any macro.\n-pub fn in_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n-    cx.sess().codemap().with_expn_info(span.expn_id, |info| {\n-        match info {\n-            Some(info) => {\n-                match info.callee.format {\n-                    // don't treat range expressions desugared to structs as \"in_macro\"\n-                    ExpnFormat::CompilerDesugaring(name) => name != \"...\",\n-                    _ => true,\n-                }\n-            },\n-            None => false,\n+pub fn in_macro(span: Span) -> bool {\n+    span.ctxt.outer().expn_info().map_or(false, |info| {\n+        match info.callee.format {// don't treat range expressions desugared to structs as \"in_macro\"\n+            ExpnFormat::CompilerDesugaring(name) => name != \"...\",\n+            _ => true,\n         }\n     })\n }\n@@ -131,22 +125,20 @@ pub fn in_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     /// Invokes `in_macro` with the expansion info of the given span slightly heavy, try to use\n     /// this after other checks have already happened.\n-    fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n+    fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, info: &ExpnInfo) -> bool {\n         // no ExpnInfo = no macro\n-        opt_info.map_or(false, |info| {\n-            if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n-                // these are all plugins\n-                return true;\n-            }\n-            // no span for the callee = external macro\n-            info.callee.span.map_or(true, |span| {\n-                // no snippet = external macro or compiler-builtin expansion\n-                cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| !code.starts_with(\"macro_rules\"))\n-            })\n+        if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n+            // these are all plugins\n+            return true;\n+        }\n+        // no span for the callee = external macro\n+        info.callee.span.map_or(true, |span| {\n+            // no snippet = external macro or compiler-builtin expansion\n+            cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| !code.starts_with(\"macro_rules\"))\n         })\n     }\n \n-    cx.sess().codemap().with_expn_info(span.expn_id, |info| in_macro_ext(cx, info))\n+    span.ctxt.outer().expn_info().map_or(false, |info| in_macro_ext(cx, &info))\n }\n \n /// Check if a `DefId`'s path matches the given absolute type path usage.\n@@ -365,6 +357,9 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n         // method chains are stored last -> first\n         if let ExprMethodCall(ref name, _, ref args) = current.node {\n             if name.node == *method_name {\n+                if args.iter().any(|e| in_macro(e.span)) {\n+                    return None;\n+                }\n                 matched.push(&**args); // build up `matched` backwards\n                 current = &args[0] // go to parent expression\n             } else {\n@@ -693,12 +688,10 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n \n /// Return the pre-expansion span if is this comes from an expansion of the macro `name`.\n /// See also `is_direct_expn_of`.\n-pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span> {\n+pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n-        let span_name_span = cx.tcx\n-            .sess\n-            .codemap()\n-            .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n+        let span_name_span = span.ctxt.outer()\n+            .expn_info().map(|ei| (ei.callee.name(), ei.call_site));\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n@@ -715,11 +708,9 @@ pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span>\n /// ```\n /// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only `bar!` by\n /// `is_direct_expn_of`.\n-pub fn is_direct_expn_of(cx: &LateContext, span: Span, name: &str) -> Option<Span> {\n-    let span_name_span = cx.tcx\n-        .sess\n-        .codemap()\n-        .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n+pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n+    let span_name_span = span.ctxt.outer()\n+        .expn_info().map(|ei| (ei.callee.name(), ei.call_site));\n \n     match span_name_span {\n         Some((mac_name, new_span)) if mac_name == name => Some(new_span),"}, {"sha": "da65474ed968a6dc4aacc0dbf73cbd3a3e3c9c3a", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg)), cx.tcx.hir.get_parent(expr.id)),\n         ], {\n             // report the error around the `vec!` not inside `<std macros>:`\n-            let span = cx.sess().codemap().source_callsite(arg.span);\n+            let span = arg.span.ctxt.outer().expn_info().map(|info| info.call_site).expect(\"unable to get call_site\");\n             check_vec_macro(cx, &vec_args, span);\n         }}\n     }\n@@ -70,7 +70,7 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n                 let span = Span {\n                     lo: args[0].span.lo,\n                     hi: last.span.hi,\n-                    expn_id: args[0].span.expn_id,\n+                    ctxt: args[0].span.ctxt,\n                 };\n \n                 format!(\"&[{}]\", snippet(cx, span, \"..\")).into()"}, {"sha": "62f1434c0ab51d7036a4e425144efbb797510898", "filename": "rls.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/rls.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/rls.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rls.toml?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -0,0 +1 @@\n+build_lib = true\n\\ No newline at end of file"}, {"sha": "a6473b0f909e1261658f1f7a9ec658a666f7126b", "filename": "tests/run-pass/mut_mut_macro.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/tests%2Frun-pass%2Fmut_mut_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/tests%2Frun-pass%2Fmut_mut_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmut_mut_macro.rs?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -20,13 +20,12 @@ fn main() {\n     lazy_static! {\n         static ref MUT_MAP : HashMap<usize, &'static str> = {\n             let mut m = HashMap::new();\n-            let mut zero = &mut &mut \"zero\";\n             m.insert(0, \"zero\");\n             m\n         };\n         static ref MUT_COUNT : usize = MUT_MAP.len();\n     }\n-    assert!(*MUT_COUNT == 1);\n+    assert_eq!(*MUT_COUNT, 1);\n     // FIXME: don't lint in array length, requires `check_body`\n     //let _ = [\"\"; (42.0 < std::f32::NAN) as usize];\n }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/panic.stderr", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3052000c738755bf81d6ac01ec4f35d4d791c8a9/tests%2Fui%2Fpanic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3052000c738755bf81d6ac01ec4f35d4d791c8a9/tests%2Fui%2Fpanic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic.stderr?ref=3052000c738755bf81d6ac01ec4f35d4d791c8a9", "patch": "@@ -1,26 +0,0 @@\n-error: you probably are missing some parameter in your format string\n- --> $DIR/panic.rs:8:16\n-  |\n-8 |         panic!(\"{}\");\n-  |                ^^^^\n-  |\n-note: lint level defined here\n- --> $DIR/panic.rs:4:9\n-  |\n-4 | #![deny(panic_params)]\n-  |         ^^^^^^^^^^^^\n-\n-error: you probably are missing some parameter in your format string\n-  --> $DIR/panic.rs:10:16\n-   |\n-10 |         panic!(\"{:?}\");\n-   |                ^^^^^^\n-\n-error: you probably are missing some parameter in your format string\n-  --> $DIR/panic.rs:12:23\n-   |\n-12 |         assert!(true, \"here be missing values: {}\");\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-"}]}