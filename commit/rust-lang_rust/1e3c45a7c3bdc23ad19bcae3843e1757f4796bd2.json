{"sha": "1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlM2M0NWE3YzNiZGMyM2FkMTliY2FlMzg0M2UxNzU3ZjQ3OTZiZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-03T00:50:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-03T00:50:09Z"}, "message": "Auto merge of #51657 - wesleywiser:wip_profiling, r=eddyb\n\nImplement a self profiler\n\nThis is a work in progress implementation of #50780. I'd love feedback on the overall structure and code as well as some specific things:\n\n- [The query categorization mechanism](https://github.com/rust-lang/rust/compare/master...wesleywiser:wip_profiling?expand=1#diff-19e0a69c10eff31eb2d16805e79f3437R101). This works but looks kind of ugly to me. Perhaps there's a better way?\n\n- [The profiler assumes only one activity can run at a time](https://github.com/rust-lang/rust/compare/master...wesleywiser:wip_profiling?expand=1#diff-f8a403b2d88d873e4b27c097c614a236R177). This is obviously incompatible with the ongoing parallel queries.\n\n- [The output code is just a bunch of `format!()`s](https://github.com/rust-lang/rust/compare/master...wesleywiser:wip_profiling?expand=1#diff-f8a403b2d88d873e4b27c097c614a236R91). Is there a better way to generate markdown or json in the compiler?\n\n- [The query categorizations are likely wrong](https://github.com/rust-lang/rust/compare/master...wesleywiser:wip_profiling?expand=1#diff-19e0a69c10eff31eb2d16805e79f3437R101). I've marked what seemed obvious to me but I'm sure I got a lot of them wrong.\n\nThe overhead currently seems very low. Running `perf` on a sample compilation with profiling enabled reveals:\n![image](https://user-images.githubusercontent.com/831192/41657821-9775efec-7462-11e8-9e5e-47ec94105d9d.png)", "tree": {"sha": "b5c989c51e3560f1e3a23ca540fa3fb3d6a8b05a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5c989c51e3560f1e3a23ca540fa3fb3d6a8b05a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "html_url": "https://github.com/rust-lang/rust/commit/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "url": "https://api.github.com/repos/rust-lang/rust/commits/40e4b6ee3dd70a05007915bd1c15c150a7b7899f", "html_url": "https://github.com/rust-lang/rust/commit/40e4b6ee3dd70a05007915bd1c15c150a7b7899f"}, {"sha": "2d3a0a99279093e024c819dda826626a088bcd7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3a0a99279093e024c819dda826626a088bcd7e", "html_url": "https://github.com/rust-lang/rust/commit/2d3a0a99279093e024c819dda826626a088bcd7e"}], "stats": {"total": 333, "additions": 332, "deletions": 1}, "files": [{"sha": "bac511aac1fe10108f01adb76258d4df01fdcbdf", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -165,6 +165,7 @@ pub mod util {\n     pub mod nodemap;\n     pub mod fs;\n     pub mod time_graph;\n+    pub mod profiling;\n }\n \n // A private module so that macro-expanded idents like"}, {"sha": "dda4a2d2418d7bc09784b39907b747c08b11f091", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -65,7 +65,7 @@ pub enum Sanitizer {\n     Thread,\n }\n \n-#[derive(Clone, Copy, PartialEq, Hash)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n pub enum OptLevel {\n     No,         // -O0\n     Less,       // -O1\n@@ -1367,6 +1367,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n     crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n         \"inject the given attribute in the crate\"),\n+    self_profile: bool = (false, parse_bool, [UNTRACKED],\n+          \"run the self profiler\"),\n+    profile_json: bool = (false, parse_bool, [UNTRACKED],\n+          \"output a json file with profiler results\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "0ab482c89a125813b85150cf4a4eb810892f60df", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -40,6 +40,7 @@ use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n use syntax_pos::{MultiSpan, Span};\n+use util::profiling::SelfProfiler;\n \n use rustc_target::spec::{LinkerFlavor, PanicStrategy};\n use rustc_target::spec::{Target, TargetTriple};\n@@ -133,6 +134,9 @@ pub struct Session {\n     /// Used by -Z profile-queries in util::common\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n+    /// Used by -Z self-profile\n+    pub self_profiling: Lock<SelfProfiler>,\n+\n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n \n@@ -825,6 +829,21 @@ impl Session {\n         }\n     }\n \n+    pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+        let mut profiler = self.self_profiling.borrow_mut();\n+        f(&mut profiler);\n+    }\n+\n+    pub fn print_profiler_results(&self) {\n+        let mut profiler = self.self_profiling.borrow_mut();\n+        profiler.print_results(&self.opts);\n+    }\n+\n+    pub fn save_json_results(&self) {\n+        let profiler = self.self_profiling.borrow();\n+        profiler.save_results(&self.opts);\n+    }\n+\n     pub fn print_perf_stats(&self) {\n         println!(\n             \"Total time spent computing symbol hashes:      {}\",\n@@ -1125,6 +1144,7 @@ pub fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(HashMap::new())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         ignored_attr_names: ich::compute_ignored_attr_names(),\n+        self_profiling: Lock::new(SelfProfiler::new()),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),"}, {"sha": "d2648cad55ee9fa11dd03372af55cc510952b906", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -21,6 +21,7 @@ use ty::subst::Substs;\n use ty::query::queries;\n use ty::query::Query;\n use ty::query::QueryCache;\n+use util::profiling::ProfileCategory;\n \n use std::hash::Hash;\n use std::fmt::Debug;\n@@ -33,6 +34,7 @@ use ich::StableHashingContext;\n \n pub trait QueryConfig<'tcx> {\n     const NAME: &'static str;\n+    const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;\n     type Value: Clone + for<'a> HashStable<StableHashingContext<'a>>;"}, {"sha": "ab9bdd82e01ebf6cb97aa00f404f6810c93d571e", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -46,6 +46,7 @@ use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n use util::common::{ErrorReported};\n+use util::profiling::ProfileCategory::*;\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_target::spec::PanicStrategy;"}, {"sha": "0fa643d796e0e1c7a3451ad84c35b9f133bcd78e", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -118,6 +118,11 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             let mut lock = cache.borrow_mut();\n             if let Some(value) = lock.results.get(key) {\n                 profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                tcx.sess.profiler(|p| {\n+                    p.record_query(Q::CATEGORY);\n+                    p.record_query_hit(Q::CATEGORY);\n+                });\n+\n                 let result = Ok((value.value.clone(), value.index));\n                 return TryGetJob::JobCompleted(result);\n             }\n@@ -358,10 +363,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             )\n         );\n \n+        self.sess.profiler(|p| p.record_query(Q::CATEGORY));\n+\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::JobCompleted(result) => {\n                 return result.map(|(v, index)| {\n+                    self.sess.profiler(|p| p.record_query_hit(Q::CATEGORY));\n                     self.dep_graph.read_index(index);\n                     v\n                 })\n@@ -379,13 +387,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         if dep_node.kind.is_anon() {\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+            self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n \n             let res = job.start(self, |tcx| {\n                 tcx.dep_graph.with_anon_task(dep_node.kind, || {\n                     Q::compute(tcx.global_tcx(), key)\n                 })\n             });\n \n+            self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n             profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n             let ((result, dep_node_index), diagnostics) = res;\n \n@@ -402,6 +412,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if !dep_node.kind.is_input() {\n             if let Some(dep_node_index) = self.try_mark_green_and_read(&dep_node) {\n                 profq_msg!(self, ProfileQueriesMsg::CacheHit);\n+                self.sess.profiler(|p| p.record_query_hit(Q::CATEGORY));\n+\n                 return self.load_from_disk_and_cache_in_memory::<Q>(key,\n                                                                     job,\n                                                                     dep_node_index,\n@@ -523,6 +535,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+        self.sess.profiler(|p| {\n+            p.start_activity(Q::CATEGORY);\n+            p.record_query(Q::CATEGORY);\n+        });\n+\n         let res = job.start(self, |tcx| {\n             if dep_node.kind.is_eval_always() {\n                 tcx.dep_graph.with_eval_always_task(dep_node,\n@@ -536,6 +553,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                         Q::compute)\n             }\n         });\n+\n+        self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n         profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n         let ((result, dep_node_index), diagnostics) = res;\n@@ -574,7 +593,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // DepNodeIndex. We must invoke the query itself. The performance cost\n             // this introduces should be negligible as we'll immediately hit the\n             // in-memory cache, or another query down the line will.\n+\n+            self.sess.profiler(|p| {\n+                p.start_activity(Q::CATEGORY);\n+                p.record_query(Q::CATEGORY);\n+            });\n+\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n+\n+            self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n         }\n     }\n \n@@ -655,6 +682,7 @@ macro_rules! define_queries_inner {\n             rustc_data_structures::stable_hasher::StableHasher,\n             ich::StableHashingContext\n         };\n+        use util::profiling::ProfileCategory;\n \n         define_queries_struct! {\n             tcx: $tcx,\n@@ -768,6 +796,7 @@ macro_rules! define_queries_inner {\n             type Value = $V;\n \n             const NAME: &'static str = stringify!($name);\n+            const CATEGORY: ProfileCategory = $category;\n         }\n \n         impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {"}, {"sha": "447b75e547f01d903c6fec73fe38aac2933fbb49", "filename": "src/librustc/util/profiling.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -0,0 +1,248 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use session::config::Options;\n+\n+use std::fs;\n+use std::io::{self, StdoutLock, Write};\n+use std::time::Instant;\n+\n+macro_rules! define_categories {\n+    ($($name:ident,)*) => {\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+        pub enum ProfileCategory {\n+            $($name),*\n+        }\n+\n+        #[allow(bad_style)]\n+        struct Categories<T> {\n+            $($name: T),*\n+        }\n+\n+        impl<T: Default> Categories<T> {\n+            fn new() -> Categories<T> {\n+                Categories {\n+                    $($name: T::default()),*\n+                }\n+            }\n+        }\n+\n+        impl<T> Categories<T> {\n+            fn get(&self, category: ProfileCategory) -> &T {\n+                match category {\n+                    $(ProfileCategory::$name => &self.$name),*\n+                }\n+            }\n+\n+            fn set(&mut self, category: ProfileCategory, value: T) {\n+                match category {\n+                    $(ProfileCategory::$name => self.$name = value),*\n+                }\n+            }\n+        }\n+\n+        struct CategoryData {\n+            times: Categories<u64>,\n+            query_counts: Categories<(u64, u64)>,\n+        }\n+\n+        impl CategoryData {\n+            fn new() -> CategoryData {\n+                CategoryData {\n+                    times: Categories::new(),\n+                    query_counts: Categories::new(),\n+                }\n+            }\n+\n+            fn print(&self, lock: &mut StdoutLock) {\n+                writeln!(lock, \"| Phase            | Time (ms)      | Queries        | Hits (%) |\")\n+                    .unwrap();\n+                writeln!(lock, \"| ---------------- | -------------- | -------------- | -------- |\")\n+                    .unwrap();\n+\n+                $(\n+                    let (hits, total) = self.query_counts.$name;\n+                    let (hits, total) = if total > 0 {\n+                        (format!(\"{:.2}\",\n+                        (((hits as f32) / (total as f32)) * 100.0)), total.to_string())\n+                    } else {\n+                        (\"\".into(), \"\".into())\n+                    };\n+\n+                    writeln!(\n+                        lock,\n+                        \"| {0: <16} | {1: <14} | {2: <14} | {3: <8} |\",\n+                        stringify!($name),\n+                        self.times.$name / 1_000_000,\n+                        total,\n+                        hits\n+                    ).unwrap();\n+                )*\n+            }\n+\n+            fn json(&self) -> String {\n+                let mut json = String::from(\"[\");\n+\n+                $(\n+                    let (hits, total) = self.query_counts.$name;\n+\n+                    json.push_str(&format!(\n+                        \"{{ \\\"category\\\": {}, \\\"time_ms\\\": {},\n+                            \\\"query_count\\\": {}, \\\"query_hits\\\": {} }}\",\n+                        stringify!($name),\n+                        self.times.$name / 1_000_000,\n+                        total,\n+                        format!(\"{:.2}\", (((hits as f32) / (total as f32)) * 100.0))\n+                    ));\n+                )*\n+\n+                json.push(']');\n+\n+                json\n+            }\n+        }\n+    }\n+}\n+\n+define_categories! {\n+    Parsing,\n+    Expansion,\n+    TypeChecking,\n+    BorrowChecking,\n+    Codegen,\n+    Linking,\n+    Other,\n+}\n+\n+pub struct SelfProfiler {\n+    timer_stack: Vec<ProfileCategory>,\n+    data: CategoryData,\n+    current_timer: Instant,\n+}\n+\n+impl SelfProfiler {\n+    pub fn new() -> SelfProfiler {\n+        let mut profiler = SelfProfiler {\n+            timer_stack: Vec::new(),\n+            data: CategoryData::new(),\n+            current_timer: Instant::now(),\n+        };\n+\n+        profiler.start_activity(ProfileCategory::Other);\n+\n+        profiler\n+    }\n+\n+    pub fn start_activity(&mut self, category: ProfileCategory) {\n+        match self.timer_stack.last().cloned() {\n+            None => {\n+                self.current_timer = Instant::now();\n+            },\n+            Some(current_category) if current_category == category => {\n+                //since the current category is the same as the new activity's category,\n+                //we don't need to do anything with the timer, we just need to push it on the stack\n+            }\n+            Some(current_category) => {\n+                let elapsed = self.stop_timer();\n+\n+                //record the current category's time\n+                let new_time = self.data.times.get(current_category) + elapsed;\n+                self.data.times.set(current_category, new_time);\n+            }\n+        }\n+\n+        //push the new category\n+        self.timer_stack.push(category);\n+    }\n+\n+    pub fn record_query(&mut self, category: ProfileCategory) {\n+        let (hits, total) = *self.data.query_counts.get(category);\n+        self.data.query_counts.set(category, (hits, total + 1));\n+    }\n+\n+    pub fn record_query_hit(&mut self, category: ProfileCategory) {\n+        let (hits, total) = *self.data.query_counts.get(category);\n+        self.data.query_counts.set(category, (hits + 1, total));\n+    }\n+\n+    pub fn end_activity(&mut self, category: ProfileCategory) {\n+        match self.timer_stack.pop() {\n+            None => bug!(\"end_activity() was called but there was no running activity\"),\n+            Some(c) =>\n+                assert!(\n+                    c == category,\n+                    \"end_activity() was called but a different activity was running\"),\n+        }\n+\n+        //check if the new running timer is in the same category as this one\n+        //if it is, we don't need to do anything\n+        if let Some(c) = self.timer_stack.last() {\n+            if *c == category {\n+                return;\n+            }\n+        }\n+\n+        //the new timer is different than the previous,\n+        //so record the elapsed time and start a new timer\n+        let elapsed = self.stop_timer();\n+        let new_time = self.data.times.get(category) + elapsed;\n+        self.data.times.set(category, new_time);\n+    }\n+\n+    fn stop_timer(&mut self) -> u64 {\n+        let elapsed = self.current_timer.elapsed();\n+\n+        self.current_timer = Instant::now();\n+\n+        (elapsed.as_secs() * 1_000_000_000) + (elapsed.subsec_nanos() as u64)\n+    }\n+\n+    pub fn print_results(&mut self, opts: &Options) {\n+        self.end_activity(ProfileCategory::Other);\n+\n+        assert!(\n+            self.timer_stack.is_empty(),\n+            \"there were timers running when print_results() was called\");\n+\n+        let out = io::stdout();\n+        let mut lock = out.lock();\n+\n+        let crate_name =\n+            opts.crate_name\n+            .as_ref()\n+            .map(|n| format!(\" for {}\", n))\n+            .unwrap_or_default();\n+\n+        writeln!(lock, \"Self profiling results{}:\", crate_name).unwrap();\n+        writeln!(lock).unwrap();\n+\n+        self.data.print(&mut lock);\n+\n+        writeln!(lock).unwrap();\n+        writeln!(lock, \"Optimization level: {:?}\", opts.optimize).unwrap();\n+\n+        let incremental = if opts.incremental.is_some() { \"on\" } else { \"off\" };\n+        writeln!(lock, \"Incremental: {}\", incremental).unwrap();\n+    }\n+\n+    pub fn save_results(&self, opts: &Options) {\n+        let category_data = self.data.json();\n+        let compilation_options =\n+            format!(\"{{ \\\"optimization_level\\\": \\\"{:?}\\\", \\\"incremental\\\": {} }}\",\n+                    opts.optimize,\n+                    if opts.incremental.is_some() { \"true\" } else { \"false\" });\n+\n+        let json = format!(\"{{ \\\"category_data\\\": {}, \\\"compilation_options\\\": {} }}\",\n+                        category_data,\n+                        compilation_options);\n+\n+        fs::write(\"self_profiler_results.json\", json).unwrap();\n+    }\n+}"}, {"sha": "34cd3998f83cc689b0b278bcfa35d367daf48614", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -45,6 +45,7 @@ use rustc::dep_graph::{DepNode, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::middle::exported_symbols;\n use rustc::util::common::{time, print_time_passes_entry};\n+use rustc::util::profiling::ProfileCategory;\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc_incremental;\n@@ -741,11 +742,13 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let link_meta = link::build_link_meta(crate_hash);\n \n     // Codegen the metadata.\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n     let llmod_id = \"metadata\";\n     let metadata_llvm_module = ModuleLlvm::new(tcx.sess, llmod_id);\n     let metadata = time(tcx.sess, \"write metadata\", || {\n         write_metadata(tcx, &metadata_llvm_module, &link_meta)\n     });\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n \n     let metadata_module = ModuleCodegen {\n         name: link::METADATA_MODULE_NAME.to_string(),"}, {"sha": "c01ef37d1b8cca664653b8e90d249c09f51d2680", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -84,6 +84,7 @@ use rustc::session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::time_graph;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::util::profiling::ProfileCategory;\n use rustc_mir::monomorphize;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n@@ -240,10 +241,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n+        sess.profiler(|p| p.start_activity(ProfileCategory::Linking));\n         time(sess, \"linking\", || {\n             back::link::link_binary(sess, &ongoing_codegen,\n                                     outputs, &ongoing_codegen.crate_name.as_str());\n         });\n+        sess.profiler(|p| p.end_activity(ProfileCategory::Linking));\n \n         // Now that we won't touch anything in the incremental compilation directory\n         // any more, we can finalize it (which involves renaming it)"}, {"sha": "f178f847aa51e21858f17929d60107f4b756405f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -25,6 +25,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n use rustc::traits;\n use rustc::util::common::{install_panic_hook, time, ErrorReported};\n+use rustc::util::profiling::ProfileCategory;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_incremental;\n@@ -352,6 +353,14 @@ pub fn compile_input(\n         sess.print_perf_stats();\n     }\n \n+    if sess.opts.debugging_opts.self_profile {\n+        sess.print_profiler_results();\n+\n+        if sess.opts.debugging_opts.profile_json {\n+            sess.save_json_results();\n+        }\n+    }\n+\n     controller_entry_point!(\n         compilation_done,\n         sess,\n@@ -667,13 +676,15 @@ pub fn phase_1_parse_input<'a>(\n         profile::begin(sess);\n     }\n \n+    sess.profiler(|p| p.start_activity(ProfileCategory::Parsing));\n     let krate = time(sess, \"parsing\", || match *input {\n         Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n         Input::Str {\n             ref input,\n             ref name,\n         } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n     })?;\n+    sess.profiler(|p| p.end_activity(ProfileCategory::Parsing));\n \n     sess.diagnostic().set_continue_after_error(true);\n \n@@ -944,6 +955,7 @@ where\n     syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features_untracked().quote);\n \n     // Expand all macros\n+    sess.profiler(|p| p.start_activity(ProfileCategory::Expansion));\n     krate = time(sess, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n@@ -1021,6 +1033,7 @@ where\n         }\n         krate\n     });\n+    sess.profiler(|p| p.end_activity(ProfileCategory::Expansion));\n \n     krate = time(sess, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(\n@@ -1350,7 +1363,9 @@ pub fn phase_4_codegen<'a, 'tcx>(\n         ::rustc::middle::dependency_format::calculate(tcx)\n     });\n \n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n     let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n     if tcx.sess.profile_queries() {\n         profile::dump(&tcx.sess, \"profile_queries\".to_string())\n     }"}, {"sha": "4f1609455178b0cbbafc53d4c26a57fa988691c6", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=1e3c45a7c3bdc23ad19bcae3843e1757f4796bd2", "patch": "@@ -109,6 +109,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n+use rustc::util::profiling::ProfileCategory;\n use session::{CompileIncomplete, config};\n use util::common::time;\n \n@@ -334,6 +335,8 @@ pub fn provide(providers: &mut Providers) {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> Result<(), CompileIncomplete>\n {\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::TypeChecking));\n+\n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.track_errors(|| {\n@@ -371,6 +374,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n \n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::TypeChecking));\n+\n     tcx.sess.compile_status()\n }\n "}]}