{"sha": "9ac5e986ed8e7d589787532857ef74576473adcf", "node_id": "C_kwDOAAsO6NoAKDlhYzVlOTg2ZWQ4ZTdkNTg5Nzg3NTMyODU3ZWY3NDU3NjQ3M2FkY2Y", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-03-25T02:30:23Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-11T19:18:54Z"}, "message": "Extend the MIR validator to check many more things around rvalues.", "tree": {"sha": "30ee33ff252342e77ed5a741e5f53e4775056425", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ee33ff252342e77ed5a741e5f53e4775056425"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ac5e986ed8e7d589787532857ef74576473adcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ac5e986ed8e7d589787532857ef74576473adcf", "html_url": "https://github.com/rust-lang/rust/commit/9ac5e986ed8e7d589787532857ef74576473adcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ac5e986ed8e7d589787532857ef74576473adcf/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "634369170a5bc73daa51b2b15763eb508885d9c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/634369170a5bc73daa51b2b15763eb508885d9c0", "html_url": "https://github.com/rust-lang/rust/commit/634369170a5bc73daa51b2b15763eb508885d9c0"}], "stats": {"total": 242, "additions": 182, "deletions": 60}, "files": [{"sha": "7eb91385653e5e685e0b4064fdc11a2cd4ee6747", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 161, "deletions": 39, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5e986ed8e7d589787532857ef74576473adcf/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5e986ed8e7d589787532857ef74576473adcf/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=9ac5e986ed8e7d589787532857ef74576473adcf", "patch": "@@ -4,14 +4,13 @@ use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n-use rustc_middle::mir::{traversal, Place};\n use rustc_middle::mir::{\n-    AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPass, MirPhase, Operand,\n-    PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n-    TerminatorKind, START_BLOCK,\n+    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, Local, Location, MirPass,\n+    MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement,\n+    StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::AlwaysLiveLocals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -36,6 +35,13 @@ pub struct Validator {\n \n impl<'tcx> MirPass<'tcx> for Validator {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // FIXME(JakobDegen): These bodies never instantiated in codegend anyway, so it's not\n+        // terribly important that they pass the validator. However, I think other passes might\n+        // still see them, in which case they might be surprised. It would probably be better if we\n+        // didn't put this through the MIR pipeline at all.\n+        if matches!(body.source.instance, InstanceDef::Intrinsic(..) | InstanceDef::Virtual(..)) {\n+            return;\n+        }\n         let def_id = body.source.def_id();\n         let param_env = tcx.param_env(def_id);\n         let mir_phase = self.mir_phase;\n@@ -248,58 +254,174 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        match &statement.kind {\n-            StatementKind::Assign(box (dest, rvalue)) => {\n-                // LHS and RHS of the assignment must have the same type.\n-                let left_ty = dest.ty(&self.body.local_decls, self.tcx).ty;\n-                let right_ty = rvalue.ty(&self.body.local_decls, self.tcx);\n-                if !self.mir_assign_valid_types(right_ty, left_ty) {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        macro_rules! check_kinds {\n+            ($t:expr, $text:literal, $($patterns:tt)*) => {\n+                if !matches!(($t).kind(), $($patterns)*) {\n+                    self.fail(location, format!($text, $t));\n+                }\n+            };\n+        }\n+        match rvalue {\n+            Rvalue::Use(_) => {}\n+            Rvalue::Aggregate(agg_kind, _) => {\n+                let disallowed = match **agg_kind {\n+                    AggregateKind::Array(..) => false,\n+                    AggregateKind::Generator(..) => self.mir_phase >= MirPhase::GeneratorsLowered,\n+                    _ => self.mir_phase >= MirPhase::Deaggregated,\n+                };\n+                if disallowed {\n                     self.fail(\n                         location,\n-                        format!(\n-                            \"encountered `{:?}` with incompatible types:\\n\\\n-                            left-hand side has type: {}\\n\\\n-                            right-hand side has type: {}\",\n-                            statement.kind, left_ty, right_ty,\n-                        ),\n+                        format!(\"{:?} have been lowered to field assignments\", rvalue),\n+                    )\n+                }\n+            }\n+            Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n                     );\n                 }\n-                match rvalue {\n-                    // The sides of an assignment must not alias. Currently this just checks whether the places\n-                    // are identical.\n-                    Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n-                        if dest == src {\n+            }\n+            Rvalue::Len(p) => {\n+                let pty = p.ty(&self.body.local_decls, self.tcx).ty;\n+                check_kinds!(\n+                    pty,\n+                    \"Cannot compute length of non-array type {:?}\",\n+                    ty::Array(..) | ty::Slice(..)\n+                );\n+            }\n+            Rvalue::BinaryOp(op, vals) | Rvalue::CheckedBinaryOp(op, vals) => {\n+                use BinOp::*;\n+                let a = vals.0.ty(&self.body.local_decls, self.tcx);\n+                let b = vals.1.ty(&self.body.local_decls, self.tcx);\n+                match op {\n+                    Offset => {\n+                        check_kinds!(a, \"Cannot offset non-pointer type {:?}\", ty::RawPtr(..));\n+                        if b != self.tcx.types.isize && b != self.tcx.types.usize {\n+                            self.fail(location, format!(\"Cannot offset by non-isize type {:?}\", b));\n+                        }\n+                    }\n+                    Eq | Lt | Le | Ne | Ge | Gt => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot compare type {:?}\",\n+                                ty::Bool\n+                                    | ty::Char\n+                                    | ty::Int(..)\n+                                    | ty::Uint(..)\n+                                    | ty::Float(..)\n+                                    | ty::RawPtr(..)\n+                                    | ty::FnPtr(..)\n+                            )\n+                        }\n+                        // None of the possible types have lifetimes, so we can just compare\n+                        // directly\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                \"encountered `Assign` statement with overlapping memory\",\n+                                format!(\"Cannot compare unequal types {:?} and {:?}\", a, b),\n                             );\n                         }\n                     }\n-                    Rvalue::Aggregate(agg_kind, _) => {\n-                        let disallowed = match **agg_kind {\n-                            AggregateKind::Array(..) => false,\n-                            AggregateKind::Generator(..) => {\n-                                self.mir_phase >= MirPhase::GeneratorsLowered\n-                            }\n-                            _ => self.mir_phase >= MirPhase::Deaggregated,\n-                        };\n-                        if disallowed {\n+                    Shl | Shr => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot shift non-integer type {:?}\",\n+                                ty::Uint(..) | ty::Int(..)\n+                            )\n+                        }\n+                    }\n+                    BitAnd | BitOr | BitXor => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot perform bitwise op on type {:?}\",\n+                                ty::Uint(..) | ty::Int(..) | ty::Bool\n+                            )\n+                        }\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                format!(\"{:?} have been lowered to field assignments\", rvalue),\n-                            )\n+                                format!(\n+                                    \"Cannot perform bitwise op on unequal types {:?} and {:?}\",\n+                                    a, b\n+                                ),\n+                            );\n                         }\n                     }\n-                    Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n-                        if self.mir_phase >= MirPhase::DropsLowered {\n+                    Add | Sub | Mul | Div | Rem => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot perform op on type {:?}\",\n+                                ty::Uint(..) | ty::Int(..) | ty::Float(..)\n+                            )\n+                        }\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n+                                format!(\"Cannot perform op on unequal types {:?} and {:?}\", a, b),\n                             );\n                         }\n                     }\n-                    _ => {}\n+                }\n+            }\n+            Rvalue::UnaryOp(op, operand) => {\n+                let a = operand.ty(&self.body.local_decls, self.tcx);\n+                match op {\n+                    UnOp::Neg => {\n+                        check_kinds!(a, \"Cannot negate type {:?}\", ty::Int(..) | ty::Float(..))\n+                    }\n+                    UnOp::Not => {\n+                        check_kinds!(\n+                            a,\n+                            \"Cannot binary not type {:?}\",\n+                            ty::Int(..) | ty::Uint(..) | ty::Bool\n+                        );\n+                    }\n+                }\n+            }\n+            Rvalue::ShallowInitBox(operand, _) => {\n+                let a = operand.ty(&self.body.local_decls, self.tcx);\n+                check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n+            }\n+            _ => {}\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (dest, rvalue)) => {\n+                // LHS and RHS of the assignment must have the same type.\n+                let left_ty = dest.ty(&self.body.local_decls, self.tcx).ty;\n+                let right_ty = rvalue.ty(&self.body.local_decls, self.tcx);\n+                if !self.mir_assign_valid_types(right_ty, left_ty) {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"encountered `{:?}` with incompatible types:\\n\\\n+                            left-hand side has type: {}\\n\\\n+                            right-hand side has type: {}\",\n+                            statement.kind, left_ty, right_ty,\n+                        ),\n+                    );\n+                }\n+                // FIXME(JakobDegen): Check this for all rvalues, not just this one.\n+                if let Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) = rvalue {\n+                    // The sides of an assignment must not alias. Currently this just checks whether\n+                    // the places are identical.\n+                    if dest == src {\n+                        self.fail(\n+                            location,\n+                            \"encountered `Assign` statement with overlapping memory\",\n+                        );\n+                    }\n                 }\n             }\n             StatementKind::AscribeUserType(..) => {"}, {"sha": "eab51b65f1a19a6e868dbe6b4c24221a5d7b917e", "filename": "src/test/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5e986ed8e7d589787532857ef74576473adcf/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5e986ed8e7d589787532857ef74576473adcf/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs?ref=9ac5e986ed8e7d589787532857ef74576473adcf", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // EMIT_MIR lower_intrinsics.wrapping.LowerIntrinsics.diff\n-pub fn wrapping<T: Copy>(a: T, b: T) {\n+pub fn wrapping(a: i32, b: i32) {\n     let _x = core::intrinsics::wrapping_add(a, b);\n     let _y = core::intrinsics::wrapping_sub(a, b);\n     let _z = core::intrinsics::wrapping_mul(a, b);"}, {"sha": "5a0286bad2fb7cba37a66835507b7496a3a41101", "filename": "src/test/mir-opt/lower_intrinsics.wrapping.LowerIntrinsics.diff", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9ac5e986ed8e7d589787532857ef74576473adcf/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/9ac5e986ed8e7d589787532857ef74576473adcf/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff?ref=9ac5e986ed8e7d589787532857ef74576473adcf", "patch": "@@ -1,23 +1,23 @@\n - // MIR for `wrapping` before LowerIntrinsics\n + // MIR for `wrapping` after LowerIntrinsics\n   \n-  fn wrapping(_1: T, _2: T) -> () {\n-      debug a => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:26: 6:27\n-      debug b => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:32: 6:33\n-      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:6:38: 6:38\n-      let _3: T;                           // in scope 0 at $DIR/lower_intrinsics.rs:7:9: 7:11\n-      let mut _4: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n-      let mut _5: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n-      let mut _7: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:8:45: 8:46\n-      let mut _8: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:8:48: 8:49\n-      let mut _10: T;                      // in scope 0 at $DIR/lower_intrinsics.rs:9:45: 9:46\n-      let mut _11: T;                      // in scope 0 at $DIR/lower_intrinsics.rs:9:48: 9:49\n+  fn wrapping(_1: i32, _2: i32) -> () {\n+      debug a => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:17: 6:18\n+      debug b => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:25: 6:26\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:6:33: 6:33\n+      let _3: i32;                         // in scope 0 at $DIR/lower_intrinsics.rs:7:9: 7:11\n+      let mut _4: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n+      let mut _5: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n+      let mut _7: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:8:45: 8:46\n+      let mut _8: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:8:48: 8:49\n+      let mut _10: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:9:45: 9:46\n+      let mut _11: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:9:48: 9:49\n       scope 1 {\n           debug _x => _3;                  // in scope 1 at $DIR/lower_intrinsics.rs:7:9: 7:11\n-          let _6: T;                       // in scope 1 at $DIR/lower_intrinsics.rs:8:9: 8:11\n+          let _6: i32;                     // in scope 1 at $DIR/lower_intrinsics.rs:8:9: 8:11\n           scope 2 {\n               debug _y => _6;              // in scope 2 at $DIR/lower_intrinsics.rs:8:9: 8:11\n-              let _9: T;                   // in scope 2 at $DIR/lower_intrinsics.rs:9:9: 9:11\n+              let _9: i32;                 // in scope 2 at $DIR/lower_intrinsics.rs:9:9: 9:11\n               scope 3 {\n                   debug _z => _9;          // in scope 3 at $DIR/lower_intrinsics.rs:9:9: 9:11\n               }\n@@ -30,10 +30,10 @@\n           _4 = _1;                         // scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n           StorageLive(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n           _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n--         _3 = wrapping_add::<T>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n+-         _3 = wrapping_add::<i32>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:7:14: 7:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_add::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_add::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _3 = Add(move _4, move _5);      // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n       }\n@@ -46,10 +46,10 @@\n           _7 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:8:45: 8:46\n           StorageLive(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:8:48: 8:49\n           _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:8:48: 8:49\n--         _6 = wrapping_sub::<T>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n+-         _6 = wrapping_sub::<i32>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:8:14: 8:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_sub::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_sub::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _6 = Sub(move _7, move _8);      // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n +         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n       }\n@@ -62,18 +62,18 @@\n           _10 = _1;                        // scope 2 at $DIR/lower_intrinsics.rs:9:45: 9:46\n           StorageLive(_11);                // scope 2 at $DIR/lower_intrinsics.rs:9:48: 9:49\n           _11 = _2;                        // scope 2 at $DIR/lower_intrinsics.rs:9:48: 9:49\n--         _9 = wrapping_mul::<T>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n+-         _9 = wrapping_mul::<i32>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:9:14: 9:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_mul::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_mul::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _9 = Mul(move _10, move _11);    // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n +         goto -> bb3;                     // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n       }\n   \n       bb3: {\n           StorageDead(_11);                // scope 2 at $DIR/lower_intrinsics.rs:9:49: 9:50\n           StorageDead(_10);                // scope 2 at $DIR/lower_intrinsics.rs:9:49: 9:50\n-          _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:6:38: 10:2\n+          _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:6:33: 10:2\n           StorageDead(_9);                 // scope 2 at $DIR/lower_intrinsics.rs:10:1: 10:2\n           StorageDead(_6);                 // scope 1 at $DIR/lower_intrinsics.rs:10:1: 10:2\n           StorageDead(_3);                 // scope 0 at $DIR/lower_intrinsics.rs:10:1: 10:2"}]}