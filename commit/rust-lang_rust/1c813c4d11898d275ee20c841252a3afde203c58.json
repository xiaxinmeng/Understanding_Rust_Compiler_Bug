{"sha": "1c813c4d11898d275ee20c841252a3afde203c58", "node_id": "C_kwDOAAsO6NoAKDFjODEzYzRkMTE4OThkMjc1ZWUyMGM4NDEyNTJhM2FmZGUyMDNjNTg", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-11-09T15:17:42Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-11-14T01:15:18Z"}, "message": "Reuse `Vec<T>` backing storage for `Rc<[T]>`\n\nCo-authored-by: joboet <jonas.boettiger@icloud.com>", "tree": {"sha": "8bf5021a870153eedf45085a0a6654e0eca010bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bf5021a870153eedf45085a0a6654e0eca010bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c813c4d11898d275ee20c841252a3afde203c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c813c4d11898d275ee20c841252a3afde203c58", "html_url": "https://github.com/rust-lang/rust/commit/1c813c4d11898d275ee20c841252a3afde203c58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c813c4d11898d275ee20c841252a3afde203c58/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b513af6c4b39b86f70b19fbd1a2dc72aa485d5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b513af6c4b39b86f70b19fbd1a2dc72aa485d5c", "html_url": "https://github.com/rust-lang/rust/commit/7b513af6c4b39b86f70b19fbd1a2dc72aa485d5c"}], "stats": {"total": 84, "additions": 65, "deletions": 19}, "files": [{"sha": "f3cbfe27b3eed620adf88462ecba8e7c0dfdf80e", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1c813c4d11898d275ee20c841252a3afde203c58/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c813c4d11898d275ee20c841252a3afde203c58/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=1c813c4d11898d275ee20c841252a3afde203c58", "patch": "@@ -293,6 +293,15 @@ struct RcBox<T: ?Sized> {\n     value: T,\n }\n \n+/// Calculate layout for `RcBox<T>` using the inner value's layout\n+fn rcbox_layout_for_value_layout(layout: Layout) -> Layout {\n+    // Calculate layout using the given value layout.\n+    // Previously, layout was calculated on the expression\n+    // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n+    // reference (see #54908).\n+    Layout::new::<RcBox<()>>().extend(layout).unwrap().0.pad_to_align()\n+}\n+\n /// A single-threaded reference-counting pointer. 'Rc' stands for 'Reference\n /// Counted'.\n ///\n@@ -1334,11 +1343,7 @@ impl<T: ?Sized> Rc<T> {\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n     ) -> *mut RcBox<T> {\n-        // Calculate layout using the given value layout.\n-        // Previously, layout was calculated on the expression\n-        // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n-        // reference (see #54908).\n-        let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        let layout = rcbox_layout_for_value_layout(value_layout);\n         unsafe {\n             Rc::try_allocate_for_layout(value_layout, allocate, mem_to_rcbox)\n                 .unwrap_or_else(|_| handle_alloc_error(layout))\n@@ -1357,11 +1362,7 @@ impl<T: ?Sized> Rc<T> {\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n     ) -> Result<*mut RcBox<T>, AllocError> {\n-        // Calculate layout using the given value layout.\n-        // Previously, layout was calculated on the expression\n-        // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n-        // reference (see #54908).\n-        let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        let layout = rcbox_layout_for_value_layout(value_layout);\n \n         // Allocate for the layout.\n         let ptr = allocate(layout)?;\n@@ -1428,7 +1429,7 @@ impl<T> Rc<[T]> {\n         }\n     }\n \n-    /// Copy elements from slice into newly allocated Rc<\\[T\\]>\n+    /// Copy elements from slice into newly allocated `Rc<[T]>`\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`\n     #[cfg(not(no_global_oom_handling))]\n@@ -1440,6 +1441,48 @@ impl<T> Rc<[T]> {\n         }\n     }\n \n+    /// Create an `Rc<[T]>` by reusing the underlying memory\n+    /// of a `Vec<T>`. This will return the vector if the existing allocation\n+    /// is not large enough.\n+    #[cfg(not(no_global_oom_handling))]\n+    fn try_from_vec_in_place(mut v: Vec<T>) -> Result<Rc<[T]>, Vec<T>> {\n+        let layout_elements = Layout::array::<T>(v.len()).unwrap();\n+        let layout_allocation = Layout::array::<T>(v.capacity()).unwrap();\n+        let layout_rcbox = rcbox_layout_for_value_layout(layout_elements);\n+        let mut ptr = NonNull::new(v.as_mut_ptr()).expect(\"`Vec<T>` stores `NonNull<T>`\");\n+        if layout_rcbox.size() > layout_allocation.size()\n+            || layout_rcbox.align() > layout_allocation.align()\n+        {\n+            // Can't fit - calling `grow` would involve `realloc`\n+            // (which copies the elements), followed by copying again.\n+            return Err(v);\n+        }\n+        if layout_rcbox.size() < layout_allocation.size()\n+            || layout_rcbox.align() < layout_allocation.align()\n+        {\n+            // We need to shrink the allocation so that it fits\n+            // https://doc.rust-lang.org/nightly/std/alloc/trait.Allocator.html#memory-fitting\n+            // SAFETY:\n+            // - Vec allocates by requesting `Layout::array::<T>(capacity)`, so this capacity matches\n+            // - `layout_rcbox` is smaller\n+            // If this fails, the ownership has not been transferred\n+            if let Ok(p) = unsafe { Global.shrink(ptr.cast(), layout_allocation, layout_rcbox) } {\n+                ptr = p.cast();\n+            } else {\n+                return Err(v);\n+            }\n+        }\n+        // Make sure the vec's memory isn't deallocated now\n+        let v = mem::ManuallyDrop::new(v);\n+        let ptr: *mut RcBox<[T]> = ptr::slice_from_raw_parts_mut(ptr.as_ptr(), v.len()) as _;\n+        unsafe {\n+            ptr::copy(ptr.cast::<T>(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n+            ptr::write(&mut (*ptr).strong, Cell::new(1));\n+            ptr::write(&mut (*ptr).weak, Cell::new(1));\n+            Ok(Self::from_ptr(ptr))\n+        }\n+    }\n+\n     /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n@@ -1965,14 +2008,17 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     /// assert_eq!(vec![1, 2, 3], *shared);\n     /// ```\n     #[inline]\n-    fn from(mut v: Vec<T>) -> Rc<[T]> {\n-        unsafe {\n-            let rc = Rc::copy_from_slice(&v);\n-\n-            // Allow the Vec to free its memory, but not destroy its contents\n-            v.set_len(0);\n-\n-            rc\n+    fn from(v: Vec<T>) -> Rc<[T]> {\n+        match Rc::try_from_vec_in_place(v) {\n+            Ok(rc) => rc,\n+            Err(mut v) => {\n+                unsafe {\n+                    let rc = Rc::copy_from_slice(&v);\n+                    // Allow the Vec to free its memory, but not destroy its contents\n+                    v.set_len(0);\n+                    rc\n+                }\n+            }\n         }\n     }\n }"}]}