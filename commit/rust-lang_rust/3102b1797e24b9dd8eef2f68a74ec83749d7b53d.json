{"sha": "3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMDJiMTc5N2UyNGI5ZGQ4ZWVmMmY2OGE3NGVjODM3NDlkN2I1M2Q=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-04T00:13:14Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-04T21:13:17Z"}, "message": "std: replace str::as_c_str with std::c_str", "tree": {"sha": "c68578899941c134b1bc4e59999d5a40047f89f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c68578899941c134b1bc4e59999d5a40047f89f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "html_url": "https://github.com/rust-lang/rust/commit/3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0512475fdab549182e73a42c2cd02df0cb710ebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0512475fdab549182e73a42c2cd02df0cb710ebf", "html_url": "https://github.com/rust-lang/rust/commit/0512475fdab549182e73a42c2cd02df0cb710ebf"}], "stats": {"total": 777, "additions": 509, "deletions": 268}, "files": [{"sha": "9106d4cd684d916f5c6d58bcbb83dd87962cce90", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -11,7 +11,7 @@\n // FIXME #3921. This is unsafe because linenoise uses global mutable\n // state without mutexes.\n \n-\n+use std::c_str::ToCStr;\n use std::libc::{c_char, c_int};\n use std::local_data;\n use std::str;\n@@ -32,7 +32,7 @@ pub mod rustrt {\n \n /// Add a line to history\n pub unsafe fn add_history(line: &str) -> bool {\n-    do line.as_c_str |buf| {\n+    do line.to_c_str().with_ref |buf| {\n         rustrt::linenoiseHistoryAdd(buf) == 1 as c_int\n     }\n }\n@@ -44,21 +44,21 @@ pub unsafe fn set_history_max_len(len: int) -> bool {\n \n /// Save line history to a file\n pub unsafe fn save_history(file: &str) -> bool {\n-    do file.as_c_str |buf| {\n+    do file.to_c_str().with_ref |buf| {\n         rustrt::linenoiseHistorySave(buf) == 1 as c_int\n     }\n }\n \n /// Load line history from a file\n pub unsafe fn load_history(file: &str) -> bool {\n-    do file.as_c_str |buf| {\n+    do file.to_c_str().with_ref |buf| {\n         rustrt::linenoiseHistoryLoad(buf) == 1 as c_int\n     }\n }\n \n /// Print out a prompt and then wait for input and return it\n pub unsafe fn read(prompt: &str) -> Option<~str> {\n-    do prompt.as_c_str |buf| {\n+    do prompt.to_c_str().with_ref |buf| {\n         let line = rustrt::linenoise(buf);\n \n         if line.is_null() { None }\n@@ -80,7 +80,7 @@ pub unsafe fn complete(cb: CompletionCb) {\n \n             unsafe {\n                 do cb(str::raw::from_c_str(line)) |suggestion| {\n-                    do suggestion.as_c_str |buf| {\n+                    do suggestion.to_c_str().with_ref |buf| {\n                         rustrt::linenoiseAddCompletion(completions, buf);\n                     }\n                 }"}, {"sha": "3d02d50b49125b0315ef1f9bddf1efe28a6063c2", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -22,6 +22,7 @@ use middle::trans::common::gensym_name;\n use middle::ty;\n use util::ppaux;\n \n+use std::c_str::ToCStr;\n use std::char;\n use std::hash::Streaming;\n use std::hash;\n@@ -76,9 +77,9 @@ pub fn WriteOutputFile(sess: Session,\n         OptLevel: c_int,\n         EnableSegmentedStacks: bool) {\n     unsafe {\n-        do Triple.as_c_str |Triple| {\n-            do Feature.as_c_str |Feature| {\n-                do Output.as_c_str |Output| {\n+        do Triple.to_c_str().with_ref |Triple| {\n+            do Feature.to_c_str().with_ref |Feature| {\n+                do Output.to_c_str().with_ref |Output| {\n                     let result = llvm::LLVMRustWriteOutputFile(\n                             PM,\n                             M,\n@@ -105,6 +106,7 @@ pub mod jit {\n     use lib::llvm::{ModuleRef, ContextRef, ExecutionEngineRef};\n     use metadata::cstore;\n \n+    use std::c_str::ToCStr;\n     use std::cast;\n     use std::local_data;\n     use std::unstable::intrinsics;\n@@ -146,7 +148,7 @@ pub mod jit {\n \n                 debug!(\"linking: %s\", path);\n \n-                do path.as_c_str |buf_t| {\n+                do path.to_c_str().with_ref |buf_t| {\n                     if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n                         llvm_err(sess, ~\"Could not link\");\n                     }\n@@ -165,7 +167,7 @@ pub mod jit {\n             // Next, we need to get a handle on the _rust_main function by\n             // looking up it's corresponding ValueRef and then requesting that\n             // the execution engine compiles the function.\n-            let fun = do \"_rust_main\".as_c_str |entry| {\n+            let fun = do \"_rust_main\".to_c_str().with_ref |entry| {\n                 llvm::LLVMGetNamedFunction(m, entry)\n             };\n             if fun.is_null() {\n@@ -230,6 +232,7 @@ pub mod write {\n \n     use back::passes;\n \n+    use std::c_str::ToCStr;\n     use std::libc::{c_int, c_uint};\n     use std::path::Path;\n     use std::run;\n@@ -263,14 +266,14 @@ pub mod write {\n                   output_type_bitcode => {\n                     if opts.optimize != session::No {\n                         let filename = output.with_filetype(\"no-opt.bc\");\n-                        do filename.to_str().as_c_str |buf| {\n+                        do filename.to_c_str().with_ref |buf| {\n                             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                         }\n                     }\n                   }\n                   _ => {\n                     let filename = output.with_filetype(\"bc\");\n-                    do filename.to_str().as_c_str |buf| {\n+                    do filename.to_c_str().with_ref |buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                     }\n                   }\n@@ -333,7 +336,7 @@ pub mod write {\n                     // Always output the bitcode file with --save-temps\n \n                     let filename = output.with_filetype(\"opt.bc\");\n-                    do filename.to_str().as_c_str |buf| {\n+                    do filename.to_c_str().with_ref |buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                     };\n                     // Save the assembly file if -S is used\n@@ -391,13 +394,13 @@ pub mod write {\n \n             if output_type == output_type_llvm_assembly {\n                 // Given options \"-S --emit-llvm\": output LLVM assembly\n-                do output.to_str().as_c_str |buf_o| {\n+                do output.to_c_str().with_ref |buf_o| {\n                     llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o);\n                 }\n             } else {\n                 // If only a bitcode file is asked for by using the\n                 // '--emit-llvm' flag, then output it here\n-                do output.to_str().as_c_str |buf| {\n+                do output.to_c_str().with_ref |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 }\n             }"}, {"sha": "eb70a811fe00b4ac31961d551909d13fd30cabcb", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::c_str::ToCStr;\n use std::io;\n \n use driver::session::{OptLevel, No, Less, Aggressive};\n@@ -173,7 +174,7 @@ pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~s\n }\n \n pub fn create_pass(name:&str) -> Option<PassRef> {\n-    do name.as_c_str |s| {\n+    do name.to_c_str().with_ref |s| {\n         unsafe {\n             let p = llvm::LLVMCreatePass(s);\n             if p.is_null() {"}, {"sha": "98f32af2f30aa1a41bacd1904c137e2016804437", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use std::c_str::ToCStr;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ushort};\n use std::option;\n@@ -2234,7 +2234,7 @@ pub struct TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    let lltd = do string_rep.as_c_str |buf| {\n+    let lltd = do string_rep.to_c_str().with_ref |buf| {\n         unsafe { llvm::LLVMCreateTargetData(buf) }\n     };\n "}, {"sha": "8b41277a3dab70f613c58df24c0dbcdf892f4e29", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -24,6 +24,7 @@ use syntax::print::pprust;\n use syntax::{ast, attr};\n use syntax::attr::AttrMetaMethods;\n \n+use std::c_str::ToCStr;\n use std::cast;\n use std::io;\n use std::num;\n@@ -186,7 +187,7 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n fn get_metadata_section(os: os,\n                         filename: &Path) -> Option<@~[u8]> {\n     unsafe {\n-        let mb = do filename.to_str().as_c_str |buf| {\n+        let mb = do filename.to_c_str().with_ref |buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n         };\n         if mb as int == 0 { return option::None::<@~[u8]>; }"}, {"sha": "9973599e339545f69778b0204533754f0ed4825b", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -12,6 +12,7 @@\n # Translation of inline assembly.\n */\n \n+use std::c_str::ToCStr;\n \n use lib;\n use middle::trans::build::*;\n@@ -122,8 +123,8 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         ast::asm_intel => lib::llvm::AD_Intel\n     };\n \n-    let r = do ia.asm.as_c_str |a| {\n-        do constraints.as_c_str |c| {\n+    let r = do ia.asm.to_c_str().with_ref |a| {\n+        do constraints.to_c_str().with_ref |c| {\n             InlineAsmCall(bcx, a, c, inputs, output, ia.volatile, ia.alignstack, dialect)\n         }\n     };"}, {"sha": "5b048558fd117ca89264c04c65e4fac9ff302c6e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -65,6 +65,7 @@ use util::ppaux::{Repr, ty_to_str};\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::hash;\n use std::hashmap::HashMap;\n use std::io;\n@@ -179,7 +180,7 @@ impl<'self> Drop for StatRecorder<'self> {\n }\n \n pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n-    let llfn: ValueRef = do name.as_c_str |buf| {\n+    let llfn: ValueRef = do name.to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n         }\n@@ -219,7 +220,7 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n         None => ()\n     }\n     unsafe {\n-        let c = do name.as_c_str |buf| {\n+        let c = do name.to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n         };\n         externs.insert(name, c);\n@@ -548,7 +549,7 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n     if cx.sess.opts.save_temps {\n-        do s.as_c_str |buf| {\n+        do s.to_c_str().with_ref |buf| {\n             unsafe {\n                 llvm::LLVMSetValueName(v, buf)\n             }\n@@ -1162,7 +1163,7 @@ pub fn new_block(cx: @mut FunctionContext,\n                  opt_node_info: Option<NodeInfo>)\n               -> @mut Block {\n     unsafe {\n-        let llbb = do name.as_c_str |buf| {\n+        let llbb = do name.to_c_str().with_ref |buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n         };\n         let bcx = @mut Block::new(llbb,\n@@ -1579,7 +1580,7 @@ pub struct BasicBlocks {\n pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        do \"static_allocas\".as_c_str | buf| {\n+        do \"static_allocas\".to_c_str().with_ref | buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n         }\n     }\n@@ -1588,7 +1589,7 @@ pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        do \"return\".as_c_str |buf| {\n+        do \"return\".to_c_str().with_ref |buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n         }\n     }\n@@ -2346,7 +2347,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             };\n             decl_cdecl_fn(ccx.llmod, main_name, llfty)\n         };\n-        let llbb = do \"top\".as_c_str |buf| {\n+        let llbb = do \"top\".to_c_str().with_ref |buf| {\n             unsafe {\n                 llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n             }\n@@ -2356,7 +2357,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n             let crate_map = ccx.crate_map;\n-            let opaque_crate_map = do \"crate_map\".as_c_str |buf| {\n+            let opaque_crate_map = do \"crate_map\".to_c_str().with_ref |buf| {\n                 llvm::LLVMBuildPointerCast(bld, crate_map, Type::i8p().to_ref(), buf)\n             };\n \n@@ -2374,7 +2375,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n \n                 let args = {\n-                    let opaque_rust_main = do \"rust_main\".as_c_str |buf| {\n+                    let opaque_rust_main = do \"rust_main\".to_c_str().with_ref |buf| {\n                         llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n                     };\n \n@@ -2462,7 +2463,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                             unsafe {\n                                 let llty = llvm::LLVMTypeOf(v);\n-                                let g = do sym.as_c_str |buf| {\n+                                let g = do sym.to_c_str().with_ref |buf| {\n                                     llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n                                 };\n \n@@ -2486,7 +2487,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n                         Some(sect) => unsafe {\n-                            do sect.as_c_str |buf| {\n+                            do sect.to_c_str().with_ref |buf| {\n                                 llvm::LLVMSetSection(v, buf);\n                             }\n                         },\n@@ -2527,7 +2528,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                         }\n                         ast::foreign_item_static(*) => {\n                             let ident = token::ident_to_str(&ni.ident);\n-                            let g = do ident.as_c_str |buf| {\n+                            let g = do ident.to_c_str().with_ref |buf| {\n                                 unsafe {\n                                     let ty = type_of(ccx, ty);\n                                     llvm::LLVMAddGlobal(ccx.llmod, ty.to_ref(), buf)\n@@ -2633,7 +2634,7 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n             let s = mangle_exported_name(ccx, p, ty::mk_int()).to_managed();\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n-            let discrim_gvar = do s.as_c_str |buf| {\n+            let discrim_gvar = do s.to_c_str().with_ref |buf| {\n                 unsafe {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n                 }\n@@ -2774,7 +2775,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n \n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n-    let gc_metadata = do gc_metadata_name.as_c_str |buf| {\n+    let gc_metadata = do gc_metadata_name.to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n         }\n@@ -2789,7 +2790,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     let elttype = Type::struct_([ccx.int_type, ccx.int_type], false);\n     let maptype = Type::array(&elttype, (ccx.module_data.len() + 1) as u64);\n-    let map = do \"_rust_mod_map\".as_c_str |buf| {\n+    let map = do \"_rust_mod_map\".to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n         }\n@@ -2837,7 +2838,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = Type::array(&int_type, n_subcrates as u64);\n     let maptype = Type::struct_([Type::i32(), Type::i8p(), int_type, arrtype], false);\n-    let map = do sym_name.as_c_str |buf| {\n+    let map = do sym_name.to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n         }\n@@ -2856,7 +2857,7 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n                       cdata.name,\n                       cstore::get_crate_vers(cstore, i),\n                       cstore::get_crate_hash(cstore, i));\n-        let cr = do nm.as_c_str |buf| {\n+        let cr = do nm.to_c_str().with_ref |buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n             }\n@@ -2919,21 +2920,21 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::Crate) {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct([llmeta]);\n-    let mut llglobal = do \"rust_metadata\".as_c_str |buf| {\n+    let mut llglobal = do \"rust_metadata\".to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n         }\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        do cx.sess.targ_cfg.target_strs.meta_sect_name.as_c_str |buf| {\n+        do cx.sess.targ_cfg.target_strs.meta_sect_name.to_c_str().with_ref |buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         };\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n         let t_ptr_i8 = Type::i8p();\n         llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n-        let llvm_used = do \"llvm.used\".as_c_str |buf| {\n+        let llvm_used = do \"llvm.used\".to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(cx.llmod, Type::array(&t_ptr_i8, 1).to_ref(), buf)\n         };\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n@@ -2947,7 +2948,7 @@ fn mk_global(ccx: &CrateContext,\n              internal: bool)\n           -> ValueRef {\n     unsafe {\n-        let llglobal = do name.as_c_str |buf| {\n+        let llglobal = do name.to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(llglobal, llval);"}, {"sha": "bfdee1b8f34df4ff92e44dcb80cf04fcba2171d2", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -423,7 +423,7 @@ impl Builder {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                do name.as_c_str |c| {\n+                do name.to_c_str().with_ref |c| {\n                     llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c)\n                 }\n             }\n@@ -739,7 +739,7 @@ impl Builder {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = fmt!(\"# %s\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let asm = do comment_text.as_c_str |c| {\n+            let asm = do comment_text.to_c_str().with_ref |c| {\n                 unsafe {\n                     llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n                                              c, noname(), False, False)\n@@ -895,7 +895,7 @@ impl Builder {\n             let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n             let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n             let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-            let T: ValueRef = do \"llvm.trap\".as_c_str |buf| {\n+            let T: ValueRef = do \"llvm.trap\".to_c_str().with_ref |buf| {\n                 llvm::LLVMGetNamedFunction(M, buf)\n             };\n             assert!((T as int != 0));"}, {"sha": "4f5fae8db1a4cf4783d82969f7273749a575b577", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -31,6 +31,7 @@ use util::ppaux::{Repr};\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::cast::transmute;\n use std::cast;\n use std::hashmap::{HashMap};\n@@ -707,7 +708,7 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        do s.as_c_str |buf| {\n+        do s.to_c_str().with_ref |buf| {\n             llvm::LLVMConstRealOfString(t.to_ref(), buf)\n         }\n     }\n@@ -755,12 +756,12 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n             None => ()\n         }\n \n-        let sc = do s.as_c_str |buf| {\n+        let sc = do s.to_c_str().with_ref |buf| {\n             llvm::LLVMConstStringInContext(cx.llcx, buf, s.len() as c_uint, False)\n         };\n \n         let gsym = token::gensym(\"str\");\n-        let g = do fmt!(\"str%u\", gsym).as_c_str |buf| {\n+        let g = do fmt!(\"str%u\", gsym).to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(g, sc);"}, {"sha": "0cb423d4921eb77a0ab654d279d5b6d2e892bc9d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -30,6 +30,7 @@ use util::ppaux::{Repr, ty_to_str};\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::libc::c_uint;\n use syntax::{ast, ast_util, ast_map};\n \n@@ -101,7 +102,7 @@ pub fn const_vec(cx: @mut CrateContext, e: &ast::expr, es: &[@ast::expr])\n \n fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n-        let gv = do \"const\".as_c_str |name| {\n+        let gv = do \"const\".to_c_str().with_ref |name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n         };\n         llvm::LLVMSetInitializer(gv, cv);\n@@ -527,7 +528,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               ast::expr_vec(ref es, ast::m_imm) => {\n                 let (cv, sz, llunitty) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n-                let gv = do \"const\".as_c_str |name| {\n+                let gv = do \"const\".to_c_str().with_ref |name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n                 };\n                 llvm::LLVMSetInitializer(gv, cv);"}, {"sha": "54c957d115a4da811d9e4d7120ff2cf8d414e345", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -26,6 +26,7 @@ use middle::ty;\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::hash;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n@@ -124,11 +125,17 @@ impl CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n             set_task_llcx(llcx);\n-            let llmod = name.as_c_str(|buf| llvm::LLVMModuleCreateWithNameInContext(buf, llcx));\n+            let llmod = do name.to_c_str().with_ref |buf| {\n+                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n+            };\n             let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n             let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-            data_layout.as_c_str(|buf| llvm::LLVMSetDataLayout(llmod, buf));\n-            targ_triple.as_c_str(|buf| llvm::LLVMSetTarget(llmod, buf));\n+            do data_layout.to_c_str().with_ref |buf| {\n+                llvm::LLVMSetDataLayout(llmod, buf)\n+            };\n+            do targ_triple.to_c_str().with_ref |buf| {\n+                llvm::LLVMSetTarget(llmod, buf)\n+            };\n             let targ_cfg = sess.targ_cfg;\n \n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);"}, {"sha": "ec96371132e96b19e23b3d01a6e61f2b278f82bc", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::c_str::ToCStr;\n \n use back::link;\n use lib;\n@@ -240,7 +241,7 @@ pub fn trans_log(log_ex: &ast::expr,\n             ccx, modpath, \"loglevel\");\n         let global;\n         unsafe {\n-            global = do s.as_c_str |buf| {\n+            global = do s.to_c_str().with_ref |buf| {\n                 llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n             };\n             llvm::LLVMSetGlobalConstant(global, False);"}, {"sha": "c427c34e1d85dbed268a5f0179b2924429109ea7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -63,6 +63,7 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux::ty_to_str;\n \n+use std::c_str::ToCStr;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n@@ -159,7 +160,7 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n         let ty = node_id_type(bcx, node_id);\n         let type_metadata = type_metadata(cx, ty, span);\n \n-        let var_metadata = do name.as_c_str |name| {\n+        let var_metadata = do name.to_c_str().with_ref |name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateLocalVariable(\n                     DIB(cx),\n@@ -246,7 +247,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n             argument_index as c_uint\n         };\n \n-        let arg_metadata = do name.as_c_str |name| {\n+        let arg_metadata = do name.to_c_str().with_ref |name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateLocalVariable(\n                     DIB(cx),\n@@ -382,8 +383,8 @@ pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n     };\n \n     let fn_metadata =\n-        do cx.sess.str_of(ident).as_c_str |name| {\n-        do cx.sess.str_of(ident).as_c_str |linkage| {\n+        do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+        do cx.sess.str_of(ident).to_c_str().with_ref |linkage| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFunction(\n                     DIB(cx),\n@@ -430,11 +431,11 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n \n-    do crate_name.as_c_str |crate_name| {\n-    do work_dir.as_c_str |work_dir| {\n-    do producer.as_c_str |producer| {\n-    do \"\".as_c_str |flags| {\n-    do \"\".as_c_str |split_name| {\n+    do crate_name.to_c_str().with_ref |crate_name| {\n+    do work_dir.to_c_str().with_ref |work_dir| {\n+    do producer.to_c_str().with_ref |producer| {\n+    do \"\".to_c_str().with_ref |flags| {\n+    do \"\".to_c_str().with_ref |split_name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n                 DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n@@ -461,8 +462,8 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n         };\n \n     let file_metadata =\n-        do file_name.as_c_str |file_name| {\n-        do work_dir.as_c_str |work_dir| {\n+        do file_name.to_c_str().with_ref |file_name| {\n+        do work_dir.to_c_str().with_ref |work_dir| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n             }\n@@ -550,7 +551,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let ty_metadata = do name.as_c_str |name| {\n+    let ty_metadata = do name.to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -571,7 +572,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = ty_to_str(cx.tcx, pointer_type);\n-    let ptr_metadata = do name.as_c_str |name| {\n+    let ptr_metadata = do name.to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n                 DIB(cx),\n@@ -665,7 +666,7 @@ fn enum_metadata(cx: &mut CrateContext,\n             let name: &str = cx.sess.str_of(v.name);\n             let discriminant_value = v.disr_val as c_ulonglong;\n \n-            do name.as_c_str |name| {\n+            do name.to_c_str().with_ref |name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerator(\n                         DIB(cx),\n@@ -679,7 +680,7 @@ fn enum_metadata(cx: &mut CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| {\n+    let discriminant_type_metadata = do enum_name.to_c_str().with_ref |enum_name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateEnumerationType(\n                 DIB(cx),\n@@ -716,7 +717,7 @@ fn enum_metadata(cx: &mut CrateContext,\n                         Some(discriminant_type_metadata),\n                         span);\n \n-                    do \"\".as_c_str |name| {\n+                    do \"\".to_c_str().with_ref |name| {\n                         unsafe {\n                             llvm::LLVMDIBuilderCreateMemberType(\n                                 DIB(cx),\n@@ -736,7 +737,7 @@ fn enum_metadata(cx: &mut CrateContext,\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-            return do enum_name.as_c_str |enum_name| {\n+            return do enum_name.to_c_str().with_ref |enum_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateUnionType(\n                     DIB(cx),\n@@ -820,7 +821,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n             let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n             let member_name: &str = member_names[i];\n \n-            do member_name.as_c_str |member_name| {\n+            do member_name.to_c_str().with_ref |member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n@@ -838,7 +839,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n         })\n         .collect();\n \n-    return do composite_type_name.as_c_str |name| {\n+    return do composite_type_name.to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateStructType(\n                 DIB(cx),\n@@ -1064,7 +1065,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     debug!(\"unimplemented_type_metadata: %?\", ty::get(t));\n \n     let name = ty_to_str(cx.tcx, t);\n-    let metadata = do fmt!(\"NYI<%s>\", name).as_c_str |name| {\n+    let metadata = do fmt!(\"NYI<%s>\", name).to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),"}, {"sha": "10586dbe55b1acc349d7862d54c1788d824880a1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -964,7 +964,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n                             let symbol = csearch::get_symbol(\n                                 bcx.ccx().sess.cstore,\n                                 did);\n-                            let llval = do symbol.as_c_str |buf| {\n+                            let llval = do symbol.to_c_str().with_ref |buf| {\n                                 llvm::LLVMAddGlobal(bcx.ccx().llmod,\n                                                     llty.to_ref(),\n                                                     buf)"}, {"sha": "c0a5795e87de1870970deb9053a0f65edfc9326d", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -37,6 +37,7 @@ use util::ppaux::ty_to_short_str;\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::libc::c_uint;\n use syntax::ast;\n \n@@ -659,7 +660,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n     debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), name);\n-    let gvar = do name.as_c_str |buf| {\n+    let gvar = do name.to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n         }"}, {"sha": "b3939a3105065b03e979aa69ceff657800f0819e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -32,6 +32,7 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::vec;\n use syntax::ast_map::{path, path_mod, path_name};\n use syntax::ast_util;\n@@ -605,7 +606,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n \n         let tbl = C_struct(components);\n         let vtable = ccx.sess.str_of(gensym_name(\"vtable\"));\n-        let vt_gvar = do vtable.as_c_str |buf| {\n+        let vt_gvar = do vtable.to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);"}, {"sha": "110febfcc9f579b7080786fb98335b77c7f6a678", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -20,6 +20,7 @@ use middle::trans::base;\n use syntax::ast;\n use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n \n+use std::c_str::ToCStr;\n use std::vec;\n use std::cast;\n \n@@ -170,7 +171,7 @@ impl Type {\n \n     pub fn named_struct(name: &str) -> Type {\n         let ctx = base::task_llcx();\n-        ty!(name.as_c_str(|s| llvm::LLVMStructCreateNamed(ctx, s)))\n+        ty!(name.to_c_str().with_ref(|s| llvm::LLVMStructCreateNamed(ctx, s)))\n     }\n \n     pub fn empty_struct() -> Type {"}, {"sha": "7ef2b90297d732f116e875309418ef0d9bb779fe", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::{os, result};\n+use std::c_str::ToCStr;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use extra::getopts::groups::getopts;\n@@ -374,8 +375,8 @@ pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n pub fn link_exe(src: &Path, dest: &Path) -> bool {\n     use std::libc;\n     unsafe {\n-        do src.to_str().as_c_str |src_buf| {\n-            do dest.to_str().as_c_str |dest_buf| {\n+        do src.to_c_str().with_ref |src_buf| {\n+            do dest.to_c_str().with_ref |dest_buf| {\n                 libc::link(src_buf, dest_buf) == 0 as libc::c_int &&\n                     libc::chmod(dest_buf, 755) == 0 as libc::c_int\n             }"}, {"sha": "29aa68b1533e4aa5a0ebd776ce906238f009d37c", "filename": "src/libstd/c_str.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -0,0 +1,291 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use iterator::Iterator;\n+use libc;\n+use ops::Drop;\n+use option::{Option, Some, None};\n+use ptr::RawPtr;\n+use ptr;\n+use str::StrSlice;\n+use vec::ImmutableVector;\n+\n+/**\n+ * The representation of a C String.\n+ *\n+ * This structure wraps a `*libc::c_char`, and will automatically free the\n+ * memory it is pointing to when it goes out of scope.\n+ */\n+pub struct CString {\n+    priv buf: *libc::c_char,\n+}\n+\n+impl<'self> CString {\n+    /**\n+     * Create a C String from a str.\n+     */\n+    pub fn from_str(s: &str) -> CString {\n+        s.to_c_str()\n+    }\n+\n+    /**\n+     * Take the wrapped `*libc::c_char` from the `CString` wrapper.\n+     *\n+     * # Failure\n+     *\n+     * If the wrapper is empty.\n+     */\n+    pub unsafe fn take(&mut self) -> *libc::c_char {\n+        if self.buf.is_null() {\n+            fail!(\"CString has no wrapped `*libc::c_char`\");\n+        }\n+        let buf = self.buf;\n+        self.buf = ptr::null();\n+        buf\n+    }\n+\n+    /**\n+     * Puts a `*libc::c_char` into the `CString` wrapper.\n+     *\n+     * # Failure\n+     *\n+     * If the `*libc::c_char` is null.\n+     * If the wrapper is not empty.\n+     */\n+    pub fn put_back(&mut self, buf: *libc::c_char) {\n+        if buf.is_null() {\n+            fail!(\"attempt to put a null pointer into a CString\");\n+        }\n+        if self.buf.is_not_null() {\n+            fail!(\"CString already wraps a `*libc::c_char`\");\n+        }\n+        self.buf = buf;\n+    }\n+\n+    /**\n+     * Calls a closure with a reference to the underlying `*libc::c_char`.\n+     */\n+    pub fn with_ref<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+        if self.buf.is_null() {\n+            fail!(\"CString already wraps a `*libc::c_char`\");\n+        }\n+        f(self.buf)\n+    }\n+\n+    /**\n+     * Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n+     */\n+    pub fn with_mut_ref<T>(&mut self, f: &fn(*mut libc::c_char) -> T) -> T {\n+        if self.buf.is_not_null() {\n+            fail!(\"CString already wraps a `*libc::c_char`\");\n+        }\n+        f(unsafe { cast::transmute(self.buf) })\n+    }\n+\n+    /**\n+     * Returns true if the CString does not wrap a `*libc::c_char`.\n+     */\n+    pub fn is_empty(&self) -> bool {\n+        self.buf.is_null()\n+    }\n+\n+    /**\n+     * Returns true if the CString wraps a `*libc::c_char`.\n+     */\n+    pub fn is_not_empty(&self) -> bool {\n+        self.buf.is_not_null()\n+    }\n+\n+    /**\n+     * Converts the CString into a `&[u8]` without copying.\n+     */\n+    pub fn as_bytes(&self) -> &'self [u8] {\n+        unsafe {\n+            let len = libc::strlen(self.buf) as uint;\n+            cast::transmute((self.buf, len + 1))\n+        }\n+    }\n+\n+    /**\n+     * Return a CString iterator.\n+     */\n+    fn iter(&self) -> CStringIterator<'self> {\n+        CStringIterator {\n+            ptr: self.buf,\n+            lifetime: unsafe { cast::transmute(self.buf) },\n+        }\n+    }\n+}\n+\n+impl Drop for CString {\n+    fn drop(&self) {\n+        if self.buf.is_not_null() {\n+            unsafe {\n+                libc::free(self.buf as *libc::c_void)\n+            };\n+        }\n+    }\n+}\n+\n+/**\n+ * A generic trait for converting a value to a CString.\n+ */\n+pub trait ToCStr {\n+    /**\n+     * Create a C String.\n+     */\n+    fn to_c_str(&self) -> CString;\n+}\n+\n+impl<'self> ToCStr for &'self str {\n+    /**\n+     * Create a C String from a `&str`.\n+     */\n+    fn to_c_str(&self) -> CString {\n+        self.as_bytes().to_c_str()\n+    }\n+}\n+\n+impl<'self> ToCStr for &'self [u8] {\n+    /**\n+     * Create a C String from a `&[u8]`.\n+     */\n+    fn to_c_str(&self) -> CString {\n+        do self.as_imm_buf |self_buf, self_len| {\n+            unsafe {\n+                let buf = libc::malloc(self_len as u64 + 1) as *mut u8;\n+                if buf.is_null() {\n+                    fail!(\"failed to allocate memory!\");\n+                }\n+\n+                ptr::copy_memory(buf, self_buf, self_len);\n+                *ptr::mut_offset(buf, self_len as int) = 0;\n+                CString { buf: buf as *libc::c_char }\n+            }\n+        }\n+    }\n+}\n+\n+/**\n+ * External iterator for a CString's bytes.\n+ *\n+ * Use with the `std::iterator` module.\n+ */\n+pub struct CStringIterator<'self> {\n+    priv ptr: *libc::c_char,\n+    priv lifetime: &'self libc::c_char, // FIXME: #5922\n+}\n+\n+impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n+    /**\n+     * Advance the iterator.\n+     */\n+    fn next(&mut self) -> Option<libc::c_char> {\n+        if self.ptr.is_null() {\n+            None\n+        } else {\n+            let ch = unsafe { *self.ptr };\n+            self.ptr = ptr::offset(self.ptr, 1);\n+            Some(ch)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use libc;\n+    use ptr;\n+\n+    #[test]\n+    fn test_to_c_str() {\n+        do \"\".to_c_str().with_ref |buf| {\n+            unsafe {\n+                assert_eq!(*ptr::offset(buf, 0), 0);\n+            }\n+        }\n+\n+        do \"hello\".to_c_str().with_ref |buf| {\n+            unsafe {\n+                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 5), 0);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_take() {\n+        let mut c_str = \"hello\".to_c_str();\n+        unsafe { libc::free(c_str.take() as *libc::c_void) }\n+        assert!(c_str.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_take_and_put_back() {\n+        let mut c_str = \"hello\".to_c_str();\n+        assert!(c_str.is_not_empty());\n+\n+        let buf = unsafe { c_str.take() };\n+\n+        assert!(c_str.is_empty());\n+\n+        c_str.put_back(buf);\n+\n+        assert!(c_str.is_not_empty());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_take_empty_fail() {\n+        let mut c_str = \"hello\".to_c_str();\n+        unsafe {\n+            libc::free(c_str.take() as *libc::c_void);\n+            c_str.take();\n+        }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_put_back_null_fail() {\n+        let mut c_str = \"hello\".to_c_str();\n+        c_str.put_back(ptr::null());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_put_back_full_fail() {\n+        let mut c_str = \"hello\".to_c_str();\n+        c_str.put_back(0xdeadbeef as *libc::c_char);\n+    }\n+\n+    fn test_with() {\n+        let c_str = \"hello\".to_c_str();\n+        let len = unsafe { c_str.with_ref(|buf| libc::strlen(buf)) };\n+        assert!(c_str.is_not_empty());\n+        assert_eq!(len, 5);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_with_empty_fail() {\n+        let mut c_str = \"hello\".to_c_str();\n+        unsafe { libc::free(c_str.take() as *libc::c_void) }\n+        c_str.with_ref(|_| ());\n+    }\n+}"}, {"sha": "78c6e8d5342ded001a00363f435c306ab3436274", "filename": "src/libstd/io.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -48,6 +48,7 @@ implement `Reader` and `Writer`, where appropriate.\n \n use cast;\n use clone::Clone;\n+use c_str::ToCStr;\n use container::Container;\n use int;\n use iterator::Iterator;\n@@ -1040,8 +1041,8 @@ pub fn stdin() -> @Reader {\n }\n \n pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n-    let f = do path.to_str().as_c_str |pathbuf| {\n-        do \"r\".as_c_str |modebuf| {\n+    let f = do path.to_c_str().with_ref |pathbuf| {\n+        do \"r\".to_c_str().with_ref |modebuf| {\n             unsafe { libc::fopen(pathbuf, modebuf as *libc::c_char) }\n         }\n     };\n@@ -1290,9 +1291,8 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n         }\n     }\n     let fd = unsafe {\n-        do path.to_str().as_c_str |pathbuf| {\n-            libc::open(pathbuf, fflags,\n-                       (S_IRUSR | S_IWUSR) as c_int)\n+        do path.to_c_str().with_ref |pathbuf| {\n+            libc::open(pathbuf, fflags, (S_IRUSR | S_IWUSR) as c_int)\n         }\n     };\n     if fd < (0 as c_int) {\n@@ -1574,8 +1574,8 @@ pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n // FIXME: fileflags // #2004\n pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n     unsafe {\n-        let f = do path.to_str().as_c_str |pathbuf| {\n-            do \"w\".as_c_str |modebuf| {\n+        let f = do path.to_c_str().with_ref |pathbuf| {\n+            do \"w\".to_c_str().with_ref |modebuf| {\n                 libc::fopen(pathbuf, modebuf)\n             }\n         };"}, {"sha": "fb4f14d33c60bc8d145d5307058bcac3c4f9514d", "filename": "src/libstd/os.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -28,6 +28,7 @@\n \n #[allow(missing_doc)];\n \n+use c_str::ToCStr;\n use cast;\n use clone::Clone;\n use container::Container;\n@@ -241,7 +242,9 @@ pub fn env() -> ~[(~str,~str)] {\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n         do with_env_lock {\n-            let s = n.as_c_str(|s| libc::getenv(s as *libc::c_char));\n+            let s = do n.to_c_str().with_ref |buf| {\n+                libc::getenv(buf)\n+            };\n             if ptr::null::<u8>() == cast::transmute(s) {\n                 None\n             } else {\n@@ -274,8 +277,8 @@ pub fn getenv(n: &str) -> Option<~str> {\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n         do with_env_lock {\n-            do n.to_str().as_c_str |nbuf| {\n-                do v.to_str().as_c_str |vbuf| {\n+            do n.to_c_str().with_ref |nbuf| {\n+                do v.to_c_str().with_ref |vbuf| {\n                     libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n                 }\n             }\n@@ -306,7 +309,7 @@ pub fn unsetenv(n: &str) {\n     fn _unsetenv(n: &str) {\n         unsafe {\n             do with_env_lock {\n-                do n.to_str().as_c_str |nbuf| {\n+                do n.to_c_str().with_ref |nbuf| {\n                     libc::funcs::posix01::unistd::unsetenv(nbuf);\n                 }\n             }\n@@ -328,7 +331,7 @@ pub fn unsetenv(n: &str) {\n }\n \n pub fn fdopen(fd: c_int) -> *FILE {\n-    do \"r\".as_c_str |modebuf| {\n+    do \"r\".to_c_str().with_ref |modebuf| {\n         unsafe {\n             libc::fdopen(fd, modebuf)\n         }\n@@ -462,9 +465,9 @@ pub fn self_exe_path() -> Option<Path> {\n             use libc::funcs::posix01::unistd::readlink;\n \n             let mut path_str = str::with_capacity(TMPBUF_SZ);\n-            let len = do path_str.as_c_str |buf| {\n+            let len = do path_str.to_c_str().with_ref |buf| {\n                 let buf = buf as *mut c_char;\n-                do \"/proc/self/exe\".as_c_str |proc_self_buf| {\n+                do \"/proc/self/exe\".to_c_str().with_ref |proc_self_buf| {\n                     readlink(proc_self_buf, buf, TMPBUF_SZ as size_t)\n                 }\n             };\n@@ -595,7 +598,7 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n /// Indicates whether a path represents a directory\n pub fn path_is_dir(p: &Path) -> bool {\n     unsafe {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             rustrt::rust_path_is_dir(buf) != 0 as c_int\n         }\n     }\n@@ -604,7 +607,7 @@ pub fn path_is_dir(p: &Path) -> bool {\n /// Indicates whether a path exists\n pub fn path_exists(p: &Path) -> bool {\n     unsafe {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             rustrt::rust_path_exists(buf) != 0 as c_int\n         }\n     }\n@@ -647,7 +650,7 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n \n     #[cfg(unix)]\n     fn mkdir(p: &Path, mode: c_int) -> bool {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             unsafe {\n                 libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n             }\n@@ -823,7 +826,7 @@ pub fn remove_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn rmdir(p: &Path) -> bool {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             unsafe {\n                 libc::rmdir(buf) == (0 as c_int)\n             }\n@@ -848,7 +851,7 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             unsafe {\n                 libc::chdir(buf) == (0 as c_int)\n             }\n@@ -876,8 +879,8 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n     #[cfg(unix)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n         unsafe {\n-            let istream = do from.to_str().as_c_str |fromp| {\n-                do \"rb\".as_c_str |modebuf| {\n+            let istream = do from.to_c_str().with_ref |fromp| {\n+                do \"rb\".to_c_str().with_ref |modebuf| {\n                     libc::fopen(fromp, modebuf)\n                 }\n             };\n@@ -888,8 +891,8 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             let from_mode = from.get_mode().expect(\"copy_file: couldn't get permissions \\\n                                                     for source file\");\n \n-            let ostream = do to.to_str().as_c_str |top| {\n-                do \"w+b\".as_c_str |modebuf| {\n+            let ostream = do to.to_c_str().with_ref |top| {\n+                do \"w+b\".to_c_str().with_ref |modebuf| {\n                     libc::fopen(top, modebuf)\n                 }\n             };\n@@ -921,7 +924,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             fclose(ostream);\n \n             // Give the new file the old file's permissions\n-            if do to.to_str().as_c_str |to_buf| {\n+            if do to.to_c_str().with_ref |to_buf| {\n                 libc::chmod(to_buf, from_mode as libc::mode_t)\n             } != 0 {\n                 return false; // should be a condition...\n@@ -948,7 +951,7 @@ pub fn remove_file(p: &Path) -> bool {\n     #[cfg(unix)]\n     fn unlink(p: &Path) -> bool {\n         unsafe {\n-            do p.to_str().as_c_str |buf| {\n+            do p.to_c_str().with_ref |buf| {\n                 libc::unlink(buf) == (0 as c_int)\n             }\n         }\n@@ -1294,7 +1297,7 @@ pub fn glob(pattern: &str) -> ~[Path] {\n     }\n \n     let mut g = default_glob_t();\n-    do pattern.as_c_str |c_pattern| {\n+    do pattern.to_c_str().with_ref |c_pattern| {\n         unsafe { libc::glob(c_pattern, 0, ptr::null(), &mut g) }\n     };\n     do(|| {\n@@ -1699,6 +1702,7 @@ pub mod consts {\n \n #[cfg(test)]\n mod tests {\n+    use c_str::ToCStr;\n     use libc::{c_int, c_void, size_t};\n     use libc;\n     use option::Some;\n@@ -1711,7 +1715,6 @@ mod tests {\n     use rand;\n     use run;\n     use str::StrSlice;\n-    use vec::CopyableVector;\n     use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n \n@@ -1941,19 +1944,19 @@ mod tests {\n             let out = tempdir.push(\"out.txt\");\n \n             /* Write the temp input file */\n-            let ostream = do input.to_str().as_c_str |fromp| {\n-                do \"w+b\".as_c_str |modebuf| {\n+            let ostream = do input.to_c_str().with_ref |fromp| {\n+                do \"w+b\".to_c_str().with_ref |modebuf| {\n                     libc::fopen(fromp, modebuf)\n                 }\n             };\n             assert!((ostream as uint != 0u));\n             let s = ~\"hello\";\n-            let mut buf = s.to_owned().to_c_str();\n-            let len = buf.len();\n-            do buf.as_mut_buf |b, _len| {\n-                assert_eq!(libc::fwrite(b as *c_void, 1u as size_t,\n-                                        (s.len() + 1u) as size_t, ostream),\n-                           len as size_t)\n+            do \"hello\".to_c_str().with_ref |buf| {\n+                let write_len = libc::fwrite(buf as *c_void,\n+                                             1u as size_t,\n+                                             (s.len() + 1u) as size_t,\n+                                             ostream);\n+                assert_eq!(write_len, (s.len() + 1) as size_t)\n             }\n             assert_eq!(libc::fclose(ostream), (0u as c_int));\n             let in_mode = input.get_mode();\n@@ -2025,11 +2028,11 @@ mod tests {\n         remove_file(&path);\n \n         let fd = unsafe {\n-            let fd = do path.to_str().as_c_str |path| {\n+            let fd = do path.to_c_str().with_ref |path| {\n                 open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n             };\n             lseek_(fd, size);\n-            do \"x\".as_c_str |x| {\n+            do \"x\".to_c_str().with_ref |x| {\n                 assert!(write(fd, x as *c_void, 1) == 1);\n             }\n             fd"}, {"sha": "fe8776c21d5a38caab50bada20f5696313198467", "filename": "src/libstd/path.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -16,9 +16,11 @@ Cross-platform file path handling\n \n #[allow(missing_doc)];\n \n+use c_str::ToCStr;\n+use c_str;\n use clone::Clone;\n-use container::Container;\n use cmp::Eq;\n+use container::Container;\n use iterator::{Iterator, IteratorUtil};\n use libc;\n use option::{None, Option, Some};\n@@ -341,7 +343,7 @@ mod stat {\n #[cfg(target_os = \"win32\")]\n impl WindowsPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n-        do self.to_str().as_c_str |buf| {\n+        do self.to_c_str().with_ref |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::stat(buf, &mut st) } {\n                 0 => Some(st),\n@@ -375,7 +377,7 @@ impl WindowsPath {\n #[cfg(not(target_os = \"win32\"))]\n impl PosixPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n-        do self.to_str().as_c_str |buf| {\n+        do self.to_c_str().with_ref |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::stat(buf as *libc::c_char, &mut st) } {\n                 0 => Some(st),\n@@ -453,7 +455,7 @@ impl PosixPath {\n #[cfg(unix)]\n impl PosixPath {\n     pub fn lstat(&self) -> Option<libc::stat> {\n-        do self.to_str().as_c_str |buf| {\n+        do self.to_c_str().with_ref |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::lstat(buf, &mut st) } {\n                 0 => Some(st),\n@@ -525,6 +527,12 @@ impl ToStr for PosixPath {\n     }\n }\n \n+impl ToCStr for PosixPath {\n+    fn to_c_str(&self) -> c_str::CString {\n+        self.to_str().to_c_str()\n+    }\n+}\n+\n // FIXME (#3227): when default methods in traits are working, de-duplicate\n // PosixPath and WindowsPath, most of their methods are common.\n impl GenericPath for PosixPath {\n@@ -730,6 +738,11 @@ impl ToStr for WindowsPath {\n     }\n }\n \n+impl c_str::ToCStr for WindowsPath {\n+    fn to_c_str(&self) -> c_str::CString {\n+        self.to_str().to_c_str()\n+    }\n+}\n \n impl GenericPath for WindowsPath {\n     fn from_str(s: &str) -> WindowsPath {"}, {"sha": "5b8833f3f361bdbff53f3a03a1fddad5a5b89044", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -43,6 +43,7 @@ pub use io::{print, println};\n pub use iterator::range;\n \n // Reexported types and traits\n+pub use c_str::ToCStr;\n pub use clone::{Clone, DeepClone};\n pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n pub use char::Char;"}, {"sha": "77222490f171d028abd3d5f0fadf70c2f9e28cb9", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -486,24 +486,25 @@ pub mod ptr_tests {\n \n     #[test]\n     fn test_position() {\n+        use c_str::ToCStr;\n         use libc::c_char;\n \n-        let s = ~\"hello\";\n-        unsafe {\n-            assert!(2u == s.as_c_str(|p| position(p, |c| *c == 'l' as c_char)));\n-            assert!(4u == s.as_c_str(|p| position(p, |c| *c == 'o' as c_char)));\n-            assert!(5u == s.as_c_str(|p| position(p, |c| *c == 0 as c_char)));\n+        do \"hello\".to_c_str().with_ref |p| {\n+            unsafe {\n+                assert!(2u == position(p, |c| *c == 'l' as c_char));\n+                assert!(4u == position(p, |c| *c == 'o' as c_char));\n+                assert!(5u == position(p, |c| *c == 0 as c_char));\n+            }\n         }\n     }\n \n     #[test]\n     fn test_buf_len() {\n-        let s0 = ~\"hello\";\n-        let s1 = ~\"there\";\n-        let s2 = ~\"thing\";\n-        do s0.as_c_str |p0| {\n-            do s1.as_c_str |p1| {\n-                do s2.as_c_str |p2| {\n+        use c_str::ToCStr;\n+\n+        do \"hello\".to_c_str().with_ref |p0| {\n+            do \"there\".to_c_str().with_ref |p1| {\n+                do \"thing\".to_c_str().with_ref |p2| {\n                     let v = ~[p0, p1, p2, null()];\n                     do v.as_imm_buf |vp, len| {\n                         assert_eq!(unsafe { buf_len(vp) }, 3u);"}, {"sha": "3a51fd032c0e8d6669af793e026da312758a83ce", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use c_str::ToCStr;\n use cast::transmute;\n use libc::{c_char, c_void, size_t, STDERR_FILENO};\n use io;\n@@ -76,7 +77,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n             let msg = \"borrowed\";\n-            do msg.as_c_str |msg_p| {\n+            do msg.to_c_str().with_ref |msg_p| {\n                 sys::begin_unwind_(msg_p, file, line);\n             }\n         }\n@@ -92,7 +93,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n                     sep = \" and at \";\n                 }\n             }\n-            do msg.as_c_str |msg_p| {\n+            do msg.to_c_str().with_ref |msg_p| {\n                 sys::begin_unwind_(msg_p, file, line)\n             }\n         }\n@@ -231,7 +232,7 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n             let br = borrow_list.pop();\n             if br.box != a || br.file != file || br.line != line {\n                 let err = fmt!(\"wrong borrow found, br=%?\", br);\n-                do err.as_c_str |msg_p| {\n+                do err.to_c_str().with_ref |msg_p| {\n                     sys::begin_unwind_(msg_p, file, line)\n                 }\n             }"}, {"sha": "76619704bee43d3350d506675e86f27712550316", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -45,15 +45,15 @@ impl Logger for StdErrLogger {\n /// Configure logging by traversing the crate map and setting the\n /// per-module global logging flags based on the logging spec\n pub fn init(crate_map: *u8) {\n+    use c_str::ToCStr;\n     use os;\n-    use str::StrSlice;\n     use ptr;\n     use option::{Some, None};\n \n     let log_spec = os::getenv(\"RUST_LOG\");\n     match log_spec {\n         Some(spec) => {\n-            do spec.as_c_str |buf| {\n+            do spec.to_c_str().with_ref |buf| {\n                 unsafe { rust_update_log_settings(crate_map, buf) }\n             }\n         }"}, {"sha": "071a90f4a8346531aace430293fb8969cf9bf15a", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -8,26 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::*;\n-use result::*;\n-use ops::Drop;\n-use cell::Cell;\n-use cast;\n+use c_str::ToCStr;\n use cast::transmute;\n+use cast;\n+use cell::Cell;\n use clone::Clone;\n use libc::{c_int, c_uint, c_void};\n+use ops::Drop;\n+use option::*;\n use ptr;\n+use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n-use rt::uv::*;\n-use rt::uv::idle::IdleWatcher;\n-use rt::uv::net::{UvIpv4, UvIpv6};\n+use rt::io::{standard_error, OtherIoError};\n+use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::Scheduler;\n-use rt::io::{standard_error, OtherIoError};\n use rt::tube::Tube;\n-use rt::local::Local;\n-use str::StrSlice;\n+use rt::uv::*;\n+use rt::uv::idle::IdleWatcher;\n+use rt::uv::net::{UvIpv4, UvIpv6};\n use unstable::sync::Exclusive;\n \n #[cfg(test)] use container::Container;\n@@ -663,7 +663,7 @@ impl RtioUdpSocket for UvUdpSocket {\n         };\n \n         let r = unsafe {\n-            do ip_str.as_c_str |m_addr| {\n+            do ip_str.to_c_str().with_ref |m_addr| {\n                 uvll::udp_set_membership(self.native_handle(), m_addr,\n                                          ptr::null(), uvll::UV_JOIN_GROUP)\n             }\n@@ -686,7 +686,7 @@ impl RtioUdpSocket for UvUdpSocket {\n         };\n \n         let r = unsafe {\n-            do ip_str.as_c_str |m_addr| {\n+            do ip_str.to_c_str().with_ref |m_addr| {\n                 uvll::udp_set_membership(self.native_handle(), m_addr,\n                                          ptr::null(), uvll::UV_LEAVE_GROUP)\n             }"}, {"sha": "bd2d28f8642c44736552dfc9d400b066436df33e", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -29,6 +29,7 @@\n \n #[allow(non_camel_case_types)]; // C types\n \n+use c_str::ToCStr;\n use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n use libc::{malloc, free};\n use libc;\n@@ -372,12 +373,12 @@ pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n }\n \n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n-    do ip.as_c_str |ip_buf| {\n+    do ip.to_c_str().with_ref |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }\n pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n-    do ip.as_c_str |ip_buf| {\n+    do ip.to_c_str().with_ref |ip_buf| {\n         rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }"}, {"sha": "6e447d3ded473d839636694665ed91989d0f9fd8", "filename": "src/libstd/run.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -12,6 +12,7 @@\n \n #[allow(missing_doc)];\n \n+use c_str::ToCStr;\n use cast;\n use clone::Clone;\n use comm::{stream, SharedChan, GenericChan, GenericPort};\n@@ -506,7 +507,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         do with_envp(env) |envp| {\n             do with_dirp(dir) |dirp| {\n-                do cmd.as_c_str |cmdp| {\n+                do cmd.to_c_str().with_ref |cmdp| {\n                     let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n                                                  0, envp, dirp, &mut si, &mut pi);\n@@ -697,17 +698,17 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n     // hold all the ~[u8] byte strings.\n     let mut tmps = vec::with_capacity(args.len() + 1);\n \n-    tmps.push(prog.to_owned().to_c_str());\n+    tmps.push(prog.to_c_str());\n \n     foreach arg in args.iter() {\n-        tmps.push(arg.to_owned().to_c_str());\n+        tmps.push(arg.to_c_str());\n     }\n \n     // Next, convert each of the byte strings into a pointer. This is\n     // technically unsafe as the caller could leak these pointers out of our\n     // scope.\n     let mut ptrs = do tmps.map |tmp| {\n-        tmp.as_imm_buf(|buf, _| buf as *libc::c_char)\n+        tmp.with_ref(|buf| buf)\n     };\n \n     // Finally, make sure we add a null pointer.\n@@ -734,7 +735,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n \n             // Once again, this is unsafe.\n             let mut ptrs = do tmps.map |tmp| {\n-                tmp.as_imm_buf(|buf, _| buf as *libc::c_char)\n+                tmp.with_ref(|buf| buf)\n             };\n             ptrs.push(ptr::null());\n \n@@ -757,7 +758,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n \n             foreach pair in env.iter() {\n                 let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n-                blk.push_all(kv.to_c_str());\n+                blk.push_all(kv.to_c_str().as_bytes());\n             }\n \n             blk.push(0);\n@@ -772,7 +773,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n \n fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n     match d {\n-      Some(dir) => dir.to_str().as_c_str(cb),\n+      Some(dir) => dir.to_c_str().with_ref(|buf| cb(buf)),\n       None => cb(ptr::null())\n     }\n }"}, {"sha": "d51f0de1d275b2bd84eaa273a7a6a123e9ec25b8", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -172,6 +172,7 @@ pub mod local_data;\n \n pub mod gc;\n pub mod libc;\n+pub mod c_str;\n pub mod os;\n pub mod path;\n pub mod rand;"}, {"sha": "851a9326392d13f9c43d79426772210dc36b1a5c", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -1182,7 +1182,6 @@ pub trait StrSlice<'self> {\n     fn subslice_offset(&self, inner: &str) -> uint;\n \n     fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n-    fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T;\n }\n \n /// Extension methods for strings\n@@ -1931,32 +1930,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         let v: &[u8] = unsafe { cast::transmute(*self) };\n         v.as_imm_buf(f)\n     }\n-\n-    /// Work with the byte buffer of a string as a null-terminated C string.\n-    ///\n-    /// Allows for unsafe manipulation of strings, which is useful for foreign\n-    /// interop. This is similar to `str::as_buf`, but guarantees null-termination.\n-    /// If the given slice is not already null-terminated, this function will\n-    /// allocate a temporary, copy the slice, null terminate it, and pass\n-    /// that instead.\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~ {.rust}\n-    /// let s = \"PATH\".as_c_str(|path| libc::getenv(path));\n-    /// ~~~\n-    #[inline]\n-    fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n-        do self.as_imm_buf |buf, len| {\n-            // NB: len includes the trailing null.\n-            assert!(len > 0);\n-            if unsafe { *(ptr::offset(buf, (len - 1) as int)) != 0 } {\n-                self.to_owned().as_c_str(|s| f(s))\n-            } else {\n-                f(buf as *libc::c_char)\n-            }\n-        }\n-    }\n }\n \n #[allow(missing_doc)]\n@@ -1973,13 +1946,6 @@ pub trait OwnedStr {\n     fn capacity(&self) -> uint;\n     fn to_bytes_with_null(self) -> ~[u8];\n \n-    /// Allocates a null terminate byte array.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if there are any null characters inside the byte array.\n-    fn to_c_str(self) -> ~[u8];\n-\n     /// Work with the mutable byte buffer and length of a slice.\n     ///\n     /// The given length is one byte longer than the 'official' indexable\n@@ -2171,13 +2137,6 @@ impl OwnedStr for ~str {\n         unsafe { cast::transmute(self) }\n     }\n \n-    #[inline]\n-    fn to_c_str(self) -> ~[u8] {\n-        let bytes = self.to_bytes_with_null();\n-        assert!(bytes.slice(0, bytes.len() - 1).iter().all(|byte| *byte != 0));\n-        bytes\n-    }\n-\n     #[inline]\n     fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T {\n         let v: &mut ~[u8] = unsafe { cast::transmute(self) };\n@@ -2915,63 +2874,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_as_c_str() {\n-        let a = ~\"\";\n-        do a.as_c_str |buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n-            }\n-        }\n-\n-        let a = ~\"hello\";\n-        do a.as_c_str |buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_c_str() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = ~[\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109, 0\n-        ];\n-        assert_eq!((~\"\").to_c_str(), ~[0]);\n-        assert_eq!((~\"abc\").to_c_str(), ~['a' as u8, 'b' as u8, 'c' as u8, 0]);\n-        assert_eq!(s.to_c_str(), v);\n-    }\n-\n-    #[test]\n-    fn test_as_c_str() {\n-        let a = ~\"\";\n-        do a.as_c_str |buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n-            }\n-        }\n-\n-        let a = ~\"hello\";\n-        do a.as_c_str |buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n-            }\n-        }\n-    }\n-\n     #[test]\n     fn test_subslice_offset() {\n         let a = \"kernelsprite\";"}, {"sha": "b40f87617a91411fa263d77bca0996e9cb0dc0b0", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -12,13 +12,13 @@\n \n #[allow(missing_doc)];\n \n+use c_str::ToCStr;\n use cast;\n use gc;\n use io;\n use libc;\n use libc::{c_char, size_t};\n use repr;\n-use str::StrSlice;\n use str;\n use unstable::intrinsics;\n \n@@ -115,8 +115,8 @@ pub trait FailWithCause {\n \n impl FailWithCause for ~str {\n     fn fail_with(cause: ~str, file: &'static str, line: uint) -> ! {\n-        do cause.as_c_str |msg_buf| {\n-            do file.as_c_str |file_buf| {\n+        do cause.to_c_str().with_ref |msg_buf| {\n+            do file.to_c_str().with_ref |file_buf| {\n                 begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n             }\n         }\n@@ -125,8 +125,8 @@ impl FailWithCause for ~str {\n \n impl FailWithCause for &'static str {\n     fn fail_with(cause: &'static str, file: &'static str, line: uint) -> ! {\n-        do cause.as_c_str |msg_buf| {\n-            do file.as_c_str |file_buf| {\n+        do cause.to_c_str().with_ref |msg_buf| {\n+            do file.to_c_str().with_ref |file_buf| {\n                 begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n             }\n         }"}, {"sha": "49e3e0777df84e58356fe734fe07d3e37c36f34f", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -15,6 +15,7 @@ Dynamic library facilities.\n A simple wrapper over the platforms dynamic library facilities\n \n */\n+use c_str::ToCStr;\n use cast;\n use path;\n use libc;\n@@ -65,7 +66,7 @@ impl DynamicLibrary {\n         // T but that feature is still unimplemented\n \n         let maybe_symbol_value = do dl::check_for_errors_in {\n-            do symbol.as_c_str |raw_string| {\n+            do symbol.to_c_str().with_ref |raw_string| {\n                 dl::symbol(self.handle, raw_string)\n             }\n         };\n@@ -135,6 +136,7 @@ mod test {\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n mod dl {\n+    use c_str::ToCStr;\n     use libc;\n     use path;\n     use ptr;\n@@ -143,7 +145,7 @@ mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n-        do filename.to_str().as_c_str |raw_name| {\n+        do filename.to_c_str().with_ref |raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int)\n         }\n     }"}, {"sha": "1ea815f721cc1cb0d170c0c3cacbf11f9ef6ac38", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -10,6 +10,7 @@\n \n //! Runtime calls emitted by the compiler.\n \n+use c_str::ToCStr;\n use cast::transmute;\n use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int};\n use str;\n@@ -49,7 +50,7 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n                          index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n-    do msg.as_c_str |buf| {\n+    do msg.to_c_str().with_ref |buf| {\n         fail_(buf, file, line);\n     }\n }"}, {"sha": "b5a114ef22364e64dc2bea3f7ccf326b914afa50", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b1797e24b9dd8eef2f68a74ec83749d7b53d/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=3102b1797e24b9dd8eef2f68a74ec83749d7b53d", "patch": "@@ -26,8 +26,9 @@ mod libc {\n fn strlen(str: ~str) -> uint {\n     unsafe {\n         // C string is terminated with a zero\n-        let bytes = str.to_bytes_with_null();\n-        return libc::my_strlen(vec::raw::to_ptr(bytes));\n+        do str.to_c_str().with_ref |buf| {\n+            libc::my_strlen(buf as *u8)\n+        }\n     }\n }\n "}]}