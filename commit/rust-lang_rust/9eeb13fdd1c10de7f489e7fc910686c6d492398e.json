{"sha": "9eeb13fdd1c10de7f489e7fc910686c6d492398e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZWIxM2ZkZDFjMTBkZTdmNDg5ZTdmYzkxMDY4NmM2ZDQ5MjM5OGU=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2018-05-06T11:46:20Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2018-05-06T11:46:20Z"}, "message": "Improve `Debug` impl of `core::time::Duration`\n\nPrior to this, Duration simply derived Debug. Since Duration doesn't\nimplement `Display`, the only way to inspect its value is to use\n`Debug`. Unfortunately, the derived `Debug` impl is far from optimal\nfor humans. In many cases, Durations are used for some quick'n'dirty\nbenchmarking (or in general: measuring the time of some code). Correctly\nunderstanding the output of Duration's Debug impl is not easy (e.g.\nis \"{ secs: 0, nanos: 968360102 }\" or \"{ secs: 0, nanos 98507324 }\"\nshorter?).\n\nThis commit replaces the derived impl with a manual one. It prints\nthe duration as seconds (i.e. \"3.1803s\") if the duration is longer than\na second, otherwise it prints it in either ms, \u00b5s or ns (depending on\nthe duration's length). This already helps readability a lot and it\nnever omits information that is stored.\n\nThis `Debug` impl does *not* respect the following formatting parameters:\n\n- fill/align/padding: difficult to implement, probably not worth it\n- alternate # flag: not clear what this should do", "tree": {"sha": "72a400ad9e6051dd3e5305d954dc76b6b1204202", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72a400ad9e6051dd3e5305d954dc76b6b1204202"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eeb13fdd1c10de7f489e7fc910686c6d492398e", "comment_count": 1, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEENwctvZ5TgcKYXim8PLr0FT+BhicFAlru6zYACgkQPLr0FT+B\nhify9xAAg7wX++niiS5x1N+H0FyDgs1Zz9snQ7Xal+TvHVDLgIzyZtd8CPkQ1Mov\nXKD5HiTJzvEWD+8bR7DzrqxoNCs5rmAr0a5x294qkgBKAwE1WSRI/sA/F4wgPsHI\nAXtoKmbmytdSkr4FWzHeTepIdsb6R2tIAuQ+SHVMoXhPv+i3c6A1Wo/no9ZBXZlJ\ncJ5IALnbm2ctaMstsqjMBpNVtRO3ksYviLgxJdsief83c+k3qVl9z/+AhFgPSs9u\neq+gn2q1vMM2lmxc0P/Z3KEefNWi6gcranc+xtOryBQkiA/kP5Xn8vOudbkSed2m\njZwhB6EiIbJ/W8E0Exr70J1H9afSYWo2Kn6oJFihSd4eliahxquaYKVTnz0vADZ5\nhnSasx18IQeO3kmckwVlvut/qKmWqFPYDWcW3Rvublh4b48e/w/o4GO3D2aDkSvu\nxUQpGamG2nCau7D7qRDBon8YWYwO8Yjkid51AmOi0iUcrAV2XKd5QVIoQ9lEKZOv\nv+BdE06SUEDWr0RW5nUoIVtI/8PRzAB42jQtKSxXxjibJuPY/Fai6768g+BaNEpc\nddXrmlZ9qHD7TayHZU5WyXn1TvIqKKzhAAcJNnrqEl6S113j1+Ezr47rZkRRmq+u\nzu+o1P+72TzgI1InJwMar7xv5dG6mb+HfUcQOoGqODthWh4aXio=\n=Lm5b\n-----END PGP SIGNATURE-----", "payload": "tree 72a400ad9e6051dd3e5305d954dc76b6b1204202\nparent 6f721f54c6fb1de9cf00eb9d2d050f818c882871\nauthor Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1525607180 +0200\ncommitter Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1525607180 +0200\n\nImprove `Debug` impl of `core::time::Duration`\n\nPrior to this, Duration simply derived Debug. Since Duration doesn't\nimplement `Display`, the only way to inspect its value is to use\n`Debug`. Unfortunately, the derived `Debug` impl is far from optimal\nfor humans. In many cases, Durations are used for some quick'n'dirty\nbenchmarking (or in general: measuring the time of some code). Correctly\nunderstanding the output of Duration's Debug impl is not easy (e.g.\nis \"{ secs: 0, nanos: 968360102 }\" or \"{ secs: 0, nanos 98507324 }\"\nshorter?).\n\nThis commit replaces the derived impl with a manual one. It prints\nthe duration as seconds (i.e. \"3.1803s\") if the duration is longer than\na second, otherwise it prints it in either ms, \u00b5s or ns (depending on\nthe duration's length). This already helps readability a lot and it\nnever omits information that is stored.\n\nThis `Debug` impl does *not* respect the following formatting parameters:\n\n- fill/align/padding: difficult to implement, probably not worth it\n- alternate # flag: not clear what this should do\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eeb13fdd1c10de7f489e7fc910686c6d492398e", "html_url": "https://github.com/rust-lang/rust/commit/9eeb13fdd1c10de7f489e7fc910686c6d492398e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eeb13fdd1c10de7f489e7fc910686c6d492398e/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f721f54c6fb1de9cf00eb9d2d050f818c882871", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f721f54c6fb1de9cf00eb9d2d050f818c882871", "html_url": "https://github.com/rust-lang/rust/commit/6f721f54c6fb1de9cf00eb9d2d050f818c882871"}], "stats": {"total": 190, "additions": 189, "deletions": 1}, "files": [{"sha": "bfb5369cf8f8c1d9f67f3340e2a6161df30715de", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9eeb13fdd1c10de7f489e7fc910686c6d492398e/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eeb13fdd1c10de7f489e7fc910686c6d492398e/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=9eeb13fdd1c10de7f489e7fc910686c6d492398e", "patch": "@@ -122,3 +122,115 @@ fn checked_div() {\n     assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n     assert_eq!(Duration::new(2, 0).checked_div(0), None);\n }\n+\n+#[test]\n+fn debug_formatting_extreme_values() {\n+    assert_eq!(\n+        format!(\"{:?}\", Duration::new(18_446_744_073_709_551_615, 123_456_789)),\n+        \"18446744073709551615.123456789s\"\n+    );\n+}\n+\n+#[test]\n+fn debug_formatting_secs() {\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_000_000)), \"7s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 100_000_000)), \"7.1s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_010_000)), \"7.00001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_000_001)), \"7.000000001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(7, 123_456_789)), \"7.123456789s\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_000_000)), \"88s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 100_000_000)), \"88.1s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_010_000)), \"88.00001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_000_001)), \"88.000000001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(88, 123_456_789)), \"88.123456789s\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_000_000)), \"999s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 100_000_000)), \"999.1s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_010_000)), \"999.00001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_000_001)), \"999.000000001s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(999, 123_456_789)), \"999.123456789s\");\n+}\n+\n+#[test]\n+fn debug_formatting_millis() {\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000_000)), \"7ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_100_000)), \"7.1ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000_001)), \"7.000001ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_123_456)), \"7.123456ms\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000_000)), \"88ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_100_000)), \"88.1ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000_001)), \"88.000001ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_123_456)), \"88.123456ms\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000_000)), \"999ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_100_000)), \"999.1ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000_001)), \"999.000001ms\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_123_456)), \"999.123456ms\");\n+}\n+\n+#[test]\n+fn debug_formatting_micros() {\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000)), \"7\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_100)), \"7.1\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_001)), \"7.001\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_123)), \"7.123\u00b5s\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000)), \"88\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_100)), \"88.1\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_001)), \"88.001\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_123)), \"88.123\u00b5s\");\n+\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000)), \"999\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_100)), \"999.1\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_001)), \"999.001\u00b5s\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_123)), \"999.123\u00b5s\");\n+}\n+\n+#[test]\n+fn debug_formatting_nanos() {\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 0)), \"0ns\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 1)), \"1ns\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 88)), \"88ns\");\n+    assert_eq!(format!(\"{:?}\", Duration::new(0, 999)), \"999ns\");\n+}\n+\n+#[test]\n+fn debug_formatting_precision_zero() {\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 0)), \"0ns\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 123)), \"123ns\");\n+\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_001)), \"1\u00b5s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_999)), \"1\u00b5s\");\n+\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_000_001)), \"1ms\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_999_999)), \"1ms\");\n+\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 000_000_001)), \"1s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 999_999_999)), \"1s\");\n+}\n+\n+#[test]\n+fn debug_formatting_precision_two() {\n+    // This might seem inconsistent with the other units, but printing\n+    // fractional digits for nano seconds would imply more precision than is\n+    // actually stored.\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 0)), \"0ns\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 123)), \"123ns\");\n+\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_000)), \"1.00\u00b5s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_001)), \"7.00\u00b5s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_100)), \"7.10\u00b5s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_999)), \"1.99\u00b5s\");\n+\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_000_000)), \"1.00ms\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 3_001_000)), \"3.00ms\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 3_100_000)), \"3.10ms\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_999_999)), \"1.99ms\");\n+\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(1, 000_000_000)), \"1.00s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(4, 001_000_000)), \"4.00s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(2, 100_000_000)), \"2.10s\");\n+    assert_eq!(format!(\"{:.2?}\", Duration::new(8, 999_999_999)), \"8.99s\");\n+}"}, {"sha": "a0a48e8493ce3dff393e8878d666a6e8e7d44f63", "filename": "src/libcore/time.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9eeb13fdd1c10de7f489e7fc910686c6d492398e/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eeb13fdd1c10de7f489e7fc910686c6d492398e/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=9eeb13fdd1c10de7f489e7fc910686c6d492398e", "patch": "@@ -21,6 +21,7 @@\n //! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n //! ```\n \n+use fmt;\n use iter::Sum;\n use ops::{Add, Sub, Mul, Div, AddAssign, SubAssign, MulAssign, DivAssign};\n \n@@ -59,7 +60,7 @@ const MICROS_PER_SEC: u64 = 1_000_000;\n /// let ten_millis = Duration::from_millis(10);\n /// ```\n #[stable(feature = \"duration\", since = \"1.3.0\")]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash, Default)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\n pub struct Duration {\n     secs: u64,\n     nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC\n@@ -481,3 +482,78 @@ impl<'a> Sum<&'a Duration> for Duration {\n         iter.fold(Duration::new(0, 0), |a, b| a + *b)\n     }\n }\n+\n+#[stable(feature = \"duration_debug_impl\", since = \"1.27.0\")]\n+impl fmt::Debug for Duration {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        /// Formats a floating point number in decimal notation.\n+        ///\n+        /// The number is given as the `integer_part` and a fractional part.\n+        /// The value of the fractional part is `fractional_part / divisor`. So\n+        /// `integer_part` = 3, `fractional_part` = 12 and `divisor` = 100\n+        /// represents the number `3.012`. Trailing zeros are omitted.\n+        ///\n+        /// `divisor` must not be above 100_000_000. It also should be a power\n+        /// of 10, everything else doesn't make sense. `fractional_part` has\n+        /// to be less than `10 * divisor`!\n+        fn fmt_decimal(\n+            f: &mut fmt::Formatter,\n+            integer_part: u64,\n+            mut fractional_part: u32,\n+            mut divisor: u32,\n+        ) -> fmt::Result {\n+            // Encode the fractional part into a temporary buffer. The buffer\n+            // only need to hold 9 elements, because `fractional_part` has to\n+            // be smaller than 10^9. The buffer is prefilled with '0' digits\n+            // to simplify the code below.\n+            let mut buf = [b'0'; 9];\n+\n+            // The next digit is written at this position\n+            let mut pos = 0;\n+\n+            // We can stop when there are no non-zero digits left or (when a\n+            // precision was set and we already emitted that many digits).\n+            while fractional_part > 0 && f.precision().map(|p| p > pos).unwrap_or(true) {\n+                // Write new digit into the buffer\n+                buf[pos] = b'0' + (fractional_part / divisor) as u8;\n+\n+                fractional_part %= divisor;\n+                divisor /= 10;\n+                pos += 1;\n+            }\n+\n+            // If we haven't emitted a single fractional digit and the precision\n+            // wasn't set to a non-zero value, we don't print the decimal point.\n+            let end = f.precision().unwrap_or(pos);\n+            if end == 0 {\n+                write!(f, \"{}\", integer_part)\n+            } else {\n+                // We are only writing ASCII digits into the buffer and it was\n+                // initialized with '0's, so it contains valid UTF8.\n+                let s = unsafe {\n+                    ::str::from_utf8_unchecked(&buf[..end])\n+                };\n+\n+                write!(f, \"{}.{}\", integer_part, s)\n+            }\n+        }\n+\n+        // Print leading '+' sign if requested\n+        if f.sign_plus() {\n+            write!(f, \"+\")?;\n+        }\n+\n+        if self.secs > 0 {\n+            fmt_decimal(f, self.secs, self.nanos, 100_000_000)?;\n+            f.write_str(\"s\")\n+        } else if self.nanos >= 1_000_000 {\n+            fmt_decimal(f, self.nanos as u64 / 1_000_000, self.nanos % 1_000_000, 100_000)?;\n+            f.write_str(\"ms\")\n+        } else if self.nanos >= 1_000 {\n+            fmt_decimal(f, self.nanos as u64 / 1_000, self.nanos % 1_000, 100)?;\n+            f.write_str(\"\u00b5s\")\n+        } else {\n+            write!(f, \"{}ns\", self.nanos)\n+        }\n+    }\n+}"}]}