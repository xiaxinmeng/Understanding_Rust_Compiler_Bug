{"sha": "0420c27c8e662990e884fc93f58eff5ea12dd995", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MjBjMjdjOGU2NjI5OTBlODg0ZmM5M2Y1OGVmZjVlYTEyZGQ5OTU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-04T14:55:05Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-04T14:55:05Z"}, "message": "fix drop ordering and forward fat pointer extras to fields\n\nthis doesn't yet use the fat pointer extras", "tree": {"sha": "7f7d760ab2d6477582ea797e10ecfef16bc58a86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f7d760ab2d6477582ea797e10ecfef16bc58a86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0420c27c8e662990e884fc93f58eff5ea12dd995", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYHKFJAAoJEFbW7qD8Z6xG2nkP/2mS7CFD7Du/mpBFm4eX8Soz\nzKY9u4nSMlQYNRmKqmFJTlF6TFnJ6W+WCDk0P1B0n5Ufzk1dShxAkEwVwT1Ig0OM\ntl0gxPGGmrw85+MoSP36Tk/Z6fsqJByqiGE2XV39nlJZhjmdSv+CWWUCz1Wtd5T1\ncu7aBhH9XpuMBPWgyunbmeGhOQTaaRkgo41isH2xTlnccQqszvXwgHleOX63v4g0\n+i6pT8ilRqUYixBhJWmabWEtm8Ih0rYRGx0VxtAB3jSFdy/hHasnRU1aaiEsSQRl\n68X6SsvZgFFzmLFG9vvsWRUvpnF/wyxQFt/hgjL4qvMFYCSlveFGdOlpanDIccwm\niNHBb4eH55JdEFe2CHftcMOtUrxtaMVvW0OdBv7CLjrkkLMfdLJdIEh/JfEi5nug\nChMY4MlFqX10lZrVBY/lKsjQVlw1GZ5Nu3YVrWOnW/JBki79tWSG7egTwFJSAQCZ\naM1DA+wANw6VaOSKwrbD95NEhK86hr6jsI0dL6klwUnBkxV6rI3nPLTqvsXmZxnh\nIsa/G9w+1BBMFo4xUOl5ORCTI+uRcAoTJIJc1UWAnB43+sJ0NdgSnFjD0l7Bs8+t\n4HBNgDegdnWGn0c+LS+UpiJAAYNVgZRn+l3c7oajcryDzdjfkvE3Ou/hw7ZxnHpL\nRCjbZbyaxfNc0b+p/nLe\n=Of/m\n-----END PGP SIGNATURE-----", "payload": "tree 7f7d760ab2d6477582ea797e10ecfef16bc58a86\nparent 859b7049c89244c73c0ebf1520f73f1bdf98f359\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1478271305 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1478271305 +0100\n\nfix drop ordering and forward fat pointer extras to fields\n\nthis doesn't yet use the fat pointer extras"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0420c27c8e662990e884fc93f58eff5ea12dd995", "html_url": "https://github.com/rust-lang/rust/commit/0420c27c8e662990e884fc93f58eff5ea12dd995", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0420c27c8e662990e884fc93f58eff5ea12dd995/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "859b7049c89244c73c0ebf1520f73f1bdf98f359", "url": "https://api.github.com/repos/rust-lang/rust/commits/859b7049c89244c73c0ebf1520f73f1bdf98f359", "html_url": "https://github.com/rust-lang/rust/commit/859b7049c89244c73c0ebf1520f73f1bdf98f359"}], "stats": {"total": 137, "additions": 113, "deletions": 24}, "files": [{"sha": "1a0edb0b91a7a60adda4161d4d04b3811bd671e8", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/0420c27c8e662990e884fc93f58eff5ea12dd995/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0420c27c8e662990e884fc93f58eff5ea12dd995/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=0420c27c8e662990e884fc93f58eff5ea12dd995", "patch": "@@ -3,7 +3,7 @@ use rustc::mir;\n use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use std::rc::Rc;\n use syntax::codemap::{DUMMY_SP, Span};\n@@ -12,7 +12,7 @@ use syntax::{ast, attr};\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n use primval::PrimVal;\n-use super::{EvalContext, Lvalue, IntegerExt, StackPopCleanup};\n+use super::{EvalContext, Lvalue, IntegerExt, StackPopCleanup, LvalueExtra, monomorphize_field_ty};\n use super::value::Value;\n \n mod intrinsics;\n@@ -146,9 +146,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn eval_drop_impls(&mut self, drops: Vec<(DefId, Pointer, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n+    fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n         let span = self.frame().span;\n-        for (drop_def_id, adt_ptr, substs) in drops {\n+        // add them to the stack in reverse order, because the impl that needs to run the last\n+        // is the one that needs to be at the bottom of the stack\n+        for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n             // FIXME: supply a real span\n             let mir = self.load_mir(drop_def_id)?;\n             trace!(\"substs for drop glue: {:?}\", substs);\n@@ -165,7 +167,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             assert!(arg_locals.next().is_none(), \"drop impl should have only one arg\");\n             let dest = self.eval_lvalue(&mir::Lvalue::Local(first))?;\n             let ty = self.frame().mir.local_decls[first].ty;\n-            self.write_value(Value::ByVal(PrimVal::from_ptr(adt_ptr)), dest, ty)?;\n+            self.write_value(self_arg, dest, ty)?;\n         }\n         Ok(())\n     }\n@@ -513,7 +515,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         lval: Lvalue<'tcx>,\n         ty: Ty<'tcx>,\n-        drop: &mut Vec<(DefId, Pointer, &'tcx Substs<'tcx>)>,\n+        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n     ) -> EvalResult<'tcx, ()> {\n         if !self.type_needs_drop(ty) {\n             debug!(\"no need to drop {:?}\", ty);\n@@ -525,18 +527,53 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // special case `Box` to deallocate the inner allocation\n             ty::TyBox(contents_ty) => {\n                 let val = self.read_lvalue(lval)?;\n-                let contents_ptr = val.read_ptr(&self.memory)?;\n-                self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n-                trace!(\"-deallocating box\");\n-                self.memory.deallocate(contents_ptr)?;\n+                // we are going through the read_value path, because that already does all the\n+                // checks for the trait object types. We'd only be repeating ourselves here.\n+                let val = self.follow_by_ref_value(val, ty)?;\n+                trace!(\"box dealloc on {:?}\", val);\n+                match val {\n+                    Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n+                    Value::ByVal(ptr) => {\n+                        assert!(self.type_is_sized(contents_ty));\n+                        let contents_ptr = ptr.expect_ptr(\"value of Box type must be a pointer\");\n+                        self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n+                    },\n+                    Value::ByValPair(prim_ptr, extra) => {\n+                        let ptr = prim_ptr.expect_ptr(\"value of Box type must be a pointer\");\n+                        let extra = match extra.try_as_ptr() {\n+                            Some(vtable) => LvalueExtra::Vtable(vtable),\n+                            None => LvalueExtra::Length(extra.expect_uint(\"slice length\")),\n+                        };\n+                        self.drop(\n+                            Lvalue::Ptr {\n+                                ptr: ptr,\n+                                extra: extra,\n+                            },\n+                            contents_ty,\n+                            drop,\n+                        )?;\n+                    },\n+                }\n+                let box_free_fn = self.tcx.lang_items.box_free_fn().expect(\"no box_free lang item\");\n+                let substs = self.tcx.intern_substs(&[Kind::from(contents_ty)]);\n+                // this is somewhat hacky, but hey, there's no representation difference between\n+                // pointers and references, so\n+                // #[lang = \"box_free\"] unsafe fn box_free<T>(ptr: *mut T)\n+                // is the same as\n+                // fn drop(&mut self) if Self is Box<T>\n+                drop.push((box_free_fn, val, substs));\n             },\n \n             ty::TyAdt(adt_def, substs) => {\n                 // FIXME: some structs are represented as ByValPair\n-                let adt_ptr = self.force_allocation(lval)?.to_ptr();\n+                let lval = self.force_allocation(lval)?;\n+                let adt_ptr = match lval {\n+                    Lvalue::Ptr { ptr, .. } => ptr,\n+                    _ => bug!(\"force allocation can only yield Lvalue::Ptr\"),\n+                };\n                 // run drop impl before the fields' drop impls\n                 if let Some(drop_def_id) = adt_def.destructor() {\n-                    drop.push((drop_def_id, adt_ptr, substs));\n+                    drop.push((drop_def_id, Value::ByVal(PrimVal::from_ptr(adt_ptr)), substs));\n                 }\n                 let layout = self.type_layout(ty);\n                 let fields = match *layout {\n@@ -565,10 +602,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         if discr == nndiscr {\n                             assert_eq!(adt_def.variants[discr as usize].fields.len(), 1);\n                             let field_ty = &adt_def.variants[discr as usize].fields[0];\n-                            let field_ty = self.monomorphize_field_ty(field_ty, substs);\n+                            let field_ty = monomorphize_field_ty(self.tcx, field_ty, substs);\n                             // FIXME: once read_discriminant_value works with lvalue, don't force\n                             // alloc in the RawNullablePointer case\n-                            self.drop(Lvalue::from_ptr(adt_ptr), field_ty, drop)?;\n+                            self.drop(lval, field_ty, drop)?;\n                             return Ok(());\n                         } else {\n                             // FIXME: the zst variant might contain zst types that impl Drop\n@@ -577,25 +614,57 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n                     _ => bug!(\"{:?} is not an adt layout\", layout),\n                 };\n-                for (field_ty, offset) in fields {\n-                    let field_ty = self.monomorphize_field_ty(field_ty, substs);\n-                    self.drop(Lvalue::from_ptr(adt_ptr.offset(offset.bytes() as isize)), field_ty, drop)?;\n-                }\n+                let tcx = self.tcx;\n+                self.drop_fields(\n+                    fields.map(|(ty, &offset)| (monomorphize_field_ty(tcx, ty, substs), offset)),\n+                    lval,\n+                    drop,\n+                )?;\n             },\n             ty::TyTuple(fields) => {\n-                // FIXME: some tuples are represented as ByValPair\n-                let ptr = self.force_allocation(lval)?.to_ptr();\n-                for (i, field_ty) in fields.iter().enumerate() {\n-                    let offset = self.get_field_offset(ty, i)?.bytes() as isize;\n-                    self.drop(Lvalue::from_ptr(ptr.offset(offset)), field_ty, drop)?;\n-                }\n+                let offsets = match *self.type_layout(ty) {\n+                    Layout::Univariant { ref variant, .. } => &variant.offsets,\n+                    _ => bug!(\"tuples must be univariant\"),\n+                };\n+                self.drop_fields(fields.iter().cloned().zip(offsets.iter().cloned()), lval, drop)?;\n             },\n             // other types do not need to process drop\n             _ => {},\n         }\n \n         Ok(())\n     }\n+\n+    fn drop_fields<\n+        I: Iterator<Item=(Ty<'tcx>, ty::layout::Size)>,\n+    >(\n+        &mut self,\n+        mut fields: I,\n+        lval: Lvalue<'tcx>,\n+        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n+    ) -> EvalResult<'tcx, ()> {\n+        // FIXME: some aggregates may be represented by PrimVal::Pair\n+        let (adt_ptr, extra) = match self.force_allocation(lval)? {\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+            _ => bug!(\"force allocation must yield Lvalue::Ptr\"),\n+        };\n+        // manual iteration, because we need to be careful about the last field if it is unsized\n+        while let Some((field_ty, offset)) = fields.next() {\n+            let ptr = adt_ptr.offset(offset.bytes() as isize);\n+            if self.type_is_sized(field_ty) {\n+                self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n+            } else {\n+                let lvalue = Lvalue::Ptr {\n+                    ptr: ptr,\n+                    extra: extra,\n+                };\n+                self.drop(lvalue, field_ty, drop)?;\n+                break; // if it is not sized, then this is the last field anyway\n+            }\n+        }\n+        assert!(fields.next().is_none());\n+        Ok(())\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "d44c83763b7c448875c91a2e7ac37a2c0eddb1e6", "filename": "tests/run-pass/move-arg-2-unique.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0420c27c8e662990e884fc93f58eff5ea12dd995/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0420c27c8e662990e884fc93f58eff5ea12dd995/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-arg-2-unique.rs?ref=0420c27c8e662990e884fc93f58eff5ea12dd995", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_features, unused_variables)]\n+#![feature(box_syntax)]\n+\n+fn test(foo: Box<Vec<isize>> ) { assert_eq!((*foo)[0], 10); }\n+\n+pub fn main() {\n+    let x = box vec![10];\n+    // Test forgetting a local by move-in\n+    test(x);\n+}"}]}