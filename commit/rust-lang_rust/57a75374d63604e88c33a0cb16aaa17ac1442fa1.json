{"sha": "57a75374d63604e88c33a0cb16aaa17ac1442fa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YTc1Mzc0ZDYzNjA0ZTg4YzMzYTBjYjE2YWFhMTdhYzE0NDJmYTE=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-16T03:45:48Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-22T00:32:11Z"}, "message": "Initial Type Refactoring done", "tree": {"sha": "96fc42ec1a417f6dff50db759a43a7a913908299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96fc42ec1a417f6dff50db759a43a7a913908299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57a75374d63604e88c33a0cb16aaa17ac1442fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57a75374d63604e88c33a0cb16aaa17ac1442fa1", "html_url": "https://github.com/rust-lang/rust/commit/57a75374d63604e88c33a0cb16aaa17ac1442fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57a75374d63604e88c33a0cb16aaa17ac1442fa1/comments", "author": null, "committer": null, "parents": [{"sha": "befbd3a680e79672108845e1b2d9d5278f92659c", "url": "https://api.github.com/repos/rust-lang/rust/commits/befbd3a680e79672108845e1b2d9d5278f92659c", "html_url": "https://github.com/rust-lang/rust/commit/befbd3a680e79672108845e1b2d9d5278f92659c"}], "stats": {"total": 907, "additions": 429, "deletions": 478}, "files": [{"sha": "73d26b91672d24b91968359c87a6b42c4fbf45c7", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -31,7 +31,7 @@ fn align(off: uint, ty: Type) -> uint {\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: TypeRef) -> uint {\n+fn ty_align(ty: Type) -> uint {\n     unsafe {\n         return match llvm::LLVMGetTypeKind(ty) {\n             Integer => {\n@@ -41,7 +41,7 @@ fn ty_align(ty: TypeRef) -> uint {\n             Float => 4,\n             Double => 8,\n             Struct => {\n-              if llvm::LLVMIsPackedStruct(ty) == True {\n+              if ty.is_packed() {\n                 1\n               } else {\n                 let str_tys = struct_tys(ty);\n@@ -71,32 +71,31 @@ fn ty_size(ty: TypeRef) -> uint {\n                     let str_tys = struct_tys(ty);\n                     str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n                 } else {\n-                    let str_tys = struct_tys(ty);\n+                    let str_tys = ty.field_types();\n                     let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n                     align(size, ty)\n                 }\n             }\n             Array => {\n-              let len = llvm::LLVMGetArrayLength(ty) as uint;\n-              let elt = llvm::LLVMGetElementType(ty);\n-              let eltsz = ty_size(elt);\n-              len * eltsz\n+                let len = ty.array_length();\n+                let elt = ty.element_type();\n+                let eltsz = ty_size(elt);\n+                len * eltsz\n             }\n             _ => fail!(\"ty_size: unhandled type\")\n         };\n     }\n }\n \n-fn classify_ret_ty(ty: TypeRef) -> (LLVMType, Option<Attribute>) {\n+fn classify_ret_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n     return if is_reg_ty(ty) {\n         (LLVMType { cast: false, ty: ty }, None)\n     } else {\n-        (LLVMType { cast: false, ty: T_ptr(ty) }, Some(StructRetAttribute))\n+        (LLVMType { cast: false, ty: ty.ptr_to() }, Some(StructRetAttribute))\n     };\n }\n \n-fn classify_arg_ty(ty: TypeRef,\n-                   offset: &mut uint) -> (LLVMType, Option<Attribute>) {\n+fn classify_arg_ty(ty: Type, offset: &mut uint) -> (LLVMType, Option<Attribute>) {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -123,7 +122,7 @@ fn classify_arg_ty(ty: TypeRef,\n \n fn is_reg_ty(ty: TypeRef) -> bool {\n     unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n+        return match ty.kind() {\n             Integer\n             | Pointer\n             | Float\n@@ -133,16 +132,16 @@ fn is_reg_ty(ty: TypeRef) -> bool {\n     }\n }\n \n-fn padding_ty(align: uint, offset: uint) -> Option<TypeRef> {\n+fn padding_ty(align: uint, offset: uint) -> Option<Type> {\n     if ((align - 1 ) & offset) > 0 {\n-        return Some(T_i32());\n+        return Some(Type::i32());\n     }\n \n     return None;\n }\n \n-fn coerce_to_int(size: uint) -> ~[TypeRef] {\n-    let int_ty = T_i32();\n+fn coerce_to_int(size: uint) -> ~[Type] {\n+    let int_ty = Type::i32();\n     let mut args = ~[];\n \n     let mut n = size / 32;\n@@ -154,16 +153,16 @@ fn coerce_to_int(size: uint) -> ~[TypeRef] {\n     let r = size % 32;\n     if r > 0 {\n         unsafe {\n-            args.push(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint))\n+            Type::from_ref(args.push(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint)))\n         }\n     }\n \n     return args;\n }\n \n-fn struct_ty(ty: TypeRef,\n-             padding: Option<TypeRef>,\n-             coerce: bool) -> TypeRef {\n+fn struct_ty(ty: Type,\n+             padding: Option<Type>,\n+             coerce: bool) -> Type {\n     let size = ty_size(ty) * 8;\n     let mut fields = padding.map_default(~[], |p| ~[*p]);\n \n@@ -173,20 +172,20 @@ fn struct_ty(ty: TypeRef,\n         fields.push(ty);\n     }\n \n-    return T_struct(fields, false);\n+    return Type::struct_(fields, false);\n }\n \n enum MIPS_ABIInfo { MIPS_ABIInfo }\n \n impl ABIInfo for MIPS_ABIInfo {\n     fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n+                    atys: &[Type],\n+                    rty: Type,\n                     ret_def: bool) -> FnType {\n         let mut (ret_ty, ret_attr) = if ret_def {\n             classify_ret_ty(rty)\n         } else {\n-            (LLVMType { cast: false, ty: T_void() }, None)\n+            (LLVMType { cast: false, ty: Type::void() }, None)\n         };\n \n         let sret = ret_attr.is_some();\n@@ -203,7 +202,7 @@ impl ABIInfo for MIPS_ABIInfo {\n         if sret {\n             arg_tys = vec::append(~[ret_ty], arg_tys);\n             attrs = vec::append(~[ret_attr], attrs);\n-            ret_ty = LLVMType { cast: false, ty: T_void() };\n+            ret_ty = LLVMType { cast: false, ty: Type::void() };\n         }\n \n         return FnType {"}, {"sha": "0f02f7d2f868f896b5c78f3628cbba1ce298b4df", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -23,8 +23,8 @@ struct X86_ABIInfo {\n \n impl ABIInfo for X86_ABIInfo {\n     fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n+                    atys: &[Type],\n+                    rty: Type,\n                     ret_def: bool) -> FnType {\n         let mut arg_tys = do atys.map |a| {\n             LLVMType { cast: false, ty: *a }\n@@ -41,7 +41,7 @@ impl ABIInfo for X86_ABIInfo {\n         // http://www.angelcode.com/dev/callconv/callconv.html\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n         let sret = {\n-            let returning_a_struct = unsafe { LLVMGetTypeKind(rty) == Struct && ret_def };\n+            let returning_a_struct = unsafe { rty.kind() == Struct && ret_def };\n             let big_struct = match self.ccx.sess.targ_cfg.os {\n                 os_win32 | os_macos => llsize_of_alloc(self.ccx, rty) > 8,\n                 _ => true\n@@ -52,13 +52,13 @@ impl ABIInfo for X86_ABIInfo {\n         if sret {\n             let ret_ptr_ty = LLVMType {\n                 cast: false,\n-                ty: T_ptr(ret_ty.ty)\n+                ty: ret_ty.ty.ptr_to()\n             };\n             arg_tys = ~[ret_ptr_ty] + arg_tys;\n             attrs = ~[Some(StructRetAttribute)] + attrs;\n             ret_ty = LLVMType {\n                 cast: false,\n-                ty: T_void(),\n+                ty: Type::void(),\n             };\n         } else if !ret_def {\n             ret_ty = LLVMType {"}, {"sha": "e0f9ad85e10a757afc07f5996166ff682eb0460c", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 106, "deletions": 119, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -26,66 +26,81 @@ use core::uint;\n use core::vec;\n \n #[deriving(Eq)]\n-enum x86_64_reg_class {\n-    no_class,\n-    integer_class,\n-    sse_fs_class,\n-    sse_fv_class,\n-    sse_ds_class,\n-    sse_dv_class,\n-    sse_int_class,\n-    sseup_class,\n-    x87_class,\n-    x87up_class,\n-    complex_x87_class,\n-    memory_class\n+enum RegClass {\n+    NoClass,\n+    Integer,\n+    SSEFs,\n+    SSEFv,\n+    SSEDs,\n+    SSEDv,\n+    SSEInt,\n+    SSEUp,\n+    X87,\n+    X87Up,\n+    ComplexX87,\n+    Memory\n }\n \n-fn is_sse(c: x86_64_reg_class) -> bool {\n-    return match c {\n-        sse_fs_class | sse_fv_class |\n-        sse_ds_class | sse_dv_class => true,\n-        _ => false\n-    };\n+impl Type {\n+    fn is_reg_ty(&self) -> bool {\n+        match ty.kind() {\n+            Integer | Pointer | Float | Double => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n+impl RegClass {\n+    fn is_sse(&self) -> bool {\n+        match *self {\n+            SSEFs | SSEFv | SSEDs | SSEDv => true,\n+            _ => false\n+        }\n+    }\n }\n \n-fn is_ymm(cls: &[x86_64_reg_class]) -> bool {\n-    let len = cls.len();\n-    return (len > 2u &&\n-         is_sse(cls[0]) &&\n-         cls[1] == sseup_class &&\n-         cls[2] == sseup_class) ||\n-        (len > 3u &&\n-         is_sse(cls[1]) &&\n-         cls[2] == sseup_class &&\n-         cls[3] == sseup_class);\n+impl<'self> ClassList for &'self [RegClass] {\n+    fn is_pass_byval(&self) -> bool {\n+        if self.len() == 0 { return false; }\n+\n+        let class = self[0];\n+           class == Memory\n+        || class == X87\n+        || class == ComplexX87\n+    }\n+\n+    fn is_ret_bysret(&self) -> bool {\n+        if self.len() == 0 { return false; }\n+\n+        self[0] == Memory\n+    }\n }\n \n-fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n-    fn align(off: uint, ty: TypeRef) -> uint {\n+fn classify_ty(ty: Type) -> ~[RegClass] {\n+    fn align(off: uint, ty: Type) -> uint {\n         let a = ty_align(ty);\n         return (off + a - 1u) / a * a;\n     }\n \n-    fn ty_align(ty: TypeRef) -> uint {\n+    fn ty_align(ty: Type) -> uint {\n         unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) {\n+            match ty.kind() {\n                 Integer => {\n-                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+                    ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n                 }\n                 Pointer => 8,\n                 Float => 4,\n                 Double => 8,\n                 Struct => {\n-                  if llvm::LLVMIsPackedStruct(ty) == True {\n+                  if ty.is_packed() {\n                     1\n                   } else {\n-                    let str_tys = struct_tys(ty);\n+                    let str_tys = ty.field_types();\n                     str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n                   }\n                 }\n                 Array => {\n-                    let elt = llvm::LLVMGetElementType(ty);\n+                    let elt = ty.element_type();\n                     ty_align(elt)\n                 }\n                 _ => fail!(\"ty_size: unhandled type\")\n@@ -95,43 +110,43 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n \n     fn ty_size(ty: TypeRef) -> uint {\n         unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) {\n+            match ty.kind() {\n                 Integer => {\n                     ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n                 }\n                 Pointer => 8,\n                 Float => 4,\n                 Double => 8,\n                 Struct => {\n-                    if llvm::LLVMIsPackedStruct(ty) == True {\n-                        let str_tys = struct_tys(ty);\n+                    if ty.is_packed() {\n+                        let str_tys = ty.field_types();\n                         str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n                     } else {\n-                        let str_tys = struct_tys(ty);\n+                        let str_tys = ty.field_types();\n                         let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n                         align(size, ty)\n                     }\n                 }\n                 Array => {\n-                  let len = llvm::LLVMGetArrayLength(ty) as uint;\n-                  let elt = llvm::LLVMGetElementType(ty);\n-                  let eltsz = ty_size(elt);\n-                  len * eltsz\n+                    let len = ty.array_length();\n+                    let elt = ty.element_type();\n+                    let eltsz = ty_size(elt);\n+                    len * eltsz\n                 }\n                 _ => fail!(\"ty_size: unhandled type\")\n-            };\n+            }\n         }\n     }\n \n-    fn all_mem(cls: &mut [x86_64_reg_class]) {\n+    fn all_mem(cls: &mut [RegClass]) {\n         for uint::range(0, cls.len()) |i| {\n             cls[i] = memory_class;\n         }\n     }\n \n-    fn unify(cls: &mut [x86_64_reg_class],\n+    fn unify(cls: &mut [RegClass],\n              i: uint,\n-             newv: x86_64_reg_class) {\n+             newv: RegClass) {\n         if cls[i] == newv {\n             return;\n         } else if cls[i] == no_class {\n@@ -154,8 +169,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn classify_struct(tys: &[TypeRef],\n-                       cls: &mut [x86_64_reg_class], i: uint,\n+    fn classify_struct(tys: &[Type],\n+                       cls: &mut [RegClass], i: uint,\n                        off: uint) {\n         let mut field_off = off;\n         for tys.each |ty| {\n@@ -165,8 +180,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn classify(ty: TypeRef,\n-                cls: &mut [x86_64_reg_class], ix: uint,\n+    fn classify(ty: Type,\n+                cls: &mut [RegClass], ix: uint,\n                 off: uint) {\n         unsafe {\n             let t_align = ty_align(ty);\n@@ -183,28 +198,28 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                 return;\n             }\n \n-            match llvm::LLVMGetTypeKind(ty) as int {\n-                8 /* integer */ |\n-                12 /* pointer */ => {\n+            match ty.kind() {\n+                Integer |\n+                Pointer => {\n                     unify(cls, ix + off / 8u, integer_class);\n                 }\n-                2 /* float */ => {\n+                Float => {\n                     if off % 8u == 4u {\n                         unify(cls, ix + off / 8u, sse_fv_class);\n                     } else {\n                         unify(cls, ix + off / 8u, sse_fs_class);\n                     }\n                 }\n-                3 /* double */ => {\n+                Double => {\n                     unify(cls, ix + off / 8u, sse_ds_class);\n                 }\n-                10 /* struct */ => {\n-                    classify_struct(struct_tys(ty), cls, ix, off);\n+                Struct => {\n+                    classify_struct(ty.field_types(), cls, ix, off);\n                 }\n-                11 /* array */ => {\n-                    let elt = llvm::LLVMGetElementType(ty);\n+                Array => {\n+                    let len = ty.array_length();\n+                    let elt = ty.element_type();\n                     let eltsz = ty_size(elt);\n-                    let len = llvm::LLVMGetArrayLength(ty) as uint;\n                     let mut i = 0u;\n                     while i < len {\n                         classify(elt, cls, ix, off + i * eltsz);\n@@ -216,15 +231,15 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn fixup(ty: TypeRef, cls: &mut [x86_64_reg_class]) {\n+    fn fixup(ty: Type, cls: &mut [RegClass]) {\n         unsafe {\n             let mut i = 0u;\n-            let llty = llvm::LLVMGetTypeKind(ty) as int;\n+            let ty_kind = ty.kind();\n             let e = cls.len();\n             if cls.len() > 2u &&\n-               (llty == 10 /* struct */ ||\n-                llty == 11 /* array */) {\n-                if is_sse(cls[i]) {\n+               (ty_kind == Struct ||\n+                ty_kind == Array) {\n+                if cls[i].is_sse() {\n                     i += 1u;\n                     while i < e {\n                         if cls[i] != sseup_class {\n@@ -251,7 +266,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                     }\n                     if cls[i] == sseup_class {\n                         cls[i] = sse_int_class;\n-                    } else if is_sse(cls[i]) {\n+                    } else if cls[i].is_sse() {\n                         i += 1;\n                         while i != e && cls[i] == sseup_class { i += 1u; }\n                     } else if cls[i] == x87_class {\n@@ -277,8 +292,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     return cls;\n }\n \n-fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n-    fn llvec_len(cls: &[x86_64_reg_class]) -> uint {\n+fn llreg_ty(cls: &[RegClass]) -> Type {\n+    fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1u;\n         for cls.each |c| {\n             if *c != sseup_class {\n@@ -296,96 +311,68 @@ fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n         while i < e {\n             match cls[i] {\n                 integer_class => {\n-                    tys.push(T_i64());\n+                    tys.push(Type::i64());\n                 }\n                 sse_fv_class => {\n                     let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n-                    let vec_ty = llvm::LLVMVectorType(T_f32(),\n-                                                      vec_len as c_uint);\n+                    let vec_ty = Type::vector(Type::f32(), vec_len);\n                     tys.push(vec_ty);\n                     i += vec_len;\n                     loop;\n                 }\n                 sse_fs_class => {\n-                    tys.push(T_f32());\n+                    tys.push(Type::f32());\n                 }\n                 sse_ds_class => {\n-                    tys.push(T_f64());\n+                    tys.push(Type::f64());\n                 }\n                 _ => fail!(\"llregtype: unhandled class\")\n             }\n             i += 1u;\n         }\n-        return T_struct(tys, false);\n+        return Type::struct_(tys, false);\n     }\n }\n \n-fn x86_64_tys(atys: &[TypeRef],\n-              rty: TypeRef,\n+fn x86_64_tys(atys: &[Type],\n+              rty: Type,\n               ret_def: bool) -> FnType {\n-    fn is_reg_ty(ty: TypeRef) -> bool {\n-        unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) as int {\n-                8 /* integer */ |\n-                12 /* pointer */ |\n-                2 /* float */ |\n-                3 /* double */ => true,\n-                _ => false\n-            };\n-        }\n-    }\n-\n-    fn is_pass_byval(cls: &[x86_64_reg_class]) -> bool {\n-        return cls.len() > 0 &&\n-            (cls[0] == memory_class ||\n-             cls[0] == x87_class ||\n-             cls[0] == complex_x87_class);\n-    }\n \n-    fn is_ret_bysret(cls: &[x86_64_reg_class]) -> bool {\n-        return cls.len() > 0 && cls[0] == memory_class;\n-    }\n-\n-    fn x86_64_ty(ty: TypeRef,\n-                 is_mem_cls: &fn(cls: &[x86_64_reg_class]) -> bool,\n+    fn x86_64_ty(ty: Type,\n+                 is_mem_cls: &fn(cls: &[RegClass]) -> bool,\n                  attr: Attribute) -> (LLVMType, Option<Attribute>) {\n-        let mut cast = false;\n-        let mut ty_attr = option::None;\n-        let mut llty = ty;\n-        if !is_reg_ty(ty) {\n+        let (cast, attr, ty) = if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls) {\n-                llty = T_ptr(ty);\n-                ty_attr = option::Some(attr);\n+                (false, option::Some(attr), ty.ptr_to())\n             } else {\n-                cast = true;\n-                llty = llreg_ty(cls);\n+                (true, option::None, llreg_ty(cls))\n             }\n-        }\n-        return (LLVMType { cast: cast, ty: llty }, ty_attr);\n+        };\n+        return (LLVMType { cast: cast, ty: ty }, attr);\n     }\n \n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n     for atys.each |t| {\n-        let (ty, attr) = x86_64_ty(*t, is_pass_byval, ByValAttribute);\n+        let (ty, attr) = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n         attrs.push(attr);\n     }\n-    let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n+    let mut (ret_ty, ret_attr) = x86_64_ty(rty, |cls| cls.is_ret_bysret(),\n                                        StructRetAttribute);\n     let sret = ret_attr.is_some();\n     if sret {\n         arg_tys = vec::append(~[ret_ty], arg_tys);\n         ret_ty = LLVMType {\n                    cast:  false,\n-                   ty: T_void()\n+                   ty: Type::void()\n                  };\n         attrs = vec::append(~[ret_attr], attrs);\n     } else if !ret_def {\n         ret_ty = LLVMType {\n                    cast: false,\n-                   ty: T_void()\n+                   ty: Type::void()\n                  };\n     }\n     return FnType {\n@@ -400,8 +387,8 @@ enum X86_64_ABIInfo { X86_64_ABIInfo }\n \n impl ABIInfo for X86_64_ABIInfo {\n     fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n+                    atys: &[Type],\n+                    rty: Type,\n                     ret_def: bool) -> FnType {\n         return x86_64_tys(atys, rty, ret_def);\n     }"}, {"sha": "6d2446f013705c09e9c1b360c3e992a4414a1e40", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -326,7 +326,7 @@ pub fn trans_fn_ref_with_vtables(\n             let ref_ty = common::node_id_type(bcx, ref_id);\n \n             val = PointerCast(\n-                bcx, val, T_ptr(type_of::type_of_fn_from_ty(ccx, ref_ty)));\n+                bcx, val, type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to());\n         }\n         return FnData {llfn: val};\n     }\n@@ -516,7 +516,7 @@ pub fn trans_call_inner(in_cx: block,\n         let mut bcx = callee.bcx;\n         let ccx = cx.ccx();\n         let ret_flag = if ret_in_loop {\n-            let flag = alloca(bcx, T_bool());\n+            let flag = alloca(bcx, Type::bool());\n             Store(bcx, C_bool(false), flag);\n             Some(flag)\n         } else {\n@@ -526,13 +526,13 @@ pub fn trans_call_inner(in_cx: block,\n         let (llfn, llenv) = unsafe {\n             match callee.data {\n                 Fn(d) => {\n-                    (d.llfn, llvm::LLVMGetUndef(T_opaque_box_ptr(ccx)))\n+                    (d.llfn, llvm::LLVMGetUndef(Type::opaque_box(ccx).ptr_to()))\n                 }\n                 Method(d) => {\n                     // Weird but true: we pass self in the *environment* slot!\n                     let llself = PointerCast(bcx,\n                                              d.llself,\n-                                             T_opaque_box_ptr(ccx));\n+                                             Type::opaque_box(ccx).ptr_to());\n                     (d.llfn, llself)\n                 }\n                 Closure(d) => {\n@@ -653,7 +653,7 @@ pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: expr::Dest)\n         expr::Ignore => {\n             if ty::type_is_nil(retty) {\n                 unsafe {\n-                    llvm::LLVMGetUndef(T_ptr(T_nil()))\n+                    llvm::LLVMGetUndef(Type::nil().ptr_to())\n                 }\n             } else {\n                 alloc_ty(bcx, retty)\n@@ -838,7 +838,7 @@ pub fn trans_arg_expr(bcx: block,\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, &formal_arg_ty);\n             let llformal_arg_ty = match self_mode {\n-                ty::ByRef => T_ptr(llformal_arg_ty),\n+                ty::ByRef => llformal_arg_ty.ptr_to(),\n                 ty::ByCopy => llformal_arg_ty,\n             };\n             debug!(\"casting actual type (%s) to match formal (%s)\","}, {"sha": "35e8e866039ca3894d068b9a4c19788790197f61", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -72,7 +72,7 @@ use syntax::parse::token::special_idents;\n // closure\".\n //\n // Typically an opaque closure suffices because we only manipulate it\n-// by ptr.  The routine common::T_opaque_box_ptr() returns an\n+// by ptr.  The routine Type::opaque_box().ptr_to() returns an\n // appropriate type for such an opaque closure; it allows access to\n // the box fields, but not the closure_data itself.\n //\n@@ -168,7 +168,7 @@ pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n         let _icx = bcx.insn_ctxt(\"closure::nuke_ref_count\");\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n-        let llbox = PointerCast(bcx, llbox, T_opaque_box_ptr(ccx));\n+        let llbox = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n         let ref_cnt = GEPi(bcx, llbox, [0u, abi::box_field_refcnt]);\n         let rc = C_int(ccx, 0x12345678);\n         Store(bcx, rc, ref_cnt);\n@@ -302,7 +302,7 @@ pub fn build_closure(bcx0: block,\n                 Some(retptr) => retptr,\n             }\n         };\n-        let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n+        let ret_casted = PointerCast(bcx, ret_true, Type::nil().ptr_to());\n         let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(),\n                                mode: ByRef(ZeroMem)};\n         env_vals.push(EnvValue {action: EnvRef,\n@@ -509,22 +509,22 @@ pub fn make_opaque_cbox_take_glue(\n     // ~fn requires a deep copy.\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n-    let llopaquecboxty = T_opaque_box_ptr(ccx);\n+    let llopaquecboxty = Type::opaque_box(ccx).ptr_to();\n     let cbox_in = Load(bcx, cboxptr);\n     do with_cond(bcx, IsNotNull(bcx, cbox_in)) |bcx| {\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n         let tydescptr = GEPi(bcx, cbox_in, [0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n-        let tydesc = PointerCast(bcx, tydesc, T_ptr(ccx.tydesc_type));\n+        let tydesc = PointerCast(bcx, tydesc, ccx.tydesc_type.ptr_to());\n         let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));\n \n         // Adjust sz to account for the rust_opaque_box header fields\n-        let sz = Add(bcx, sz, machine::llsize_of(ccx, T_box_header(ccx)));\n+        let sz = Add(bcx, sz, machine::llsize_of(ccx, Type::box_header(ccx)));\n \n         // Allocate memory, update original ptr, and copy existing data\n-        let opaque_tydesc = PointerCast(bcx, tydesc, T_ptr(T_i8()));\n-        let rval = alloca(bcx, T_ptr(T_i8()));\n+        let opaque_tydesc = PointerCast(bcx, tydesc, Type::i8p());\n+        let rval = alloca(bcx, Type::i8p());\n         let bcx = callee::trans_lang_call(\n             bcx,\n             bcx.tcx().lang_items.exchange_malloc_fn(),\n@@ -585,7 +585,7 @@ pub fn make_opaque_cbox_free_glue(\n     let ccx = bcx.ccx();\n     do with_cond(bcx, IsNotNull(bcx, cbox)) |bcx| {\n         // Load the type descr found in the cbox\n-        let lltydescty = T_ptr(ccx.tydesc_type);\n+        let lltydescty = ccx.tydesc_type.ptr_to();\n         let cbox = Load(bcx, cbox);\n         let tydescptr = GEPi(bcx, cbox, [0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);"}, {"sha": "01b0411a07b27c8e241afa71329a3f6cbc1c9211", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 47, "deletions": 54, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -53,9 +53,7 @@ pub use middle::trans::context::CrateContext;\n pub type namegen = @fn(s: &str) -> ident;\n pub fn new_namegen() -> namegen {\n     let f: @fn(s: &str) -> ident = |prefix| {\n-        token::str_to_ident(fmt!(\"%s_%u\",\n-                                 prefix,\n-                                 token::gensym(prefix)))\n+        token::str_to_ident(fmt!(\"%s_%u\", prefix, token::gensym(prefix)))\n     };\n     f\n }\n@@ -1030,79 +1028,82 @@ pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n \n \n // LLVM constant constructors.\n-pub fn C_null(t: TypeRef) -> ValueRef {\n+pub fn C_null(t: Type) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstNull(t);\n+        llvm::LLVMConstNull(t.to_ref())\n     }\n }\n \n-pub fn C_undef(t: TypeRef) -> ValueRef {\n+pub fn C_undef(t: Type) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMGetUndef(t);\n+        llvm::LLVMGetUndef(t.to_ref())\n     }\n }\n \n-pub fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n+pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstInt(t, u, sign_extend);\n+        llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n     }\n }\n \n-pub fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n+pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        return str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n+        do s.as_c_str |buf| {\n+            llvm::LLVMConstRealOfString(t.to_ref(), buf)\n+        }\n     }\n }\n \n pub fn C_nil() -> ValueRef {\n     return C_struct([]);\n }\n \n-pub fn C_bool(b: bool) -> ValueRef {\n-    C_integral(T_bool(), if b { 1u64 } else { 0u64 }, False)\n+pub fn C_bool(val: bool) -> ValueRef {\n+    C_integral(Type::bool(), val as u64, false)\n }\n \n-pub fn C_i1(b: bool) -> ValueRef {\n-    return C_integral(T_i1(), if b { 1 } else { 0 }, False);\n+pub fn C_i1(val: bool) -> ValueRef {\n+    C_integral(Type::i1(), val as u64, false)\n }\n \n pub fn C_i32(i: i32) -> ValueRef {\n-    return C_integral(T_i32(), i as u64, True);\n+    return C_integral(Type::i32(), i as u64, true);\n }\n \n pub fn C_i64(i: i64) -> ValueRef {\n-    return C_integral(T_i64(), i as u64, True);\n+    return C_integral(Type::i64(), i as u64, true);\n }\n \n pub fn C_int(cx: &CrateContext, i: int) -> ValueRef {\n-    return C_integral(cx.int_type, i as u64, True);\n+    return C_integral(cx.int_type, i as u64, true);\n }\n \n pub fn C_uint(cx: &CrateContext, i: uint) -> ValueRef {\n-    return C_integral(cx.int_type, i as u64, False);\n+    return C_integral(cx.int_type, i as u64, false);\n }\n \n pub fn C_u8(i: uint) -> ValueRef {\n-    return C_integral(T_i8(), i as u64, False);\n+    return C_integral(Type::i8(), i as u64, false);\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache.find(&s) {\n+        match cx.const_cstr_cache.find_equiv(&s) {\n             Some(&llval) => return llval,\n             None => ()\n         }\n \n-        let sc = do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstStringInContext(cx.llcx, buf, s.len() as c_uint,\n-                                           False)\n+        let sc = do s.as_c_str |buf| {\n+            llvm::LLVMConstStringInContext(cx.llcx, buf, s.len() as c_uint, False)\n+        };\n+\n+        let gsym = token::gensym(\"str\");\n+        let g = fmt!(\"str%u\", gsym).as_c_str |buf| {\n+            llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n         };\n-        let g =\n-            str::as_c_str(fmt!(\"str%u\", (cx.names)(\"str\").name),\n-                        |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -1118,18 +1119,17 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n pub fn C_estr_slice(cx: &mut CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n-        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n+        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n         C_struct([cs, C_uint(cx, len + 1u /* +1 for null */)])\n     }\n }\n \n // Returns a Plain Old LLVM String:\n pub fn C_postr(s: &str) -> ValueRef {\n     unsafe {\n-        return do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstStringInContext(base::task_llcx(),\n-                                           buf, s.len() as c_uint, False)\n-        };\n+        do s.as_c_str |buf| {\n+            llvm::LLVMConstStringInContext(base::task_llcx(), buf, s.len() as c_uint, False)\n+        }\n     }\n }\n \n@@ -1138,26 +1138,22 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n         let mut i = 0u;\n         let mut elts: ~[ValueRef] = ~[];\n         while i < size { elts.push(C_u8(0u)); i += 1u; }\n-        return llvm::LLVMConstArray(T_i8(),\n-                                    vec::raw::to_ptr(elts),\n-                                    elts.len() as c_uint);\n+        return llvm::LLVMConstArray(Type::i8(), vec::raw::to_ptr(elts), elts.len() as c_uint);\n     }\n }\n \n pub fn C_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n-            llvm::LLVMConstStructInContext(base::task_llcx(),\n-                                           ptr, len as c_uint, False)\n+            llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, False)\n         }\n     }\n }\n \n pub fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n-            llvm::LLVMConstStructInContext(base::task_llcx(),\n-                                           ptr, len as c_uint, True)\n+            llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, True)\n         }\n     }\n }\n@@ -1172,38 +1168,35 @@ pub fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n \n pub fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n-                                    elts.len() as c_uint);\n+        return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts), elts.len() as c_uint);\n     }\n }\n \n pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstStringInContext(base::task_llcx(),\n-            cast::transmute(vec::raw::to_ptr(bytes)),\n-            bytes.len() as c_uint, True);\n+        let ptr = cast::transmute(vec::raw::to_ptr(bytes));\n+        return llvm::LLVMConstStringInContext(base::task_llcx(), ptr, bytes.len() as c_uint, True);\n     }\n }\n \n pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstStringInContext(base::task_llcx(),\n-            cast::transmute(vec::raw::to_ptr(bytes)),\n-            bytes.len() as c_uint, False);\n+        let ptr = cast::transmute(vec::raw::to_ptr(bytes));\n+        return llvm::LLVMConstStringInContext(base::task_llcx(), ptr, bytes.len() as c_uint,False);\n     }\n }\n \n pub fn C_shape(ccx: &CrateContext, bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n-        let name = fmt!(\"shape%u\", (ccx.names)(\"shape\").name);\n-        let llglobal = str::as_c_str(name, |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n-        });\n-        llvm::LLVMSetInitializer(llglobal, llshape);\n+        let name = fmt!(\"shape%u\", token::gensym(\"shape\"));\n+        let llglobal = do name.as_c_str |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape).to_ref(), buf)\n+        };\n+        llvm::LLVMSetInitializer(llglobal, llshape.to_ref());\n         llvm::LLVMSetGlobalConstant(llglobal, True);\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n-        return llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n+        return llvm::LLVMConstPointerCast(llglobal, Type::i8p().to_ref());\n     }\n }\n \n@@ -1478,7 +1471,7 @@ pub fn filename_and_line_num_from_span(bcx: block,\n                                        span: span) -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n-    let filename = build::PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n+    let filename = build::PointerCast(bcx, filename_cstr, Type::i8p());\n     let line = C_int(bcx.ccx(), loc.line as int);\n     (filename, line)\n }"}, {"sha": "bf9d3932298d496f3ba5d4f153e8c4910037e031", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -151,7 +151,11 @@ impl CrateContext {\n             let tydesc_type = Type::tydesc(targ_cfg.arch);\n             let opaque_vec_type = Type::opaque_vec(targ_cfg.arch);\n \n+            let str_slice_ty = Type::named_struct(\"str_slice\");\n+            str_slice_ty.set_struct_body([Type::i8p(), int_type]);\n+\n             tn.associate_type(\"tydesc\", &tydesc_type);\n+            tn.associate_type(\"str_slice\", &str_slice_ty);\n \n             let crate_map = decl_crate_map(sess, link_meta, llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n@@ -233,6 +237,7 @@ impl CrateContext {\n             ((end.nsec as int) - (start.nsec as int)) / 1000000;\n         self.stats.fn_times.push((name, elapsed));\n     }\n+\n }\n \n #[unsafe_destructor]"}, {"sha": "17009afda4915e8203a577430d443ce3b21e69b2", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -204,10 +204,10 @@ pub fn trans_log(log_ex: @ast::expr,\n         let global;\n         unsafe {\n             global = str::as_c_str(s, |buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+                llvm::LLVMAddGlobal(ccx.llmod, Type::i32(), buf)\n             });\n             llvm::LLVMSetGlobalConstant(global, False);\n-            llvm::LLVMSetInitializer(global, C_null(T_i32()));\n+            llvm::LLVMSetInitializer(global, C_null(Type::i32()));\n             lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);\n         }\n         ccx.module_data.insert(modname, global);\n@@ -307,7 +307,7 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n         Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n         expr::SaveIn(match e {\n           Some(x) => PointerCast(bcx, retptr,\n-                                 T_ptr(type_of(bcx.ccx(), expr_ty(bcx, x)))),\n+                                 type_of(bcx.ccx(), expr_ty(bcx, x)).ptr_to()),\n           None => retptr\n         })\n       }\n@@ -381,8 +381,8 @@ fn trans_fail_value(bcx: block,\n         (C_cstr(bcx.ccx(), @\"<runtime>\"), 0)\n       }\n     };\n-    let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n-    let V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n+    let V_str = PointerCast(bcx, V_fail_str, Type::i8p());\n+    let V_filename = PointerCast(bcx, V_filename, Type::i8p());\n     let args = ~[V_str, V_filename, C_int(ccx, V_line)];\n     let bcx = callee::trans_lang_call(\n         bcx, bcx.tcx().lang_items.fail_fn(), args, expr::Ignore);"}, {"sha": "8e25da202cca524448874a61d6faca963f74dca2", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -474,7 +474,7 @@ impl Datum {\n             ByRef(_) => self.val,\n             ByValue => {\n                 if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n-                    C_null(T_ptr(type_of::type_of(bcx.ccx(), self.ty)))\n+                    C_null(type_of::type_of(bcx.ccx(), self.ty).ptr_to())\n                 } else {\n                     let slot = alloc_ty(bcx, self.ty);\n                     Store(bcx, self.val, slot);"}, {"sha": "92cbf2c09570d3e83ff47178d662b6af7e5ab3a7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -122,7 +122,7 @@ lvalues are *never* stored by value.\n use core::prelude::*;\n \n use back::abi;\n-use lib::llvm::{ValueRef, TypeRef, llvm};\n+use lib::llvm::{ValueRef, llvm};\n use lib;\n use metadata::csearch;\n use middle::trans::_match;\n@@ -794,7 +794,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n                     ty: ty::mk_mach_uint(ast::ty_u8),\n                     mutbl: ast::m_imm\n                 }); // *u8\n-            (rust_ty, PointerCast(bcx, fn_data.llfn, T_ptr(T_i8())))\n+            (rust_ty, PointerCast(bcx, fn_data.llfn, Type::i8p()))\n         } else {\n             let fn_ty = expr_ty(bcx, ref_expr);\n             (fn_ty, fn_data.llfn)\n@@ -924,7 +924,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                                  ix_val, unscaled_len)\n         };\n         let elt = InBoundsGEP(bcx, base, [ix_val]);\n-        let elt = PointerCast(bcx, elt, T_ptr(vt.llunit_ty));\n+        let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n         return DatumBlock {\n             bcx: bcx,\n             datum: Datum {val: elt,\n@@ -963,7 +963,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                         // which may not be equal to the enum's type for\n                         // non-C-like enums.\n                         let val = base::get_item_val(bcx.ccx(), did.node);\n-                        let pty = T_ptr(type_of(bcx.ccx(), const_ty));\n+                        let pty = type_of(bcx.ccx(), const_ty).ptr_to();\n                         PointerCast(bcx, val, pty)\n                     } else {\n                         {\n@@ -1054,7 +1054,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             // This cast should not be necessary. We should cast self *once*,\n             // but right now this conflicts with default methods.\n             let real_self_ty = monomorphize_type(bcx, self_info.t);\n-            let llselfty = T_ptr(type_of::type_of(bcx.ccx(), real_self_ty));\n+            let llselfty = type_of::type_of(bcx.ccx(), real_self_ty).ptr_to();\n \n             let casted_val = PointerCast(bcx, self_info.v, llselfty);\n             Datum {\n@@ -1438,7 +1438,7 @@ fn trans_eager_binop(bcx: block,\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n-            ZExt(bcx, cmpr.val, T_i8())\n+            ZExt(bcx, cmpr.val, Type::i8())\n         }\n       }\n       _ => {\n@@ -1491,7 +1491,7 @@ fn trans_lazy_binop(bcx: block,\n     }\n \n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, T_bool(), [lhs, rhs], [past_lhs.llbb,\n+    let phi = Phi(join, Type::bool(), [lhs, rhs], [past_lhs.llbb,\n                                                past_rhs.llbb]);\n \n     return immediate_rvalue_bcx(join, phi, binop_ty);\n@@ -1548,7 +1548,7 @@ fn trans_overloaded_op(bcx: block,\n                              DoAutorefArg)\n }\n \n-fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n+fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"int_cast\");\n     unsafe {\n@@ -1566,7 +1566,7 @@ fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     }\n }\n \n-fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n+fn float_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n               llsrc: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"float_cast\");\n     let srcsz = lib::llvm::float_width(llsrctype);"}, {"sha": "50d4709735ca9230d108f7b5c217001e454e918e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -11,7 +11,7 @@\n use core::prelude::*;\n \n use back::{link, abi};\n-use lib::llvm::{TypeRef, ValueRef};\n+use lib::llvm::{ValueRef};\n use lib;\n use middle::trans::base::*;\n use middle::trans::cabi;\n@@ -72,19 +72,19 @@ struct ShimTypes {\n \n     /// Type of the struct we will use to shuttle values back and forth.\n     /// This is always derived from the llsig.\n-    bundle_ty: TypeRef,\n+    bundle_ty: Type,\n \n     /// Type of the shim function itself.\n-    shim_fn_ty: TypeRef,\n+    shim_fn_ty: Type,\n \n     /// Adapter object for handling native ABI rules (trust me, you\n     /// don't want to know).\n     fn_ty: cabi::FnType\n }\n \n struct LlvmSignature {\n-    llarg_tys: ~[TypeRef],\n-    llret_ty: TypeRef,\n+    llarg_tys: ~[Type],\n+    llret_ty: Type,\n     sret: bool,\n }\n \n@@ -113,20 +113,16 @@ fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n         _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig);\n-    let bundle_ty = T_struct(vec::append_one(copy llsig.llarg_tys,\n-                                             T_ptr(llsig.llret_ty)),\n-                             false);\n+    let bundle_ty = Type::struct_(llsig.llarg_tys + [llsig.llret_ty.ptr_to()], false);\n     let ret_def = !ty::type_is_bot(fn_sig.output) &&\n                   !ty::type_is_nil(fn_sig.output);\n-    let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys,\n-                                           llsig.llret_ty,\n-                                           ret_def);\n+    let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys, llsig.llret_ty, ret_def);\n     ShimTypes {\n         fn_sig: fn_sig,\n         llsig: llsig,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n-        shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void()),\n+        shim_fn_ty: Type::func([bundle_ty.ptr_to()], Type::void()),\n         fn_ty: fn_ty\n     }\n }\n@@ -210,8 +206,8 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     arg_builder(bcx, tys, llwrapfn, llargbundle);\n \n     // Create call itself.\n-    let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n-    let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n+    let llshimfnptr = PointerCast(bcx, llshimfn, Type::i8p());\n+    let llrawargbundle = PointerCast(bcx, llargbundle, Type::i8p());\n     Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n     ret_builder(bcx, tys, llargbundle);\n \n@@ -239,7 +235,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n             // XXX: This is ugly.\n             let llretptr = BitCast(return_context,\n                                    fcx.llretptr.get(),\n-                                   T_ptr(llfunctionreturntype));\n+                                   llfunctionreturntype.ptr_to());\n             Ret(return_context, Load(return_context, llretptr));\n         }\n     }\n@@ -688,9 +684,9 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let static_ti = get_tydesc(ccx, tp_ty);\n             glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n-            // FIXME (#3727): change this to T_ptr(ccx.tydesc_ty) when the\n+            // FIXME (#3727): change this to ccx.tydesc_ty.ptr_to() when the\n             // core::sys copy of the get_tydesc interface dies off.\n-            let td = PointerCast(bcx, static_ti.tydesc, T_ptr(T_nil()));\n+            let td = PointerCast(bcx, static_ti.tydesc, Type::nil().ptr_to());\n             Store(bcx, td, fcx.llretptr.get());\n         }\n         \"init\" => {\n@@ -734,7 +730,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 // code bloat when `transmute` is used on large structural\n                 // types.\n                 let lldestptr = fcx.llretptr.get();\n-                let lldestptr = PointerCast(bcx, lldestptr, T_ptr(T_i8()));\n+                let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n \n                 let llsrcval = get_param(decl, first_real_arg);\n                 let llsrcptr = if ty::type_is_immediate(in_type) {\n@@ -744,7 +740,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 } else {\n                     llsrcval\n                 };\n-                let llsrcptr = PointerCast(bcx, llsrcptr, T_ptr(T_i8()));\n+                let llsrcptr = PointerCast(bcx, llsrcptr, Type::i8p());\n \n                 let llsize = llsize_of(ccx, llintype);\n                 call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n@@ -761,12 +757,9 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let visitor = get_param(decl, first_real_arg + 1u);\n             //let llvisitorptr = alloca(bcx, val_ty(visitor));\n             //Store(bcx, visitor, llvisitorptr);\n-            let td = PointerCast(bcx, td, T_ptr(ccx.tydesc_type));\n-            glue::call_tydesc_glue_full(bcx,\n-                                        visitor,\n-                                        td,\n-                                        abi::tydesc_field_visit_glue,\n-                                        None);\n+            let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n+            glue::call_tydesc_glue_full(bcx, visitor, td,\n+                                        abi::tydesc_field_visit_glue, None);\n         }\n         \"frame_address\" => {\n             let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n@@ -801,8 +794,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let llfty = type_of_fn(bcx.ccx(), [], ty::mk_nil());\n             let morestack_addr = decl_cdecl_fn(\n                 bcx.ccx().llmod, \"__morestack\", llfty);\n-            let morestack_addr = PointerCast(bcx, morestack_addr,\n-                                             T_ptr(T_nil()));\n+            let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n             Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n         \"memcpy32\" => {\n@@ -811,8 +803,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i32\");\n@@ -824,8 +816,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i64\");\n@@ -837,8 +829,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i32\");\n@@ -850,8 +842,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i64\");\n@@ -863,7 +855,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n             let val = get_param(decl, first_real_arg + 1);\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n@@ -876,7 +868,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n             let val = get_param(decl, first_real_arg + 1);\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n@@ -1231,7 +1223,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                 llargvals.push(llretptr);\n             }\n \n-            let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n+            let llenvptr = C_null(Type::opaque_box(bcx.ccx()).ptr_to());\n             llargvals.push(llenvptr);\n             while i < n {\n                 // Get a pointer to the argument:"}, {"sha": "7396508fb8dd8b3612745c15f5b038ee4f51e8d8", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -18,7 +18,7 @@ use back::abi;\n use back::link::*;\n use driver::session;\n use lib;\n-use lib::llvm::{llvm, ValueRef, TypeRef, True};\n+use lib::llvm::{llvm, ValueRef, Type, True};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::callee;\n@@ -44,19 +44,17 @@ use syntax::ast;\n \n pub fn trans_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_free\");\n-    callee::trans_lang_call(\n-        cx,\n+    callee::trans_lang_call(cx,\n         cx.tcx().lang_items.free_fn(),\n-        [PointerCast(cx, v, T_ptr(T_i8()))],\n+        [PointerCast(cx, v, Type::i8p())],\n         expr::Ignore)\n }\n \n pub fn trans_exchange_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_exchange_free\");\n-    callee::trans_lang_call(\n-        cx,\n+    callee::trans_lang_call(cx,\n         cx.tcx().lang_items.exchange_free_fn(),\n-        [PointerCast(cx, v, T_ptr(T_i8()))],\n+        [PointerCast(cx, v, Type::i8p())],\n         expr::Ignore)\n }\n \n@@ -78,14 +76,10 @@ pub fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n-pub fn drop_ty_root(bcx: block,\n-                    v: ValueRef,\n-                    rooted: bool,\n-                    t: ty::t)\n-                 -> block {\n+pub fn drop_ty_root(bcx: block, v: ValueRef, rooted: bool, t: ty::t) -> block {\n     if rooted {\n         // NB: v is a raw ptr to an addrspace'd ptr to the value.\n-        let v = PointerCast(bcx, Load(bcx, v), T_ptr(type_of(bcx.ccx(), t)));\n+        let v = PointerCast(bcx, Load(bcx, v), type_of(bcx.ccx(), t).ptr_to());\n         drop_ty(bcx, v, t)\n     } else {\n         drop_ty(bcx, v, t)\n@@ -95,14 +89,14 @@ pub fn drop_ty_root(bcx: block,\n pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).sty {\n-      ty::ty_uniq(_) |\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) => {\n+        ty::ty_uniq(_)\n+      | ty::ty_evec(_, ty::vstore_uniq)\n+      | ty::ty_estr(ty::vstore_uniq) => {\n         free_ty_immediate(bcx, v, t)\n       }\n-      ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_estr(ty::vstore_box) => {\n+        ty::ty_box(_) | ty::ty_opaque_box\n+      | ty::ty_evec(_, ty::vstore_box)\n+      | ty::ty_estr(ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, v, None, t)\n       }\n       _ => bcx.tcx().sess.bug(\"drop_ty_immediate: non-box ty\")\n@@ -340,7 +334,7 @@ pub fn call_tydesc_glue_full(bcx: block,\n       }\n     };\n \n-    let llrawptr = PointerCast(bcx, v, T_ptr(T_i8()));\n+    let llrawptr = PointerCast(bcx, v, Type::i8p());\n \n     let llfn = {\n         match static_glue_fn {\n@@ -353,8 +347,8 @@ pub fn call_tydesc_glue_full(bcx: block,\n         }\n     };\n \n-    Call(bcx, llfn, [C_null(T_ptr(T_nil())),\n-                        C_null(T_ptr(T_ptr(bcx.ccx().tydesc_type))),\n+    Call(bcx, llfn, [C_null(Type::nil().ptr_to()),\n+                        C_null(bcx.ccx().tydesc_type.ptr_to().ptr_to()),\n                         llrawptr]);\n }\n \n@@ -372,7 +366,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let bcx = do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n-        let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n+        let v = PointerCast(bcx, v, type_of::type_of(bcx.ccx(), object_ty).ptr_to());\n         bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n         // The visitor is a boxed object and needs to be dropped\n         add_clean(bcx, v, object_ty);\n@@ -390,7 +384,7 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         let v = Load(bcx, v);\n         let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n         // Cast away the addrspace of the box pointer.\n-        let body = PointerCast(bcx, body, T_ptr(type_of(ccx, body_mt.ty)));\n+        let body = PointerCast(bcx, body, type_of(ccx, body_mt.ty).ptr_to());\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n@@ -517,9 +511,8 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n               let llvtable = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n \n               // Cast the vtable to a pointer to a pointer to a tydesc.\n-              let llvtable = PointerCast(bcx,\n-                                         llvtable,\n-                                         T_ptr(T_ptr(ccx.tydesc_type)));\n+              let llvtable = PointerCast(bcx, llvtable,\n+                                         ccx.tydesc_type.ptr_to().ptr_to());\n               let lltydesc = Load(bcx, llvtable);\n               call_tydesc_glue_full(bcx,\n                                     lluniquevalue,\n@@ -680,7 +673,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n \n pub type glue_helper = @fn(block, ValueRef, ty::t);\n \n-pub fn declare_generic_glue(ccx: @mut CrateContext, t: ty::t, llfnty: TypeRef,\n+pub fn declare_generic_glue(ccx: @mut CrateContext, t: ty::t, llfnty: Type,\n                             name: ~str) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n@@ -711,7 +704,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     let rawptr0_arg = fcx.arg_pos(1u);\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let llty = type_of(ccx, t);\n-    let llrawptr0 = PointerCast(bcx, llrawptr0, T_ptr(llty));\n+    let llrawptr0 = PointerCast(bcx, llrawptr0, llty.ptr_to());\n     helper(bcx, llrawptr0, t);\n     finish_fn(fcx, lltop);\n     return llfn;\n@@ -739,7 +732,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n     //let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;\n-    let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n+    let glue_fn_ty = T_generic_glue_fn(ccx).ptr_to();\n     let tyds = &mut ccx.tydescs;\n     for tyds.each_value |&val| {\n         let ti = val;\n@@ -789,8 +782,8 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               }\n             };\n \n-        let shape = C_null(T_ptr(T_i8()));\n-        let shape_tables = C_null(T_ptr(T_i8()));\n+        let shape = C_null(Type::i8p());\n+        let shape_tables = C_null(Type::i8p());\n \n         let tydesc =\n             C_named_struct(ccx.tydesc_type,\n@@ -811,7 +804,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n \n             // Index tydesc by addrspace.\n             if ti.addrspace > gc_box_addrspace {\n-                let llty = T_ptr(ccx.tydesc_type);\n+                let llty = ccx.tydesc_type.ptr_to();\n                 let addrspace_name = fmt!(\"_gc_addrspace_metadata_%u\",\n                                           ti.addrspace as uint);\n                 let addrspace_gvar = str::as_c_str(addrspace_name, |buf| {"}, {"sha": "eb7240419ed6c551b9ee68a5353e3b72d43449e9", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -22,17 +22,17 @@ use util::ppaux::ty_to_str;\n // compute sizeof / alignof\n \n // Returns the number of bytes clobbered by a Store to this type.\n-pub fn llsize_of_store(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n+        return llvm::LLVMStoreSizeOfType(cx.td.lltd, ty.to_ref()) as uint;\n     }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-pub fn llsize_of_alloc(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n+        return llvm::LLVMABISizeOfType(cx.td.lltd, ty.to_ref()) as uint;\n     }\n }\n \n@@ -44,9 +44,9 @@ pub fn llsize_of_alloc(cx: &CrateContext, t: TypeRef) -> uint {\n // that LLVM *does* distinguish between e.g. a 1-bit value and an 8-bit value\n // at the codegen level! In general you should prefer `llbitsize_of_real`\n // below.\n-pub fn llsize_of_real(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n+        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, ty.to_ref()) as uint;\n         if nbits & 7u != 0u {\n             // Not an even number of bytes, spills into \"next\" byte.\n             1u + (nbits >> 3)\n@@ -57,61 +57,61 @@ pub fn llsize_of_real(cx: &CrateContext, t: TypeRef) -> uint {\n }\n \n /// Returns the \"real\" size of the type in bits.\n-pub fn llbitsize_of_real(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint\n+        llvm::LLVMSizeOfTypeInBits(cx.td.lltd, ty.to_ref()) as uint\n     }\n }\n \n /// Returns the size of the type as an LLVM constant integer value.\n-pub fn llsize_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n+pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     // Once upon a time, this called LLVMSizeOf, which does a\n     // getelementptr(1) on a null pointer and casts to an int, in\n     // order to obtain the type size as a value without requiring the\n     // target data layout.  But we have the target data layout, so\n     // there's no need for that contrivance.  The instruction\n     // selection DAG generator would flatten that GEP(1) node into a\n     // constant of the type's alloc size, so let's save it some work.\n-    return C_uint(cx, llsize_of_alloc(cx, t));\n+    return C_uint(cx, llsize_of_alloc(cx, ty));\n }\n \n // Returns the \"default\" size of t (see above), or 1 if the size would\n // be zero.  This is important for things like vectors that expect\n // space to be consumed.\n-pub fn nonzero_llsize_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n-    if llbitsize_of_real(cx, t) == 0 {\n-        unsafe { llvm::LLVMConstInt(cx.int_type, 1, False) }\n+pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n+    if llbitsize_of_real(cx, ty) == 0 {\n+        unsafe { llvm::LLVMConstInt(cx.int_type.to_ref(), 1, False) }\n     } else {\n-        llsize_of(cx, t)\n+        llsize_of(cx, ty)\n     }\n }\n \n // Returns the preferred alignment of the given type for the current target.\n // The preferred alignment may be larger than the alignment used when\n // packing the type into structs. This will be used for things like\n // allocations inside a stack frame, which LLVM has a free hand in.\n-pub fn llalign_of_pref(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n+        return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, ty.to_ref()) as uint;\n     }\n }\n \n // Returns the minimum alignment of a type required by the platform.\n // This is the alignment that will be used for struct fields, arrays,\n // and similar ABI-mandated things.\n-pub fn llalign_of_min(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n+        return llvm::LLVMABIAlignmentOfType(cx.td.lltd, ty.to_ref()) as uint;\n     }\n }\n \n // Returns the \"default\" alignment of t, which is calculated by casting\n // null to a record containing a single-bit followed by a t value, then\n // doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n-pub fn llalign_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n+pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstIntCast(\n-            llvm::LLVMAlignOf(t), cx.int_type, False);\n+            llvm::LLVMAlignOf(ty.to_ref()), cx.int_type.to_ref(), False);\n     }\n }\n \n@@ -142,7 +142,7 @@ pub fn static_size_of_enum(cx: &mut CrateContext, t: ty::t) -> uint {\n                        cx.tcx.sess.str_of(variant.name),\n                        cx.tn.type_to_str(T_struct(lltypes, false)));\n \n-                let this_size = llsize_of_real(cx, T_struct(lltypes, false));\n+                let this_size = llsize_of_real(cx, Type::struct_(lltypes, false));\n                 if max_size < this_size {\n                     max_size = this_size;\n                 }"}, {"sha": "ce240dc2484ee42672d72e220d69d427e03a6053", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -363,7 +363,7 @@ pub fn trans_static_method_callee(bcx: block,\n                                           Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, callee_id);\n-            let llty = T_ptr(type_of_fn_from_ty(ccx, callee_ty));\n+            let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n             FnData {llfn: PointerCast(bcx, lval, llty)}\n         }\n         _ => {\n@@ -463,7 +463,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n \n           // create a llvalue that represents the fn ptr\n           let fn_ty = node_id_type(bcx, callee_id);\n-          let llfn_ty = T_ptr(type_of_fn_from_ty(ccx, fn_ty));\n+          let llfn_ty = type_of_fn_from_ty(ccx, fn_ty).to_ptr();\n           let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n \n           // combine the self environment with the rest\n@@ -628,7 +628,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n                       PointerCast(bcx,\n                                   GEPi(bcx, llpair,\n                                        [0u, abi::trt_field_vtable]),\n-                                  T_ptr(T_ptr(T_vtable()))));\n+                                  Type::vtable().ptr_to().ptr_to()));\n \n     // Load the box from the @Trait pair and GEP over the box header if\n     // necessary:\n@@ -705,7 +705,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     // Plus one in order to skip past the type descriptor.\n     let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + 1]));\n \n-    let mptr = PointerCast(bcx, mptr, T_ptr(llcallee_ty));\n+    let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n         bcx: bcx,\n@@ -814,7 +814,7 @@ pub fn make_impl_vtable(bcx: block,\n         if im.generics.has_type_params() || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    tcx.sess.str_of(im.ident));\n-            C_null(T_ptr(T_nil()))\n+            C_null(Type::nil().ptr_to())\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n                    tcx.sess.str_of(im.ident));\n@@ -857,7 +857,7 @@ pub fn trans_trait_cast(bcx: block,\n     // have no type descriptor field.)\n     llboxdest = PointerCast(bcx,\n                             llboxdest,\n-                            T_ptr(type_of(bcx.ccx(), v_ty)));\n+                            type_of(bcx.ccx(), v_ty).ptr_to());\n     bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n \n     // Store the vtable into the pair or triple.\n@@ -866,7 +866,7 @@ pub fn trans_trait_cast(bcx: block,\n     let vtable = get_vtable(bcx, v_ty, orig);\n     Store(bcx, vtable, PointerCast(bcx,\n                                    GEPi(bcx, lldest, [0u, abi::trt_field_vtable]),\n-                                   T_ptr(val_ty(vtable))));\n+                                   val_ty(vtable).ptr_to()));\n \n     bcx\n }"}, {"sha": "ebf2d888148a36589fb17065135ae032e98dde2e", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use back::link::mangle_internal_name_by_path_and_seq;\n-use lib::llvm::{TypeRef, ValueRef, llvm};\n+use lib::llvm::{Type, ValueRef, llvm};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -37,7 +37,7 @@ pub struct Reflector {\n     visitor_val: ValueRef,\n     visitor_methods: @~[@ty::Method],\n     final_bcx: block,\n-    tydesc_ty: TypeRef,\n+    tydesc_ty: Type,\n     bcx: block\n }\n \n@@ -58,7 +58,7 @@ impl Reflector {\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, false);\n         let len = C_uint(bcx.ccx(), s.len() + 1);\n-        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), T_ptr(T_i8()));\n+        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n         scratch.val\n@@ -76,7 +76,7 @@ impl Reflector {\n         let bcx = self.bcx;\n         let static_ti = get_tydesc(bcx.ccx(), t);\n         glue::lazily_emit_all_tydesc_glue(bcx.ccx(), static_ti);\n-        PointerCast(bcx, static_ti.tydesc, T_ptr(self.tydesc_ty))\n+        PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n     }\n \n     pub fn c_mt(&mut self, mt: &ty::mt) -> ~[ValueRef] {\n@@ -271,7 +271,7 @@ impl Reflector {\n             let ccx = bcx.ccx();\n             let repr = adt::represent_type(bcx.ccx(), t);\n             let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n-            let llptrty = T_ptr(type_of(ccx, t));\n+            let llptrty = type_of(ccx, t).ptr_to();\n             let (_, opaquety) =\n                 ccx.tcx.intrinsic_defs.find_copy(&ccx.sess.ident_of(\"Opaque\"))\n                 .expect(\"Failed to resolve intrinsic::Opaque\");"}, {"sha": "f3554b34806173e78cadc5948260a730c759401f", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -48,23 +48,22 @@ pub fn mk_global(ccx: &CrateContext,\n \n pub fn mk_ctxt(llmod: ModuleRef) -> Ctxt {\n     unsafe {\n-        let llshapetablesty = trans::common::T_named_struct(\"shapes\");\n-        let _llshapetables = str::as_c_str(\"shapes\", |buf| {\n+        let llshapetablesty = Type::named_struct(\"shapes\");\n+        do \"shapes\".as_c_str |buf| {\n             llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n-        });\n+        };\n \n-        return Ctxt {\n+        Ctxt {\n             next_tag_id: 0u16,\n             pad: 0u16,\n             pad2: 0u32\n-        };\n+        }\n     }\n }\n \n /*\n Although these two functions are never called, they are here\n for a VERY GOOD REASON. See #3670\n-*/\n pub fn add_u16(dest: &mut ~[u8], val: u16) {\n     *dest += [(val & 0xffu16) as u8, (val >> 8u16) as u8];\n }\n@@ -73,3 +72,4 @@ pub fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n     add_u16(&mut *dest, src.len() as u16);\n     *dest += src;\n }\n+*/"}, {"sha": "0093386501227bc3ce51223f15719dcac5f11445", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -11,7 +11,7 @@\n \n use back::abi;\n use lib;\n-use lib::llvm::{llvm, ValueRef, TypeRef};\n+use lib::llvm::{llvm, ValueRef};\n use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -73,7 +73,7 @@ pub fn get_dataptr(bcx: block, vptr: ValueRef) -> ValueRef {\n pub fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n-    let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n+    let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n@@ -146,7 +146,7 @@ pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n pub struct VecTypes {\n     vec_ty: ty::t,\n     unit_ty: ty::t,\n-    llunit_ty: TypeRef,\n+    llunit_ty: Type,\n     llunit_size: ValueRef\n }\n \n@@ -227,7 +227,7 @@ pub fn trans_slice_vstore(bcx: block,\n     let fixed_ty = ty::mk_evec(bcx.tcx(),\n                                ty::mt {ty: vt.unit_ty, mutbl: ast::m_mutbl},\n                                ty::vstore_fixed(count));\n-    let llfixed_ty = T_ptr(type_of::type_of(bcx.ccx(), fixed_ty));\n+    let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n     let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n     add_clean(bcx, llfixed_casted, fixed_ty);\n \n@@ -271,13 +271,10 @@ pub fn trans_lit_str(bcx: block,\n                 let bytes = str_lit.len() + 1; // count null-terminator too\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit);\n-                let llcstr = llvm::LLVMConstPointerCast(llcstr,\n-                                                        T_ptr(T_i8()));\n-                Store(bcx,\n-                      llcstr,\n+                let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p().to_ref());\n+                Store(bcx, llcstr,\n                       GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-                Store(bcx,\n-                      llbytes,\n+                Store(bcx, llbytes,\n                       GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n                 bcx\n             }\n@@ -286,9 +283,7 @@ pub fn trans_lit_str(bcx: block,\n }\n \n \n-pub fn trans_uniq_or_managed_vstore(bcx: block,\n-                                    heap: heap,\n-                                    vstore_expr: @ast::expr,\n+pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::expr,\n                                     content_expr: @ast::expr) -> DatumBlock {\n     //!\n     //\n@@ -307,7 +302,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n                     node: ast::lit_str(s), _\n                 }) => {\n                     let llptrval = C_cstr(bcx.ccx(), s);\n-                    let llptrval = PointerCast(bcx, llptrval, T_ptr(T_i8()));\n+                    let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n                     let llsizeval = C_uint(bcx.ccx(), s.len());\n                     let typ = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n                     let lldestval = scratch_datum(bcx, typ, false);"}, {"sha": "9ace4991f1ba335f82c8afa1c92f57a32876b140", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 94, "deletions": 99, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use lib::llvm::llvm;\n-use lib::llvm::{TypeRef};\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::common::*;\n@@ -25,46 +24,50 @@ pub fn arg_is_indirect(_: &CrateContext, arg_ty: &ty::t) -> bool {\n     !ty::type_is_immediate(*arg_ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> TypeRef {\n+pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> Type {\n     let llty = type_of(ccx, *arg_ty);\n-    if arg_is_indirect(ccx, arg_ty) {T_ptr(llty)} else {llty}\n+    if arg_is_indirect(ccx, arg_ty) {\n+        llty.ptr_to()\n+    } else {\n+        llty\n+    }\n }\n \n pub fn type_of_explicit_args(ccx: &mut CrateContext,\n-                             inputs: &[ty::t]) -> ~[TypeRef] {\n+                             inputs: &[ty::t]) -> ~[Type] {\n     inputs.map(|arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t)\n-               -> TypeRef {\n+               -> Type {\n     unsafe {\n-        let mut atys: ~[TypeRef] = ~[];\n+        let mut atys: ~[Type] = ~[];\n \n         // Arg 0: Output pointer.\n         // (if the output type is non-immediate)\n         let output_is_immediate = ty::type_is_immediate(output);\n         let lloutputtype = type_of(cx, output);\n         if !output_is_immediate {\n-            atys.push(T_ptr(lloutputtype));\n+            atys.push(lloutputtype.ptr_to());\n         }\n \n         // Arg 1: Environment\n-        atys.push(T_opaque_box_ptr(cx));\n+        atys.push(Type::opaque_box(cx).ptr_to());\n \n         // ... then explicit args.\n         atys.push_all(type_of_explicit_args(cx, inputs));\n \n         // Use the output as the actual return value if it's immediate.\n         if output_is_immediate && !ty::type_is_nil(output) {\n-            T_fn(atys, lloutputtype)\n+            Type::func(atys, lloutputtype)\n         } else {\n-            T_fn(atys, llvm::LLVMVoidTypeInContext(cx.llcx))\n+            Type::func(atys, Type::void())\n         }\n     }\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> TypeRef {\n+pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n         ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n@@ -74,7 +77,7 @@ pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> TypeRef {\n     }\n }\n \n-pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n+pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> Type {\n     assert!(!ty::type_needs_infer(t));\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n@@ -84,11 +87,11 @@ pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n         match ty::get(t).sty {\n           ty::ty_box(mt) => {\n               let ty = type_of(cx, mt.ty);\n-              T_ptr(T_box(cx, ty))\n+              Type::box(cx, ty).ptr_to()\n           }\n           ty::ty_uniq(mt) => {\n               let ty = type_of(cx, mt.ty);\n-              T_ptr(T_unique(cx, ty))\n+              Type::unique(cx, ty).ptr_to()\n           }\n           _ => {\n             cx.sess.bug(\"non-box in type_of_non_gc_box\");\n@@ -109,18 +112,18 @@ pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n //     recursive types. For example, `static_size_of_enum()` relies on this\n //     behavior.\n \n-pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n-    match cx.llsizingtypes.find(&t) {\n-        Some(t) => return *t,\n+pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n+    match cx.llsizingtypes.find_copy(&t) {\n+        Some(t) => return t,\n         None => ()\n     }\n \n     let llsizingty = match ty::get(t).sty {\n-        ty::ty_nil | ty::ty_bot => T_nil(),\n-        ty::ty_bool => T_bool(),\n-        ty::ty_int(t) => T_int_ty(cx, t),\n-        ty::ty_uint(t) => T_uint_ty(cx, t),\n-        ty::ty_float(t) => T_float_ty(cx, t),\n+        ty::ty_nil | ty::ty_bot => Type::nil(),\n+        ty::ty_bool => Type::bool(),\n+        ty::ty_int(t) => Type::int_from_ty(cx, t),\n+        ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n+        ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n         ty::ty_estr(ty::vstore_uniq) |\n         ty::ty_estr(ty::vstore_box) |\n@@ -132,48 +135,46 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n         ty::ty_ptr(*) |\n         ty::ty_rptr(*) |\n         ty::ty_type |\n-        ty::ty_opaque_closure_ptr(*) => T_ptr(T_i8()),\n+        ty::ty_opaque_closure_ptr(*) => Type::i8p(),\n \n         ty::ty_estr(ty::vstore_slice(*)) |\n         ty::ty_evec(_, ty::vstore_slice(*)) => {\n-            T_struct([T_ptr(T_i8()), T_ptr(T_i8())], false)\n+            Type::struct_([Type::i8p(), Type::i8p()], false)\n         }\n \n-        ty::ty_bare_fn(*) => T_ptr(T_i8()),\n-        ty::ty_closure(*) => T_struct([T_ptr(T_i8()), T_ptr(T_i8())], false),\n-        ty::ty_trait(_, _, store, _) => T_opaque_trait(cx, store),\n+        ty::ty_bare_fn(*) => Type::i8p(),\n+        ty::ty_closure(*) => Type::struct_([Type::i8p(), Type::i8p()], false),\n+        ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n \n-        ty::ty_estr(ty::vstore_fixed(size)) => T_array(T_i8(), size),\n+        ty::ty_estr(ty::vstore_fixed(size)) => Type::array(Type::i8(), size),\n         ty::ty_evec(mt, ty::vstore_fixed(size)) => {\n-            T_array(sizing_type_of(cx, mt.ty), size)\n+            Type::array(sizing_type_of(cx, mt.ty), size)\n         }\n \n         ty::ty_unboxed_vec(mt) => {\n             let sz_ty = sizing_type_of(cx, mt.ty);\n-            T_vec(cx, sz_ty)\n+            Type::vec(cx.sess.targ_cfg.arch, sz_ty)\n         }\n \n         ty::ty_tup(*) | ty::ty_enum(*) => {\n             let repr = adt::represent_type(cx, t);\n-            T_struct(adt::sizing_fields_of(cx, repr), false)\n+            Type::struct_(adt::sizing_fields_of(cx, repr), false)\n         }\n \n         ty::ty_struct(did, _) => {\n             if ty::type_is_simd(cx.tcx, t) {\n                 let et = ty::simd_type(cx.tcx, t);\n                 let n = ty::simd_size(cx.tcx, t);\n-                T_vector(type_of(cx, et), n)\n+                Type::vector(type_of(cx, et), n)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n                 let packed = ty::lookup_packed(cx.tcx, did);\n-                T_struct(adt::sizing_fields_of(cx, repr), packed)\n+                Type::struct_(adt::sizing_fields_of(cx, repr), packed)\n             }\n         }\n \n         ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n-            cx.tcx.sess.bug(\n-                fmt!(\"fictitious type %? in sizing_type_of()\",\n-                     ty::get(t).sty))\n+            cx.tcx.sess.bug(fmt!(\"fictitious type %? in sizing_type_of()\", ty::get(t).sty))\n         }\n     };\n \n@@ -182,7 +183,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n+pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n@@ -205,98 +206,93 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n     }\n \n     let llty = match ty::get(t).sty {\n-      ty::ty_nil | ty::ty_bot => T_nil(),\n-      ty::ty_bool => T_bool(),\n-      ty::ty_int(t) => T_int_ty(cx, t),\n-      ty::ty_uint(t) => T_uint_ty(cx, t),\n-      ty::ty_float(t) => T_float_ty(cx, t),\n+      ty::ty_nil | ty::ty_bot => Type::nil(),\n+      ty::ty_bool => Type::bool(),\n+      ty::ty_int(t) => Type::int_from_ty(cx, t),\n+      ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n+      ty::ty_float(t) => Type::float_from_ty(cx, t),\n       ty::ty_estr(ty::vstore_uniq) => {\n-        T_unique_ptr(T_unique(cx, T_vec(cx, T_i8())))\n+        Type::unique(cx, Type::vec(cx.sess.targ_cfg.arch, Type::i8())).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n         // fill it in *after* placing it into the type cache. This\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n \n-        common::T_named_struct(llvm_type_name(cx,\n-                                              an_enum,\n-                                              did,\n-                                              substs.tps))\n+        Type::named_struct(llvm_type_name(cx, an_enum, did, substs.tps))\n       }\n       ty::ty_estr(ty::vstore_box) => {\n-        T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n+        Type::box(cx, Type::vec(cx, Type::i8())).ptr_to()\n       }\n       ty::ty_evec(ref mt, ty::vstore_box) => {\n           let e_ty = type_of(cx, mt.ty);\n-          let v_ty = T_vec(cx, e_ty);\n-          T_box_ptr(T_box(cx, v_ty))\n+          let v_ty = Type::vec(cx.sess.targ_cfg.arch, e_ty);\n+          Type::box(cx, v_ty).ptr_to()\n       }\n       ty::ty_box(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          T_box_ptr(T_box(cx, ty))\n+          Type::box(cx, ty).ptr_to()\n       }\n-      ty::ty_opaque_box => T_box_ptr(T_box(cx, T_i8())),\n+      ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          T_unique_ptr(T_unique(cx, ty))\n+          Type::unique(cx, ty).ptr_to()\n       }\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n-          let ty = T_vec(cx, ty);\n-          T_unique_ptr(T_unique(cx, ty))\n+          let ty = Type::vec(cx, ty);\n+          Type::unique(cx, ty).ptr_to()\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          T_vec(cx, ty)\n+          Type::vec(cx.sess.targ_cfg.arch, ty)\n       }\n-      ty::ty_ptr(ref mt) => T_ptr(type_of(cx, mt.ty)),\n-      ty::ty_rptr(_, ref mt) => T_ptr(type_of(cx, mt.ty)),\n+      ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n+      ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n \n       ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n-          let p_ty = T_ptr(type_of(cx, mt.ty));\n-          let u_ty = T_uint_ty(cx, ast::ty_u);\n-          T_struct([p_ty, u_ty], false)\n+          let p_ty = type_of(cx, mt.ty).ptr_to();\n+          let u_ty = Type::uint_from_ty(cx, ast::ty_u);\n+          Type::struct_([p_ty, u_ty], false)\n       }\n \n       ty::ty_estr(ty::vstore_slice(_)) => {\n-        T_struct([T_ptr(T_i8()), T_uint_ty(cx, ast::ty_u)], false)\n+          // This means we get a nicer name in the output\n+          cx.tn.find_type(\"str_slice\").get()\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) => {\n-        T_array(T_i8(), n + 1u /* +1 for trailing null */)\n+          Type::array(Type::i8(), n + 1u /* +1 for trailing null */)\n       }\n \n       ty::ty_evec(ref mt, ty::vstore_fixed(n)) => {\n-        T_array(type_of(cx, mt.ty), n)\n+          Type::array(type_of(cx, mt.ty), n)\n       }\n \n-      ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n+      ty::ty_bare_fn(_) => type_of_fn_from_ty(cx, t).ptr_to(),\n       ty::ty_closure(_) => {\n           let ty = type_of_fn_from_ty(cx, t);\n-          T_fn_pair(cx, ty)\n+          Type::func_pair(cx, ty)\n       }\n-      ty::ty_trait(_, _, store, _) => T_opaque_trait(cx, store),\n-      ty::ty_type => T_ptr(cx.tydesc_type),\n+      ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n+      ty::ty_type => cx.tydesc_type.to_ptr(),\n       ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);\n-          T_struct(adt::fields_of(cx, repr), false)\n+          Type::struct_(adt::fields_of(cx, repr), false)\n       }\n-      ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n+      ty::ty_opaque_closure_ptr(_) => Type::opaque_box(cx).ptr_to(),\n       ty::ty_struct(did, ref substs) => {\n-        if ty::type_is_simd(cx.tcx, t) {\n-          let et = ty::simd_type(cx.tcx, t);\n-          let n = ty::simd_size(cx.tcx, t);\n-          T_vector(type_of(cx, et), n)\n-        } else {\n-          // Only create the named struct, but don't fill it in. We fill it\n-          // in *after* placing it into the type cache. This prevents\n-          // infinite recursion with recursive struct types.\n-          T_named_struct(llvm_type_name(cx,\n-                                        a_struct,\n-                                        did,\n-                                        substs.tps))\n-        }\n+          if ty::type_is_simd(cx.tcx, t) {\n+              let et = ty::simd_type(cx.tcx, t);\n+              let n = ty::simd_size(cx.tcx, t);\n+              Type::vector(type_of(cx, et), n)\n+          } else {\n+              // Only create the named struct, but don't fill it in. We fill it\n+              // in *after* placing it into the type cache. This prevents\n+              // infinite recursion with recursive struct types.\n+              Type::named_struct(llvm_type_name(cx, a_struct, did, substs.tps))\n+          }\n       }\n       ty::ty_self(*) => cx.tcx.sess.unimpl(\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(\"type_of with ty_infer\"),\n@@ -336,33 +332,32 @@ pub fn llvm_type_name(cx: &CrateContext,\n                       did: ast::def_id,\n                       tps: &[ty::t]) -> ~str {\n     let name = match what {\n-        a_struct => { \"~struct\" }\n-        an_enum => { \"~enum\" }\n+        a_struct => { \"struct\" }\n+        an_enum => { \"enum\" }\n     };\n-    return fmt!(\n-        \"%s %s[#%d]\",\n-          name,\n-        ppaux::parameterized(\n-            cx.tcx,\n-            ty::item_path_str(cx.tcx, did),\n-            None,\n-            tps),\n-        did.crate\n-    );\n+    let tstr = ppaux::parameterized(cx.tcx, ty::item_path_str(cx.tcx, did), None, tps);\n+    if did.crate == 0 {\n+        fmt!(\"%s.%s\", name, tstr)\n+    } else {\n+        fmt!(\"%s.%s[#%d]\", name, tstr, did.crate)\n+    }\n }\n \n-pub fn type_of_dtor(ccx: &mut CrateContext, self_ty: ty::t) -> TypeRef {\n-    T_fn([T_ptr(type_of(ccx, self_ty))] /* self */, T_void())\n+pub fn type_of_dtor(ccx: &mut CrateContext, self_ty: ty::t) -> Type {\n+    let self_ty = type_of(ccx, self_ty).ptr_to();\n+    Type::func([self_ty], Type::viod())\n }\n \n-pub fn type_of_rooted(ccx: &mut CrateContext, t: ty::t) -> TypeRef {\n+/*\n+pub fn type_of_rooted(ccx: &mut CrateContext, t: ty::t) -> Type {\n     let addrspace = base::get_tydesc(ccx, t).addrspace;\n     debug!(\"type_of_rooted %s in addrspace %u\",\n            ppaux::ty_to_str(ccx.tcx, t), addrspace as uint);\n     return T_root(type_of(ccx, t), addrspace);\n }\n \n-pub fn type_of_glue_fn(ccx: &CrateContext) -> TypeRef {\n+pub fn type_of_glue_fn(ccx: &CrateContext) -> Type {\n     let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n     return T_fn([T_ptr(T_nil()), tydescpp, T_ptr(T_i8())], T_void());\n }\n+*/"}, {"sha": "6b2c6801e589885f3f6064e1b166ad8b8d2fc442", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -67,17 +67,12 @@ pub fn return_to_mut(mut bcx: block,\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n \n-    let box_ptr =\n-        Load(bcx, PointerCast(bcx,\n-                              frozen_val_ref,\n-                              T_ptr(T_ptr(T_i8()))));\n+    let box_ptr = Load(bcx, PointerCast(bcx, frozen_val_ref, Type::i8p().ptr_to()));\n \n-    let bits_val =\n-        Load(bcx, bits_val_ref);\n+    let bits_val = Load(bcx, bits_val_ref);\n \n     if bcx.tcx().sess.debug_borrows() {\n-        bcx = callee::trans_lang_call(\n-            bcx,\n+        bcx = callee::trans_lang_call( bcx,\n             bcx.tcx().lang_items.unrecord_borrow_fn(),\n             [\n                 box_ptr,\n@@ -146,10 +141,7 @@ fn root(datum: &Datum,\n                 DynaMut => bcx.tcx().lang_items.borrow_as_mut_fn(),\n             };\n \n-            let box_ptr = Load(bcx,\n-                               PointerCast(bcx,\n-                                           scratch.val,\n-                                           T_ptr(T_ptr(T_i8()))));\n+            let box_ptr = Load(bcx, PointerCast(bcx, scratch.val, Type::i8p().ptr_to()));\n \n             bcx = callee::trans_lang_call(\n                 bcx,\n@@ -194,6 +186,6 @@ fn perform_write_guard(datum: &Datum,\n     callee::trans_lang_call(\n         bcx,\n         bcx.tcx().lang_items.check_not_borrowed_fn(),\n-        [PointerCast(bcx, llval, T_ptr(T_i8())), filename, line],\n+        [PointerCast(bcx, llval, Type::i8p()), filename, line],\n         expr::Ignore)\n }"}, {"sha": "05833a52be285ca0fbf78184b6e86207762f339f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a75374d63604e88c33a0cb16aaa17ac1442fa1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=57a75374d63604e88c33a0cb16aaa17ac1442fa1", "patch": "@@ -457,9 +457,9 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), \"str\"),\n       ty_opaque_box => ~\"@?\",\n-      ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"closure&\",\n-      ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"closure@\",\n-      ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"closure~\",\n+      ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"&closure\",\n+      ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"@closure\",\n+      ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"~closure\",\n     }\n }\n \n@@ -469,17 +469,17 @@ pub fn parameterized(cx: ctxt,\n                      tps: &[ty::t]) -> ~str {\n \n     let r_str = match self_r {\n-      None => ~\"\",\n-      Some(r) => {\n-        fmt!(\"/%s\", region_to_str(cx, r))\n-      }\n+        None => ~\"\",\n+        Some(r) => {\n+            region_to_str(cx, r)\n+        }\n     };\n \n     if tps.len() > 0u {\n         let strs = vec::map(tps, |t| ty_to_str(cx, *t));\n-        fmt!(\"%s%s<%s>\", base, r_str, strs.connect(\",\"))\n+        fmt!(\"%s%s<%s>\", r_str, base, strs.connect(\",\"))\n     } else {\n-        fmt!(\"%s%s\", base, r_str)\n+        fmt!(\"%s%s\", r_str, base)\n     }\n }\n "}]}