{"sha": "c951882c7364c672fe127f61d25b458e810572ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NTE4ODJjNzM2NGM2NzJmZTEyN2Y2MWQyNWI0NThlODEwNTcyZmY=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-17T07:12:02Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-17T14:38:44Z"}, "message": "Extract ConsoleTestState", "tree": {"sha": "479d251415878a9f6748aa33231d65a139be0faa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/479d251415878a9f6748aa33231d65a139be0faa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c951882c7364c672fe127f61d25b458e810572ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c951882c7364c672fe127f61d25b458e810572ff", "html_url": "https://github.com/rust-lang/rust/commit/c951882c7364c672fe127f61d25b458e810572ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c951882c7364c672fe127f61d25b458e810572ff/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d5052203d200474b1a9aacbb0d59666a576ee16", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d5052203d200474b1a9aacbb0d59666a576ee16", "html_url": "https://github.com/rust-lang/rust/commit/4d5052203d200474b1a9aacbb0d59666a576ee16"}], "stats": {"total": 603, "additions": 317, "deletions": 286}, "files": [{"sha": "851c0389ff377c7b45c8535e8b657ad72e17c814", "filename": "src/libtest/console.rs", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fconsole.rs?ref=c951882c7364c672fe127f61d25b458e810572ff", "patch": "@@ -0,0 +1,288 @@\n+//! Module providing interface for running tests in the console.\n+\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::io;\n+\n+use term;\n+\n+use super::{\n+    helpers::{\n+        concurrency::get_concurrency,\n+        metrics::MetricMap,\n+    },\n+    types::{TestDesc, TestDescAndFn, NamePadding},\n+    options::{Options, OutputFormat},\n+    bench::fmt_bench_samples,\n+    test_result::TestResult,\n+    time::TestExecTime,\n+    cli::TestOpts,\n+    event::TestEvent,\n+    run_tests,\n+    filter_tests,\n+};\n+\n+pub enum OutputLocation<T> {\n+    Pretty(Box<term::StdoutTerminal>),\n+    Raw(T),\n+}\n+\n+impl<T: Write> Write for OutputLocation<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        match *self {\n+            OutputLocation::Pretty(ref mut term) => term.write(buf),\n+            OutputLocation::Raw(ref mut stdout) => stdout.write(buf),\n+        }\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        match *self {\n+            OutputLocation::Pretty(ref mut term) => term.flush(),\n+            OutputLocation::Raw(ref mut stdout) => stdout.flush(),\n+        }\n+    }\n+}\n+\n+use crate::formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n+\n+pub struct ConsoleTestState {\n+    pub log_out: Option<File>,\n+    pub total: usize,\n+    pub passed: usize,\n+    pub failed: usize,\n+    pub ignored: usize,\n+    pub allowed_fail: usize,\n+    pub filtered_out: usize,\n+    pub measured: usize,\n+    pub metrics: MetricMap,\n+    pub failures: Vec<(TestDesc, Vec<u8>)>,\n+    pub not_failures: Vec<(TestDesc, Vec<u8>)>,\n+    pub time_failures: Vec<(TestDesc, Vec<u8>)>,\n+    pub options: Options,\n+}\n+\n+impl ConsoleTestState {\n+    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n+        let log_out = match opts.logfile {\n+            Some(ref path) => Some(File::create(path)?),\n+            None => None,\n+        };\n+\n+        Ok(ConsoleTestState {\n+            log_out,\n+            total: 0,\n+            passed: 0,\n+            failed: 0,\n+            ignored: 0,\n+            allowed_fail: 0,\n+            filtered_out: 0,\n+            measured: 0,\n+            metrics: MetricMap::new(),\n+            failures: Vec::new(),\n+            not_failures: Vec::new(),\n+            time_failures: Vec::new(),\n+            options: opts.options,\n+        })\n+    }\n+\n+    pub fn write_log<F, S>(\n+        &mut self,\n+        msg: F,\n+    ) -> io::Result<()>\n+    where\n+        S: AsRef<str>,\n+        F: FnOnce() -> S,\n+    {\n+        match self.log_out {\n+            None => Ok(()),\n+            Some(ref mut o) => {\n+                let msg = msg();\n+                let msg = msg.as_ref();\n+                o.write_all(msg.as_bytes())\n+            },\n+        }\n+    }\n+\n+    pub fn write_log_result(&mut self,test: &TestDesc,\n+        result: &TestResult,\n+        exec_time: Option<&TestExecTime>,\n+    ) -> io::Result<()> {\n+        self.write_log(|| format!(\n+            \"{} {}\",\n+            match *result {\n+                TestResult::TrOk => \"ok\".to_owned(),\n+                TestResult::TrFailed => \"failed\".to_owned(),\n+                TestResult::TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n+                TestResult::TrIgnored => \"ignored\".to_owned(),\n+                TestResult::TrAllowedFail => \"failed (allowed)\".to_owned(),\n+                TestResult::TrBench(ref bs) => fmt_bench_samples(bs),\n+                TestResult::TrTimedFail => \"failed (time limit exceeded)\".to_owned(),\n+            },\n+            test.name,\n+        ))?;\n+        if let Some(exec_time) = exec_time {\n+            self.write_log(|| format!(\" <{}>\", exec_time))?;\n+        }\n+        self.write_log(|| \"\\n\")\n+    }\n+\n+    fn current_test_count(&self) -> usize {\n+        self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n+    }\n+}\n+\n+// List the tests to console, and optionally to logfile. Filters are honored.\n+pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n+    let mut output = match term::stdout() {\n+        None => OutputLocation::Raw(io::stdout()),\n+        Some(t) => OutputLocation::Pretty(t),\n+    };\n+\n+    let quiet = opts.format == OutputFormat::Terse;\n+    let mut st = ConsoleTestState::new(opts)?;\n+\n+    let mut ntest = 0;\n+    let mut nbench = 0;\n+\n+    for test in filter_tests(&opts, tests) {\n+        use crate::TestFn::*;\n+\n+        let TestDescAndFn {\n+            desc: TestDesc { name, .. },\n+            testfn,\n+        } = test;\n+\n+        let fntype = match testfn {\n+            StaticTestFn(..) | DynTestFn(..) => {\n+                ntest += 1;\n+                \"test\"\n+            }\n+            StaticBenchFn(..) | DynBenchFn(..) => {\n+                nbench += 1;\n+                \"benchmark\"\n+            }\n+        };\n+\n+        writeln!(output, \"{}: {}\", name, fntype)?;\n+        st.write_log(|| format!(\"{} {}\\n\", fntype, name))?;\n+    }\n+\n+    fn plural(count: u32, s: &str) -> String {\n+        match count {\n+            1 => format!(\"{} {}\", 1, s),\n+            n => format!(\"{} {}s\", n, s),\n+        }\n+    }\n+\n+    if !quiet {\n+        if ntest != 0 || nbench != 0 {\n+            writeln!(output, \"\")?;\n+        }\n+\n+        writeln!(\n+            output,\n+            \"{}, {}\",\n+            plural(ntest, \"test\"),\n+            plural(nbench, \"benchmark\")\n+        )?;\n+    }\n+\n+    Ok(())\n+}\n+\n+// A simple console test runner\n+pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n+    fn callback(\n+        event: &TestEvent,\n+        st: &mut ConsoleTestState,\n+        out: &mut dyn OutputFormatter,\n+    ) -> io::Result<()> {\n+        match (*event).clone() {\n+            TestEvent::TeFiltered(ref filtered_tests) => {\n+                st.total = filtered_tests.len();\n+                out.write_run_start(filtered_tests.len())\n+            }\n+            TestEvent::TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n+            TestEvent::TeWait(ref test) => out.write_test_start(test),\n+            TestEvent::TeTimeout(ref test) => out.write_timeout(test),\n+            TestEvent::TeResult(test, result, exec_time, stdout) => {\n+                st.write_log_result(&test, &result, exec_time.as_ref())?;\n+                out.write_result(&test, &result, exec_time.as_ref(), &*stdout, &st)?;\n+                match result {\n+                    TestResult::TrOk => {\n+                        st.passed += 1;\n+                        st.not_failures.push((test, stdout));\n+                    }\n+                    TestResult::TrIgnored => st.ignored += 1,\n+                    TestResult::TrAllowedFail => st.allowed_fail += 1,\n+                    TestResult::TrBench(bs) => {\n+                        st.metrics.insert_metric(\n+                            test.name.as_slice(),\n+                            bs.ns_iter_summ.median,\n+                            bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n+                        );\n+                        st.measured += 1\n+                    }\n+                    TestResult::TrFailed => {\n+                        st.failed += 1;\n+                        st.failures.push((test, stdout));\n+                    }\n+                    TestResult::TrFailedMsg(msg) => {\n+                        st.failed += 1;\n+                        let mut stdout = stdout;\n+                        stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n+                        st.failures.push((test, stdout));\n+                    }\n+                    TestResult::TrTimedFail => {\n+                        st.failed += 1;\n+                        st.time_failures.push((test, stdout));\n+                    }\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    let output = match term::stdout() {\n+        None => OutputLocation::Raw(io::stdout()),\n+        Some(t) => OutputLocation::Pretty(t),\n+    };\n+\n+    let max_name_len = tests\n+        .iter()\n+        .max_by_key(|t| len_if_padded(*t))\n+        .map(|t| t.desc.name.as_slice().len())\n+        .unwrap_or(0);\n+\n+    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n+\n+    let mut out: Box<dyn OutputFormatter> = match opts.format {\n+        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n+            output,\n+            opts.use_color(),\n+            max_name_len,\n+            is_multithreaded,\n+            opts.time_options,\n+        )),\n+        OutputFormat::Terse => Box::new(TerseFormatter::new(\n+            output,\n+            opts.use_color(),\n+            max_name_len,\n+            is_multithreaded,\n+        )),\n+        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n+    };\n+    let mut st = ConsoleTestState::new(opts)?;\n+    fn len_if_padded(t: &TestDescAndFn) -> usize {\n+        match t.testfn.padding() {\n+            NamePadding::PadNone => 0,\n+            NamePadding::PadOnRight => t.desc.name.as_slice().len(),\n+        }\n+    }\n+\n+    run_tests(opts, tests, |x| callback(&x, &mut st, &mut *out))?;\n+\n+    assert!(st.current_test_count() == st.total);\n+\n+    return out.write_run_finish(&st);\n+}"}, {"sha": "b84551826c691d6204fccf5f5144fbf603896d7a", "filename": "src/libtest/event.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fevent.rs?ref=c951882c7364c672fe127f61d25b458e810572ff", "patch": "@@ -0,0 +1,15 @@\n+//! Module containing different events that can occur\n+//! during tests execution process.\n+\n+use super::types::TestDesc;\n+use super::test_result::TestResult;\n+use super::time::TestExecTime;\n+\n+#[derive(Clone)]\n+pub enum TestEvent {\n+    TeFiltered(Vec<TestDesc>),\n+    TeWait(TestDesc),\n+    TeResult(TestDesc, TestResult, Option<TestExecTime>, Vec<u8>),\n+    TeTimeout(TestDesc),\n+    TeFilteredOut(usize),\n+}"}, {"sha": "41a293195cc815a794a0bf8519d97ac6d06b4342", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=c951882c7364c672fe127f61d25b458e810572ff", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use super::console::{ConsoleTestState, OutputLocation};\n \n pub(crate) struct JsonFormatter<T> {\n     out: OutputLocation<T>,"}, {"sha": "4f3ffdafe3fbf30a8aaa64cf4698d7bb9f5e8c24", "filename": "src/libtest/formatters/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=c951882c7364c672fe127f61d25b458e810572ff", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use super::console::ConsoleTestState;\n \n mod pretty;\n mod json;"}, {"sha": "6f2c56bdf45e0b345199ccdfc8234f50eb21a79d", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=c951882c7364c672fe127f61d25b458e810572ff", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use super::console::{ConsoleTestState, OutputLocation};\n \n pub(crate) struct PrettyFormatter<T> {\n     out: OutputLocation<T>,\n@@ -67,7 +68,7 @@ impl<T: Write> PrettyFormatter<T> {\n \n     pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n         match self.out {\n-            Pretty(ref mut term) => {\n+            OutputLocation::Pretty(ref mut term) => {\n                 if self.use_color {\n                     term.fg(color)?;\n                 }\n@@ -77,7 +78,7 @@ impl<T: Write> PrettyFormatter<T> {\n                 }\n                 term.flush()\n             }\n-            Raw(ref mut stdout) => {\n+            OutputLocation::Raw(ref mut stdout) => {\n                 stdout.write_all(word.as_bytes())?;\n                 stdout.flush()\n             }"}, {"sha": "96203d5ea42794766ae35d80617f974e2fcf4345", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=c951882c7364c672fe127f61d25b458e810572ff", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use super::console::{ConsoleTestState, OutputLocation};\n \n pub(crate) struct TerseFormatter<T> {\n     out: OutputLocation<T>,\n@@ -68,7 +69,7 @@ impl<T: Write> TerseFormatter<T> {\n \n     pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n         match self.out {\n-            Pretty(ref mut term) => {\n+            OutputLocation::Pretty(ref mut term) => {\n                 if self.use_color {\n                     term.fg(color)?;\n                 }\n@@ -78,7 +79,7 @@ impl<T: Write> TerseFormatter<T> {\n                 }\n                 term.flush()\n             }\n-            Raw(ref mut stdout) => {\n+            OutputLocation::Raw(ref mut stdout) => {\n                 stdout.write_all(word.as_bytes())?;\n                 stdout.flush()\n             }"}, {"sha": "6221140f60698150ff270b230774e2a01beb1479", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 282, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c951882c7364c672fe127f61d25b458e810572ff/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c951882c7364c672fe127f61d25b458e810572ff", "patch": "@@ -30,16 +30,12 @@\n #![feature(termination_trait_lib)]\n #![feature(test)]\n \n-use term;\n-\n pub use self::ColorConfig::*;\n-use self::OutputLocation::*;\n-use self::TestEvent::*;\n+use self::event::TestEvent::*;\n pub use self::types::TestName::*;\n \n use std::borrow::Cow;\n use std::env;\n-use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n use std::panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo};\n@@ -79,23 +75,23 @@ use test_result::*;\n use types::*;\n use options::*;\n use cli::*;\n+use event::*;\n \n use helpers::concurrency::get_concurrency;\n-use helpers::metrics::MetricMap;\n \n mod formatters;\n pub mod stats;\n \n mod cli;\n+mod console;\n+mod event;\n mod helpers;\n mod time;\n mod types;\n mod options;\n mod bench;\n mod test_result;\n \n-use crate::formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n-\n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Options>) {\n@@ -111,12 +107,12 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n         opts.options = options;\n     }\n     if opts.list {\n-        if let Err(e) = list_tests_console(&opts, tests) {\n+        if let Err(e) = console::list_tests_console(&opts, tests) {\n             eprintln!(\"error: io error when listing tests: {:?}\", e);\n             process::exit(101);\n         }\n     } else {\n-        match run_tests_console(&opts, tests) {\n+        match console::run_tests_console(&opts, tests) {\n             Ok(true) => {}\n             Ok(false) => process::exit(101),\n             Err(e) => {\n@@ -200,278 +196,6 @@ pub fn assert_test_result<T: Termination>(result: T) {\n     );\n }\n \n-enum OutputLocation<T> {\n-    Pretty(Box<term::StdoutTerminal>),\n-    Raw(T),\n-}\n-\n-impl<T: Write> Write for OutputLocation<T> {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        match *self {\n-            Pretty(ref mut term) => term.write(buf),\n-            Raw(ref mut stdout) => stdout.write(buf),\n-        }\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        match *self {\n-            Pretty(ref mut term) => term.flush(),\n-            Raw(ref mut stdout) => stdout.flush(),\n-        }\n-    }\n-}\n-\n-struct ConsoleTestState {\n-    log_out: Option<File>,\n-    total: usize,\n-    passed: usize,\n-    failed: usize,\n-    ignored: usize,\n-    allowed_fail: usize,\n-    filtered_out: usize,\n-    measured: usize,\n-    metrics: MetricMap,\n-    failures: Vec<(TestDesc, Vec<u8>)>,\n-    not_failures: Vec<(TestDesc, Vec<u8>)>,\n-    time_failures: Vec<(TestDesc, Vec<u8>)>,\n-    options: Options,\n-}\n-\n-impl ConsoleTestState {\n-    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n-        let log_out = match opts.logfile {\n-            Some(ref path) => Some(File::create(path)?),\n-            None => None,\n-        };\n-\n-        Ok(ConsoleTestState {\n-            log_out,\n-            total: 0,\n-            passed: 0,\n-            failed: 0,\n-            ignored: 0,\n-            allowed_fail: 0,\n-            filtered_out: 0,\n-            measured: 0,\n-            metrics: MetricMap::new(),\n-            failures: Vec::new(),\n-            not_failures: Vec::new(),\n-            time_failures: Vec::new(),\n-            options: opts.options,\n-        })\n-    }\n-\n-    pub fn write_log<F, S>(\n-        &mut self,\n-        msg: F,\n-    ) -> io::Result<()>\n-    where\n-        S: AsRef<str>,\n-        F: FnOnce() -> S,\n-    {\n-        match self.log_out {\n-            None => Ok(()),\n-            Some(ref mut o) => {\n-                let msg = msg();\n-                let msg = msg.as_ref();\n-                o.write_all(msg.as_bytes())\n-            },\n-        }\n-    }\n-\n-    pub fn write_log_result(&mut self,test: &TestDesc,\n-        result: &TestResult,\n-        exec_time: Option<&time::TestExecTime>,\n-    ) -> io::Result<()> {\n-        self.write_log(|| format!(\n-            \"{} {}\",\n-            match *result {\n-                TrOk => \"ok\".to_owned(),\n-                TrFailed => \"failed\".to_owned(),\n-                TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n-                TrIgnored => \"ignored\".to_owned(),\n-                TrAllowedFail => \"failed (allowed)\".to_owned(),\n-                TrBench(ref bs) => fmt_bench_samples(bs),\n-                TrTimedFail => \"failed (time limit exceeded)\".to_owned(),\n-            },\n-            test.name,\n-        ))?;\n-        if let Some(exec_time) = exec_time {\n-            self.write_log(|| format!(\" <{}>\", exec_time))?;\n-        }\n-        self.write_log(|| \"\\n\")\n-    }\n-\n-    fn current_test_count(&self) -> usize {\n-        self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n-    }\n-}\n-\n-// List the tests to console, and optionally to logfile. Filters are honored.\n-pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n-    let mut output = match term::stdout() {\n-        None => Raw(io::stdout()),\n-        Some(t) => Pretty(t),\n-    };\n-\n-    let quiet = opts.format == OutputFormat::Terse;\n-    let mut st = ConsoleTestState::new(opts)?;\n-\n-    let mut ntest = 0;\n-    let mut nbench = 0;\n-\n-    for test in filter_tests(&opts, tests) {\n-        use crate::TestFn::*;\n-\n-        let TestDescAndFn {\n-            desc: TestDesc { name, .. },\n-            testfn,\n-        } = test;\n-\n-        let fntype = match testfn {\n-            StaticTestFn(..) | DynTestFn(..) => {\n-                ntest += 1;\n-                \"test\"\n-            }\n-            StaticBenchFn(..) | DynBenchFn(..) => {\n-                nbench += 1;\n-                \"benchmark\"\n-            }\n-        };\n-\n-        writeln!(output, \"{}: {}\", name, fntype)?;\n-        st.write_log(|| format!(\"{} {}\\n\", fntype, name))?;\n-    }\n-\n-    fn plural(count: u32, s: &str) -> String {\n-        match count {\n-            1 => format!(\"{} {}\", 1, s),\n-            n => format!(\"{} {}s\", n, s),\n-        }\n-    }\n-\n-    if !quiet {\n-        if ntest != 0 || nbench != 0 {\n-            writeln!(output, \"\")?;\n-        }\n-\n-        writeln!(\n-            output,\n-            \"{}, {}\",\n-            plural(ntest, \"test\"),\n-            plural(nbench, \"benchmark\")\n-        )?;\n-    }\n-\n-    Ok(())\n-}\n-\n-// A simple console test runner\n-pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n-    fn callback(\n-        event: &TestEvent,\n-        st: &mut ConsoleTestState,\n-        out: &mut dyn OutputFormatter,\n-    ) -> io::Result<()> {\n-        match (*event).clone() {\n-            TeFiltered(ref filtered_tests) => {\n-                st.total = filtered_tests.len();\n-                out.write_run_start(filtered_tests.len())\n-            }\n-            TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n-            TeWait(ref test) => out.write_test_start(test),\n-            TeTimeout(ref test) => out.write_timeout(test),\n-            TeResult(test, result, exec_time, stdout) => {\n-                st.write_log_result(&test, &result, exec_time.as_ref())?;\n-                out.write_result(&test, &result, exec_time.as_ref(), &*stdout, &st)?;\n-                match result {\n-                    TrOk => {\n-                        st.passed += 1;\n-                        st.not_failures.push((test, stdout));\n-                    }\n-                    TrIgnored => st.ignored += 1,\n-                    TrAllowedFail => st.allowed_fail += 1,\n-                    TrBench(bs) => {\n-                        st.metrics.insert_metric(\n-                            test.name.as_slice(),\n-                            bs.ns_iter_summ.median,\n-                            bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n-                        );\n-                        st.measured += 1\n-                    }\n-                    TrFailed => {\n-                        st.failed += 1;\n-                        st.failures.push((test, stdout));\n-                    }\n-                    TrFailedMsg(msg) => {\n-                        st.failed += 1;\n-                        let mut stdout = stdout;\n-                        stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n-                        st.failures.push((test, stdout));\n-                    }\n-                    TrTimedFail => {\n-                        st.failed += 1;\n-                        st.time_failures.push((test, stdout));\n-                    }\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    let output = match term::stdout() {\n-        None => Raw(io::stdout()),\n-        Some(t) => Pretty(t),\n-    };\n-\n-    let max_name_len = tests\n-        .iter()\n-        .max_by_key(|t| len_if_padded(*t))\n-        .map(|t| t.desc.name.as_slice().len())\n-        .unwrap_or(0);\n-\n-    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n-\n-    let mut out: Box<dyn OutputFormatter> = match opts.format {\n-        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n-            output,\n-            opts.use_color(),\n-            max_name_len,\n-            is_multithreaded,\n-            opts.time_options,\n-        )),\n-        OutputFormat::Terse => Box::new(TerseFormatter::new(\n-            output,\n-            opts.use_color(),\n-            max_name_len,\n-            is_multithreaded,\n-        )),\n-        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n-    };\n-    let mut st = ConsoleTestState::new(opts)?;\n-    fn len_if_padded(t: &TestDescAndFn) -> usize {\n-        match t.testfn.padding() {\n-            PadNone => 0,\n-            PadOnRight => t.desc.name.as_slice().len(),\n-        }\n-    }\n-\n-    run_tests(opts, tests, |x| callback(&x, &mut st, &mut *out))?;\n-\n-    assert!(st.current_test_count() == st.total);\n-\n-    return out.write_run_finish(&st);\n-}\n-\n-#[derive(Clone)]\n-pub enum TestEvent {\n-    TeFiltered(Vec<TestDesc>),\n-    TeWait(TestDesc),\n-    TeResult(TestDesc, TestResult, Option<time::TestExecTime>, Vec<u8>),\n-    TeTimeout(TestDesc),\n-    TeFilteredOut(usize),\n-}\n-\n pub type MonitorMsg = (TestDesc, TestResult, Option<time::TestExecTime>, Vec<u8>);\n \n struct Sink(Arc<Mutex<Vec<u8>>>);"}]}