{"sha": "145f66fdf06b5e975910cf887879d575be6af672", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NWY2NmZkZjA2YjVlOTc1OTEwY2Y4ODc4NzlkNTc1YmU2YWY2NzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-28T19:40:57Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-28T19:40:57Z"}, "message": "Register snapshots", "tree": {"sha": "45afb357dee983b40a900d84d9e4019b0e7c411c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45afb357dee983b40a900d84d9e4019b0e7c411c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/145f66fdf06b5e975910cf887879d575be6af672", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/145f66fdf06b5e975910cf887879d575be6af672", "html_url": "https://github.com/rust-lang/rust/commit/145f66fdf06b5e975910cf887879d575be6af672", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/145f66fdf06b5e975910cf887879d575be6af672/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09dc38eda54537c0c10b8a89852c714e3e14f57a", "url": "https://api.github.com/repos/rust-lang/rust/commits/09dc38eda54537c0c10b8a89852c714e3e14f57a", "html_url": "https://github.com/rust-lang/rust/commit/09dc38eda54537c0c10b8a89852c714e3e14f57a"}], "stats": {"total": 197, "additions": 8, "deletions": 189}, "files": [{"sha": "d9fd6d87b726f35298a9081638ff48d9e27e3084", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/145f66fdf06b5e975910cf887879d575be6af672/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145f66fdf06b5e975910cf887879d575be6af672/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=145f66fdf06b5e975910cf887879d575be6af672", "patch": "@@ -470,9 +470,6 @@ pub mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it this way, I think.\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n #[doc(hidden)]\n pub mod rt {\n     use float;\n@@ -676,192 +673,6 @@ pub mod rt {\n     }\n }\n \n-// XXX: remove after a snapshot of the above changes have gone in\n-#[cfg(stage0)]\n-#[doc(hidden)]\n-pub mod rt {\n-    use float;\n-    use str;\n-    use sys;\n-    use uint;\n-    use vec;\n-\n-    pub static flag_none : u32 = 0u32;\n-    pub static flag_left_justify   : u32 = 0b00000000000001u32;\n-    pub static flag_left_zero_pad  : u32 = 0b00000000000010u32;\n-    pub static flag_space_for_sign : u32 = 0b00000000000100u32;\n-    pub static flag_sign_always    : u32 = 0b00000000001000u32;\n-    pub static flag_alternate      : u32 = 0b00000000010000u32;\n-\n-    pub enum Count { CountIs(uint), CountImplied, }\n-\n-    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n-\n-    pub struct Conv {\n-        flags: u32,\n-        width: Count,\n-        precision: Count,\n-        ty: Ty,\n-    }\n-\n-    pub fn conv_int(cv: Conv, i: int) -> ~str {\n-        let radix = 10;\n-        let prec = get_int_precision(cv);\n-        let mut s : ~str = int_to_str_prec(i, radix, prec);\n-        if 0 <= i {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                unsafe { str::unshift_char(&mut s, '+') };\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                unsafe { str::unshift_char(&mut s, ' ') };\n-            }\n-        }\n-        return unsafe { pad(cv, s, PadSigned) };\n-    }\n-    pub fn conv_uint(cv: Conv, u: uint) -> ~str {\n-        let prec = get_int_precision(cv);\n-        let mut rs =\n-            match cv.ty {\n-              TyDefault => uint_to_str_prec(u, 10, prec),\n-              TyHexLower => uint_to_str_prec(u, 16, prec),\n-              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16, prec)),\n-              TyBits => uint_to_str_prec(u, 2, prec),\n-              TyOctal => uint_to_str_prec(u, 8, prec)\n-            };\n-        return unsafe { pad(cv, rs, PadUnsigned) };\n-    }\n-    pub fn conv_bool(cv: Conv, b: bool) -> ~str {\n-        let s = if b { ~\"true\" } else { ~\"false\" };\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-        return conv_str(cv, s);\n-    }\n-    pub fn conv_char(cv: Conv, c: char) -> ~str {\n-        let mut s = str::from_char(c);\n-        return unsafe { pad(cv, s, PadNozero) };\n-    }\n-    pub fn conv_str(cv: Conv, s: &str) -> ~str {\n-        // For strings, precision is the maximum characters\n-        // displayed\n-        let mut unpadded = match cv.precision {\n-          CountImplied => s.to_owned(),\n-          CountIs(max) => if (max as uint) < str::char_len(s) {\n-            str::substr(s, 0, max as uint).to_owned()\n-          } else {\n-            s.to_owned()\n-          }\n-        };\n-        return unsafe { pad(cv, unpadded, PadNozero) };\n-    }\n-    pub fn conv_float(cv: Conv, f: float) -> ~str {\n-        let (to_str, digits) = match cv.precision {\n-              CountIs(c) => (float::to_str_exact, c as uint),\n-              CountImplied => (float::to_str_digits, 6u)\n-        };\n-        let mut s = unsafe { to_str(f, digits) };\n-        if 0.0 <= f {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                s = ~\"+\" + s;\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = ~\" \" + s;\n-            }\n-        }\n-        return unsafe { pad(cv, s, PadFloat) };\n-    }\n-    pub fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n-        let s = sys::log_str(v);\n-        return conv_str(cv, s);\n-    }\n-\n-    // Convert an int to string with minimum number of digits. If precision is\n-    // 0 and num is 0 then the result is the empty string.\n-    pub fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n-        return if num < 0 {\n-                ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n-            } else { uint_to_str_prec(num as uint, radix, prec) };\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to uint: but it doesn't seem all that useful.\n-    pub fn uint_to_str_prec(num: uint, radix: uint,\n-                                 prec: uint) -> ~str {\n-        return if prec == 0u && num == 0u {\n-                ~\"\"\n-            } else {\n-                let s = uint::to_str_radix(num, radix);\n-                let len = str::char_len(s);\n-                if len < prec {\n-                    let diff = prec - len;\n-                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n-                    pad + s\n-                } else { s }\n-            };\n-    }\n-    pub fn get_int_precision(cv: Conv) -> uint {\n-        return match cv.precision {\n-              CountIs(c) => c as uint,\n-              CountImplied => 1u\n-            };\n-    }\n-\n-    #[deriving(Eq)]\n-    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n-\n-    pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n-        let mut s = s; // sadtimes\n-        let uwidth : uint = match cv.width {\n-          CountImplied => return (s),\n-          CountIs(width) => { width as uint }\n-        };\n-        let strlen = str::char_len(s);\n-        if uwidth <= strlen { return (s); }\n-        let mut padchar = ' ';\n-        let diff = uwidth - strlen;\n-        if have_flag(cv.flags, flag_left_justify) {\n-            let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-            return s + padstr;\n-        }\n-        let (might_zero_pad, signed) = match mode {\n-          PadNozero   => (false, true),\n-          PadSigned   => (true, true),\n-          PadFloat    => (true, true),\n-          PadUnsigned => (true, false)\n-        };\n-        fn have_precision(cv: Conv) -> bool {\n-            return match cv.precision { CountImplied => false, _ => true };\n-        }\n-        let zero_padding = {\n-            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-                (!have_precision(cv) || mode == PadFloat) {\n-                padchar = '0';\n-                true\n-            } else {\n-                false\n-            }\n-        };\n-        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-\n-        if signed && zero_padding && s.len() > 0 {\n-            let head = str::shift_char(&mut s);\n-            if head == '+' || head == '-' || head == ' ' {\n-                let headstr = str::from_chars(vec::from_elem(1u, head));\n-                return headstr + padstr + s;\n-            }\n-            else {\n-                str::unshift_char(&mut s, head);\n-            }\n-        }\n-        return padstr + s;\n-    }\n-    pub fn have_flag(flags: u32, f: u32) -> bool {\n-        flags & f != 0\n-    }\n-}\n-\n // Bulk of the tests are in src/test/run-pass/syntax-extension-fmt.rs\n #[cfg(test)]\n mod test {"}, {"sha": "c3f8c8b1e632b5dd0fb1d978f77e5b0f4bb1105e", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/145f66fdf06b5e975910cf887879d575be6af672/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/145f66fdf06b5e975910cf887879d575be6af672/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=145f66fdf06b5e975910cf887879d575be6af672", "patch": "@@ -1,3 +1,11 @@\n+S 2013-03-27 8c15409\n+  macos-x86_64 05eb3801b60056d95715c891d00c5d372e34d00c\n+  macos-i386 4119e3fa614fa86adf60ed0183d00db3ce6d0dbc\n+  linux-x86_64 e9308bade0e068bca4abe59ef4afe8c8bb7c134d\n+  linux-i386 bcb30ed1817df1a07588cde2fb0ccaf9ffad7efb\n+  winnt-i386 a16d409465e125bc6f779b45821ae1ea276c6bd4\n+  freebsd-x86_64 348192f348f03541549f4e2c97af78901d59ca6e\n+\n S 2013-03-21 ed25a67\n   freebsd-x86_64 5f0b08839ae3d1207808f0d57cbfdb00eff9c883\n   linux-i386 54765a17c6b6d04a7013cada2a51d190462979b8"}]}