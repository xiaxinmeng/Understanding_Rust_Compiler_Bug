{"sha": "41902f2859e8c23a8b903c187bd20ba780a78c31", "node_id": "C_kwDOAAsO6NoAKDQxOTAyZjI4NTllOGMyM2E4YjkwM2MxODdiZDIwYmE3ODBhNzhjMzE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-14T18:28:56Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-31T11:47:02Z"}, "message": "Implement with_parent_item_lifetime_defs on ItemLowerer.", "tree": {"sha": "52bd50913cf896ba2bfdb1860ea14fcc7b4d95d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52bd50913cf896ba2bfdb1860ea14fcc7b4d95d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41902f2859e8c23a8b903c187bd20ba780a78c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41902f2859e8c23a8b903c187bd20ba780a78c31", "html_url": "https://github.com/rust-lang/rust/commit/41902f2859e8c23a8b903c187bd20ba780a78c31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41902f2859e8c23a8b903c187bd20ba780a78c31/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc8b6b4be4a7123ad700a95afa469c88d6ce97eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc8b6b4be4a7123ad700a95afa469c88d6ce97eb", "html_url": "https://github.com/rust-lang/rust/commit/dc8b6b4be4a7123ad700a95afa469c88d6ce97eb"}], "stats": {"total": 132, "additions": 62, "deletions": 70}, "files": [{"sha": "ad22418eb7dec5ada63053e6e6e3b9c3f22e9b44", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 62, "deletions": 70, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/41902f2859e8c23a8b903c187bd20ba780a78c31/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41902f2859e8c23a8b903c187bd20ba780a78c31/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=41902f2859e8c23a8b903c187bd20ba780a78c31", "patch": "@@ -46,11 +46,59 @@ fn add_ty_alias_where_clause(\n }\n \n impl ItemLowerer<'_, '_, '_> {\n-    fn with_trait_impl_ref<T>(\n+    /// Clears (and restores) the `in_scope_lifetimes` field. Used when\n+    /// visiting nested items, which never inherit in-scope lifetimes\n+    /// from their surrounding environment.\n+    #[tracing::instrument(level = \"debug\", skip(self, f))]\n+    fn without_in_scope_lifetime_defs<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n+        let old_in_scope_lifetimes = mem::take(&mut self.lctx.in_scope_lifetimes);\n+        debug!(?old_in_scope_lifetimes);\n+\n+        // this vector is only used when walking over impl headers,\n+        // input types, and the like, and should not be non-empty in\n+        // between items\n+        assert!(self.lctx.lifetimes_to_define.is_empty());\n+\n+        let res = f(self);\n+\n+        assert!(self.lctx.in_scope_lifetimes.is_empty());\n+        self.lctx.in_scope_lifetimes = old_in_scope_lifetimes;\n+\n+        res\n+    }\n+\n+    /// Evaluates `f` with the lifetimes in `params` in-scope.\n+    /// This is used to track which lifetimes have already been defined, and\n+    /// which are new in-band lifetimes that need to have a definition created\n+    /// for them.\n+    fn with_parent_item_lifetime_defs(\n         &mut self,\n-        impl_ref: &Option<TraitRef>,\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> T {\n+        parent_item: LocalDefId,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        let parent_hir = self.lctx.owners[parent_item].unwrap().node().expect_item();\n+        let parent_generics = match parent_hir.kind {\n+            hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n+            _ => &[],\n+        };\n+        let lt_def_names = parent_generics\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                hir::GenericParamKind::Lifetime { .. } => {\n+                    Some(param.name.normalize_to_macros_2_0())\n+                }\n+                _ => None,\n+            })\n+            .collect();\n+        let old_in_scope_lifetimes = mem::replace(&mut self.lctx.in_scope_lifetimes, lt_def_names);\n+\n+        f(self);\n+\n+        self.lctx.in_scope_lifetimes = old_in_scope_lifetimes;\n+    }\n+\n+    fn with_trait_impl_ref(&mut self, impl_ref: &Option<TraitRef>, f: impl FnOnce(&mut Self)) {\n         let old = self.lctx.is_in_trait_impl;\n         self.lctx.is_in_trait_impl = impl_ref.is_some();\n         let ret = f(self);\n@@ -66,20 +114,19 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        let hir_id = self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            let node = lctx.without_in_scope_lifetime_defs(|lctx| lctx.lower_item(item));\n-            hir::OwnerNode::Item(node)\n+        let hir_id = self.without_in_scope_lifetime_defs(|this| {\n+            this.lctx.with_hir_id_owner(item.id, |lctx| {\n+                let node = lctx.lower_item(item);\n+                hir::OwnerNode::Item(node)\n+            })\n         });\n \n-        self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n-            let this = &mut ItemLowerer { lctx: this };\n-            match item.kind {\n-                ItemKind::Impl(box Impl { ref of_trait, .. }) => {\n-                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n-                }\n-                _ => visit::walk_item(this, item),\n+        self.with_parent_item_lifetime_defs(hir_id, |this| match item.kind {\n+            ItemKind::Impl(box Impl { ref of_trait, .. }) => {\n+                this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n             }\n-        });\n+            _ => visit::walk_item(this, item),\n+        })\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'a>, sp: Span, _: NodeId) {\n@@ -114,61 +161,6 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n }\n \n impl<'hir> LoweringContext<'_, 'hir> {\n-    // Same as the method above, but accepts `hir::GenericParam`s\n-    // instead of `ast::GenericParam`s.\n-    // This should only be used with generics that have already had their\n-    // in-band lifetimes added. In practice, this means that this function is\n-    // only used when lowering a child item of a trait or impl.\n-    #[tracing::instrument(level = \"debug\", skip(self, f))]\n-    fn with_parent_item_lifetime_defs<T>(\n-        &mut self,\n-        parent_hir_id: LocalDefId,\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> T {\n-        let parent_generics = match self.owners[parent_hir_id].unwrap().node().expect_item().kind {\n-            hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n-            | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n-            _ => &[],\n-        };\n-        let lt_def_names = parent_generics\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => {\n-                    Some(param.name.normalize_to_macros_2_0())\n-                }\n-                _ => None,\n-            })\n-            .collect();\n-        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, lt_def_names);\n-        debug!(in_scope_lifetimes = ?self.in_scope_lifetimes);\n-\n-        let res = f(self);\n-\n-        self.in_scope_lifetimes = old_in_scope_lifetimes;\n-        res\n-    }\n-\n-    // Clears (and restores) the `in_scope_lifetimes` field. Used when\n-    // visiting nested items, which never inherit in-scope lifetimes\n-    // from their surrounding environment.\n-    #[tracing::instrument(level = \"debug\", skip(self, f))]\n-    fn without_in_scope_lifetime_defs<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, vec![]);\n-        debug!(?old_in_scope_lifetimes);\n-\n-        // this vector is only used when walking over impl headers,\n-        // input types, and the like, and should not be non-empty in\n-        // between items\n-        assert!(self.lifetimes_to_define.is_empty());\n-\n-        let res = f(self);\n-\n-        assert!(self.in_scope_lifetimes.is_empty());\n-        self.in_scope_lifetimes = old_in_scope_lifetimes;\n-\n-        res\n-    }\n-\n     pub(super) fn lower_mod(&mut self, items: &[P<Item>], inner: Span) -> hir::Mod<'hir> {\n         hir::Mod {\n             inner: self.lower_span(inner),"}]}