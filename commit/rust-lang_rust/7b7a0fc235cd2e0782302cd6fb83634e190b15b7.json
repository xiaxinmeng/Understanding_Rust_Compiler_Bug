{"sha": "7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiN2EwZmMyMzVjZDJlMDc4MjMwMmNkNmZiODM2MzRlMTkwYjE1Yjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-29T02:36:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-29T02:36:36Z"}, "message": "auto merge of #6056 : thestinger/rust/iter, r=catamorphism\n\nThe existing adaptors like `map` in the `iter` module are very flawed because they only work for `BaseIter` implementations. There are many internal iterator implementations in the standard library like the set methods (`difference`, `symmetric_difference`, `intersection`, `union`) and the `range` functions that only share the `for` loop protocol in common.\r\n\r\nThe internal iterator adaptors should be implemented to work on any implementation of that protocol, rather than just a method called `each` taking `&self`.\r\n\r\nThis just moves `iter.rs` to `old_iter.rs` and begins work on documenting and implementing a nicer module.", "tree": {"sha": "c4d6aedddc64db81f6ada877e9ec585cf981d2d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4d6aedddc64db81f6ada877e9ec585cf981d2d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "html_url": "https://github.com/rust-lang/rust/commit/7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f03d45c56b37b36912c16bd5b4fb4723fd91cb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f03d45c56b37b36912c16bd5b4fb4723fd91cb7", "html_url": "https://github.com/rust-lang/rust/commit/9f03d45c56b37b36912c16bd5b4fb4723fd91cb7"}, {"sha": "46f91a0fa95cd13f7433a1d72d087283f483a4b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/46f91a0fa95cd13f7433a1d72d087283f483a4b8", "html_url": "https://github.com/rust-lang/rust/commit/46f91a0fa95cd13f7433a1d72d087283f483a4b8"}], "stats": {"total": 1144, "additions": 626, "deletions": 518}, "files": [{"sha": "066518769639747833cd5cba84a5c1b13f3c4ebd", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -1981,7 +1981,7 @@ struct TimeBomb {\n \n impl Drop for TimeBomb {\n     fn finalize(&self) {\n-        for iter::repeat(self.explosivity) {\n+        for old_iter::repeat(self.explosivity) {\n             io::println(\"blam!\");\n         }\n     }"}, {"sha": "6ce1acf59472c6f70ca9523223504bf64ed120df", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -12,7 +12,7 @@\n \n use cast::transmute;\n use kinds::Copy;\n-use iter;\n+use old_iter;\n use option::Option;\n use ptr::addr_of;\n use sys;\n@@ -125,7 +125,7 @@ pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n+pub fn from_fn<T>(n_elts: uint, op: old_iter::InitOp<T>) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }"}, {"sha": "dc3cd03dc2078954ae17982cc65d7b1c0872a775", "filename": "src/libcore/core.rc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -99,9 +99,10 @@ pub use container::{Container, Mutable};\n pub use vec::{CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};\n-pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n-pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n-pub use iter::{ExtendedMutableIter};\n+pub use old_iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use old_iter::{CopyableOrderedIter, CopyableNonstrictIter};\n+pub use old_iter::{ExtendedMutableIter};\n+pub use iter::Times;\n \n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Integer};\n@@ -188,6 +189,7 @@ pub mod from_str;\n #[path = \"num/num.rs\"]\n pub mod num;\n pub mod iter;\n+pub mod old_iter;\n pub mod iterator;\n pub mod to_str;\n pub mod to_bytes;"}, {"sha": "41f4f34dc1971518edcd6fd3f07b86e9cd9931fd", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -16,9 +16,9 @@\n use container::{Container, Mutable, Map, Set};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iter::BaseIter;\n+use old_iter::BaseIter;\n use hash::Hash;\n-use iter;\n+use old_iter;\n use option::{None, Option, Some};\n use rand::RngUtil;\n use rand;\n@@ -757,12 +757,12 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &HashSet<T>) -> bool {\n-        iter::all(self, |v| !other.contains(v))\n+        old_iter::all(self, |v| !other.contains(v))\n     }\n \n     /// Return true if the set is a subset of another\n     fn is_subset(&self, other: &HashSet<T>) -> bool {\n-        iter::all(self, |v| other.contains(v))\n+        old_iter::all(self, |v| other.contains(v))\n     }\n \n     /// Return true if the set is a superset of another"}, {"sha": "7476531ef944cdd301d52bd81859b3f1b841630b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 78, "deletions": 323, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -8,369 +8,124 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n+/*! Composable internal iterators\n \n-The iteration traits and common implementation\n+Internal iterators are functions implementing the protocol used by the `for` loop.\n \n-*/\n-\n-use cmp::{Eq, Ord};\n-use kinds::Copy;\n-use option::{None, Option, Some};\n-use vec;\n+An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n+breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n+tied to specific traits. For example:\n \n-/// A function used to initialize the elements of a sequence\n-pub type InitOp<'self,T> = &'self fn(uint) -> T;\n-\n-pub trait BaseIter<A> {\n-    fn each(&self, blk: &fn(v: &A) -> bool);\n-    fn size_hint(&self) -> Option<uint>;\n-}\n+~~~~\n+use core::iter::iter_to_vec;\n+println(iter_to_vec(|f| uint::range(0, 20, f)).to_str());\n+~~~~\n \n-pub trait ReverseIter<A>: BaseIter<A> {\n-    fn each_reverse(&self, blk: &fn(&A) -> bool);\n-}\n+An external iterator object implementing the interface in the `iterator` module can be used as an\n+internal iterator by calling the `advance` method. For example:\n \n-pub trait MutableIter<A>: BaseIter<A> {\n-    fn each_mut(&mut self, blk: &fn(&mut A) -> bool);\n-}\n+~~~~\n+use core::iterator::*;\n \n-pub trait ExtendedIter<A> {\n-    fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n-    fn all(&self, blk: &fn(&A) -> bool) -> bool;\n-    fn any(&self, blk: &fn(&A) -> bool) -> bool;\n-    fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n-    fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n-    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n-    fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n+let xs = [0u, 1, 2, 3, 4, 5];\n+let ys = [30, 40, 50, 60];\n+let mut it = xs.iter().chain(ys.iter());\n+for it.advance |&x: &uint| {\n+    println(x.to_str());\n }\n+~~~~\n \n-pub trait ExtendedMutableIter<A> {\n-    fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool);\n-}\n+Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n+to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n+much easier to implement.\n \n-pub trait EqIter<A:Eq> {\n-    fn contains(&self, x: &A) -> bool;\n-    fn count(&self, x: &A) -> uint;\n-}\n+*/\n \n pub trait Times {\n     fn times(&self, it: &fn() -> bool);\n }\n \n-pub trait CopyableIter<A:Copy> {\n-    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n-    fn to_vec(&self) -> ~[A];\n-    fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n-}\n-\n-pub trait CopyableOrderedIter<A:Copy + Ord> {\n-    fn min(&self) -> A;\n-    fn max(&self) -> A;\n-}\n-\n-pub trait CopyableNonstrictIter<A:Copy> {\n-    // Like \"each\", but copies out the value. If the receiver is mutated while\n-    // iterating over it, the semantics must not be memory-unsafe but are\n-    // otherwise undefined.\n-    fn each_val(&const self, f: &fn(A) -> bool);\n-}\n-\n-// A trait for sequences that can be built by imperatively pushing elements\n-// onto them.\n-pub trait Buildable<A> {\n-    /**\n-     * Builds a buildable sequence by calling a provided function with\n-     * an argument function that pushes an element onto the back of\n-     * the sequence.\n-     * This version takes an initial size for the sequence.\n-     *\n-     * # Arguments\n-     *\n-     * * size - A hint for an initial size of the sequence\n-     * * builder - A function that will construct the sequence. It receives\n-     *             as an argument a function that will push an element\n-     *             onto the sequence being constructed.\n-     */\n-     fn build_sized(size: uint, builder: &fn(push: &fn(A))) -> Self;\n-}\n-\n-#[inline(always)]\n-pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) {\n-    let mut i = 0;\n-    for self.each |a| {\n-        if !blk(i, a) { break; }\n-        i += 1;\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn all<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n-    for self.each |a| {\n-        if !blk(a) { return false; }\n-    }\n-    return true;\n-}\n-\n-#[inline(always)]\n-pub fn any<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n-    for self.each |a| {\n-        if blk(a) { return true; }\n-    }\n-    return false;\n-}\n-\n-#[inline(always)]\n-pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: &IA,\n-                                            prd: &fn(&A) -> bool)\n-                                         -> ~[A] {\n-    do vec::build_sized_opt(self.size_hint()) |push| {\n-        for self.each |a| {\n-            if prd(a) { push(*a); }\n-        }\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA, op: &fn(&A) -> B) -> ~[B] {\n-    do vec::build_sized_opt(self.size_hint()) |push| {\n-        for self.each |a| {\n-            push(op(a));\n-        }\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(self: &IA,\n-                                                          op: &fn(&A) -> IB)\n-                                                       -> ~[B] {\n-    do vec::build |push| {\n-        for self.each |a| {\n-            for op(a).each |&b| {\n-                push(b);\n-            }\n-        }\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B, blk: &fn(&B, &A) -> B)\n-                              -> B {\n-    let mut b = b0;\n-    for self.each |a| {\n-        b = blk(&b, a);\n-    }\n-    b\n-}\n-\n-#[inline(always)]\n-pub fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n-    map_to_vec(self, |&x| x)\n-}\n-\n-#[inline(always)]\n-pub fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n-    for self.each |a| {\n-        if *a == *x { return true; }\n-    }\n-    return false;\n-}\n-\n-#[inline(always)]\n-pub fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n-    do foldl(self, 0) |count, value| {\n-        if *value == *x {\n-            *count + 1\n-        } else {\n-            *count\n-        }\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n-                               -> Option<uint> {\n-    let mut i = 0;\n-    for self.each |a| {\n-        if f(a) { return Some(i); }\n-        i += 1;\n-    }\n-    return None;\n-}\n-\n-// note: 'rposition' would only make sense to provide with a bidirectional\n-// iter interface, such as would provide \"reach\" in addition to \"each\". As is,\n-// it would have to be implemented with foldr, which is too inefficient.\n-\n-#[inline(always)]\n-pub fn repeat(times: uint, blk: &fn() -> bool) {\n-    let mut i = 0;\n-    while i < times {\n-        if !blk() { break }\n-        i += 1;\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n-    match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n-        match a {\n-          &Some(ref a_) if *a_ < *b => {\n-             *(a)\n-          }\n-          _ => Some(*b)\n-        }\n-    } {\n-        Some(val) => val,\n-        None => fail!(~\"min called on empty iterator\")\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n-    match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n-        match a {\n-          &Some(ref a_) if *a_ > *b => {\n-              *(a)\n-          }\n-          _ => Some(*b)\n-        }\n-    } {\n-        Some(val) => val,\n-        None => fail!(~\"max called on empty iterator\")\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn find<A:Copy,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n-                                -> Option<A> {\n-    for self.each |i| {\n-        if f(i) { return Some(*i) }\n-    }\n-    return None;\n-}\n-\n-// Some functions for just building\n-\n /**\n- * Builds a sequence by calling a provided function with an argument\n- * function that pushes an element to the back of a sequence.\n+ * Transform an internal iterator into an owned vector.\n  *\n- * # Arguments\n+ * # Example:\n  *\n- * * builder - A function that will construct the sequence. It receives\n- *             as an argument a function that will push an element\n- *             onto the sequence being constructed.\n+ * ~~~\n+ * let xs = ~[1, 2, 3];\n+ * let ys = do iter_to_vec |f| { xs.each(|x| f(*x)) };\n+ * assert_eq!(xs, ys);\n+ * ~~~\n  */\n #[inline(always)]\n-pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n-    Buildable::build_sized(4, builder)\n+pub fn iter_to_vec<T>(iter: &fn(f: &fn(T) -> bool)) -> ~[T] {\n+    let mut v = ~[];\n+    for iter |x| { v.push(x) }\n+    v\n }\n \n /**\n- * Builds a sequence by calling a provided function with an argument\n- * function that pushes an element to the back of the sequence.\n- * This version takes an initial size for the sequence.\n+ * Return true if `predicate` is true for any values yielded by an internal iterator.\n  *\n- * # Arguments\n+ * Example:\n  *\n- * * size - An option, maybe containing initial size of the sequence\n- *          to reserve.\n- * * builder - A function that will construct the sequence. It receives\n- *             as an argument a function that will push an element\n- *             onto the sequence being constructed.\n+ * ~~~~\n+ * let xs = ~[1u, 2, 3, 4, 5];\n+ * assert!(any(|&x: &uint| x > 2, |f| xs.each(f)));\n+ * assert!(!any(|&x: &uint| x > 5, |f| xs.each(f)));\n+ * ~~~~\n  */\n #[inline(always)]\n-pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n-                                          builder: &fn(push: &fn(A))) -> B {\n-    Buildable::build_sized(size.get_or_default(4), builder)\n-}\n-\n-// Functions that combine iteration and building\n-\n-/// Applies a function to each element of an iterable and returns the results\n-/// in a sequence built via `BU`.  See also `map_to_vec`.\n-#[inline(always)]\n-pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n-    -> BU {\n-    do build_sized_opt(v.size_hint()) |push| {\n-        for v.each() |elem| {\n-            push(f(elem));\n+pub fn any<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n+    for iter |x| {\n+        if predicate(x) {\n+            return true\n         }\n     }\n+    false\n }\n \n /**\n- * Creates and initializes a generic sequence from a function.\n+ * Return true if `predicate` is true for all values yielded by an internal iterator.\n  *\n- * Creates a generic sequence of size `n_elts` and initializes the elements\n- * to the value returned by the function `op`.\n- */\n-#[inline(always)]\n-pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n-    do Buildable::build_sized(n_elts) |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts { push(op(i)); i += 1u; }\n-    }\n-}\n-\n-/**\n- * Creates and initializes a generic sequence with some elements.\n+ * # Example:\n  *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n- * to the value `t`.\n+ * ~~~~\n+ * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n+ * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n+ * ~~~~\n  */\n #[inline(always)]\n-pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n-    do Buildable::build_sized(n_elts) |push| {\n-        let mut i: uint = 0;\n-        while i < n_elts { push(t); i += 1; }\n+pub fn all<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n+    for iter |x| {\n+        if !predicate(x) {\n+            return false\n+        }\n     }\n+    true\n }\n \n-/// Appends two generic sequences.\n-#[inline(always)]\n-pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n-                                                  -> BT {\n-    let size_opt = lhs.size_hint().chain_ref(\n-        |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n-    do build_sized_opt(size_opt) |push| {\n-        for lhs.each |x| { push(*x); }\n-        for rhs.each |x| { push(*x); }\n-    }\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n \n-/// Copies a generic sequence, possibly converting it to a different\n-/// type of sequence.\n-#[inline(always)]\n-pub fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(v: &IT) -> BT {\n-    do build_sized_opt(v.size_hint()) |push| {\n-        for v.each |x| { push(*x); }\n+    #[test]\n+    fn test_iter_to_vec() {\n+        let xs = ~[1, 2, 3];\n+        let ys = do iter_to_vec |f| { xs.each(|x| f(*x)) };\n+        assert_eq!(xs, ys);\n     }\n-}\n \n-/**\n- * Helper function to transform an internal iterator into an owned vector.\n- *\n- * # Example:\n- *\n- * ~~~\n- * let v = ~[1, 2, 3];\n- * let v2 = do iter_to_vec |f| { v.each(|e| f(*e)) };\n- * if v != v2 { fail!() }\n- * ~~~\n- */\n-#[inline(always)]\n-pub fn iter_to_vec<T>(pusher: &fn(it: &fn(T) -> bool)) -> ~[T] {\n-    let mut v = ~[];\n-    let pushf = |e| {v.push(e); true};\n-    pusher(pushf);\n-    v\n-}\n+    #[test]\n+    fn test_any() {\n+        let xs = ~[1u, 2, 3, 4, 5];\n+        assert!(any(|&x: &uint| x > 2, |f| xs.each(f)));\n+        assert!(!any(|&x: &uint| x > 5, |f| xs.each(f)));\n+    }\n \n-#[test]\n-fn test_iter_to_vec() {\n-    let v = ~[1, 2, 3];\n-    let v2 = do iter_to_vec |f| { v.each(|e| f(*e)) };\n-    if v != v2 { fail!() }\n+    #[test]\n+    fn test_all() {\n+        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n+        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n+    }\n }"}, {"sha": "de882f1ee7a1f900432d23992b034082028ba62b", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -16,9 +16,9 @@ pub use self::inst::{\n };\n \n pub mod inst {\n-    use sys;\n     use iter;\n     use num::{Primitive, BitCount};\n+    use sys;\n \n     pub type T = uint;\n     #[allow(non_camel_case_types)]"}, {"sha": "98b847c75b408aff467e635c097de824870a5dea", "filename": "src/libcore/old_iter.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fold_iter.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -0,0 +1,346 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+**Deprecated** iteration traits and common implementations.\n+\n+*/\n+\n+use cmp::{Eq, Ord};\n+use kinds::Copy;\n+use option::{None, Option, Some};\n+use vec;\n+\n+/// A function used to initialize the elements of a sequence\n+pub type InitOp<'self,T> = &'self fn(uint) -> T;\n+\n+pub trait BaseIter<A> {\n+    fn each(&self, blk: &fn(v: &A) -> bool);\n+    fn size_hint(&self) -> Option<uint>;\n+}\n+\n+pub trait ReverseIter<A>: BaseIter<A> {\n+    fn each_reverse(&self, blk: &fn(&A) -> bool);\n+}\n+\n+pub trait MutableIter<A>: BaseIter<A> {\n+    fn each_mut(&mut self, blk: &fn(&mut A) -> bool);\n+}\n+\n+pub trait ExtendedIter<A> {\n+    fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n+    fn all(&self, blk: &fn(&A) -> bool) -> bool;\n+    fn any(&self, blk: &fn(&A) -> bool) -> bool;\n+    fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n+    fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n+    fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n+}\n+\n+pub trait ExtendedMutableIter<A> {\n+    fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool);\n+}\n+\n+pub trait EqIter<A:Eq> {\n+    fn contains(&self, x: &A) -> bool;\n+    fn count(&self, x: &A) -> uint;\n+}\n+\n+pub trait CopyableIter<A:Copy> {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n+    fn to_vec(&self) -> ~[A];\n+    fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n+}\n+\n+pub trait CopyableOrderedIter<A:Copy + Ord> {\n+    fn min(&self) -> A;\n+    fn max(&self) -> A;\n+}\n+\n+pub trait CopyableNonstrictIter<A:Copy> {\n+    // Like \"each\", but copies out the value. If the receiver is mutated while\n+    // iterating over it, the semantics must not be memory-unsafe but are\n+    // otherwise undefined.\n+    fn each_val(&const self, f: &fn(A) -> bool);\n+}\n+\n+// A trait for sequences that can be built by imperatively pushing elements\n+// onto them.\n+pub trait Buildable<A> {\n+    /**\n+     * Builds a buildable sequence by calling a provided function with\n+     * an argument function that pushes an element onto the back of\n+     * the sequence.\n+     * This version takes an initial size for the sequence.\n+     *\n+     * # Arguments\n+     *\n+     * * size - A hint for an initial size of the sequence\n+     * * builder - A function that will construct the sequence. It receives\n+     *             as an argument a function that will push an element\n+     *             onto the sequence being constructed.\n+     */\n+     fn build_sized(size: uint, builder: &fn(push: &fn(A))) -> Self;\n+}\n+\n+#[inline(always)]\n+pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) {\n+    let mut i = 0;\n+    for self.each |a| {\n+        if !blk(i, a) { break; }\n+        i += 1;\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn all<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n+    for self.each |a| {\n+        if !blk(a) { return false; }\n+    }\n+    return true;\n+}\n+\n+#[inline(always)]\n+pub fn any<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n+    for self.each |a| {\n+        if blk(a) { return true; }\n+    }\n+    return false;\n+}\n+\n+#[inline(always)]\n+pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: &IA,\n+                                            prd: &fn(&A) -> bool)\n+                                         -> ~[A] {\n+    do vec::build_sized_opt(self.size_hint()) |push| {\n+        for self.each |a| {\n+            if prd(a) { push(*a); }\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA, op: &fn(&A) -> B) -> ~[B] {\n+    do vec::build_sized_opt(self.size_hint()) |push| {\n+        for self.each |a| {\n+            push(op(a));\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(self: &IA,\n+                                                          op: &fn(&A) -> IB)\n+                                                       -> ~[B] {\n+    do vec::build |push| {\n+        for self.each |a| {\n+            for op(a).each |&b| {\n+                push(b);\n+            }\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B, blk: &fn(&B, &A) -> B)\n+                              -> B {\n+    let mut b = b0;\n+    for self.each |a| {\n+        b = blk(&b, a);\n+    }\n+    b\n+}\n+\n+#[inline(always)]\n+pub fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n+    map_to_vec(self, |&x| x)\n+}\n+\n+#[inline(always)]\n+pub fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n+    for self.each |a| {\n+        if *a == *x { return true; }\n+    }\n+    return false;\n+}\n+\n+#[inline(always)]\n+pub fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n+    do foldl(self, 0) |count, value| {\n+        if *value == *x {\n+            *count + 1\n+        } else {\n+            *count\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n+                               -> Option<uint> {\n+    let mut i = 0;\n+    for self.each |a| {\n+        if f(a) { return Some(i); }\n+        i += 1;\n+    }\n+    return None;\n+}\n+\n+// note: 'rposition' would only make sense to provide with a bidirectional\n+// iter interface, such as would provide \"reach\" in addition to \"each\". As is,\n+// it would have to be implemented with foldr, which is too inefficient.\n+\n+#[inline(always)]\n+pub fn repeat(times: uint, blk: &fn() -> bool) {\n+    let mut i = 0;\n+    while i < times {\n+        if !blk() { break }\n+        i += 1;\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+    match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n+        match a {\n+          &Some(ref a_) if *a_ < *b => {\n+             *(a)\n+          }\n+          _ => Some(*b)\n+        }\n+    } {\n+        Some(val) => val,\n+        None => fail!(~\"min called on empty iterator\")\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+    match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n+        match a {\n+          &Some(ref a_) if *a_ > *b => {\n+              *(a)\n+          }\n+          _ => Some(*b)\n+        }\n+    } {\n+        Some(val) => val,\n+        None => fail!(~\"max called on empty iterator\")\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn find<A:Copy,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n+                                -> Option<A> {\n+    for self.each |i| {\n+        if f(i) { return Some(*i) }\n+    }\n+    return None;\n+}\n+\n+// Some functions for just building\n+\n+/**\n+ * Builds a sequence by calling a provided function with an argument\n+ * function that pushes an element to the back of a sequence.\n+ *\n+ * # Arguments\n+ *\n+ * * builder - A function that will construct the sequence. It receives\n+ *             as an argument a function that will push an element\n+ *             onto the sequence being constructed.\n+ */\n+#[inline(always)]\n+pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n+    Buildable::build_sized(4, builder)\n+}\n+\n+/**\n+ * Builds a sequence by calling a provided function with an argument\n+ * function that pushes an element to the back of the sequence.\n+ * This version takes an initial size for the sequence.\n+ *\n+ * # Arguments\n+ *\n+ * * size - An option, maybe containing initial size of the sequence\n+ *          to reserve.\n+ * * builder - A function that will construct the sequence. It receives\n+ *             as an argument a function that will push an element\n+ *             onto the sequence being constructed.\n+ */\n+#[inline(always)]\n+pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n+                                          builder: &fn(push: &fn(A))) -> B {\n+    Buildable::build_sized(size.get_or_default(4), builder)\n+}\n+\n+// Functions that combine iteration and building\n+\n+/// Applies a function to each element of an iterable and returns the results\n+/// in a sequence built via `BU`.  See also `map_to_vec`.\n+#[inline(always)]\n+pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n+    -> BU {\n+    do build_sized_opt(v.size_hint()) |push| {\n+        for v.each() |elem| {\n+            push(f(elem));\n+        }\n+    }\n+}\n+\n+/**\n+ * Creates and initializes a generic sequence from a function.\n+ *\n+ * Creates a generic sequence of size `n_elts` and initializes the elements\n+ * to the value returned by the function `op`.\n+ */\n+#[inline(always)]\n+pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n+    do Buildable::build_sized(n_elts) |push| {\n+        let mut i: uint = 0u;\n+        while i < n_elts { push(op(i)); i += 1u; }\n+    }\n+}\n+\n+/**\n+ * Creates and initializes a generic sequence with some elements.\n+ *\n+ * Creates an immutable vector of size `n_elts` and initializes the elements\n+ * to the value `t`.\n+ */\n+#[inline(always)]\n+pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n+    do Buildable::build_sized(n_elts) |push| {\n+        let mut i: uint = 0;\n+        while i < n_elts { push(t); i += 1; }\n+    }\n+}\n+\n+/// Appends two generic sequences.\n+#[inline(always)]\n+pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n+                                                  -> BT {\n+    let size_opt = lhs.size_hint().chain_ref(\n+        |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n+    do build_sized_opt(size_opt) |push| {\n+        for lhs.each |x| { push(*x); }\n+        for rhs.each |x| { push(*x); }\n+    }\n+}\n+\n+/// Copies a generic sequence, possibly converting it to a different\n+/// type of sequence.\n+#[inline(always)]\n+pub fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(v: &IT) -> BT {\n+    do build_sized_opt(v.size_hint()) |push| {\n+        for v.each |x| { push(*x); }\n+    }\n+}"}, {"sha": "d3519854a0a366063b5d5a9183229a474640511a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -46,8 +46,8 @@ use ops::Add;\n use kinds::Copy;\n use util;\n use num::Zero;\n-use iter::{BaseIter, MutableIter, ExtendedIter};\n-use iter;\n+use old_iter::{BaseIter, MutableIter, ExtendedIter};\n+use old_iter;\n \n #[cfg(test)] use ptr;\n #[cfg(test)] use str;\n@@ -140,26 +140,26 @@ impl<T> MutableIter<T> for Option<T> {\n \n impl<A> ExtendedIter<A> for Option<A> {\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n-        iter::eachi(self, blk)\n+        old_iter::eachi(self, blk)\n     }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::all(self, blk)\n+        old_iter::all(self, blk)\n     }\n     pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::any(self, blk)\n+        old_iter::any(self, blk)\n     }\n     pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        iter::foldl(self, b0, blk)\n+        old_iter::foldl(self, b0, blk)\n     }\n     pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        iter::position(self, f)\n+        old_iter::position(self, f)\n     }\n     fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        iter::map_to_vec(self, op)\n+        old_iter::map_to_vec(self, op)\n     }\n     fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n-        iter::flat_map_to_vec(self, op)\n+        old_iter::flat_map_to_vec(self, op)\n     }\n }\n "}, {"sha": "41078fb8920a71730f22dadc85a18f66f3918632", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -34,9 +34,10 @@ pub use clone::Clone;\n pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n-pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n-pub use iter::{Times, ExtendedMutableIter};\n+pub use old_iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n+pub use old_iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n+pub use old_iter::{ExtendedMutableIter};\n+pub use iter::Times;\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Integer};\n pub use num::{Round, Fractional, Real, RealExt};\n@@ -79,6 +80,7 @@ pub use i8;\n pub use int;\n pub use io;\n pub use iter;\n+pub use old_iter;\n pub use libc;\n pub use num;\n pub use ops;"}, {"sha": "2163a0e325f1364014471af3913bddedbf0a4cc6", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -687,7 +687,7 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n         let ch = ch.clone();\n         do spawn_unlinked {\n             // Give middle task a chance to fail-but-not-kill-us.\n-            for iter::repeat(16) { task::yield(); }\n+            for old_iter::repeat(16) { task::yield(); }\n             ch.send(()); // If killed first, grandparent hangs.\n         }\n         fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n@@ -702,7 +702,7 @@ fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n     do spawn_supervised { fail!(); }\n     // Give child a chance to fail-but-not-kill-us.\n-    for iter::repeat(16) { task::yield(); }\n+    for old_iter::repeat(16) { task::yield(); }\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_fail_down() {\n@@ -783,7 +783,7 @@ fn test_spawn_failure_propagate_grandchild() {\n             loop { task::yield(); }\n         }\n     }\n-    for iter::repeat(16) { task::yield(); }\n+    for old_iter::repeat(16) { task::yield(); }\n     fail!();\n }\n \n@@ -795,7 +795,7 @@ fn test_spawn_failure_propagate_secondborn() {\n             loop { task::yield(); }\n         }\n     }\n-    for iter::repeat(16) { task::yield(); }\n+    for old_iter::repeat(16) { task::yield(); }\n     fail!();\n }\n \n@@ -807,7 +807,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n             loop { task::yield(); }\n         }\n     }\n-    for iter::repeat(16) { task::yield(); }\n+    for old_iter::repeat(16) { task::yield(); }\n     fail!();\n }\n \n@@ -819,7 +819,7 @@ fn test_spawn_linked_sup_propagate_sibling() {\n             loop { task::yield(); }\n         }\n     }\n-    for iter::repeat(16) { task::yield(); }\n+    for old_iter::repeat(16) { task::yield(); }\n     fail!();\n }\n \n@@ -971,7 +971,7 @@ fn test_spawn_sched_blocking() {\n \n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers\n-        for iter::repeat(20u) {\n+        for old_iter::repeat(20u) {\n \n             let (start_po, start_ch) = stream();\n             let (fin_po, fin_ch) = stream();\n@@ -1088,7 +1088,7 @@ fn test_unkillable() {\n \n     // We want to do this after failing\n     do spawn_unlinked {\n-        for iter::repeat(10) { yield() }\n+        for old_iter::repeat(10) { yield() }\n         ch.send(());\n     }\n \n@@ -1123,7 +1123,7 @@ fn test_unkillable_nested() {\n \n     // We want to do this after failing\n     do spawn_unlinked || {\n-        for iter::repeat(10) { yield() }\n+        for old_iter::repeat(10) { yield() }\n         ch.send(());\n     }\n "}, {"sha": "ef42647411a34516026af94598dbb739f6f0f1a1", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -17,8 +17,8 @@ use cast;\n use container::{Container, Mutable};\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n-use iter::BaseIter;\n-use iter;\n+use old_iter::BaseIter;\n+use old_iter;\n #[cfg(stage1)]\n #[cfg(stage2)]\n #[cfg(stage3)]\n@@ -142,7 +142,7 @@ pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n+pub fn from_fn<T>(n_elts: uint, op: old_iter::InitOp<T>) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         do as_mut_buf(v) |p, _len| {\n@@ -786,7 +786,7 @@ pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n  * * init_op - A function to call to retreive each appended element's\n  *             value\n  */\n-pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n+pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: old_iter::InitOp<T>) {\n     let new_len = v.len() + n;\n     reserve_at_least(&mut *v, new_len);\n     let mut i: uint = 0u;\n@@ -2265,7 +2265,7 @@ pub trait OwnedVector<T> {\n     fn consume_reverse(self, f: &fn(uint, v: T));\n     fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n     fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n-    fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n+    fn grow_fn(&mut self, n: uint, op: old_iter::InitOp<T>);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -2344,7 +2344,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>) {\n+    fn grow_fn(&mut self, n: uint, op: old_iter::InitOp<T>) {\n         grow_fn(self, n, op);\n     }\n }\n@@ -2643,7 +2643,7 @@ pub mod bytes {\n // ITERATION TRAIT METHODS\n \n #[cfg(stage0)]\n-impl<'self,A> iter::BaseIter<A> for &'self [A] {\n+impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n@@ -2653,7 +2653,7 @@ impl<'self,A> iter::BaseIter<A> for &'self [A] {\n #[cfg(stage1)]\n #[cfg(stage2)]\n #[cfg(stage3)]\n-impl<'self,A> iter::BaseIter<A> for &'self [A] {\n+impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n@@ -2662,7 +2662,7 @@ impl<'self,A> iter::BaseIter<A> for &'self [A] {\n \n // FIXME(#4148): This should be redundant\n #[cfg(stage0)]\n-impl<A> iter::BaseIter<A> for ~[A] {\n+impl<A> old_iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n@@ -2673,7 +2673,7 @@ impl<A> iter::BaseIter<A> for ~[A] {\n #[cfg(stage1)]\n #[cfg(stage2)]\n #[cfg(stage3)]\n-impl<A> iter::BaseIter<A> for ~[A] {\n+impl<A> old_iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n@@ -2682,7 +2682,7 @@ impl<A> iter::BaseIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n #[cfg(stage0)]\n-impl<A> iter::BaseIter<A> for @[A] {\n+impl<A> old_iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n@@ -2693,15 +2693,15 @@ impl<A> iter::BaseIter<A> for @[A] {\n #[cfg(stage1)]\n #[cfg(stage2)]\n #[cfg(stage3)]\n-impl<A> iter::BaseIter<A> for @[A] {\n+impl<A> old_iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n #[cfg(stage0)]\n-impl<'self,A> iter::MutableIter<A> for &'self mut [A] {\n+impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n         each_mut(*self, blk)\n@@ -2711,7 +2711,7 @@ impl<'self,A> iter::MutableIter<A> for &'self mut [A] {\n #[cfg(stage1)]\n #[cfg(stage2)]\n #[cfg(stage3)]\n-impl<'self,A> iter::MutableIter<A> for &'self mut [A] {\n+impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n         each_mut(*self, blk)\n@@ -2720,7 +2720,7 @@ impl<'self,A> iter::MutableIter<A> for &'self mut [A] {\n \n // FIXME(#4148): This should be redundant\n #[cfg(stage0)]\n-impl<A> iter::MutableIter<A> for ~[A] {\n+impl<A> old_iter::MutableIter<A> for ~[A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n         each_mut(*self, blk)\n@@ -2730,172 +2730,172 @@ impl<A> iter::MutableIter<A> for ~[A] {\n #[cfg(stage1)]\n #[cfg(stage2)]\n #[cfg(stage3)]\n-impl<A> iter::MutableIter<A> for ~[A] {\n+impl<A> old_iter::MutableIter<A> for ~[A] {\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A> iter::MutableIter<A> for @mut [A] {\n+impl<A> old_iter::MutableIter<A> for @mut [A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n }\n \n-impl<'self,A> iter::ExtendedIter<A> for &'self [A] {\n+impl<'self,A> old_iter::ExtendedIter<A> for &'self [A] {\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n-        iter::eachi(self, blk)\n+        old_iter::eachi(self, blk)\n     }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::all(self, blk)\n+        old_iter::all(self, blk)\n     }\n     pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::any(self, blk)\n+        old_iter::any(self, blk)\n     }\n     pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        iter::foldl(self, b0, blk)\n+        old_iter::foldl(self, b0, blk)\n     }\n     pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        iter::position(self, f)\n+        old_iter::position(self, f)\n     }\n     fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        iter::map_to_vec(self, op)\n+        old_iter::map_to_vec(self, op)\n     }\n     fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n-        iter::flat_map_to_vec(self, op)\n+        old_iter::flat_map_to_vec(self, op)\n     }\n }\n \n-impl<'self,A> iter::ExtendedMutableIter<A> for &'self mut [A] {\n+impl<'self,A> old_iter::ExtendedMutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n     pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) {\n         eachi_mut(*self, blk)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A> iter::ExtendedIter<A> for ~[A] {\n+impl<A> old_iter::ExtendedIter<A> for ~[A] {\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n-        iter::eachi(self, blk)\n+        old_iter::eachi(self, blk)\n     }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::all(self, blk)\n+        old_iter::all(self, blk)\n     }\n     pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::any(self, blk)\n+        old_iter::any(self, blk)\n     }\n     pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        iter::foldl(self, b0, blk)\n+        old_iter::foldl(self, b0, blk)\n     }\n     pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        iter::position(self, f)\n+        old_iter::position(self, f)\n     }\n     fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        iter::map_to_vec(self, op)\n+        old_iter::map_to_vec(self, op)\n     }\n     fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n-        iter::flat_map_to_vec(self, op)\n+        old_iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A> iter::ExtendedIter<A> for @[A] {\n+impl<A> old_iter::ExtendedIter<A> for @[A] {\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n-        iter::eachi(self, blk)\n+        old_iter::eachi(self, blk)\n     }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::all(self, blk)\n+        old_iter::all(self, blk)\n     }\n     pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::any(self, blk)\n+        old_iter::any(self, blk)\n     }\n     pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        iter::foldl(self, b0, blk)\n+        old_iter::foldl(self, b0, blk)\n     }\n     pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        iter::position(self, f)\n+        old_iter::position(self, f)\n     }\n     fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        iter::map_to_vec(self, op)\n+        old_iter::map_to_vec(self, op)\n     }\n     fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n-        iter::flat_map_to_vec(self, op)\n+        old_iter::flat_map_to_vec(self, op)\n     }\n }\n \n-impl<'self,A:Eq> iter::EqIter<A> for &'self [A] {\n-    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+impl<'self,A:Eq> old_iter::EqIter<A> for &'self [A] {\n+    pub fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A:Eq> iter::EqIter<A> for ~[A] {\n-    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+impl<A:Eq> old_iter::EqIter<A> for ~[A] {\n+    pub fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A:Eq> iter::EqIter<A> for @[A] {\n-    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+impl<A:Eq> old_iter::EqIter<A> for @[A] {\n+    pub fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n }\n \n-impl<'self,A:Copy> iter::CopyableIter<A> for &'self [A] {\n+impl<'self,A:Copy> old_iter::CopyableIter<A> for &'self [A] {\n     fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(self, pred)\n+        old_iter::filter_to_vec(self, pred)\n     }\n-    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n     pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n-        iter::find(self, f)\n+        old_iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A:Copy> iter::CopyableIter<A> for ~[A] {\n+impl<A:Copy> old_iter::CopyableIter<A> for ~[A] {\n     fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(self, pred)\n+        old_iter::filter_to_vec(self, pred)\n     }\n-    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n     pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n-        iter::find(self, f)\n+        old_iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A:Copy> iter::CopyableIter<A> for @[A] {\n+impl<A:Copy> old_iter::CopyableIter<A> for @[A] {\n     fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(self, pred)\n+        old_iter::filter_to_vec(self, pred)\n     }\n-    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n     pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n-        iter::find(self, f)\n+        old_iter::find(self, f)\n     }\n }\n \n-impl<'self,A:Copy + Ord> iter::CopyableOrderedIter<A> for &'self [A] {\n-    fn min(&self) -> A { iter::min(self) }\n-    fn max(&self) -> A { iter::max(self) }\n+impl<'self,A:Copy + Ord> old_iter::CopyableOrderedIter<A> for &'self [A] {\n+    fn min(&self) -> A { old_iter::min(self) }\n+    fn max(&self) -> A { old_iter::max(self) }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for ~[A] {\n-    fn min(&self) -> A { iter::min(self) }\n-    fn max(&self) -> A { iter::max(self) }\n+impl<A:Copy + Ord> old_iter::CopyableOrderedIter<A> for ~[A] {\n+    fn min(&self) -> A { old_iter::min(self) }\n+    fn max(&self) -> A { old_iter::max(self) }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for @[A] {\n-    fn min(&self) -> A { iter::min(self) }\n-    fn max(&self) -> A { iter::max(self) }\n+impl<A:Copy + Ord> old_iter::CopyableOrderedIter<A> for @[A] {\n+    fn min(&self) -> A { old_iter::min(self) }\n+    fn max(&self) -> A { old_iter::max(self) }\n }\n \n-impl<'self,A:Copy> iter::CopyableNonstrictIter<A> for &'self [A] {\n+impl<'self,A:Copy> old_iter::CopyableNonstrictIter<A> for &'self [A] {\n     fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n@@ -2906,7 +2906,7 @@ impl<'self,A:Copy> iter::CopyableNonstrictIter<A> for &'self [A] {\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n+impl<A:Copy> old_iter::CopyableNonstrictIter<A> for ~[A] {\n     fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < uniq_len(self) {\n@@ -2917,7 +2917,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A:Copy> iter::CopyableNonstrictIter<A> for @[A] {\n+impl<A:Copy> old_iter::CopyableNonstrictIter<A> for @[A] {\n     fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {"}, {"sha": "fd836b20b8100c37fe8138ee8f473c07a8c4b03e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -1071,7 +1071,7 @@ pub impl Liveness {\n \n     fn propagate_through_opt_expr(&self, opt_expr: Option<@expr>,\n                                   succ: LiveNode) -> LiveNode {\n-        do iter::foldl(&opt_expr, succ) |succ, expr| {\n+        do old_iter::foldl(&opt_expr, succ) |succ, expr| {\n             self.propagate_through_expr(*expr, *succ)\n         }\n     }"}, {"sha": "14c9bc36d7f7a1502e15f7c23d08c233427fc823", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -210,7 +210,7 @@ pub impl CoherenceChecker {\n                 match item.node {\n                     item_impl(_, opt_trait, _, _) => {\n                         self.check_implementation(item,\n-                                                  iter::to_vec(&opt_trait));\n+                                                  old_iter::to_vec(&opt_trait));\n                     }\n                     _ => {\n                         // Nothing to do."}, {"sha": "16b84190ee391364b0b90797f325048e45b64ea8", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -629,7 +629,7 @@ mod test {\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n         // We expect two pages to have been written\n-        for iter::repeat(2) {\n+        for old_iter::repeat(2) {\n             po.recv();\n         }\n     }\n@@ -641,7 +641,7 @@ mod test {\n             ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n-        for iter::repeat(2) {\n+        for old_iter::repeat(2) {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {"}, {"sha": "b26296c9acae4f256152e1d3c4605fc022d19da4", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -10,7 +10,7 @@\n \n //! Base64 binary-to-text encoding\n \n-use core::iter;\n+use core::old_iter;\n use core::str;\n use core::vec;\n \n@@ -152,7 +152,7 @@ impl FromBase64 for ~[u8] {\n         while i < len {\n             let mut n = 0u;\n \n-            for iter::repeat(4u) {\n+            for old_iter::repeat(4u) {\n                 let ch = self[i] as char;\n                 n <<= 6u;\n "}, {"sha": "1257d5545320528d1e2aa3cf43c17c2d46e545fa", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -483,7 +483,7 @@ pub impl<T:Copy> DList<T> {\n     /// Get the elements of the list as a vector. O(n).\n     fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n-        for iter::eachi(&self) |index,data| {\n+        for old_iter::eachi(&self) |index,data| {\n             v[index] = *data;\n         }\n         v\n@@ -750,7 +750,7 @@ mod tests {\n     #[test]\n     fn test_dlist_foldl() {\n         let l = from_vec(vec::from_fn(101, |x|x));\n-        assert_eq!(iter::foldl(&l, 0, |accum,elem| *accum+*elem), 5050);\n+        assert_eq!(old_iter::foldl(&l, 0, |accum,elem| *accum+*elem), 5050);\n     }\n     #[test]\n     fn test_dlist_break_early() {"}, {"sha": "60f25c2a270b2103c3fe6a44d11832317c58b721", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -10,7 +10,7 @@\n \n //! A priority queue implemented with a binary heap\n \n-use core::iter::BaseIter;\n+use core::old_iter::BaseIter;\n use core::ptr::addr_of;\n \n #[abi = \"rust-intrinsic\"]"}, {"sha": "fb17d4e50900ce6e99be6eab41fc167357afcbaf", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -14,7 +14,7 @@\n  */\n \n use core::container::{Container, Mutable, Map, Set};\n-use core::iter::{BaseIter};\n+use core::old_iter::{BaseIter};\n use core::option::{Some, None};\n \n pub struct SmallIntMap<T> {"}, {"sha": "69e01d4e4dbdda3ebb0b4ccced735d83c4c8f326", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -183,7 +183,7 @@ mod test {\n     #[test]\n     fn test_gl_timer_sleep_stress1() {\n         let hl_loop = &uv::global_loop::get();\n-        for iter::repeat(50u) {\n+        for old_iter::repeat(50u) {\n             sleep(hl_loop, 1u);\n         }\n     }\n@@ -203,7 +203,7 @@ mod test {\n \n         };\n \n-        for iter::repeat(repeat) {\n+        for old_iter::repeat(repeat) {\n \n             let ch = ch.clone();\n             for spec.each |spec| {\n@@ -213,15 +213,15 @@ mod test {\n                 do task::spawn {\n                     use core::rand::*;\n                     let rng = rng();\n-                    for iter::repeat(times) {\n+                    for old_iter::repeat(times) {\n                         sleep(&hl_loop_clone, rng.next() as uint % maxms);\n                     }\n                     ch.send(());\n                 }\n             }\n         }\n \n-        for iter::repeat(repeat * spec.len()) {\n+        for old_iter::repeat(repeat * spec.len()) {\n             po.recv()\n         }\n     }\n@@ -239,7 +239,7 @@ mod test {\n         let mut failures = 0;\n         let hl_loop = uv::global_loop::get();\n \n-        for iter::repeat(times as uint) {\n+        for old_iter::repeat(times as uint) {\n             task::yield();\n \n             let expected = rand::rng().gen_str(16u);\n@@ -268,7 +268,7 @@ mod test {\n         let mut failures = 0;\n         let hl_loop = uv::global_loop::get();\n \n-        for iter::repeat(times as uint) {\n+        for old_iter::repeat(times as uint) {\n             let expected = rand::rng().gen_str(16u);\n             let (test_po, test_ch) = stream::<~str>();\n             let hl_loop_clone = hl_loop.clone();"}, {"sha": "2ab5ce8698c25a9911f2ece7ad4514c0d21db45b", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -119,7 +119,7 @@ mod test {\n     use uv::ll;\n     use uv_iotask::IoTask;\n \n-    use core::iter;\n+    use core::old_iter;\n     use core::libc;\n     use core::ptr;\n     use core::task;\n@@ -210,15 +210,15 @@ mod test {\n         let (exit_po, exit_ch) = stream::<()>();\n         let exit_ch = SharedChan::new(exit_ch);\n         let cycles = 5000u;\n-        for iter::repeat(cycles) {\n+        for old_iter::repeat(cycles) {\n             let exit_ch_clone = exit_ch.clone();\n             task::spawn_sched(task::ManualThreads(1u), || {\n                 let hl_loop = &get_gl();\n                 impl_uv_hl_simple_timer(hl_loop);\n                 exit_ch_clone.send(());\n             });\n         };\n-        for iter::repeat(cycles) {\n+        for old_iter::repeat(cycles) {\n             exit_po.recv();\n         };\n         debug!(~\"test_stress_gl_uv_global_loop_high_level_global_timer\"+"}, {"sha": "309ae32dc59af9807cdb763872e680e61ac7b400", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -285,7 +285,7 @@ fn test_uv_iotask_async() {\n     // impl_uv_hl_async() runs have been called, at least.\n     let (work_exit_po, work_exit_ch) = stream::<()>();\n     let work_exit_ch = SharedChan::new(work_exit_ch);\n-    for iter::repeat(7u) {\n+    for old_iter::repeat(7u) {\n         let iotask_clone = iotask.clone();\n         let work_exit_ch_clone = work_exit_ch.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -295,7 +295,7 @@ fn test_uv_iotask_async() {\n             work_exit_ch_clone.send(());\n         };\n     };\n-    for iter::repeat(7u) {\n+    for old_iter::repeat(7u) {\n         debug!(\"waiting\");\n         work_exit_po.recv();\n     };"}, {"sha": "fd1c5a960d149ef031cb0610cd31e9a51afb3bc4", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -16,8 +16,9 @@\n  * other useful things like `push()` and `len()`.\n  */\n \n-use core::iter;\n-use core::iter::BaseIter;\n+use core::prelude::*;\n+use core::old_iter;\n+use core::old_iter::BaseIter;\n \n #[auto_encode]\n #[auto_decode]\n@@ -116,7 +117,7 @@ impl<T:Copy> OptVec<T> {\n     #[inline(always)]\n     fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n         let mut index = 0;\n-        iter::map_to_vec(self, |a| {\n+        old_iter::map_to_vec(self, |a| {\n             let i = index;\n             index += 1;\n             op(i, a)\n@@ -154,62 +155,62 @@ impl<A> BaseIter<A> for OptVec<A> {\n     }\n }\n \n-impl<A> iter::ExtendedIter<A> for OptVec<A> {\n+impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n     fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) {\n-        iter::eachi(self, blk)\n+        old_iter::eachi(self, blk)\n     }\n     #[inline(always)]\n     fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::all(self, blk)\n+        old_iter::all(self, blk)\n     }\n     #[inline(always)]\n     fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        iter::any(self, blk)\n+        old_iter::any(self, blk)\n     }\n     #[inline(always)]\n     fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        iter::foldl(self, b0, blk)\n+        old_iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]\n     fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        iter::position(self, f)\n+        old_iter::position(self, f)\n     }\n     #[inline(always)]\n     fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        iter::map_to_vec(self, op)\n+        old_iter::map_to_vec(self, op)\n     }\n     #[inline(always)]\n     fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n-        iter::flat_map_to_vec(self, op)\n+        old_iter::flat_map_to_vec(self, op)\n     }\n \n }\n \n-impl<A: Eq> iter::EqIter<A> for OptVec<A> {\n+impl<A: Eq> old_iter::EqIter<A> for OptVec<A> {\n     #[inline(always)]\n-    fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n     #[inline(always)]\n-    fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n }\n \n-impl<A: Copy> iter::CopyableIter<A> for OptVec<A> {\n+impl<A: Copy> old_iter::CopyableIter<A> for OptVec<A> {\n     #[inline(always)]\n     fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(self, pred)\n+        old_iter::filter_to_vec(self, pred)\n     }\n     #[inline(always)]\n-    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n     #[inline(always)]\n     fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n-        iter::find(self, f)\n+        old_iter::find(self, f)\n     }\n }\n \n-impl<A: Copy+Ord> iter::CopyableOrderedIter<A> for OptVec<A> {\n+impl<A: Copy+Ord> old_iter::CopyableOrderedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    fn min(&self) -> A { iter::min(self) }\n+    fn min(&self) -> A { old_iter::min(self) }\n     #[inline(always)]\n-    fn max(&self) -> A { iter::max(self) }\n+    fn max(&self) -> A { old_iter::max(self) }\n }"}, {"sha": "25889167050454bc11bd7d109df0e13c88922e5f", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -30,7 +30,7 @@ fn main() {\n }\n \n fn run(repeat: int, depth: int) {\n-    for iter::repeat(repeat as uint) {\n+    for old_iter::repeat(repeat as uint) {\n         debug!(\"starting %.4f\", precise_time_s());\n         do task::try {\n             recurse_or_fail(depth, None)"}, {"sha": "2deee10527cc99397203f4733734d81f03ef1ae5", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -12,6 +12,8 @@\n // Testing that runtime failure doesn't cause callbacks to abort abnormally.\n // Instead the failure will be delivered after the callbacks return.\n \n+use core::old_iter;\n+\n mod rustrt {\n     pub extern {\n         pub fn rust_dbg_call(cb: *u8, data: libc::uintptr_t)\n@@ -35,7 +37,7 @@ fn count(n: uint) -> uint {\n }\n \n fn main() {\n-    for iter::repeat(10u) {\n+    for old_iter::repeat(10u) {\n         do task::spawn {\n             let result = count(5u);\n             debug!(\"result = %?\", result);"}, {"sha": "bf2285480b47787b8086139abb1ef3c3f67569bc", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -21,5 +21,5 @@ fn bitv_test() -> bool {\n }\n \n pub fn main() {\n-    do iter::repeat(10000) || {bitv_test()};\n+    do old_iter::repeat(10000) || {bitv_test()};\n }"}, {"sha": "cf887758bff7d00c06159c633097f01c58542f0a", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n \n use core::container::{Container, Mutable, Map};\n-use core::iter::BaseIter;\n+use core::old_iter::BaseIter;\n \n enum cat_type { tuxedo, tabby, tortoiseshell }\n "}, {"sha": "e1929d33d5b9c6d24f5f72646f08b911969c2137", "filename": "src/test/run-pass/class-trait-bounded-param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -14,7 +14,7 @@ extern mod std;\n use std::oldmap::{map, hashmap, int_hash};\n \n class keys<K:Copy,V:Copy,M:Copy + map<K,V>>\n-    : iter::base_iter<K> {\n+    : old_iter::base_iter<K> {\n \n     let map: M;\n \n@@ -24,12 +24,12 @@ class keys<K:Copy,V:Copy,M:Copy + map<K,V>>\n \n     fn each(blk: &fn(K) -> bool) { self.map.each(|k, _v| blk(k) ) }\n     fn size_hint() -> Option<uint> { Some(self.map.size()) }\n-    fn eachi(blk: &fn(uint, K) -> bool) { iter::eachi(self, blk) }\n+    fn eachi(blk: &fn(uint, K) -> bool) { old_iter::eachi(self, blk) }\n }\n \n pub fn main() {\n     let m = int_hash();\n     m.insert(1, 2);\n     m.insert(3, 4);\n-    assert!(iter::to_vec(keys(m)) == ~[1, 3]);\n+    assert!(old_iter::to_vec(keys(m)) == ~[1, 3]);\n }"}, {"sha": "58b192e839b385b7735138dd345091e9ed9d9a7b", "filename": "src/test/run-pass/early-vtbl-resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -21,7 +21,7 @@ struct A { a: int }\n \n pub fn main() {\n \n-    for iter::eachi(&(Some(A {a: 0}))) |i, a| { \n+    for old_iter::eachi(&(Some(A {a: 0}))) |i, a| {\n         debug!(\"%u %d\", i, a.a);\n     }\n "}, {"sha": "0b640c8c623600f8cae8c58a57dd01a48800cd08", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -34,7 +34,7 @@ fn count(n: uint) -> uint {\n }\n \n pub fn main() {\n-    for iter::repeat(100u) {\n+    for old_iter::repeat(100u) {\n         do task::spawn {\n             assert!(count(5u) == 16u);\n         };"}, {"sha": "bde3f5dd52ff6070b96f3ac5ad2914e0075ef035", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -31,7 +31,7 @@ fn count(n: uint) -> uint {\n }\n \n pub fn main() {\n-    for iter::repeat(10u) {\n+    for old_iter::repeat(10u) {\n         do task::spawn {\n             let result = count(5u);\n             debug!(\"result = %?\", result);"}, {"sha": "f24605339ad777159bdd498a90fc9af50f360972", "filename": "src/test/run-pass/issue-2611.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::iter::BaseIter;\n+use core::old_iter::BaseIter;\n \n trait FlatMapToVec<A> {\n   fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n impl<A:Copy> FlatMapToVec<A> for ~[A] {\n    fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B] {\n-     iter::flat_map_to_vec(self, op)\n+     old_iter::flat_map_to_vec(self, op)\n    }\n }\n "}, {"sha": "b21ddc656c93c99a39bddf699c3efa39411c04ed", "filename": "src/test/run-pass/iter-all.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-all.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     assert!([2u, 4u].all(is_even));\n     assert!([].all(is_even));\n \n-    assert!(!iter::all(&Some(1u), is_even));\n-    assert!(iter::all(&Some(2u), is_even));\n-    assert!(iter::all(&None::<uint>, is_even));\n+    assert!(!old_iter::all(&Some(1u), is_even));\n+    assert!(old_iter::all(&Some(2u), is_even));\n+    assert!(old_iter::all(&None::<uint>, is_even));\n }"}, {"sha": "657c8d7c624591223baf61aaf9e45ad643e1efc0", "filename": "src/test/run-pass/iter-any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-any.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     assert!([1u, 2u].any(is_even));\n     assert!(![].any(is_even));\n \n-    assert!(!iter::any(&Some(1u), is_even));\n-    assert!(iter::any(&Some(2u), is_even));\n-    assert!(!iter::any(&None::<uint>, is_even));\n+    assert!(!old_iter::any(&Some(1u), is_even));\n+    assert!(old_iter::any(&Some(2u), is_even));\n+    assert!(!old_iter::any(&None::<uint>, is_even));\n }"}, {"sha": "fe10ecdcf95e48b8a61d63d6cd82c362786963e4", "filename": "src/test/run-pass/iter-contains.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-contains.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n     assert!([22u, 1u, 3u].contains(&22u) == true);\n     assert!([1u, 22u, 3u].contains(&22u) == true);\n     assert!([1u, 3u, 22u].contains(&22u) == true);\n-    assert!(iter::contains(&None::<uint>, &22u) == false);\n-    assert!(iter::contains(&Some(1u), &22u) == false);\n-    assert!(iter::contains(&Some(22u), &22u) == true);\n+    assert!(old_iter::contains(&None::<uint>, &22u) == false);\n+    assert!(old_iter::contains(&Some(1u), &22u) == false);\n+    assert!(old_iter::contains(&Some(22u), &22u) == true);\n }"}, {"sha": "8e061775c2bfa43364aa43117c0c1ef23c841167", "filename": "src/test/run-pass/iter-count.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-count.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -13,7 +13,7 @@ pub fn main() {\n     assert!([1u, 3u].count(&22u) == 0u);\n     assert!([22u, 1u, 3u].count(&22u) == 1u);\n     assert!([22u, 1u, 22u].count(&22u) == 2u);\n-    assert!(iter::count(&None::<uint>, &22u) == 0u);\n-    assert!(iter::count(&Some(1u), &22u) == 0u);\n-    assert!(iter::count(&Some(22u), &22u) == 1u);\n+    assert!(old_iter::count(&None::<uint>, &22u) == 0u);\n+    assert!(old_iter::count(&Some(1u), &22u) == 0u);\n+    assert!(old_iter::count(&Some(22u), &22u) == 1u);\n }"}, {"sha": "03130a6632c3c9ed8b99033cdf313da6ecb436ce", "filename": "src/test/run-pass/iter-eachi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-eachi.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -16,10 +16,10 @@ pub fn main() {\n     }\n     assert!(c == 5u);\n \n-    for iter::eachi(&None::<uint>) |i, v| { fail!(); }\n+    for old_iter::eachi(&None::<uint>) |i, v| { fail!(); }\n \n     let mut c = 0u;\n-    for iter::eachi(&Some(1u)) |i, v| {\n+    for old_iter::eachi(&Some(1u)) |i, v| {\n         assert!((i + 1u) == *v);\n         c += 1u;\n     }"}, {"sha": "a9cdec9a0b7cc4b995ce1e6c570ba7aa5a8deaf4", "filename": "src/test/run-pass/iter-filter-to-vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -13,7 +13,7 @@ fn is_even(x: &uint) -> bool { (*x % 2) == 0 }\n pub fn main() {\n     assert!([1, 3].filter_to_vec(is_even) == ~[]);\n     assert!([1, 2, 3].filter_to_vec(is_even) == ~[2]);\n-    assert!(iter::filter_to_vec(&None::<uint>, is_even) == ~[]);\n-    assert!(iter::filter_to_vec(&Some(1u), is_even) == ~[]);\n-    assert!(iter::filter_to_vec(&Some(2u), is_even) == ~[2]);\n+    assert!(old_iter::filter_to_vec(&None::<uint>, is_even) == ~[]);\n+    assert!(old_iter::filter_to_vec(&Some(1u), is_even) == ~[]);\n+    assert!(old_iter::filter_to_vec(&Some(2u), is_even) == ~[2]);\n }"}, {"sha": "d9a7791527e446c14a752ab2d06c75668bf925c1", "filename": "src/test/run-pass/iter-flat-map-to-vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -17,13 +17,13 @@ fn incd_if_even(x: &uint) -> Option<uint> {\n pub fn main() {\n     assert!((~[1u, 3u]).flat_map_to_vec(repeat) == ~[1u, 1u, 3u, 3u]);\n     assert!((~[]).flat_map_to_vec(repeat) == ~[]);\n-    assert!(iter::flat_map_to_vec(&None::<uint>, repeat) == ~[]);\n-    assert!(iter::flat_map_to_vec(&Some(1u), repeat) == ~[1u, 1u]);\n-    assert!(iter::flat_map_to_vec(&Some(2u), repeat) == ~[2u, 2u]);\n+    assert!(old_iter::flat_map_to_vec(&None::<uint>, repeat) == ~[]);\n+    assert!(old_iter::flat_map_to_vec(&Some(1u), repeat) == ~[1u, 1u]);\n+    assert!(old_iter::flat_map_to_vec(&Some(2u), repeat) == ~[2u, 2u]);\n \n     assert!((~[1u, 2u, 5u]).flat_map_to_vec(incd_if_even) == ~[3u]);\n     assert!((~[]).flat_map_to_vec(incd_if_even) == ~[]);\n-    assert!(iter::flat_map_to_vec(&None::<uint>, incd_if_even) == ~[]);\n-    assert!(iter::flat_map_to_vec(&Some(1u), incd_if_even) == ~[]);\n-    assert!(iter::flat_map_to_vec(&Some(2u), incd_if_even) == ~[3u]);\n+    assert!(old_iter::flat_map_to_vec(&None::<uint>, incd_if_even) == ~[]);\n+    assert!(old_iter::flat_map_to_vec(&Some(1u), incd_if_even) == ~[]);\n+    assert!(old_iter::flat_map_to_vec(&Some(2u), incd_if_even) == ~[3u]);\n }"}, {"sha": "b299cf8322505b5ed3513dc11fc7c39ec2959194", "filename": "src/test/run-pass/iter-foldl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-foldl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-foldl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-foldl.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -13,7 +13,7 @@ fn add(x: &float, y: &uint) -> float { *x + ((*y) as float) }\n pub fn main() {\n     assert!([1u, 3u].foldl(20f, add) == 24f);\n     assert!([].foldl(20f, add) == 20f);\n-    assert!(iter::foldl(&None::<uint>, 20f, add) == 20f);\n-    assert!(iter::foldl(&Some(1u), 20f, add) == 21f);\n-    assert!(iter::foldl(&Some(2u), 20f, add) == 22f);\n+    assert!(old_iter::foldl(&None::<uint>, 20f, add) == 20f);\n+    assert!(old_iter::foldl(&Some(1u), 20f, add) == 21f);\n+    assert!(old_iter::foldl(&Some(2u), 20f, add) == 22f);\n }"}, {"sha": "4e9976e4eb9d33a3a58a368af7e908ba51015f1c", "filename": "src/test/run-pass/iter-map-to-vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -13,7 +13,7 @@ fn inc(x: &uint) -> uint { *x + 1 }\n pub fn main() {\n     assert!([1, 3].map_to_vec(inc) == ~[2, 4]);\n     assert!([1, 2, 3].map_to_vec(inc) == ~[2, 3, 4]);\n-    assert!(iter::map_to_vec(&None::<uint>, inc) == ~[]);\n-    assert!(iter::map_to_vec(&Some(1u), inc) == ~[2]);\n-    assert!(iter::map_to_vec(&Some(2u), inc) == ~[3]);\n+    assert!(old_iter::map_to_vec(&None::<uint>, inc) == ~[]);\n+    assert!(old_iter::map_to_vec(&Some(1u), inc) == ~[2]);\n+    assert!(old_iter::map_to_vec(&Some(2u), inc) == ~[3]);\n }"}, {"sha": "a8831a9c5ad590544235b3e68507b72620b6c2f4", "filename": "src/test/run-pass/iter-min-max.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-min-max.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-min-max.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-min-max.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -13,9 +13,9 @@ fn is_even(&&x: uint) -> bool { (x % 2u) == 0u }\n pub fn main() {\n     assert!([1u, 3u].min() == 1u);\n     assert!([3u, 1u].min() == 1u);\n-    assert!(iter::min(&Some(1u)) == 1u);\n+    assert!(old_iter::min(&Some(1u)) == 1u);\n \n     assert!([1u, 3u].max() == 3u);\n     assert!([3u, 1u].max() == 3u);\n-    assert!(iter::max(&Some(3u)) == 3u);\n+    assert!(old_iter::max(&Some(3u)) == 3u);\n }"}, {"sha": "d7fdcdbe4e0a0f5140122ab14ea54426e3d2e15b", "filename": "src/test/run-pass/iter-to-vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -12,7 +12,7 @@ pub fn main() {\n     assert!([1u, 3u].to_vec() == ~[1u, 3u]);\n     let e: ~[uint] = ~[];\n     assert!(e.to_vec() == ~[]);\n-    assert!(iter::to_vec(&None::<uint>) == ~[]);\n-    assert!(iter::to_vec(&Some(1u)) == ~[1u]);\n-    assert!(iter::to_vec(&Some(2u)) == ~[2u]);\n+    assert!(old_iter::to_vec(&None::<uint>) == ~[]);\n+    assert!(old_iter::to_vec(&Some(1u)) == ~[1u]);\n+    assert!(old_iter::to_vec(&Some(2u)) == ~[2u]);\n }"}]}