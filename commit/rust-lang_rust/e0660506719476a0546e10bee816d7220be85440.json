{"sha": "e0660506719476a0546e10bee816d7220be85440", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNjYwNTA2NzE5NDc2YTA1NDZlMTBiZWU4MTZkNzIyMGJlODU0NDA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-27T18:21:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-27T18:21:10Z"}, "message": "use names everywhere", "tree": {"sha": "b9b338b6f6eb6332790e01771a0b2bdee13248de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9b338b6f6eb6332790e01771a0b2bdee13248de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0660506719476a0546e10bee816d7220be85440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0660506719476a0546e10bee816d7220be85440", "html_url": "https://github.com/rust-lang/rust/commit/e0660506719476a0546e10bee816d7220be85440", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0660506719476a0546e10bee816d7220be85440/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63f54d234f0d622d043dca8176f0715889a6ed48", "url": "https://api.github.com/repos/rust-lang/rust/commits/63f54d234f0d622d043dca8176f0715889a6ed48", "html_url": "https://github.com/rust-lang/rust/commit/63f54d234f0d622d043dca8176f0715889a6ed48"}], "stats": {"total": 81, "additions": 51, "deletions": 30}, "files": [{"sha": "0471a2fca560fb7ecae764cf7df6afe6b7903da8", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0660506719476a0546e10bee816d7220be85440/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0660506719476a0546e10bee816d7220be85440/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=e0660506719476a0546e10bee816d7220be85440", "patch": "@@ -243,7 +243,7 @@ impl AnalysisImpl {\n                     rr.add_resolution(\n                         position.file_id,\n                         FileSymbol {\n-                            name: entry.name().clone(),\n+                            name: entry.name().to_string().into(),\n                             node_range: entry.ptr().range(),\n                             kind: NAME,\n                         },\n@@ -261,23 +261,21 @@ impl AnalysisImpl {\n             let mut rr = ReferenceResolution::new(name.syntax().range());\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n-                    let parent_module =\n-                        source_binder::module_from_file_id(&*self.db, position.file_id)?;\n-                    let child_name = module.name();\n-                    match (parent_module, child_name) {\n-                        (Some(parent_module), Some(child_name)) => {\n-                            if let Some(child) = parent_module.child(&child_name.text()) {\n-                                let file_id = child.source().file_id();\n-                                let symbol = FileSymbol {\n-                                    name: child_name.text(),\n-                                    node_range: TextRange::offset_len(0.into(), 0.into()),\n-                                    kind: MODULE,\n-                                };\n-                                rr.add_resolution(file_id, symbol);\n-                                return Ok(Some(rr));\n-                            }\n-                        }\n-                        _ => (),\n+                    if let Some(child_module) =\n+                        source_binder::module_from_declaration(&*self.db, position.file_id, module)?\n+                    {\n+                        let file_id = child_module.source().file_id();\n+                        let name = match child_module.name() {\n+                            Some(name) => name.to_string().into(),\n+                            None => \"\".into(),\n+                        };\n+                        let symbol = FileSymbol {\n+                            name,\n+                            node_range: TextRange::offset_len(0.into(), 0.into()),\n+                            kind: MODULE,\n+                        };\n+                        rr.add_resolution(file_id, symbol);\n+                        return Ok(Some(rr));\n                     }\n                 }\n             }"}, {"sha": "3e4cfad0c4b8178bc1238707bbfa8ee474cdde55", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0660506719476a0546e10bee816d7220be85440/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0660506719476a0546e10bee816d7220be85440/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=e0660506719476a0546e10bee816d7220be85440", "patch": "@@ -1,14 +1,15 @@\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    AstNode, SmolStr, SyntaxNodeRef, TextUnit, TextRange,\n+    AstNode, SyntaxNodeRef, TextUnit, TextRange,\n     algo::generate,\n     ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n };\n use ra_db::LocalSyntaxPtr;\n \n use crate::{\n     arena::{Arena, Id},\n+    Name, AsName,\n };\n \n pub(crate) type ScopeId = Id<ScopeData>;\n@@ -22,7 +23,7 @@ pub struct FnScopes {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct ScopeEntry {\n-    name: SmolStr,\n+    name: Name,\n     ptr: LocalSyntaxPtr,\n }\n \n@@ -101,11 +102,12 @@ impl FnScopes {\n \n     pub fn resolve_local_name<'a>(&'a self, name_ref: ast::NameRef) -> Option<&'a ScopeEntry> {\n         let mut shadowed = FxHashSet::default();\n+        let name = name_ref.as_name();\n         let ret = self\n             .scope_chain(name_ref.syntax())\n             .flat_map(|scope| self.entries(scope).iter())\n             .filter(|entry| shadowed.insert(entry.name()))\n-            .filter(|entry| entry.name() == &name_ref.text())\n+            .filter(|entry| entry.name() == &name)\n             .nth(0);\n         ret\n     }\n@@ -170,14 +172,14 @@ impl FnScopes {\n \n impl ScopeEntry {\n     fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n-        let name = pat.name()?;\n+        let name = pat.name()?.as_name();\n         let res = ScopeEntry {\n-            name: name.text(),\n+            name,\n             ptr: LocalSyntaxPtr::new(pat.syntax()),\n         };\n         Some(res)\n     }\n-    pub fn name(&self) -> &SmolStr {\n+    pub fn name(&self) -> &Name {\n         &self.name\n     }\n     pub fn ptr(&self) -> LocalSyntaxPtr {\n@@ -334,7 +336,7 @@ pub struct ReferenceDescriptor {\n mod tests {\n     use ra_editor::find_node_at_offset;\n     use ra_syntax::SourceFileNode;\n-    use test_utils::extract_offset;\n+    use test_utils::{extract_offset, assert_eq_text};\n \n     use super::*;\n \n@@ -355,9 +357,11 @@ mod tests {\n         let actual = scopes\n             .scope_chain(marker.syntax())\n             .flat_map(|scope| scopes.entries(scope))\n-            .map(|it| it.name())\n-            .collect::<Vec<_>>();\n-        assert_eq!(actual.as_slice(), expected);\n+            .map(|it| it.name().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let expected = expected.join(\"\\n\");\n+        assert_eq_text!(&actual, &expected);\n     }\n \n     #[test]"}, {"sha": "a0d1daf7111352dd220ca7add60ddc21a98a291c", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0660506719476a0546e10bee816d7220be85440/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0660506719476a0546e10bee816d7220be85440/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=e0660506719476a0546e10bee816d7220be85440", "patch": "@@ -8,14 +8,14 @@\n use ra_db::{FileId, FilePosition, Cancelable};\n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, NameOwner},\n     SyntaxNodeRef,\n };\n \n use crate::{\n     HirDatabase, Module, Function, SourceItemId,\n     module::ModuleSource,\n-    DefKind, DefLoc\n+    DefKind, DefLoc, AsName,\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -24,6 +24,25 @@ pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable\n     module_from_source(db, module_source)\n }\n \n+/// Locates the child module by `mod child;` declaration.\n+pub fn module_from_declaration(\n+    db: &impl HirDatabase,\n+    file_id: FileId,\n+    decl: ast::Module,\n+) -> Cancelable<Option<Module>> {\n+    let parent_module = module_from_file_id(db, file_id)?;\n+    let child_name = decl.name();\n+    match (parent_module, child_name) {\n+        (Some(parent_module), Some(child_name)) => {\n+            if let Some(child) = parent_module.child(&child_name.as_name()) {\n+                return Ok(Some(child));\n+            }\n+        }\n+        _ => (),\n+    }\n+    Ok(None)\n+}\n+\n /// Locates the module by position in the source code.\n pub fn module_from_position(\n     db: &impl HirDatabase,"}]}