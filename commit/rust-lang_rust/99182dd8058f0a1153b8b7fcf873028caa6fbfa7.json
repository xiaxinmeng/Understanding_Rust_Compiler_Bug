{"sha": "99182dd8058f0a1153b8b7fcf873028caa6fbfa7", "node_id": "C_kwDOAAsO6NoAKDk5MTgyZGQ4MDU4ZjBhMTE1M2I4YjdmY2Y4NzMwMjhjYWE2ZmJmYTc", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-10-06T20:46:15Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-10-06T20:46:15Z"}, "message": "std: use semaphore for thread parking on Apple platforms", "tree": {"sha": "7cf15f528664bccbf62ec76c41314f20d33425ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cf15f528664bccbf62ec76c41314f20d33425ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99182dd8058f0a1153b8b7fcf873028caa6fbfa7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmM/PpcACgkQcE4BSbAZ\nSzxJ3hAAiwge+cyevF/P7jjSNJOHilv8U1k+FIrQktyAIeDnM77lBTT/bhj7ixFD\nwk9+1ZDBMxA9yAPj7g+Tkwnm7y0B4UXrkM3GgwioemQBcHZLVcT53RIfzd/wyV3N\noiJRs4TTV5bCKHO3PVyjqIi/N3Oll5i9vhdtw85H+2oxfpjyLVEtnYBavCCcT23n\nuRr8S1Jk1EOacSy8oW/Z4UfZw6/6dInamSCUbPbiOO1XJcfJaNgafSeIf3dL4ZQI\nKSk/WYU5tdWXFBAgG9kxf+2B8kZ3uLUx+oZhc0PNyqTG5OjMesouOiSV6crgQMtM\nAoK490cyiwR0n+7Gvu/RdwmxCBfGZP8LUPlgx0hPC2aWqYyWvtl/V6OZeFMudO51\n6mV5a0c+QjtPX59FOLuG6VlK3RZmo5byZgz7ss3dz89BBL30cZPl21uRfD8z2v7F\nmxfnERT4rybEhs+KF2KLq56S7haMdbF6JF5IQwXyk9UMstr6/tfZ+ubRHEe4Y1zU\ntlybxm31KSwKo6QG6un+pb5FNCXkIKSp7qnrzD5B5IaEorxu+2cCfdohxN3slhAY\nVfXyzNfvDxG7CjLr2GTQSeF8K13FcCnGDFRe6PoJT8fO2q8pFmenPzCyAmG8ccYf\nt1Ast5mgMHHRJ+/8F6L8Y6Xxt7Nw9TrV9EJ9PBfCc8AUKKeh+1I=\n=/L/W\n-----END PGP SIGNATURE-----", "payload": "tree 7cf15f528664bccbf62ec76c41314f20d33425ad\nparent 75ada3a1534fbc4801c73fafecd0f7455f1e3419\nauthor joboet <jonasboettiger@icloud.com> 1665089175 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1665089175 +0200\n\nstd: use semaphore for thread parking on Apple platforms\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99182dd8058f0a1153b8b7fcf873028caa6fbfa7", "html_url": "https://github.com/rust-lang/rust/commit/99182dd8058f0a1153b8b7fcf873028caa6fbfa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99182dd8058f0a1153b8b7fcf873028caa6fbfa7/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75ada3a1534fbc4801c73fafecd0f7455f1e3419", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ada3a1534fbc4801c73fafecd0f7455f1e3419", "html_url": "https://github.com/rust-lang/rust/commit/75ada3a1534fbc4801c73fafecd0f7455f1e3419"}], "stats": {"total": 141, "additions": 140, "deletions": 1}, "files": [{"sha": "510839d5dafbf7630826b8adfc6f9f65adac5e57", "filename": "library/std/src/sys/unix/thread_parker/darwin.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/99182dd8058f0a1153b8b7fcf873028caa6fbfa7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99182dd8058f0a1153b8b7fcf873028caa6fbfa7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs?ref=99182dd8058f0a1153b8b7fcf873028caa6fbfa7", "patch": "@@ -0,0 +1,131 @@\n+//! Thread parking for Darwin-based systems.\n+//!\n+//! Darwin actually has futex syscalls (`__ulock_wait`/`__ulock_wake`), but they\n+//! cannot be used in `std` because they are non-public (their use will lead to\n+//! rejection from the App Store) and because they are only available starting\n+//! with macOS version 10.12, even though the minimum target version is 10.7.\n+//!\n+//! Therefore, we need to look for other synchronization primitives. Luckily, Darwin\n+//! supports semaphores, which allow us to implement the behaviour we need with\n+//! only one primitive (as opposed to a mutex-condvar pair). We use the semaphore\n+//! provided by libdispatch, as the underlying Mach semaphore is only dubiously\n+//! public.\n+\n+use crate::pin::Pin;\n+use crate::sync::atomic::{\n+    AtomicI8,\n+    Ordering::{Acquire, Release},\n+};\n+use crate::time::Duration;\n+\n+type dispatch_semaphore_t = *mut crate::ffi::c_void;\n+type dispatch_time_t = u64;\n+\n+const DISPATCH_TIME_NOW: dispatch_time_t = 0;\n+const DISPATCH_TIME_FOREVER: dispatch_time_t = !0;\n+\n+#[link(name = \"System\", kind = \"dylib\")]\n+extern \"C\" {\n+    fn dispatch_time(when: dispatch_time_t, delta: i64) -> dispatch_time_t;\n+    fn dispatch_semaphore_create(val: isize) -> dispatch_semaphore_t;\n+    fn dispatch_semaphore_wait(dsema: dispatch_semaphore_t, timeout: dispatch_time_t) -> isize;\n+    fn dispatch_semaphore_signal(dsema: dispatch_semaphore_t) -> isize;\n+    fn dispatch_release(object: *mut crate::ffi::c_void);\n+}\n+\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+const PARKED: i8 = -1;\n+\n+pub struct Parker {\n+    semaphore: dispatch_semaphore_t,\n+    state: AtomicI8,\n+}\n+\n+unsafe impl Sync for Parker {}\n+unsafe impl Send for Parker {}\n+\n+impl Parker {\n+    pub unsafe fn new(parker: *mut Parker) {\n+        let semaphore = dispatch_semaphore_create(0);\n+        assert!(\n+            !semaphore.is_null(),\n+            \"failed to create dispatch semaphore for thread synchronization\"\n+        );\n+        parker.write(Parker { semaphore, state: AtomicI8::new(EMPTY) })\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        // The semaphore counter must be zero at this point, because unparking\n+        // threads will not actually increase it until we signalled that we\n+        // are waiting.\n+\n+        // Change NOTIFIED to EMPTY and EMPTY to PARKED.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        // Another thread may increase the semaphore counter from this point on.\n+        // If it is faster than us, we will decrement it again immediately below.\n+        // If we are faster, we wait.\n+\n+        // Ensure that the semaphore counter has actually been decremented, even\n+        // if the call timed out for some reason.\n+        while dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) != 0 {}\n+\n+        // At this point, the semaphore counter is zero again.\n+\n+        // We were definitely woken up, so we don't need to check the state.\n+        // Still, we need to reset the state using a swap to observe the state\n+        // change with acquire ordering.\n+        self.state.swap(EMPTY, Acquire);\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        let nanos = dur.as_nanos().try_into().unwrap_or(i64::MAX);\n+        let timeout = dispatch_time(DISPATCH_TIME_NOW, nanos);\n+\n+        let timeout = dispatch_semaphore_wait(self.semaphore, timeout) != 0;\n+\n+        let state = self.state.swap(EMPTY, Acquire);\n+        if state == NOTIFIED && timeout {\n+            // If the state was NOTIFIED but semaphore_wait returned without\n+            // decrementing the count because of a timeout, it means another\n+            // thread is about to call semaphore_signal. We must wait for that\n+            // to happen to ensure the semaphore count is reset.\n+            while dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) != 0 {}\n+        } else {\n+            // Either a timeout occurred and we reset the state before any thread\n+            // tried to wake us up, or we were woken up and reset the state,\n+            // making sure to observe the state change with acquire ordering.\n+            // Either way, the semaphore counter is now zero again.\n+        }\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if state == PARKED {\n+            unsafe {\n+                dispatch_semaphore_signal(self.semaphore);\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Parker {\n+    fn drop(&mut self) {\n+        // SAFETY:\n+        // We always ensure that the semaphore count is reset, so this will\n+        // never cause an exception.\n+        unsafe {\n+            dispatch_release(self.semaphore);\n+        }\n+    }\n+}"}, {"sha": "724ec2d482edb6330828fc7e6b7e93f05693a7a7", "filename": "library/std/src/sys/unix/thread_parker/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99182dd8058f0a1153b8b7fcf873028caa6fbfa7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99182dd8058f0a1153b8b7fcf873028caa6fbfa7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs?ref=99182dd8058f0a1153b8b7fcf873028caa6fbfa7", "patch": "@@ -11,7 +11,15 @@\n )))]\n \n cfg_if::cfg_if! {\n-    if #[cfg(target_os = \"netbsd\")] {\n+    if #[cfg(any(\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"watchos\",\n+        target_os = \"tvos\",\n+    ))] {\n+        mod darwin;\n+        pub use darwin::Parker;\n+    } else if #[cfg(target_os = \"netbsd\")] {\n         mod netbsd;\n         pub use netbsd::Parker;\n     } else {"}]}