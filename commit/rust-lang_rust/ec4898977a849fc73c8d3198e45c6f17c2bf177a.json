{"sha": "ec4898977a849fc73c8d3198e45c6f17c2bf177a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNDg5ODk3N2E4NDlmYzczYzhkMzE5OGU0NWM2ZjE3YzJiZjE3N2E=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-28T15:30:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-28T15:30:22Z"}, "message": "Rollup merge of #73577 - VillSnow:master, r=Amanieu\n\nAdd partition_point\n\nAdd partition_point in C++.\nAlthough existing binary_search in rust does not suitable when the slice has multiple hits,\nthis function returns exact point of partition.\nThe definition of this function is very clear and able to accept general matter, therefore you can easily get index which you want like lower/upper_bound.\n\nhttps://github.com/rust-lang/rfcs/issues/2184", "tree": {"sha": "8abe212f831aa30f49239dbb3f52349ee5d6244f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8abe212f831aa30f49239dbb3f52349ee5d6244f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec4898977a849fc73c8d3198e45c6f17c2bf177a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+LeOCRBK7hj4Ov3rIwAAdHIIAFdMIeZGwFsTYCr62h09cgQI\nN8pDTVjl9VL1tnY9c+VEDmVNG+51BXj0Fg9EOxD3W5CF51vtV83vSDmnL+fPk7mF\nNMNpgJw0hTOm0r7LUX5TF9rlusnOBnRJYDKSfXvMz0cVjuA8YrIPh5KNw+E294vj\nb7m3f0GGa0Nx/y31tSqbzOEqXJCis4DkZeFSDgRxw4rc9vBRCiktgL3ZdT/eUbaa\n7DMYurdpwSDtrTD59TN/uDNnrJcsxx1QIKhpJaef0RmErgSQEb7AzBoyY/HfJA7j\nMx2/tDOOiR91Y8RPP9DSh//0eZS934Vwmv8jj1MmFOUXHgOIfODUS5DNgRDuXHA=\n=Pel9\n-----END PGP SIGNATURE-----\n", "payload": "tree 8abe212f831aa30f49239dbb3f52349ee5d6244f\nparent 25687caa2e4e35b31c29e28998710670e9d54ee9\nparent 6f8ad3b20858c6c63c2098e690fddf0f33a80d2b\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593358222 -0700\ncommitter GitHub <noreply@github.com> 1593358222 -0700\n\nRollup merge of #73577 - VillSnow:master, r=Amanieu\n\nAdd partition_point\n\nAdd partition_point in C++.\nAlthough existing binary_search in rust does not suitable when the slice has multiple hits,\nthis function returns exact point of partition.\nThe definition of this function is very clear and able to accept general matter, therefore you can easily get index which you want like lower/upper_bound.\n\nhttps://github.com/rust-lang/rfcs/issues/2184\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4898977a849fc73c8d3198e45c6f17c2bf177a", "html_url": "https://github.com/rust-lang/rust/commit/ec4898977a849fc73c8d3198e45c6f17c2bf177a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec4898977a849fc73c8d3198e45c6f17c2bf177a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25687caa2e4e35b31c29e28998710670e9d54ee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/25687caa2e4e35b31c29e28998710670e9d54ee9", "html_url": "https://github.com/rust-lang/rust/commit/25687caa2e4e35b31c29e28998710670e9d54ee9"}, {"sha": "6f8ad3b20858c6c63c2098e690fddf0f33a80d2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8ad3b20858c6c63c2098e690fddf0f33a80d2b", "html_url": "https://github.com/rust-lang/rust/commit/6f8ad3b20858c6c63c2098e690fddf0f33a80d2b"}], "stats": {"total": 95, "additions": 95, "deletions": 0}, "files": [{"sha": "6a50cdbc1d9fb78b5ec9379afe980e6069b38e69", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ec4898977a849fc73c8d3198e45c6f17c2bf177a/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec4898977a849fc73c8d3198e45c6f17c2bf177a/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=ec4898977a849fc73c8d3198e45c6f17c2bf177a", "patch": "@@ -2663,6 +2663,60 @@ impl<T> [T] {\n     {\n         self.iter().is_sorted_by_key(f)\n     }\n+\n+    /// Returns the index of the partition point according to the given predicate\n+    /// (the index of the first element of the second partition).\n+    ///\n+    /// The slice is assumed to be partitioned according to the given predicate.\n+    /// This means that all elements for which the predicate returns true are at the start of the slice\n+    /// and all elements for which the predicate returns false are at the end.\n+    /// For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0\n+    /// (all odd numbers are at the start, all even at the end).\n+    ///\n+    /// If this slice is not partitioned, the returned result is unspecified and meaningless,\n+    /// as this method performs a kind of binary search.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(partition_point)]\n+    ///\n+    /// let v = [1, 2, 3, 3, 5, 6, 7];\n+    /// let i = v.partition_point(|&x| x < 5);\n+    ///\n+    /// assert_eq!(i, 4);\n+    /// assert!(v[..i].iter().all(|&x| x < 5));\n+    /// assert!(v[i..].iter().all(|&x| !(x < 5)));\n+    /// ```\n+    #[unstable(feature = \"partition_point\", reason = \"new API\", issue = \"73831\")]\n+    pub fn partition_point<P>(&self, mut pred: P) -> usize\n+    where\n+        P: FnMut(&T) -> bool,\n+    {\n+        let mut left = 0;\n+        let mut right = self.len();\n+\n+        while left != right {\n+            let mid = left + (right - left) / 2;\n+            // SAFETY:\n+            // When left < right, left <= mid < right.\n+            // Therefore left always increases and right always decreases,\n+            // and eigher of them is selected.\n+            // In both cases left <= right is satisfied.\n+            // Therefore if left < right in a step,\n+            // left <= right is satisfied in the next step.\n+            // Therefore as long as left != right, 0 <= left < right <= len is satisfied\n+            // and if this case 0 <= mid < len is satisfied too.\n+            let value = unsafe { self.get_unchecked(mid) };\n+            if pred(value) {\n+                left = mid + 1;\n+            } else {\n+                right = mid;\n+            }\n+        }\n+\n+        left\n+    }\n }\n \n #[lang = \"slice_u8\"]"}, {"sha": "524c38a7ab4c1f1a0a2bdca82bc791823d38ac9d", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec4898977a849fc73c8d3198e45c6f17c2bf177a/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec4898977a849fc73c8d3198e45c6f17c2bf177a/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=ec4898977a849fc73c8d3198e45c6f17c2bf177a", "patch": "@@ -44,6 +44,7 @@\n #![feature(const_forget)]\n #![feature(option_unwrap_none)]\n #![feature(peekable_next_if)]\n+#![feature(partition_point)]\n \n extern crate test;\n "}, {"sha": "fba73be92be09b527971a4e410dbf302106ce498", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ec4898977a849fc73c8d3198e45c6f17c2bf177a/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec4898977a849fc73c8d3198e45c6f17c2bf177a/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=ec4898977a849fc73c8d3198e45c6f17c2bf177a", "patch": "@@ -81,6 +81,46 @@ fn test_binary_search_implementation_details() {\n     assert_eq!(b.binary_search(&3), Ok(8));\n }\n \n+#[test]\n+fn test_partition_point() {\n+    let b: [i32; 0] = [];\n+    assert_eq!(b.partition_point(|&x| x < 5), 0);\n+\n+    let b = [4];\n+    assert_eq!(b.partition_point(|&x| x < 3), 0);\n+    assert_eq!(b.partition_point(|&x| x < 4), 0);\n+    assert_eq!(b.partition_point(|&x| x < 5), 1);\n+\n+    let b = [1, 2, 4, 6, 8, 9];\n+    assert_eq!(b.partition_point(|&x| x < 5), 3);\n+    assert_eq!(b.partition_point(|&x| x < 6), 3);\n+    assert_eq!(b.partition_point(|&x| x < 7), 4);\n+    assert_eq!(b.partition_point(|&x| x < 8), 4);\n+\n+    let b = [1, 2, 4, 5, 6, 8];\n+    assert_eq!(b.partition_point(|&x| x < 9), 6);\n+\n+    let b = [1, 2, 4, 6, 7, 8, 9];\n+    assert_eq!(b.partition_point(|&x| x < 6), 3);\n+    assert_eq!(b.partition_point(|&x| x < 5), 3);\n+    assert_eq!(b.partition_point(|&x| x < 8), 5);\n+\n+    let b = [1, 2, 4, 5, 6, 8, 9];\n+    assert_eq!(b.partition_point(|&x| x < 7), 5);\n+    assert_eq!(b.partition_point(|&x| x < 0), 0);\n+\n+    let b = [1, 3, 3, 3, 7];\n+    assert_eq!(b.partition_point(|&x| x < 0), 0);\n+    assert_eq!(b.partition_point(|&x| x < 1), 0);\n+    assert_eq!(b.partition_point(|&x| x < 2), 1);\n+    assert_eq!(b.partition_point(|&x| x < 3), 1);\n+    assert_eq!(b.partition_point(|&x| x < 4), 4);\n+    assert_eq!(b.partition_point(|&x| x < 5), 4);\n+    assert_eq!(b.partition_point(|&x| x < 6), 4);\n+    assert_eq!(b.partition_point(|&x| x < 7), 4);\n+    assert_eq!(b.partition_point(|&x| x < 8), 5);\n+}\n+\n #[test]\n fn test_iterator_nth() {\n     let v: &[_] = &[0, 1, 2, 3, 4];"}]}