{"sha": "00684d708b64fe81a0264795f27594d450a8d08d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNjg0ZDcwOGI2NGZlODFhMDI2NDc5NWYyNzU5NGQ0NTBhOGQwOGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-21T12:24:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-21T12:24:51Z"}, "message": "Decouple", "tree": {"sha": "031d8f3859fd7d38279c96be34afb09c85e2f74d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/031d8f3859fd7d38279c96be34afb09c85e2f74d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00684d708b64fe81a0264795f27594d450a8d08d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00684d708b64fe81a0264795f27594d450a8d08d", "html_url": "https://github.com/rust-lang/rust/commit/00684d708b64fe81a0264795f27594d450a8d08d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00684d708b64fe81a0264795f27594d450a8d08d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb53aa37a336b6c9369ea931812f6c491e8f4a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb53aa37a336b6c9369ea931812f6c491e8f4a71", "html_url": "https://github.com/rust-lang/rust/commit/eb53aa37a336b6c9369ea931812f6c491e8f4a71"}], "stats": {"total": 102, "additions": 53, "deletions": 49}, "files": [{"sha": "a3e9d8525f2076bf86b1d6880cffe0d80761e727", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=00684d708b64fe81a0264795f27594d450a8d08d", "patch": "@@ -9,10 +9,16 @@ use hir_def::{\n };\n \n use crate::{\n-    ty::TypableDef, Adt, AssocItem, Const, DefWithBody, EnumVariant, Function, GenericDef,\n+    ty::TypableDef, Adt, AssocItem, Const, Crate, DefWithBody, EnumVariant, Function, GenericDef,\n     ModuleDef, Static, TypeAlias,\n };\n \n+impl From<ra_db::CrateId> for Crate {\n+    fn from(crate_id: ra_db::CrateId) -> Self {\n+        Crate { crate_id }\n+    }\n+}\n+\n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n         impl From<$id> for $ty {"}, {"sha": "a616f0ea5721bbf41b96de4f66c939505da93c06", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=00684d708b64fe81a0264795f27594d450a8d08d", "patch": "@@ -2,25 +2,23 @@\n use std::sync::Arc;\n \n use hir_def::{\n+    body::scope::{ExprScopes, ScopeId},\n     builtin_type::BuiltinType,\n     db::DefDatabase2,\n-    expr::ExprId,\n+    expr::{ExprId, PatId},\n     generics::GenericParams,\n-    nameres::CrateDefMap,\n+    nameres::{per_ns::PerNs, CrateDefMap},\n     path::{Path, PathKind},\n     AdtId, AstItemDef, ConstId, ContainerId, CrateModuleId, DefWithBodyId, EnumId, EnumVariantId,\n     FunctionId, GenericDefId, ImplId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId,\n     TypeAliasId, UnionId,\n };\n-use hir_expand::name::{self, Name};\n-use rustc_hash::FxHashSet;\n-\n-use crate::{\n-    code_model::Crate,\n-    db::HirDatabase,\n-    expr::{ExprScopes, PatId, ScopeId},\n-    DefWithBody, GenericDef, MacroDef, PerNs,\n+use hir_expand::{\n+    name::{self, Name},\n+    MacroDefId,\n };\n+use ra_db::CrateId;\n+use rustc_hash::FxHashSet;\n \n #[derive(Debug, Clone, Default)]\n pub(crate) struct Resolver {\n@@ -318,9 +316,9 @@ impl Resolver {\n         &self,\n         db: &impl DefDatabase2,\n         path: &Path,\n-    ) -> Option<MacroDef> {\n+    ) -> Option<MacroDefId> {\n         let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path).0.get_macros().map(MacroDef::from)\n+        item_map.resolve_path(db, module, path).0.get_macros()\n     }\n \n     pub(crate) fn process_all_names(\n@@ -355,8 +353,8 @@ impl Resolver {\n         })\n     }\n \n-    pub(crate) fn krate(&self) -> Option<Crate> {\n-        self.module().map(|t| Crate { crate_id: t.0.krate() })\n+    pub(crate) fn krate(&self) -> Option<CrateId> {\n+        self.module().map(|t| t.0.krate())\n     }\n \n     pub(crate) fn where_predicates_in_scope<'a>(\n@@ -484,7 +482,7 @@ impl Scope {\n \n // needs arbitrary_self_types to be a method... or maybe move to the def?\n pub(crate) fn resolver_for_expr(\n-    db: &impl HirDatabase,\n+    db: &impl DefDatabase2,\n     owner: DefWithBodyId,\n     expr_id: ExprId,\n ) -> Resolver {\n@@ -493,7 +491,7 @@ pub(crate) fn resolver_for_expr(\n }\n \n pub(crate) fn resolver_for_scope(\n-    db: &impl HirDatabase,\n+    db: &impl DefDatabase2,\n     owner: DefWithBodyId,\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n@@ -623,15 +621,3 @@ impl HasResolver for ImplId {\n             .push_impl_block_scope(self)\n     }\n }\n-\n-impl HasResolver for GenericDef {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n-        GenericDefId::from(self).resolver(db)\n-    }\n-}\n-\n-impl HasResolver for DefWithBody {\n-    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n-        DefWithBodyId::from(self).resolver(db)\n-    }\n-}"}, {"sha": "898b823c0b0a4ddd00adea13c7f79f846ae268d4", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=00684d708b64fe81a0264795f27594d450a8d08d", "patch": "@@ -10,6 +10,7 @@ use std::sync::Arc;\n use hir_def::{\n     expr::{ExprId, PatId},\n     path::known,\n+    DefWithBodyId,\n };\n use hir_expand::{name::AsName, AstId, MacroCallId, MacroCallLoc, MacroFileKind, Source};\n use ra_syntax::{\n@@ -51,7 +52,9 @@ fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -\n             },\n             _ => match node.value.kind() {\n                 FN_DEF | CONST_DEF | STATIC_DEF => {\n-                    Some(def_with_body_from_child_node(db, node)?.resolver(db))\n+                    let def = def_with_body_from_child_node(db, node)?;\n+                    let def = DefWithBodyId::from(def);\n+                    Some(def.resolver(db))\n                 }\n                 // FIXME add missing cases\n                 _ => None\n@@ -232,7 +235,7 @@ impl SourceAnalyzer {\n     ) -> Option<MacroDef> {\n         // This must be a normal source file rather than macro file.\n         let path = macro_call.path().and_then(Path::from_ast)?;\n-        self.resolver.resolve_path_as_macro(db, &path)\n+        self.resolver.resolve_path_as_macro(db, &path).map(|it| it.into())\n     }\n \n     pub fn resolve_hir_path(\n@@ -275,7 +278,9 @@ impl SourceAnalyzer {\n             .take_types()\n             .map(|it| PathResolution::Def(it.into()));\n         types.or(values).or(items).or_else(|| {\n-            self.resolver.resolve_path_as_macro(db, &path).map(|def| PathResolution::Macro(def))\n+            self.resolver\n+                .resolve_path_as_macro(db, &path)\n+                .map(|def| PathResolution::Macro(def.into()))\n         })\n     }\n \n@@ -420,7 +425,7 @@ impl SourceAnalyzer {\n         };\n \n         let canonical_ty = crate::ty::Canonical { value: ty, num_vars: 0 };\n-        implements_trait(&canonical_ty, db, &self.resolver, krate, std_future_trait)\n+        implements_trait(&canonical_ty, db, &self.resolver, krate.into(), std_future_trait)\n     }\n \n     pub fn expand("}, {"sha": "f774921701c68a8867c69028336bf6e504ea729c", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=00684d708b64fe81a0264795f27594d450a8d08d", "patch": "@@ -39,7 +39,7 @@ fn deref_by_trait(\n     ty: &Canonical<Ty>,\n ) -> Option<Canonical<Ty>> {\n     let krate = resolver.krate()?;\n-    let deref_trait = match db.lang_item(krate, \"deref\".into())? {\n+    let deref_trait = match db.lang_item(krate.into(), \"deref\".into())? {\n         crate::lang_item::LangItemTarget::Trait(t) => t,\n         _ => return None,\n     };\n@@ -71,7 +71,7 @@ fn deref_by_trait(\n \n     let canonical = super::Canonical { num_vars: 1 + ty.num_vars, value: in_env };\n \n-    let solution = db.trait_solve(krate, canonical)?;\n+    let solution = db.trait_solve(krate.into(), canonical)?;\n \n     match &solution {\n         Solution::Unique(vars) => {"}, {"sha": "c3d65afa68801b417b0a3ca5a75ddd73ffb95745", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=00684d708b64fe81a0264795f27594d450a8d08d", "patch": "@@ -24,7 +24,7 @@ use rustc_hash::FxHashMap;\n use hir_def::{\n     path::known,\n     type_ref::{Mutability, TypeRef},\n-    AdtId,\n+    AdtId, DefWithBodyId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n@@ -65,7 +65,7 @@ mod coerce;\n /// The entry point of type inference.\n pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n     let _p = profile(\"infer_query\");\n-    let resolver = def.resolver(db);\n+    let resolver = DefWithBodyId::from(def).resolver(db);\n     let mut ctx = InferenceContext::new(db, def, resolver);\n \n     match def {\n@@ -378,8 +378,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for obligation in obligations {\n             let in_env = InEnvironment::new(self.trait_env.clone(), obligation.clone());\n             let canonicalized = self.canonicalizer().canonicalize_obligation(in_env);\n-            let solution =\n-                self.db.trait_solve(self.resolver.krate().unwrap(), canonicalized.value.clone());\n+            let solution = self\n+                .db\n+                .trait_solve(self.resolver.krate().unwrap().into(), canonicalized.value.clone());\n \n             match solution {\n                 Some(Solution::Unique(substs)) => {"}, {"sha": "6d297c268e24f075fa16744ebfa2be23c74925d6", "filename": "crates/ra_hir/src/ty/infer/coerce.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs?ref=00684d708b64fe81a0264795f27594d450a8d08d", "patch": "@@ -49,8 +49,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         resolver: &Resolver,\n     ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n         let krate = resolver.krate().unwrap();\n-        let impls = match db.lang_item(krate, \"coerce_unsized\".into()) {\n-            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate, trait_),\n+        let impls = match db.lang_item(krate.into(), \"coerce_unsized\".into()) {\n+            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate.into(), trait_),\n             _ => return FxHashMap::default(),\n         };\n "}, {"sha": "e477b2439aac38a6a40ff547012b9f6ad67c5bba", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=00684d708b64fe81a0264795f27594d450a8d08d", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType},\n     path::{GenericArg, PathSegment},\n     type_ref::{TypeBound, TypeRef},\n+    GenericDefId,\n };\n \n use super::{\n@@ -574,7 +575,7 @@ pub(crate) fn generic_predicates_for_param_query(\n     def: GenericDef,\n     param_idx: u32,\n ) -> Arc<[GenericPredicate]> {\n-    let resolver = def.resolver(db);\n+    let resolver = GenericDefId::from(def).resolver(db);\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n@@ -600,7 +601,7 @@ pub(crate) fn generic_predicates_query(\n     db: &impl HirDatabase,\n     def: GenericDef,\n ) -> Arc<[GenericPredicate]> {\n-    let resolver = def.resolver(db);\n+    let resolver = GenericDefId::from(def).resolver(db);\n     resolver\n         .where_predicates_in_scope()\n         .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n@@ -609,7 +610,7 @@ pub(crate) fn generic_predicates_query(\n \n /// Resolve the default type params from generics\n pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) -> Substs {\n-    let resolver = def.resolver(db);\n+    let resolver = GenericDefId::from(def).resolver(db);\n     let generic_params = def.generic_params(db);\n \n     let defaults = generic_params"}, {"sha": "5ad72ef9f579b6f17f062ffb9631149b350dbc2b", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00684d708b64fe81a0264795f27594d450a8d08d/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=00684d708b64fe81a0264795f27594d450a8d08d", "patch": "@@ -172,9 +172,14 @@ pub(crate) fn iterate_method_candidates<T>(\n             // rustc does an autoderef and then autoref again).\n \n             for derefed_ty in autoderef::autoderef(db, resolver, ty.clone()) {\n-                if let Some(result) =\n-                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n-                {\n+                if let Some(result) = iterate_inherent_methods(\n+                    &derefed_ty,\n+                    db,\n+                    name,\n+                    mode,\n+                    krate.into(),\n+                    &mut callback,\n+                ) {\n                     return Some(result);\n                 }\n                 if let Some(result) = iterate_trait_method_candidates(\n@@ -192,7 +197,7 @@ pub(crate) fn iterate_method_candidates<T>(\n         LookupMode::Path => {\n             // No autoderef for path lookups\n             if let Some(result) =\n-                iterate_inherent_methods(&ty, db, name, mode, krate, &mut callback)\n+                iterate_inherent_methods(&ty, db, name, mode, krate.into(), &mut callback)\n             {\n                 return Some(result);\n             }\n@@ -240,7 +245,7 @@ fn iterate_trait_method_candidates<T>(\n             }\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n-                if db.trait_solve(krate, goal).is_none() {\n+                if db.trait_solve(krate.into(), goal).is_none() {\n                     continue 'traits;\n                 }\n             }"}]}