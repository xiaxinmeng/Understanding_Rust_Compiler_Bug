{"sha": "d5fa533ab0bfdbb02a1d37ae7787472b20291f11", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZmE1MzNhYjBiZmRiYjAyYTFkMzdhZTc3ODc0NzJiMjAyOTFmMTE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-05-23T01:23:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-23T01:23:34Z"}, "message": "Rollup merge of #84758 - ChrisDenton:dllimport, r=dtolnay\n\nMSVC: Avoid using jmp stubs for dll function imports\n\nWindows import libraries contain two symbols for every function: `__imp_FunctionName` and `FunctionName` (where `FunctionName` is the name of the function to be imported).\n\n`__imp_FunctionName` contains the address of the imported function. This will be filled in by the Windows executable loader at runtime. `FunctionName` contains a jmp stub that simply jumps to the address given by `__imp_FunctionName`. E.g. it's a function that solely contains a single jmp instruction:\n\n```asm\njmp __imp_FunctionName\n```\n\nWhen using an external DLL function in Rust, by default the linker will link to FunctionName, causing a bit of indirection at runtime. In Microsoft's C++ it's possible to instead tell it to insert calls to the address in `__imp_FunctionName` by using the  `__declspec(dllimport)` attribute. In Rust it's possible to get effectively the same behaviour using the `#[link]` attribute on `extern` blocks.\n\n----\n\nThe second commit also merges multiple `extern` blocks into one block. This is because otherwise Rust will currently create duplicate linker arguments for each block. In this case having duplicates shouldn't matter much other than the noise when displaying the linker command.", "tree": {"sha": "62409fea16da8d4be3e434cab5d282c43eb6af97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62409fea16da8d4be3e434cab5d282c43eb6af97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5fa533ab0bfdbb02a1d37ae7787472b20291f11", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgqa6XCRBK7hj4Ov3rIwAAuMgIABWT8CtGDz34BNYW+l4LMM+E\n5PAFBswzvK+w7nZlJtAQ48mGWaT8CkBjtUaTdUFZMTqgaOyzWE4ECPCyxNQt57Ms\no9gGXnkrt/+sEO2eqZMJVLKeqIGtRK/VCI8ob75bvmfdw1a1lyUISBd1futs6zHc\nDLLyo54+fTyRylj5vz5OPvcpArIfwf+yegxi4WwEcO16RkvVvCCJeGYB42+tufEg\nvnaXbg0wsAQvXIlxwExAFSLCRgxiCCGKAjPkMbyydH9RgilPbk5JCQiZacoUa6mI\nCDG0z56QBww+B3IQWoabwgPR1mUYLw96RngJxnbxVp5phwgvU4eSY/G1nbCfV2U=\n=2tAt\n-----END PGP SIGNATURE-----\n", "payload": "tree 62409fea16da8d4be3e434cab5d282c43eb6af97\nparent e4ca1662f255db774dcd16ed9c3776bf25ac8361\nparent fc40aa059bdf917866e9b22aa9095c654333c88c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1621733014 +0200\ncommitter GitHub <noreply@github.com> 1621733014 +0200\n\nRollup merge of #84758 - ChrisDenton:dllimport, r=dtolnay\n\nMSVC: Avoid using jmp stubs for dll function imports\n\nWindows import libraries contain two symbols for every function: `__imp_FunctionName` and `FunctionName` (where `FunctionName` is the name of the function to be imported).\n\n`__imp_FunctionName` contains the address of the imported function. This will be filled in by the Windows executable loader at runtime. `FunctionName` contains a jmp stub that simply jumps to the address given by `__imp_FunctionName`. E.g. it's a function that solely contains a single jmp instruction:\n\n```asm\njmp __imp_FunctionName\n```\n\nWhen using an external DLL function in Rust, by default the linker will link to FunctionName, causing a bit of indirection at runtime. In Microsoft's C++ it's possible to instead tell it to insert calls to the address in `__imp_FunctionName` by using the  `__declspec(dllimport)` attribute. In Rust it's possible to get effectively the same behaviour using the `#[link]` attribute on `extern` blocks.\n\n----\n\nThe second commit also merges multiple `extern` blocks into one block. This is because otherwise Rust will currently create duplicate linker arguments for each block. In this case having duplicates shouldn't matter much other than the noise when displaying the linker command.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5fa533ab0bfdbb02a1d37ae7787472b20291f11", "html_url": "https://github.com/rust-lang/rust/commit/d5fa533ab0bfdbb02a1d37ae7787472b20291f11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5fa533ab0bfdbb02a1d37ae7787472b20291f11/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4ca1662f255db774dcd16ed9c3776bf25ac8361", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ca1662f255db774dcd16ed9c3776bf25ac8361", "html_url": "https://github.com/rust-lang/rust/commit/e4ca1662f255db774dcd16ed9c3776bf25ac8361"}, {"sha": "fc40aa059bdf917866e9b22aa9095c654333c88c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc40aa059bdf917866e9b22aa9095c654333c88c", "html_url": "https://github.com/rust-lang/rust/commit/fc40aa059bdf917866e9b22aa9095c654333c88c"}], "stats": {"total": 334, "additions": 168, "deletions": 166}, "files": [{"sha": "b7efc884473b417715ebb46142e94acef7e4ba3d", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 168, "deletions": 152, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/d5fa533ab0bfdbb02a1d37ae7787472b20291f11/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5fa533ab0bfdbb02a1d37ae7787472b20291f11/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=d5fa533ab0bfdbb02a1d37ae7787472b20291f11", "patch": "@@ -631,7 +631,7 @@ pub struct timeval {\n     pub tv_usec: c_long,\n }\n \n-// Functions forbidden when targeting UWP\n+// Desktop specific functions & types\n cfg_if::cfg_if! {\n if #[cfg(not(target_vendor = \"uwp\"))] {\n     pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n@@ -645,7 +645,7 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n         pub ExceptionRecord: *mut EXCEPTION_RECORD,\n         pub ExceptionAddress: LPVOID,\n         pub NumberParameters: DWORD,\n-        pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n+        pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS],\n     }\n \n     pub enum CONTEXT {}\n@@ -656,8 +656,8 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n         pub ContextRecord: *mut CONTEXT,\n     }\n \n-    pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n-            fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n+    pub type PVECTORED_EXCEPTION_HANDLER =\n+        extern \"system\" fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n \n     #[repr(C)]\n     #[derive(Copy, Clone)]\n@@ -691,44 +691,66 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n \n     pub const TOKEN_READ: DWORD = 0x20008;\n \n+    #[link(name = \"advapi32\")]\n     extern \"system\" {\n+        // Forbidden when targeting UWP\n         #[link_name = \"SystemFunction036\"]\n         pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n \n-        pub fn ReadConsoleW(hConsoleInput: HANDLE,\n-                            lpBuffer: LPVOID,\n-                            nNumberOfCharsToRead: DWORD,\n-                            lpNumberOfCharsRead: LPDWORD,\n-                            pInputControl: PCONSOLE_READCONSOLE_CONTROL) -> BOOL;\n+        // Allowed but unused by UWP\n+        pub fn OpenProcessToken(\n+            ProcessHandle: HANDLE,\n+            DesiredAccess: DWORD,\n+            TokenHandle: *mut HANDLE,\n+        ) -> BOOL;\n+    }\n \n-        pub fn WriteConsoleW(hConsoleOutput: HANDLE,\n-                             lpBuffer: LPCVOID,\n-                             nNumberOfCharsToWrite: DWORD,\n-                             lpNumberOfCharsWritten: LPDWORD,\n-                             lpReserved: LPVOID) -> BOOL;\n+    #[link(name = \"userenv\")]\n+    extern \"system\" {\n+        // Allowed but unused by UWP\n+        pub fn GetUserProfileDirectoryW(\n+            hToken: HANDLE,\n+            lpProfileDir: LPWSTR,\n+            lpcchSize: *mut DWORD,\n+        ) -> BOOL;\n+    }\n \n-        pub fn GetConsoleMode(hConsoleHandle: HANDLE,\n-                              lpMode: LPDWORD) -> BOOL;\n+    #[link(name = \"kernel32\")]\n+    extern \"system\" {\n+        // Functions forbidden when targeting UWP\n+        pub fn ReadConsoleW(\n+            hConsoleInput: HANDLE,\n+            lpBuffer: LPVOID,\n+            nNumberOfCharsToRead: DWORD,\n+            lpNumberOfCharsRead: LPDWORD,\n+            pInputControl: PCONSOLE_READCONSOLE_CONTROL,\n+        ) -> BOOL;\n+\n+        pub fn WriteConsoleW(\n+            hConsoleOutput: HANDLE,\n+            lpBuffer: LPCVOID,\n+            nNumberOfCharsToWrite: DWORD,\n+            lpNumberOfCharsWritten: LPDWORD,\n+            lpReserved: LPVOID,\n+        ) -> BOOL;\n+\n+        pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n         // Allowed but unused by UWP\n-        pub fn OpenProcessToken(ProcessHandle: HANDLE,\n-                                DesiredAccess: DWORD,\n-                                TokenHandle: *mut HANDLE) -> BOOL;\n-        pub fn GetUserProfileDirectoryW(hToken: HANDLE,\n-                                        lpProfileDir: LPWSTR,\n-                                        lpcchSize: *mut DWORD) -> BOOL;\n-        pub fn GetFileInformationByHandle(hFile: HANDLE,\n-                            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION)\n-                            -> BOOL;\n-        pub fn SetHandleInformation(hObject: HANDLE,\n-                                    dwMask: DWORD,\n-                                    dwFlags: DWORD) -> BOOL;\n-        pub fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n-                                           VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n-                                           -> LPVOID;\n-        pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,\n-                               lpTargetFileName: LPCWSTR,\n-                               lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n-                               -> BOOL;\n+        pub fn GetFileInformationByHandle(\n+            hFile: HANDLE,\n+            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION,\n+        ) -> BOOL;\n+        pub fn SetHandleInformation(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD) -> BOOL;\n+        pub fn AddVectoredExceptionHandler(\n+            FirstHandler: ULONG,\n+            VectoredHandler: PVECTORED_EXCEPTION_HANDLER,\n+        ) -> LPVOID;\n+        pub fn CreateHardLinkW(\n+            lpSymlinkFileName: LPCWSTR,\n+            lpTargetFileName: LPCWSTR,\n+            lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+        ) -> BOOL;\n+        pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n     }\n }\n }\n@@ -747,55 +769,32 @@ if #[cfg(target_vendor = \"uwp\")] {\n         pub Directory: BOOLEAN,\n     }\n \n+    #[link(name = \"bcrypt\")]\n     extern \"system\" {\n-        pub fn GetFileInformationByHandleEx(hFile: HANDLE,\n-                                            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n-                                            lpFileInformation: LPVOID,\n-                                            dwBufferSize: DWORD) -> BOOL;\n-        pub fn BCryptGenRandom(hAlgorithm: LPVOID, pBuffer: *mut u8,\n-                               cbBuffer: ULONG, dwFlags: ULONG) -> LONG;\n+        pub fn BCryptGenRandom(\n+            hAlgorithm: LPVOID,\n+            pBuffer: *mut u8,\n+            cbBuffer: ULONG,\n+            dwFlags: ULONG,\n+        ) -> LONG;\n+    }\n+    #[link(name = \"kernel32\")]\n+    extern \"system\" {\n+        pub fn GetFileInformationByHandleEx(\n+            hFile: HANDLE,\n+            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n+            lpFileInformation: LPVOID,\n+            dwBufferSize: DWORD,\n+        ) -> BOOL;\n     }\n }\n }\n \n // Shared between Desktop & UWP\n+\n+#[link(name = \"kernel32\")]\n extern \"system\" {\n-    pub fn WSAStartup(wVersionRequested: WORD, lpWSAData: LPWSADATA) -> c_int;\n-    pub fn WSACleanup() -> c_int;\n-    pub fn WSAGetLastError() -> c_int;\n-    pub fn WSADuplicateSocketW(\n-        s: SOCKET,\n-        dwProcessId: DWORD,\n-        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n-    ) -> c_int;\n-    pub fn WSASend(\n-        s: SOCKET,\n-        lpBuffers: LPWSABUF,\n-        dwBufferCount: DWORD,\n-        lpNumberOfBytesSent: LPDWORD,\n-        dwFlags: DWORD,\n-        lpOverlapped: LPWSAOVERLAPPED,\n-        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n-    ) -> c_int;\n-    pub fn WSARecv(\n-        s: SOCKET,\n-        lpBuffers: LPWSABUF,\n-        dwBufferCount: DWORD,\n-        lpNumberOfBytesRecvd: LPDWORD,\n-        lpFlags: LPDWORD,\n-        lpOverlapped: LPWSAOVERLAPPED,\n-        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n-    ) -> c_int;\n     pub fn GetCurrentProcessId() -> DWORD;\n-    pub fn WSASocketW(\n-        af: c_int,\n-        kind: c_int,\n-        protocol: c_int,\n-        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n-        g: GROUP,\n-        dwFlags: DWORD,\n-    ) -> SOCKET;\n-    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n     pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOL;\n@@ -882,28 +881,6 @@ extern \"system\" {\n     pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;\n     pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n-\n-    pub fn closesocket(socket: SOCKET) -> c_int;\n-    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int, flags: c_int) -> c_int;\n-    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int, flags: c_int) -> c_int;\n-    pub fn recvfrom(\n-        socket: SOCKET,\n-        buf: *mut c_void,\n-        len: c_int,\n-        flags: c_int,\n-        addr: *mut SOCKADDR,\n-        addrlen: *mut c_int,\n-    ) -> c_int;\n-    pub fn sendto(\n-        socket: SOCKET,\n-        buf: *const c_void,\n-        len: c_int,\n-        flags: c_int,\n-        addr: *const SOCKADDR,\n-        addrlen: c_int,\n-    ) -> c_int;\n-    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n-    pub fn accept(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> SOCKET;\n     pub fn DuplicateHandle(\n         hSourceProcessHandle: HANDLE,\n         hSourceHandle: HANDLE,\n@@ -950,32 +927,6 @@ extern \"system\" {\n     pub fn FindFirstFileW(fileName: LPCWSTR, findFileData: LPWIN32_FIND_DATAW) -> HANDLE;\n     pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW) -> BOOL;\n     pub fn FindClose(findFile: HANDLE) -> BOOL;\n-    pub fn getsockopt(\n-        s: SOCKET,\n-        level: c_int,\n-        optname: c_int,\n-        optval: *mut c_char,\n-        optlen: *mut c_int,\n-    ) -> c_int;\n-    pub fn setsockopt(\n-        s: SOCKET,\n-        level: c_int,\n-        optname: c_int,\n-        optval: *const c_void,\n-        optlen: c_int,\n-    ) -> c_int;\n-    pub fn getsockname(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n-    pub fn getpeername(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n-    pub fn bind(socket: SOCKET, address: *const SOCKADDR, address_len: socklen_t) -> c_int;\n-    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n-    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int) -> c_int;\n-    pub fn getaddrinfo(\n-        node: *const c_char,\n-        service: *const c_char,\n-        hints: *const ADDRINFOA,\n-        res: *mut *mut ADDRINFOA,\n-    ) -> c_int;\n-    pub fn freeaddrinfo(res: *mut ADDRINFOA);\n \n     pub fn GetProcAddress(handle: HMODULE, name: LPCSTR) -> *mut c_void;\n     pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;\n@@ -1012,61 +963,33 @@ extern \"system\" {\n         lpNumberOfBytesTransferred: LPDWORD,\n         bWait: BOOL,\n     ) -> BOOL;\n-    pub fn select(\n-        nfds: c_int,\n-        readfds: *mut fd_set,\n-        writefds: *mut fd_set,\n-        exceptfds: *mut fd_set,\n-        timeout: *const timeval,\n-    ) -> c_int;\n-\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinkw\n     pub fn CreateSymbolicLinkW(\n         lpSymlinkFileName: LPCWSTR,\n         lpTargetFileName: LPCWSTR,\n         dwFlags: DWORD,\n     ) -> BOOLEAN;\n-\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfinalpathnamebyhandlew\n     pub fn GetFinalPathNameByHandleW(\n         hFile: HANDLE,\n         lpszFilePath: LPCWSTR,\n         cchFilePath: DWORD,\n         dwFlags: DWORD,\n     ) -> DWORD;\n-\n-    // >= Vista / Server 2003\n-    // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadstackguarantee\n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n-\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfileinformationbyhandle\n     pub fn SetFileInformationByHandle(\n         hFile: HANDLE,\n         FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n         lpFileInformation: LPVOID,\n         dwBufferSize: DWORD,\n     ) -> BOOL;\n-\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepconditionvariablesrw\n     pub fn SleepConditionVariableSRW(\n         ConditionVariable: PCONDITION_VARIABLE,\n         SRWLock: PSRWLOCK,\n         dwMilliseconds: DWORD,\n         Flags: ULONG,\n     ) -> BOOL;\n \n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeconditionvariable\n     pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n     pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n \n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-acquiresrwlockexclusive\n     pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);\n     pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);\n     pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);\n@@ -1075,6 +998,99 @@ extern \"system\" {\n     pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n }\n \n+#[link(name = \"ws2_32\")]\n+extern \"system\" {\n+    pub fn WSAStartup(wVersionRequested: WORD, lpWSAData: LPWSADATA) -> c_int;\n+    pub fn WSACleanup() -> c_int;\n+    pub fn WSAGetLastError() -> c_int;\n+    pub fn WSADuplicateSocketW(\n+        s: SOCKET,\n+        dwProcessId: DWORD,\n+        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n+    ) -> c_int;\n+    pub fn WSASend(\n+        s: SOCKET,\n+        lpBuffers: LPWSABUF,\n+        dwBufferCount: DWORD,\n+        lpNumberOfBytesSent: LPDWORD,\n+        dwFlags: DWORD,\n+        lpOverlapped: LPWSAOVERLAPPED,\n+        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n+    ) -> c_int;\n+    pub fn WSARecv(\n+        s: SOCKET,\n+        lpBuffers: LPWSABUF,\n+        dwBufferCount: DWORD,\n+        lpNumberOfBytesRecvd: LPDWORD,\n+        lpFlags: LPDWORD,\n+        lpOverlapped: LPWSAOVERLAPPED,\n+        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n+    ) -> c_int;\n+    pub fn WSASocketW(\n+        af: c_int,\n+        kind: c_int,\n+        protocol: c_int,\n+        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n+        g: GROUP,\n+        dwFlags: DWORD,\n+    ) -> SOCKET;\n+    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n+    pub fn closesocket(socket: SOCKET) -> c_int;\n+    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int, flags: c_int) -> c_int;\n+    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int, flags: c_int) -> c_int;\n+    pub fn recvfrom(\n+        socket: SOCKET,\n+        buf: *mut c_void,\n+        len: c_int,\n+        flags: c_int,\n+        addr: *mut SOCKADDR,\n+        addrlen: *mut c_int,\n+    ) -> c_int;\n+    pub fn sendto(\n+        socket: SOCKET,\n+        buf: *const c_void,\n+        len: c_int,\n+        flags: c_int,\n+        addr: *const SOCKADDR,\n+        addrlen: c_int,\n+    ) -> c_int;\n+    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n+    pub fn accept(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> SOCKET;\n+    pub fn getsockopt(\n+        s: SOCKET,\n+        level: c_int,\n+        optname: c_int,\n+        optval: *mut c_char,\n+        optlen: *mut c_int,\n+    ) -> c_int;\n+    pub fn setsockopt(\n+        s: SOCKET,\n+        level: c_int,\n+        optname: c_int,\n+        optval: *const c_void,\n+        optlen: c_int,\n+    ) -> c_int;\n+    pub fn getsockname(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n+    pub fn getpeername(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n+    pub fn bind(socket: SOCKET, address: *const SOCKADDR, address_len: socklen_t) -> c_int;\n+    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n+    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int) -> c_int;\n+    pub fn getaddrinfo(\n+        node: *const c_char,\n+        service: *const c_char,\n+        hints: *const ADDRINFOA,\n+        res: *mut *mut ADDRINFOA,\n+    ) -> c_int;\n+    pub fn freeaddrinfo(res: *mut ADDRINFOA);\n+    pub fn select(\n+        nfds: c_int,\n+        readfds: *mut fd_set,\n+        writefds: *mut fd_set,\n+        exceptfds: *mut fd_set,\n+        timeout: *const timeval,\n+    ) -> c_int;\n+}\n+\n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n compat_fn! {"}, {"sha": "f23e874f249054df88c85c792f9ec37704ef9612", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5fa533ab0bfdbb02a1d37ae7787472b20291f11/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5fa533ab0bfdbb02a1d37ae7787472b20291f11/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=d5fa533ab0bfdbb02a1d37ae7787472b20291f11", "patch": "@@ -281,17 +281,3 @@ pub fn abort_internal() -> ! {\n     }\n     crate::intrinsics::abort();\n }\n-\n-cfg_if::cfg_if! {\n-    if #[cfg(target_vendor = \"uwp\")] {\n-        #[link(name = \"ws2_32\")]\n-        // For BCryptGenRandom\n-        #[link(name = \"bcrypt\")]\n-        extern \"C\" {}\n-    } else {\n-        #[link(name = \"advapi32\")]\n-        #[link(name = \"ws2_32\")]\n-        #[link(name = \"userenv\")]\n-        extern \"C\" {}\n-    }\n-}"}]}