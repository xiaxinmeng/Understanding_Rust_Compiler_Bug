{"sha": "3d9dd681f520d1d59f38aed0056cf9474894cc74", "node_id": "C_kwDOAAsO6NoAKDNkOWRkNjgxZjUyMGQxZDU5ZjM4YWVkMDA1NmNmOTQ3NDg5NGNjNzQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-20T23:42:24Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-21T07:33:54Z"}, "message": "Resolve vars in same_type_modulo_infer", "tree": {"sha": "7082082b4bf032449efdd06024ab321a54452fbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7082082b4bf032449efdd06024ab321a54452fbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d9dd681f520d1d59f38aed0056cf9474894cc74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9dd681f520d1d59f38aed0056cf9474894cc74", "html_url": "https://github.com/rust-lang/rust/commit/3d9dd681f520d1d59f38aed0056cf9474894cc74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d9dd681f520d1d59f38aed0056cf9474894cc74/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "039a6ad1caa996379f683f2e219ac4f0e34889bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/039a6ad1caa996379f683f2e219ac4f0e34889bf", "html_url": "https://github.com/rust-lang/rust/commit/039a6ad1caa996379f683f2e219ac4f0e34889bf"}], "stats": {"total": 149, "additions": 79, "deletions": 70}, "files": [{"sha": "6c57e7f4347f209a05c9215140c6bc8afbe2195f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 78, "deletions": 68, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/3d9dd681f520d1d59f38aed0056cf9474894cc74/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9dd681f520d1d59f38aed0056cf9474894cc74/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3d9dd681f520d1d59f38aed0056cf9474894cc74", "patch": "@@ -316,37 +316,6 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     err\n }\n \n-/// Structurally compares two types, modulo any inference variables.\n-///\n-/// Returns `true` if two types are equal, or if one type is an inference variable compatible\n-/// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n-/// FloatVar inference type are compatible with themselves or their concrete types (Int and\n-/// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n-pub fn same_type_modulo_infer<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-    match (&a.kind(), &b.kind()) {\n-        (&ty::Adt(did_a, substs_a), &ty::Adt(did_b, substs_b)) => {\n-            if did_a != did_b {\n-                return false;\n-            }\n-\n-            substs_a.types().zip(substs_b.types()).all(|(a, b)| same_type_modulo_infer(a, b))\n-        }\n-        (&ty::Int(_), &ty::Infer(ty::InferTy::IntVar(_)))\n-        | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Int(_) | &ty::Infer(ty::InferTy::IntVar(_)))\n-        | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n-        | (\n-            &ty::Infer(ty::InferTy::FloatVar(_)),\n-            &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n-        )\n-        | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n-        | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n-        (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n-            mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n-        }\n-        _ => a == b,\n-    }\n-}\n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n@@ -1723,15 +1692,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n         debug!(\"exp_found {:?} terr {:?} cause.code {:?}\", exp_found, terr, cause.code());\n         if let Some(exp_found) = exp_found {\n-            let should_suggest_fixes = if let ObligationCauseCode::Pattern { root_ty, .. } =\n-                cause.code()\n-            {\n-                // Skip if the root_ty of the pattern is not the same as the expected_ty.\n-                // If these types aren't equal then we've probably peeled off a layer of arrays.\n-                same_type_modulo_infer(self.resolve_vars_if_possible(*root_ty), exp_found.expected)\n-            } else {\n-                true\n-            };\n+            let should_suggest_fixes =\n+                if let ObligationCauseCode::Pattern { root_ty, .. } = cause.code() {\n+                    // Skip if the root_ty of the pattern is not the same as the expected_ty.\n+                    // If these types aren't equal then we've probably peeled off a layer of arrays.\n+                    self.same_type_modulo_infer(*root_ty, exp_found.expected)\n+                } else {\n+                    true\n+                };\n \n             if should_suggest_fixes {\n                 self.suggest_tuple_pattern(cause, &exp_found, diag);\n@@ -1786,7 +1754,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .filter_map(|variant| {\n                         let sole_field = &variant.fields[0];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if same_type_modulo_infer(sole_field_ty, exp_found.found) {\n+                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n                             let variant_path =\n                                 with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n                             // FIXME #56861: DRYer prelude filtering\n@@ -1902,47 +1870,50 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.get_impl_future_output_ty(exp_found.expected).map(Binder::skip_binder),\n             self.get_impl_future_output_ty(exp_found.found).map(Binder::skip_binder),\n         ) {\n-            (Some(exp), Some(found)) if same_type_modulo_infer(exp, found) => match cause.code() {\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n-                    diag.multipart_suggestion(\n-                        \"consider `await`ing on both `Future`s\",\n-                        vec![\n-                            (then.shrink_to_hi(), \".await\".to_string()),\n-                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                    prior_arms,\n-                    ..\n-                }) => {\n-                    if let [.., arm_span] = &prior_arms[..] {\n+            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => {\n+                match cause.code() {\n+                    ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n                         diag.multipart_suggestion(\n                             \"consider `await`ing on both `Future`s\",\n                             vec![\n-                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n+                                (then.shrink_to_hi(), \".await\".to_string()),\n                                 (exp_span.shrink_to_hi(), \".await\".to_string()),\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n-                    } else {\n+                    }\n+                    ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                        prior_arms,\n+                        ..\n+                    }) => {\n+                        if let [.., arm_span] = &prior_arms[..] {\n+                            diag.multipart_suggestion(\n+                                \"consider `await`ing on both `Future`s\",\n+                                vec![\n+                                    (arm_span.shrink_to_hi(), \".await\".to_string()),\n+                                    (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                                ],\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            diag.help(\"consider `await`ing on both `Future`s\");\n+                        }\n+                    }\n+                    _ => {\n                         diag.help(\"consider `await`ing on both `Future`s\");\n                     }\n                 }\n-                _ => {\n-                    diag.help(\"consider `await`ing on both `Future`s\");\n-                }\n-            },\n-            (_, Some(ty)) if same_type_modulo_infer(exp_found.expected, ty) => {\n+            }\n+            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n                 diag.span_suggestion_verbose(\n                     exp_span.shrink_to_hi(),\n                     \"consider `await`ing on the `Future`\",\n                     \".await\",\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            (Some(ty), _) if same_type_modulo_infer(ty, exp_found.found) => match cause.code() {\n+            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n+            {\n                 ObligationCauseCode::Pattern { span: Some(span), .. }\n                 | ObligationCauseCode::IfExpression(box IfExpressionCause { then: span, .. }) => {\n                     diag.span_suggestion_verbose(\n@@ -1992,7 +1963,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .iter()\n                 .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n                 .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| same_type_modulo_infer(*ty, exp_found.found))\n+                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n             {\n                 if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -2057,7 +2028,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                         | (_, ty::Infer(_))\n                                         | (ty::Param(_), _)\n                                         | (ty::Infer(_), _) => {}\n-                                        _ if same_type_modulo_infer(exp_ty, found_ty) => {}\n+                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n                                         _ => show_suggestion = false,\n                                     };\n                                 }\n@@ -2179,7 +2150,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         let [expected_tup_elem] = expected_fields[..] else { return };\n \n-        if !same_type_modulo_infer(expected_tup_elem, found) {\n+        if !self.same_type_modulo_infer(expected_tup_elem, found) {\n             return;\n         }\n \n@@ -2647,6 +2618,45 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         span.is_desugaring(DesugaringKind::QuestionMark)\n             && self.tcx.is_diagnostic_item(sym::From, trait_def_id)\n     }\n+\n+    /// Structurally compares two types, modulo any inference variables.\n+    ///\n+    /// Returns `true` if two types are equal, or if one type is an inference variable compatible\n+    /// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n+    /// FloatVar inference type are compatible with themselves or their concrete types (Int and\n+    /// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n+    pub fn same_type_modulo_infer(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        let (a, b) = self.resolve_vars_if_possible((a, b));\n+        match (&a.kind(), &b.kind()) {\n+            (&ty::Adt(did_a, substs_a), &ty::Adt(did_b, substs_b)) => {\n+                if did_a != did_b {\n+                    return false;\n+                }\n+\n+                substs_a\n+                    .types()\n+                    .zip(substs_b.types())\n+                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            (&ty::Int(_) | &ty::Uint(_), &ty::Infer(ty::InferTy::IntVar(_)))\n+            | (\n+                &ty::Infer(ty::InferTy::IntVar(_)),\n+                &ty::Int(_) | &ty::Uint(_) | &ty::Infer(ty::InferTy::IntVar(_)),\n+            )\n+            | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n+            | (\n+                &ty::Infer(ty::InferTy::FloatVar(_)),\n+                &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n+            )\n+            | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n+            | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n+            (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n+                mut_a == mut_b && self.same_type_modulo_infer(*ty_a, *ty_b)\n+            }\n+            // FIXME(compiler-errors): This needs to be generalized more\n+            _ => a == b,\n+        }\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {"}, {"sha": "1fbc904eb48e83f2aed1968d2a0e638b4550361a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d9dd681f520d1d59f38aed0056cf9474894cc74/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9dd681f520d1d59f38aed0056cf9474894cc74/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=3d9dd681f520d1d59f38aed0056cf9474894cc74", "patch": "@@ -22,7 +22,6 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n-use rustc_infer::infer::error_reporting::same_type_modulo_infer;\n use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n@@ -640,7 +639,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                             if expected.len() == 1 { \"\" } else { \"s\" },\n                                         )\n                                     );\n-                                } else if !same_type_modulo_infer(given_ty, expected_ty) {\n+                                } else if !self.same_type_modulo_infer(given_ty, expected_ty) {\n                                     // Print type mismatch\n                                     let (expected_args, given_args) =\n                                         self.cmp(given_ty, expected_ty);"}]}