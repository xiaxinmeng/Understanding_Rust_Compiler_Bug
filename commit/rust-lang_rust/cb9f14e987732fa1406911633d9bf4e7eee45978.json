{"sha": "cb9f14e987732fa1406911633d9bf4e7eee45978", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiOWYxNGU5ODc3MzJmYTE0MDY5MTE2MzNkOWJmNGU3ZWVlNDU5Nzg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-22T11:32:52Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-28T23:30:03Z"}, "message": "Use `Def::Err` to signal that an error has already been reported where possible.", "tree": {"sha": "9ac6781d648c3b79fb0d8df3173acc277b59b0a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ac6781d648c3b79fb0d8df3173acc277b59b0a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb9f14e987732fa1406911633d9bf4e7eee45978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb9f14e987732fa1406911633d9bf4e7eee45978", "html_url": "https://github.com/rust-lang/rust/commit/cb9f14e987732fa1406911633d9bf4e7eee45978", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb9f14e987732fa1406911633d9bf4e7eee45978/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c267a8d5ab141faaf5d4b33a20cac62cdc4507", "url": "https://api.github.com/repos/rust-lang/rust/commits/39c267a8d5ab141faaf5d4b33a20cac62cdc4507", "html_url": "https://github.com/rust-lang/rust/commit/39c267a8d5ab141faaf5d4b33a20cac62cdc4507"}], "stats": {"total": 111, "additions": 48, "deletions": 63}, "files": [{"sha": "7b73582449bfc58b9e5bab6a3a5f33c284808e38", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 48, "deletions": 63, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cb9f14e987732fa1406911633d9bf4e7eee45978/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9f14e987732fa1406911633d9bf4e7eee45978/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cb9f14e987732fa1406911633d9bf4e7eee45978", "patch": "@@ -584,13 +584,9 @@ impl<'a> Visitor for Resolver<'a> {\n         self.resolve_type(ty);\n     }\n     fn visit_poly_trait_ref(&mut self, tref: &ast::PolyTraitRef, m: &ast::TraitBoundModifier) {\n-        match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0, None) {\n-            Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n-            Err(_) => {\n-                // error already reported\n-                self.record_def(tref.trait_ref.ref_id, err_path_resolution())\n-            }\n-        }\n+        let def =\n+            self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0, None);\n+        self.record_def(tref.trait_ref.ref_id, def);\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self,\n@@ -1205,8 +1201,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n             Ok(binding) => path.def = binding.def(),\n-            Err(true) => {}\n-            Err(false) => {\n+            None => {\n                 let path_name = &format!(\"{}\", path);\n                 let error =\n                     ResolutionError::UnresolvedName {\n@@ -1844,12 +1839,11 @@ impl<'a> Resolver<'a> {\n                             match self.resolve_crate_relative_path(prefix.span,\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n-                                Ok(binding) => {\n+                                Some(binding) => {\n                                     let def = binding.def();\n                                     self.record_def(item.id, PathResolution::new(def));\n                                 }\n-                                Err(true) => self.record_def(item.id, err_path_resolution()),\n-                                Err(false) => {\n+                                None => {\n                                     resolve_error(self,\n                                                   prefix.span,\n                                                   ResolutionError::FailedToResolve(\n@@ -1935,14 +1929,14 @@ impl<'a> Resolver<'a> {\n                                trait_path: &Path,\n                                path_depth: usize,\n                                generics: Option<&Generics>)\n-                               -> Result<PathResolution, ()> {\n-        self.resolve_path(id, trait_path, path_depth, TypeNS).and_then(|path_res| {\n+                               -> PathResolution {\n+        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS) {\n             match path_res.base_def {\n                 Def::Trait(_) => {\n                     debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n-                    return Ok(path_res);\n+                    return path_res;\n                 }\n-                Def::Err => return Err(true),\n+                Def::Err => return err_path_resolution(),\n                 _ => {}\n             }\n \n@@ -1963,10 +1957,7 @@ impl<'a> Resolver<'a> {\n                 err.note(&format!(\"type aliases cannot be used for traits\"));\n             }\n             err.emit();\n-            Err(true)\n-        }).map_err(|error_reported| {\n-            if error_reported { return }\n-\n+        } else {\n             // find possible candidates\n             let trait_name = trait_path.segments.last().unwrap().identifier.name;\n             let candidates =\n@@ -1988,7 +1979,8 @@ impl<'a> Resolver<'a> {\n                 );\n \n             resolve_error(self, trait_path.span, error);\n-        })\n+        }\n+        err_path_resolution()\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n@@ -2011,16 +2003,13 @@ impl<'a> Resolver<'a> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            if let Ok(path_res) = self.resolve_trait_reference(trait_ref.ref_id,\n-                                                               &trait_ref.path,\n-                                                               0,\n-                                                               generics) {\n-                assert!(path_res.depth == 0);\n-                self.record_def(trait_ref.ref_id, path_res);\n+            let path_res =\n+                self.resolve_trait_reference(trait_ref.ref_id, &trait_ref.path, 0, generics);\n+            assert!(path_res.depth == 0);\n+            self.record_def(trait_ref.ref_id, path_res);\n+            if path_res.base_def != Def::Err {\n                 new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n                 new_id = Some(path_res.base_def.def_id());\n-            } else {\n-                self.record_def(trait_ref.ref_id, err_path_resolution());\n             }\n             visit::walk_trait_ref(self, trait_ref);\n         }\n@@ -2276,9 +2265,8 @@ impl<'a> Resolver<'a> {\n                     self.record_def(ty.id, err_path_resolution());\n \n                     // Keep reporting some errors even if they're ignored above.\n-                    if let Err(true) = self.resolve_path(ty.id, path, 0, TypeNS) {\n-                        // `resolve_path` already reported the error\n-                    } else {\n+                    let result = self.resolve_path(ty.id, path, 0, TypeNS);\n+                    if result.map(|resolution| resolution.base_def) != Some(Def::Err) {\n                         let kind = if maybe_qself.is_some() {\n                             \"associated type\"\n                         } else {\n@@ -2420,7 +2408,7 @@ impl<'a> Resolver<'a> {\n                 resolution\n             }\n         } else {\n-            if let Err(false) = self.resolve_path(pat_id, path, 0, namespace) {\n+            if self.resolve_path(pat_id, path, 0, namespace).is_none() {\n                 resolve_error(\n                     self,\n                     path.span,\n@@ -2553,26 +2541,28 @@ impl<'a> Resolver<'a> {\n                 }\n                 max_assoc_types = path.segments.len() - qself.position;\n                 // Make sure the trait is valid.\n-                let _ = self.resolve_trait_reference(id, path, max_assoc_types, None);\n+                self.resolve_trait_reference(id, path, max_assoc_types, None);\n             }\n             None => {\n                 max_assoc_types = path.segments.len();\n             }\n         }\n \n         let mut resolution = self.with_no_errors(|this| {\n-            this.resolve_path(id, path, 0, namespace).ok()\n+            this.resolve_path(id, path, 0, namespace)\n         });\n+        if resolution.map(|res| res.base_def) == Some(Def::Err) { resolution = None; }\n         for depth in 1..max_assoc_types {\n             if resolution.is_some() {\n                 break;\n             }\n             self.with_no_errors(|this| {\n-                let partial_resolution = this.resolve_path(id, path, depth, TypeNS).ok();\n+                let partial_resolution = this.resolve_path(id, path, depth, TypeNS);\n                 if let Some(Def::Mod(..)) = partial_resolution.map(|r| r.base_def) {\n                     // Modules cannot have associated items\n                 } else {\n                     resolution = partial_resolution;\n+                    if resolution.map(|res| res.base_def) == Some(Def::Err) { resolution = None; }\n                 }\n             });\n         }\n@@ -2582,7 +2572,7 @@ impl<'a> Resolver<'a> {\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n     /// returned value. See `hir::def::PathResolution` for more info.\n     fn resolve_path(&mut self, id: NodeId, path: &Path, path_depth: usize, namespace: Namespace)\n-                    -> Result<PathResolution, bool /* true if an error was reported */ > {\n+                    -> Option<PathResolution> {\n         debug!(\"resolve_path(id={:?} path={:?}, path_depth={:?})\", id, path, path_depth);\n \n         let span = path.span;\n@@ -2623,15 +2613,15 @@ impl<'a> Resolver<'a> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            let def = resolve_identifier_with_fallback(self, Some(span)).ok_or(false);\n-            return def.and_then(|def| self.adjust_local_def(def, span).ok_or(true)).map(mk_res);\n+            let def = resolve_identifier_with_fallback(self, Some(span));\n+            return def.map(|def| mk_res(self.adjust_local_def(def, span)));\n         }\n \n         let unqualified_def = resolve_identifier_with_fallback(self, None);\n         let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n         match (qualified_binding, unqualified_def) {\n-            (Ok(binding), Some(ref ud)) if binding.def() == ud.def &&\n-                                           segments[0].identifier.name != \"$crate\" => {\n+            (Some(binding), Some(ref ud)) if binding.def() == ud.def &&\n+                                             segments[0].identifier.name != \"$crate\" => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2659,7 +2649,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n-    fn adjust_local_def(&mut self, local_def: LocalDef, span: Span) -> Option<Def> {\n+    fn adjust_local_def(&mut self, local_def: LocalDef, span: Span) -> Def {\n         let ribs = match local_def.ribs {\n             Some((ns, i)) => &self.ribs[ns][i + 1..],\n             None => &[] as &[_],\n@@ -2705,14 +2695,14 @@ impl<'a> Resolver<'a> {\n                             resolve_error(self,\n                                           span,\n                                           ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n-                            return None;\n+                            return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n                             resolve_error(self,\n                                           span,\n                                           ResolutionError::AttemptToUseNonConstantValueInConstant);\n-                            return None;\n+                            return Def::Err;\n                         }\n                     }\n                 }\n@@ -2731,28 +2721,27 @@ impl<'a> Resolver<'a> {\n                             resolve_error(self,\n                                           span,\n                                           ResolutionError::TypeParametersFromOuterFunction);\n-                            return None;\n+                            return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n                             resolve_error(self, span, ResolutionError::OuterTypeParameterContext);\n-                            return None;\n+                            return Def::Err;\n                         }\n                     }\n                 }\n             }\n             _ => {}\n         }\n-        return Some(def);\n+        return def;\n     }\n \n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n                                     span: Span,\n                                     segments: &[ast::PathSegment],\n                                     namespace: Namespace)\n-                                    -> Result<&'a NameBinding<'a>,\n-                                              bool /* true if an error was reported */> {\n+                                    -> Option<&'a NameBinding<'a>> {\n         let module_path =\n             segments.split_last().unwrap().1.iter().map(|ps| ps.identifier).collect::<Vec<_>>();\n \n@@ -2761,22 +2750,20 @@ impl<'a> Resolver<'a> {\n                 if let Some((span, msg)) = err {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n-                return Err(true);\n+                return Some(self.dummy_binding);\n             }\n-            Indeterminate => return Err(false),\n+            Indeterminate => return None,\n             Success(module) => module,\n         };\n \n         let name = segments.last().unwrap().identifier.name;\n-        let result = self.resolve_name_in_module(module, name, namespace, false, Some(span));\n-        result.success().ok_or(false)\n+        self.resolve_name_in_module(module, name, namespace, false, Some(span)).success()\n     }\n \n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n     fn resolve_crate_relative_path<T>(&mut self, span: Span, segments: &[T], namespace: Namespace)\n-                                      -> Result<&'a NameBinding<'a>,\n-                                                bool /* true if an error was reported */>\n+                                      -> Option<&'a NameBinding<'a>>\n         where T: Named,\n     {\n         let module_path = segments.split_last().unwrap().1.iter().map(T::ident).collect::<Vec<_>>();\n@@ -2787,17 +2774,16 @@ impl<'a> Resolver<'a> {\n                 if let Some((span, msg)) = err {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n-                return Err(true);\n+                return Some(self.dummy_binding);\n             }\n \n-            Indeterminate => return Err(false),\n+            Indeterminate => return None,\n \n             Success(module) => module,\n         };\n \n         let name = segments.last().unwrap().ident().name;\n-        let result = self.resolve_name_in_module(module, name, namespace, false, Some(span));\n-        result.success().ok_or(false)\n+        self.resolve_name_in_module(module, name, namespace, false, Some(span)).success()\n     }\n \n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n@@ -2963,7 +2949,7 @@ impl<'a> Resolver<'a> {\n \n                     self.record_def(expr.id, err_path_resolution());\n \n-                    if let Ok(Def::Struct(..)) = type_res.map(|r| r.base_def) {\n+                    if let Some(Def::Struct(..)) = type_res.map(|r| r.base_def) {\n                         let error_variant =\n                             ResolutionError::StructVariantUsedAsFunction(&path_name);\n                         let mut err = resolve_struct_error(self, expr.span, error_variant);\n@@ -2979,9 +2965,8 @@ impl<'a> Resolver<'a> {\n                         err.emit();\n                     } else {\n                         // Keep reporting some errors even if they're ignored above.\n-                        if let Err(true) = self.resolve_path(expr.id, path, 0, ValueNS) {\n-                            // `resolve_path` already reported the error\n-                        } else {\n+                        let result = self.resolve_path(expr.id, path, 0, ValueNS);\n+                        if result.map(|resolution| resolution.base_def) != Some(Def::Err) {\n                             let mut method_scope = false;\n                             let mut is_static = false;\n                             self.ribs[ValueNS].iter().rev().all(|rib| {"}]}