{"sha": "7871b55597b368bd647b94187a805f29d512b6e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NzFiNTU1OTdiMzY4YmQ2NDdiOTQxODdhODA1ZjI5ZDUxMmI2ZTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-10T19:47:51Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-10T19:47:51Z"}, "message": "stdlib: Implement an interior-vector version of the io module", "tree": {"sha": "ae117399ce1682fc39f7f63504e599dea1549041", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae117399ce1682fc39f7f63504e599dea1549041"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7871b55597b368bd647b94187a805f29d512b6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7871b55597b368bd647b94187a805f29d512b6e5", "html_url": "https://github.com/rust-lang/rust/commit/7871b55597b368bd647b94187a805f29d512b6e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7871b55597b368bd647b94187a805f29d512b6e5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "875c4622fba068149a9c635684c644d84cb3e014", "url": "https://api.github.com/repos/rust-lang/rust/commits/875c4622fba068149a9c635684c644d84cb3e014", "html_url": "https://github.com/rust-lang/rust/commit/875c4622fba068149a9c635684c644d84cb3e014"}], "stats": {"total": 489, "additions": 489, "deletions": 0}, "files": [{"sha": "d10e5a088d21c9d31d0040ac47a42fcea8cdcf94", "filename": "src/lib/ioivec.rs", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fioivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fioivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fioivec.rs?ref=7871b55597b368bd647b94187a805f29d512b6e5", "patch": "@@ -0,0 +1,462 @@\n+\n+import os::libc;\n+\n+native \"rust\" mod rustrt {\n+    fn rust_get_stdin() -> os::libc::FILE;\n+    fn rust_get_stdout() -> os::libc::FILE;\n+}\n+\n+\n+// Reading\n+\n+// FIXME This is all buffered. We might need an unbuffered variant as well\n+tag seek_style { seek_set; seek_end; seek_cur; }\n+\n+\n+// The raw underlying reader class. All readers must implement this.\n+type buf_reader =\n+    obj {\n+        fn read(uint) -> u8[] ;\n+        fn read_byte() -> int ;\n+        fn unread_byte(int) ;\n+        fn eof() -> bool ;\n+\n+            // FIXME: Seekable really should be orthogonal. We will need\n+            // inheritance.\n+            fn seek(int, seek_style) ;\n+        fn tell() -> uint ;\n+    };\n+\n+\n+// Convenience methods for reading.\n+type reader =\n+    obj {\n+\n+            // FIXME: This should inherit from buf_reader.\n+            fn get_buf_reader() -> buf_reader ;\n+        fn read_byte() -> int ;\n+        fn unread_byte(int) ;\n+        fn read_bytes(uint) -> u8[] ;\n+        fn read_char() -> char ;\n+        fn eof() -> bool ;\n+        fn read_line() -> str ;\n+        fn read_c_str() -> str ;\n+        fn read_le_uint(uint) -> uint ;\n+        fn read_le_int(uint) -> int ;\n+        fn read_be_uint(uint) -> uint ;\n+        fn read_whole_stream() -> u8[] ;\n+        fn seek(int, seek_style) ;\n+        fn tell() -> uint ; // FIXME: eventually u64\n+\n+    };\n+\n+fn convert_whence(seek_style whence) -> int {\n+    ret alt (whence) {\n+            case (seek_set) { 0 }\n+            case (seek_cur) { 1 }\n+            case (seek_end) { 2 }\n+        };\n+}\n+\n+obj FILE_buf_reader(os::libc::FILE f, bool must_close) {\n+    fn read(uint len) -> u8[] {\n+        auto buf = ~[];\n+        ivec::reserve[u8](buf, len);\n+        auto read = os::libc_ivec::fread(ivec::to_ptr[u8](buf), 1u, len, f);\n+        ivec::len_set[u8](buf, read);\n+        ret buf;\n+    }\n+    fn read_byte() -> int { ret os::libc::fgetc(f); }\n+    fn unread_byte(int byte) { os::libc::ungetc(byte, f); }\n+    fn eof() -> bool { ret os::libc::feof(f) != 0; }\n+    fn seek(int offset, seek_style whence) {\n+        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n+    }\n+    fn tell() -> uint {\n+        ret os::libc::ftell(f) as uint;\n+    }drop { if (must_close) { os::libc::fclose(f); } }\n+}\n+\n+\n+// FIXME: Convert this into pseudomethods on buf_reader.\n+obj new_reader(buf_reader rdr) {\n+    fn get_buf_reader() -> buf_reader { ret rdr; }\n+    fn read_byte() -> int { ret rdr.read_byte(); }\n+    fn unread_byte(int byte) { ret rdr.unread_byte(byte); }\n+    fn read_bytes(uint len) -> u8[] { ret rdr.read(len); }\n+    fn read_char() -> char {\n+        auto c0 = rdr.read_byte();\n+        if (c0 == -1) {\n+            ret -1 as char; // FIXME will this stay valid?\n+\n+        }\n+        auto b0 = c0 as u8;\n+        auto w = str::utf8_char_width(b0);\n+        assert (w > 0u);\n+        if (w == 1u) { ret b0 as char; }\n+        auto val = 0u;\n+        while (w > 1u) {\n+            w -= 1u;\n+            auto next = rdr.read_byte();\n+            assert (next > -1);\n+            assert (next & 192 == 128);\n+            val <<= 6u;\n+            val += next & 63 as uint;\n+        }\n+        // See str::char_at\n+\n+        val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n+        ret val as char;\n+    }\n+    fn eof() -> bool { ret rdr.eof(); }\n+    fn read_line() -> str {\n+        let u8[] buf = ~[];\n+        // No break yet in rustc\n+\n+        auto go_on = true;\n+        while (go_on) {\n+            auto ch = rdr.read_byte();\n+            if (ch == -1 || ch == 10) {\n+                go_on = false;\n+            } else { buf += ~[ch as u8]; }\n+        }\n+        ret str::unsafe_from_bytes_ivec(buf);\n+    }\n+    fn read_c_str() -> str {\n+        let u8[] buf = ~[];\n+        auto go_on = true;\n+        while (go_on) {\n+            auto ch = rdr.read_byte();\n+            if (ch < 1) {\n+                go_on = false;\n+            } else { buf += ~[ch as u8]; }\n+        }\n+        ret str::unsafe_from_bytes_ivec(buf);\n+    }\n+\n+    // FIXME deal with eof?\n+    fn read_le_uint(uint size) -> uint {\n+        auto val = 0u;\n+        auto pos = 0u;\n+        while (size > 0u) {\n+            val += (rdr.read_byte() as uint) << pos;\n+            pos += 8u;\n+            size -= 1u;\n+        }\n+        ret val;\n+    }\n+    fn read_le_int(uint size) -> int {\n+        auto val = 0u;\n+        auto pos = 0u;\n+        while (size > 0u) {\n+            val += (rdr.read_byte() as uint) << pos;\n+            pos += 8u;\n+            size -= 1u;\n+        }\n+        ret val as int;\n+    }\n+\n+    // FIXME deal with eof?\n+    fn read_be_uint(uint size) -> uint {\n+        auto val = 0u;\n+        auto sz = size; // FIXME: trans::ml bug workaround\n+\n+        while (sz > 0u) {\n+            sz -= 1u;\n+            val += (rdr.read_byte() as uint) << sz * 8u;\n+        }\n+        ret val;\n+    }\n+    fn read_whole_stream() -> u8[] {\n+        let u8[] buf = ~[];\n+        while (!rdr.eof()) { buf += rdr.read(2048u); }\n+        ret buf;\n+    }\n+    fn seek(int offset, seek_style whence) { ret rdr.seek(offset, whence); }\n+    fn tell() -> uint { ret rdr.tell(); }\n+}\n+\n+fn stdin() -> reader {\n+    ret new_reader(FILE_buf_reader(rustrt::rust_get_stdin(), false));\n+}\n+\n+fn file_reader(str path) -> reader {\n+    auto f = os::libc::fopen(str::buf(path), str::buf(\"r\"));\n+    if (f as uint == 0u) { log_err \"error opening \" + path; fail; }\n+    ret new_reader(FILE_buf_reader(f, true));\n+}\n+\n+\n+// FIXME: Remove me once objects are exported.\n+fn new_reader_(buf_reader bufr) -> reader { ret new_reader(bufr); }\n+\n+\n+// Byte buffer readers\n+\n+// TODO: mutable? u8, but this fails with rustboot.\n+type byte_buf = @rec(u8[] buf, mutable uint pos);\n+\n+obj byte_buf_reader(byte_buf bbuf) {\n+    fn read(uint len) -> u8[] {\n+        auto rest = ivec::len[u8](bbuf.buf) - bbuf.pos;\n+        auto to_read = len;\n+        if (rest < to_read) { to_read = rest; }\n+        auto range = ivec::slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n+        bbuf.pos += to_read;\n+        ret range;\n+    }\n+    fn read_byte() -> int {\n+        if (bbuf.pos == ivec::len[u8](bbuf.buf)) { ret -1; }\n+        auto b = bbuf.buf.(bbuf.pos);\n+        bbuf.pos += 1u;\n+        ret b as int;\n+    }\n+    fn unread_byte(int byte) { log_err \"TODO: unread_byte\"; fail; }\n+    fn eof() -> bool { ret bbuf.pos == ivec::len[u8](bbuf.buf); }\n+    fn seek(int offset, seek_style whence) {\n+        auto pos = bbuf.pos;\n+        auto len = ivec::len[u8](bbuf.buf);\n+        bbuf.pos = seek_in_buf(offset, pos, len, whence);\n+    }\n+    fn tell() -> uint { ret bbuf.pos; }\n+}\n+\n+fn new_byte_buf_reader(&u8[] buf) -> byte_buf_reader {\n+    ret byte_buf_reader(@rec(buf=buf, mutable pos=0u));\n+}\n+\n+\n+// Writing\n+tag fileflag { append; create; truncate; none; }\n+\n+type buf_writer =\n+    obj {\n+        fn write(&u8[]) ;\n+\n+            // FIXME: Seekable really should be orthogonal. We will need\n+            // inheritance.\n+            fn seek(int, seek_style) ;\n+        fn tell() -> uint ; // FIXME: eventually u64\n+\n+    };\n+\n+obj FILE_writer(os::libc::FILE f, bool must_close) {\n+    fn write(&u8[] v) {\n+        auto len = ivec::len[u8](v);\n+        auto vbuf = ivec::to_ptr[u8](v);\n+        auto nout = os::libc_ivec::fwrite(vbuf, len, 1u, f);\n+        if (nout < 1u) { log_err \"error dumping buffer\"; }\n+    }\n+    fn seek(int offset, seek_style whence) {\n+        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n+    }\n+    fn tell() -> uint {\n+        ret os::libc::ftell(f) as uint;\n+    }drop { if (must_close) { os::libc::fclose(f); } }\n+}\n+\n+obj fd_buf_writer(int fd, bool must_close) {\n+    fn write(&u8[] v) {\n+        auto len = ivec::len[u8](v);\n+        auto count = 0u;\n+        auto vbuf;\n+        while (count < len) {\n+            vbuf = ptr::offset(ivec::to_ptr[u8](v), count);\n+            auto nout = os::libc_ivec::write(fd, vbuf, len);\n+            if (nout < 0) {\n+                log_err \"error dumping buffer\";\n+                log_err sys::rustrt::last_os_error();\n+                fail;\n+            }\n+            count += nout as uint;\n+        }\n+    }\n+    fn seek(int offset, seek_style whence) {\n+        log_err \"need 64-bit native calls for seek, sorry\";\n+        fail;\n+    }\n+    fn tell() -> uint {\n+        log_err \"need 64-bit native calls for tell, sorry\";\n+        fail;\n+    }drop { if (must_close) { os::libc::close(fd); } }\n+}\n+\n+fn file_buf_writer(str path, &fileflag[] flags) -> buf_writer {\n+    let int fflags =\n+        os::libc_constants::O_WRONLY() | os::libc_constants::O_BINARY();\n+    for (fileflag f in flags) {\n+        alt (f) {\n+            case (append) { fflags |= os::libc_constants::O_APPEND(); }\n+            case (create) { fflags |= os::libc_constants::O_CREAT(); }\n+            case (truncate) { fflags |= os::libc_constants::O_TRUNC(); }\n+            case (none) { }\n+        }\n+    }\n+    auto fd =\n+        os::libc::open(str::buf(path), fflags,\n+                       os::libc_constants::S_IRUSR() |\n+                           os::libc_constants::S_IWUSR());\n+    if (fd < 0) {\n+        log_err \"error opening file for writing\";\n+        log_err sys::rustrt::last_os_error();\n+        fail;\n+    }\n+    ret fd_buf_writer(fd, true);\n+}\n+\n+type writer =\n+    obj {\n+        fn get_buf_writer() -> buf_writer ;\n+\n+            // write_str will continue to do utf-8 output only. an alternative\n+            // function will be provided for general encoded string output\n+            fn write_str(str) ;\n+        fn write_line(str) ;\n+        fn write_char(char) ;\n+        fn write_int(int) ;\n+        fn write_uint(uint) ;\n+        fn write_bytes(&u8[]) ;\n+        fn write_le_uint(uint, uint) ;\n+        fn write_le_int(int, uint) ;\n+        fn write_be_uint(uint, uint) ;\n+    };\n+\n+fn uint_to_le_bytes(uint n, uint size) -> u8[] {\n+    let u8[] bytes = ~[];\n+    while (size > 0u) { bytes += ~[n & 255u as u8]; n >>= 8u; size -= 1u; }\n+    ret bytes;\n+}\n+\n+fn uint_to_be_bytes(uint n, uint size) -> u8[] {\n+    let u8[] bytes = ~[];\n+    auto i = size - 1u as int;\n+    while (i >= 0) { bytes += ~[n >> (i * 8 as uint) & 255u as u8]; i -= 1; }\n+    ret bytes;\n+}\n+\n+obj new_writer(buf_writer out) {\n+    fn get_buf_writer() -> buf_writer { ret out; }\n+    fn write_str(str s) { out.write(str::bytes_ivec(s)); }\n+    fn write_line(str s) {\n+        out.write(str::bytes_ivec(s));\n+        out.write(str::bytes_ivec(\"\\n\"));\n+    }\n+    fn write_char(char ch) {\n+        // FIXME needlessly consy\n+\n+        out.write(str::bytes_ivec(str::from_char(ch)));\n+    }\n+    fn write_int(int n) { out.write(str::bytes_ivec(int::to_str(n, 10u))); }\n+    fn write_uint(uint n) {\n+        out.write(str::bytes_ivec(uint::to_str(n, 10u)));\n+    }\n+    fn write_bytes(&u8[] bytes) { out.write(bytes); }\n+    fn write_le_uint(uint n, uint size) {\n+        out.write(uint_to_le_bytes(n, size));\n+    }\n+    fn write_le_int(int n, uint size) {\n+        out.write(uint_to_le_bytes(n as uint, size));\n+    }\n+    fn write_be_uint(uint n, uint size) {\n+        out.write(uint_to_be_bytes(n, size));\n+    }\n+}\n+\n+\n+// FIXME: Remove me once objects are exported.\n+fn new_writer_(buf_writer out) -> writer { ret new_writer(out); }\n+\n+fn file_writer(str path, &fileflag[] flags) -> writer {\n+    ret new_writer(file_buf_writer(path, flags));\n+}\n+\n+\n+// FIXME: fileflags\n+fn buffered_file_buf_writer(str path) -> buf_writer {\n+    auto f = os::libc::fopen(str::buf(path), str::buf(\"w\"));\n+    if (f as uint == 0u) { log_err \"error opening \" + path; fail; }\n+    ret FILE_writer(f, true);\n+}\n+\n+\n+// FIXME it would be great if this could be a const\n+fn stdout() -> writer { ret new_writer(fd_buf_writer(1, false)); }\n+\n+type str_writer =\n+    obj {\n+        fn get_writer() -> writer ;\n+        fn get_str() -> str ;\n+    };\n+\n+type mutable_byte_buf = @rec(mutable u8[mutable] buf, mutable uint pos);\n+\n+obj byte_buf_writer(mutable_byte_buf buf) {\n+    fn write(&u8[] v) {\n+        // Fast path.\n+\n+        if (buf.pos == ivec::len(buf.buf)) {\n+            // FIXME: Fix our type system. There's no reason you shouldn't be\n+            // able to add a mutable vector to an immutable one.\n+\n+            let u8[mutable] mv = unsafe::reinterpret_cast(v);\n+            buf.buf += mv;\n+            buf.pos += ivec::len[u8](v);\n+            ret;\n+        }\n+        // FIXME: Optimize: These should be unique pointers.\n+\n+        auto vlen = ivec::len[u8](v);\n+        auto vpos = 0u;\n+        while (vpos < vlen) {\n+            auto b = v.(vpos);\n+            if (buf.pos == ivec::len(buf.buf)) {\n+                buf.buf += ~[mutable b];\n+            } else { buf.buf.(buf.pos) = b; }\n+            buf.pos += 1u;\n+            vpos += 1u;\n+        }\n+    }\n+    fn seek(int offset, seek_style whence) {\n+        auto pos = buf.pos;\n+        auto len = ivec::len(buf.buf);\n+        buf.pos = seek_in_buf(offset, pos, len, whence);\n+    }\n+    fn tell() -> uint { ret buf.pos; }\n+}\n+\n+fn string_writer() -> str_writer {\n+    // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n+\n+    let u8[mutable] b = ~[mutable 0u8];\n+    ivec::pop(b);\n+    let mutable_byte_buf buf = @rec(mutable buf=b, mutable pos=0u);\n+    obj str_writer_wrap(writer wr, mutable_byte_buf buf) {\n+        fn get_writer() -> writer { ret wr; }\n+        fn get_str() -> str { ret str::unsafe_from_bytes_ivec(buf.buf); }\n+    }\n+    ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n+}\n+\n+\n+// Utility functions\n+fn seek_in_buf(int offset, uint pos, uint len, seek_style whence) -> uint {\n+    auto bpos = pos as int;\n+    auto blen = len as int;\n+    alt (whence) {\n+        case (seek_set) { bpos = offset; }\n+        case (seek_cur) { bpos += offset; }\n+        case (seek_end) { bpos = blen + offset; }\n+    }\n+    if (bpos < 0) { bpos = 0; } else if (bpos > blen) { bpos = blen; }\n+    ret bpos as uint;\n+}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "cd55793a66e33636dc96772b04cfcc70eac13036", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=7871b55597b368bd647b94187a805f29d512b6e5", "patch": "@@ -35,6 +35,10 @@ fn len[T](&T[mutable?] v) -> uint {\n     ret rusti::ivec_len(v);\n }\n \n+fn len_set[T](&mutable T[mutable?] v, uint new_len) {\n+    v = slice(v, 0u, new_len);\n+}\n+\n type init_op[T] = fn(uint) -> T;\n \n fn init_fn[T](&init_op[T] op, uint n_elts) -> T[] {"}, {"sha": "353add3f7662496147afa1cb01a887aa8350eb1c", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=7871b55597b368bd647b94187a805f29d512b6e5", "patch": "@@ -33,6 +33,13 @@ native \"cdecl\" mod libc = \"\" {\n     fn waitpid(int pid, vbuf status, int options) -> int;\n }\n \n+native \"cdecl\" mod libc_ivec = \"\" {\n+    fn read(int fd, *u8 buf, uint count) -> int;\n+    fn write(int fd, *u8 buf, uint count) -> int;\n+    fn fread(*u8 buf, uint size, uint n, libc::FILE f) -> uint;\n+    fn fwrite(*u8 buf, uint size, uint n, libc::FILE f) -> uint;\n+}\n+\n mod libc_constants {\n     fn O_RDONLY() -> int { ret 0; }\n     fn O_WRONLY() -> int { ret 1; }"}, {"sha": "95b601ffc17adfec8224397a92cdcf9aaec98d8d", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=7871b55597b368bd647b94187a805f29d512b6e5", "patch": "@@ -30,6 +30,13 @@ native \"cdecl\" mod libc = \"\" {\n     fn waitpid(int pid, vbuf status, int options) -> int;\n }\n \n+native \"cdecl\" mod libc_ivec = \"\" {\n+    fn read(int fd, *u8 buf, uint count) -> int;\n+    fn write(int fd, *u8 buf, uint count) -> int;\n+    fn fread(*u8 buf, uint size, uint n, libc::FILE f) -> uint;\n+    fn fwrite(*u8 buf, uint size, uint n, libc::FILE f) -> uint;\n+}\n+\n mod libc_constants {\n     fn O_RDONLY() -> int { ret 0; }\n     fn O_WRONLY() -> int { ret 1; }"}, {"sha": "07833b7eea5fd84454f648568a99c1a6e48e15f5", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=7871b55597b368bd647b94187a805f29d512b6e5", "patch": "@@ -20,6 +20,7 @@ mod str;\n // General io and system-services modules.\n \n mod io;\n+mod ioivec;\n mod sys;\n mod task;\n "}, {"sha": "079c502b85f0db80f2267e30568fdd0deb20da70", "filename": "src/lib/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=7871b55597b368bd647b94187a805f29d512b6e5", "patch": "@@ -49,6 +49,7 @@ export connect_ivec;\n export to_upper;\n export safe_slice;\n export bytes_ivec;\n+export unsafe_from_bytes_ivec;\n \n native \"rust\" mod rustrt {\n     type sbuf;"}, {"sha": "da86cad3bafbb3e3e8e1f3a5b2c7a0cfc58ec8d9", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7871b55597b368bd647b94187a805f29d512b6e5/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=7871b55597b368bd647b94187a805f29d512b6e5", "patch": "@@ -22,6 +22,13 @@ native \"cdecl\" mod libc = \"\" {\n     fn _pipe(vbuf fds, uint size, int mode) -> int;\n }\n \n+native \"cdecl\" mod libc_ivec = \"\" {\n+    fn read(int fd, *u8 buf, uint count) -> int;\n+    fn write(int fd, *u8 buf, uint count) -> int;\n+    fn fread(*u8 buf, uint size, uint n, libc::FILE f) -> uint;\n+    fn fwrite(*u8 buf, uint size, uint n, libc::FILE f) -> uint;\n+}\n+\n mod libc_constants {\n     fn O_RDONLY() -> int { ret 0; }\n     fn O_WRONLY() -> int { ret 1; }"}]}