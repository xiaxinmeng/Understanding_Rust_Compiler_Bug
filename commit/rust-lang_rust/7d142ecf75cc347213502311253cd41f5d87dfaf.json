{"sha": "7d142ecf75cc347213502311253cd41f5d87dfaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMTQyZWNmNzVjYzM0NzIxMzUwMjMxMTI1M2NkNDFmNWQ4N2RmYWY=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-02-01T22:26:42Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-03-11T08:43:52Z"}, "message": "Use the new rustc interface", "tree": {"sha": "78cd86e8b2c937b14ac5d55dc13b78d55935dd36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78cd86e8b2c937b14ac5d55dc13b78d55935dd36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d142ecf75cc347213502311253cd41f5d87dfaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d142ecf75cc347213502311253cd41f5d87dfaf", "html_url": "https://github.com/rust-lang/rust/commit/7d142ecf75cc347213502311253cd41f5d87dfaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d142ecf75cc347213502311253cd41f5d87dfaf/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e66d6ec58bb18145bfbd2a42c8032657d8986d95", "url": "https://api.github.com/repos/rust-lang/rust/commits/e66d6ec58bb18145bfbd2a42c8032657d8986d95", "html_url": "https://github.com/rust-lang/rust/commit/e66d6ec58bb18145bfbd2a42c8032657d8986d95"}], "stats": {"total": 312, "additions": 99, "deletions": 213}, "files": [{"sha": "3e3c3a53f754e2ee960a1e8eb91f3bd2be5f667a", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7d142ecf75cc347213502311253cd41f5d87dfaf/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d142ecf75cc347213502311253cd41f5d87dfaf/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=7d142ecf75cc347213502311253cd41f5d87dfaf", "patch": "@@ -2,18 +2,39 @@ extern crate getopts;\n extern crate miri;\n extern crate rustc;\n extern crate rustc_driver;\n+extern crate rustc_interface;\n extern crate test;\n \n-use rustc_driver::{driver, Compilation};\n+use self::miri::eval_main;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use std::cell::RefCell;\n-use std::rc::Rc;\n+use rustc_interface::interface;\n+use crate::test::Bencher;\n+\n+struct MiriCompilerCalls<'a> {\n+    bencher: &'a mut Bencher,\n+}\n \n-use miri::{MiriConfig, eval_main};\n+impl rustc_driver::Callbacks for MiriCompilerCalls<'_> {\n+    fn after_analysis(&mut self, compiler: &interface::Compiler<'_>) -> bool {\n+        compiler.session().abort_if_errors();\n \n-use crate::test::Bencher;\n+        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+            let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\n+                \"no main or start function found\",\n+            );\n \n-pub struct MiriCompilerCalls<'a>(Rc<RefCell<&'a mut Bencher>>);\n+            self.bencher.iter(|| {\n+                let config = MiriConfig { validate: true, args: vec![] };\n+                eval_main(tcx, entry_def_id, config);\n+            });\n+        });\n+\n+        compiler.session().abort_if_errors();\n+\n+        // Don't continue execution\n+        false\n+    }\n+}\n \n fn find_sysroot() -> String {\n     // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n@@ -38,26 +59,5 @@ pub fn run(filename: &str, bencher: &mut Bencher) {\n         \"--sysroot\".to_string(),\n         find_sysroot(),\n     ];\n-    let bencher = RefCell::new(bencher);\n-\n-    let mut control = driver::CompileController::basic();\n-\n-    control.after_analysis.stop = Compilation::Stop;\n-    control.after_analysis.callback = Box::new(move |state| {\n-        state.session.abort_if_errors();\n-\n-        let tcx = state.tcx.unwrap();\n-        let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\n-            \"no main or start function found\",\n-        );\n-\n-        bencher.borrow_mut().iter(|| {\n-            let config = MiriConfig { validate: true, args: vec![] };\n-            eval_main(tcx, entry_def_id, config);\n-        });\n-\n-        state.session.abort_if_errors();\n-    });\n-\n-    rustc_driver::run_compiler(args, Box::new(control), None, None);\n+    rustc_driver::run_compiler(args, &mut MiriCompilerCalls { bencher }, None, None);\n }"}, {"sha": "cab8d845fc0d14c367be127dfb280eac29355e21", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 42, "deletions": 84, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7d142ecf75cc347213502311253cd41f5d87dfaf/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d142ecf75cc347213502311253cd41f5d87dfaf/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=7d142ecf75cc347213502311253cd41f5d87dfaf", "patch": "@@ -6,6 +6,7 @@ extern crate rustc_metadata;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_codegen_utils;\n+extern crate rustc_interface;\n extern crate syntax;\n \n use std::path::{PathBuf, Path};\n@@ -15,106 +16,66 @@ use std::io;\n \n \n use rustc::session::Session;\n+use rustc_interface::interface;\n use rustc_metadata::cstore::CStore;\n-use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n-use rustc_driver::driver::{CompileState, CompileController};\n use rustc::session::config::{self, Input, ErrorOutputType};\n use rustc::hir::{self, itemlikevisit};\n-use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n use miri::MiriConfig;\n \n struct MiriCompilerCalls {\n-    default: Box<RustcDefaultCalls>,\n     /// whether we are building for the host\n     host_target: bool,\n }\n \n-impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n-    fn early_callback(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        descriptions: &rustc_errors::registry::Registry,\n-        output: ErrorOutputType\n-    ) -> Compilation {\n-        self.default.early_callback(matches, sopts, cfg, descriptions, output)\n-    }\n-    fn no_input(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        descriptions: &rustc_errors::registry::Registry\n-    ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n-    }\n-    fn late_callback(\n-        &mut self,\n-        trans: &CodegenBackend,\n-        matches: &getopts::Matches,\n-        sess: &Session,\n-        cstore: &CStore,\n-        input: &Input,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-    ) -> Compilation {\n-        self.default.late_callback(trans, matches, sess, cstore, input, odir, ofile)\n-    }\n-    fn build_controller(self: Box<Self>, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n-        let this = *self;\n-        let mut control = this.default.build_controller(sess, matches);\n-        control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        control.after_analysis.callback = Box::new(after_analysis);\n-        if !this.host_target {\n-            // only fully compile targets on the host\n-            control.after_analysis.stop = Compilation::Stop;\n-        }\n-        control\n-    }\n-}\n-\n-fn after_hir_lowering(state: &mut CompileState) {\n-    let attr = (String::from(\"miri\"), syntax::feature_gate::AttributeType::Whitelisted);\n-    state.session.plugin_attributes.borrow_mut().push(attr);\n-}\n+impl rustc_driver::Callbacks for MiriCompilerCalls {\n+    fn after_parsing(&mut self, compiler: &interface::Compiler<'_>) -> bool {\n+        let attr = (\n+            String::from(\"miri\"),\n+            syntax::feature_gate::AttributeType::Whitelisted,\n+        );\n+        compiler.session().plugin_attributes.borrow_mut().push(attr);\n \n-fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n-    state.session.abort_if_errors();\n-\n-    let tcx = state.tcx.unwrap();\n+        // Continue execution\n+        true\n+    }\n \n-    if std::env::args().any(|arg| arg == \"--test\") {\n-        struct Visitor<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>, &'a CompileState<'a, 'tcx>);\n-        impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n-            fn visit_item(&mut self, i: &'hir hir::Item) {\n-                if let hir::ItemKind::Fn(.., body_id) = i.node {\n-                    if i.attrs.iter().any(|attr| attr.name() == \"test\") {\n-                        let config = MiriConfig { validate: true, args: vec![] };\n-                        let did = self.0.hir().body_owner_def_id(body_id);\n-                        println!(\"running test: {}\", self.0.def_path_debug_str(did));\n-                        miri::eval_main(self.0, did, config);\n-                        self.1.session.abort_if_errors();\n+    fn after_analysis(&mut self, compiler: &interface::Compiler<'_>) -> bool {\n+        compiler.session().abort_if_errors();\n+        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+            if std::env::args().any(|arg| arg == \"--test\") {\n+                struct Visitor<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>);\n+                impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n+                    fn visit_item(&mut self, i: &'hir hir::Item) {\n+                        if let hir::ItemKind::Fn(.., body_id) = i.node {\n+                            if i.attrs.iter().any(|attr| attr.name() == \"test\") {\n+                                let config = MiriConfig { validate: true, args: vec![] };\n+                                let did = self.0.hir().body_owner_def_id(body_id);\n+                                println!(\"running test: {}\", self.0.def_path_debug_str(did));\n+                                miri::eval_main(self.0, did, config);\n+                                self.0.sess.abort_if_errors();\n+                            }\n+                        }\n                     }\n+                    fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n+                    fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n                 }\n+                tcx.hir().krate().visit_all_item_likes(&mut Visitor(tcx));\n+            } else if let Some((entry_def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n+                let config = MiriConfig { validate: true, args: vec![] };\n+                miri::eval_main(tcx, entry_def_id, config);\n+\n+                compiler.session().abort_if_errors();\n+            } else {\n+                println!(\"no main function found, assuming auxiliary build\");\n             }\n-            fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n-            fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n-        }\n-        state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(tcx, state));\n-    } else if let Some((entry_def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-        let config = MiriConfig { validate: true, args: vec![] };\n-        miri::eval_main(tcx, entry_def_id, config);\n+        });\n \n-        state.session.abort_if_errors();\n-    } else {\n-        println!(\"no main function found, assuming auxiliary build\");\n+        // Continue execution on host target\n+        self.host_target\n     }\n }\n \n@@ -185,10 +146,7 @@ fn main() {\n         let buf = BufWriter::default();\n         let output = buf.clone();\n         let result = std::panic::catch_unwind(|| {\n-            rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n-                default: Box::new(RustcDefaultCalls),\n-                host_target,\n-            }), None, Some(Box::new(buf)));\n+            rustc_driver::run_compiler(&args, &mut MiriCompilerCalls { host_target }, None, Some(Box::new(buf)));\n         });\n \n         match result {"}, {"sha": "27e52d5f1a069967054da964587a89e77e0583a4", "filename": "src/bin/miri.rs", "status": "modified", "additions": 29, "deletions": 101, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7d142ecf75cc347213502311253cd41f5d87dfaf/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d142ecf75cc347213502311253cd41f5d87dfaf/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=7d142ecf75cc347213502311253cd41f5d87dfaf", "patch": "@@ -11,115 +11,46 @@ extern crate rustc_metadata;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_codegen_utils;\n+extern crate rustc_interface;\n extern crate syntax;\n \n-use std::path::PathBuf;\n use std::str::FromStr;\n use std::env;\n \n-use miri::MiriConfig;\n-use rustc::session::Session;\n-use rustc_metadata::cstore::CStore;\n-use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n-use rustc_driver::driver::{CompileState, CompileController};\n-use rustc::session::config::{self, Input, ErrorOutputType};\n-use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_interface::interface;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use syntax::ast;\n \n struct MiriCompilerCalls {\n-    default: Box<RustcDefaultCalls>,\n-    miri_config: MiriConfig,\n+    miri_config: miri::MiriConfig,\n }\n \n-impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n-    fn early_callback(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        descriptions: &rustc_errors::registry::Registry,\n-        output: ErrorOutputType,\n-    ) -> Compilation {\n-        self.default.early_callback(\n-            matches,\n-            sopts,\n-            cfg,\n-            descriptions,\n-            output,\n-        )\n-    }\n-    fn no_input(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        descriptions: &rustc_errors::registry::Registry,\n-    ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default.no_input(\n-            matches,\n-            sopts,\n-            cfg,\n-            odir,\n-            ofile,\n-            descriptions,\n-        )\n-    }\n-    fn late_callback(\n-        &mut self,\n-        codegen_backend: &CodegenBackend,\n-        matches: &getopts::Matches,\n-        sess: &Session,\n-        cstore: &CStore,\n-        input: &Input,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-    ) -> Compilation {\n-        // Called *before* `build_controller`. Add filename to `miri` arguments.\n-        self.miri_config.args.insert(0, input.filestem().to_string());\n-        self.default.late_callback(codegen_backend, matches, sess, cstore, input, odir, ofile)\n-    }\n-    fn build_controller(\n-        self: Box<Self>,\n-        sess: &Session,\n-        matches: &getopts::Matches,\n-    ) -> CompileController<'a> {\n-        let this = *self;\n-        let mut control = this.default.build_controller(sess, matches);\n-        control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        let miri_config = this.miri_config;\n-        control.after_analysis.callback =\n-            Box::new(move |state| after_analysis(state, miri_config.clone()));\n-        control.after_analysis.stop = Compilation::Stop;\n-        control\n-    }\n-}\n+impl rustc_driver::Callbacks for MiriCompilerCalls {\n+    fn after_parsing(&mut self, compiler: &interface::Compiler) -> bool {\n+        let attr = (\n+            String::from(\"miri\"),\n+            syntax::feature_gate::AttributeType::Whitelisted,\n+        );\n+        compiler.session().plugin_attributes.borrow_mut().push(attr);\n \n-fn after_hir_lowering(state: &mut CompileState) {\n-    let attr = (\n-        String::from(\"miri\"),\n-        syntax::feature_gate::AttributeType::Whitelisted,\n-    );\n-    state.session.plugin_attributes.borrow_mut().push(attr);\n-}\n-\n-fn after_analysis<'a, 'tcx>(\n-    state: &mut CompileState<'a, 'tcx>,\n-    miri_config: MiriConfig,\n-) {\n-    init_late_loggers();\n-    state.session.abort_if_errors();\n+        // Continue execution\n+        true\n+    }\n \n-    let tcx = state.tcx.unwrap();\n+    fn after_analysis(&mut self, compiler: &interface::Compiler) -> bool {\n+        init_late_loggers();\n+        compiler.session().abort_if_errors();\n \n+        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+            let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\"no main function found!\");\n \n-    let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\"no main function found!\");\n+            miri::eval_main(tcx, entry_def_id, self.miri_config.clone());\n+        });\n \n-    miri::eval_main(tcx, entry_def_id, miri_config);\n+        compiler.session().abort_if_errors();\n \n-    state.session.abort_if_errors();\n+        // Don't continue execution\n+        false\n+    }\n }\n \n fn init_early_loggers() {\n@@ -228,12 +159,9 @@ fn main() {\n \n     debug!(\"rustc arguments: {:?}\", rustc_args);\n     debug!(\"miri arguments: {:?}\", miri_args);\n-    let miri_config = MiriConfig { validate, args: miri_args };\n-    let result = rustc_driver::run(move || {\n-        rustc_driver::run_compiler(&rustc_args, Box::new(MiriCompilerCalls {\n-            default: Box::new(RustcDefaultCalls),\n-            miri_config,\n-        }), None, None)\n-    });\n-    std::process::exit(result as i32);\n+    let miri_config = miri::MiriConfig { validate, args: miri_args };\n+    let result = rustc_driver::report_ices_to_stderr_if_any(move || {\n+        rustc_driver::run_compiler(&rustc_args, &mut MiriCompilerCalls { miri_config }, None, None)\n+    }).and_then(|result| result);\n+    std::process::exit(result.is_err() as i32);\n }"}]}