{"sha": "192da8819f2e936f7b944624a202a97405e689b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MmRhODgxOWYyZTkzNmY3Yjk0NDYyNGEyMDJhOTc0MDVlNjg5YjM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-12T12:51:47Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-07-14T15:36:06Z"}, "message": "Ensure that it is not possible to explicitly free stack memory", "tree": {"sha": "fab52d3357e893f8d7b86cb3040aa86cc6609b13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fab52d3357e893f8d7b86cb3040aa86cc6609b13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/192da8819f2e936f7b944624a202a97405e689b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJgBAABCABKFiEEvpMjxK4/cnPNfesJHVy0/Fl8MAQFAllo5OYsHGdpdC1uby1y\nZXBseS05ODc5MTY1NzE2NDc5NDEzMTMxQG9saS1vYmsuZGUACgkQHVy0/Fl8MATe\n3A//eQLngU/eyRICUVhGrA0PcwysmxeppMYV8Rcx5KCrdndiXp/wGZRAUfZZ87QM\ny0k3NRWGl6RgzLsXdgR8UEUNzrtcVXQkiP9ZCcybYH0gFuPLpGjNFzLWSNPSH8ey\nM1TillYqcjXPbmH5/7ulFXQWKc8TBZwBNYltjkTbQn1FCj+MXm9RoGskZFxcI1sk\nLhdiSW+GoV7NKdKinsYlqSW+VelQvqahw4w7c9mprYcTSmkDRIYpWwGW3+voMGE5\nUv5dPDXXQUdA5pBq+W4IKMMYhM20nSyeAHvS3JgNSERXhWI94oQ+PJQ2bNSVKEmt\nUgJBs080/yQZMZQyKMu7VuMANrZNNFLtVQDvop7PRv3aTSqZ1ICySmpoWOmxnY2G\nUaAChl6TbW4DZBexdiLfcR75aCYwv2Lqs4CvWxChS87KirvB11fjxhCIJ0H28POk\nqUv2XigHIY7p14bwKRSmp8UAo7bQvth4Uwz73uhZcvb1/W7OFJ+c9chxBsRVkuUJ\n2cZL1zJWjVfvFtcj+uDIO413Rm+pcTPdHDzPrbhfKktfQB1vDi9WapsHRwZGPxsK\nwJSnC7y6fe1qJQbF3Mx/J1dH9UzV0ntUO5SWzQWhalkaeDVcvmA3/ABlbnw2xHBt\nWvD+gOJ7XCE8tMFZvFFihrTAbUKzSinTRTMLKUV1JdNTzag=\n=k5hC\n-----END PGP SIGNATURE-----", "payload": "tree fab52d3357e893f8d7b86cb3040aa86cc6609b13\nparent 56d4de303fb59a7235caa1bd2c8e32675428f421\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1499863907 +0200\ncommitter Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1500046566 +0200\n\nEnsure that it is not possible to explicitly free stack memory\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/192da8819f2e936f7b944624a202a97405e689b3", "html_url": "https://github.com/rust-lang/rust/commit/192da8819f2e936f7b944624a202a97405e689b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/192da8819f2e936f7b944624a202a97405e689b3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56d4de303fb59a7235caa1bd2c8e32675428f421", "url": "https://api.github.com/repos/rust-lang/rust/commits/56d4de303fb59a7235caa1bd2c8e32675428f421", "html_url": "https://github.com/rust-lang/rust/commit/56d4de303fb59a7235caa1bd2c8e32675428f421"}], "stats": {"total": 212, "additions": 122, "deletions": 90}, "files": [{"sha": "403ca9539e5b0db8622dd8e3a36a04d0d3e6442e", "filename": "src/error.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/192da8819f2e936f7b944624a202a97405e689b3/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192da8819f2e936f7b944624a202a97405e689b3/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=192da8819f2e936f7b944624a202a97405e689b3", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::MemoryPointer;\n+use memory::{MemoryPointer, Kind};\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n@@ -12,6 +12,7 @@ pub enum EvalError<'tcx> {\n     NoMirFor(String),\n     UnterminatedCString(MemoryPointer),\n     DanglingPointerDeref,\n+    DoubleFree,\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n@@ -56,8 +57,8 @@ pub enum EvalError<'tcx> {\n     AssumptionNotHeld,\n     InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n-    ReallocatedStaticMemory,\n-    DeallocatedStaticMemory,\n+    ReallocatedWrongMemoryKind(Kind, Kind),\n+    DeallocatedWrongMemoryKind(Kind, Kind),\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n     IncorrectAllocationInformation,\n@@ -84,6 +85,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to access memory through an invalid pointer\",\n             DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n+            DoubleFree =>\n+                \"tried to deallocate dangling pointer\",\n             InvalidFunctionPointer =>\n                 \"tried to use an integer pointer or a dangling pointer as a function pointer\",\n             InvalidBool =>\n@@ -148,10 +151,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"miri does not support inline assembly\",\n             TypeNotPrimitive(_) =>\n                 \"expected primitive type, got nonprimitive\",\n-            ReallocatedStaticMemory =>\n-                \"tried to reallocate static memory\",\n-            DeallocatedStaticMemory =>\n-                \"tried to deallocate static memory\",\n+            ReallocatedWrongMemoryKind(_, _) =>\n+                \"tried to reallocate memory from one kind to another\",\n+            DeallocatedWrongMemoryKind(_, _) =>\n+                \"tried to deallocate memory of the wrong kind\",\n             ReallocateNonBasePtr =>\n                 \"tried to reallocate with a pointer not to the beginning of an existing object\",\n             DeallocateNonBasePtr =>\n@@ -198,6 +201,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n             ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n+            ReallocatedWrongMemoryKind(old, new) =>\n+                write!(f, \"tried to reallocate memory from {:?} to {:?}\", old, new),\n+            DeallocatedWrongMemoryKind(old, new) =>\n+                write!(f, \"tried to deallocate {:?} memory but gave {:?} as the kind\", old, new),\n             Math(span, ref err) =>\n                 write!(f, \"{:?} at {:?}\", err, span),\n             Intrinsic(ref err) =>"}, {"sha": "ac39cc4339d1649ec5471a6a4a10048dde0d1164", "filename": "src/eval_context.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/192da8819f2e936f7b944624a202a97405e689b3/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192da8819f2e936f7b944624a202a97405e689b3/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=192da8819f2e936f7b944624a202a97405e689b3", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         let size = self.type_size_with_substs(ty, substs)?.expect(\"cannot alloc memory for unsized type\");\n         let align = self.type_align_with_substs(ty, substs)?;\n-        self.memory.allocate(size, align)\n+        self.memory.allocate(size, align, ::memory::Kind::Stack)\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'tcx> {\n@@ -354,16 +354,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n                     Value::ByRef(ptr, _aligned) =>\n                         // Alignment does not matter for this call\n-                        self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n+                        self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, !mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n+                        self.memory.mark_inner_allocation(ptr.alloc_id, !mutable)?;\n                     },\n                     Value::ByValPair(val1, val2) => {\n                         if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_inner_allocation(ptr.alloc_id, !mutable)?;\n                         }\n                         if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_inner_allocation(ptr.alloc_id, !mutable)?;\n                         }\n                     },\n                 }\n@@ -414,11 +414,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n-            match self.memory.deallocate(ptr, None) {\n-                // We could alternatively check whether the alloc_id is static before calling\n-                // deallocate, but this is much simpler and is probably the rare case.\n-                Ok(()) | Err(EvalError::DeallocatedStaticMemory) => {},\n-                other => return other,\n+            match self.memory.get(ptr.alloc_id)?.kind {\n+                ::memory::Kind::Static => {},\n+                ::memory::Kind::Stack => self.memory.deallocate(ptr, None, ::memory::Kind::Stack)?,\n+                other => bug!(\"local contained non-stack memory: {:?}\", other),\n             }\n         };\n         Ok(())\n@@ -693,11 +692,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return Err(EvalError::NeedsRfc(\"\\\"heap\\\" allocations\".to_string()));\n                 }\n                 // FIXME: call the `exchange_malloc` lang item if available\n-                if self.type_size(ty)?.expect(\"box only works with sized types\") == 0 {\n+                let size = self.type_size(ty)?.expect(\"box only works with sized types\");\n+                if size == 0 {\n                     let align = self.type_align(ty)?;\n                     self.write_primval(dest, PrimVal::Bytes(align.into()), dest_ty)?;\n                 } else {\n-                    let ptr = self.alloc_ptr(ty)?;\n+                    let align = self.type_align(ty)?;\n+                    let ptr = self.memory.allocate(size, align, ::memory::Kind::Rust)?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n             }\n@@ -1032,7 +1033,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         self.write_value_to_ptr(global_val.value, ptr.into(), global_val.ty)?;\n                         // see comment on `initialized` field\n                         if global_val.initialized {\n-                            self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n+                            self.memory.mark_static_initalized(ptr.alloc_id, !global_val.mutable)?;\n                         }\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n@@ -1686,7 +1687,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             }\n \n             // Return value\n-            let ret_ptr = ecx.memory.allocate(ecx.tcx.data_layout.pointer_size.bytes(), ecx.tcx.data_layout.pointer_align.abi())?;\n+            let ret_ptr = ecx.memory.allocate(ecx.tcx.data_layout.pointer_size.bytes(), ecx.tcx.data_layout.pointer_align.abi(), ::memory::Kind::Stack)?;\n             cleanup_ptr = Some(ret_ptr);\n \n             // Push our stack frame\n@@ -1728,7 +1729,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n \n         while ecx.step()? {}\n         if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory.deallocate(cleanup_ptr, None)?;\n+            ecx.memory.deallocate(cleanup_ptr, None, ::memory::Kind::Stack)?;\n         }\n         return Ok(());\n     }"}, {"sha": "f84dd3124824562d39ad87b5b5996af2e673359f", "filename": "src/memory.rs", "status": "modified", "additions": 66, "deletions": 55, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/192da8819f2e936f7b944624a202a97405e689b3/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192da8819f2e936f7b944624a202a97405e689b3/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=192da8819f2e936f7b944624a202a97405e689b3", "patch": "@@ -35,19 +35,25 @@ pub struct Allocation {\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: u64,\n     /// Whether the allocation may be modified.\n+    pub mutable: bool,\n     /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n-    pub static_kind: StaticKind,\n+    /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n+    pub kind: Kind,\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum StaticKind {\n-    /// may be deallocated without breaking miri's invariants\n-    NotStatic,\n-    /// may be modified, but never deallocated\n-    Mutable,\n-    /// may neither be modified nor deallocated\n-    Immutable,\n+pub enum Kind {\n+    /// Error if deallocated any other way than `rust_deallocate`\n+    Rust,\n+    /// Error if deallocated any other way than `free`\n+    C,\n+    /// Error if deallocated via `rust_deallocate`\n+    Stack,\n+    /// May never be deallocated\n+    Static,\n+    /// Part of env var emulation\n+    Env,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -181,14 +187,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(MemoryPointer::new(alloc_id, 0));\n         }\n \n-        let ptr = self.allocate(bytes.len() as u64, 1)?;\n+        let ptr = self.allocate(bytes.len() as u64, 1, Kind::Static)?;\n         self.write_bytes(PrimVal::Ptr(ptr), bytes)?;\n-        self.mark_static_initalized(ptr.alloc_id, false)?;\n+        self.mark_static_initalized(ptr.alloc_id, true)?;\n         self.literal_alloc_cache.insert(bytes.to_vec(), ptr.alloc_id);\n         Ok(ptr)\n     }\n \n-    pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn allocate(&mut self, size: u64, align: u64, kind: Kind) -> EvalResult<'tcx, MemoryPointer> {\n         assert_ne!(align, 0);\n         assert!(align.is_power_of_two());\n \n@@ -206,57 +212,54 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n-            static_kind: StaticKind::NotStatic,\n+            kind,\n+            mutable: true,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n         Ok(MemoryPointer::new(id, 0))\n     }\n \n-    // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n-    // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64, kind: Kind) -> EvalResult<'tcx, MemoryPointer> {\n         use std::cmp::min;\n \n-        // TODO(solson): Report error about non-__rust_allocate'd pointer.\n         if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n             return Err(EvalError::ReallocateNonBasePtr);\n         }\n-        if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n-            return Err(EvalError::ReallocatedStaticMemory);\n+        if let Ok(alloc) = self.get(ptr.alloc_id) {\n+            if alloc.kind != kind {\n+                return Err(EvalError::ReallocatedWrongMemoryKind(alloc.kind, kind));\n+            }\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n-        let new_ptr = self.allocate(new_size, new_align)?;\n+        let new_ptr = self.allocate(new_size, new_align, kind)?;\n         self.copy(ptr.into(), new_ptr.into(), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n-        self.deallocate(ptr, Some((old_size, old_align)))?;\n+        self.deallocate(ptr, Some((old_size, old_align)), kind)?;\n \n         Ok(new_ptr)\n     }\n \n-    // TODO(solson): See comment on `reallocate`.\n-    pub fn deallocate(&mut self, ptr: MemoryPointer, size_and_align: Option<(u64, u64)>) -> EvalResult<'tcx> {\n+    pub fn deallocate(&mut self, ptr: MemoryPointer, size_and_align: Option<(u64, u64)>, kind: Kind) -> EvalResult<'tcx> {\n         if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n-            // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::DeallocateNonBasePtr);\n         }\n \n-        {\n-            // deallocate_local in eval_context.rs relies on nothing actually having changed when this error occurs.\n-            // So we do this test in advance.\n-            let alloc = self.get(ptr.alloc_id)?;\n-            if alloc.static_kind != StaticKind::NotStatic {\n-                return Err(EvalError::DeallocatedStaticMemory);\n-            }\n-            if let Some((size, align)) = size_and_align {\n-                if size != alloc.bytes.len() as u64 || align != alloc.align {\n-                    return Err(EvalError::IncorrectAllocationInformation);\n-                }\n+        let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n+            Some(alloc) => alloc,\n+            None => return Err(EvalError::DoubleFree),\n+        };\n+\n+        if alloc.kind != kind {\n+            return Err(EvalError::DeallocatedWrongMemoryKind(alloc.kind, kind));\n+        }\n+        if let Some((size, align)) = size_and_align {\n+            if size != alloc.bytes.len() as u64 || align != alloc.align {\n+                return Err(EvalError::IncorrectAllocationInformation);\n             }\n         }\n \n-        let alloc = self.alloc_map.remove(&ptr.alloc_id).expect(\"already verified\");\n         self.memory_usage -= alloc.bytes.len() as u64;\n         debug!(\"deallocated : {}\", ptr.alloc_id);\n \n@@ -401,10 +404,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n-            Some(alloc) => match alloc.static_kind {\n-                StaticKind::Mutable |\n-                StaticKind::NotStatic => Ok(alloc),\n-                StaticKind::Immutable => Err(EvalError::ModifiedConstantMemory),\n+            Some(alloc) => if alloc.mutable {\n+                Ok(alloc)\n+            } else {\n+                Err(EvalError::ModifiedConstantMemory)\n             },\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n@@ -473,10 +476,13 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 }\n             }\n \n-            let immutable = match alloc.static_kind {\n-                StaticKind::Mutable => \" (static mut)\",\n-                StaticKind::Immutable => \" (immutable)\",\n-                StaticKind::NotStatic => \"\",\n+            let immutable = match (alloc.kind, alloc.mutable) {\n+                (Kind::Static, true) => \" (static mut)\",\n+                (Kind::Static, false) => \" (immutable)\",\n+                (Kind::Env, _) => \" (env var)\",\n+                (Kind::C, _) => \" (malloc)\",\n+                (Kind::Rust, _) => \" (heap)\",\n+                (Kind::Stack, _) => \" (stack)\",\n             };\n             trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n \n@@ -503,7 +509,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let leaks: Vec<_> = self.alloc_map\n             .iter()\n             .filter_map(|(&key, val)| {\n-                if val.static_kind == StaticKind::NotStatic {\n+                if val.kind != Kind::Static {\n                     Some(key)\n                 } else {\n                     None\n@@ -578,26 +584,31 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     /// mark an allocation pointed to by a static as static and initialized\n-    pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+    pub fn mark_inner_allocation(&mut self, alloc: AllocId, make_immutable: bool) -> EvalResult<'tcx> {\n         // relocations into other statics are not \"inner allocations\"\n         if !self.static_alloc.contains(&alloc) {\n-            self.mark_static_initalized(alloc, mutable)?;\n+            self.mark_static_initalized(alloc, make_immutable)?;\n         }\n         Ok(())\n     }\n \n     /// mark an allocation as static and initialized, either mutable or not\n-    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n-        trace!(\"mark_static_initialized {:?}, mutable: {:?}\", alloc_id, mutable);\n+    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, make_immutable: bool) -> EvalResult<'tcx> {\n+        trace!(\"mark_static_initalized {:?}, make_immutable: {:?}\", alloc_id, make_immutable);\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n-            Some(&mut Allocation { ref mut relocations, static_kind: ref mut kind @ StaticKind::NotStatic, .. }) => {\n-                *kind = if mutable {\n-                    StaticKind::Mutable\n-                } else {\n-                    StaticKind::Immutable\n-                };\n+            Some(&mut Allocation { kind: Kind::Static, ref mut mutable, .. }) => {\n+                if make_immutable {\n+                    *mutable = false;\n+                }\n+                return Ok(());\n+            },\n+            Some(&mut Allocation { ref mut relocations, ref mut kind, ref mut mutable, .. }) => {\n+                *kind = Kind::Static;\n+                if make_immutable {\n+                    *mutable = false;\n+                }\n                 // take out the relocations vector to free the borrow on self, so we can call\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n@@ -607,7 +618,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.mark_inner_allocation(alloc, mutable)?;\n+            self.mark_inner_allocation(alloc, make_immutable)?;\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "c4a8d2e73c2918d349bc9957efaf0fdfe6798b57", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/192da8819f2e936f7b944624a202a97405e689b3/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192da8819f2e936f7b944624a202a97405e689b3/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=192da8819f2e936f7b944624a202a97405e689b3", "patch": "@@ -9,7 +9,7 @@ use syntax::abi::Abi;\n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{MemoryPointer, TlsKey};\n+use memory::{MemoryPointer, TlsKey, Kind};\n use value::{PrimVal, Value};\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -558,7 +558,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align)?;\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_alloc_zeroed\" => {\n@@ -570,7 +570,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align)?;\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n                 self.memory.write_repeat(ptr.into(), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n@@ -584,7 +584,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(ptr, Some((old_size, align)))?;\n+                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if !new_align.is_power_of_two() {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n                 }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align)?;\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n@@ -657,15 +657,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align)?;\n+                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n             }\n \n             \"free\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n                 if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None)?;\n+                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n                 }\n             }\n \n@@ -789,7 +789,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var, None)?;\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -812,11 +812,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1)?;\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n                     self.memory.write_bytes(PrimVal::Ptr(value_copy), &value)?;\n                     self.memory.write_bytes(PrimVal::Ptr(value_copy.offset(value.len() as u64, self.memory.layout)?), &[0])?;\n                     if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var, None)?;\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {"}, {"sha": "6fbb973d7b1446557433f46ebac3f15244d924dd", "filename": "src/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/192da8819f2e936f7b944624a202a97405e689b3/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192da8819f2e936f7b944624a202a97405e689b3/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=192da8819f2e936f7b944624a202a97405e689b3", "patch": "@@ -1,7 +1,7 @@\n use rustc::traits::{self, Reveal};\n \n use eval_context::EvalContext;\n-use memory::MemoryPointer;\n+use memory::{MemoryPointer, Kind};\n use value::{Value, PrimVal};\n \n use rustc::hir::def_id::DefId;\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let ptr_size = self.memory.pointer_size();\n         let methods = ::rustc::traits::get_vtable_methods(self.tcx, trait_ref);\n-        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size)?;\n+        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size, Kind::Static)?;\n \n         let drop = ::eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        self.memory.mark_static_initalized(vtable.alloc_id, false)?;\n+        self.memory.mark_static_initalized(vtable.alloc_id, true)?;\n \n         Ok(vtable)\n     }"}, {"sha": "29ccf8c32131db028f95f3332f81950a53fda660", "filename": "tests/compile-fail/double_free.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/192da8819f2e936f7b944624a202a97405e689b3/tests%2Fcompile-fail%2Fdouble_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192da8819f2e936f7b944624a202a97405e689b3/tests%2Fcompile-fail%2Fdouble_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdouble_free.rs?ref=192da8819f2e936f7b944624a202a97405e689b3", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let x = Box::new(42);\n+    {\n+        let bad_box: Box<i32> = unsafe { std::ptr::read(&x) };\n+        drop(bad_box);\n+    }\n+    drop(x); //~ ERROR dangling pointer was dereferenced\n+}"}, {"sha": "1828d809b20821950cdb8a5b25156f11f05b6bac", "filename": "tests/compile-fail/stack_free.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/192da8819f2e936f7b944624a202a97405e689b3/tests%2Fcompile-fail%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192da8819f2e936f7b944624a202a97405e689b3/tests%2Fcompile-fail%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_free.rs?ref=192da8819f2e936f7b944624a202a97405e689b3", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let x = 42;\n+    let bad_box = unsafe { std::mem::transmute::<&i32, Box<i32>>(&x) };\n+    drop(bad_box); //~ ERROR tried to deallocate Stack memory but gave Rust as the kind\n+}"}]}