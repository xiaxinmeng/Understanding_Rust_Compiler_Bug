{"sha": "9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNGRlM2YzMDU4ZGRiMmNkNDM4NjNjN2MyNzIzY2VjM2QwZmMzMGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-31T01:00:38Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-24T01:23:21Z"}, "message": "libsyntax: Introduce routines and remove all `@fn`s from libsyntax save the old visitor", "tree": {"sha": "1e288570b1c33e5fc7579805015d223ebe249336", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e288570b1c33e5fc7579805015d223ebe249336"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "html_url": "https://github.com/rust-lang/rust/commit/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e95996399fe6d306a206082eb1a49189c5afe878", "url": "https://api.github.com/repos/rust-lang/rust/commits/e95996399fe6d306a206082eb1a49189c5afe878", "html_url": "https://github.com/rust-lang/rust/commit/e95996399fe6d306a206082eb1a49189c5afe878"}], "stats": {"total": 140, "additions": 85, "deletions": 55}, "files": [{"sha": "be7acc7bd9ca535f34cc0b8c881834c7b17723de", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "patch": "@@ -36,22 +36,22 @@\n  * still held if needed.\n  */\n \n-\n-use std::option;\n+use std::cast;\n use std::ptr;\n+use std::routine::Runnable;\n+use std::util;\n \n /**\n  * The type representing a foreign chunk of memory\n- *\n  */\n pub struct CVec<T> {\n     priv base: *mut T,\n     priv len: uint,\n-    priv rsrc: @DtorRes\n+    priv rsrc: @DtorRes,\n }\n \n struct DtorRes {\n-  dtor: Option<@fn()>,\n+    dtor: Option<~Runnable>,\n }\n \n #[unsafe_destructor]\n@@ -64,9 +64,11 @@ impl Drop for DtorRes {\n     }\n }\n \n-fn DtorRes(dtor: Option<@fn()>) -> DtorRes {\n-    DtorRes {\n-        dtor: dtor\n+impl DtorRes {\n+    fn new(dtor: Option<~Runnable>) -> DtorRes {\n+        DtorRes {\n+            dtor: dtor,\n+        }\n     }\n }\n \n@@ -83,10 +85,10 @@ fn DtorRes(dtor: Option<@fn()>) -> DtorRes {\n  * * len - The number of elements in the buffer\n  */\n pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n-    return CVec{\n+    return CVec {\n         base: base,\n         len: len,\n-        rsrc: @DtorRes(option::None)\n+        rsrc: @DtorRes::new(None)\n     };\n }\n \n@@ -101,12 +103,12 @@ pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n  * * dtor - A function to run when the value is destructed, useful\n  *          for freeing the buffer, etc.\n  */\n-pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n-  -> CVec<T> {\n+pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: ~Runnable)\n+                                 -> CVec<T> {\n     return CVec{\n         base: base,\n         len: len,\n-        rsrc: @DtorRes(option::Some(dtor))\n+        rsrc: @DtorRes::new(Some(dtor))\n     };\n }\n \n@@ -153,6 +155,17 @@ mod tests {\n \n     use std::libc::*;\n     use std::libc;\n+    use std::routine::Runnable;\n+\n+    struct LibcFree {\n+        mem: *c_void,\n+    }\n+\n+    impl Runnable for LibcFree {\n+        fn run(~self) {\n+            libc::free(self.mem)\n+        }\n+    }\n \n     fn malloc(n: size_t) -> CVec<u8> {\n         #[fixed_stack_segment];\n@@ -163,12 +176,11 @@ mod tests {\n \n             assert!(mem as int != 0);\n \n-            return c_vec_with_dtor(mem as *mut u8, n as uint, || f(mem));\n-        }\n-\n-        fn f(mem: *c_void) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            unsafe { libc::free(mem) }\n+            return c_vec_with_dtor(mem as *mut u8,\n+                                   n as uint,\n+                                   ~LibcFree {\n+                                    mem: mem,\n+                                   } as ~Runnable);\n         }\n     }\n "}, {"sha": "e8a91b49c8ee4cb31aa4ecd70cfe0ccadbad551f", "filename": "src/libstd/routine.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibstd%2Froutine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibstd%2Froutine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Froutine.rs?ref=9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Routines are like closures except that they own their arguments and can\n+ * only run once.\n+ */\n+\n+/// A routine that takes no arguments and returns nothing.\n+pub trait Runnable {\n+    /// The entry point for the routine.\n+    fn run(~self);\n+}\n+\n+/// A convenience routine that does nothing.\n+pub struct NoOpRunnable;\n+\n+impl Runnable for NoOpRunnable {\n+    fn run(~self) {}\n+}\n+"}, {"sha": "5c1bac7418e6f330ca2d92c478edcdc0cc97fa08", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "patch": "@@ -189,7 +189,7 @@ pub mod reflect;\n pub mod condition;\n pub mod logging;\n pub mod util;\n-\n+pub mod routine;\n \n /* Unsupported interfaces */\n "}, {"sha": "4d53dd7d7bfff63c36355dc1e011260e9d11d137", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "patch": "@@ -158,11 +158,14 @@ pub mod ct {\n \n     // A fragment of the output sequence\n     #[deriving(Eq)]\n-    pub enum Piece { PieceString(~str), PieceConv(Conv), }\n+    pub enum Piece {\n+        PieceString(~str),\n+        PieceConv(Conv),\n+    }\n \n-    pub type ErrorFn = @fn(&str) -> !;\n+    pub type ErrorFn<'self> = &'self fn(&str) -> !;\n \n-    pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n+    pub fn parse_fmt_string<'a>(s: &str, err: ErrorFn<'a>) -> ~[Piece] {\n         fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n             if to > from {\n                 ps.push(PieceString(s.slice(from, to).to_owned()));\n@@ -185,7 +188,10 @@ pub mod ct {\n                     i += 1;\n                 } else {\n                     push_slice(&mut pieces, s, h, i - 1);\n-                    let Parsed {val, next} = parse_conversion(s, i, lim, err);\n+                    let Parsed {\n+                        val,\n+                        next\n+                    } = parse_conversion(s, i, lim, |s| err(s));\n                     pieces.push(val);\n                     i = next;\n                 }\n@@ -224,8 +230,8 @@ pub mod ct {\n         }\n     }\n \n-    pub fn parse_conversion(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n-        Parsed<Piece> {\n+    pub fn parse_conversion<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n+                                -> Parsed<Piece> {\n         let param = parse_parameter(s, i, lim);\n         // avoid copying ~[Flag] by destructuring\n         let Parsed {val: flags_val, next: flags_next} = parse_flags(s,\n@@ -308,8 +314,8 @@ pub mod ct {\n         }\n     }\n \n-    pub fn parse_type(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n-        Parsed<Ty> {\n+    pub fn parse_type<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n+                          -> Parsed<Ty> {\n         if i >= lim { err(\"missing type in conversion\"); }\n \n         // FIXME (#2249): Do we really want two signed types here?"}, {"sha": "d48fa03c0ef258fbeb4ddf6142d7578c57da76b9", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "patch": "@@ -38,7 +38,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     fn parse_fmt_err_(cx: @ExtCtxt, sp: Span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n-    let parse_fmt_err: @fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n+    let parse_fmt_err: &fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n     let pieces = parse_fmt_string(fmt, parse_fmt_err);\n     MRExpr(pieces_to_expr(cx, sp, pieces, args))\n }"}, {"sha": "66fe125aef4cf7c6b0adf9dd4660c4341233c526", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9a4de3f3058ddb2cd43863c7c2723cec3d0fc30a", "patch": "@@ -869,35 +869,19 @@ mod test {\n     use parse::token;\n     use print::pprust;\n     use super::*;\n-\n-    struct IdentFolder {\n-        f: @fn(ast::ident)->ast::ident,\n-    }\n-\n-    impl ast_fold for IdentFolder {\n-        fn fold_ident(@self, i: ident) -> ident {\n-            (self.f)(i)\n-        }\n-    }\n-\n-    // taken from expand\n-    // given a function from idents to idents, produce\n-    // an ast_fold that applies that function:\n-    pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold {\n-        @IdentFolder {\n-            f: f,\n-        } as @ast_fold\n-    }\n-\n+    \n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: @pprust::ps, crate: &ast::Crate) {\n         pprust::print_mod(s, &crate.module, crate.attrs);\n     }\n \n     // change every identifier to \"zz\"\n-    pub fn to_zz() -> @fn(ast::Ident)->ast::Ident {\n-        let zz_id = token::str_to_ident(\"zz\");\n-        |_id| {zz_id}\n+    struct ToZzIdentFolder;\n+\n+    impl ast_fold for ToZzIdentFolder {\n+        fn fold_ident(&self, _: ident) -> ident {\n+            token::str_to_ident(\"zz\")\n+        }\n     }\n \n     // maybe add to expand.rs...\n@@ -917,7 +901,7 @@ mod test {\n \n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n-        let zz_fold = fun_to_ident_folder(to_zz());\n+        let zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n@@ -928,7 +912,7 @@ mod test {\n \n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n-        let zz_fold = fun_to_ident_folder(to_zz());\n+        let zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"macro_rules! a {(b $c:expr $(d $e:token)f+\n => (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n@@ -940,7 +924,7 @@ mod test {\n \n     // and in cast expressions... this appears to be an existing bug.\n     #[test] fn ident_transformation_in_types () {\n-        let zz_fold = fun_to_ident_folder(to_zz());\n+        let zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"fn a() {let z = 13 as int;}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\","}]}