{"sha": "b91e0a378690871fa744768f38d42bd90830bcd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MWUwYTM3ODY5MDg3MWZhNzQ0NzY4ZjM4ZDQyYmQ5MDgzMGJjZDA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-13T09:06:37Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-13T11:54:34Z"}, "message": "move span and token to tt reader", "tree": {"sha": "a7b82e48e51a805aeb8c8aa2c530130424b9beef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7b82e48e51a805aeb8c8aa2c530130424b9beef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b91e0a378690871fa744768f38d42bd90830bcd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b91e0a378690871fa744768f38d42bd90830bcd0", "html_url": "https://github.com/rust-lang/rust/commit/b91e0a378690871fa744768f38d42bd90830bcd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b91e0a378690871fa744768f38d42bd90830bcd0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d29f0d23c3624047a3f3671a8e352783e8796373", "url": "https://api.github.com/repos/rust-lang/rust/commits/d29f0d23c3624047a3f3671a8e352783e8796373", "html_url": "https://github.com/rust-lang/rust/commit/d29f0d23c3624047a3f3671a8e352783e8796373"}], "stats": {"total": 75, "additions": 35, "deletions": 40}, "files": [{"sha": "9caa9ea807c1d473b2b5c1c304356ce559e41907", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b91e0a378690871fa744768f38d42bd90830bcd0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91e0a378690871fa744768f38d42bd90830bcd0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b91e0a378690871fa744768f38d42bd90830bcd0", "patch": "@@ -62,10 +62,6 @@ pub struct StringReader<'a> {\n     // cache a direct reference to the source text, so that we don't have to\n     // retrieve it via `self.source_file.src.as_ref().unwrap()` all the time.\n     src: Lrc<String>,\n-    token: token::Token,\n-    span: Span,\n-    /// The raw source span which *does not* take `override_span` into account\n-    span_src_raw: Span,\n     override_span: Option<Span>,\n }\n \n@@ -113,8 +109,6 @@ impl<'a> StringReader<'a> {\n             sp: self.peek_span,\n         };\n         self.advance_token()?;\n-        self.span_src_raw = self.peek_span_src_raw;\n-\n         Ok(ret_val)\n     }\n \n@@ -151,9 +145,6 @@ impl<'a> StringReader<'a> {\n             }\n         }\n \n-        self.token = t.tok.clone();\n-        self.span = t.sp;\n-\n         Ok(t)\n     }\n \n@@ -243,9 +234,6 @@ impl<'a> StringReader<'a> {\n             peek_span_src_raw: syntax_pos::DUMMY_SP,\n             src,\n             fatal_errs: Vec::new(),\n-            token: token::Eof,\n-            span: syntax_pos::DUMMY_SP,\n-            span_src_raw: syntax_pos::DUMMY_SP,\n             override_span,\n         }\n     }"}, {"sha": "1070d6dcb1b34c3205784f6cab9a3b26d7f84b53", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b91e0a378690871fa744768f38d42bd90830bcd0/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91e0a378690871fa744768f38d42bd90830bcd0/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=b91e0a378690871fa744768f38d42bd90830bcd0", "patch": "@@ -9,6 +9,8 @@ impl<'a> StringReader<'a> {\n     crate fn into_token_trees(self) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n         let mut tt_reader = TokenTreesReader {\n             string_reader: self,\n+            token: token::Eof,\n+            span: syntax_pos::DUMMY_SP,\n             open_braces: Vec::new(),\n             unmatched_braces: Vec::new(),\n             matching_delim_spans: Vec::new(),\n@@ -21,6 +23,8 @@ impl<'a> StringReader<'a> {\n \n struct TokenTreesReader<'a> {\n     string_reader: StringReader<'a>,\n+    token: token::Token,\n+    span: Span,\n     /// Stack of open delimiters and their spans. Used for error message.\n     open_braces: Vec<(token::DelimToken, Span)>,\n     unmatched_braces: Vec<UnmatchedBrace>,\n@@ -36,7 +40,8 @@ impl<'a> TokenTreesReader<'a> {\n     fn parse_all_token_trees(&mut self) -> PResult<'a, TokenStream> {\n         let mut tts = Vec::new();\n \n-        while self.string_reader.token != token::Eof {\n+        self.real_token();\n+        while self.token != token::Eof {\n             tts.push(self.parse_token_tree()?);\n         }\n \n@@ -47,7 +52,7 @@ impl<'a> TokenTreesReader<'a> {\n     fn parse_token_trees_until_close_delim(&mut self) -> TokenStream {\n         let mut tts = vec![];\n         loop {\n-            if let token::CloseDelim(..) = self.string_reader.token {\n+            if let token::CloseDelim(..) = self.token {\n                 return TokenStream::new(tts);\n             }\n \n@@ -63,11 +68,11 @@ impl<'a> TokenTreesReader<'a> {\n \n     fn parse_token_tree(&mut self) -> PResult<'a, TreeAndJoint> {\n         let sm = self.string_reader.sess.source_map();\n-        match self.string_reader.token {\n+        match self.token {\n             token::Eof => {\n                 let msg = \"this file contains an un-closed delimiter\";\n                 let mut err = self.string_reader.sess.span_diagnostic\n-                    .struct_span_err(self.span(), msg);\n+                    .struct_span_err(self.span, msg);\n                 for &(_, sp) in &self.open_braces {\n                     err.span_label(sp, \"un-closed delimiter\");\n                 }\n@@ -97,21 +102,21 @@ impl<'a> TokenTreesReader<'a> {\n             },\n             token::OpenDelim(delim) => {\n                 // The span for beginning of the delimited section\n-                let pre_span = self.span();\n+                let pre_span = self.span;\n \n                 // Parse the open delimiter.\n-                self.open_braces.push((delim, self.span()));\n-                self.string_reader.real_token();\n+                self.open_braces.push((delim, self.span));\n+                self.real_token();\n \n                 // Parse the token trees within the delimiters.\n                 // We stop at any delimiter so we can try to recover if the user\n                 // uses an incorrect delimiter.\n                 let tts = self.parse_token_trees_until_close_delim();\n \n                 // Expand to cover the entire delimited token tree\n-                let delim_span = DelimSpan::from_pair(pre_span, self.span());\n+                let delim_span = DelimSpan::from_pair(pre_span, self.span);\n \n-                match self.string_reader.token {\n+                match self.token {\n                     // Correct delimiter.\n                     token::CloseDelim(d) if d == delim => {\n                         let (open_brace, open_brace_span) = self.open_braces.pop().unwrap();\n@@ -121,26 +126,26 @@ impl<'a> TokenTreesReader<'a> {\n                             self.matching_delim_spans.clear();\n                         } else {\n                             self.matching_delim_spans.push(\n-                                (open_brace, open_brace_span, self.span()),\n+                                (open_brace, open_brace_span, self.span),\n                             );\n                         }\n                         // Parse the close delimiter.\n-                        self.string_reader.real_token();\n+                        self.real_token();\n                     }\n                     // Incorrect delimiter.\n                     token::CloseDelim(other) => {\n                         let mut unclosed_delimiter = None;\n                         let mut candidate = None;\n-                        if self.last_unclosed_found_span != Some(self.span()) {\n+                        if self.last_unclosed_found_span != Some(self.span) {\n                             // do not complain about the same unclosed delimiter multiple times\n-                            self.last_unclosed_found_span = Some(self.span());\n+                            self.last_unclosed_found_span = Some(self.span);\n                             // This is a conservative error: only report the last unclosed\n                             // delimiter. The previous unclosed delimiters could actually be\n                             // closed! The parser just hasn't gotten to them yet.\n                             if let Some(&(_, sp)) = self.open_braces.last() {\n                                 unclosed_delimiter = Some(sp);\n                             };\n-                            if let Some(current_padding) = sm.span_to_margin(self.span()) {\n+                            if let Some(current_padding) = sm.span_to_margin(self.span) {\n                                 for (brace, brace_span) in &self.open_braces {\n                                     if let Some(padding) = sm.span_to_margin(*brace_span) {\n                                         // high likelihood of these two corresponding\n@@ -154,7 +159,7 @@ impl<'a> TokenTreesReader<'a> {\n                             self.unmatched_braces.push(UnmatchedBrace {\n                                 expected_delim: tok,\n                                 found_delim: other,\n-                                found_span: self.span(),\n+                                found_span: self.span,\n                                 unclosed_span: unclosed_delimiter,\n                                 candidate_span: candidate,\n                             });\n@@ -170,7 +175,7 @@ impl<'a> TokenTreesReader<'a> {\n                         //     bar(baz(\n                         // }  // Incorrect delimiter but matches the earlier `{`\n                         if !self.open_braces.iter().any(|&(b, _)| b == other) {\n-                            self.string_reader.real_token();\n+                            self.real_token();\n                         }\n                     }\n                     token::Eof => {\n@@ -190,28 +195,31 @@ impl<'a> TokenTreesReader<'a> {\n             token::CloseDelim(_) => {\n                 // An unexpected closing delimiter (i.e., there is no\n                 // matching opening delimiter).\n-                let token_str = token_to_string(&self.string_reader.token);\n+                let token_str = token_to_string(&self.token);\n                 let msg = format!(\"unexpected close delimiter: `{}`\", token_str);\n                 let mut err = self.string_reader.sess.span_diagnostic\n-                    .struct_span_err(self.span(), &msg);\n-                err.span_label(self.span(), \"unexpected close delimiter\");\n+                    .struct_span_err(self.span, &msg);\n+                err.span_label(self.span, \"unexpected close delimiter\");\n                 Err(err)\n             },\n             _ => {\n-                let tt = TokenTree::Token(self.span(), self.string_reader.token.clone());\n+                let tt = TokenTree::Token(self.span, self.token.clone());\n                 // Note that testing for joint-ness here is done via the raw\n                 // source span as the joint-ness is a property of the raw source\n                 // rather than wanting to take `override_span` into account.\n-                let raw = self.string_reader.span_src_raw;\n-                self.string_reader.real_token();\n-                let is_joint = raw.hi() == self.string_reader.span_src_raw.lo()\n-                    && token::is_op(&self.string_reader.token);\n+                let raw = self.string_reader.peek_span_src_raw;\n+                self.real_token();\n+                let is_joint = raw.hi() == self.string_reader.peek_span_src_raw.lo()\n+                    && token::is_op(&self.token);\n                 Ok((tt, if is_joint { Joint } else { NonJoint }))\n             }\n         }\n     }\n \n-    fn span(&self) -> Span {\n-        self.string_reader.span\n+    fn real_token(&mut self) {\n+        let t = self.string_reader.real_token();\n+        self.token = t.tok;\n+        self.span = t.sp;\n     }\n }\n+"}, {"sha": "4a9a7aec6addea8e664bbd47c36ac3b0dc2a8756", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b91e0a378690871fa744768f38d42bd90830bcd0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91e0a378690871fa744768f38d42bd90830bcd0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b91e0a378690871fa744768f38d42bd90830bcd0", "patch": "@@ -301,8 +301,7 @@ pub fn maybe_file_to_stream(\n     source_file: Lrc<SourceFile>,\n     override_span: Option<Span>,\n ) -> Result<(TokenStream, Vec<lexer::UnmatchedBrace>), Vec<Diagnostic>> {\n-    let mut srdr = lexer::StringReader::new_or_buffered_errs(sess, source_file, override_span)?;\n-    srdr.real_token();\n+    let srdr = lexer::StringReader::new_or_buffered_errs(sess, source_file, override_span)?;\n     let (token_trees, unmatched_braces) = srdr.into_token_trees();\n \n     match token_trees {"}]}