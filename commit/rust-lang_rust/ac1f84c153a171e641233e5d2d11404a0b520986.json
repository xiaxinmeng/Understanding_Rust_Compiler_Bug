{"sha": "ac1f84c153a171e641233e5d2d11404a0b520986", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMWY4NGMxNTNhMTcxZTY0MTIzM2U1ZDJkMTE0MDRhMGI1MjA5ODY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-05T22:36:11Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-07T19:11:17Z"}, "message": "Don't check impl ty params for equality with trait ty params\n\nThis was too restrictive. We need to check the number of ty params,\nand that the bounds are equal, but otherwise require_same_types does the job.\n\nCloses #2611", "tree": {"sha": "e5e5cef275c3f158db97aa653f164ae28a6ac109", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5e5cef275c3f158db97aa653f164ae28a6ac109"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac1f84c153a171e641233e5d2d11404a0b520986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac1f84c153a171e641233e5d2d11404a0b520986", "html_url": "https://github.com/rust-lang/rust/commit/ac1f84c153a171e641233e5d2d11404a0b520986", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac1f84c153a171e641233e5d2d11404a0b520986/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6b51547c14780a0473a5bcae90c8d4b0530b7c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b51547c14780a0473a5bcae90c8d4b0530b7c8", "html_url": "https://github.com/rust-lang/rust/commit/c6b51547c14780a0473a5bcae90c8d4b0530b7c8"}], "stats": {"total": 124, "additions": 115, "deletions": 9}, "files": [{"sha": "3206d1709c5e8dfe058edabfe874380b0ead93ec", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ac1f84c153a171e641233e5d2d11404a0b520986", "patch": "@@ -24,6 +24,8 @@ use astconv::{ast_conv, ty_of_fn_decl, ty_of_arg, ast_ty_to_ty};\n use ast_util::trait_method_to_ty_method;\n use rscope::*;\n use ty::{FnTyBase, FnMeta, FnSig};\n+use util::common::pluralize;\n+use util::ppaux::bound_to_str;\n \n fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n \n@@ -263,9 +265,13 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n                           self type\", tcx.sess.str_of(impl_m.ident)));\n     }\n \n-    if impl_m.tps != trait_m.tps {\n-        tcx.sess.span_err(sp, ~\"method `\" + tcx.sess.str_of(trait_m.ident) +\n-                          ~\"` has an incompatible set of type parameters\");\n+    if impl_m.tps.len() != trait_m.tps.len() {\n+        tcx.sess.span_err(sp, #fmt(\"method `%s` \\\n+           has %u type %s, but its trait declaration has %u type %s\",\n+           tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n+           pluralize(impl_m.tps.len(), ~\"parameter\"),\n+           trait_m.tps.len(),\n+           pluralize(trait_m.tps.len(), ~\"parameter\")));\n         return;\n     }\n \n@@ -278,6 +284,28 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         return;\n     }\n \n+    for trait_m.tps.eachi() |i, trait_param_bounds| {\n+        // For each of the corresponding impl ty param's bounds...\n+        let impl_param_bounds = impl_m.tps[i];\n+        // Make sure the bounds lists have the same length\n+        // Would be nice to use the ty param names in the error message,\n+        // but we don't have easy access to them here\n+        if impl_param_bounds.len() != trait_param_bounds.len() {\n+           tcx.sess.span_err(sp, #fmt(\"in method `%s`, \\\n+             type parameter %u has %u %s, but the same type \\\n+             parameter in its trait declaration has %u %s\",\n+             tcx.sess.str_of(trait_m.ident),\n+             i, impl_param_bounds.len(),\n+             pluralize(impl_param_bounds.len(), ~\"bound\"),\n+             trait_param_bounds.len(),\n+             pluralize(trait_param_bounds.len(), ~\"bound\")));\n+           return;\n+        }\n+        // tjc: I'm mildly worried that there's something I'm\n+        // not checking that require_same_types doesn't catch,\n+        // but I can't figure out what.\n+    }\n+\n     // Perform substitutions so that the trait/impl methods are expressed\n     // in terms of the same set of type/region parameters:\n     // - replace trait type parameters with those from `trait_substs`"}, {"sha": "901d5d504eb56a0c3419dff2c5bece08251e6a71", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=ac1f84c153a171e641233e5d2d11404a0b520986", "patch": "@@ -94,6 +94,11 @@ fn is_main_name(path: syntax::ast_map::path) -> bool {\n     )\n }\n \n+fn pluralize(n: uint, s: ~str) -> ~str {\n+    if n == 1 { s }\n+    else { str::concat([s, ~\"s\"]) }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "3a27a521985c61938dd0bda8f250476217d37e54", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=ac1f84c153a171e641233e5d2d11404a0b520986", "patch": "@@ -1,9 +1,11 @@\n use std::map::hashmap;\n use middle::ty;\n use middle::ty::{arg, canon_mode};\n+use middle::ty::{bound_copy, bound_const, bound_owned, bound_send,\n+        bound_trait};\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n use middle::ty::{ck_block, ck_box, ck_uniq, ctxt, field, method};\n-use middle::ty::{mt, t};\n+use middle::ty::{mt, t, param_bound};\n use middle::ty::{re_bound, re_free, re_scope, re_var, re_static, region};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_enum};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n@@ -233,6 +235,16 @@ fn tys_to_str(cx: ctxt, ts: ~[t]) -> ~str {\n     rs\n }\n \n+fn bound_to_str(cx: ctxt, b: param_bound) -> ~str {\n+    match b {\n+      bound_copy     => ~\"copy\",\n+      bound_owned    => ~\"owned\",\n+      bound_send     => ~\"send\",\n+      bound_const    => ~\"const\",\n+      bound_trait(t) => ty_to_str(cx, t)\n+    }\n+}\n+\n fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: ast::mode, ty: t}) ->\n        ~str {"}, {"sha": "172fb81d3bbe79d6da8c4a36b67c0d698c8916d0", "filename": "src/test/compile-fail/issue-2611-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs?ref=ac1f84c153a171e641233e5d2d11404a0b520986", "patch": "@@ -0,0 +1,21 @@\n+// Tests that impl methods are matched to traits exactly:\n+// we might be tempted to think matching is contravariant, but if\n+// we let an impl method can have more permissive bounds than the trait\n+// method it's implementing, the return type might be less specific than\n+// needed. Just punt and make it invariant.\n+import iter;\n+import iter::BaseIter;\n+\n+trait A {\n+  fn b<C:copy const, D>(x: C) -> C;\n+}\n+\n+struct E {\n+ f: int;\n+}\n+\n+impl E: A {\n+  fn b<F:copy, G>(_x: F) -> F { fail } //~ ERROR in method `b`, type parameter 0 has 1 bound, but\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "95f5685d84fda7bdf38fb887ec1a40a243a3745f", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=ac1f84c153a171e641233e5d2d11404a0b520986", "patch": "@@ -0,0 +1,18 @@\n+// Tests that an impl method's bounds aren't *more* restrictive\n+// than the trait method it's implementing\n+import iter;\n+import iter::BaseIter;\n+\n+trait A {\n+  fn b<C:copy, D>(x: C) -> C;\n+}\n+\n+struct E {\n+ f: int;\n+}\n+\n+impl E: A {\n+  fn b<F:copy const, G>(_x: F) -> F { fail } //~ ERROR in method `b`, type parameter 0 has 2 bounds, but\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "4278dcb2fb6972c7c615dda205a6492110a2c0dd", "filename": "src/test/compile-fail/issue-2611-5.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs?ref=ac1f84c153a171e641233e5d2d11404a0b520986", "patch": "@@ -0,0 +1,19 @@\n+// Tests that ty params get matched correctly when comparing\n+// an impl against a trait\n+import iter;\n+import iter::BaseIter;\n+\n+trait A {\n+  fn b<C:copy, D>(x: C) -> C;\n+}\n+\n+struct E {\n+ f: int;\n+}\n+\n+impl E: A {\n+  // n.b. The error message is awful -- see #3404\n+  fn b<F:copy, G>(_x: G) -> G { fail } //~ ERROR method `b` has an incompatible type\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "94456ecb25bb1eeae952e6ef81650a2472982d87", "filename": "src/test/run-pass/issue-2611.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1f84c153a171e641233e5d2d11404a0b520986/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=ac1f84c153a171e641233e5d2d11404a0b520986", "patch": "@@ -1,9 +1,12 @@\n-// xfail-test\n-use iter::base_iter;\n+use iter::BaseIter;\n \n-impl Q<A> for base_iter<A> {\n-   fn flat_map_to_vec<B:copy, IB:base_iter<B>>(op: fn(B) -> IB) -> ~[B] {\n-      iter::flat_map_to_vec(self, op)\n+trait FlatMapToVec<A> {\n+  fn flat_map_to_vec<B:copy, IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B];\n+}\n+\n+impl<A:copy> BaseIter<A>: FlatMapToVec<A> {\n+   fn flat_map_to_vec<B:copy, IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B] {\n+     iter::flat_map_to_vec(self, op)\n    }\n }\n "}]}