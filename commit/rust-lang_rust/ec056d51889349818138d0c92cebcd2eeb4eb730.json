{"sha": "ec056d51889349818138d0c92cebcd2eeb4eb730", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMDU2ZDUxODg5MzQ5ODE4MTM4ZDBjOTJjZWJjZDJlZWI0ZWI3MzA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T11:34:35Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T06:44:37Z"}, "message": "re-do argument passing one more time to finally be sane", "tree": {"sha": "71f034498bf54b237b20ee32ea82f29b476dbb36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71f034498bf54b237b20ee32ea82f29b476dbb36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec056d51889349818138d0c92cebcd2eeb4eb730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec056d51889349818138d0c92cebcd2eeb4eb730", "html_url": "https://github.com/rust-lang/rust/commit/ec056d51889349818138d0c92cebcd2eeb4eb730", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec056d51889349818138d0c92cebcd2eeb4eb730/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8a40aad1b309bdeac2bf2a7d1509aa568f84093", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8a40aad1b309bdeac2bf2a7d1509aa568f84093", "html_url": "https://github.com/rust-lang/rust/commit/b8a40aad1b309bdeac2bf2a7d1509aa568f84093"}], "stats": {"total": 382, "additions": 189, "deletions": 193}, "files": [{"sha": "6250e12f43043beac2ba90a37fb0e8d286733542", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ec056d51889349818138d0c92cebcd2eeb4eb730", "patch": "@@ -512,6 +512,7 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n         mem::discriminant(&self).hash_stable(hcx, hasher);\n \n         match *self {\n+            FunctionArgCountMismatch |\n             DanglingPointerDeref |\n             DoubleFree |\n             InvalidMemoryAccess |\n@@ -558,7 +559,11 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             },\n             ReferencedConstant(ref err) => err.hash_stable(hcx, hasher),\n             MachineError(ref err) => err.hash_stable(hcx, hasher),\n-            FunctionPointerTyMismatch(a, b) => {\n+            FunctionAbiMismatch(a, b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            FunctionArgMismatch(a, b) => {\n                 a.hash_stable(hcx, hasher);\n                 b.hash_stable(hcx, hasher)\n             },"}, {"sha": "84d55c84ce154b8e23dd643c5f571ca3e53c55d3", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=ec056d51889349818138d0c92cebcd2eeb4eb730", "patch": "@@ -11,9 +11,10 @@\n use std::{fmt, env};\n \n use mir;\n-use ty::{FnSig, Ty, layout};\n+use ty::{Ty, layout};\n use ty::layout::{Size, Align};\n use rustc_data_structures::sync::Lrc;\n+use rustc_target::spec::abi::Abi;\n \n use super::{\n     Pointer, Lock, AccessKind\n@@ -182,7 +183,10 @@ pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant\n     MachineError(String),\n-    FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n+\n+    FunctionAbiMismatch(Abi, Abi),\n+    FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n+    FunctionArgCountMismatch,\n     NoMirFor(String),\n     UnterminatedCString(Pointer),\n     DanglingPointerDeref,\n@@ -290,8 +294,8 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n         use self::EvalErrorKind::*;\n         match *self {\n             MachineError(ref inner) => inner,\n-            FunctionPointerTyMismatch(..) =>\n-                \"tried to call a function through a function pointer of a different type\",\n+            FunctionAbiMismatch(..) | FunctionArgMismatch(..) | FunctionArgCountMismatch =>\n+                \"tried to call a function through a function pointer of incompatible type\",\n             InvalidMemoryAccess =>\n                 \"tried to access memory through an invalid pointer\",\n             DanglingPointerDeref =>\n@@ -459,9 +463,15 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                 write!(f, \"type validation failed: {}\", err)\n             }\n             NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n-            FunctionPointerTyMismatch(sig, got) =>\n-                write!(f, \"tried to call a function with sig {} through a \\\n-                       function pointer of type {}\", sig, got),\n+            FunctionAbiMismatch(caller_abi, callee_abi) =>\n+                write!(f, \"tried to call a function with ABI {:?} using caller ABI {:?}\",\n+                    callee_abi, caller_abi),\n+            FunctionArgMismatch(caller_ty, callee_ty) =>\n+                write!(f, \"tried to call a function with argument of type {:?} \\\n+                           passing data of type {:?}\",\n+                    callee_ty, caller_ty),\n+            FunctionArgCountMismatch =>\n+                write!(f, \"tried to call a function with incorrect number of arguments\"),\n             BoundsCheck { ref len, ref index } =>\n                 write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index),\n             ReallocatedWrongMemoryKind(ref old, ref new) =>"}, {"sha": "60b85e8a8eb9aad5c4eed9938a5caeabb07009f6", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ec056d51889349818138d0c92cebcd2eeb4eb730", "patch": "@@ -487,10 +487,12 @@ impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n         use ::mir::interpret::EvalErrorKind::*;\n         Some(match *self {\n             MachineError(ref err) => MachineError(err.clone()),\n-            FunctionPointerTyMismatch(a, b) => FunctionPointerTyMismatch(\n+            FunctionAbiMismatch(a, b) => FunctionAbiMismatch(a, b),\n+            FunctionArgMismatch(a, b) => FunctionArgMismatch(\n                 tcx.lift(&a)?,\n                 tcx.lift(&b)?,\n             ),\n+            FunctionArgCountMismatch => FunctionArgCountMismatch,\n             NoMirFor(ref s) => NoMirFor(s.clone()),\n             UnterminatedCString(ptr) => UnterminatedCString(ptr),\n             DanglingPointerDeref => DanglingPointerDeref,"}, {"sha": "08ee30e5948a68bdb5ea6a735e2a9e74990db58a", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 160, "deletions": 183, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=ec056d51889349818138d0c92cebcd2eeb4eb730", "patch": "@@ -10,13 +10,12 @@\n \n use std::borrow::Cow;\n \n-use rustc::mir;\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::{mir, ty};\n+use rustc::ty::layout::{self, TyLayout, LayoutOf};\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n+use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n     EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup\n };\n@@ -59,7 +58,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n-                    // Compare using binary_op\n+                    // Compare using binary_op, to also support pointer values\n                     let const_int = Scalar::from_uint(const_int, discr.layout.size);\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n                         discr,\n@@ -86,37 +85,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n \n                 let func = self.eval_operand(func, None)?;\n-                let (fn_def, sig) = match func.layout.ty.sty {\n+                let (fn_def, abi) = match func.layout.ty.sty {\n                     ty::FnPtr(sig) => {\n+                        let caller_abi = sig.abi();\n                         let fn_ptr = self.read_scalar(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n-                        let instance_ty = instance.ty(*self.tcx);\n-                        match instance_ty.sty {\n-                            ty::FnDef(..) => {\n-                                let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                                    self.param_env,\n-                                    &sig,\n-                                );\n-                                let real_sig = instance_ty.fn_sig(*self.tcx);\n-                                let real_sig = self.tcx.normalize_erasing_late_bound_regions(\n-                                    self.param_env,\n-                                    &real_sig,\n-                                );\n-                                if !self.check_sig_compat(sig, real_sig)? {\n-                                    return err!(FunctionPointerTyMismatch(real_sig, sig));\n-                                }\n-                                (instance, sig)\n-                            }\n-                            _ => bug!(\"unexpected fn ptr to ty: {:?}\", instance_ty),\n-                        }\n+                        (instance, caller_abi)\n                     }\n                     ty::FnDef(def_id, substs) => {\n                         let sig = func.layout.ty.fn_sig(*self.tcx);\n-                        let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                            self.param_env,\n-                            &sig,\n-                        );\n-                        (self.resolve(def_id, substs)?, sig)\n+                        (self.resolve(def_id, substs)?, sig.abi())\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n@@ -126,11 +104,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let args = self.eval_operands(args)?;\n                 self.eval_fn_call(\n                     fn_def,\n+                    terminator.source_info.span,\n+                    abi,\n                     &args[..],\n                     dest,\n                     ret,\n-                    terminator.source_info.span,\n-                    Some(sig),\n                 )?;\n             }\n \n@@ -165,6 +143,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 if expected == cond_val {\n                     self.goto_block(Some(target))?;\n                 } else {\n+                    // Compute error message\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n@@ -187,11 +166,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n             }\n \n-            Yield { .. } => unimplemented!(\"{:#?}\", terminator.kind),\n-            GeneratorDrop => unimplemented!(),\n-            DropAndReplace { .. } => unimplemented!(),\n-            Resume => unimplemented!(),\n-            Abort => unimplemented!(),\n+            Yield { .. } |\n+            GeneratorDrop |\n+            DropAndReplace { .. } |\n+            Resume |\n+            Abort => unimplemented!(\"{:#?}\", terminator.kind),\n             FalseEdges { .. } => bug!(\"should have been eliminated by\\\n                                       `simplify_branches` mir pass\"),\n             FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n@@ -202,91 +181,67 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Decides whether it is okay to call the method with signature `real_sig`\n-    /// using signature `sig`.\n-    /// FIXME: This should take into account the platform-dependent ABI description.\n-    fn check_sig_compat(\n-        &mut self,\n-        sig: ty::FnSig<'tcx>,\n-        real_sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        fn check_ty_compat<'tcx>(ty: Ty<'tcx>, real_ty: Ty<'tcx>) -> bool {\n-            if ty == real_ty {\n-                return true;\n-            } // This is actually a fast pointer comparison\n-            return match (&ty.sty, &real_ty.sty) {\n-                // Permit changing the pointer type of raw pointers and references as well as\n-                // mutability of raw pointers.\n-                // FIXME: Should not be allowed when fat pointers are involved.\n-                (&ty::RawPtr(_), &ty::RawPtr(_)) => true,\n-                (&ty::Ref(_, _, _), &ty::Ref(_, _, _)) => {\n-                    ty.is_mutable_pointer() == real_ty.is_mutable_pointer()\n-                }\n-                // rule out everything else\n-                _ => false,\n-            };\n+    fn check_argument_compat(\n+        caller: TyLayout<'tcx>,\n+        callee: TyLayout<'tcx>,\n+    ) -> bool {\n+        if caller.ty == callee.ty {\n+            // No question\n+            return true;\n         }\n-\n-        if sig.abi == real_sig.abi && sig.variadic == real_sig.variadic &&\n-            sig.inputs_and_output.len() == real_sig.inputs_and_output.len() &&\n-            sig.inputs_and_output\n-                .iter()\n-                .zip(real_sig.inputs_and_output)\n-                .all(|(ty, real_ty)| check_ty_compat(ty, real_ty))\n-        {\n-            // Definitely good.\n-            return Ok(true);\n+        // Compare layout\n+        match (&caller.abi, &callee.abi) {\n+            (layout::Abi::Scalar(ref caller), layout::Abi::Scalar(ref callee)) =>\n+                // Different valid ranges are okay (once we enforce validity,\n+                // that will take care to make it UB to leave the range, just\n+                // like for transmute).\n+                caller.value == callee.value,\n+            // Be conservative\n+            _ => false\n         }\n+    }\n \n-        if sig.variadic || real_sig.variadic {\n-            // We're not touching this\n-            return Ok(false);\n+    /// Pass a single argument, checking the types for compatibility.\n+    fn pass_argument(\n+        &mut self,\n+        skip_zst: bool,\n+        caller_arg: &mut impl Iterator<Item=OpTy<'tcx>>,\n+        callee_arg: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        if skip_zst && callee_arg.layout.is_zst() {\n+            // Nothing to do.\n+            trace!(\"Skipping callee ZST\");\n+            return Ok(());\n         }\n-\n-        // We need to allow what comes up when a non-capturing closure is cast to a fn().\n-        match (sig.abi, real_sig.abi) {\n-            (Abi::Rust, Abi::RustCall) // check the ABIs.  This makes the test here non-symmetric.\n-                if check_ty_compat(sig.output(), real_sig.output())\n-                    && real_sig.inputs_and_output.len() == 3 => {\n-                // First argument of real_sig must be a ZST\n-                let fst_ty = real_sig.inputs_and_output[0];\n-                if self.layout_of(fst_ty)?.is_zst() {\n-                    // Second argument must be a tuple matching the argument list of sig\n-                    let snd_ty = real_sig.inputs_and_output[1];\n-                    match snd_ty.sty {\n-                        ty::Tuple(tys) if sig.inputs().len() == tys.len() =>\n-                            if sig.inputs()\n-                                .iter()\n-                                .zip(tys)\n-                                .all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n-                                return Ok(true)\n-                            },\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            _ => {}\n-        };\n-\n-        // Nope, this doesn't work.\n-        return Ok(false);\n+        let caller_arg = caller_arg.next()\n+            .ok_or_else(|| EvalErrorKind::FunctionArgCountMismatch)?;\n+        if skip_zst {\n+            debug_assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n+        }\n+        // Now, check\n+        if !Self::check_argument_compat(caller_arg.layout, callee_arg.layout) {\n+            return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n+        }\n+        self.copy_op(caller_arg, callee_arg)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments.\n-    /// `sig` is optional in case of FnPtr/FnDef -- but mandatory for closures!\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n+        span: Span,\n+        caller_abi: Abi,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n         ret: Option<mir::BasicBlock>,\n-        span: Span,\n-        sig: Option<ty::FnSig<'tcx>>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", instance);\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n+                if caller_abi != Abi::RustIntrinsic {\n+                    return err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n+                }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g. for transmute returning `!`)\n                 let dest = match dest {\n@@ -305,6 +260,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n+                // ABI check\n+                {\n+                    let callee_abi = {\n+                        let instance_ty = instance.ty(*self.tcx);\n+                        match instance_ty.sty {\n+                            ty::FnDef(..) =>\n+                                instance_ty.fn_sig(*self.tcx).abi(),\n+                            ty::Closure(..) => Abi::RustCall,\n+                            ty::Generator(..) => Abi::Rust,\n+                            _ => bug!(\"unexpected callee ty: {:?}\", instance_ty),\n+                        }\n+                    };\n+                    // Rust and RustCall are compatible\n+                    let normalize_abi = |abi| if abi == Abi::RustCall { Abi::Rust } else { abi };\n+                    if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n+                        return err!(FunctionAbiMismatch(caller_abi, callee_abi));\n+                    }\n+                }\n+\n+                // We need MIR for this fn\n                 let mir = match M::find_fn(self, instance, args, dest, ret)? {\n                     Some(mir) => mir,\n                     None => return Ok(()),\n@@ -322,89 +297,91 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     StackPopCleanup::Goto(ret),\n                 )?;\n \n-                // If we didn't get a signture, ask `fn_sig`\n-                let sig = sig.unwrap_or_else(|| {\n-                    let fn_sig = instance.ty(*self.tcx).fn_sig(*self.tcx);\n-                    self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig)\n-                });\n-                assert_eq!(sig.inputs().len(), args.len());\n-                // We can't test the types, as it is fine if the types are ABI-compatible but\n-                // not equal.\n-\n-                // Figure out how to pass which arguments.\n-                // FIXME: Somehow this is horribly full of special cases here, and codegen has\n-                // none of that.  What is going on?\n-                trace!(\n-                    \"ABI: {:?}, args: {:#?}\",\n-                    sig.abi,\n-                    args.iter()\n-                        .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n-                        .collect::<Vec<_>>()\n-                );\n-                trace!(\n-                    \"spread_arg: {:?}, locals: {:#?}\",\n-                    mir.spread_arg,\n-                    mir.args_iter()\n-                        .map(|local|\n-                            (local, self.layout_of_local(self.cur_frame(), local).unwrap().ty)\n-                        )\n-                        .collect::<Vec<_>>()\n-                );\n-\n-                // We have two iterators: Where the arguments come from,\n-                // and where they go to.\n-\n-                // For where they come from: If the ABI is RustCall, we untuple the\n-                // last incoming argument.  These do not have the same type,\n-                // so to keep the code paths uniform we accept an allocation\n-                // (for RustCall ABI only).\n-                let args_effective : Cow<[OpTy<'tcx>]> =\n-                    if sig.abi == Abi::RustCall && !args.is_empty() {\n-                        // Untuple\n-                        let (&untuple_arg, args) = args.split_last().unwrap();\n-                        trace!(\"eval_fn_call: Will pass last argument by untupling\");\n-                        Cow::from(args.iter().map(|&a| Ok(a))\n-                            .chain((0..untuple_arg.layout.fields.count()).into_iter()\n-                                .map(|i| self.operand_field(untuple_arg, i as u64))\n+                // We want to pop this frame again in case there was an error, to put\n+                // the blame in the right location.  Until the 2018 edition is used in\n+                // the compiler, we have to do this with an immediately invoked function.\n+                let res = (||{\n+                    trace!(\n+                        \"caller ABI: {:?}, args: {:#?}\",\n+                        caller_abi,\n+                        args.iter()\n+                            .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n+                            .collect::<Vec<_>>()\n+                    );\n+                    trace!(\n+                        \"spread_arg: {:?}, locals: {:#?}\",\n+                        mir.spread_arg,\n+                        mir.args_iter()\n+                            .map(|local|\n+                                (local, self.layout_of_local(self.cur_frame(), local).unwrap().ty)\n                             )\n-                            .collect::<EvalResult<Vec<OpTy<'tcx>>>>()?)\n-                    } else {\n-                        // Plain arg passing\n-                        Cow::from(args)\n+                            .collect::<Vec<_>>()\n+                    );\n+\n+                    // Figure out how to pass which arguments.\n+                    // We have two iterators: Where the arguments come from,\n+                    // and where they go to.\n+                    let skip_zst = match caller_abi {\n+                        Abi::Rust | Abi::RustCall => true,\n+                        _ => false\n                     };\n \n-                // Now we have to spread them out across the callee's locals,\n-                // taking into account the `spread_arg`.\n-                let mut args_iter = args_effective.iter();\n-                let mut local_iter = mir.args_iter();\n-                // HACK: ClosureOnceShim calls something that expects a ZST as\n-                // first argument, but the callers do not actually pass that ZST.\n-                // Codegen doesn't care because ZST arguments do not even exist there.\n-                match instance.def {\n-                    ty::InstanceDef::ClosureOnceShim { .. } if sig.abi == Abi::Rust => {\n-                        let local = local_iter.next().unwrap();\n+                    // For where they come from: If the ABI is RustCall, we untuple the\n+                    // last incoming argument.  These two iterators do not have the same type,\n+                    // so to keep the code paths uniform we accept an allocation\n+                    // (for RustCall ABI only).\n+                    let caller_args : Cow<[OpTy<'tcx>]> =\n+                        if caller_abi == Abi::RustCall && !args.is_empty() {\n+                            // Untuple\n+                            let (&untuple_arg, args) = args.split_last().unwrap();\n+                            trace!(\"eval_fn_call: Will pass last argument by untupling\");\n+                            Cow::from(args.iter().map(|&a| Ok(a))\n+                                .chain((0..untuple_arg.layout.fields.count()).into_iter()\n+                                    .map(|i| self.operand_field(untuple_arg, i as u64))\n+                                )\n+                                .collect::<EvalResult<Vec<OpTy<'tcx>>>>()?)\n+                        } else {\n+                            // Plain arg passing\n+                            Cow::from(args)\n+                        };\n+                    // Skip ZSTs\n+                    let mut caller_iter = caller_args.iter()\n+                        .filter(|op| !skip_zst || !op.layout.is_zst())\n+                        .map(|op| *op);\n+\n+                    // Now we have to spread them out across the callee's locals,\n+                    // taking into account the `spread_arg`.  If we could write\n+                    // this is a single iterator (that handles `spread_arg`), then\n+                    // `pass_argument` would be the loop body. It takes care to\n+                    // not advance `caller_iter` for ZSTs.\n+                    let mut locals_iter = mir.args_iter();\n+                    while let Some(local) = locals_iter.next() {\n                         let dest = self.eval_place(&mir::Place::Local(local))?;\n-                        assert!(dest.layout.is_zst());\n-                    }\n-                    _ => {}\n-                }\n-                // Now back to norml argument passing.\n-                while let Some(local) = local_iter.next() {\n-                    let dest = self.eval_place(&mir::Place::Local(local))?;\n-                    if Some(local) == mir.spread_arg {\n-                        // Must be a tuple\n-                        for i in 0..dest.layout.fields.count() {\n-                            let dest = self.place_field(dest, i as u64)?;\n-                            self.copy_op(*args_iter.next().unwrap(), dest)?;\n+                        if Some(local) == mir.spread_arg {\n+                            // Must be a tuple\n+                            for i in 0..dest.layout.fields.count() {\n+                                let dest = self.place_field(dest, i as u64)?;\n+                                self.pass_argument(skip_zst, &mut caller_iter, dest)?;\n+                            }\n+                        } else {\n+                            // Normal argument\n+                            self.pass_argument(skip_zst, &mut caller_iter, dest)?;\n                         }\n-                    } else {\n-                        // Normal argument\n-                        self.copy_op(*args_iter.next().unwrap(), dest)?;\n                     }\n+                    // Now we should have no more caller args\n+                    if caller_iter.next().is_some() {\n+                        trace!(\"Caller has too many args over\");\n+                        return err!(FunctionArgCountMismatch);\n+                    }\n+                    Ok(())\n+                })();\n+                match res {\n+                    Err(err) => {\n+                        self.stack.pop();\n+                        Err(err)\n+                    }\n+                    Ok(v) => Ok(v)\n                 }\n-                // Now we should be done\n-                assert!(args_iter.next().is_none());\n-                Ok(())\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n@@ -428,7 +405,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 args[0].op = Operand::Immediate(Value::Scalar(ptr.ptr.into())); // strip vtable\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(instance, &args, dest, ret, span, sig)\n+                self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)\n             }\n         }\n     }\n@@ -464,11 +441,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         self.eval_fn_call(\n             instance,\n+            span,\n+            Abi::Rust,\n             &[arg],\n             Some(dest),\n             Some(target),\n-            span,\n-            None,\n         )\n     }\n }"}, {"sha": "8d4e67b96e5b7a6a0cbf55a230ed237a236f40f8", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec056d51889349818138d0c92cebcd2eeb4eb730/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ec056d51889349818138d0c92cebcd2eeb4eb730", "patch": "@@ -153,7 +153,9 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     | MachineError(_)\n                     // at runtime these transformations might make sense\n                     // FIXME: figure out the rules and start linting\n-                    | FunctionPointerTyMismatch(..)\n+                    | FunctionAbiMismatch(..)\n+                    | FunctionArgMismatch(..)\n+                    | FunctionArgCountMismatch\n                     // fine at runtime, might be a register address or sth\n                     | ReadBytesAsPointer\n                     // fine at runtime"}]}