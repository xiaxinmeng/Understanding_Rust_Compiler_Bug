{"sha": "f6f9a0bf35f073e554a340f04e213867732d81a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZjlhMGJmMzVmMDczZTU1NGEzNDBmMDRlMjEzODY3NzMyZDgxYTE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-01T10:53:17Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-01T10:53:17Z"}, "message": "Merge #182\n\n182: Module source r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9c9cfc3f6868864d7dd1164aaff6b248f81a402b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c9cfc3f6868864d7dd1164aaff6b248f81a402b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6f9a0bf35f073e554a340f04e213867732d81a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f9a0bf35f073e554a340f04e213867732d81a1", "html_url": "https://github.com/rust-lang/rust/commit/f6f9a0bf35f073e554a340f04e213867732d81a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6f9a0bf35f073e554a340f04e213867732d81a1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "d685a9b564fe524865cda5713c527aaeb1ca6b1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d685a9b564fe524865cda5713c527aaeb1ca6b1d", "html_url": "https://github.com/rust-lang/rust/commit/d685a9b564fe524865cda5713c527aaeb1ca6b1d"}, {"sha": "f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "html_url": "https://github.com/rust-lang/rust/commit/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a"}], "stats": {"total": 152, "additions": 114, "deletions": 38}, "files": [{"sha": "6667c06e7d9ad91745e31a04783134cad10b214d", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=f6f9a0bf35f073e554a340f04e213867732d81a1", "patch": "@@ -148,7 +148,7 @@ fn complete_module_items(\n     this_item: Option<ast::NameRef>,\n     acc: &mut Vec<CompletionItem>,\n ) {\n-    let scope = ModuleScope::from_items(items);\n+    let scope = ModuleScope::new(items); // FIXME\n     acc.extend(\n         scope\n             .entries()"}, {"sha": "3a010ecf54e75ee422e57d22c60e12085e5681e8", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=f6f9a0bf35f073e554a340f04e213867732d81a1", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    ast::{self, NameOwner},\n+    ast::{self, ModuleItemOwner, NameOwner},\n     SmolStr,\n };\n use relative_path::RelativePathBuf;\n@@ -14,7 +14,10 @@ use crate::{\n     Cancelable, FileId, FileResolverImp,\n };\n \n-use super::{LinkData, LinkId, ModuleData, ModuleId, ModuleScope, ModuleTree, Problem};\n+use super::{\n+    LinkData, LinkId, ModuleData, ModuleId, ModuleScope, ModuleSource, ModuleSourceNode,\n+    ModuleTree, Problem,\n+};\n \n pub(crate) fn submodules(\n     db: &impl DescriptorDatabase,\n@@ -43,9 +46,14 @@ pub(crate) fn module_scope(\n     module_id: ModuleId,\n ) -> Cancelable<Arc<ModuleScope>> {\n     let tree = db.module_tree(source_root_id)?;\n-    let file_id = module_id.file_id(&tree);\n-    let syntax = db.file_syntax(file_id);\n-    let res = ModuleScope::new(&syntax);\n+    let source = module_id.source(&tree).resolve(db);\n+    let res = match source {\n+        ModuleSourceNode::Root(root) => ModuleScope::new(root.ast().items()),\n+        ModuleSourceNode::Inline(inline) => match inline.ast().item_list() {\n+            Some(items) => ModuleScope::new(items.items()),\n+            None => ModuleScope::new(std::iter::empty()),\n+        },\n+    };\n     Ok(Arc::new(res))\n }\n \n@@ -106,7 +114,7 @@ fn build_subtree(\n ) -> Cancelable<ModuleId> {\n     visited.insert(file_id);\n     let id = tree.push_mod(ModuleData {\n-        file_id,\n+        source: ModuleSource::File(file_id),\n         parent,\n         children: Vec::new(),\n     });"}, {"sha": "e22489fc105e8e3a550d4c209d950fd12dcb56da", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 82, "deletions": 13, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=f6f9a0bf35f073e554a340f04e213867732d81a1", "patch": "@@ -7,10 +7,17 @@ use ra_syntax::{\n };\n use relative_path::RelativePathBuf;\n \n-use crate::FileId;\n+use crate::{db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId};\n \n pub(crate) use self::scope::ModuleScope;\n \n+/// Phisically, rust source is organized as a set of files, but logically it is\n+/// organized as a tree of modules. Usually, a single file corresponds to a\n+/// single module, but it is not nessary the case.\n+///\n+/// Module encapsulate the logic of transitioning from the fuzzy world of files\n+/// (which can have multiple parents) to the precise world of modules (which\n+/// always have one parent).\n #[derive(Debug, PartialEq, Eq, Hash)]\n pub(crate) struct ModuleTree {\n     mods: Vec<ModuleData>,\n@@ -22,7 +29,7 @@ impl ModuleTree {\n         self.mods\n             .iter()\n             .enumerate()\n-            .filter(|(_idx, it)| it.file_id == file_id)\n+            .filter(|(_idx, it)| it.source.is_file(file_id))\n             .map(|(idx, _)| ModuleId(idx as u32))\n             .collect()\n     }\n@@ -32,6 +39,23 @@ impl ModuleTree {\n     }\n }\n \n+/// `ModuleSource` is the syntax tree element that produced this module:\n+/// either a file, or an inlinde module.\n+/// TODO: we don't produce Inline modules yet\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum ModuleSource {\n+    File(FileId),\n+    #[allow(dead_code)]\n+    Inline(SyntaxPtr),\n+}\n+\n+/// An owned syntax node for a module. Unlike `ModuleSource`,\n+/// this holds onto the AST for the whole file.\n+enum ModuleSourceNode {\n+    Root(ast::RootNode),\n+    Inline(ast::ModuleNode),\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub(crate) struct ModuleId(u32);\n \n@@ -50,8 +74,8 @@ pub enum Problem {\n }\n \n impl ModuleId {\n-    pub(crate) fn file_id(self, tree: &ModuleTree) -> FileId {\n-        tree.module(self).file_id\n+    pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n+        tree.module(self).source\n     }\n     pub(crate) fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n         tree.module(self).parent\n@@ -82,14 +106,18 @@ impl ModuleId {\n             .find(|it| it.name == name)?;\n         Some(*link.points_to.first()?)\n     }\n-    pub(crate) fn problems(self, tree: &ModuleTree, root: ast::Root) -> Vec<(SyntaxNode, Problem)> {\n+    pub(crate) fn problems(\n+        self,\n+        tree: &ModuleTree,\n+        db: &impl SyntaxDatabase,\n+    ) -> Vec<(SyntaxNode, Problem)> {\n         tree.module(self)\n             .children\n             .iter()\n             .filter_map(|&it| {\n                 let p = tree.link(it).problem.clone()?;\n-                let s = it.bind_source(tree, root);\n-                let s = s.name().unwrap().syntax().owned();\n+                let s = it.bind_source(tree, db);\n+                let s = s.ast().name().unwrap().syntax().owned();\n                 Some((s, p))\n             })\n             .collect()\n@@ -100,21 +128,62 @@ impl LinkId {\n     pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.link(self).owner\n     }\n-    pub(crate) fn bind_source<'a>(self, tree: &ModuleTree, root: ast::Root<'a>) -> ast::Module<'a> {\n-        imp::modules(root)\n-            .find(|(name, _)| name == &tree.link(self).name)\n-            .unwrap()\n-            .1\n+    pub(crate) fn bind_source<'a>(\n+        self,\n+        tree: &ModuleTree,\n+        db: &impl SyntaxDatabase,\n+    ) -> ast::ModuleNode {\n+        let owner = self.owner(tree);\n+        match owner.source(tree).resolve(db) {\n+            ModuleSourceNode::Root(root) => {\n+                let ast = imp::modules(root.ast())\n+                    .find(|(name, _)| name == &tree.link(self).name)\n+                    .unwrap()\n+                    .1;\n+                ast.into()\n+            }\n+            ModuleSourceNode::Inline(..) => {\n+                unimplemented!(\"https://github.com/rust-analyzer/rust-analyzer/issues/181\")\n+            }\n+        }\n     }\n }\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n struct ModuleData {\n-    file_id: FileId,\n+    source: ModuleSource,\n     parent: Option<LinkId>,\n     children: Vec<LinkId>,\n }\n \n+impl ModuleSource {\n+    pub(crate) fn as_file(self) -> Option<FileId> {\n+        match self {\n+            ModuleSource::File(f) => Some(f),\n+            ModuleSource::Inline(..) => None,\n+        }\n+    }\n+\n+    fn resolve(self, db: &impl SyntaxDatabase) -> ModuleSourceNode {\n+        match self {\n+            ModuleSource::File(file_id) => {\n+                let syntax = db.file_syntax(file_id);\n+                ModuleSourceNode::Root(syntax.ast().into())\n+            }\n+            ModuleSource::Inline(ptr) => {\n+                let syntax = db.resolve_syntax_ptr(ptr);\n+                let syntax = syntax.borrowed();\n+                let module = ast::Module::cast(syntax).unwrap();\n+                ModuleSourceNode::Inline(module.into())\n+            }\n+        }\n+    }\n+\n+    fn is_file(self, file_id: FileId) -> bool {\n+        self.as_file() == Some(file_id)\n+    }\n+}\n+\n #[derive(Hash, Debug, PartialEq, Eq)]\n struct LinkData {\n     owner: ModuleId,"}, {"sha": "215b31f8efe088f8c390201297392a5f32ec4295", "filename": "crates/ra_analysis/src/descriptors/module/scope.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs?ref=f6f9a0bf35f073e554a340f04e213867732d81a1", "patch": "@@ -1,9 +1,6 @@\n //! Backend for module-level scope resolution & completion\n \n-use ra_syntax::{\n-    ast::{self, ModuleItemOwner},\n-    AstNode, File, SmolStr,\n-};\n+use ra_syntax::{ast, AstNode, SmolStr};\n \n use crate::syntax_ptr::LocalSyntaxPtr;\n \n@@ -28,11 +25,7 @@ enum EntryKind {\n }\n \n impl ModuleScope {\n-    pub fn new(file: &File) -> ModuleScope {\n-        ModuleScope::from_items(file.ast().items())\n-    }\n-\n-    pub fn from_items<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n+    pub(crate) fn new<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n         let mut entries = Vec::new();\n         for item in items {\n             let entry = match item {\n@@ -102,11 +95,11 @@ fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ra_syntax::File;\n+    use ra_syntax::{ast::ModuleItemOwner, File};\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let file = File::parse(&code);\n-        let scope = ModuleScope::new(&file);\n+        let scope = ModuleScope::new(file.ast().items());\n         let actual = scope.entries.iter().map(|it| it.name()).collect::<Vec<_>>();\n         assert_eq!(expected, actual.as_slice());\n     }"}, {"sha": "060e2b6068e2b3b0731902d50dabc1a152b501f4", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9a0bf35f073e554a340f04e213867732d81a1/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=f6f9a0bf35f073e554a340f04e213867732d81a1", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     db::{self, FileSyntaxQuery, SyntaxDatabase},\n     descriptors::{\n         function::{FnDescriptor, FnId},\n-        module::{ModuleTree, Problem},\n+        module::{ModuleSource, ModuleTree, Problem},\n         DeclarationDescriptor, DescriptorDatabase,\n     },\n     input::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE},\n@@ -222,9 +222,15 @@ impl AnalysisImpl {\n             .into_iter()\n             .filter_map(|module_id| {\n                 let link = module_id.parent_link(&module_tree)?;\n-                let file_id = link.owner(&module_tree).file_id(&module_tree);\n-                let syntax = self.db.file_syntax(file_id);\n-                let decl = link.bind_source(&module_tree, syntax.ast());\n+                let file_id = match link.owner(&module_tree).source(&module_tree) {\n+                    ModuleSource::File(file_id) => file_id,\n+                    ModuleSource::Inline(..) => {\n+                        //TODO: https://github.com/rust-analyzer/rust-analyzer/issues/181\n+                        return None;\n+                    }\n+                };\n+                let decl = link.bind_source(&module_tree, &self.db);\n+                let decl = decl.ast();\n \n                 let sym = FileSymbol {\n                     name: decl.name().unwrap().text(),\n@@ -243,7 +249,7 @@ impl AnalysisImpl {\n             .modules_for_file(file_id)\n             .into_iter()\n             .map(|it| it.root(&module_tree))\n-            .map(|it| it.file_id(&module_tree))\n+            .filter_map(|it| it.source(&module_tree).as_file())\n             .filter_map(|it| crate_graph.crate_id_for_crate_root(it))\n             .collect();\n \n@@ -365,7 +371,7 @@ impl AnalysisImpl {\n             })\n             .collect::<Vec<_>>();\n         if let Some(m) = module_tree.any_module_for_file(file_id) {\n-            for (name_node, problem) in m.problems(&module_tree, syntax.ast()) {\n+            for (name_node, problem) in m.problems(&module_tree, &self.db) {\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n                         let create_file = FileSystemEdit::CreateFile {\n@@ -533,7 +539,7 @@ impl AnalysisImpl {\n         };\n         module_id\n             .child(module_tree, name.as_str())\n-            .map(|it| it.file_id(module_tree))\n+            .and_then(|it| it.source(&module_tree).as_file())\n             .into_iter()\n             .collect()\n     }"}]}