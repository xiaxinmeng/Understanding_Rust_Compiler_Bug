{"sha": "0f9e009987f62d3b1c59b142770a118adfc05c9f", "node_id": "C_kwDOAAsO6NoAKDBmOWUwMDk5ODdmNjJkM2IxYzU5YjE0Mjc3MGExMThhZGZjMDVjOWY", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-08-26T22:56:15Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-08-27T14:24:57Z"}, "message": "Fix C++20 SC access unsoundness", "tree": {"sha": "9f5f0db90c61db57fcf93cab801c86427b58a00b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f5f0db90c61db57fcf93cab801c86427b58a00b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f9e009987f62d3b1c59b142770a118adfc05c9f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmMKKTsACgkQGBtJ+fOP\nM3S7egv7BDNXzku+vZkxlSdCf8GpZh3UlA+aBGcojiUIWpJN26jWZ13CWcENTaKS\n4CpFvUG8Cq5KJ8auYYpZL9tepuJXQaALLzJRoeEKn3mfKWEFR3TTpX6/lOoA49Gn\ntMmT2hhFwgkUbiDVGoDwFV1jX0qJgpv9RBckhyOGRWT5n6W9dIj5MpLE6re5RmN9\nuUZQjX6VkPWuiZdbc9sM9x+2ZVcyGmjwlzSiHKDnefWMADVhJ04YoyF7RORnRcWW\njt7tSlZlApoyyDGyMVWBApHpzXh2sIg1hqmKvTnV0wapZVRlev1AWSPhmwrB2YKA\nzfPqQfyZ8329aEdtf/UmOqT7Ef0XHXzo8BN9k8shOKFanJR4EJQO1i39lQnyiTxk\nuiXugZIwhh9bCqNq7WhjsBym5xGl5Zw+RBaWyjU2Sevs/dON1M0DMb5qfJllO6Vk\nooZn0kxc6KdE6nSIaHNWuxro9kqJ87eRIw9y3ptUN6d7sUvWQQMwtk1rf0EoeRt2\nMSvKsyJ0\n=dd5Z\n-----END PGP SIGNATURE-----", "payload": "tree 9f5f0db90c61db57fcf93cab801c86427b58a00b\nparent a2467c9b2acbba6434dd49a32b5ef99ce9e57412\nauthor Andy Wang <cbeuw.andy@gmail.com> 1661554575 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1661610297 +0100\n\nFix C++20 SC access unsoundness\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f9e009987f62d3b1c59b142770a118adfc05c9f", "html_url": "https://github.com/rust-lang/rust/commit/0f9e009987f62d3b1c59b142770a118adfc05c9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f9e009987f62d3b1c59b142770a118adfc05c9f/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2467c9b2acbba6434dd49a32b5ef99ce9e57412", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2467c9b2acbba6434dd49a32b5ef99ce9e57412", "html_url": "https://github.com/rust-lang/rust/commit/a2467c9b2acbba6434dd49a32b5ef99ce9e57412"}], "stats": {"total": 68, "additions": 51, "deletions": 17}, "files": [{"sha": "6e7486c135549cd6dc6ac6682a0873b43d5f4d84", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0f9e009987f62d3b1c59b142770a118adfc05c9f/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f9e009987f62d3b1c59b142770a118adfc05c9f/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=0f9e009987f62d3b1c59b142770a118adfc05c9f", "patch": "@@ -6,7 +6,7 @@\n //! but it is incapable of producing all possible weak behaviours allowed by the model. There are\n //! certain weak behaviours observable on real hardware but not while using this.\n //!\n-//! Note that this implementation does not take into account of C++20's memory model revision to SC accesses\n+//! Note that this implementation does not fully take into account of C++20's memory model revision to SC accesses\n //! and fences introduced by P0668 (<https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html>).\n //! This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20\n //! disallows (<https://github.com/rust-lang/miri/issues/2301>).\n@@ -133,9 +133,17 @@ struct StoreElement {\n     // (partially) uninitialized data.\n     val: Scalar<Provenance>,\n \n+    /// Metadata about loads from this store element,\n+    /// behind a RefCell to keep load op take &self\n+    load_info: RefCell<LoadInfo>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+struct LoadInfo {\n     /// Timestamp of first loads from this store element by each thread\n-    /// Behind a RefCell to keep load op take &self\n-    loads: RefCell<FxHashMap<VectorIdx, VTimestamp>>,\n+    timestamps: FxHashMap<VectorIdx, VTimestamp>,\n+    /// Whether this store element has been read by an SC load\n+    sc_loaded: bool,\n }\n \n impl StoreBufferAlloc {\n@@ -235,18 +243,23 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n             timestamp: 0,\n             val: init,\n             is_seqcst: false,\n-            loads: RefCell::new(FxHashMap::default()),\n+            load_info: RefCell::new(LoadInfo::default()),\n         };\n         ret.buffer.push_back(store_elem);\n         ret\n     }\n \n     /// Reads from the last store in modification order\n-    fn read_from_last_store(&self, global: &DataRaceState, thread_mgr: &ThreadManager<'_, '_>) {\n+    fn read_from_last_store(\n+        &self,\n+        global: &DataRaceState,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        is_seqcst: bool,\n+    ) {\n         let store_elem = self.buffer.back();\n         if let Some(store_elem) = store_elem {\n             let (index, clocks) = global.current_thread_state(thread_mgr);\n-            store_elem.load_impl(index, &clocks);\n+            store_elem.load_impl(index, &clocks, is_seqcst);\n         }\n     }\n \n@@ -276,7 +289,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         validate()?;\n \n         let (index, clocks) = global.current_thread_state(thread_mgr);\n-        let loaded = store_elem.load_impl(index, &clocks);\n+        let loaded = store_elem.load_impl(index, &clocks, is_seqcst);\n         Ok((loaded, recency))\n     }\n \n@@ -321,9 +334,9 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n                     // then we can't read-from anything earlier in modification order.\n                     // C++20 \u00a76.9.2.2 [intro.races] paragraph 18\n                     false\n-                } else if store_elem.loads.borrow().iter().any(|(&load_index, &load_timestamp)| {\n-                    load_timestamp <= clocks.clock[load_index]\n-                }) {\n+                } else if store_elem.load_info.borrow().timestamps.iter().any(\n+                    |(&load_index, &load_timestamp)| load_timestamp <= clocks.clock[load_index],\n+                ) {\n                     // CoRR: if there was a load from this store which happened-before the current load,\n                     // then we cannot read-from anything earlier in modification order.\n                     // C++20 \u00a76.9.2.2 [intro.races] paragraph 16\n@@ -340,12 +353,22 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n                     // cannot read-before the last SC store executed before the fence.\n                     // C++17 \u00a732.4 [atomics.order] paragraph 4\n                     false\n-                } else if is_seqcst && store_elem.timestamp <= clocks.read_seqcst[store_elem.store_index] {\n+                } else if is_seqcst\n+                    && store_elem.timestamp <= clocks.read_seqcst[store_elem.store_index]\n+                {\n                     // The current SC load cannot read-before the last store sequenced-before\n                     // the last SC fence.\n                     // C++17 \u00a732.4 [atomics.order] paragraph 5\n                     false\n-                } else {true};\n+                } else if is_seqcst && store_elem.load_info.borrow().sc_loaded {\n+                    // The current SC load cannot read-before a store that an earlier SC load has observed.\n+                    // See https://github.com/rust-lang/miri/issues/2301#issuecomment-1222720427\n+                    // Consequences of C++20 \u00a731.4 [atomics.order] paragraph 3.1, 3.3 (coherence-ordered before)\n+                    // and 4.1 (coherence-ordered before between SC makes global total order S)\n+                    false\n+                } else {\n+                    true\n+                };\n \n                 true\n             })\n@@ -386,7 +409,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n             // access\n             val,\n             is_seqcst,\n-            loads: RefCell::new(FxHashMap::default()),\n+            load_info: RefCell::new(LoadInfo::default()),\n         };\n         self.buffer.push_back(store_elem);\n         if self.buffer.len() > STORE_BUFFER_LIMIT {\n@@ -414,8 +437,15 @@ impl StoreElement {\n     /// buffer regardless of subsequent loads by the same thread; if the earliest load of another\n     /// thread doesn't happen before the current one, then no subsequent load by the other thread\n     /// can happen before the current one.\n-    fn load_impl(&self, index: VectorIdx, clocks: &ThreadClockSet) -> Scalar<Provenance> {\n-        let _ = self.loads.borrow_mut().try_insert(index, clocks.clock[index]);\n+    fn load_impl(\n+        &self,\n+        index: VectorIdx,\n+        clocks: &ThreadClockSet,\n+        is_seqcst: bool,\n+    ) -> Scalar<Provenance> {\n+        let mut load_info = self.load_info.borrow_mut();\n+        load_info.sc_loaded |= is_seqcst;\n+        let _ = load_info.timestamps.try_insert(index, clocks.clock[index]);\n         self.val\n     }\n }\n@@ -475,7 +505,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             }\n             let range = alloc_range(base_offset, place.layout.size);\n             let buffer = alloc_buffers.get_or_create_store_buffer_mut(range, init)?;\n-            buffer.read_from_last_store(global, threads);\n+            buffer.read_from_last_store(global, threads, atomic == AtomicRwOrd::SeqCst);\n             buffer.buffered_write(new_val, global, threads, atomic == AtomicRwOrd::SeqCst)?;\n         }\n         Ok(())\n@@ -582,7 +612,11 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n                 let buffer = alloc_buffers\n                     .get_or_create_store_buffer(alloc_range(base_offset, size), init)?;\n-                buffer.read_from_last_store(global, &this.machine.threads);\n+                buffer.read_from_last_store(\n+                    global,\n+                    &this.machine.threads,\n+                    atomic == AtomicReadOrd::SeqCst,\n+                );\n             }\n         }\n         Ok(())"}]}