{"sha": "670dc7d55126cad910e554d98ad6f49e5381f645", "node_id": "C_kwDOAAsO6NoAKDY3MGRjN2Q1NTEyNmNhZDkxMGU1NTRkOThhZDZmNDllNTM4MWY2NDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-17T13:26:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-17T13:26:29Z"}, "message": "Auto merge of #1971 - saethlin:sb-details, r=RalfJung\n\nAdd a lot more information to SB fatal errors\n\nIn fatal errors, this clarifies the difference between a tag not being present in the borrow stack at all, and the tag being present but granting SRO. It also introduces a little notation for memory ranges so we can mention to the user that the span may point to code that operates on multiple memory locations, but we are reporting an error at a particular offset.\n\nThis also gets rid of the unqualified phrase \"the borrow stack\" in errors, and clarifies that it is the borrow stack _for some location_.\n\nThe crate `pdqselect` v0.1.1:\nBefore:\n```\n2103 |     unsafe { copy_nonoverlapping(src, dst, count) }\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item granting read access to tag <2357> at alloc1029 found in borrow stack.\n```\nAfter:\n```\n2103 |     unsafe { copy_nonoverlapping(src, dst, count) }\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |              |\n     |              attempting a read access using <2357> at alloc1029[0x0], but that tag does not exist in the borrow stack for this location\n     |              this error occurs as part of an access at alloc1029[0x0..0x4]\n```\n\nAnd the crate `half` v1.8.2\nBefore:\n```\n131 |     unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to reborrow for Unique at alloc1051, but parent tag <2091> does not have an appropriate item in the borrow stack\n```\nAfter:\n```\n131 |     unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |              |\n    |              trying to reborrow <2091> for Unique permission at alloc1051[0x0], but that tag only grants SharedReadOnly permission for this location\n    |              this error occurs as part of a reborrow at alloc1051[0x0..0x6]\n```", "tree": {"sha": "bea479ab7a1597f7f8285182a04b85962147d3ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bea479ab7a1597f7f8285182a04b85962147d3ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/670dc7d55126cad910e554d98ad6f49e5381f645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/670dc7d55126cad910e554d98ad6f49e5381f645", "html_url": "https://github.com/rust-lang/rust/commit/670dc7d55126cad910e554d98ad6f49e5381f645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/670dc7d55126cad910e554d98ad6f49e5381f645/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a33f1a682da1ce199e2450cb70ad04a5ac754b70", "url": "https://api.github.com/repos/rust-lang/rust/commits/a33f1a682da1ce199e2450cb70ad04a5ac754b70", "html_url": "https://github.com/rust-lang/rust/commit/a33f1a682da1ce199e2450cb70ad04a5ac754b70"}, {"sha": "730cd272481427149d8d4a1e471d983a73f77105", "url": "https://api.github.com/repos/rust-lang/rust/commits/730cd272481427149d8d4a1e471d983a73f77105", "html_url": "https://github.com/rust-lang/rust/commit/730cd272481427149d8d4a1e471d983a73f77105"}], "stats": {"total": 166, "additions": 126, "deletions": 40}, "files": [{"sha": "fbcb2e0d0ff782efaa546beb75c8fb14a9d3b1be", "filename": "src/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/670dc7d55126cad910e554d98ad6f49e5381f645/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670dc7d55126cad910e554d98ad6f49e5381f645/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=670dc7d55126cad910e554d98ad6f49e5381f645", "patch": "@@ -17,6 +17,7 @@ pub enum TerminationInfo {\n     UnsupportedInIsolation(String),\n     ExperimentalUb {\n         msg: String,\n+        help: Option<String>,\n         url: String,\n     },\n     Deadlock,\n@@ -133,6 +134,8 @@ pub fn report_error<'tcx, 'mir>(\n ) -> Option<i64> {\n     use InterpError::*;\n \n+    let mut msg = vec![];\n+\n     let (title, helps) = match &e.kind() {\n         MachineStop(info) => {\n             let info = info.downcast_ref::<TerminationInfo>().expect(\"invalid MachineStop payload\");\n@@ -152,11 +155,13 @@ pub fn report_error<'tcx, 'mir>(\n                         (None, format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation;\")),\n                         (None, format!(\"or pass `-Zmiri-isolation-error=warn` to configure Miri to return an error code from isolated operations (if supported for that operation) and continue with a warning\")),\n                     ],\n-                ExperimentalUb { url, .. } =>\n+                ExperimentalUb { url, help, .. } => {\n+                    msg.extend(help.clone());\n                     vec![\n                         (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\")),\n-                        (None, format!(\"see {} for further information\", url)),\n-                    ],\n+                        (None, format!(\"see {} for further information\", url))\n+                    ]\n+                }\n                 MultipleSymbolDefinitions { first, first_crate, second, second_crate, .. } =>\n                     vec![\n                         (Some(*first), format!(\"it's first defined here, in crate `{}`\", first_crate)),\n@@ -211,11 +216,11 @@ pub fn report_error<'tcx, 'mir>(\n     let stacktrace = ecx.generate_stacktrace();\n     let (stacktrace, was_pruned) = prune_stacktrace(ecx, stacktrace);\n     e.print_backtrace();\n-    let msg = e.to_string();\n+    msg.insert(0, e.to_string());\n     report_msg(\n         *ecx.tcx,\n         DiagLevel::Error,\n-        &if let Some(title) = title { format!(\"{}: {}\", title, msg) } else { msg.clone() },\n+        &if let Some(title) = title { format!(\"{}: {}\", title, msg[0]) } else { msg[0].clone() },\n         msg,\n         helps,\n         &stacktrace,\n@@ -256,11 +261,14 @@ pub fn report_error<'tcx, 'mir>(\n \n /// Report an error or note (depending on the `error` argument) with the given stacktrace.\n /// Also emits a full stacktrace of the interpreter stack.\n+/// We want to present a multi-line span message for some errors. Diagnostics do not support this\n+/// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n+/// additional `span_label` or `note` call.\n fn report_msg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     diag_level: DiagLevel,\n     title: &str,\n-    span_msg: String,\n+    span_msg: Vec<String>,\n     mut helps: Vec<(Option<SpanData>, String)>,\n     stacktrace: &[FrameInfo<'tcx>],\n ) {\n@@ -273,12 +281,17 @@ fn report_msg<'tcx>(\n \n     // Show main message.\n     if span != DUMMY_SP {\n-        err.span_label(span, span_msg);\n+        for line in span_msg {\n+            err.span_label(span, line);\n+        }\n     } else {\n         // Make sure we show the message even when it is a dummy span.\n-        err.note(&span_msg);\n+        for line in span_msg {\n+            err.note(&line);\n+        }\n         err.note(\"(no span available)\");\n     }\n+\n     // Show help messages.\n     if !helps.is_empty() {\n         // Add visual separator before backtrace.\n@@ -413,7 +426,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     _ => (\"tracking was triggered\", DiagLevel::Note),\n                 };\n \n-                report_msg(*this.tcx, diag_level, title, msg, vec![], &stacktrace);\n+                report_msg(*this.tcx, diag_level, title, vec![msg], vec![], &stacktrace);\n             }\n         });\n     }"}, {"sha": "777b8e9331ee2c3c197ac955be86b8a8914548a4", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 99, "deletions": 26, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/670dc7d55126cad910e554d98ad6f49e5381f645/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670dc7d55126cad910e554d98ad6f49e5381f645/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=670dc7d55126cad910e554d98ad6f49e5381f645", "patch": "@@ -220,9 +220,10 @@ impl GlobalState {\n }\n \n /// Error reporting\n-fn err_sb_ub(msg: String) -> InterpError<'static> {\n+fn err_sb_ub(msg: String, help: Option<String>) -> InterpError<'static> {\n     err_machine_stop!(TerminationInfo::ExperimentalUb {\n         msg,\n+        help,\n         url: format!(\n             \"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\"\n         ),\n@@ -320,12 +321,18 @@ impl<'tcx> Stack {\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n                 if let Some((tag, _)) = provoking_access {\n-                    Err(err_sb_ub(format!(\n-                        \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n-                        tag, item\n-                    )))?\n+                    Err(err_sb_ub(\n+                        format!(\n+                            \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n+                            tag, item\n+                        ),\n+                        None,\n+                    ))?\n                 } else {\n-                    Err(err_sb_ub(format!(\"deallocating while item is protected: {:?}\", item)))?\n+                    Err(err_sb_ub(\n+                        format!(\"deallocating while item is protected: {:?}\", item),\n+                        None,\n+                    ))?\n                 }\n             }\n         }\n@@ -334,22 +341,21 @@ impl<'tcx> Stack {\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n     /// If yes, return the index of the item that granted it.\n+    /// `range` refers the entire operation, and `offset` refers to the specific offset into the\n+    /// allocation that we are currently checking.\n     fn access(\n         &mut self,\n         access: AccessKind,\n         tag: SbTag,\n-        dbg_ptr: Pointer<AllocId>, // just for debug printing amd error messages\n+        (alloc_id, range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n-            err_sb_ub(format!(\n-                \"no item granting {} to tag {:?} at {:?} found in borrow stack.\",\n-                access, tag, dbg_ptr,\n-            ))\n-        })?;\n+        let granting_idx = self\n+            .find_granting(access, tag)\n+            .ok_or_else(|| self.access_error(access, tag, alloc_id, range, offset))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -389,15 +395,15 @@ impl<'tcx> Stack {\n     fn dealloc(\n         &mut self,\n         tag: SbTag,\n-        dbg_ptr: Pointer<AllocId>, // just for debug printing amd error messages\n+        dbg_ptr: Pointer<AllocId>, // just for debug printing and error messages\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n             err_sb_ub(format!(\n                 \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n                 tag, dbg_ptr,\n-            ))\n+            ), None)\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n@@ -412,23 +418,23 @@ impl<'tcx> Stack {\n     /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n     /// an access, and they add the new item directly on top of the one it is derived\n     /// from instead of all the way at the top of the stack.\n+    /// `range` refers the entire operation, and `offset` refers to the specific location in\n+    /// `range` that we are currently checking.\n     fn grant(\n         &mut self,\n         derived_from: SbTag,\n         new: Item,\n-        dbg_ptr: Pointer<AllocId>,\n+        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let granting_idx = self.find_granting(access, derived_from)\n-            .ok_or_else(|| err_sb_ub(format!(\n-                \"trying to reborrow for {:?} at {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n-                new.perm, dbg_ptr, derived_from,\n-            )))?;\n+        let granting_idx = self\n+            .find_granting(access, derived_from)\n+            .ok_or_else(|| self.grant_error(derived_from, new, alloc_id, alloc_range, offset))?;\n \n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n@@ -447,7 +453,7 @@ impl<'tcx> Stack {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, dbg_ptr, global)?;\n+            self.access(access, derived_from, (alloc_id, alloc_range, offset), global)?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we\n@@ -467,6 +473,72 @@ impl<'tcx> Stack {\n \n         Ok(())\n     }\n+\n+    /// Report a descriptive error when `new` could not be granted from `derived_from`.\n+    fn grant_error(\n+        &self,\n+        derived_from: SbTag,\n+        new: Item,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+        error_offset: Size,\n+    ) -> InterpError<'static> {\n+        let action = format!(\n+            \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n+            derived_from,\n+            new.perm,\n+            alloc_id,\n+            error_offset.bytes(),\n+        );\n+        err_sb_ub(\n+            format!(\"{}{}\", action, self.error_cause(derived_from)),\n+            Some(Self::operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n+        )\n+    }\n+\n+    /// Report a descriptive error when `access` is not permitted based on `tag`.\n+    fn access_error(\n+        &self,\n+        access: AccessKind,\n+        tag: SbTag,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+        error_offset: Size,\n+    ) -> InterpError<'static> {\n+        let action = format!(\n+            \"attempting a {} using {:?} at {}[{:#x}]\",\n+            access,\n+            tag,\n+            alloc_id,\n+            error_offset.bytes(),\n+        );\n+        err_sb_ub(\n+            format!(\"{}{}\", action, self.error_cause(tag)),\n+            Some(Self::operation_summary(\"an access\", alloc_id, alloc_range)),\n+        )\n+    }\n+\n+    fn operation_summary(\n+        operation: &'static str,\n+        alloc_id: AllocId,\n+        alloc_range: AllocRange,\n+    ) -> String {\n+        format!(\n+            \"this error occurs as part of {} at {:?}[{:#x}..{:#x}]\",\n+            operation,\n+            alloc_id,\n+            alloc_range.start.bytes(),\n+            alloc_range.end().bytes()\n+        )\n+    }\n+\n+    fn error_cause(&self, tag: SbTag) -> &'static str {\n+        if self.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n+            \", but that tag only grants SharedReadOnly permission for this location\"\n+        } else {\n+            \", but that tag does not exist in the borrow stack for this location\"\n+        }\n+    }\n }\n // # Stacked Borrows Core End\n \n@@ -566,7 +638,7 @@ impl Stacks {\n         );\n         let global = &*extra.borrow();\n         self.for_each(range, move |offset, stack| {\n-            stack.access(AccessKind::Read, tag, Pointer::new(alloc_id, offset), global)\n+            stack.access(AccessKind::Read, tag, (alloc_id, range, offset), global)\n         })\n     }\n \n@@ -586,7 +658,7 @@ impl Stacks {\n         );\n         let global = extra.get_mut();\n         self.for_each_mut(range, move |offset, stack| {\n-            stack.access(AccessKind::Write, tag, Pointer::new(alloc_id, offset), global)\n+            stack.access(AccessKind::Write, tag, (alloc_id, range, offset), global)\n         })\n     }\n \n@@ -693,7 +765,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n                     stacked_borrows.for_each(range, |offset, stack| {\n-                        stack.grant(orig_tag, item, Pointer::new(alloc_id, offset), &*global)\n+                        stack.grant(orig_tag, item, (alloc_id, range, offset), &*global)\n                     })\n                 })?;\n                 return Ok(());\n@@ -707,8 +779,9 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n         let global = memory_extra.stacked_borrows.as_mut().unwrap().get_mut();\n         let item = Item { perm, tag: new_tag, protector };\n+        let range = alloc_range(base_offset, size);\n         stacked_borrows.for_each_mut(alloc_range(base_offset, size), |offset, stack| {\n-            stack.grant(orig_tag, item, Pointer::new(alloc_id, offset), global)\n+            stack.grant(orig_tag, item, (alloc_id, range, offset), global)\n         })?;\n         Ok(())\n     }"}, {"sha": "5b9614f79fde97adbc1030d88a5216ddb8fbfda4", "filename": "tests/compile-fail/box-cell-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fbox-cell-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fbox-cell-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbox-cell-alias.rs?ref=670dc7d55126cad910e554d98ad6f49e5381f645", "patch": "@@ -6,7 +6,7 @@ use std::cell::Cell;\n \n fn helper(val: Box<Cell<u8>>, ptr: *const Cell<u8>) -> u8 {\n     val.set(10);\n-    unsafe { (*ptr).set(20); } //~ ERROR does not have an appropriate item in the borrow stack\n+    unsafe { (*ptr).set(20); } //~ ERROR does not exist in the borrow stack\n     val.get()\n }\n "}, {"sha": "7851eeb02690ae65e316a005a23432ed6253519f", "filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs?ref=670dc7d55126cad910e554d98ad6f49e5381f645", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; } //~ ERROR borrow stack\n+    unsafe { *ptr = 42; } //~ ERROR only grants SharedReadOnly permission\n     let _val = *r#ref;\n }"}, {"sha": "a8e1d806cbbb28510e75320ce9c7e6117180963c", "filename": "tests/compile-fail/stacked_borrows/raw_tracking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fstacked_borrows%2Fraw_tracking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fstacked_borrows%2Fraw_tracking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fraw_tracking.rs?ref=670dc7d55126cad910e554d98ad6f49e5381f645", "patch": "@@ -7,6 +7,6 @@ fn main() {\n     let raw2 = &mut l as *mut _; // invalidates raw1\n     // Without raw pointer tracking, Stacked Borrows cannot distinguish raw1 and raw2, and thus\n     // fails to realize that raw1 should not be used any more.\n-    unsafe { *raw1 = 13; } //~ ERROR no item granting write access to tag\n+    unsafe { *raw1 = 13; } //~ ERROR does not exist in the borrow stack\n     unsafe { *raw2 = 13; }\n }"}, {"sha": "1ea96086d3e467e91cd062fabc81268c036a7bb3", "filename": "tests/compile-fail/stacked_borrows/shr_frozen_violation1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshr_frozen_violation1.rs?ref=670dc7d55126cad910e554d98ad6f49e5381f645", "patch": "@@ -9,5 +9,5 @@ fn main() {\n }\n \n fn unknown_code(x: &i32) {\n-    unsafe { *(x as *const i32 as *mut i32) = 7; } //~ ERROR borrow stack\n+    unsafe { *(x as *const i32 as *mut i32) = 7; } //~ ERROR only grants SharedReadOnly permission\n }"}, {"sha": "065bf77d04ae2429923b359970e1595785349975", "filename": "tests/compile-fail/stacked_borrows/zst_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fstacked_borrows%2Fzst_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670dc7d55126cad910e554d98ad6f49e5381f645/tests%2Fcompile-fail%2Fstacked_borrows%2Fzst_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fzst_slice.rs?ref=670dc7d55126cad910e554d98ad6f49e5381f645", "patch": "@@ -1,5 +1,5 @@\n // compile-flags: -Zmiri-tag-raw-pointers\n-// error-pattern: does not have an appropriate item in the borrow stack\n+// error-pattern: does not exist in the borrow stack\n \n fn main() {\n     unsafe {"}]}