{"sha": "9ec1741b651bd13e4e5e6224f2e2c5c503846a6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYzE3NDFiNjUxYmQxM2U0ZTVlNjIyNGYyZTJjNWM1MDM4NDZhNmI=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-04T04:37:43Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-12T08:05:00Z"}, "message": "Refactor string helpers for decl_check module", "tree": {"sha": "555b4872ec6df0adc325dd4295cd6acfdc14e7da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/555b4872ec6df0adc325dd4295cd6acfdc14e7da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ec1741b651bd13e4e5e6224f2e2c5c503846a6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ec1741b651bd13e4e5e6224f2e2c5c503846a6b", "html_url": "https://github.com/rust-lang/rust/commit/9ec1741b651bd13e4e5e6224f2e2c5c503846a6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ec1741b651bd13e4e5e6224f2e2c5c503846a6b/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb96bba87895c062a78e6599cea161e461ff607d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb96bba87895c062a78e6599cea161e461ff607d", "html_url": "https://github.com/rust-lang/rust/commit/fb96bba87895c062a78e6599cea161e461ff607d"}], "stats": {"total": 129, "additions": 97, "deletions": 32}, "files": [{"sha": "e3826909bb0d5a067578a6520fa692231de6f6b4", "filename": "crates/hir_ty/src/diagnostics/decl_check/str_helpers.rs", "status": "modified", "additions": 97, "deletions": 32, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/9ec1741b651bd13e4e5e6224f2e2c5c503846a6b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fstr_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec1741b651bd13e4e5e6224f2e2c5c503846a6b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fstr_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fstr_helpers.rs?ref=9ec1741b651bd13e4e5e6224f2e2c5c503846a6b", "patch": "@@ -1,10 +1,74 @@\n+#[derive(Debug)]\n+enum DetectedCase {\n+    LowerCamelCase,\n+    UpperCamelCase,\n+    LowerSnakeCase,\n+    UpperSnakeCase,\n+    Unknown,\n+}\n+\n+fn detect_case(ident: &str) -> DetectedCase {\n+    let trimmed_ident = ident.trim_matches('_');\n+    let first_lowercase =\n+        trimmed_ident.chars().next().map(|chr| chr.is_ascii_lowercase()).unwrap_or(false);\n+    let mut has_lowercase = first_lowercase;\n+    let mut has_uppercase = false;\n+    let mut has_underscore = false;\n+\n+    for chr in trimmed_ident.chars() {\n+        if chr == '_' {\n+            has_underscore = true;\n+        } else if chr.is_ascii_uppercase() {\n+            has_uppercase = true;\n+        } else if chr.is_ascii_lowercase() {\n+            has_lowercase = true;\n+        }\n+    }\n+\n+    if has_uppercase {\n+        if !has_lowercase {\n+            DetectedCase::UpperSnakeCase\n+        } else if !has_underscore {\n+            if first_lowercase {\n+                DetectedCase::LowerCamelCase\n+            } else {\n+                DetectedCase::UpperCamelCase\n+            }\n+        } else {\n+            // It has uppercase, it has lowercase, it has underscore.\n+            // No assumptions here\n+            DetectedCase::Unknown\n+        }\n+    } else {\n+        DetectedCase::LowerSnakeCase\n+    }\n+}\n+\n pub fn to_camel_case(ident: &str) -> Option<String> {\n-    let mut output = String::new();\n+    let detected_case = detect_case(ident);\n \n-    if is_camel_case(ident) {\n-        return None;\n+    match detected_case {\n+        DetectedCase::UpperCamelCase => return None,\n+        DetectedCase::LowerCamelCase => {\n+            let mut first_capitalized = false;\n+            let output = ident\n+                .chars()\n+                .map(|chr| {\n+                    if !first_capitalized && chr.is_ascii_lowercase() {\n+                        first_capitalized = true;\n+                        chr.to_ascii_uppercase()\n+                    } else {\n+                        chr\n+                    }\n+                })\n+                .collect();\n+            return Some(output);\n+        }\n+        _ => {}\n     }\n \n+    let mut output = String::with_capacity(ident.len());\n+\n     let mut capital_added = false;\n     for chr in ident.chars() {\n         if chr.is_alphabetic() {\n@@ -23,47 +87,37 @@ pub fn to_camel_case(ident: &str) -> Option<String> {\n         }\n     }\n \n-    if output == ident {\n-        None\n-    } else {\n-        Some(output)\n-    }\n+    Some(output)\n }\n \n pub fn to_lower_snake_case(ident: &str) -> Option<String> {\n     // First, assume that it's UPPER_SNAKE_CASE.\n-    if let Some(normalized) = to_lower_snake_case_from_upper_snake_case(ident) {\n-        return Some(normalized);\n+    match detect_case(ident) {\n+        DetectedCase::LowerSnakeCase => return None,\n+        DetectedCase::UpperSnakeCase => {\n+            return Some(ident.chars().map(|chr| chr.to_ascii_lowercase()).collect())\n+        }\n+        _ => {}\n     }\n \n     // Otherwise, assume that it's CamelCase.\n     let lower_snake_case = stdx::to_lower_snake_case(ident);\n-\n-    if lower_snake_case == ident {\n-        None\n-    } else {\n-        Some(lower_snake_case)\n-    }\n+    Some(lower_snake_case)\n }\n \n-fn to_lower_snake_case_from_upper_snake_case(ident: &str) -> Option<String> {\n-    if is_upper_snake_case(ident) {\n-        let string = ident.chars().map(|c| c.to_ascii_lowercase()).collect();\n-        Some(string)\n-    } else {\n-        None\n+pub fn to_upper_snake_case(ident: &str) -> Option<String> {\n+    match detect_case(ident) {\n+        DetectedCase::UpperSnakeCase => return None,\n+        DetectedCase::LowerSnakeCase => {\n+            return Some(ident.chars().map(|chr| chr.to_ascii_uppercase()).collect())\n+        }\n+        _ => {}\n     }\n-}\n-\n-fn is_upper_snake_case(ident: &str) -> bool {\n-    ident.chars().all(|c| c.is_ascii_uppercase() || c == '_')\n-}\n \n-fn is_camel_case(ident: &str) -> bool {\n-    // We assume that the string is either snake case or camel case.\n-    // `_` is allowed only at the beginning or in the end of identifier, not between characters.\n-    ident.trim_matches('_').chars().all(|c| c != '_')\n-        && ident.chars().find(|c| c.is_alphabetic()).map(|c| c.is_ascii_uppercase()).unwrap_or(true)\n+    // Normalize the string from whatever form it's in currently, and then just make it uppercase.\n+    let upper_snake_case =\n+        stdx::to_lower_snake_case(ident).chars().map(|c| c.to_ascii_uppercase()).collect();\n+    Some(upper_snake_case)\n }\n \n #[cfg(test)]\n@@ -84,16 +138,27 @@ mod tests {\n         check(to_lower_snake_case, \"UPPER_SNAKE_CASE\", expect![[\"upper_snake_case\"]]);\n         check(to_lower_snake_case, \"Weird_Case\", expect![[\"weird_case\"]]);\n         check(to_lower_snake_case, \"CamelCase\", expect![[\"camel_case\"]]);\n+        check(to_lower_snake_case, \"lowerCamelCase\", expect![[\"lower_camel_case\"]]);\n     }\n \n     #[test]\n     fn test_to_camel_case() {\n         check(to_camel_case, \"CamelCase\", expect![[\"\"]]);\n         check(to_camel_case, \"CamelCase_\", expect![[\"\"]]);\n         check(to_camel_case, \"_CamelCase\", expect![[\"\"]]);\n+        check(to_camel_case, \"lowerCamelCase\", expect![[\"LowerCamelCase\"]]);\n         check(to_camel_case, \"lower_snake_case\", expect![[\"LowerSnakeCase\"]]);\n         check(to_camel_case, \"UPPER_SNAKE_CASE\", expect![[\"UpperSnakeCase\"]]);\n         check(to_camel_case, \"Weird_Case\", expect![[\"WeirdCase\"]]);\n         check(to_camel_case, \"name\", expect![[\"Name\"]]);\n     }\n+\n+    #[test]\n+    fn test_to_upper_snake_case() {\n+        check(to_upper_snake_case, \"UPPER_SNAKE_CASE\", expect![[\"\"]]);\n+        check(to_upper_snake_case, \"lower_snake_case\", expect![[\"LOWER_SNAKE_CASE\"]]);\n+        check(to_upper_snake_case, \"Weird_Case\", expect![[\"WEIRD_CASE\"]]);\n+        check(to_upper_snake_case, \"CamelCase\", expect![[\"CAMEL_CASE\"]]);\n+        check(to_upper_snake_case, \"lowerCamelCase\", expect![[\"LOWER_CAMEL_CASE\"]]);\n+    }\n }"}]}