{"sha": "b9f1064760b19d8b861f8113be4fc147240096ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZjEwNjQ3NjBiMTlkOGI4NjFmODExM2JlNGZjMTQ3MjQwMDk2YWI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-20T01:34:07Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:04:44Z"}, "message": "Inline make_drop_glue", "tree": {"sha": "abbb0cd8d55a41977e9977f8f36231872dcb0501", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abbb0cd8d55a41977e9977f8f36231872dcb0501"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9f1064760b19d8b861f8113be4fc147240096ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9f1064760b19d8b861f8113be4fc147240096ab", "html_url": "https://github.com/rust-lang/rust/commit/b9f1064760b19d8b861f8113be4fc147240096ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9f1064760b19d8b861f8113be4fc147240096ab/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a1ec55c4722aa1d2f4a68e062bb1e2b7342ae70", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a1ec55c4722aa1d2f4a68e062bb1e2b7342ae70", "html_url": "https://github.com/rust-lang/rust/commit/6a1ec55c4722aa1d2f4a68e062bb1e2b7342ae70"}], "stats": {"total": 156, "additions": 74, "deletions": 82}, "files": [{"sha": "1e5bd7eb606800abf259008bc1c1315fbb2e1d3c", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 74, "deletions": 82, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/b9f1064760b19d8b861f8113be4fc147240096ab/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9f1064760b19d8b861f8113be4fc147240096ab/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=b9f1064760b19d8b861f8113be4fc147240096ab", "patch": "@@ -200,7 +200,80 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = make_drop_glue(bcx, get_param(llfn, 0), g);\n+    // NB: v0 is an *alias* of type t here, not a direct value.\n+    // Only drop the value when it ... well, we used to check for\n+    // non-null, (and maybe we need to continue doing so), but we now\n+    // must definitely check for special bit-patterns corresponding to\n+    // the special dtor markings.\n+    let v0 = get_param(llfn, 0);\n+    let t = g.ty();\n+\n+    let skip_dtor = match g {\n+        DropGlueKind::Ty(_) => false,\n+        DropGlueKind::TyContents(_) => true\n+    };\n+\n+    let bcx = match t.sty {\n+        ty::TyBox(content_ty) => {\n+            // Support for TyBox is built-in and its drop glue is\n+            // special. It may move to library and have Drop impl. As\n+            // a safe-guard, assert TyBox not used with TyContents.\n+            assert!(!skip_dtor);\n+            if !bcx.ccx.shared().type_is_sized(content_ty) {\n+                let llval = get_dataptr(&bcx, v0);\n+                let llbox = bcx.load(llval);\n+                drop_ty(&bcx, v0, content_ty);\n+                // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n+                let info = get_meta(&bcx, v0);\n+                let info = bcx.load(info);\n+                let (llsize, llalign) = size_and_align_of_dst(&bcx, content_ty, info);\n+\n+                // `Box<ZeroSizeType>` does not allocate.\n+                let needs_free = bcx.icmp(llvm::IntNE, llsize, C_uint(bcx.ccx, 0u64));\n+                if const_to_opt_uint(needs_free) == Some(0) {\n+                    bcx\n+                } else {\n+                    let next_cx = bcx.fcx().build_new_block(\"next\");\n+                    let cond_cx = bcx.fcx().build_new_block(\"cond\");\n+                    bcx.cond_br(needs_free, cond_cx.llbb(), next_cx.llbb());\n+                    trans_exchange_free_dyn(&cond_cx, llbox, llsize, llalign);\n+                    cond_cx.br(next_cx.llbb());\n+                    next_cx\n+                }\n+            } else {\n+                let llval = v0;\n+                let llbox = bcx.load(llval);\n+                drop_ty(&bcx, llbox, content_ty);\n+                trans_exchange_free_ty(&bcx, llbox, content_ty);\n+                bcx\n+            }\n+        }\n+        ty::TyDynamic(..) => {\n+            // No support in vtable for distinguishing destroying with\n+            // versus without calling Drop::drop. Assert caller is\n+            // okay with always calling the Drop impl, if any.\n+            // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n+            assert!(!skip_dtor);\n+            let data_ptr = get_dataptr(&bcx, v0);\n+            let vtable_ptr = bcx.load(get_meta(&bcx, v0));\n+            let dtor = bcx.load(vtable_ptr);\n+            bcx.call(dtor, &[bcx.pointercast(bcx.load(data_ptr), Type::i8p(bcx.ccx))], None);\n+            bcx\n+        }\n+        ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n+            trans_custom_dtor(bcx, t, v0, def.is_union())\n+        }\n+        ty::TyAdt(def, ..) if def.is_union() => {\n+            bcx\n+        }\n+        _ => {\n+            if bcx.ccx.shared().type_needs_drop(t) {\n+                drop_structural_ty(bcx, v0, t)\n+            } else {\n+                bcx\n+            }\n+        }\n+    };\n     bcx.ret_void();\n }\n \n@@ -373,87 +446,6 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n     }\n }\n \n-fn make_drop_glue<'a, 'tcx>(bcx: BlockAndBuilder<'a, 'tcx>,\n-                            v0: ValueRef,\n-                            g: DropGlueKind<'tcx>)\n-                            -> BlockAndBuilder<'a, 'tcx> {\n-    let t = g.ty();\n-\n-    let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };\n-    // NB: v0 is an *alias* of type t here, not a direct value.\n-    // Only drop the value when it ... well, we used to check for\n-    // non-null, (and maybe we need to continue doing so), but we now\n-    // must definitely check for special bit-patterns corresponding to\n-    // the special dtor markings.\n-\n-    match t.sty {\n-        ty::TyBox(content_ty) => {\n-            // Support for TyBox is built-in and its drop glue is\n-            // special. It may move to library and have Drop impl. As\n-            // a safe-guard, assert TyBox not used with TyContents.\n-            assert!(!skip_dtor);\n-            if !bcx.ccx.shared().type_is_sized(content_ty) {\n-                let llval = get_dataptr(&bcx, v0);\n-                let llbox = bcx.load(llval);\n-                drop_ty(&bcx, v0, content_ty);\n-                // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n-                let info = get_meta(&bcx, v0);\n-                let info = bcx.load(info);\n-                let (llsize, llalign) = size_and_align_of_dst(&bcx, content_ty, info);\n-\n-                // `Box<ZeroSizeType>` does not allocate.\n-                let needs_free = bcx.icmp(\n-                    llvm::IntNE,\n-                    llsize,\n-                    C_uint(bcx.ccx, 0u64),\n-                );\n-                if const_to_opt_uint(needs_free) == Some(0) {\n-                    bcx\n-                } else {\n-                    let fcx = bcx.fcx();\n-                    let next_cx = fcx.build_new_block(\"next\");\n-                    let cond_cx = fcx.build_new_block(\"cond\");\n-                    bcx.cond_br(needs_free, cond_cx.llbb(), next_cx.llbb());\n-                    trans_exchange_free_dyn(&cond_cx, llbox, llsize, llalign);\n-                    cond_cx.br(next_cx.llbb());\n-                    next_cx\n-                }\n-            } else {\n-                let llval = v0;\n-                let llbox = bcx.load(llval);\n-                drop_ty(&bcx, llbox, content_ty);\n-                trans_exchange_free_ty(&bcx, llbox, content_ty);\n-                bcx\n-            }\n-        }\n-        ty::TyDynamic(..) => {\n-            // No support in vtable for distinguishing destroying with\n-            // versus without calling Drop::drop. Assert caller is\n-            // okay with always calling the Drop impl, if any.\n-            // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n-            assert!(!skip_dtor);\n-            let data_ptr = get_dataptr(&bcx, v0);\n-            let vtable_ptr = bcx.load(get_meta(&bcx, v0));\n-            let dtor = bcx.load(vtable_ptr);\n-            bcx.call(dtor, &[bcx.pointercast(bcx.load(data_ptr), Type::i8p(bcx.ccx))], None);\n-            bcx\n-        }\n-        ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n-            trans_custom_dtor(bcx, t, v0, def.is_union())\n-        }\n-        ty::TyAdt(def, ..) if def.is_union() => {\n-            bcx\n-        }\n-        _ => {\n-            if bcx.ccx.shared().type_needs_drop(t) {\n-                drop_structural_ty(bcx, v0, t)\n-            } else {\n-                bcx\n-            }\n-        }\n-    }\n-}\n-\n // Iterates through the elements of a structural type, dropping them.\n fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                                 av: ValueRef,"}]}