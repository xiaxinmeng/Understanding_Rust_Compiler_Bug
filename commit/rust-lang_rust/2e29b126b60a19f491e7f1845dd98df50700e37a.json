{"sha": "2e29b126b60a19f491e7f1845dd98df50700e37a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMjliMTI2YjYwYTE5ZjQ5MWU3ZjE4NDVkZDk4ZGY1MDcwMGUzN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-14T13:42:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-14T13:42:16Z"}, "message": "Auto merge of #35534 - michaelwoerister:fix-const-collection2, r=nikomatsakis\n\nMake the translation item collector handle *uses* of 'const' items instead of declarations.\n\nThis should fix issue #34754.", "tree": {"sha": "9ecd0f7505d4fd68ee8bedbf86633c4ad67ad93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ecd0f7505d4fd68ee8bedbf86633c4ad67ad93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e29b126b60a19f491e7f1845dd98df50700e37a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e29b126b60a19f491e7f1845dd98df50700e37a", "html_url": "https://github.com/rust-lang/rust/commit/2e29b126b60a19f491e7f1845dd98df50700e37a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e29b126b60a19f491e7f1845dd98df50700e37a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d927fa48567ea9ebb2128a2271459c1257639292", "url": "https://api.github.com/repos/rust-lang/rust/commits/d927fa48567ea9ebb2128a2271459c1257639292", "html_url": "https://github.com/rust-lang/rust/commit/d927fa48567ea9ebb2128a2271459c1257639292"}, {"sha": "09e73a5b0315f507e0659e62a56a34bba03c2581", "url": "https://api.github.com/repos/rust-lang/rust/commits/09e73a5b0315f507e0659e62a56a34bba03c2581", "html_url": "https://github.com/rust-lang/rust/commit/09e73a5b0315f507e0659e62a56a34bba03c2581"}], "stats": {"total": 157, "additions": 142, "deletions": 15}, "files": [{"sha": "794da0d1473bd12b900d0aad7d842074f52c2dc8", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2e29b126b60a19f491e7f1845dd98df50700e37a/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e29b126b60a19f491e7f1845dd98df50700e37a/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=2e29b126b60a19f491e7f1845dd98df50700e37a", "patch": "@@ -202,10 +202,11 @@ use rustc::mir::repr as mir;\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n+use rustc_const_eval as const_eval;\n+\n use syntax::abi::Abi;\n use errors;\n use syntax_pos::DUMMY_SP;\n-use syntax::ast::NodeId;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};\n@@ -543,9 +544,46 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting operand {:?}\", *operand);\n \n         let callee = match *operand {\n-            mir::Operand::Constant(mir::Constant { ty: &ty::TyS {\n-                sty: ty::TyFnDef(def_id, substs, _), ..\n-            }, .. }) => Some((def_id, substs)),\n+            mir::Operand::Constant(ref constant) => {\n+                if let ty::TyFnDef(def_id, substs, _) = constant.ty.sty {\n+                    // This is something that can act as a callee, proceed\n+                    Some((def_id, substs))\n+                } else {\n+                    // This is not a callee, but we still have to look for\n+                    // references to `const` items\n+                    if let mir::Literal::Item { def_id, substs } = constant.literal {\n+                        let tcx = self.scx.tcx();\n+                        let substs = monomorphize::apply_param_substs(tcx,\n+                                                                      self.param_substs,\n+                                                                      &substs);\n+\n+                        // If the constant referred to here is an associated\n+                        // item of a trait, we need to resolve it to the actual\n+                        // constant in the corresponding impl. Luckily\n+                        // const_eval::lookup_const_by_id() does that for us.\n+                        if let Some((expr, _)) = const_eval::lookup_const_by_id(tcx,\n+                                                                                def_id,\n+                                                                                Some(substs)) {\n+                            // The hir::Expr we get here is the initializer of\n+                            // the constant, what we really want is the item\n+                            // DefId.\n+                            let const_node_id = tcx.map.get_parent(expr.id);\n+                            let def_id = if tcx.map.is_inlined_node_id(const_node_id) {\n+                                tcx.sess.cstore.defid_for_inlined_node(const_node_id).unwrap()\n+                            } else {\n+                                tcx.map.local_def_id(const_node_id)\n+                            };\n+\n+                            collect_const_item_neighbours(self.scx,\n+                                                          def_id,\n+                                                          substs,\n+                                                          self.output);\n+                        }\n+                    }\n+\n+                    None\n+                }\n+            }\n             _ => None\n         };\n \n@@ -1117,10 +1155,8 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 self.output.push(TransItem::Static(item.id));\n             }\n             hir::ItemConst(..) => {\n-                debug!(\"RootCollector: ItemConst({})\",\n-                       def_id_to_string(self.scx.tcx(),\n-                                        self.scx.tcx().map.local_def_id(item.id)));\n-                add_roots_for_const_item(self.scx, item.id, self.output);\n+                // const items only generate translation items if they are\n+                // actually used somewhere. Just declaring them is insufficient.\n             }\n             hir::ItemFn(_, _, _, _, ref generics, _) => {\n                 if !generics.is_type_parameterized() {\n@@ -1244,23 +1280,21 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // There are no translation items for constants themselves but their\n // initializers might still contain something that produces translation items,\n // such as cast that introduce a new vtable.\n-fn add_roots_for_const_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                      const_item_node_id: NodeId,\n-                                      output: &mut Vec<TransItem<'tcx>>)\n+fn collect_const_item_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                           def_id: DefId,\n+                                           substs: &'tcx Substs<'tcx>,\n+                                           output: &mut Vec<TransItem<'tcx>>)\n {\n-    let def_id = scx.tcx().map.local_def_id(const_item_node_id);\n-\n     // Scan the MIR in order to find function calls, closures, and\n     // drop-glue\n     let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(def_id),\n         || format!(\"Could not find MIR for const: {:?}\", def_id));\n \n-    let empty_substs = scx.empty_substs_for_def_id(def_id);\n     let visitor = MirNeighborCollector {\n         scx: scx,\n         mir: &mir,\n         output: output,\n-        param_substs: empty_substs\n+        param_substs: substs\n     };\n \n     visit_mir_and_promoted(visitor, &mir);"}, {"sha": "b40bb7f60973a0222fe530f9588c42c114be1536", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2e29b126b60a19f491e7f1845dd98df50700e37a/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e29b126b60a19f491e7f1845dd98df50700e37a/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=2e29b126b60a19f491e7f1845dd98df50700e37a", "patch": "@@ -0,0 +1,93 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// We specify -Z incremental here because we want to test the partitioning for\n+// incremental compilation\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/vtable-through-const\n+\n+// This test case makes sure, that references made through constants are\n+// recorded properly in the InliningMap.\n+\n+mod mod1 {\n+    pub trait Trait1 {\n+        fn do_something(&self) {}\n+        fn do_something_else(&self) {}\n+    }\n+\n+    impl Trait1 for u32 {}\n+\n+    pub trait Trait1Gen<T> {\n+        fn do_something(&self, x: T) -> T;\n+        fn do_something_else(&self, x: T) -> T;\n+    }\n+\n+    impl<T> Trait1Gen<T> for u32 {\n+        fn do_something(&self, x: T) -> T { x }\n+        fn do_something_else(&self, x: T) -> T { x }\n+    }\n+\n+    fn id<T>(x: T) -> T { x }\n+\n+    // These are referenced, so they produce trans-items (see main())\n+    pub const TRAIT1_REF: &'static Trait1 = &0u32 as &Trait1;\n+    pub const TRAIT1_GEN_REF: &'static Trait1Gen<u8> = &0u32 as &Trait1Gen<u8>;\n+    pub const ID_CHAR: fn(char) -> char = id::<char>;\n+\n+\n+\n+    pub trait Trait2 {\n+        fn do_something(&self) {}\n+        fn do_something_else(&self) {}\n+    }\n+\n+    impl Trait2 for u32 {}\n+\n+    pub trait Trait2Gen<T> {\n+        fn do_something(&self, x: T) -> T;\n+        fn do_something_else(&self, x: T) -> T;\n+    }\n+\n+    impl<T> Trait2Gen<T> for u32 {\n+        fn do_something(&self, x: T) -> T { x }\n+        fn do_something_else(&self, x: T) -> T { x }\n+    }\n+\n+    // These are not referenced, so they do not produce trans-items\n+    pub const TRAIT2_REF: &'static Trait2 = &0u32 as &Trait2;\n+    pub const TRAIT2_GEN_REF: &'static Trait2Gen<u8> = &0u32 as &Trait2Gen<u8>;\n+    pub const ID_I64: fn(i64) -> i64 = id::<i64>;\n+}\n+\n+//~ TRANS_ITEM fn vtable_through_const::main[0] @@ vtable_through_const[External]\n+fn main() {\n+\n+    // Since Trait1::do_something() is instantiated via its default implementation,\n+    // it is considered a generic and is instantiated here only because it is\n+    // referenced in this module.\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something_else[0]<u32> @@ vtable_through_const[Internal]\n+\n+    // Although it is never used, Trait1::do_something_else() has to be\n+    // instantiated locally here too, otherwise the <&u32 as &Trait1> vtable\n+    // could not be fully constructed.\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something[0]<u32> @@ vtable_through_const[Internal]\n+    mod1::TRAIT1_REF.do_something();\n+\n+    // Same as above\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something[0]<u8> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something_else[0]<u8> @@ vtable_through_const[Internal]\n+    mod1::TRAIT1_GEN_REF.do_something(0u8);\n+\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::id[0]<char> @@ vtable_through_const[Internal]\n+    mod1::ID_CHAR('x');\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}]}