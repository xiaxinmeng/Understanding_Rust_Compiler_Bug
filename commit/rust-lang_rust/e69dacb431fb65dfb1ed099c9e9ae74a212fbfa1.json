{"sha": "e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2OWRhY2I0MzFmYjY1ZGZiMWVkMDk5YzllOWFlNzRhMjEyZmJmYTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-05T05:04:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-14T06:56:44Z"}, "message": "rustc_trans: rename ccx to cx.", "tree": {"sha": "8a703cd06156ac91bf54e359a64c36c4a7f79974", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a703cd06156ac91bf54e359a64c36c4a7f79974"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "html_url": "https://github.com/rust-lang/rust/commit/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb7de6a041bf9917135ab52ca2778c1b1663df35", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb7de6a041bf9917135ab52ca2778c1b1663df35", "html_url": "https://github.com/rust-lang/rust/commit/fb7de6a041bf9917135ab52ca2778c1b1663df35"}], "stats": {"total": 2386, "additions": 1193, "deletions": 1193}, "files": [{"sha": "c57242bc3ce04304ecf73f85c7b8fc9292acbd6b", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 91, "deletions": 91, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -209,8 +209,8 @@ impl Reg {\n }\n \n impl Reg {\n-    pub fn align(&self, ccx: &CodegenCx) -> Align {\n-        let dl = ccx.data_layout();\n+    pub fn align(&self, cx: &CodegenCx) -> Align {\n+        let dl = cx.data_layout();\n         match self.kind {\n             RegKind::Integer => {\n                 match self.size.bits() {\n@@ -234,18 +234,18 @@ impl Reg {\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CodegenCx) -> Type {\n+    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n         match self.kind {\n-            RegKind::Integer => Type::ix(ccx, self.size.bits()),\n+            RegKind::Integer => Type::ix(cx, self.size.bits()),\n             RegKind::Float => {\n                 match self.size.bits() {\n-                    32 => Type::f32(ccx),\n-                    64 => Type::f64(ccx),\n+                    32 => Type::f32(cx),\n+                    64 => Type::f64(cx),\n                     _ => bug!(\"unsupported float: {:?}\", self)\n                 }\n             }\n             RegKind::Vector => {\n-                Type::vector(&Type::i8(ccx), self.size.bytes())\n+                Type::vector(&Type::i8(cx), self.size.bytes())\n             }\n         }\n     }\n@@ -276,12 +276,12 @@ impl From<Reg> for Uniform {\n }\n \n impl Uniform {\n-    pub fn align(&self, ccx: &CodegenCx) -> Align {\n-        self.unit.align(ccx)\n+    pub fn align(&self, cx: &CodegenCx) -> Align {\n+        self.unit.align(cx)\n     }\n \n-    pub fn llvm_type(&self, ccx: &CodegenCx) -> Type {\n-        let llunit = self.unit.llvm_type(ccx);\n+    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n+        let llunit = self.unit.llvm_type(cx);\n \n         if self.total <= self.unit.size {\n             return llunit;\n@@ -298,16 +298,16 @@ impl Uniform {\n         assert_eq!(self.unit.kind, RegKind::Integer);\n \n         let args: Vec<_> = (0..count).map(|_| llunit)\n-            .chain(iter::once(Type::ix(ccx, rem_bytes * 8)))\n+            .chain(iter::once(Type::ix(cx, rem_bytes * 8)))\n             .collect();\n \n-        Type::struct_(ccx, &args, false)\n+        Type::struct_(cx, &args, false)\n     }\n }\n \n pub trait LayoutExt<'tcx> {\n     fn is_aggregate(&self) -> bool;\n-    fn homogeneous_aggregate<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Option<Reg>;\n+    fn homogeneous_aggregate<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<Reg>;\n }\n \n impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n@@ -321,7 +321,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn homogeneous_aggregate<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Option<Reg> {\n+    fn homogeneous_aggregate<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<Reg> {\n         match self.abi {\n             layout::Abi::Uninhabited => None,\n \n@@ -354,7 +354,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                 let is_union = match self.fields {\n                     layout::FieldPlacement::Array { count, .. } => {\n                         if count > 0 {\n-                            return self.field(ccx, 0).homogeneous_aggregate(ccx);\n+                            return self.field(cx, 0).homogeneous_aggregate(cx);\n                         } else {\n                             return None;\n                         }\n@@ -368,8 +368,8 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                         return None;\n                     }\n \n-                    let field = self.field(ccx, i);\n-                    match (result, field.homogeneous_aggregate(ccx)) {\n+                    let field = self.field(cx, i);\n+                    match (result, field.homogeneous_aggregate(cx)) {\n                         // The field itself must be a homogeneous aggregate.\n                         (_, None) => return None,\n                         // If this is the first field, record the unit.\n@@ -423,34 +423,34 @@ impl From<Uniform> for CastTarget {\n }\n \n impl CastTarget {\n-    pub fn size(&self, ccx: &CodegenCx) -> Size {\n+    pub fn size(&self, cx: &CodegenCx) -> Size {\n         match *self {\n             CastTarget::Uniform(u) => u.total,\n             CastTarget::Pair(a, b) => {\n-                (a.size.abi_align(a.align(ccx)) + b.size)\n-                    .abi_align(self.align(ccx))\n+                (a.size.abi_align(a.align(cx)) + b.size)\n+                    .abi_align(self.align(cx))\n             }\n         }\n     }\n \n-    pub fn align(&self, ccx: &CodegenCx) -> Align {\n+    pub fn align(&self, cx: &CodegenCx) -> Align {\n         match *self {\n-            CastTarget::Uniform(u) => u.align(ccx),\n+            CastTarget::Uniform(u) => u.align(cx),\n             CastTarget::Pair(a, b) => {\n-                ccx.data_layout().aggregate_align\n-                    .max(a.align(ccx))\n-                    .max(b.align(ccx))\n+                cx.data_layout().aggregate_align\n+                    .max(a.align(cx))\n+                    .max(b.align(cx))\n             }\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CodegenCx) -> Type {\n+    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n         match *self {\n-            CastTarget::Uniform(u) => u.llvm_type(ccx),\n+            CastTarget::Uniform(u) => u.llvm_type(cx),\n             CastTarget::Pair(a, b) => {\n-                Type::struct_(ccx, &[\n-                    a.llvm_type(ccx),\n-                    b.llvm_type(ccx)\n+                Type::struct_(cx, &[\n+                    a.llvm_type(cx),\n+                    b.llvm_type(cx)\n                 ], false)\n             }\n         }\n@@ -547,8 +547,8 @@ impl<'a, 'tcx> ArgType<'tcx> {\n \n     /// Get the LLVM type for an place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n-    pub fn memory_ty(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type {\n-        self.layout.llvm_type(ccx)\n+    pub fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+        self.layout.llvm_type(cx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n@@ -559,15 +559,15 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         if self.is_ignore() {\n             return;\n         }\n-        let ccx = bcx.ccx;\n+        let cx = bcx.cx;\n         if self.is_indirect() {\n             OperandValue::Ref(val, self.layout.align).store(bcx, dst)\n         } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bcx.pointercast(dst.llval, cast.llvm_type(ccx).ptr_to());\n+                let cast_dst = bcx.pointercast(dst.llval, cast.llvm_type(cx).ptr_to());\n                 bcx.store(val, cast_dst, self.layout.align);\n             } else {\n                 // The actual return type is a struct, but the ABI\n@@ -585,19 +585,19 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let scratch_size = cast.size(ccx);\n-                let scratch_align = cast.align(ccx);\n-                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", scratch_align);\n+                let scratch_size = cast.size(cx);\n+                let scratch_align = cast.align(cx);\n+                let llscratch = bcx.alloca(cast.llvm_type(cx), \"abi_cast\", scratch_align);\n                 bcx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value...\n                 bcx.store(val, llscratch, scratch_align);\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bcx,\n-                                  bcx.pointercast(dst.llval, Type::i8p(ccx)),\n-                                  bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_usize(ccx, self.layout.size.bytes()),\n+                                  bcx.pointercast(dst.llval, Type::i8p(cx)),\n+                                  bcx.pointercast(llscratch, Type::i8p(cx)),\n+                                  C_usize(cx, self.layout.size.bytes()),\n                                   self.layout.align.min(scratch_align));\n \n                 bcx.lifetime_end(llscratch, scratch_size);\n@@ -647,26 +647,26 @@ pub struct FnType<'tcx> {\n }\n \n impl<'a, 'tcx> FnType<'tcx> {\n-    pub fn of_instance(ccx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+    pub fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n-        let fn_ty = instance.ty(ccx.tcx);\n-        let sig = ty_fn_sig(ccx, fn_ty);\n-        let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n-        FnType::new(ccx, sig, &[])\n+        let fn_ty = instance.ty(cx.tcx);\n+        let sig = ty_fn_sig(cx, fn_ty);\n+        let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+        FnType::new(cx, sig, &[])\n     }\n \n-    pub fn new(ccx: &CodegenCx<'a, 'tcx>,\n+    pub fn new(cx: &CodegenCx<'a, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n-        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n-        fn_ty.adjust_for_abi(ccx, sig.abi);\n+        let mut fn_ty = FnType::unadjusted(cx, sig, extra_args);\n+        fn_ty.adjust_for_abi(cx, sig.abi);\n         fn_ty\n     }\n \n-    pub fn new_vtable(ccx: &CodegenCx<'a, 'tcx>,\n+    pub fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n-        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n+        let mut fn_ty = FnType::unadjusted(cx, sig, extra_args);\n         // Don't pass the vtable, it's not an argument of the virtual fn.\n         {\n             let self_arg = &mut fn_ty.args[0];\n@@ -681,20 +681,20 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 .unwrap_or_else(|| {\n                     bug!(\"FnType::new_vtable: non-pointer self {:?}\", self_arg)\n                 }).ty;\n-            let fat_ptr_ty = ccx.tcx.mk_mut_ptr(pointee);\n-            self_arg.layout = ccx.layout_of(fat_ptr_ty).field(ccx, 0);\n+            let fat_ptr_ty = cx.tcx.mk_mut_ptr(pointee);\n+            self_arg.layout = cx.layout_of(fat_ptr_ty).field(cx, 0);\n         }\n-        fn_ty.adjust_for_abi(ccx, sig.abi);\n+        fn_ty.adjust_for_abi(cx, sig.abi);\n         fn_ty\n     }\n \n-    pub fn unadjusted(ccx: &CodegenCx<'a, 'tcx>,\n+    pub fn unadjusted(cx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         debug!(\"FnType::unadjusted({:?}, {:?})\", sig, extra_args);\n \n         use self::Abi::*;\n-        let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n+        let cconv = match cx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |\n             Rust | RustCall => llvm::CCallConv,\n \n@@ -737,7 +737,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n             extra_args\n         };\n \n-        let target = &ccx.sess().target.target;\n+        let target = &cx.sess().target.target;\n         let win_x64_gnu = target.target_os == \"windows\"\n                        && target.arch == \"x86_64\"\n                        && target.target_env == \"gnu\";\n@@ -772,7 +772,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 }\n             }\n \n-            if let Some(pointee) = layout.pointee_info_at(ccx, offset) {\n+            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n                 if let Some(kind) = pointee.safe {\n                     attrs.pointee_size = pointee.size;\n                     attrs.pointee_align = Some(pointee.align);\n@@ -809,7 +809,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         };\n \n         let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n-            let mut arg = ArgType::new(ccx.layout_of(ty));\n+            let mut arg = ArgType::new(cx.layout_of(ty));\n             if arg.layout.is_zst() {\n                 // For some forsaken reason, x86_64-pc-windows-gnu\n                 // doesn't ignore zero-sized struct arguments.\n@@ -832,7 +832,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                     adjust_for_rust_scalar(&mut b_attrs,\n                                            b,\n                                            arg.layout,\n-                                           a.value.size(ccx).abi_align(b.value.align(ccx)),\n+                                           a.value.size(cx).abi_align(b.value.align(cx)),\n                                            false);\n                     arg.mode = PassMode::Pair(a_attrs, b_attrs);\n                     return arg;\n@@ -863,7 +863,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n     }\n \n     fn adjust_for_abi(&mut self,\n-                      ccx: &CodegenCx<'a, 'tcx>,\n+                      cx: &CodegenCx<'a, 'tcx>,\n                       abi: Abi) {\n         if abi == Abi::Unadjusted { return }\n \n@@ -878,7 +878,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 }\n \n                 let size = arg.layout.size;\n-                if size > layout::Pointer.size(ccx) {\n+                if size > layout::Pointer.size(cx) {\n                     arg.make_indirect();\n                 } else {\n                     // We want to pass small aggregates as immediates, but using\n@@ -900,76 +900,76 @@ impl<'a, 'tcx> FnType<'tcx> {\n             return;\n         }\n \n-        match &ccx.sess().target.target.arch[..] {\n+        match &cx.sess().target.target.arch[..] {\n             \"x86\" => {\n                 let flavor = if abi == Abi::Fastcall {\n                     cabi_x86::Flavor::Fastcall\n                 } else {\n                     cabi_x86::Flavor::General\n                 };\n-                cabi_x86::compute_abi_info(ccx, self, flavor);\n+                cabi_x86::compute_abi_info(cx, self, flavor);\n             },\n             \"x86_64\" => if abi == Abi::SysV64 {\n-                cabi_x86_64::compute_abi_info(ccx, self);\n-            } else if abi == Abi::Win64 || ccx.sess().target.target.options.is_like_windows {\n+                cabi_x86_64::compute_abi_info(cx, self);\n+            } else if abi == Abi::Win64 || cx.sess().target.target.options.is_like_windows {\n                 cabi_x86_win64::compute_abi_info(self);\n             } else {\n-                cabi_x86_64::compute_abi_info(ccx, self);\n+                cabi_x86_64::compute_abi_info(cx, self);\n             },\n-            \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, self),\n-            \"arm\" => cabi_arm::compute_abi_info(ccx, self),\n-            \"mips\" => cabi_mips::compute_abi_info(ccx, self),\n-            \"mips64\" => cabi_mips64::compute_abi_info(ccx, self),\n-            \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, self),\n-            \"powerpc64\" => cabi_powerpc64::compute_abi_info(ccx, self),\n-            \"s390x\" => cabi_s390x::compute_abi_info(ccx, self),\n-            \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, self),\n-            \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n+            \"aarch64\" => cabi_aarch64::compute_abi_info(cx, self),\n+            \"arm\" => cabi_arm::compute_abi_info(cx, self),\n+            \"mips\" => cabi_mips::compute_abi_info(cx, self),\n+            \"mips64\" => cabi_mips64::compute_abi_info(cx, self),\n+            \"powerpc\" => cabi_powerpc::compute_abi_info(cx, self),\n+            \"powerpc64\" => cabi_powerpc64::compute_abi_info(cx, self),\n+            \"s390x\" => cabi_s390x::compute_abi_info(cx, self),\n+            \"asmjs\" => cabi_asmjs::compute_abi_info(cx, self),\n+            \"wasm32\" => cabi_asmjs::compute_abi_info(cx, self),\n             \"msp430\" => cabi_msp430::compute_abi_info(self),\n-            \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n-            \"sparc64\" => cabi_sparc64::compute_abi_info(ccx, self),\n+            \"sparc\" => cabi_sparc::compute_abi_info(cx, self),\n+            \"sparc64\" => cabi_sparc64::compute_abi_info(cx, self),\n             \"nvptx\" => cabi_nvptx::compute_abi_info(self),\n             \"nvptx64\" => cabi_nvptx64::compute_abi_info(self),\n             \"hexagon\" => cabi_hexagon::compute_abi_info(self),\n-            a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n+            a => cx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n         if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n             attrs.set(ArgAttribute::StructRet);\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type {\n+    pub fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore => Type::void(ccx),\n+            PassMode::Ignore => Type::void(cx),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n-                self.ret.layout.immediate_llvm_type(ccx)\n+                self.ret.layout.immediate_llvm_type(cx)\n             }\n-            PassMode::Cast(cast) => cast.llvm_type(ccx),\n+            PassMode::Cast(cast) => cast.llvm_type(cx),\n             PassMode::Indirect(_) => {\n-                llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n-                Type::void(ccx)\n+                llargument_tys.push(self.ret.memory_ty(cx).ptr_to());\n+                Type::void(cx)\n             }\n         };\n \n         for arg in &self.args {\n             // add padding\n             if let Some(ty) = arg.pad {\n-                llargument_tys.push(ty.llvm_type(ccx));\n+                llargument_tys.push(ty.llvm_type(cx));\n             }\n \n             let llarg_ty = match arg.mode {\n                 PassMode::Ignore => continue,\n-                PassMode::Direct(_) => arg.layout.immediate_llvm_type(ccx),\n+                PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n-                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(ccx, 0));\n-                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(ccx, 1));\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 0));\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1));\n                     continue;\n                 }\n-                PassMode::Cast(cast) => cast.llvm_type(ccx),\n-                PassMode::Indirect(_) => arg.memory_ty(ccx).ptr_to(),\n+                PassMode::Cast(cast) => cast.llvm_type(cx),\n+                PassMode::Indirect(_) => arg.memory_ty(cx).ptr_to(),\n             };\n             llargument_tys.push(llarg_ty);\n         }"}, {"sha": "33f5b737d6fbb539be0aeed0665bb42e3dbcd7ed", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -45,7 +45,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n         if out.is_indirect {\n             indirect_outputs.push(place.load(bcx).immediate());\n         } else {\n-            output_types.push(place.layout.llvm_type(bcx.ccx));\n+            output_types.push(place.layout.llvm_type(bcx.cx));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -76,9 +76,9 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     // Depending on how many outputs we have, the return type is different\n     let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n-        0 => Type::void(bcx.ccx),\n+        0 => Type::void(bcx.cx),\n         1 => output_types[0],\n-        _ => Type::struct_(bcx.ccx, &output_types, false)\n+        _ => Type::struct_(bcx.cx, &output_types, false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -109,20 +109,20 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     // back to source locations.  See #17552.\n     unsafe {\n         let key = \"srcloc\";\n-        let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx.llcx,\n+        let kind = llvm::LLVMGetMDKindIDInContext(bcx.cx.llcx,\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bcx.ccx, ia.ctxt.outer().as_u32() as i32);\n+        let val: llvm::ValueRef = C_i32(bcx.cx, ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n-            llvm::LLVMMDNodeInContext(bcx.ccx.llcx, &val, 1));\n+            llvm::LLVMMDNodeInContext(bcx.cx.llcx, &val, 1));\n     }\n }\n \n-pub fn trans_global_asm<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn trans_global_asm<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   ga: &hir::GlobalAsm) {\n     let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n     unsafe {\n-        llvm::LLVMRustAppendModuleInlineAsm(ccx.llmod, asm.as_ptr());\n+        llvm::LLVMRustAppendModuleInlineAsm(cx.llmod, asm.as_ptr());\n     }\n }"}, {"sha": "6c8088375c4b0548fc7d84f0b41a77827e137224", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -67,27 +67,27 @@ pub fn naked(val: ValueRef, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n-pub fn set_frame_pointer_elimination(ccx: &CodegenCx, llfn: ValueRef) {\n+pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {\n     // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n     // parameter.\n-    if ccx.sess().must_not_eliminate_frame_pointers() {\n+    if cx.sess().must_not_eliminate_frame_pointers() {\n         llvm::AddFunctionAttrStringValue(\n             llfn, llvm::AttributePlace::Function,\n             cstr(\"no-frame-pointer-elim\\0\"), cstr(\"true\\0\"));\n     }\n }\n \n-pub fn set_probestack(ccx: &CodegenCx, llfn: ValueRef) {\n+pub fn set_probestack(cx: &CodegenCx, llfn: ValueRef) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n-    if !ccx.sess().target.target.options.stack_probes {\n+    if !cx.sess().target.target.options.stack_probes {\n         return\n     }\n \n     // Currently stack probes seem somewhat incompatible with the address\n     // sanitizer. With asan we're already protected from stack overflow anyway\n     // so we don't really need stack probes regardless.\n-    match ccx.sess().opts.debugging_opts.sanitizer {\n+    match cx.sess().opts.debugging_opts.sanitizer {\n         Some(Sanitizer::Address) => return,\n         _ => {}\n     }\n@@ -101,13 +101,13 @@ pub fn set_probestack(ccx: &CodegenCx, llfn: ValueRef) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n-pub fn from_fn_attrs(ccx: &CodegenCx, llfn: ValueRef, id: DefId) {\n+pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n     use syntax::attr::*;\n-    let attrs = ccx.tcx.get_attrs(id);\n-    inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), &attrs));\n+    let attrs = cx.tcx.get_attrs(id);\n+    inline(llfn, find_inline_attr(Some(cx.sess().diagnostic()), &attrs));\n \n-    set_frame_pointer_elimination(ccx, llfn);\n-    set_probestack(ccx, llfn);\n+    set_frame_pointer_elimination(cx, llfn);\n+    set_probestack(cx, llfn);\n \n     for attr in attrs.iter() {\n         if attr.check_name(\"cold\") {\n@@ -124,7 +124,7 @@ pub fn from_fn_attrs(ccx: &CodegenCx, llfn: ValueRef, id: DefId) {\n         }\n     }\n \n-    let target_features = ccx.tcx.target_features_enabled(id);\n+    let target_features = cx.tcx.target_features_enabled(id);\n     if !target_features.is_empty() {\n         let val = CString::new(target_features.join(\",\")).unwrap();\n         llvm::AddFunctionAttrStringValue("}, {"sha": "e5f2a51ed3b33e23a91690e44046016699c236c5", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -94,16 +94,16 @@ pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n-    ccx: &'a CodegenCx<'a, 'tcx>,\n+    cx: &'a CodegenCx<'a, 'tcx>,\n     name: Option<String>,\n     istart: usize,\n }\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n-    pub fn new(ccx: &'a CodegenCx<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n-        let istart = ccx.stats.borrow().n_llvm_insns;\n+    pub fn new(cx: &'a CodegenCx<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n+        let istart = cx.stats.borrow().n_llvm_insns;\n         StatRecorder {\n-            ccx,\n+            cx,\n             name: Some(name),\n             istart,\n         }\n@@ -112,8 +112,8 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n \n impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n-        if self.ccx.sess().trans_stats() {\n-            let mut stats = self.ccx.stats.borrow_mut();\n+        if self.cx.sess().trans_stats() {\n+            let mut stats = self.cx.stats.borrow_mut();\n             let iend = stats.n_llvm_insns;\n             stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n             stats.n_fns += 1;\n@@ -189,15 +189,15 @@ pub fn compare_simd_types<'a, 'tcx>(\n /// The `old_info` argument is a bit funny. It is intended for use\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n-pub fn unsized_info<'ccx, 'tcx>(ccx: &CodegenCx<'ccx, 'tcx>,\n+pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n                                 source: Ty<'tcx>,\n                                 target: Ty<'tcx>,\n                                 old_info: Option<ValueRef>)\n                                 -> ValueRef {\n-    let (source, target) = ccx.tcx.struct_lockstep_tails(source, target);\n+    let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n-            C_usize(ccx, len.val.to_const_int().unwrap().to_u64().unwrap())\n+            C_usize(cx, len.val.to_const_int().unwrap().to_u64().unwrap())\n         }\n         (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n@@ -206,10 +206,10 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CodegenCx<'ccx, 'tcx>,\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n         (_, &ty::TyDynamic(ref data, ..)) => {\n-            let vtable_ptr = ccx.layout_of(ccx.tcx.mk_mut_ptr(target))\n-                .field(ccx, abi::FAT_PTR_EXTRA);\n-            consts::ptrcast(meth::get_vtable(ccx, source, data.principal()),\n-                            vtable_ptr.llvm_type(ccx))\n+            let vtable_ptr = cx.layout_of(cx.tcx.mk_mut_ptr(target))\n+                .field(cx, abi::FAT_PTR_EXTRA);\n+            consts::ptrcast(meth::get_vtable(cx, source, data.principal()),\n+                            vtable_ptr.llvm_type(cx))\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n                                      source,\n@@ -232,40 +232,40 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bcx.ccx.type_is_sized(a));\n-            let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n-            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n+            assert!(bcx.cx.type_is_sized(a));\n+            let ptr_ty = bcx.cx.layout_of(b).llvm_type(bcx.cx).ptr_to();\n+            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.cx, a, b, None))\n         }\n         (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bcx.ccx.type_is_sized(a));\n-            let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n-            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n+            assert!(bcx.cx.type_is_sized(a));\n+            let ptr_ty = bcx.cx.layout_of(b).llvm_type(bcx.cx).ptr_to();\n+            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.cx, a, b, None))\n         }\n         (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            let src_layout = bcx.ccx.layout_of(src_ty);\n-            let dst_layout = bcx.ccx.layout_of(dst_ty);\n+            let src_layout = bcx.cx.layout_of(src_ty);\n+            let dst_layout = bcx.cx.layout_of(dst_ty);\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n-                let src_f = src_layout.field(bcx.ccx, i);\n+                let src_f = src_layout.field(bcx.cx, i);\n                 assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n                 assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n                 if src_f.is_zst() {\n                     continue;\n                 }\n                 assert_eq!(src_layout.size, src_f.size);\n \n-                let dst_f = dst_layout.field(bcx.ccx, i);\n+                let dst_f = dst_layout.field(bcx.cx, i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n                 result = Some(unsize_thin_ptr(bcx, src, src_f.ty, dst_f.ty));\n             }\n             let (lldata, llextra) = result.unwrap();\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            (bcx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bcx.ccx, 0)),\n-             bcx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bcx.ccx, 1)))\n+            (bcx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bcx.cx, 0)),\n+             bcx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bcx.cx, 1)))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n@@ -285,8 +285,8 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n                 // the types match up.\n-                let thin_ptr = dst.layout.field(bcx.ccx, abi::FAT_PTR_ADDR);\n-                (bcx.pointercast(base, thin_ptr.llvm_type(bcx.ccx)), info)\n+                let thin_ptr = dst.layout.field(bcx.cx, abi::FAT_PTR_ADDR);\n+                (bcx.pointercast(base, thin_ptr.llvm_type(bcx.cx)), info)\n             }\n             OperandValue::Immediate(base) => {\n                 unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n@@ -389,13 +389,13 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n }\n \n pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n-    let assume_intrinsic = b.ccx.get_intrinsic(\"llvm.assume\");\n+    let assume_intrinsic = b.cx.get_intrinsic(\"llvm.assume\");\n     b.call(assume_intrinsic, &[val], None);\n }\n \n pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n-    if val_ty(val) == Type::i1(bcx.ccx) {\n-        bcx.zext(val, Type::i8(bcx.ccx))\n+    if val_ty(val) == Type::i1(bcx.cx) {\n+        bcx.zext(val, Type::i8(bcx.cx))\n     } else {\n         val\n     }\n@@ -404,7 +404,7 @@ pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n pub fn to_immediate(bcx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n     if let layout::Abi::Scalar(ref scalar) = layout.abi {\n         if scalar.is_bool() {\n-            return bcx.trunc(val, Type::i1(bcx.ccx));\n+            return bcx.trunc(val, Type::i1(bcx.cx));\n         }\n     }\n     val\n@@ -415,15 +415,15 @@ pub fn call_memcpy(b: &Builder,\n                    src: ValueRef,\n                    n_bytes: ValueRef,\n                    align: Align) {\n-    let ccx = b.ccx;\n-    let ptr_width = &ccx.sess().target.target.target_pointer_width;\n+    let cx = b.cx;\n+    let ptr_width = &cx.sess().target.target.target_pointer_width;\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n-    let memcpy = ccx.get_intrinsic(&key);\n-    let src_ptr = b.pointercast(src, Type::i8p(ccx));\n-    let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n-    let size = b.intcast(n_bytes, ccx.isize_ty, false);\n-    let align = C_i32(ccx, align.abi() as i32);\n-    let volatile = C_bool(ccx, false);\n+    let memcpy = cx.get_intrinsic(&key);\n+    let src_ptr = b.pointercast(src, Type::i8p(cx));\n+    let dst_ptr = b.pointercast(dst, Type::i8p(cx));\n+    let size = b.intcast(n_bytes, cx.isize_ty, false);\n+    let align = C_i32(cx, align.abi() as i32);\n+    let volatile = C_bool(cx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n@@ -439,7 +439,7 @@ pub fn memcpy_ty<'a, 'tcx>(\n         return;\n     }\n \n-    call_memcpy(bcx, dst, src, C_usize(bcx.ccx, size), align);\n+    call_memcpy(bcx, dst, src, C_usize(bcx.cx, size), align);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n@@ -448,19 +448,19 @@ pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n                              size: ValueRef,\n                              align: ValueRef,\n                              volatile: bool) -> ValueRef {\n-    let ptr_width = &b.ccx.sess().target.target.target_pointer_width;\n+    let ptr_width = &b.cx.sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-    let llintrinsicfn = b.ccx.get_intrinsic(&intrinsic_key);\n-    let volatile = C_bool(b.ccx, volatile);\n+    let llintrinsicfn = b.cx.get_intrinsic(&intrinsic_key);\n+    let volatile = C_bool(b.cx, volatile);\n     b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn trans_instance<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let _s = if ccx.sess().trans_stats() {\n+pub fn trans_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {\n+    let _s = if cx.sess().trans_stats() {\n         let mut instance_name = String::new();\n-        DefPathBasedNames::new(ccx.tcx, true, true)\n+        DefPathBasedNames::new(cx.tcx, true, true)\n             .push_def_path(instance.def_id(), &mut instance_name);\n-        Some(StatRecorder::new(ccx, instance_name))\n+        Some(StatRecorder::new(cx, instance_name))\n     } else {\n         None\n     };\n@@ -470,16 +470,16 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, instance: Instance<'t\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = instance.ty(ccx.tcx);\n-    let sig = common::ty_fn_sig(ccx, fn_ty);\n-    let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let fn_ty = instance.ty(cx.tcx);\n+    let sig = common::ty_fn_sig(cx, fn_ty);\n+    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n \n-    let lldecl = match ccx.instances.borrow().get(&instance) {\n+    let lldecl = match cx.instances.borrow().get(&instance) {\n         Some(&val) => val,\n         None => bug!(\"Instance `{:?}` not already declared\", instance)\n     };\n \n-    ccx.stats.borrow_mut().n_closures += 1;\n+    cx.stats.borrow_mut().n_closures += 1;\n \n     // The `uwtable` attribute according to LLVM is:\n     //\n@@ -497,21 +497,21 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, instance: Instance<'t\n     //\n     // You can also find more info on why Windows is whitelisted here in:\n     //      https://bugzilla.mozilla.org/show_bug.cgi?id=1302078\n-    if !ccx.sess().no_landing_pads() ||\n-       ccx.sess().target.target.options.is_like_windows {\n+    if !cx.sess().no_landing_pads() ||\n+       cx.sess().target.target.options.is_like_windows {\n         attributes::emit_uwtable(lldecl, true);\n     }\n \n-    let mir = ccx.tcx.instance_mir(instance.def);\n-    mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n+    let mir = cx.tcx.instance_mir(instance.def);\n+    mir::trans_mir(cx, lldecl, &mir, instance, sig);\n }\n \n-pub fn set_link_section(ccx: &CodegenCx,\n+pub fn set_link_section(cx: &CodegenCx,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {\n     if let Some(sect) = attr::first_attr_value_str_by_name(attrs, \"link_section\") {\n         if contains_null(&sect.as_str()) {\n-            ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n+            cx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n         }\n         unsafe {\n             let buf = CString::new(sect.as_str().as_bytes()).unwrap();\n@@ -522,82 +522,82 @@ pub fn set_link_section(ccx: &CodegenCx,\n \n /// Create the `main` function which will initialize the rust runtime and call\n /// users main function.\n-fn maybe_create_entry_wrapper(ccx: &CodegenCx) {\n-    let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n+fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n+    let (main_def_id, span) = match *cx.sess().entry_fn.borrow() {\n         Some((id, span)) => {\n-            (ccx.tcx.hir.local_def_id(id), span)\n+            (cx.tcx.hir.local_def_id(id), span)\n         }\n         None => return,\n     };\n \n-    let instance = Instance::mono(ccx.tcx, main_def_id);\n+    let instance = Instance::mono(cx.tcx, main_def_id);\n \n-    if !ccx.codegen_unit.contains_item(&MonoItem::Fn(instance)) {\n+    if !cx.codegen_unit.contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n     }\n \n-    let main_llfn = callee::get_fn(ccx, instance);\n+    let main_llfn = callee::get_fn(cx, instance);\n \n-    let et = ccx.sess().entry_type.get().unwrap();\n+    let et = cx.sess().entry_type.get().unwrap();\n     match et {\n-        config::EntryMain => create_entry_fn(ccx, span, main_llfn, main_def_id, true),\n-        config::EntryStart => create_entry_fn(ccx, span, main_llfn, main_def_id, false),\n+        config::EntryMain => create_entry_fn(cx, span, main_llfn, main_def_id, true),\n+        config::EntryStart => create_entry_fn(cx, span, main_llfn, main_def_id, false),\n         config::EntryNone => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn<'ccx>(ccx: &'ccx CodegenCx,\n+    fn create_entry_fn<'cx>(cx: &'cx CodegenCx,\n                        sp: Span,\n                        rust_main: ValueRef,\n                        rust_main_def_id: DefId,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func(&[Type::c_int(ccx), Type::i8p(ccx).ptr_to()], &Type::c_int(ccx));\n+        let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], &Type::c_int(cx));\n \n-        let main_ret_ty = ccx.tcx.fn_sig(rust_main_def_id).output();\n+        let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n         // then its return type cannot have\n         // late-bound regions, since late-bound\n         // regions must appear in the argument\n         // listing.\n         let main_ret_ty = main_ret_ty.no_late_bound_regions().unwrap();\n \n-        if declare::get_defined_value(ccx, \"main\").is_some() {\n+        if declare::get_defined_value(cx, \"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here.\n-            ccx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n+            cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n                       .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n                       .emit();\n-            ccx.sess().abort_if_errors();\n+            cx.sess().abort_if_errors();\n             bug!();\n         }\n-        let llfn = declare::declare_cfn(ccx, \"main\", llfty);\n+        let llfn = declare::declare_cfn(cx, \"main\", llfty);\n \n         // `main` should respect same config for frame pointer elimination as rest of code\n-        attributes::set_frame_pointer_elimination(ccx, llfn);\n+        attributes::set_frame_pointer_elimination(cx, llfn);\n \n-        let bld = Builder::new_block(ccx, llfn, \"top\");\n+        let bld = Builder::new_block(cx, llfn, \"top\");\n \n-        debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx, &bld);\n+        debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(cx, &bld);\n \n         // Params from native main() used as args for rust start function\n         let param_argc = get_param(llfn, 0);\n         let param_argv = get_param(llfn, 1);\n-        let arg_argc = bld.intcast(param_argc, ccx.isize_ty, true);\n+        let arg_argc = bld.intcast(param_argc, cx.isize_ty, true);\n         let arg_argv = param_argv;\n \n         let (start_fn, args) = if use_start_lang_item {\n-            let start_def_id = ccx.tcx.require_lang_item(StartFnLangItem);\n-            let start_fn = callee::resolve_and_get_fn(ccx, start_def_id, ccx.tcx.mk_substs(\n+            let start_def_id = cx.tcx.require_lang_item(StartFnLangItem);\n+            let start_fn = callee::resolve_and_get_fn(cx, start_def_id, cx.tcx.mk_substs(\n                 iter::once(Kind::from(main_ret_ty))));\n-            (start_fn, vec![bld.pointercast(rust_main, Type::i8p(ccx).ptr_to()),\n+            (start_fn, vec![bld.pointercast(rust_main, Type::i8p(cx).ptr_to()),\n                             arg_argc, arg_argv])\n         } else {\n             debug!(\"using user-defined start fn\");\n             (rust_main, vec![arg_argc, arg_argv])\n         };\n \n         let result = bld.call(start_fn, &args, None);\n-        bld.ret(bld.intcast(result, Type::c_int(ccx), true));\n+        bld.ret(bld.intcast(result, Type::c_int(cx), true));\n     }\n }\n \n@@ -1203,25 +1203,25 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    .to_fingerprint().to_hex());\n \n         // Instantiate translation items without filling out definitions yet...\n-        let ccx = CodegenCx::new(tcx, cgu, &llmod_id);\n+        let cx = CodegenCx::new(tcx, cgu, &llmod_id);\n         let module = {\n-            let trans_items = ccx.codegen_unit\n-                                 .items_in_deterministic_order(ccx.tcx);\n+            let trans_items = cx.codegen_unit\n+                                 .items_in_deterministic_order(cx.tcx);\n             for &(trans_item, (linkage, visibility)) in &trans_items {\n-                trans_item.predefine(&ccx, linkage, visibility);\n+                trans_item.predefine(&cx, linkage, visibility);\n             }\n \n             // ... and now that we have everything pre-defined, fill out those definitions.\n             for &(trans_item, _) in &trans_items {\n-                trans_item.define(&ccx);\n+                trans_item.define(&cx);\n             }\n \n             // If this codegen unit contains the main function, also create the\n             // wrapper here\n-            maybe_create_entry_wrapper(&ccx);\n+            maybe_create_entry_wrapper(&cx);\n \n             // Run replace-all-uses-with for statics that need it\n-            for &(old_g, new_g) in ccx.statics_to_rauw.borrow().iter() {\n+            for &(old_g, new_g) in cx.statics_to_rauw.borrow().iter() {\n                 unsafe {\n                     let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n                     llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n@@ -1231,13 +1231,13 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             // Create the llvm.used variable\n             // This variable has type [N x i8*] and is stored in the llvm.metadata section\n-            if !ccx.used_statics.borrow().is_empty() {\n+            if !cx.used_statics.borrow().is_empty() {\n                 let name = CString::new(\"llvm.used\").unwrap();\n                 let section = CString::new(\"llvm.metadata\").unwrap();\n-                let array = C_array(Type::i8(&ccx).ptr_to(), &*ccx.used_statics.borrow());\n+                let array = C_array(Type::i8(&cx).ptr_to(), &*cx.used_statics.borrow());\n \n                 unsafe {\n-                    let g = llvm::LLVMAddGlobal(ccx.llmod,\n+                    let g = llvm::LLVMAddGlobal(cx.llmod,\n                                                 val_ty(array).to_ref(),\n                                                 name.as_ptr());\n                     llvm::LLVMSetInitializer(g, array);\n@@ -1247,14 +1247,14 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             // Finalize debuginfo\n-            if ccx.sess().opts.debuginfo != NoDebugInfo {\n-                debuginfo::finalize(&ccx);\n+            if cx.sess().opts.debuginfo != NoDebugInfo {\n+                debuginfo::finalize(&cx);\n             }\n \n             let llvm_module = ModuleLlvm {\n-                llcx: ccx.llcx,\n-                llmod: ccx.llmod,\n-                tm: create_target_machine(ccx.sess()),\n+                llcx: cx.llcx,\n+                llmod: cx.llmod,\n+                tm: create_target_machine(cx.sess()),\n             };\n \n             ModuleTranslation {\n@@ -1265,7 +1265,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n-        (ccx.into_stats(), module)\n+        (cx.into_stats(), module)\n     }\n }\n "}, {"sha": "79b91dc48fe5b49623e45d4600cbdf773abc70e3", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -32,7 +32,7 @@ use syntax_pos::Span;\n #[must_use]\n pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,\n-    pub ccx: &'a CodegenCx<'a, 'tcx>,\n+    pub cx: &'a CodegenCx<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> Drop for Builder<'a, 'tcx> {\n@@ -51,12 +51,12 @@ fn noname() -> *const c_char {\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn new_block<'b>(ccx: &'a CodegenCx<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n-        let builder = Builder::with_ccx(ccx);\n+    pub fn new_block<'b>(cx: &'a CodegenCx<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+        let builder = Builder::with_cx(cx);\n         let llbb = unsafe {\n             let name = CString::new(name).unwrap();\n             llvm::LLVMAppendBasicBlockInContext(\n-                ccx.llcx,\n+                cx.llcx,\n                 llfn,\n                 name.as_ptr()\n             )\n@@ -65,27 +65,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         builder\n     }\n \n-    pub fn with_ccx(ccx: &'a CodegenCx<'a, 'tcx>) -> Self {\n+    pub fn with_cx(cx: &'a CodegenCx<'a, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n-            llvm::LLVMCreateBuilderInContext(ccx.llcx)\n+            llvm::LLVMCreateBuilderInContext(cx.llcx)\n         };\n         Builder {\n             llbuilder,\n-            ccx,\n+            cx,\n         }\n     }\n \n     pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'tcx> {\n-        Builder::new_block(self.ccx, self.llfn(), name)\n+        Builder::new_block(self.cx, self.llfn(), name)\n     }\n \n     pub fn sess(&self) -> &Session {\n-        self.ccx.sess()\n+        self.cx.sess()\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.ccx.tcx\n+        self.cx.tcx\n     }\n \n     pub fn llfn(&self) -> ValueRef {\n@@ -101,11 +101,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     fn count_insn(&self, category: &str) {\n-        if self.ccx.sess().trans_stats() {\n-            self.ccx.stats.borrow_mut().n_llvm_insns += 1;\n+        if self.cx.sess().trans_stats() {\n+            self.cx.stats.borrow_mut().n_llvm_insns += 1;\n         }\n-        if self.ccx.sess().count_llvm_insns() {\n-            *self.ccx.stats\n+        if self.cx.sess().count_llvm_insns() {\n+            *self.cx.stats\n                 .borrow_mut()\n                 .llvm_insns\n                 .entry(category.to_string())\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n-        let builder = Builder::with_ccx(self.ccx);\n+        let builder = Builder::with_cx(self.cx);\n         builder.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n@@ -558,7 +558,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ];\n \n             llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx,\n+                                  llvm::LLVMMDNodeInContext(self.cx.llcx,\n                                                             v.as_ptr(),\n                                                             v.len() as c_uint));\n         }\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn nonnull_metadata(&self, load: ValueRef) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx, ptr::null(), 0));\n+                                  llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n@@ -620,8 +620,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // point to a metadata value of the integer 1. Who knew?\n             //\n             // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n-            let one = C_i32(self.ccx, 1);\n-            let node = llvm::LLVMMDNodeInContext(self.ccx.llcx,\n+            let one = C_i32(self.cx, 1);\n+            let node = llvm::LLVMMDNodeInContext(self.cx.llcx,\n                                                  &one,\n                                                  1);\n             llvm::LLVMSetMetadata(insn,\n@@ -840,24 +840,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n-        if self.ccx.sess().asm_comments() {\n+        if self.cx.sess().asm_comments() {\n             let s = format!(\"{} ({})\",\n                             text,\n-                            self.ccx.sess().codemap().span_to_string(sp));\n+                            self.cx.sess().codemap().span_to_string(sp));\n             debug!(\"{}\", s);\n             self.add_comment(&s);\n         }\n     }\n \n     pub fn add_comment(&self, text: &str) {\n-        if self.ccx.sess().asm_comments() {\n+        if self.cx.sess().asm_comments() {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = format!(\"{} {}\", \"#\",\n                                        sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n             let comment_text = CString::new(comment_text).unwrap();\n             let asm = unsafe {\n-                llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n+                llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.cx)).to_ref(),\n                                          comment_text.as_ptr(), noname(), False,\n                                          False)\n             };\n@@ -949,8 +949,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let elt_ty = val_ty(elt);\n             let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n-            let vec = self.insert_element(undef, elt, C_i32(self.ccx, 0));\n-            let vec_i32_ty = Type::vector(&Type::i32(self.ccx), num_elts as u64);\n+            let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n+            let vec_i32_ty = Type::vector(&Type::i32(self.cx), num_elts as u64);\n             self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n@@ -1160,7 +1160,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn set_invariant_load(&self, load: ValueRef) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx, ptr::null(), 0));\n+                                  llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n     /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n     fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: ValueRef, size: Size) {\n-        if self.ccx.sess().opts.optimize == config::OptLevel::No {\n+        if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;\n         }\n \n@@ -1254,9 +1254,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             return;\n         }\n \n-        let lifetime_intrinsic = self.ccx.get_intrinsic(intrinsic);\n+        let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n \n-        let ptr = self.pointercast(ptr, Type::i8p(self.ccx));\n-        self.call(lifetime_intrinsic, &[C_u64(self.ccx, size), ptr], None);\n+        let ptr = self.pointercast(ptr, Type::i8p(self.cx));\n+        self.call(lifetime_intrinsic, &[C_u64(self.cx, size), ptr], None);\n     }\n }"}, {"sha": "72ae1449de04ea7968c05097e24727598dfd869b", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -11,13 +11,13 @@\n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CodegenCx;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members.\n-        if size > unit.size.checked_mul(4, ccx).unwrap() {\n+        if size > unit.size.checked_mul(4, cx).unwrap() {\n             return None;\n         }\n \n@@ -38,12 +38,12 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgTy\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, ret) {\n         ret.cast_to(uniform);\n         return;\n     }\n@@ -69,12 +69,12 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n         arg.cast_to(uniform);\n         return;\n     }\n@@ -100,13 +100,13 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n     arg.make_indirect();\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(cx, arg);\n     }\n }"}, {"sha": "b6cf16cb8d50855747a409e5d884a7b1157e11c4", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -12,13 +12,13 @@ use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CodegenCx;\n use llvm::CallConv;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members.\n-        if size > unit.size.checked_mul(4, ccx).unwrap() {\n+        if size > unit.size.checked_mul(4, cx).unwrap() {\n             return None;\n         }\n \n@@ -39,14 +39,14 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgTy\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, vfp: bool) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, vfp: bool) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n \n     if vfp {\n-        if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+        if let Some(uniform) = is_homogeneous_aggregate(cx, ret) {\n             ret.cast_to(uniform);\n             return;\n         }\n@@ -71,14 +71,14 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>,\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n \n     if vfp {\n-        if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+        if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n             arg.cast_to(uniform);\n             return;\n         }\n@@ -92,19 +92,19 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>,\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates.\n-    let vfp = ccx.sess().target.target.llvm_target.ends_with(\"hf\")\n+    let vfp = cx.sess().target.target.llvm_target.ends_with(\"hf\")\n         && fty.cconv != CallConv::ArmAapcsCallConv\n         && !fty.variadic;\n \n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, vfp);\n+        classify_ret_ty(cx, &mut fty.ret, vfp);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, vfp);\n+        classify_arg_ty(cx, arg, vfp);\n     }\n }"}, {"sha": "b182f833dd699d0f9013c851ca75a075c90ed6ae", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -16,9 +16,9 @@ use context::CodegenCx;\n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if ret.layout.is_aggregate() {\n-        if let Some(unit) = ret.layout.homogeneous_aggregate(ccx) {\n+        if let Some(unit) = ret.layout.homogeneous_aggregate(cx) {\n             let size = ret.layout.size;\n             if unit.size == size {\n                 ret.cast_to(Uniform {\n@@ -39,9 +39,9 @@ fn classify_arg_ty(arg: &mut ArgType) {\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {"}, {"sha": "cd567f517fe8c2deec3e4957a0c6bf6a828600ec", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -13,19 +13,19 @@ use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx.data_layout.pointer_size;\n+        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx.data_layout;\n+fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,14 +44,14 @@ fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, &mut offset);\n+        classify_arg_ty(cx, arg, &mut offset);\n     }\n }"}, {"sha": "e44063faab8105e3160432b67e97c3aea46ea1df", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -13,19 +13,19 @@ use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx.data_layout.pointer_size;\n+        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx.data_layout;\n+fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,14 +44,14 @@ fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, &mut offset);\n+        classify_arg_ty(cx, arg, &mut offset);\n     }\n }"}, {"sha": "1ea6e9b26952dfe906ba080cdf71251f2af86c47", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -13,19 +13,19 @@ use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx.data_layout.pointer_size;\n+        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx.data_layout;\n+fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,14 +44,14 @@ fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, &mut offset);\n+        classify_arg_ty(cx, arg, &mut offset);\n     }\n }"}, {"sha": "c614cf3a5a9eadd872e2e9d2fd943cfcdc0ff2ef", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -23,15 +23,15 @@ enum ABI {\n }\n use self::ABI::*;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                       arg: &mut ArgType<'tcx>,\n                                       abi: ABI)\n                                      -> Option<Uniform> {\n-    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n         if (abi == ELFv1 && arg.layout.size > unit.size)\n-                || arg.layout.size > unit.size.checked_mul(8, ccx).unwrap() {\n+                || arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;\n         }\n \n@@ -52,7 +52,7 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n@@ -64,7 +64,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>,\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret, abi) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, ret, abi) {\n         ret.cast_to(uniform);\n         return;\n     }\n@@ -92,13 +92,13 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>,\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg, abi) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, arg, abi) {\n         arg.cast_to(uniform);\n         return;\n     }\n@@ -128,19 +128,19 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>,\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n-    let abi = match ccx.sess().target.target.target_endian.as_str() {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let abi = match cx.sess().target.target.target_endian.as_str() {\n         \"big\" => ELFv1,\n         \"little\" => ELFv2,\n         _ => unimplemented!(),\n     };\n \n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, abi);\n+        classify_ret_ty(cx, &mut fty.ret, abi);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, abi);\n+        classify_arg_ty(cx, arg, abi);\n     }\n }"}, {"sha": "5e817686defe262fe023cdabff28cf5cdf80b9a7", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -24,7 +24,7 @@ fn classify_ret_ty(ret: &mut ArgType) {\n     }\n }\n \n-fn is_single_fp_element<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn is_single_fp_element<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n         layout::Abi::Scalar(ref scalar) => {\n@@ -35,7 +35,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         }\n         layout::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n-                is_single_fp_element(ccx, layout.field(ccx, 0))\n+                is_single_fp_element(cx, layout.field(cx, 0))\n             } else {\n                 false\n             }\n@@ -44,13 +44,13 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if is_single_fp_element(ccx, arg.layout) {\n+    if is_single_fp_element(cx, arg.layout) {\n         match arg.layout.size.bytes() {\n             4 => arg.cast_to(Reg::f32()),\n             8 => arg.cast_to(Reg::f64()),\n@@ -67,13 +67,13 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(cx, arg);\n     }\n }"}, {"sha": "cd567f517fe8c2deec3e4957a0c6bf6a828600ec", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -13,19 +13,19 @@ use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx.data_layout.pointer_size;\n+        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx.data_layout;\n+fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,14 +44,14 @@ fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, &mut offset);\n+        classify_arg_ty(cx, arg, &mut offset);\n     }\n }"}, {"sha": "fb94b09d626bd7fde4a17d8e4600e84ecd7b9d8f", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -13,11 +13,11 @@\n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CodegenCx;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n-        if arg.layout.size > unit.size.checked_mul(8, ccx).unwrap() {\n+        if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;\n         }\n \n@@ -38,13 +38,13 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgTy\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, ret) {\n         ret.cast_to(uniform);\n         return;\n     }\n@@ -72,13 +72,13 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n         arg.cast_to(uniform);\n         return;\n     }\n@@ -90,13 +90,13 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(cx, arg);\n     }\n }"}, {"sha": "60347ba0945f91beb880d2a520c18b2b5ac07748", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -19,7 +19,7 @@ pub enum Flavor {\n     Fastcall\n }\n \n-fn is_single_fp_element<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn is_single_fp_element<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n         layout::Abi::Scalar(ref scalar) => {\n@@ -30,7 +30,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         }\n         layout::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n-                is_single_fp_element(ccx, layout.field(ccx, 0))\n+                is_single_fp_element(cx, layout.field(cx, 0))\n             } else {\n                 false\n             }\n@@ -39,7 +39,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   fty: &mut FnType<'tcx>,\n                                   flavor: Flavor) {\n     if !fty.ret.is_ignore() {\n@@ -51,12 +51,12 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n             // Some links:\n             // http://www.angelcode.com/dev/callconv/callconv.html\n             // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-            let t = &ccx.sess().target.target;\n+            let t = &cx.sess().target.target;\n             if t.options.is_like_osx || t.options.is_like_windows\n                 || t.options.is_like_openbsd {\n                 // According to Clang, everyone but MSVC returns single-element\n                 // float aggregates directly in a floating-point register.\n-                if !t.options.is_like_msvc && is_single_fp_element(ccx, fty.ret.layout) {\n+                if !t.options.is_like_msvc && is_single_fp_element(cx, fty.ret.layout) {\n                     match fty.ret.layout.size.bytes() {\n                         4 => fty.ret.cast_to(Reg::f32()),\n                         8 => fty.ret.cast_to(Reg::f64()),\n@@ -112,7 +112,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n             };\n \n             // At this point we know this must be a primitive of sorts.\n-            let unit = arg.layout.homogeneous_aggregate(ccx).unwrap();\n+            let unit = arg.layout.homogeneous_aggregate(cx).unwrap();\n             assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;"}, {"sha": "6db18bfecf258b2799be9dac80e5c725eabdb4f0", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -31,7 +31,7 @@ struct Memory;\n const LARGEST_VECTOR_SIZE: usize = 512;\n const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n-fn classify_arg<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n+fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n                           -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n     fn unify(cls: &mut [Class],\n              off: Size,\n@@ -52,7 +52,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n         cls[i] = to_write;\n     }\n \n-    fn classify<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+    fn classify<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                           layout: TyLayout<'tcx>,\n                           cls: &mut [Class],\n                           off: Size)\n@@ -82,7 +82,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n \n                 // everything after the first one is the upper\n                 // half of a register.\n-                let stride = element.value.size(ccx);\n+                let stride = element.value.size(cx);\n                 for i in 1..count {\n                     let field_off = off + stride * i;\n                     unify(cls, field_off, Class::SseUp);\n@@ -95,7 +95,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n                     layout::Variants::Single { .. } => {\n                         for i in 0..layout.fields.count() {\n                             let field_off = off + layout.fields.offset(i);\n-                            classify(ccx, layout.field(ccx, i), cls, field_off)?;\n+                            classify(cx, layout.field(cx, i), cls, field_off)?;\n                         }\n                     }\n                     layout::Variants::Tagged { .. } |\n@@ -114,7 +114,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n     }\n \n     let mut cls = [Class::None; MAX_EIGHTBYTES];\n-    classify(ccx, arg.layout, &mut cls, Size::from_bytes(0))?;\n+    classify(cx, arg.layout, &mut cls, Size::from_bytes(0))?;\n     if n > 2 {\n         if cls[0] != Class::Sse {\n             return Err(Memory);\n@@ -189,12 +189,12 @@ fn cast_target(cls: &[Class], size: Size) -> CastTarget {\n     target\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n     let mut sse_regs = 8; // XMM0-7\n \n     let mut x86_64_ty = |arg: &mut ArgType<'tcx>, is_arg: bool| {\n-        let cls = classify_arg(ccx, arg);\n+        let cls = classify_arg(cx, arg);\n \n         let mut needed_int = 0;\n         let mut needed_sse = 0;"}, {"sha": "c3d5e08c73e7ec88d1a6f6448f40915287c83d6d", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -34,33 +34,33 @@ use rustc_back::PanicStrategy;\n ///\n /// # Parameters\n ///\n-/// - `ccx`: the crate context\n+/// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                         instance: Instance<'tcx>)\n                         -> ValueRef\n {\n-    let tcx = ccx.tcx;\n+    let tcx = cx.tcx;\n \n     debug!(\"get_fn(instance={:?})\", instance);\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_regions());\n     assert!(!instance.substs.has_param_types());\n \n-    let fn_ty = instance.ty(ccx.tcx);\n-    if let Some(&llfn) = ccx.instances.borrow().get(&instance) {\n+    let fn_ty = instance.ty(cx.tcx);\n+    if let Some(&llfn) = cx.instances.borrow().get(&instance) {\n         return llfn;\n     }\n \n     let sym = tcx.symbol_name(instance);\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // Create a fn pointer with the substituted signature.\n-    let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(ccx, fn_ty));\n-    let llptrty = ccx.layout_of(fn_ptr_ty).llvm_type(ccx);\n+    let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(cx, fn_ty));\n+    let llptrty = cx.layout_of(fn_ptr_ty).llvm_type(cx);\n \n-    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n+    let llfn = if let Some(llfn) = declare::get_declared_value(cx, &sym) {\n         // This is subtle and surprising, but sometimes we have to bitcast\n         // the resulting fn pointer.  The reason has to do with external\n         // functions.  If you have two crates that both bind the same C\n@@ -92,14 +92,14 @@ pub fn get_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n             llfn\n         }\n     } else {\n-        let llfn = declare::declare_fn(ccx, &sym, fn_ty);\n+        let llfn = declare::declare_fn(cx, &sym, fn_ty);\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n         if instance.def.is_inline(tcx) {\n             attributes::inline(llfn, attributes::InlineAttr::Hint);\n         }\n-        attributes::from_fn_attrs(ccx, llfn, instance.def.def_id());\n+        attributes::from_fn_attrs(cx, llfn, instance.def.def_id());\n \n         let instance_def_id = instance.def_id();\n \n@@ -149,9 +149,9 @@ pub fn get_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            if ccx.tcx.is_translated_function(instance_def_id) {\n+            if cx.tcx.is_translated_function(instance_def_id) {\n                 if instance_def_id.is_local() {\n-                    if !ccx.tcx.is_exported_symbol(instance_def_id) {\n+                    if !cx.tcx.is_exported_symbol(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n                     }\n                 } else {\n@@ -160,7 +160,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n             }\n         }\n \n-        if ccx.use_dll_storage_attrs &&\n+        if cx.use_dll_storage_attrs &&\n             tcx.is_dllimport_foreign_item(instance_def_id)\n         {\n             unsafe {\n@@ -171,20 +171,20 @@ pub fn get_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         llfn\n     };\n \n-    ccx.instances.borrow_mut().insert(instance, llfn);\n+    cx.instances.borrow_mut().insert(instance, llfn);\n \n     llfn\n }\n \n-pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn resolve_and_get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     def_id: DefId,\n                                     substs: &'tcx Substs<'tcx>)\n                                     -> ValueRef\n {\n     get_fn(\n-        ccx,\n+        cx,\n         ty::Instance::resolve(\n-            ccx.tcx,\n+            cx.tcx,\n             ty::ParamEnv::empty(traits::Reveal::All),\n             def_id,\n             substs"}, {"sha": "7b7d35caf5ec5a6958b90a60902ff29a39e03bc8", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -152,34 +152,34 @@ pub fn C_uint_big(t: Type, u: u128) -> ValueRef {\n     }\n }\n \n-pub fn C_bool(ccx: &CodegenCx, val: bool) -> ValueRef {\n-    C_uint(Type::i1(ccx), val as u64)\n+pub fn C_bool(cx: &CodegenCx, val: bool) -> ValueRef {\n+    C_uint(Type::i1(cx), val as u64)\n }\n \n-pub fn C_i32(ccx: &CodegenCx, i: i32) -> ValueRef {\n-    C_int(Type::i32(ccx), i as i64)\n+pub fn C_i32(cx: &CodegenCx, i: i32) -> ValueRef {\n+    C_int(Type::i32(cx), i as i64)\n }\n \n-pub fn C_u32(ccx: &CodegenCx, i: u32) -> ValueRef {\n-    C_uint(Type::i32(ccx), i as u64)\n+pub fn C_u32(cx: &CodegenCx, i: u32) -> ValueRef {\n+    C_uint(Type::i32(cx), i as u64)\n }\n \n-pub fn C_u64(ccx: &CodegenCx, i: u64) -> ValueRef {\n-    C_uint(Type::i64(ccx), i)\n+pub fn C_u64(cx: &CodegenCx, i: u64) -> ValueRef {\n+    C_uint(Type::i64(cx), i)\n }\n \n-pub fn C_usize(ccx: &CodegenCx, i: u64) -> ValueRef {\n-    let bit_size = ccx.data_layout().pointer_size.bits();\n+pub fn C_usize(cx: &CodegenCx, i: u64) -> ValueRef {\n+    let bit_size = cx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow\n         assert!(i < (1<<bit_size));\n     }\n \n-    C_uint(ccx.isize_ty, i)\n+    C_uint(cx.isize_ty, i)\n }\n \n-pub fn C_u8(ccx: &CodegenCx, i: u8) -> ValueRef {\n-    C_uint(Type::i8(ccx), i as u64)\n+pub fn C_u8(cx: &CodegenCx, i: u8) -> ValueRef {\n+    C_uint(Type::i8(cx), i as u64)\n }\n \n \n@@ -382,16 +382,16 @@ pub fn shift_mask_val<'a, 'tcx>(\n     }\n }\n \n-pub fn ty_fn_sig<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                            ty: Ty<'tcx>)\n                            -> ty::PolyFnSig<'tcx>\n {\n     match ty.sty {\n         ty::TyFnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx),\n+        ty::TyFnPtr(_) => ty.fn_sig(cx.tcx),\n         ty::TyClosure(def_id, substs) => {\n-            let tcx = ccx.tcx;\n+            let tcx = cx.tcx;\n             let sig = substs.closure_sig(def_id, tcx);\n \n             let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n@@ -404,8 +404,8 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n             ))\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n-            let tcx = ccx.tcx;\n-            let sig = substs.generator_poly_sig(def_id, ccx.tcx);\n+            let tcx = cx.tcx;\n+            let sig = substs.generator_poly_sig(def_id, cx.tcx);\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);"}, {"sha": "d5b33d837c5bd92e4440fd2440e26839a0a368c9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -43,17 +43,17 @@ pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n-fn set_global_alignment(ccx: &CodegenCx,\n+fn set_global_alignment(cx: &CodegenCx,\n                         gv: ValueRef,\n                         mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n-    if let Some(min) = ccx.sess().target.target.options.min_global_align {\n+    if let Some(min) = cx.sess().target.target.options.min_global_align {\n         match ty::layout::Align::from_bits(min, min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n-                ccx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n+                cx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n             }\n         }\n     }\n@@ -62,30 +62,30 @@ fn set_global_alignment(ccx: &CodegenCx,\n     }\n }\n \n-pub fn addr_of_mut(ccx: &CodegenCx,\n+pub fn addr_of_mut(cx: &CodegenCx,\n                    cv: ValueRef,\n                    align: Align,\n                    kind: &str)\n                     -> ValueRef {\n     unsafe {\n-        let name = ccx.generate_local_symbol_name(kind);\n-        let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n+        let name = cx.generate_local_symbol_name(kind);\n+        let gv = declare::define_global(cx, &name[..], val_ty(cv)).unwrap_or_else(||{\n             bug!(\"symbol `{}` is already defined\", name);\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n-        set_global_alignment(ccx, gv, align);\n+        set_global_alignment(cx, gv, align);\n         llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n         SetUnnamedAddr(gv, true);\n         gv\n     }\n }\n \n-pub fn addr_of(ccx: &CodegenCx,\n+pub fn addr_of(cx: &CodegenCx,\n                cv: ValueRef,\n                align: Align,\n                kind: &str)\n                -> ValueRef {\n-    if let Some(&gv) = ccx.const_globals.borrow().get(&cv) {\n+    if let Some(&gv) = cx.const_globals.borrow().get(&cv) {\n         unsafe {\n             // Upgrade the alignment in cases where the same constant is used with different\n             // alignment requirements\n@@ -96,42 +96,42 @@ pub fn addr_of(ccx: &CodegenCx,\n         }\n         return gv;\n     }\n-    let gv = addr_of_mut(ccx, cv, align, kind);\n+    let gv = addr_of_mut(cx, cv, align, kind);\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gv, True);\n     }\n-    ccx.const_globals.borrow_mut().insert(cv, gv);\n+    cx.const_globals.borrow_mut().insert(cv, gv);\n     gv\n }\n \n-pub fn get_static(ccx: &CodegenCx, def_id: DefId) -> ValueRef {\n-    let instance = Instance::mono(ccx.tcx, def_id);\n-    if let Some(&g) = ccx.instances.borrow().get(&instance) {\n+pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n+    let instance = Instance::mono(cx.tcx, def_id);\n+    if let Some(&g) = cx.instances.borrow().get(&instance) {\n         return g;\n     }\n \n-    let ty = instance.ty(ccx.tcx);\n-    let g = if let Some(id) = ccx.tcx.hir.as_local_node_id(def_id) {\n+    let ty = instance.ty(cx.tcx);\n+    let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n \n-        let llty = ccx.layout_of(ty).llvm_type(ccx);\n-        let (g, attrs) = match ccx.tcx.hir.get(id) {\n+        let llty = cx.layout_of(ty).llvm_type(cx);\n+        let (g, attrs) = match cx.tcx.hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = MonoItem::Static(id).symbol_name(ccx.tcx);\n+                let sym = MonoItem::Static(id).symbol_name(cx.tcx);\n \n-                let defined_in_current_codegen_unit = ccx.codegen_unit\n+                let defined_in_current_codegen_unit = cx.codegen_unit\n                                                          .items()\n                                                          .contains_key(&MonoItem::Static(id));\n                 assert!(!defined_in_current_codegen_unit);\n \n-                if declare::get_declared_value(ccx, &sym[..]).is_some() {\n+                if declare::get_declared_value(cx, &sym[..]).is_some() {\n                     span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n \n-                let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n+                let g = declare::define_global(cx, &sym[..], llty).unwrap();\n \n-                if !ccx.tcx.is_exported_symbol(def_id) {\n+                if !cx.tcx.is_exported_symbol(def_id) {\n                     unsafe {\n                         llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                     }\n@@ -143,7 +143,7 @@ pub fn get_static(ccx: &CodegenCx, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = ccx.tcx.symbol_name(instance);\n+                let sym = cx.tcx.symbol_name(instance);\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -154,18 +154,18 @@ pub fn get_static(ccx: &CodegenCx, def_id: DefId) -> ValueRef {\n                     let linkage = match base::linkage_by_name(&name.as_str()) {\n                         Some(linkage) => linkage,\n                         None => {\n-                            ccx.sess().span_fatal(span, \"invalid linkage specified\");\n+                            cx.sess().span_fatal(span, \"invalid linkage specified\");\n                         }\n                     };\n                     let llty2 = match ty.sty {\n-                        ty::TyRawPtr(ref mt) => ccx.layout_of(mt.ty).llvm_type(ccx),\n+                        ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n                         _ => {\n-                            ccx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n+                            cx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n                         }\n                     };\n                     unsafe {\n                         // Declare a symbol `foo` with the desired linkage.\n-                        let g1 = declare::declare_global(ccx, &sym, llty2);\n+                        let g1 = declare::declare_global(cx, &sym, llty2);\n                         llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n                         // Declare an internal global `extern_with_linkage_foo` which\n@@ -176,8 +176,8 @@ pub fn get_static(ccx: &CodegenCx, def_id: DefId) -> ValueRef {\n                         // zero.\n                         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                         real_name.push_str(&sym);\n-                        let g2 = declare::define_global(ccx, &real_name, llty).unwrap_or_else(||{\n-                            ccx.sess().span_fatal(span,\n+                        let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n+                            cx.sess().span_fatal(span,\n                                 &format!(\"symbol `{}` is already defined\", &sym))\n                         });\n                         llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n@@ -186,7 +186,7 @@ pub fn get_static(ccx: &CodegenCx, def_id: DefId) -> ValueRef {\n                     }\n                 } else {\n                     // Generate an external declaration.\n-                    declare::declare_global(ccx, &sym, llty)\n+                    declare::declare_global(cx, &sym, llty)\n                 };\n \n                 (g, attrs)\n@@ -197,29 +197,29 @@ pub fn get_static(ccx: &CodegenCx, def_id: DefId) -> ValueRef {\n \n         for attr in attrs {\n             if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, ccx.tls_model);\n+                llvm::set_thread_local_mode(g, cx.tls_model);\n             }\n         }\n \n         g\n     } else {\n-        let sym = ccx.tcx.symbol_name(instance);\n+        let sym = cx.tcx.symbol_name(instance);\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let g = declare::declare_global(ccx, &sym, ccx.layout_of(ty).llvm_type(ccx));\n+        let g = declare::declare_global(cx, &sym, cx.layout_of(ty).llvm_type(cx));\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        for attr in ccx.tcx.get_attrs(def_id).iter() {\n+        for attr in cx.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, ccx.tls_model);\n+                llvm::set_thread_local_mode(g, cx.tls_model);\n             }\n         }\n-        if ccx.use_dll_storage_attrs && !ccx.tcx.is_foreign_item(def_id) {\n+        if cx.use_dll_storage_attrs && !cx.tcx.is_foreign_item(def_id) {\n             // This item is external but not foreign, i.e. it originates from an external Rust\n             // crate. Since we don't know whether this crate will be linked dynamically or\n             // statically in the final application, we always mark such symbols as 'dllimport'.\n@@ -232,42 +232,42 @@ pub fn get_static(ccx: &CodegenCx, def_id: DefId) -> ValueRef {\n         g\n     };\n \n-    if ccx.use_dll_storage_attrs && ccx.tcx.is_dllimport_foreign_item(def_id) {\n+    if cx.use_dll_storage_attrs && cx.tcx.is_dllimport_foreign_item(def_id) {\n         // For foreign (native) libs we know the exact storage type to use.\n         unsafe {\n             llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n         }\n     }\n \n-    ccx.instances.borrow_mut().insert(instance, g);\n-    ccx.statics.borrow_mut().insert(g, def_id);\n+    cx.instances.borrow_mut().insert(instance, g);\n+    cx.statics.borrow_mut().insert(g, def_id);\n     g\n }\n \n-pub fn trans_static<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                               m: hir::Mutability,\n                               id: ast::NodeId,\n                               attrs: &[ast::Attribute])\n                               -> Result<ValueRef, ConstEvalErr<'tcx>> {\n     unsafe {\n-        let def_id = ccx.tcx.hir.local_def_id(id);\n-        let g = get_static(ccx, def_id);\n+        let def_id = cx.tcx.hir.local_def_id(id);\n+        let g = get_static(cx, def_id);\n \n-        let v = ::mir::trans_static_initializer(ccx, def_id)?;\n+        let v = ::mir::trans_static_initializer(cx, def_id)?;\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let mut val_llty = val_ty(v);\n-        let v = if val_llty == Type::i1(ccx) {\n-            val_llty = Type::i8(ccx);\n+        let v = if val_llty == Type::i1(cx) {\n+            val_llty = Type::i8(cx);\n             llvm::LLVMConstZExt(v, val_llty.to_ref())\n         } else {\n             v\n         };\n \n-        let instance = Instance::mono(ccx.tcx, def_id);\n-        let ty = instance.ty(ccx.tcx);\n-        let llty = ccx.layout_of(ty).llvm_type(ccx);\n+        let instance = Instance::mono(cx.tcx, def_id);\n+        let ty = instance.ty(cx.tcx);\n+        let llty = cx.layout_of(ty).llvm_type(cx);\n         let g = if val_llty == llty {\n             g\n         } else {\n@@ -282,40 +282,40 @@ pub fn trans_static<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n             let visibility = llvm::LLVMRustGetVisibility(g);\n \n             let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                ccx.llmod, name_string.as_ptr(), val_llty.to_ref());\n+                cx.llmod, name_string.as_ptr(), val_llty.to_ref());\n \n             llvm::LLVMRustSetLinkage(new_g, linkage);\n             llvm::LLVMRustSetVisibility(new_g, visibility);\n \n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n             // with the new global later. (See base::trans_crate.)\n-            ccx.statics_to_rauw.borrow_mut().push((g, new_g));\n+            cx.statics_to_rauw.borrow_mut().push((g, new_g));\n             new_g\n         };\n-        set_global_alignment(ccx, g, ccx.align_of(ty));\n+        set_global_alignment(cx, g, cx.align_of(ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != hir::MutMutable {\n-            if ccx.type_is_freeze(ty) {\n+            if cx.type_is_freeze(ty) {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }\n \n-        debuginfo::create_global_var_metadata(ccx, id, g);\n+        debuginfo::create_global_var_metadata(cx, id, g);\n \n         if attr::contains_name(attrs, \"thread_local\") {\n-            llvm::set_thread_local_mode(g, ccx.tls_model);\n+            llvm::set_thread_local_mode(g, cx.tls_model);\n         }\n \n-        base::set_link_section(ccx, g, attrs);\n+        base::set_link_section(cx, g, attrs);\n \n         if attr::contains_name(attrs, \"used\") {\n             // This static will be stored in the llvm.used variable which is an array of i8*\n-            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(ccx).to_ref());\n-            ccx.used_statics.borrow_mut().push(cast);\n+            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n+            cx.used_statics.borrow_mut().push(cast);\n         }\n \n         Ok(g)"}, {"sha": "06b8d9ff7b306d1e8ae9eacfb1662baa72e90d08", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n                 None\n             };\n \n-            let mut ccx = CodegenCx {\n+            let mut cx = CodegenCx {\n                 tcx,\n                 check_overflow,\n                 use_dll_storage_attrs,\n@@ -308,8 +308,8 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n                 intrinsics: RefCell::new(FxHashMap()),\n                 local_gen_sym_counter: Cell::new(0),\n             };\n-            ccx.isize_ty = Type::isize(&ccx);\n-            ccx\n+            cx.isize_ty = Type::isize(&cx);\n+            cx\n         }\n     }\n \n@@ -474,47 +474,47 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CodegenCx<'a, 'tcx> {\n }\n \n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(ccx: &CodegenCx, key: &str) -> Option<ValueRef> {\n+fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name, Type::variadic_func(&[], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics.borrow_mut().insert($name, f.clone());\n+                cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n     }\n     macro_rules! mk_struct {\n-        ($($field_ty:expr),*) => (Type::struct_(ccx, &[$($field_ty),*], false))\n+        ($($field_ty:expr),*) => (Type::struct_(cx, &[$($field_ty),*], false))\n     }\n \n-    let i8p = Type::i8p(ccx);\n-    let void = Type::void(ccx);\n-    let i1 = Type::i1(ccx);\n-    let t_i8 = Type::i8(ccx);\n-    let t_i16 = Type::i16(ccx);\n-    let t_i32 = Type::i32(ccx);\n-    let t_i64 = Type::i64(ccx);\n-    let t_i128 = Type::i128(ccx);\n-    let t_f32 = Type::f32(ccx);\n-    let t_f64 = Type::f64(ccx);\n+    let i8p = Type::i8p(cx);\n+    let void = Type::void(cx);\n+    let i1 = Type::i1(cx);\n+    let t_i8 = Type::i8(cx);\n+    let t_i16 = Type::i16(cx);\n+    let t_i32 = Type::i32(cx);\n+    let t_i64 = Type::i64(cx);\n+    let t_i128 = Type::i128(cx);\n+    let t_f32 = Type::f32(cx);\n+    let t_f64 = Type::f64(cx);\n \n     ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n@@ -646,9 +646,9 @@ fn declare_intrinsic(ccx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.assume\", fn(i1) -> void);\n     ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n-    if ccx.sess().opts.debuginfo != NoDebugInfo {\n-        ifn!(\"llvm.dbg.declare\", fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n-        ifn!(\"llvm.dbg.value\", fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n+    if cx.sess().opts.debuginfo != NoDebugInfo {\n+        ifn!(\"llvm.dbg.declare\", fn(Type::metadata(cx), Type::metadata(cx)) -> void);\n+        ifn!(\"llvm.dbg.value\", fn(Type::metadata(cx), t_i64, Type::metadata(cx)) -> void);\n     }\n     return None;\n }"}, {"sha": "bddb3d909402e323905f3f944cd872df672f7f48", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -44,7 +44,7 @@ impl MirDebugScope {\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(ccx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebugContext)\n+pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebugContext)\n     -> IndexVec<VisibilityScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n@@ -71,13 +71,13 @@ pub fn create_mir_scopes(ccx: &CodegenCx, mir: &Mir, debug_context: &FunctionDeb\n     // Instantiate all scopes.\n     for idx in 0..mir.visibility_scopes.len() {\n         let scope = VisibilityScope::new(idx);\n-        make_mir_scope(ccx, &mir, &has_variables, debug_context, scope, &mut scopes);\n+        make_mir_scope(cx, &mir, &has_variables, debug_context, scope, &mut scopes);\n     }\n \n     scopes\n }\n \n-fn make_mir_scope(ccx: &CodegenCx,\n+fn make_mir_scope(cx: &CodegenCx,\n                   mir: &Mir,\n                   has_variables: &BitVector,\n                   debug_context: &FunctionDebugContextData,\n@@ -89,11 +89,11 @@ fn make_mir_scope(ccx: &CodegenCx,\n \n     let scope_data = &mir.visibility_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(ccx, mir, has_variables, debug_context, parent, scopes);\n+        make_mir_scope(cx, mir, has_variables, debug_context, parent, scopes);\n         scopes[parent]\n     } else {\n         // The root is the function itself.\n-        let loc = span_start(ccx, mir.span);\n+        let loc = span_start(cx, mir.span);\n         scopes[scope] = MirDebugScope {\n             scope_metadata: debug_context.fn_metadata,\n             file_start_pos: loc.file.start_pos,\n@@ -115,14 +115,14 @@ fn make_mir_scope(ccx: &CodegenCx,\n         }\n     }\n \n-    let loc = span_start(ccx, scope_data.span);\n-    let file_metadata = file_metadata(ccx,\n+    let loc = span_start(cx, scope_data.span);\n+    let file_metadata = file_metadata(cx,\n                                       &loc.file.name,\n                                       debug_context.defining_crate);\n \n     let scope_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlock(\n-            DIB(ccx),\n+            DIB(cx),\n             parent_scope.scope_metadata,\n             file_metadata,\n             loc.line as c_uint,"}, {"sha": "195d12aca54d81e399a4aace76853c764e5e9fb9", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -24,12 +24,12 @@ use syntax::attr;\n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n-pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CodegenCx, builder: &Builder) {\n-    if needs_gdb_debug_scripts_section(ccx) {\n-        let gdb_debug_scripts_section_global = get_or_insert_gdb_debug_scripts_section_global(ccx);\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(cx: &CodegenCx, builder: &Builder) {\n+    if needs_gdb_debug_scripts_section(cx) {\n+        let gdb_debug_scripts_section_global = get_or_insert_gdb_debug_scripts_section_global(cx);\n         // Load just the first byte as that's all that's necessary to force\n         // LLVM to keep around the reference to the global.\n-        let indices = [C_i32(ccx, 0), C_i32(ccx, 0)];\n+        let indices = [C_i32(cx, 0), C_i32(cx, 0)];\n         let element = builder.inbounds_gep(gdb_debug_scripts_section_global, &indices);\n         let volative_load_instruction = builder.volatile_load(element);\n         unsafe {\n@@ -40,13 +40,13 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CodegenCx, bui\n \n /// Allocates the global variable responsible for the .debug_gdb_scripts binary\n /// section.\n-pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CodegenCx)\n+pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n                                                   -> llvm::ValueRef {\n     let c_section_var_name = \"__rustc_debug_gdb_scripts_section__\\0\";\n     let section_var_name = &c_section_var_name[..c_section_var_name.len()-1];\n \n     let section_var = unsafe {\n-        llvm::LLVMGetNamedGlobal(ccx.llmod,\n+        llvm::LLVMGetNamedGlobal(cx.llmod,\n                                  c_section_var_name.as_ptr() as *const _)\n     };\n \n@@ -55,15 +55,15 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CodegenCx)\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = Type::array(&Type::i8(ccx),\n+            let llvm_type = Type::array(&Type::i8(cx),\n                                         section_contents.len() as u64);\n \n-            let section_var = declare::define_global(ccx, section_var_name,\n+            let section_var = declare::define_global(cx, section_var_name,\n                                                      llvm_type).unwrap_or_else(||{\n                 bug!(\"symbol `{}` is already defined\", section_var_name)\n             });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n-            llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n+            llvm::LLVMSetInitializer(section_var, C_bytes(cx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n             llvm::LLVMRustSetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n@@ -77,13 +77,13 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CodegenCx)\n     }\n }\n \n-pub fn needs_gdb_debug_scripts_section(ccx: &CodegenCx) -> bool {\n+pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&ccx.tcx.hir.krate_attrs(),\n+        attr::contains_name(&cx.tcx.hir.krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");\n \n     !omit_gdb_pretty_printer_section &&\n-    !ccx.sess().target.target.options.is_like_osx &&\n-    !ccx.sess().target.target.options.is_like_windows &&\n-    ccx.sess().opts.debuginfo != NoDebugInfo\n+    !cx.sess().target.target.options.is_like_osx &&\n+    !cx.sess().target.target.options.is_like_windows &&\n+    cx.sess().opts.debuginfo != NoDebugInfo\n }"}, {"sha": "62ba91840d95e4c4281fd36566742acc881725b6", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -1210,7 +1210,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // of discriminant instead of us having to recover its path.\n                 // Right now it's not even going to work for `niche_start > 0`,\n                 // and for multiple niche variants it only supports the first.\n-                fn compute_field_path<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+                fn compute_field_path<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                                 name: &mut String,\n                                                 layout: TyLayout<'tcx>,\n                                                 offset: Size,\n@@ -1221,10 +1221,10 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             continue;\n                         }\n                         let inner_offset = offset - field_offset;\n-                        let field = layout.field(ccx, i);\n+                        let field = layout.field(cx, i);\n                         if inner_offset + size <= field.size {\n                             write!(name, \"{}$\", i).unwrap();\n-                            compute_field_path(ccx, name, field, inner_offset, size);\n+                            compute_field_path(cx, name, field, inner_offset, size);\n                         }\n                     }\n                 }\n@@ -1689,15 +1689,15 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n }\n \n // Creates an \"extension\" of an existing DIScope into another file.\n-pub fn extend_scope_to_file(ccx: &CodegenCx,\n+pub fn extend_scope_to_file(cx: &CodegenCx,\n                             scope_metadata: DIScope,\n                             file: &syntax_pos::FileMap,\n                             defining_crate: CrateNum)\n                             -> DILexicalBlock {\n-    let file_metadata = file_metadata(ccx, &file.name, defining_crate);\n+    let file_metadata = file_metadata(cx, &file.name, defining_crate);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n-            DIB(ccx),\n+            DIB(cx),\n             scope_metadata,\n             file_metadata)\n     }"}, {"sha": "788dd42d875187de42b29452412eb5c1c0e79517", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -417,7 +417,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         names\n     }\n \n-    fn get_containing_scope<'ccx, 'tcx>(cx: &CodegenCx<'ccx, 'tcx>,\n+    fn get_containing_scope<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n                                         instance: Instance<'tcx>)\n                                         -> DIScope {\n         // First, let's see if this is a method within an inherent impl. Because\n@@ -463,7 +463,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                variable_access: VariableAccess,\n                                variable_kind: VariableKind,\n                                span: Span) {\n-    let cx = bcx.ccx;\n+    let cx = bcx.cx;\n \n     let file = span_start(cx, span).file;\n     let file_metadata = file_metadata(cx,"}, {"sha": "46067a4330396e384b9d25871ef2270f7d459ad0", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -26,52 +26,52 @@ use std::ffi::CString;\n use std::ptr;\n \n pub fn mangled_name_of_instance<'a, 'tcx>(\n-    ccx: &CodegenCx<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     instance: Instance<'tcx>,\n ) -> ty::SymbolName {\n-     let tcx = ccx.tcx;\n+     let tcx = cx.tcx;\n      tcx.symbol_name(instance)\n }\n \n pub fn mangled_name_of_item<'a, 'tcx>(\n-    ccx: &CodegenCx<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     node_id: ast::NodeId,\n ) -> ty::SymbolName {\n-    let tcx = ccx.tcx;\n+    let tcx = cx.tcx;\n     let node_def_id = tcx.hir.local_def_id(node_id);\n     let instance = Instance::mono(tcx, node_def_id);\n     tcx.symbol_name(instance)\n }\n \n-pub fn item_namespace(ccx: &CodegenCx, def_id: DefId) -> DIScope {\n-    if let Some(&scope) = debug_context(ccx).namespace_map.borrow().get(&def_id) {\n+pub fn item_namespace(cx: &CodegenCx, def_id: DefId) -> DIScope {\n+    if let Some(&scope) = debug_context(cx).namespace_map.borrow().get(&def_id) {\n         return scope;\n     }\n \n-    let def_key = ccx.tcx.def_key(def_id);\n+    let def_key = cx.tcx.def_key(def_id);\n     let parent_scope = def_key.parent.map_or(ptr::null_mut(), |parent| {\n-        item_namespace(ccx, DefId {\n+        item_namespace(cx, DefId {\n             krate: def_id.krate,\n             index: parent\n         })\n     });\n \n     let namespace_name = match def_key.disambiguated_data.data {\n-        DefPathData::CrateRoot => ccx.tcx.crate_name(def_id.krate).as_str(),\n+        DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate).as_str(),\n         data => data.as_interned_str()\n     };\n \n     let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n \n     let scope = unsafe {\n         llvm::LLVMRustDIBuilderCreateNameSpace(\n-            DIB(ccx),\n+            DIB(cx),\n             parent_scope,\n             namespace_name.as_ptr(),\n-            unknown_file_metadata(ccx),\n+            unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER)\n     };\n \n-    debug_context(ccx).namespace_map.borrow_mut().insert(def_id, scope);\n+    debug_context(cx).namespace_map.borrow_mut().insert(def_id, scope);\n     scope\n }"}, {"sha": "fc2deeeb031df7ecf2f399c44a9ff91a9940102e", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -39,7 +39,7 @@ pub fn set_source_location(\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n         debug!(\"set_source_location: {}\", builder.sess().codemap().span_to_string(span));\n-        let loc = span_start(builder.ccx, span);\n+        let loc = span_start(builder.cx, span);\n         InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n@@ -88,7 +88,7 @@ pub fn set_debug_location(builder: &Builder, debug_location: InternalDebugLocati\n \n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                    debug_context(builder.ccx).llcontext,\n+                    debug_context(builder.cx).llcontext,\n                     line as c_uint,\n                     col as c_uint,\n                     scope,"}, {"sha": "aa1cd0c27e795977287702ed50890a6ccff4122c", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -39,13 +39,13 @@ use std::ffi::CString;\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// return its ValueRef instead.\n-pub fn declare_global(ccx: &CodegenCx, name: &str, ty: Type) -> llvm::ValueRef {\n+pub fn declare_global(cx: &CodegenCx, name: &str, ty: Type) -> llvm::ValueRef {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     unsafe {\n-        llvm::LLVMRustGetOrInsertGlobal(ccx.llmod, namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty.to_ref())\n     }\n }\n \n@@ -54,26 +54,26 @@ pub fn declare_global(ccx: &CodegenCx, name: &str, ty: Type) -> llvm::ValueRef {\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-fn declare_raw_fn(ccx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n+fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let llfn = unsafe {\n-        llvm::LLVMRustGetOrInsertFunction(ccx.llmod, namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertFunction(cx.llmod, namebuf.as_ptr(), ty.to_ref())\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n     // Function addresses in Rust are never significant, allowing functions to\n     // be merged.\n     llvm::SetUnnamedAddr(llfn, true);\n \n-    if ccx.tcx.sess.opts.cg.no_redzone\n-        .unwrap_or(ccx.tcx.sess.target.target.options.disable_redzone) {\n+    if cx.tcx.sess.opts.cg.no_redzone\n+        .unwrap_or(cx.tcx.sess.target.target.options.disable_redzone) {\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n \n-    if let Some(ref sanitizer) = ccx.tcx.sess.opts.debugging_opts.sanitizer {\n+    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {\n         match *sanitizer {\n             Sanitizer::Address => {\n                 llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n@@ -88,7 +88,7 @@ fn declare_raw_fn(ccx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Typ\n         }\n     }\n \n-    match ccx.tcx.sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n+    match cx.tcx.sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n         Some(\"s\") => {\n             llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n         },\n@@ -99,7 +99,7 @@ fn declare_raw_fn(ccx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Typ\n         _ => {},\n     }\n \n-    if ccx.tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n+    if cx.tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n         attributes::unwind(llfn, false);\n     }\n \n@@ -114,24 +114,24 @@ fn declare_raw_fn(ccx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Typ\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_cfn(ccx: &CodegenCx, name: &str, fn_type: Type) -> ValueRef {\n-    declare_raw_fn(ccx, name, llvm::CCallConv, fn_type)\n+pub fn declare_cfn(cx: &CodegenCx, name: &str, fn_type: Type) -> ValueRef {\n+    declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n }\n \n \n /// Declare a Rust function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, name: &str,\n+pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n                             fn_type: Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n-    let sig = common::ty_fn_sig(ccx, fn_type);\n-    let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let sig = common::ty_fn_sig(cx, fn_type);\n+    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-    let fty = FnType::new(ccx, sig, &[]);\n-    let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n+    let fty = FnType::new(cx, sig, &[]);\n+    let llfn = declare_raw_fn(cx, name, fty.cconv, fty.llvm_type(cx));\n \n     // FIXME(canndrew): This is_never should really be an is_uninhabited\n     if sig.output().is_never() {\n@@ -154,11 +154,11 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, name: &str,\n /// return None if the name already has a definition associated with it. In that\n /// case an error should be reported to the user, because it usually happens due\n /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_global(ccx: &CodegenCx, name: &str, ty: Type) -> Option<ValueRef> {\n-    if get_defined_value(ccx, name).is_some() {\n+pub fn define_global(cx: &CodegenCx, name: &str, ty: Type) -> Option<ValueRef> {\n+    if get_defined_value(cx, name).is_some() {\n         None\n     } else {\n-        Some(declare_global(ccx, name, ty))\n+        Some(declare_global(cx, name, ty))\n     }\n }\n \n@@ -167,13 +167,13 @@ pub fn define_global(ccx: &CodegenCx, name: &str, ty: Type) -> Option<ValueRef>\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn define_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                            name: &str,\n                            fn_type: Ty<'tcx>) -> ValueRef {\n-    if get_defined_value(ccx, name).is_some() {\n-        ccx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n+    if get_defined_value(cx, name).is_some() {\n+        cx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n-        declare_fn(ccx, name, fn_type)\n+        declare_fn(cx, name, fn_type)\n     }\n }\n \n@@ -182,22 +182,22 @@ pub fn define_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn define_internal_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     name: &str,\n                                     fn_type: Ty<'tcx>) -> ValueRef {\n-    let llfn = define_fn(ccx, name, fn_type);\n+    let llfn = define_fn(cx, name, fn_type);\n     unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n     llfn\n }\n \n \n /// Get declared value by name.\n-pub fn get_declared_value(ccx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+pub fn get_declared_value(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n     debug!(\"get_declared_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n-    let val = unsafe { llvm::LLVMRustGetNamedValue(ccx.llmod, namebuf.as_ptr()) };\n+    let val = unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) };\n     if val.is_null() {\n         debug!(\"get_declared_value: {:?} value is null\", name);\n         None\n@@ -209,8 +209,8 @@ pub fn get_declared_value(ccx: &CodegenCx, name: &str) -> Option<ValueRef> {\n \n /// Get defined or externally defined (AvailableExternally linkage) value by\n /// name.\n-pub fn get_defined_value(ccx: &CodegenCx, name: &str) -> Option<ValueRef> {\n-    get_declared_value(ccx, name).and_then(|val|{\n+pub fn get_defined_value(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+    get_declared_value(cx, name).and_then(|val|{\n         let declaration = unsafe {\n             llvm::LLVMIsDeclaration(val) != 0\n         };"}, {"sha": "b93b68d79e5d1231857f37b619e44f9a54158904", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -27,12 +27,12 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n-    if bcx.ccx.type_is_sized(t) {\n-        let (size, align) = bcx.ccx.size_and_align_of(t);\n+    if bcx.cx.type_is_sized(t) {\n+        let (size, align) = bcx.cx.size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, Value(info), size, align);\n-        let size = C_usize(bcx.ccx, size.bytes());\n-        let align = C_usize(bcx.ccx, align.abi());\n+        let size = C_usize(bcx.cx, size.bytes());\n+        let align = C_usize(bcx.cx, align.abi());\n         return (size, align);\n     }\n     assert!(!info.is_null());\n@@ -45,30 +45,30 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let unit = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let (size, align) = bcx.ccx.size_and_align_of(unit);\n-            (bcx.mul(info, C_usize(bcx.ccx, size.bytes())),\n-             C_usize(bcx.ccx, align.abi()))\n+            let (size, align) = bcx.cx.size_and_align_of(unit);\n+            (bcx.mul(info, C_usize(bcx.cx, size.bytes())),\n+             C_usize(bcx.cx, align.abi()))\n         }\n         _ => {\n-            let ccx = bcx.ccx;\n+            let cx = bcx.cx;\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n             // want to avoid, as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n-            let layout = ccx.layout_of(t);\n+            let layout = cx.layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n             let i = layout.fields.count() - 1;\n             let sized_size = layout.fields.offset(i).bytes();\n             let sized_align = layout.align.abi();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n-            let sized_size = C_usize(ccx, sized_size);\n-            let sized_align = C_usize(ccx, sized_align);\n+            let sized_size = C_usize(cx, sized_size);\n+            let sized_align = C_usize(cx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let field_ty = layout.field(ccx, i).ty;\n+            let field_ty = layout.field(cx, i).ty;\n             let (unsized_size, mut unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n@@ -95,7 +95,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_usize(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n+                    C_usize(cx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n                                 sized_align,\n@@ -113,7 +113,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bcx.sub(align, C_usize(bcx.ccx, 1));\n+            let addend = bcx.sub(align, C_usize(bcx.cx, 1));\n             let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n \n             (size, align)"}, {"sha": "0b518b0d728f6e2ead35b796e71c05c50cc67e0d", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -35,7 +35,7 @@ use syntax_pos::Span;\n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(ccx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+fn get_simple_intrinsic(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n     let llvm_name = match name {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n@@ -79,7 +79,7 @@ fn get_simple_intrinsic(ccx: &CodegenCx, name: &str) -> Option<ValueRef> {\n         \"abort\" => \"llvm.trap\",\n         _ => return None\n     };\n-    Some(ccx.get_intrinsic(&llvm_name))\n+    Some(cx.get_intrinsic(&llvm_name))\n }\n \n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n@@ -91,8 +91,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                       args: &[OperandRef<'tcx>],\n                                       llresult: ValueRef,\n                                       span: Span) {\n-    let ccx = bcx.ccx;\n-    let tcx = ccx.tcx;\n+    let cx = bcx.cx;\n+    let tcx = cx.tcx;\n \n     let (def_id, substs) = match callee_ty.sty {\n         ty::TyFnDef(def_id, substs) => (def_id, substs),\n@@ -105,10 +105,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ret_ty = sig.output();\n     let name = &*tcx.item_name(def_id);\n \n-    let llret_ty = ccx.layout_of(ret_ty).llvm_type(ccx);\n+    let llret_ty = cx.layout_of(ret_ty).llvm_type(cx);\n     let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align);\n \n-    let simple = get_simple_intrinsic(ccx, name);\n+    let simple = get_simple_intrinsic(cx, name);\n     let llval = match name {\n         _ if simple.is_some() => {\n             bcx.call(simple.unwrap(),\n@@ -119,28 +119,28 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             return;\n         },\n         \"likely\" => {\n-            let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[args[0].immediate(), C_bool(ccx, true)], None)\n+            let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n+            bcx.call(expect, &[args[0].immediate(), C_bool(cx, true)], None)\n         }\n         \"unlikely\" => {\n-            let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[args[0].immediate(), C_bool(ccx, false)], None)\n+            let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n+            bcx.call(expect, &[args[0].immediate(), C_bool(cx, false)], None)\n         }\n         \"try\" => {\n-            try_intrinsic(bcx, ccx,\n+            try_intrinsic(bcx, cx,\n                           args[0].immediate(),\n                           args[1].immediate(),\n                           args[2].immediate(),\n                           llresult);\n             return;\n         }\n         \"breakpoint\" => {\n-            let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n+            let llfn = cx.get_intrinsic(&(\"llvm.debugtrap\"));\n             bcx.call(llfn, &[], None)\n         }\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(ccx, ccx.size_of(tp_ty).bytes())\n+            C_usize(cx, cx.size_of(tp_ty).bytes())\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -149,12 +149,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     glue::size_and_align_of_dst(bcx, tp_ty, meta);\n                 llsize\n             } else {\n-                C_usize(ccx, ccx.size_of(tp_ty).bytes())\n+                C_usize(cx, cx.size_of(tp_ty).bytes())\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(ccx, ccx.align_of(tp_ty).abi())\n+            C_usize(cx, cx.align_of(tp_ty).abi())\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -163,29 +163,29 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     glue::size_and_align_of_dst(bcx, tp_ty, meta);\n                 llalign\n             } else {\n-                C_usize(ccx, ccx.align_of(tp_ty).abi())\n+                C_usize(cx, cx.align_of(tp_ty).abi())\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(ccx, ccx.align_of(tp_ty).pref())\n+            C_usize(cx, cx.align_of(tp_ty).pref())\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n             let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n-            C_str_slice(ccx, ty_name)\n+            C_str_slice(cx, ty_name)\n         }\n         \"type_id\" => {\n-            C_u64(ccx, ccx.tcx.type_id_hash(substs.type_at(0)))\n+            C_u64(cx, cx.tcx.type_id_hash(substs.type_at(0)))\n         }\n         \"init\" => {\n             let ty = substs.type_at(0);\n-            if !ccx.layout_of(ty).is_zst() {\n+            if !cx.layout_of(ty).is_zst() {\n                 // Just zero out the stack slot.\n                 // If we store a zero constant, LLVM will drown in vreg allocation for large data\n                 // structures, and the generated code will be awful. (A telltale sign of this is\n                 // large quantities of `mov [byte ptr foo],0` in the generated code.)\n-                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_usize(ccx, 1));\n+                memset_intrinsic(bcx, false, ty, llresult, C_u8(cx, 0), C_usize(cx, 1));\n             }\n             return;\n         }\n@@ -196,7 +196,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            C_bool(ccx, bcx.ccx.type_needs_drop(tp_ty))\n+            C_bool(cx, bcx.cx.type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = args[0].immediate();\n@@ -238,17 +238,17 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             let mut ptr = args[0].immediate();\n             if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-                ptr = bcx.pointercast(ptr, ty.llvm_type(ccx).ptr_to());\n+                ptr = bcx.pointercast(ptr, ty.llvm_type(cx).ptr_to());\n             }\n             let load = bcx.volatile_load(ptr);\n             unsafe {\n-                llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty).abi() as u32);\n+                llvm::LLVMSetAlignment(load, cx.align_of(tp_ty).abi() as u32);\n             }\n-            to_immediate(bcx, load, ccx.layout_of(tp_ty))\n+            to_immediate(bcx, load, cx.layout_of(tp_ty))\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n-            let dst = args[0].deref(bcx.ccx);\n+            let dst = args[0].deref(bcx.cx);\n             if let OperandValue::Pair(a, b) = args[1].val {\n                 bcx.volatile_store(a, dst.project_field(bcx, 0).llval);\n                 bcx.volatile_store(b, dst.project_field(bcx, 1).llval);\n@@ -264,14 +264,14 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let ptr = bcx.pointercast(dst.llval, val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);\n                 unsafe {\n-                    llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty).abi() as u32);\n+                    llvm::LLVMSetAlignment(store, cx.align_of(tp_ty).abi() as u32);\n                 }\n             }\n             return;\n         },\n         \"prefetch_read_data\" | \"prefetch_write_data\" |\n         \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n-            let expect = ccx.get_intrinsic(&(\"llvm.prefetch\"));\n+            let expect = cx.get_intrinsic(&(\"llvm.prefetch\"));\n             let (rw, cache_type) = match name {\n                 \"prefetch_read_data\" => (0, 1),\n                 \"prefetch_write_data\" => (1, 1),\n@@ -281,53 +281,53 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             };\n             bcx.call(expect, &[\n                 args[0].immediate(),\n-                C_i32(ccx, rw),\n+                C_i32(cx, rw),\n                 args[1].immediate(),\n-                C_i32(ccx, cache_type)\n+                C_i32(cx, cache_type)\n             ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n         \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n             let ty = arg_tys[0];\n-            match int_type_width_signed(ty, ccx) {\n+            match int_type_width_signed(ty, cx) {\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n-                            let y = C_bool(bcx.ccx, false);\n-                            let llfn = ccx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n+                            let y = C_bool(bcx.cx, false);\n+                            let llfn = cx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n                             bcx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n-                            let y = C_bool(bcx.ccx, true);\n+                            let y = C_bool(bcx.cx, true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n-                            let llfn = ccx.get_intrinsic(llvm_name);\n+                            let llfn = cx.get_intrinsic(llvm_name);\n                             bcx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n-                        \"ctpop\" => bcx.call(ccx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n+                        \"ctpop\" => bcx.call(cx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n                                         &[args[0].immediate()], None),\n                         \"bswap\" => {\n                             if width == 8 {\n                                 args[0].immediate() // byte swap a u8/i8 is just a no-op\n                             } else {\n-                                bcx.call(ccx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n+                                bcx.call(cx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n                                         &[args[0].immediate()], None)\n                             }\n                         }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n                             let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n                                                     if signed { 's' } else { 'u' },\n                                                     &name[..3], width);\n-                            let llfn = bcx.ccx.get_intrinsic(&intrinsic);\n+                            let llfn = bcx.cx.get_intrinsic(&intrinsic);\n \n                             // Convert `i1` to a `bool`, and write it to the out parameter\n                             let pair = bcx.call(llfn, &[\n                                 args[0].immediate(),\n                                 args[1].immediate()\n                             ], None);\n                             let val = bcx.extract_value(pair, 0);\n-                            let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(ccx));\n+                            let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(cx));\n \n                             let dest = result.project_field(bcx, 0);\n                             bcx.store(val, dest.llval, dest.align);\n@@ -394,16 +394,16 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         },\n \n         \"discriminant_value\" => {\n-            args[0].deref(bcx.ccx).trans_get_discr(bcx, ret_ty)\n+            args[0].deref(bcx.cx).trans_get_discr(bcx, ret_ty)\n         }\n \n         \"align_offset\" => {\n             // `ptr as usize`\n-            let ptr_val = bcx.ptrtoint(args[0].immediate(), bcx.ccx.isize_ty);\n+            let ptr_val = bcx.ptrtoint(args[0].immediate(), bcx.cx.isize_ty);\n             // `ptr_val % align`\n             let align = args[1].immediate();\n             let offset = bcx.urem(ptr_val, align);\n-            let zero = C_null(bcx.ccx.isize_ty);\n+            let zero = C_null(bcx.cx.isize_ty);\n             // `offset == 0`\n             let is_zero = bcx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n             // `if offset == 0 { 0 } else { align - offset }`\n@@ -439,16 +439,16 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         (SequentiallyConsistent, Monotonic),\n                     \"failacq\" if is_cxchg =>\n                         (SequentiallyConsistent, Acquire),\n-                    _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n+                    _ => cx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 },\n                 4 => match (split[2], split[3]) {\n                     (\"acq\", \"failrelaxed\") if is_cxchg =>\n                         (Acquire, Monotonic),\n                     (\"acqrel\", \"failrelaxed\") if is_cxchg =>\n                         (AcquireRelease, Monotonic),\n-                    _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n+                    _ => cx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 },\n-                _ => ccx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n+                _ => cx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n             };\n \n             let invalid_monomorphization = |ty| {\n@@ -460,7 +460,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n                     let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, ccx).is_some() {\n+                    if int_type_width_signed(ty, cx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n                         let pair = bcx.atomic_cmpxchg(\n                             args[0].immediate(),\n@@ -470,7 +470,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             failorder,\n                             weak);\n                         let val = bcx.extract_value(pair, 0);\n-                        let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.ccx));\n+                        let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.cx));\n \n                         let dest = result.project_field(bcx, 0);\n                         bcx.store(val, dest.llval, dest.align);\n@@ -484,8 +484,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n                 \"load\" => {\n                     let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, ccx).is_some() {\n-                        let align = ccx.align_of(ty);\n+                    if int_type_width_signed(ty, cx).is_some() {\n+                        let align = cx.align_of(ty);\n                         bcx.atomic_load(args[0].immediate(), order, align)\n                     } else {\n                         return invalid_monomorphization(ty);\n@@ -494,8 +494,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n                 \"store\" => {\n                     let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, ccx).is_some() {\n-                        let align = ccx.align_of(ty);\n+                    if int_type_width_signed(ty, cx).is_some() {\n+                        let align = cx.align_of(ty);\n                         bcx.atomic_store(args[1].immediate(), args[0].immediate(), order, align);\n                         return;\n                     } else {\n@@ -527,11 +527,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         \"min\"   => llvm::AtomicMin,\n                         \"umax\"  => llvm::AtomicUMax,\n                         \"umin\"  => llvm::AtomicUMin,\n-                        _ => ccx.sess().fatal(\"unknown atomic operation\")\n+                        _ => cx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n                     let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, ccx).is_some() {\n+                    if int_type_width_signed(ty, cx).is_some() {\n                         bcx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n                     } else {\n                         return invalid_monomorphization(ty);\n@@ -542,7 +542,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"nontemporal_store\" => {\n             let tp_ty = substs.type_at(0);\n-            let dst = args[0].deref(bcx.ccx);\n+            let dst = args[0].deref(bcx.cx);\n             let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n                 bcx.load(ptr, align)\n             } else {\n@@ -551,7 +551,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let ptr = bcx.pointercast(dst.llval, val_ty(val).ptr_to());\n             let store = bcx.nontemporal_store(val, ptr);\n             unsafe {\n-                llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty).abi() as u32);\n+                llvm::LLVMSetAlignment(store, cx.align_of(tp_ty).abi() as u32);\n             }\n             return\n         }\n@@ -565,39 +565,39 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n             }\n-            fn ty_to_type(ccx: &CodegenCx, t: &intrinsics::Type) -> Vec<Type> {\n+            fn ty_to_type(cx: &CodegenCx, t: &intrinsics::Type) -> Vec<Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n-                    Void => vec![Type::void(ccx)],\n+                    Void => vec![Type::void(cx)],\n                     Integer(_signed, _width, llvm_width) => {\n-                        vec![Type::ix(ccx, llvm_width as u64)]\n+                        vec![Type::ix(cx, llvm_width as u64)]\n                     }\n                     Float(x) => {\n                         match x {\n-                            32 => vec![Type::f32(ccx)],\n-                            64 => vec![Type::f64(ccx)],\n+                            32 => vec![Type::f32(cx)],\n+                            64 => vec![Type::f64(cx)],\n                             _ => bug!()\n                         }\n                     }\n                     Pointer(ref t, ref llvm_elem, _const) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t));\n+                        let elem = one(ty_to_type(cx, t));\n                         vec![elem.ptr_to()]\n                     }\n                     Vector(ref t, ref llvm_elem, length) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t));\n+                        let elem = one(ty_to_type(cx, t));\n                         vec![Type::vector(&elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n-                                            .map(|t| one(ty_to_type(ccx, t)))\n+                                            .map(|t| one(ty_to_type(cx, t)))\n                                             .collect::<Vec<_>>();\n-                        vec![Type::struct_(ccx, &elems, false)]\n+                        vec![Type::struct_(cx, &elems, false)]\n                     }\n                     Aggregate(true, ref contents) => {\n                         contents.iter()\n-                                .flat_map(|t| ty_to_type(ccx, t))\n+                                .flat_map(|t| ty_to_type(cx, t))\n                                 .collect()\n                     }\n                 }\n@@ -620,7 +620,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bcx.ccx.type_needs_drop(arg.layout.ty));\n+                        assert!(!bcx.cx.type_needs_drop(arg.layout.ty));\n                         let (ptr, align) = match arg.val {\n                             OperandValue::Ref(ptr, align) => (ptr, align),\n                             _ => bug!()\n@@ -631,29 +631,29 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         }).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem));\n+                        let llvm_elem = one(ty_to_type(bcx.cx, llvm_elem));\n                         vec![bcx.pointercast(arg.immediate(), llvm_elem.ptr_to())]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem));\n+                        let llvm_elem = one(ty_to_type(bcx.cx, llvm_elem));\n                         vec![bcx.bitcast(arg.immediate(), Type::vector(&llvm_elem, length as u64))]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so\n                         // we have to trim it down here.\n-                        vec![bcx.trunc(arg.immediate(), Type::ix(bcx.ccx, llvm_width as u64))]\n+                        vec![bcx.trunc(arg.immediate(), Type::ix(bcx.cx, llvm_width as u64))]\n                     }\n                     _ => vec![arg.immediate()],\n                 }\n             }\n \n \n             let inputs = intr.inputs.iter()\n-                                    .flat_map(|t| ty_to_type(ccx, t))\n+                                    .flat_map(|t| ty_to_type(cx, t))\n                                     .collect::<Vec<_>>();\n \n-            let outputs = one(ty_to_type(ccx, &intr.output));\n+            let outputs = one(ty_to_type(cx, &intr.output));\n \n             let llargs: Vec<_> = intr.inputs.iter().zip(args).flat_map(|(t, arg)| {\n                 modify_as_needed(bcx, t, arg)\n@@ -662,7 +662,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n             let val = match intr.definition {\n                 intrinsics::IntrinsicDef::Named(name) => {\n-                    let f = declare::declare_cfn(ccx,\n+                    let f = declare::declare_cfn(cx,\n                                                  name,\n                                                  Type::func(&inputs, &outputs));\n                     bcx.call(f, &llargs, None)\n@@ -688,7 +688,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n     if !fn_ty.ret.is_ignore() {\n         if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-            let ptr = bcx.pointercast(result.llval, ty.llvm_type(ccx).ptr_to());\n+            let ptr = bcx.pointercast(result.llval, ty.llvm_type(cx).ptr_to());\n             bcx.store(llval, ptr, result.align);\n         } else {\n             OperandRef::from_immediate_or_packed_pair(bcx, llval, result.layout)\n@@ -705,10 +705,10 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             src: ValueRef,\n                             count: ValueRef)\n                             -> ValueRef {\n-    let ccx = bcx.ccx;\n-    let (size, align) = ccx.size_and_align_of(ty);\n-    let size = C_usize(ccx, size.bytes());\n-    let align = C_i32(ccx, align.abi() as i32);\n+    let cx = bcx.cx;\n+    let (size, align) = cx.size_and_align_of(ty);\n+    let size = C_usize(cx, size.bytes());\n+    let align = C_i32(cx, align.abi() as i32);\n \n     let operation = if allow_overlap {\n         \"memmove\"\n@@ -717,18 +717,18 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     };\n \n     let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation,\n-                       ccx.data_layout().pointer_size.bits());\n+                       cx.data_layout().pointer_size.bits());\n \n-    let dst_ptr = bcx.pointercast(dst, Type::i8p(ccx));\n-    let src_ptr = bcx.pointercast(src, Type::i8p(ccx));\n-    let llfn = ccx.get_intrinsic(&name);\n+    let dst_ptr = bcx.pointercast(dst, Type::i8p(cx));\n+    let src_ptr = bcx.pointercast(src, Type::i8p(cx));\n+    let llfn = cx.get_intrinsic(&name);\n \n     bcx.call(llfn,\n         &[dst_ptr,\n         src_ptr,\n         bcx.mul(size, count),\n         align,\n-        C_bool(ccx, volatile)],\n+        C_bool(cx, volatile)],\n         None)\n }\n \n@@ -740,17 +740,17 @@ fn memset_intrinsic<'a, 'tcx>(\n     val: ValueRef,\n     count: ValueRef\n ) -> ValueRef {\n-    let ccx = bcx.ccx;\n-    let (size, align) = ccx.size_and_align_of(ty);\n-    let size = C_usize(ccx, size.bytes());\n-    let align = C_i32(ccx, align.abi() as i32);\n-    let dst = bcx.pointercast(dst, Type::i8p(ccx));\n+    let cx = bcx.cx;\n+    let (size, align) = cx.size_and_align_of(ty);\n+    let size = C_usize(cx, size.bytes());\n+    let align = C_i32(cx, align.abi() as i32);\n+    let dst = bcx.pointercast(dst, Type::i8p(cx));\n     call_memset(bcx, dst, val, bcx.mul(size, count), align, volatile)\n }\n \n fn try_intrinsic<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n-    ccx: &CodegenCx,\n+    cx: &CodegenCx,\n     func: ValueRef,\n     data: ValueRef,\n     local_ptr: ValueRef,\n@@ -759,11 +759,11 @@ fn try_intrinsic<'a, 'tcx>(\n     if bcx.sess().no_landing_pads() {\n         bcx.call(func, &[data], None);\n         let ptr_align = bcx.tcx().data_layout.pointer_align;\n-        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, ptr_align);\n+        bcx.store(C_null(Type::i8p(&bcx.cx)), dest, ptr_align);\n     } else if wants_msvc_seh(bcx.sess()) {\n-        trans_msvc_try(bcx, ccx, func, data, local_ptr, dest);\n+        trans_msvc_try(bcx, cx, func, data, local_ptr, dest);\n     } else {\n-        trans_gnu_try(bcx, ccx, func, data, local_ptr, dest);\n+        trans_gnu_try(bcx, cx, func, data, local_ptr, dest);\n     }\n }\n \n@@ -775,15 +775,15 @@ fn try_intrinsic<'a, 'tcx>(\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                            ccx: &CodegenCx,\n+                            cx: &CodegenCx,\n                             func: ValueRef,\n                             data: ValueRef,\n                             local_ptr: ValueRef,\n                             dest: ValueRef) {\n-    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n-        let ccx = bcx.ccx;\n+    let llfn = get_rust_try_fn(cx, &mut |bcx| {\n+        let cx = bcx.cx;\n \n-        bcx.set_personality_fn(bcx.ccx.eh_personality());\n+        bcx.set_personality_fn(bcx.cx.eh_personality());\n \n         let normal = bcx.build_sibling_block(\"normal\");\n         let catchswitch = bcx.build_sibling_block(\"catchswitch\");\n@@ -833,35 +833,35 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64p = Type::i64(ccx).ptr_to();\n+        let i64p = Type::i64(cx).ptr_to();\n         let ptr_align = bcx.tcx().data_layout.pointer_align;\n         let slot = bcx.alloca(i64p, \"slot\", ptr_align);\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n \n-        normal.ret(C_i32(ccx, 0));\n+        normal.ret(C_i32(cx, 0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n-        let tcx = ccx.tcx;\n+        let tcx = cx.tcx;\n         let tydesc = match tcx.lang_items().msvc_try_filter() {\n-            Some(did) => ::consts::get_static(ccx, did),\n+            Some(did) => ::consts::get_static(cx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n-        let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(ccx, 0), slot]);\n+        let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(cx, 0), slot]);\n         let addr = catchpad.load(slot, ptr_align);\n \n         let i64_align = bcx.tcx().data_layout.i64_align;\n         let arg1 = catchpad.load(addr, i64_align);\n-        let val1 = C_i32(ccx, 1);\n+        let val1 = C_i32(cx, 1);\n         let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n         catchpad.store(arg1, local_ptr, i64_align);\n         catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), i64_align);\n         catchpad.catch_ret(tok, caught.llbb());\n \n-        caught.ret(C_i32(ccx, 1));\n+        caught.ret(C_i32(cx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -883,13 +883,13 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                           ccx: &CodegenCx,\n+                           cx: &CodegenCx,\n                            func: ValueRef,\n                            data: ValueRef,\n                            local_ptr: ValueRef,\n                            dest: ValueRef) {\n-    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n-        let ccx = bcx.ccx;\n+    let llfn = get_rust_try_fn(cx, &mut |bcx| {\n+        let cx = bcx.cx;\n \n         // Translates the shims described above:\n         //\n@@ -915,22 +915,22 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         let data = llvm::get_param(bcx.llfn(), 1);\n         let local_ptr = llvm::get_param(bcx.llfn(), 2);\n         bcx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n-        then.ret(C_i32(ccx, 0));\n+        then.ret(C_i32(cx, 0));\n \n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n-        let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n+        let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)],\n                                     false);\n-        let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1);\n-        catch.add_clause(vals, C_null(Type::i8p(ccx)));\n+        let vals = catch.landing_pad(lpad_ty, bcx.cx.eh_personality(), 1);\n+        catch.add_clause(vals, C_null(Type::i8p(cx)));\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bcx.tcx().data_layout.pointer_align;\n-        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), ptr_align);\n-        catch.ret(C_i32(ccx, 1));\n+        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(cx).ptr_to()), ptr_align);\n+        catch.ret(C_i32(cx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -942,21 +942,21 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n // Helper function to give a Block to a closure to translate a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n-fn gen_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n                     trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n-    let rust_fn_ty = ccx.tcx.mk_fn_ptr(ty::Binder(ccx.tcx.mk_fn_sig(\n+    let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder(cx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n         output,\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust\n     )));\n-    let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n+    let llfn = declare::define_internal_fn(cx, name, rust_fn_ty);\n+    let bcx = Builder::new_block(cx, llfn, \"entry-block\");\n     trans(bcx);\n     llfn\n }\n@@ -965,15 +965,15 @@ fn gen_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n // catch exceptions.\n //\n // This function is only generated once and is then cached.\n-fn get_rust_try_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn get_rust_try_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n-    if let Some(llfn) = ccx.rust_try_fn.get() {\n+    if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;\n     }\n \n     // Define the type up front for the signature of the rust_try function.\n-    let tcx = ccx.tcx;\n+    let tcx = cx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n     let fn_ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n         iter::once(i8p),\n@@ -983,8 +983,8 @@ fn get_rust_try_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         Abi::Rust\n     )));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(ccx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n-    ccx.rust_try_fn.set(Some(rust_try));\n+    let rust_try = gen_fn(cx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n+    cx.rust_try_fn.set(Some(rust_try));\n     return rust_try\n }\n \n@@ -1109,7 +1109,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                                     arg_idx, total_len);\n                         None\n                     }\n-                    Some(idx) => Some(C_i32(bcx.ccx, idx as i32)),\n+                    Some(idx) => Some(C_i32(bcx.cx, idx as i32)),\n                 }\n             })\n             .collect();\n@@ -1243,11 +1243,11 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n // Returns None if the type is not an integer\n // FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n // stuffs.\n-fn int_type_width_signed(ty: Ty, ccx: &CodegenCx) -> Option<(u64, bool)> {\n+fn int_type_width_signed(ty: Ty, cx: &CodegenCx) -> Option<(u64, bool)> {\n     match ty.sty {\n         ty::TyInt(t) => Some((match t {\n             ast::IntTy::Isize => {\n-                match &ccx.tcx.sess.target.target.target_pointer_width[..] {\n+                match &cx.tcx.sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,\n                     \"32\" => 32,\n                     \"64\" => 64,\n@@ -1262,7 +1262,7 @@ fn int_type_width_signed(ty: Ty, ccx: &CodegenCx) -> Option<(u64, bool)> {\n         }, true)),\n         ty::TyUint(t) => Some((match t {\n             ast::UintTy::Usize => {\n-                match &ccx.tcx.sess.target.target.target_pointer_width[..] {\n+                match &cx.tcx.sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,\n                     \"32\" => 32,\n                     \"64\" => 64,"}, {"sha": "b9551ecbfae4bc267ff467c7a9217e9e9c3e785f", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -39,9 +39,9 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n \n-        let llvtable = bcx.pointercast(llvtable, fn_ty.llvm_type(bcx.ccx).ptr_to().ptr_to());\n+        let llvtable = bcx.pointercast(llvtable, fn_ty.llvm_type(bcx.cx).ptr_to().ptr_to());\n         let ptr_align = bcx.tcx().data_layout.pointer_align;\n-        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), ptr_align);\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.cx, self.0)]), ptr_align);\n         bcx.nonnull_metadata(ptr);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n@@ -52,9 +52,9 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n-        let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n+        let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.cx).ptr_to());\n         let usize_align = bcx.tcx().data_layout.pointer_align;\n-        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), usize_align);\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.cx, self.0)]), usize_align);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n         ptr\n@@ -69,47 +69,47 @@ impl<'a, 'tcx> VirtualIndex {\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n-pub fn get_vtable<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+pub fn get_vtable<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                             ty: Ty<'tcx>,\n                             trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>)\n                             -> ValueRef\n {\n-    let tcx = ccx.tcx;\n+    let tcx = cx.tcx;\n \n     debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);\n \n     // Check the cache.\n-    if let Some(&val) = ccx.vtables.borrow().get(&(ty, trait_ref)) {\n+    if let Some(&val) = cx.vtables.borrow().get(&(ty, trait_ref)) {\n         return val;\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = C_null(Type::i8p(ccx));\n+    let nullptr = C_null(Type::i8p(cx));\n \n-    let (size, align) = ccx.size_and_align_of(ty);\n+    let (size, align) = cx.size_and_align_of(ty);\n     let mut components: Vec<_> = [\n-        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.tcx, ty)),\n-        C_usize(ccx, size.bytes()),\n-        C_usize(ccx, align.abi())\n+        callee::get_fn(cx, monomorphize::resolve_drop_in_place(cx.tcx, ty)),\n+        C_usize(cx, size.bytes()),\n+        C_usize(cx, align.abi())\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {\n         let trait_ref = trait_ref.with_self_ty(tcx, ty);\n         let methods = tcx.vtable_methods(trait_ref);\n         let methods = methods.iter().cloned().map(|opt_mth| {\n             opt_mth.map_or(nullptr, |(def_id, substs)| {\n-                callee::resolve_and_get_fn(ccx, def_id, substs)\n+                callee::resolve_and_get_fn(cx, def_id, substs)\n             })\n         });\n         components.extend(methods);\n     }\n \n-    let vtable_const = C_struct(ccx, &components, false);\n-    let align = ccx.data_layout().pointer_align;\n-    let vtable = consts::addr_of(ccx, vtable_const, align, \"vtable\");\n+    let vtable_const = C_struct(cx, &components, false);\n+    let align = cx.data_layout().pointer_align;\n+    let vtable = consts::addr_of(cx, vtable_const, align, \"vtable\");\n \n-    debuginfo::create_vtable_metadata(ccx, ty, vtable);\n+    debuginfo::create_vtable_metadata(cx, ty, vtable);\n \n-    ccx.vtables.borrow_mut().insert((ty, trait_ref), vtable);\n+    cx.vtables.borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }"}, {"sha": "0037c6cd02707266a568a7420027ba6028b875d5", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -31,7 +31,7 @@ pub fn memory_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n     for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n         let ty = mircx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n-        let layout = mircx.ccx.layout_of(ty);\n+        let layout = mircx.cx.layout_of(ty);\n         if layout.is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n@@ -117,7 +117,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     }, ..\n                 }),\n                 ref args, ..\n-            } if Some(def_id) == self.cx.ccx.tcx.lang_items().box_free_fn() => {\n+            } if Some(def_id) == self.cx.cx.tcx.lang_items().box_free_fn() => {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n@@ -136,7 +136,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n-        let ccx = self.cx.ccx;\n+        let cx = self.cx.cx;\n \n         if let mir::Place::Projection(ref proj) = *place {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n@@ -145,18 +145,18 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 _ => false\n             };\n             if is_consume {\n-                let base_ty = proj.base.ty(self.cx.mir, ccx.tcx);\n+                let base_ty = proj.base.ty(self.cx.mir, cx.tcx);\n                 let base_ty = self.cx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty.projection_ty(ccx.tcx, &proj.elem).to_ty(ccx.tcx);\n+                let elem_ty = base_ty.projection_ty(cx.tcx, &proj.elem).to_ty(cx.tcx);\n                 let elem_ty = self.cx.monomorphize(&elem_ty);\n-                if ccx.layout_of(elem_ty).is_zst() {\n+                if cx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = ccx.layout_of(base_ty.to_ty(ccx.tcx));\n+                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx));\n                     if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n@@ -200,11 +200,11 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             }\n \n             PlaceContext::Drop => {\n-                let ty = mir::Place::Local(index).ty(self.cx.mir, self.cx.ccx.tcx);\n-                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx));\n+                let ty = mir::Place::Local(index).ty(self.cx.mir, self.cx.cx.tcx);\n+                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.cx.tcx));\n \n                 // Only need the place if we're actually dropping it.\n-                if self.cx.ccx.type_needs_drop(ty) {\n+                if self.cx.cx.type_needs_drop(ty) {\n                     self.mark_as_memory(index);\n                 }\n             }"}, {"sha": "640c489dd19d0ea43c6dcdeb0d4be2362b25bb48", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -174,15 +174,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         lp = bcx.insert_value(lp, lp1, 1);\n                         bcx.resume(lp);\n                     } else {\n-                        bcx.call(bcx.ccx.eh_unwind_resume(), &[lp0], cleanup_bundle);\n+                        bcx.call(bcx.cx.eh_unwind_resume(), &[lp0], cleanup_bundle);\n                         bcx.unreachable();\n                     }\n                 }\n             }\n \n             mir::TerminatorKind::Abort => {\n                 // Call core::intrinsics::abort()\n-                let fnname = bcx.ccx.get_intrinsic(&(\"llvm.trap\"));\n+                let fnname = bcx.cx.get_intrinsic(&(\"llvm.trap\"));\n                 bcx.call(fnname, &[], None);\n                 bcx.unreachable();\n             }\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let switch = bcx.switch(discr.immediate(),\n                                             llblock(self, *otherwise), values.len());\n                     for (value, target) in values.iter().zip(targets) {\n-                        let val = Const::from_constint(bcx.ccx, value);\n+                        let val = Const::from_constint(bcx.cx, value);\n                         let llbb = llblock(self, *target);\n                         bcx.add_case(switch, val.llval, llbb)\n                     }\n@@ -253,7 +253,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             }\n                         };\n                         bcx.load(\n-                            bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n+                            bcx.pointercast(llslot, cast_ty.llvm_type(bcx.cx).ptr_to()),\n                             self.fn_ty.ret.layout.align)\n                     }\n                 };\n@@ -267,7 +267,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(self.mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.tcx, ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bcx.cx.tcx, ty);\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n@@ -280,16 +280,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 args = &args[..1 + place.has_extra() as usize];\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::TyDynamic(..) => {\n-                        let fn_ty = drop_fn.ty(bcx.ccx.tcx);\n-                        let sig = common::ty_fn_sig(bcx.ccx, fn_ty);\n+                        let fn_ty = drop_fn.ty(bcx.cx.tcx);\n+                        let sig = common::ty_fn_sig(bcx.cx, fn_ty);\n                         let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-                        let fn_ty = FnType::new_vtable(bcx.ccx, sig, &[]);\n+                        let fn_ty = FnType::new_vtable(bcx.cx, sig, &[]);\n                         args = &args[..1];\n                         (meth::DESTRUCTOR.get_fn(&bcx, place.llextra, &fn_ty), fn_ty)\n                     }\n                     _ => {\n-                        (callee::get_fn(bcx.ccx, drop_fn),\n-                         FnType::of_instance(bcx.ccx, &drop_fn))\n+                        (callee::get_fn(bcx.cx, drop_fn),\n+                         FnType::of_instance(bcx.cx, &drop_fn))\n                     }\n                 };\n                 do_call(self, bcx, fn_ty, drop_fn, args,\n@@ -308,7 +308,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // NOTE: Unlike binops, negation doesn't have its own\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n-                if !bcx.ccx.check_overflow {\n+                if !bcx.cx.check_overflow {\n                     use rustc_const_math::ConstMathErr::Overflow;\n                     use rustc_const_math::Op::Neg;\n \n@@ -324,8 +324,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 // Pass the condition through llvm.expect for branch hinting.\n-                let expect = bcx.ccx.get_intrinsic(&\"llvm.expect.i1\");\n-                let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx, expected)], None);\n+                let expect = bcx.cx.get_intrinsic(&\"llvm.expect.i1\");\n+                let cond = bcx.call(expect, &[cond, C_bool(bcx.cx, expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n@@ -343,9 +343,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                let filename = C_str_slice(bcx.ccx, filename);\n-                let line = C_u32(bcx.ccx, loc.line as u32);\n-                let col = C_u32(bcx.ccx, loc.col.to_usize() as u32 + 1);\n+                let filename = C_str_slice(bcx.cx, filename);\n+                let line = C_u32(bcx.cx, loc.line as u32);\n+                let col = C_u32(bcx.cx, loc.col.to_usize() as u32 + 1);\n                 let align = tcx.data_layout.aggregate_align\n                     .max(tcx.data_layout.i32_align)\n                     .max(tcx.data_layout.pointer_align);\n@@ -363,8 +363,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     index: index as u64\n                                 }));\n \n-                        let file_line_col = C_struct(bcx.ccx, &[filename, line, col], false);\n-                        let file_line_col = consts::addr_of(bcx.ccx,\n+                        let file_line_col = C_struct(bcx.cx, &[filename, line, col], false);\n+                        let file_line_col = consts::addr_of(bcx.cx,\n                                                             file_line_col,\n                                                             align,\n                                                             \"panic_bounds_check_loc\");\n@@ -374,11 +374,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n                         let msg_str = Symbol::intern(err.description()).as_str();\n-                        let msg_str = C_str_slice(bcx.ccx, msg_str);\n-                        let msg_file_line_col = C_struct(bcx.ccx,\n+                        let msg_str = C_str_slice(bcx.cx, msg_str);\n+                        let msg_file_line_col = C_struct(bcx.cx,\n                                                      &[msg_str, filename, line, col],\n                                                      false);\n-                        let msg_file_line_col = consts::addr_of(bcx.ccx,\n+                        let msg_file_line_col = consts::addr_of(bcx.cx,\n                                                                 msg_file_line_col,\n                                                                 align,\n                                                                 \"panic_loc\");\n@@ -394,11 +394,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             \"generator resumed after panicking\"\n                         };\n                         let msg_str = Symbol::intern(str).as_str();\n-                        let msg_str = C_str_slice(bcx.ccx, msg_str);\n-                        let msg_file_line_col = C_struct(bcx.ccx,\n+                        let msg_str = C_str_slice(bcx.cx, msg_str);\n+                        let msg_file_line_col = C_struct(bcx.cx,\n                                                      &[msg_str, filename, line, col],\n                                                      false);\n-                        let msg_file_line_col = consts::addr_of(bcx.ccx,\n+                        let msg_file_line_col = consts::addr_of(bcx.cx,\n                                                                 msg_file_line_col,\n                                                                 align,\n                                                                 \"panic_loc\");\n@@ -423,8 +423,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n                 let instance = ty::Instance::mono(bcx.tcx(), def_id);\n-                let fn_ty = FnType::of_instance(bcx.ccx, &instance);\n-                let llfn = callee::get_fn(bcx.ccx, instance);\n+                let fn_ty = FnType::of_instance(bcx.cx, &instance);\n+                let llfn = callee::get_fn(bcx.cx, instance);\n \n                 // Translate the actual panic invoke/call.\n                 do_call(self, bcx, fn_ty, llfn, &args, None, cleanup);\n@@ -440,7 +440,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n-                        (Some(ty::Instance::resolve(bcx.ccx.tcx,\n+                        (Some(ty::Instance::resolve(bcx.cx.tcx,\n                                                     ty::ParamEnv::empty(traits::Reveal::All),\n                                                     def_id,\n                                                     substs).unwrap()),\n@@ -479,15 +479,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let fn_ty = match def {\n                     Some(ty::InstanceDef::Virtual(..)) => {\n-                        FnType::new_vtable(bcx.ccx, sig, &extra_args)\n+                        FnType::new_vtable(bcx.cx, sig, &extra_args)\n                     }\n                     Some(ty::InstanceDef::DropGlue(_, None)) => {\n                         // empty drop glue - a nop.\n                         let &(_, target) = destination.as_ref().unwrap();\n                         funclet_br(self, bcx, target);\n                         return;\n                     }\n-                    _ => FnType::new(bcx.ccx, sig, &extra_args)\n+                    _ => FnType::new(bcx.cx, sig, &extra_args)\n                 };\n \n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n@@ -509,7 +509,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to())\n+                            C_undef(fn_ty.ret.memory_ty(bcx.cx).ptr_to())\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -532,7 +532,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     let val = self.trans_constant(&bcx, constant);\n                                     return OperandRef {\n                                         val: Immediate(val.llval),\n-                                        layout: bcx.ccx.layout_of(val.ty)\n+                                        layout: bcx.cx.layout_of(val.ty)\n                                     };\n                                 }\n                             }\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }).collect();\n \n \n-                    let callee_ty = instance.as_ref().unwrap().ty(bcx.ccx.tcx);\n+                    let callee_ty = instance.as_ref().unwrap().ty(bcx.cx.tcx);\n                     trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &args, dest,\n                                          terminator.source_info.span);\n \n@@ -599,7 +599,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let fn_ptr = match (llfn, instance) {\n                     (Some(llfn), _) => llfn,\n-                    (None, Some(instance)) => callee::get_fn(bcx.ccx, instance),\n+                    (None, Some(instance)) => callee::get_fn(bcx.cx, instance),\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n@@ -620,7 +620,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       arg: &ArgType<'tcx>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(C_undef(ty.llvm_type(bcx.ccx)));\n+            llargs.push(C_undef(ty.llvm_type(bcx.cx)));\n         }\n \n         if arg.is_ignore() {\n@@ -670,7 +670,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n+                llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.cx).ptr_to()),\n                                  align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n@@ -716,13 +716,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> PlaceRef<'tcx> {\n-        let ccx = bcx.ccx;\n+        let cx = bcx.cx;\n         if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n-            let layout = ccx.layout_of(ccx.tcx.intern_tup(&[\n-                ccx.tcx.mk_mut_ptr(ccx.tcx.types.u8),\n-                ccx.tcx.types.i32\n+            let layout = cx.layout_of(cx.tcx.intern_tup(&[\n+                cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n+                cx.tcx.types.i32\n             ], false));\n             let slot = PlaceRef::alloca(bcx, layout, \"personalityslot\");\n             self.personality_slot = Some(slot);\n@@ -745,13 +745,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn landing_pad_uncached(&mut self, target_bb: BasicBlockRef) -> BasicBlockRef {\n-        if base::wants_msvc_seh(self.ccx.sess()) {\n+        if base::wants_msvc_seh(self.cx.sess()) {\n             span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n \n         let bcx = self.new_block(\"cleanup\");\n \n-        let llpersonality = self.ccx.eh_personality();\n+        let llpersonality = self.cx.eh_personality();\n         let llretty = self.landing_pad_type();\n         let lp = bcx.landing_pad(llretty, llpersonality, 1);\n         bcx.set_cleanup(lp);\n@@ -765,8 +765,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn landing_pad_type(&self) -> Type {\n-        let ccx = self.ccx;\n-        Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false)\n+        let cx = self.cx;\n+        Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false)\n     }\n \n     fn unreachable_block(&mut self) -> BasicBlockRef {\n@@ -779,11 +779,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n-        Builder::new_block(self.ccx, self.llfn, name)\n+        Builder::new_block(self.cx, self.llfn, name)\n     }\n \n     pub fn get_builder(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n-        let builder = Builder::with_ccx(self.ccx);\n+        let builder = Builder::with_cx(self.cx);\n         builder.position_at_end(self.blocks[bb]);\n         builder\n     }\n@@ -851,7 +851,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.trans_transmute_into(bcx, src, place),\n                 LocalRef::Operand(None) => {\n-                    let dst_layout = bcx.ccx.layout_of(self.monomorphized_place_ty(dst));\n+                    let dst_layout = bcx.cx.layout_of(self.monomorphized_place_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n                     let place = PlaceRef::alloca(bcx, dst_layout, \"transmute_temp\");\n                     place.storage_live(bcx);\n@@ -875,7 +875,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             src: &mir::Operand<'tcx>,\n                             dst: PlaceRef<'tcx>) {\n         let src = self.trans_operand(bcx, src);\n-        let llty = src.layout.llvm_type(bcx.ccx);\n+        let llty = src.layout.llvm_type(bcx.cx);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let align = src.layout.align.min(dst.layout.align);\n         src.val.store(bcx, PlaceRef::new_sized(cast_ptr, src.layout, align));"}, {"sha": "79df4a0749fb0b800c351075841fcd87d261329f", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 149, "deletions": 149, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -62,46 +62,46 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn from_constint(ccx: &CodegenCx<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n-        let tcx = ccx.tcx;\n+    pub fn from_constint(cx: &CodegenCx<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n+        let tcx = cx.tcx;\n         let (llval, ty) = match *ci {\n-            I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n-            I16(v) => (C_int(Type::i16(ccx), v as i64), tcx.types.i16),\n-            I32(v) => (C_int(Type::i32(ccx), v as i64), tcx.types.i32),\n-            I64(v) => (C_int(Type::i64(ccx), v as i64), tcx.types.i64),\n-            I128(v) => (C_uint_big(Type::i128(ccx), v as u128), tcx.types.i128),\n-            Isize(v) => (C_int(Type::isize(ccx), v.as_i64()), tcx.types.isize),\n-            U8(v) => (C_uint(Type::i8(ccx), v as u64), tcx.types.u8),\n-            U16(v) => (C_uint(Type::i16(ccx), v as u64), tcx.types.u16),\n-            U32(v) => (C_uint(Type::i32(ccx), v as u64), tcx.types.u32),\n-            U64(v) => (C_uint(Type::i64(ccx), v), tcx.types.u64),\n-            U128(v) => (C_uint_big(Type::i128(ccx), v), tcx.types.u128),\n-            Usize(v) => (C_uint(Type::isize(ccx), v.as_u64()), tcx.types.usize),\n+            I8(v) => (C_int(Type::i8(cx), v as i64), tcx.types.i8),\n+            I16(v) => (C_int(Type::i16(cx), v as i64), tcx.types.i16),\n+            I32(v) => (C_int(Type::i32(cx), v as i64), tcx.types.i32),\n+            I64(v) => (C_int(Type::i64(cx), v as i64), tcx.types.i64),\n+            I128(v) => (C_uint_big(Type::i128(cx), v as u128), tcx.types.i128),\n+            Isize(v) => (C_int(Type::isize(cx), v.as_i64()), tcx.types.isize),\n+            U8(v) => (C_uint(Type::i8(cx), v as u64), tcx.types.u8),\n+            U16(v) => (C_uint(Type::i16(cx), v as u64), tcx.types.u16),\n+            U32(v) => (C_uint(Type::i32(cx), v as u64), tcx.types.u32),\n+            U64(v) => (C_uint(Type::i64(cx), v), tcx.types.u64),\n+            U128(v) => (C_uint_big(Type::i128(cx), v), tcx.types.u128),\n+            Usize(v) => (C_uint(Type::isize(cx), v.as_u64()), tcx.types.usize),\n         };\n         Const { llval: llval, ty: ty }\n     }\n \n     /// Translate ConstVal into a LLVM constant value.\n-    pub fn from_constval(ccx: &CodegenCx<'a, 'tcx>,\n+    pub fn from_constval(cx: &CodegenCx<'a, 'tcx>,\n                          cv: &ConstVal,\n                          ty: Ty<'tcx>)\n                          -> Const<'tcx> {\n-        let llty = ccx.layout_of(ty).llvm_type(ccx);\n+        let llty = cx.layout_of(ty).llvm_type(cx);\n         let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n-                    ast::FloatTy::F32 => C_u32(ccx, v.bits as u32),\n-                    ast::FloatTy::F64 => C_u64(ccx, v.bits as u64)\n+                    ast::FloatTy::F32 => C_u32(cx, v.bits as u32),\n+                    ast::FloatTy::F64 => C_u64(cx, v.bits as u64)\n                 };\n                 consts::bitcast(bits, llty)\n             }\n-            ConstVal::Bool(v) => C_bool(ccx, v),\n-            ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n-            ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n+            ConstVal::Bool(v) => C_bool(cx, v),\n+            ConstVal::Integral(ref i) => return Const::from_constint(cx, i),\n+            ConstVal::Str(ref v) => C_str_slice(cx, v.clone()),\n             ConstVal::ByteStr(v) => {\n-                consts::addr_of(ccx, C_bytes(ccx, v.data), ccx.align_of(ty), \"byte_str\")\n+                consts::addr_of(cx, C_bytes(cx, v.data), cx.align_of(ty), \"byte_str\")\n             }\n-            ConstVal::Char(c) => C_uint(Type::char(ccx), c as u64),\n+            ConstVal::Char(c) => C_uint(Type::char(cx), c as u64),\n             ConstVal::Function(..) => C_undef(llty),\n             ConstVal::Variant(_) |\n             ConstVal::Aggregate(..) |\n@@ -115,11 +115,11 @@ impl<'a, 'tcx> Const<'tcx> {\n         Const::new(val, ty)\n     }\n \n-    fn get_field(&self, ccx: &CodegenCx<'a, 'tcx>, i: usize) -> ValueRef {\n-        let layout = ccx.layout_of(self.ty);\n-        let field = layout.field(ccx, i);\n+    fn get_field(&self, cx: &CodegenCx<'a, 'tcx>, i: usize) -> ValueRef {\n+        let layout = cx.layout_of(self.ty);\n+        let field = layout.field(cx, i);\n         if field.is_zst() {\n-            return C_undef(field.immediate_llvm_type(ccx));\n+            return C_undef(field.immediate_llvm_type(cx));\n         }\n         let offset = layout.fields.offset(i);\n         match layout.abi {\n@@ -130,12 +130,12 @@ impl<'a, 'tcx> Const<'tcx> {\n \n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(ccx));\n+                    assert_eq!(field.size, a.value.size(cx));\n                     const_get_elt(self.llval, 0)\n                 } else {\n-                    assert_eq!(offset, a.value.size(ccx)\n-                        .abi_align(b.value.align(ccx)));\n-                    assert_eq!(field.size, b.value.size(ccx));\n+                    assert_eq!(offset, a.value.size(cx)\n+                        .abi_align(b.value.align(cx)));\n+                    assert_eq!(field.size, b.value.size(cx));\n                     const_get_elt(self.llval, 1)\n                 }\n             }\n@@ -145,14 +145,14 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    fn get_pair(&self, ccx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n-        (self.get_field(ccx, 0), self.get_field(ccx, 1))\n+    fn get_pair(&self, cx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n+        (self.get_field(cx, 0), self.get_field(cx, 1))\n     }\n \n-    fn get_fat_ptr(&self, ccx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n+    fn get_fat_ptr(&self, cx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n         assert_eq!(abi::FAT_PTR_ADDR, 0);\n         assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        self.get_pair(ccx)\n+        self.get_pair(cx)\n     }\n \n     fn as_place(&self) -> ConstPlace<'tcx> {\n@@ -163,9 +163,9 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn to_operand(&self, ccx: &CodegenCx<'a, 'tcx>) -> OperandRef<'tcx> {\n-        let layout = ccx.layout_of(self.ty);\n-        let llty = layout.immediate_llvm_type(ccx);\n+    pub fn to_operand(&self, cx: &CodegenCx<'a, 'tcx>) -> OperandRef<'tcx> {\n+        let layout = cx.layout_of(self.ty);\n+        let llty = layout.immediate_llvm_type(cx);\n         let llvalty = val_ty(self.llval);\n \n         let val = if llty == llvalty && layout.is_llvm_scalar_pair() {\n@@ -178,9 +178,9 @@ impl<'a, 'tcx> Const<'tcx> {\n         } else {\n             // Otherwise, or if the value is not immediate, we create\n             // a constant LLVM global and cast its address if necessary.\n-            let align = ccx.align_of(self.ty);\n-            let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n-            OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(ccx).ptr_to()),\n+            let align = cx.align_of(self.ty);\n+            let ptr = consts::addr_of(cx, self.llval, align, \"const\");\n+            OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(cx).ptr_to()),\n                               layout.align)\n         };\n \n@@ -232,10 +232,10 @@ impl<'tcx> ConstPlace<'tcx> {\n         }\n     }\n \n-    pub fn len<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n+    pub fn len<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n         match self.ty.sty {\n             ty::TyArray(_, n) => {\n-                C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n+                C_usize(cx, n.val.to_const_int().unwrap().to_u64().unwrap())\n             }\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n@@ -249,7 +249,7 @@ impl<'tcx> ConstPlace<'tcx> {\n /// Machinery for translating a constant's MIR to LLVM values.\n /// FIXME(eddyb) use miri and lower its allocations to LLVM.\n struct MirConstContext<'a, 'tcx: 'a> {\n-    ccx: &'a CodegenCx<'a, 'tcx>,\n+    cx: &'a CodegenCx<'a, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n \n     /// Type parameters for const fn and associated constants.\n@@ -270,13 +270,13 @@ fn add_err<'tcx, U, V>(failure: &mut Result<U, ConstEvalErr<'tcx>>,\n }\n \n impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n-    fn new(ccx: &'a CodegenCx<'a, 'tcx>,\n+    fn new(cx: &'a CodegenCx<'a, 'tcx>,\n            mir: &'a mir::Mir<'tcx>,\n            substs: &'tcx Substs<'tcx>,\n            args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n            -> MirConstContext<'a, 'tcx> {\n         let mut context = MirConstContext {\n-            ccx,\n+            cx,\n             mir,\n             substs,\n             locals: (0..mir.local_decls.len()).map(|_| None).collect(),\n@@ -289,27 +289,27 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         context\n     }\n \n-    fn trans_def(ccx: &'a CodegenCx<'a, 'tcx>,\n+    fn trans_def(cx: &'a CodegenCx<'a, 'tcx>,\n                  def_id: DefId,\n                  substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = ty::Instance::resolve(ccx.tcx,\n+        let instance = ty::Instance::resolve(cx.tcx,\n                                              ty::ParamEnv::empty(traits::Reveal::All),\n                                              def_id,\n                                              substs).unwrap();\n-        let mir = ccx.tcx.instance_mir(instance.def);\n-        MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n+        let mir = cx.tcx.instance_mir(instance.def);\n+        MirConstContext::new(cx, &mir, instance.substs, args).trans()\n     }\n \n     fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        self.ccx.tcx.trans_apply_param_substs(self.substs, value)\n+        self.cx.tcx.trans_apply_param_substs(self.substs, value)\n     }\n \n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx;\n+        let tcx = self.cx.tcx;\n         let mut bb = mir::START_BLOCK;\n \n         // Make sure to evaluate all statemenets to\n@@ -399,13 +399,13 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n                             match &tcx.item_name(def_id)[..] {\n                                 \"size_of\" => {\n-                                    let llval = C_usize(self.ccx,\n-                                        self.ccx.size_of(substs.type_at(0)).bytes());\n+                                    let llval = C_usize(self.cx,\n+                                        self.cx.size_of(substs.type_at(0)).bytes());\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 \"min_align_of\" => {\n-                                    let llval = C_usize(self.ccx,\n-                                        self.ccx.align_of(substs.type_at(0)).abi());\n+                                    let llval = C_usize(self.cx,\n+                                        self.cx.align_of(substs.type_at(0)).abi());\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -430,12 +430,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n                                         Some((llval, of)) => {\n                                             Ok(trans_const_adt(\n-                                                self.ccx,\n+                                                self.cx,\n                                                 binop_ty,\n                                                 &mir::AggregateKind::Tuple,\n                                                 &[\n                                                     Const::new(llval, val_ty),\n-                                                    Const::new(C_bool(self.ccx, of), tcx.types.bool)\n+                                                    Const::new(C_bool(self.cx, of), tcx.types.bool)\n                                                 ]))\n                                         }\n                                         None => {\n@@ -447,7 +447,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 }\n                             })()\n                         } else {\n-                            MirConstContext::trans_def(self.ccx, def_id, substs, arg_vals)\n+                            MirConstContext::trans_def(self.cx, def_id, substs, arg_vals)\n                         };\n                         add_err(&mut failure, &result);\n                         self.store(dest, result, span);\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn is_binop_lang_item(&mut self, def_id: DefId) -> Option<(mir::BinOp, bool)> {\n-        let tcx = self.ccx.tcx;\n+        let tcx = self.cx.tcx;\n         let items = tcx.lang_items();\n         let def_id = Some(def_id);\n         if items.i128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn const_place(&self, place: &mir::Place<'tcx>, span: Span)\n                     -> Result<ConstPlace<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx;\n+        let tcx = self.cx.tcx;\n \n         if let mir::Place::Local(index) = *place {\n             return self.locals[index].clone().unwrap_or_else(|| {\n@@ -517,7 +517,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             mir::Place::Local(_)  => bug!(), // handled above\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n                 ConstPlace {\n-                    base: Base::Static(consts::get_static(self.ccx, def_id)),\n+                    base: Base::Static(consts::get_static(self.cx, def_id)),\n                     llextra: ptr::null_mut(),\n                     ty: self.monomorphize(&ty),\n                 }\n@@ -528,30 +528,30 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     .projection_ty(tcx, &projection.elem);\n                 let base = tr_base.to_const(span);\n                 let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n-                let has_metadata = self.ccx.type_has_metadata(projected_ty);\n+                let has_metadata = self.cx.type_has_metadata(projected_ty);\n \n                 let (projected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n                         let (base, extra) = if !has_metadata {\n                             (base.llval, ptr::null_mut())\n                         } else {\n-                            base.get_fat_ptr(self.ccx)\n+                            base.get_fat_ptr(self.cx)\n                         };\n-                        if self.ccx.statics.borrow().contains_key(&base) {\n+                        if self.cx.statics.borrow().contains_key(&base) {\n                             (Base::Static(base), extra)\n                         } else if let ty::TyStr = projected_ty.sty {\n                             (Base::Str(base), extra)\n                         } else {\n                             let v = base;\n-                            let v = self.ccx.const_unsized.borrow().get(&v).map_or(v, |&v| v);\n+                            let v = self.cx.const_unsized.borrow().get(&v).map_or(v, |&v| v);\n                             let mut val = unsafe { llvm::LLVMGetInitializer(v) };\n                             if val.is_null() {\n                                 span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n                                           Value(base));\n                             }\n-                            let layout = self.ccx.layout_of(projected_ty);\n+                            let layout = self.cx.layout_of(projected_ty);\n                             if let layout::Abi::Scalar(ref scalar) = layout.abi {\n-                                let i1_type = Type::i1(self.ccx);\n+                                let i1_type = Type::i1(self.cx);\n                                 if scalar.is_bool() && val_ty(val) != i1_type {\n                                     unsafe {\n                                         val = llvm::LLVMConstTrunc(val, i1_type.to_ref());\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let llprojected = base.get_field(self.ccx, field.index());\n+                        let llprojected = base.get_field(self.cx, field.index());\n                         let llextra = if !has_metadata {\n                             ptr::null_mut()\n                         } else {\n@@ -581,11 +581,11 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         };\n \n                         // Produce an undef instead of a LLVM assertion on OOB.\n-                        let len = common::const_to_uint(tr_base.len(self.ccx));\n+                        let len = common::const_to_uint(tr_base.len(self.cx));\n                         let llelem = if iv < len as u128 {\n                             const_get_elt(base.llval, iv as u64)\n                         } else {\n-                            C_undef(self.ccx.layout_of(projected_ty).llvm_type(self.ccx))\n+                            C_undef(self.cx.layout_of(projected_ty).llvm_type(self.cx))\n                         };\n \n                         (Base::Value(llelem), ptr::null_mut())\n@@ -616,14 +616,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 match constant.literal.clone() {\n                     mir::Literal::Promoted { index } => {\n                         let mir = &self.mir.promoted[index];\n-                        MirConstContext::new(self.ccx, mir, self.substs, IndexVec::new()).trans()\n+                        MirConstContext::new(self.cx, mir, self.substs, IndexVec::new()).trans()\n                     }\n                     mir::Literal::Value { value } => {\n                         if let ConstVal::Unevaluated(def_id, substs) = value.val {\n                             let substs = self.monomorphize(&substs);\n-                            MirConstContext::trans_def(self.ccx, def_id, substs, IndexVec::new())\n+                            MirConstContext::trans_def(self.cx, def_id, substs, IndexVec::new())\n                         } else {\n-                            Ok(Const::from_constval(self.ccx, &value.val, ty))\n+                            Ok(Const::from_constval(self.cx, &value.val, ty))\n                         }\n                     }\n                 }\n@@ -640,20 +640,20 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let elem_ty = array_ty.builtin_index().unwrap_or_else(|| {\n             bug!(\"bad array type {:?}\", array_ty)\n         });\n-        let llunitty = self.ccx.layout_of(elem_ty).llvm_type(self.ccx);\n+        let llunitty = self.cx.layout_of(elem_ty).llvm_type(self.cx);\n         // If the array contains enums, an LLVM array won't work.\n         let val = if fields.iter().all(|&f| val_ty(f) == llunitty) {\n             C_array(llunitty, fields)\n         } else {\n-            C_struct(self.ccx, fields, false)\n+            C_struct(self.cx, fields, false)\n         };\n         Const::new(val, array_ty)\n     }\n \n     fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n                     dest_ty: Ty<'tcx>, span: Span)\n                     -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx;\n+        let tcx = self.cx.tcx;\n         debug!(\"const_rvalue({:?}: {:?} @ {:?})\", rvalue, dest_ty, span);\n         let val = match *rvalue {\n             mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n@@ -695,7 +695,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n                 failure?;\n \n-                trans_const_adt(self.ccx, dest_ty, kind, &fields)\n+                trans_const_adt(self.cx, dest_ty, kind, &fields)\n             }\n \n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -706,7 +706,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n-                                callee::resolve_and_get_fn(self.ccx, def_id, substs)\n+                                callee::resolve_and_get_fn(self.cx, def_id, substs)\n                             }\n                             _ => {\n                                 span_bug!(span, \"{} cannot be reified to a fn ptr\",\n@@ -728,7 +728,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 let input = tcx.erase_late_bound_regions_and_normalize(&input);\n                                 let substs = tcx.mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));\n-                                callee::resolve_and_get_fn(self.ccx, call_once, substs)\n+                                callee::resolve_and_get_fn(self.cx, call_once, substs)\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n@@ -742,43 +742,43 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::Unsize => {\n                         let pointee_ty = operand.ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer type\").ty;\n-                        let (base, old_info) = if !self.ccx.type_is_sized(pointee_ty) {\n+                        let (base, old_info) = if !self.cx.type_is_sized(pointee_ty) {\n                             // Normally, the source is a thin pointer and we are\n                             // adding extra info to make a fat pointer. The exception\n                             // is when we are upcasting an existing object fat pointer\n                             // to use a different vtable. In that case, we want to\n                             // load out the original data pointer so we can repackage\n                             // it.\n-                            let (base, extra) = operand.get_fat_ptr(self.ccx);\n+                            let (base, extra) = operand.get_fat_ptr(self.cx);\n                             (base, Some(extra))\n                         } else {\n                             (operand.llval, None)\n                         };\n \n                         let unsized_ty = cast_ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer target type\").ty;\n-                        let ptr_ty = self.ccx.layout_of(unsized_ty).llvm_type(self.ccx).ptr_to();\n+                        let ptr_ty = self.cx.layout_of(unsized_ty).llvm_type(self.cx).ptr_to();\n                         let base = consts::ptrcast(base, ptr_ty);\n-                        let info = base::unsized_info(self.ccx, pointee_ty,\n+                        let info = base::unsized_info(self.cx, pointee_ty,\n                                                       unsized_ty, old_info);\n \n                         if old_info.is_none() {\n-                            let prev_const = self.ccx.const_unsized.borrow_mut()\n+                            let prev_const = self.cx.const_unsized.borrow_mut()\n                                                      .insert(base, operand.llval);\n                             assert!(prev_const.is_none() || prev_const == Some(operand.llval));\n                         }\n-                        C_fat_ptr(self.ccx, base, info)\n+                        C_fat_ptr(self.cx, base, info)\n                     }\n-                    mir::CastKind::Misc if self.ccx.layout_of(operand.ty).is_llvm_immediate() => {\n+                    mir::CastKind::Misc if self.cx.layout_of(operand.ty).is_llvm_immediate() => {\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let cast_layout = self.ccx.layout_of(cast_ty);\n+                        let cast_layout = self.cx.layout_of(cast_ty);\n                         assert!(cast_layout.is_llvm_immediate());\n-                        let ll_t_out = cast_layout.immediate_llvm_type(self.ccx);\n+                        let ll_t_out = cast_layout.immediate_llvm_type(self.cx);\n                         let llval = operand.llval;\n \n                         let mut signed = false;\n-                        let l = self.ccx.layout_of(operand.ty);\n+                        let l = self.cx.layout_of(operand.ty);\n                         if let layout::Abi::Scalar(ref scalar) = l.abi {\n                             if let layout::Int(_, true) = scalar.value {\n                                 signed = true;\n@@ -792,17 +792,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n                                 }\n                                 (CastTy::Int(_), CastTy::Float) => {\n-                                    cast_const_int_to_float(self.ccx, llval, signed, ll_t_out)\n+                                    cast_const_int_to_float(self.cx, llval, signed, ll_t_out)\n                                 }\n                                 (CastTy::Float, CastTy::Float) => {\n                                     llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n                                 }\n                                 (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                    cast_const_float_to_int(self.ccx, &operand,\n+                                    cast_const_float_to_int(self.cx, &operand,\n                                                             true, ll_t_out, span)\n                                 }\n                                 (CastTy::Float, CastTy::Int(_)) => {\n-                                    cast_const_float_to_int(self.ccx, &operand,\n+                                    cast_const_float_to_int(self.cx, &operand,\n                                                             false, ll_t_out, span)\n                                 }\n                                 (CastTy::Ptr(_), CastTy::Ptr(_)) |\n@@ -813,7 +813,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 (CastTy::Int(_), CastTy::Ptr(_)) => {\n                                     let s = signed as llvm::Bool;\n                                     let usize_llval = llvm::LLVMConstIntCast(llval,\n-                                        self.ccx.isize_ty.to_ref(), s);\n+                                        self.cx.isize_ty.to_ref(), s);\n                                     llvm::LLVMConstIntToPtr(usize_llval, ll_t_out.to_ref())\n                                 }\n                                 (CastTy::Ptr(_), CastTy::Int(_)) |\n@@ -825,18 +825,18 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let l = self.ccx.layout_of(operand.ty);\n-                        let cast = self.ccx.layout_of(cast_ty);\n+                        let l = self.cx.layout_of(operand.ty);\n+                        let cast = self.cx.layout_of(cast_ty);\n                         if l.is_llvm_scalar_pair() {\n-                            let (data_ptr, meta) = operand.get_fat_ptr(self.ccx);\n+                            let (data_ptr, meta) = operand.get_fat_ptr(self.cx);\n                             if cast.is_llvm_scalar_pair() {\n                                 let data_cast = consts::ptrcast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(self.ccx, 0));\n-                                C_fat_ptr(self.ccx, data_cast, meta)\n+                                    cast.scalar_pair_element_llvm_type(self.cx, 0));\n+                                C_fat_ptr(self.cx, data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = cast.immediate_llvm_type(self.ccx);\n+                                let llcast_ty = cast.immediate_llvm_type(self.cx);\n                                 consts::ptrcast(data_ptr, llcast_ty)\n                             }\n                         } else {\n@@ -857,32 +857,32 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let base = match tr_place.base {\n                     Base::Value(llval) => {\n                         // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n-                        let align = if self.ccx.type_is_sized(ty) {\n-                            self.ccx.align_of(ty)\n+                        let align = if self.cx.type_is_sized(ty) {\n+                            self.cx.align_of(ty)\n                         } else {\n-                            self.ccx.tcx.data_layout.pointer_align\n+                            self.cx.tcx.data_layout.pointer_align\n                         };\n                         if bk == mir::BorrowKind::Mut {\n-                            consts::addr_of_mut(self.ccx, llval, align, \"ref_mut\")\n+                            consts::addr_of_mut(self.cx, llval, align, \"ref_mut\")\n                         } else {\n-                            consts::addr_of(self.ccx, llval, align, \"ref\")\n+                            consts::addr_of(self.cx, llval, align, \"ref\")\n                         }\n                     }\n                     Base::Str(llval) |\n                     Base::Static(llval) => llval\n                 };\n \n-                let ptr = if self.ccx.type_is_sized(ty) {\n+                let ptr = if self.cx.type_is_sized(ty) {\n                     base\n                 } else {\n-                    C_fat_ptr(self.ccx, base, tr_place.llextra)\n+                    C_fat_ptr(self.cx, base, tr_place.llextra)\n                 };\n                 Const::new(ptr, ref_ty)\n             }\n \n             mir::Rvalue::Len(ref place) => {\n                 let tr_place = self.const_place(place, span)?;\n-                Const::new(tr_place.len(self.ccx), tcx.types.usize)\n+                Const::new(tr_place.len(self.cx), tcx.types.usize)\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n@@ -905,9 +905,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                 match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n                     Some((llval, of)) => {\n-                        trans_const_adt(self.ccx, binop_ty, &mir::AggregateKind::Tuple, &[\n+                        trans_const_adt(self.cx, binop_ty, &mir::AggregateKind::Tuple, &[\n                             Const::new(llval, val_ty),\n-                            Const::new(C_bool(self.ccx, of), tcx.types.bool)\n+                            Const::new(C_bool(self.cx, of), tcx.types.bool)\n                         ])\n                     }\n                     None => {\n@@ -941,8 +941,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(self.ccx.type_is_sized(ty));\n-                let llval = C_usize(self.ccx, self.ccx.size_of(ty).bytes());\n+                assert!(self.cx.type_is_sized(ty));\n+                let llval = C_usize(self.cx, self.cx.size_of(ty).bytes());\n                 Const::new(llval, tcx.types.usize)\n             }\n \n@@ -1060,7 +1060,7 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-unsafe fn cast_const_float_to_int(ccx: &CodegenCx,\n+unsafe fn cast_const_float_to_int(cx: &CodegenCx,\n                                   operand: &Const,\n                                   signed: bool,\n                                   int_ty: Type,\n@@ -1074,7 +1074,7 @@ unsafe fn cast_const_float_to_int(ccx: &CodegenCx,\n     // One way that might happen would be if addresses could be turned into integers in constant\n     // expressions, but that doesn't appear to be possible?\n     // In any case, an ICE is better than producing undef.\n-    let llval_bits = consts::bitcast(llval, Type::ix(ccx, float_bits as u64));\n+    let llval_bits = consts::bitcast(llval, Type::ix(cx, float_bits as u64));\n     let bits = const_to_opt_u128(llval_bits, false).unwrap_or_else(|| {\n         panic!(\"could not get bits of constant float {:?}\",\n                Value(llval));\n@@ -1090,12 +1090,12 @@ unsafe fn cast_const_float_to_int(ccx: &CodegenCx,\n     };\n     if cast_result.status.contains(Status::INVALID_OP) {\n         let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n-        err.report(ccx.tcx, span, \"expression\");\n+        err.report(cx.tcx, span, \"expression\");\n     }\n     C_uint_big(int_ty, cast_result.value)\n }\n \n-unsafe fn cast_const_int_to_float(ccx: &CodegenCx,\n+unsafe fn cast_const_int_to_float(cx: &CodegenCx,\n                                   llval: ValueRef,\n                                   signed: bool,\n                                   float_ty: Type) -> ValueRef {\n@@ -1111,7 +1111,7 @@ unsafe fn cast_const_int_to_float(ccx: &CodegenCx,\n         llvm::LLVMConstSIToFP(llval, float_ty.to_ref())\n     } else if float_ty.float_width() == 32 && value >= MAX_F32_PLUS_HALF_ULP {\n         // We're casting to f32 and the value is > f32::MAX + 0.5 ULP -> round up to infinity.\n-        let infinity_bits = C_u32(ccx, ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity_bits = C_u32(cx, ieee::Single::INFINITY.to_bits() as u32);\n         consts::bitcast(infinity_bits, float_ty)\n     } else {\n         llvm::LLVMConstUIToFP(llval, float_ty.to_ref())\n@@ -1129,21 +1129,21 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let result = match constant.literal.clone() {\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n-                MirConstContext::new(bcx.ccx, mir, self.param_substs, IndexVec::new()).trans()\n+                MirConstContext::new(bcx.cx, mir, self.param_substs, IndexVec::new()).trans()\n             }\n             mir::Literal::Value { value } => {\n                 if let ConstVal::Unevaluated(def_id, substs) = value.val {\n                     let substs = self.monomorphize(&substs);\n-                    MirConstContext::trans_def(bcx.ccx, def_id, substs, IndexVec::new())\n+                    MirConstContext::trans_def(bcx.cx, def_id, substs, IndexVec::new())\n                 } else {\n-                    Ok(Const::from_constval(bcx.ccx, &value.val, ty))\n+                    Ok(Const::from_constval(bcx.cx, &value.val, ty))\n                 }\n             }\n         };\n \n         let result = result.unwrap_or_else(|_| {\n             // We've errored, so we don't have to produce working code.\n-            let llty = bcx.ccx.layout_of(ty).llvm_type(bcx.ccx);\n+            let llty = bcx.cx.layout_of(ty).llvm_type(bcx.cx);\n             Const::new(C_undef(llty), ty)\n         });\n \n@@ -1154,11 +1154,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n \n pub fn trans_static_initializer<'a, 'tcx>(\n-    ccx: &CodegenCx<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>\n {\n-    MirConstContext::trans_def(ccx, def_id, Substs::empty(), IndexVec::new())\n+    MirConstContext::trans_def(cx, def_id, Substs::empty(), IndexVec::new())\n         .map(|c| c.llval)\n }\n \n@@ -1182,19 +1182,19 @@ pub fn trans_static_initializer<'a, 'tcx>(\n /// this could be changed in the future to avoid allocating unnecessary\n /// space after values of shorter-than-maximum cases.\n fn trans_const_adt<'a, 'tcx>(\n-    ccx: &CodegenCx<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     t: Ty<'tcx>,\n     kind: &mir::AggregateKind,\n     vals: &[Const<'tcx>]\n ) -> Const<'tcx> {\n-    let l = ccx.layout_of(t);\n+    let l = cx.layout_of(t);\n     let variant_index = match *kind {\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n     };\n \n     if let layout::Abi::Uninhabited = l.abi {\n-        return Const::new(C_undef(l.llvm_type(ccx)), t);\n+        return Const::new(C_undef(l.llvm_type(cx)), t);\n     }\n \n     match l.variants {\n@@ -1203,39 +1203,39 @@ fn trans_const_adt<'a, 'tcx>(\n             if let layout::FieldPlacement::Union(_) = l.fields {\n                 assert_eq!(variant_index, 0);\n                 assert_eq!(vals.len(), 1);\n-                let (field_size, field_align) = ccx.size_and_align_of(vals[0].ty);\n+                let (field_size, field_align) = cx.size_and_align_of(vals[0].ty);\n                 let contents = [\n                     vals[0].llval,\n-                    padding(ccx, l.size - field_size)\n+                    padding(cx, l.size - field_size)\n                 ];\n \n                 let packed = l.align.abi() < field_align.abi();\n-                Const::new(C_struct(ccx, &contents, packed), t)\n+                Const::new(C_struct(cx, &contents, packed), t)\n             } else {\n                 if let layout::Abi::Vector { .. } = l.abi {\n                     if let layout::FieldPlacement::Array { .. } = l.fields {\n                         return Const::new(C_vector(&vals.iter().map(|x| x.llval)\n                             .collect::<Vec<_>>()), t);\n                     }\n                 }\n-                build_const_struct(ccx, l, vals, None)\n+                build_const_struct(cx, l, vals, None)\n             }\n         }\n         layout::Variants::Tagged { .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    adt_def.discriminant_for_variant(ccx.tcx, variant_index)\n+                    adt_def.discriminant_for_variant(cx.tcx, variant_index)\n                            .to_u128_unchecked() as u64\n                 },\n                 _ => 0,\n             };\n-            let discr_field = l.field(ccx, 0);\n-            let discr = C_int(discr_field.llvm_type(ccx), discr as i64);\n+            let discr_field = l.field(cx, 0);\n+            let discr = C_int(discr_field.llvm_type(cx), discr as i64);\n             if let layout::Abi::Scalar(_) = l.abi {\n                 Const::new(discr, t)\n             } else {\n                 let discr = Const::new(discr, discr_field.ty);\n-                build_const_struct(ccx, l.for_variant(ccx, variant_index), vals, Some(discr))\n+                build_const_struct(cx, l.for_variant(cx, variant_index), vals, Some(discr))\n             }\n         }\n         layout::Variants::NicheFilling {\n@@ -1245,10 +1245,10 @@ fn trans_const_adt<'a, 'tcx>(\n             ..\n         } => {\n             if variant_index == dataful_variant {\n-                build_const_struct(ccx, l.for_variant(ccx, dataful_variant), vals, None)\n+                build_const_struct(cx, l.for_variant(cx, dataful_variant), vals, None)\n             } else {\n-                let niche = l.field(ccx, 0);\n-                let niche_llty = niche.llvm_type(ccx);\n+                let niche = l.field(cx, 0);\n+                let niche_llty = niche.llvm_type(cx);\n                 let niche_value = ((variant_index - niche_variants.start) as u128)\n                     .wrapping_add(niche_start);\n                 // FIXME(eddyb) Check the actual primitive type here.\n@@ -1258,7 +1258,7 @@ fn trans_const_adt<'a, 'tcx>(\n                 } else {\n                     C_uint_big(niche_llty, niche_value)\n                 };\n-                build_const_struct(ccx, l, &[Const::new(niche_llval, niche.ty)], None)\n+                build_const_struct(cx, l, &[Const::new(niche_llval, niche.ty)], None)\n             }\n         }\n     }\n@@ -1272,7 +1272,7 @@ fn trans_const_adt<'a, 'tcx>(\n /// initializer is 4-byte aligned then simply translating the tuple as\n /// a two-element struct will locate it at offset 4, and accesses to it\n /// will read the wrong memory.\n-fn build_const_struct<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn build_const_struct<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 layout: layout::TyLayout<'tcx>,\n                                 vals: &[Const<'tcx>],\n                                 discr: Option<Const<'tcx>>)\n@@ -1285,16 +1285,16 @@ fn build_const_struct<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         layout::Abi::Vector { .. } if discr.is_none() => {\n             let mut non_zst_fields = vals.iter().enumerate().map(|(i, f)| {\n                 (f, layout.fields.offset(i))\n-            }).filter(|&(f, _)| !ccx.layout_of(f.ty).is_zst());\n+            }).filter(|&(f, _)| !cx.layout_of(f.ty).is_zst());\n             match (non_zst_fields.next(), non_zst_fields.next()) {\n                 (Some((x, offset)), None) if offset.bytes() == 0 => {\n                     return Const::new(x.llval, layout.ty);\n                 }\n                 (Some((a, a_offset)), Some((b, _))) if a_offset.bytes() == 0 => {\n-                    return Const::new(C_struct(ccx, &[a.llval, b.llval], false), layout.ty);\n+                    return Const::new(C_struct(cx, &[a.llval, b.llval], false), layout.ty);\n                 }\n                 (Some((a, _)), Some((b, b_offset))) if b_offset.bytes() == 0 => {\n-                    return Const::new(C_struct(ccx, &[b.llval, a.llval], false), layout.ty);\n+                    return Const::new(C_struct(cx, &[b.llval, a.llval], false), layout.ty);\n                 }\n                 _ => {}\n             }\n@@ -1309,7 +1309,7 @@ fn build_const_struct<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n     cfields.reserve(discr.is_some() as usize + 1 + layout.fields.count() * 2);\n \n     if let Some(discr) = discr {\n-        let (field_size, field_align) = ccx.size_and_align_of(discr.ty);\n+        let (field_size, field_align) = cx.size_and_align_of(discr.ty);\n         packed |= layout.align.abi() < field_align.abi();\n         cfields.push(discr.llval);\n         offset = field_size;\n@@ -1319,19 +1319,19 @@ fn build_const_struct<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         (vals[i], layout.fields.offset(i))\n     });\n     for (val, target_offset) in parts {\n-        let (field_size, field_align) = ccx.size_and_align_of(val.ty);\n+        let (field_size, field_align) = cx.size_and_align_of(val.ty);\n         packed |= layout.align.abi() < field_align.abi();\n-        cfields.push(padding(ccx, target_offset - offset));\n+        cfields.push(padding(cx, target_offset - offset));\n         cfields.push(val.llval);\n         offset = target_offset + field_size;\n     }\n \n     // Pad to the size of the whole type, not e.g. the variant.\n-    cfields.push(padding(ccx, ccx.size_of(layout.ty) - offset));\n+    cfields.push(padding(cx, cx.size_of(layout.ty) - offset));\n \n-    Const::new(C_struct(ccx, &cfields, packed), layout.ty)\n+    Const::new(C_struct(cx, &cfields, packed), layout.ty)\n }\n \n-fn padding(ccx: &CodegenCx, size: Size) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(ccx), size.bytes()))\n+fn padding(cx: &CodegenCx, size: Size) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(cx), size.bytes()))\n }"}, {"sha": "0253062df2f8601564cf506efa866fce021ce886", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -48,7 +48,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     llfn: ValueRef,\n \n-    ccx: &'a CodegenCx<'a, 'tcx>,\n+    cx: &'a CodegenCx<'a, 'tcx>,\n \n     fn_ty: FnType<'tcx>,\n \n@@ -106,7 +106,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        self.ccx.tcx.trans_apply_param_substs(self.param_substs, value)\n+        self.cx.tcx.trans_apply_param_substs(self.param_substs, value)\n     }\n \n     pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n         if source_info.span.ctxt() == NO_EXPANSION ||\n-           self.ccx.sess().opts.debugging_opts.debug_macros {\n+           self.cx.sess().opts.debugging_opts.debug_macros {\n             let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n             (scope, source_info.span)\n         } else {\n@@ -158,9 +158,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n-            let cm = self.ccx.sess().codemap();\n+            let cm = self.cx.sess().codemap();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n-            debuginfo::extend_scope_to_file(self.ccx,\n+            debuginfo::extend_scope_to_file(self.cx,\n                                             scope_metadata,\n                                             &cm.lookup_char_pos(pos).file,\n                                             defining_crate)\n@@ -176,12 +176,12 @@ enum LocalRef<'tcx> {\n }\n \n impl<'a, 'tcx> LocalRef<'tcx> {\n-    fn new_operand(ccx: &CodegenCx<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n+    fn new_operand(cx: &CodegenCx<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(Some(OperandRef::new_zst(ccx, layout)))\n+            LocalRef::Operand(Some(OperandRef::new_zst(cx, layout)))\n         } else {\n             LocalRef::Operand(None)\n         }\n@@ -191,20 +191,20 @@ impl<'a, 'tcx> LocalRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'a, 'tcx: 'a>(\n-    ccx: &'a CodegenCx<'a, 'tcx>,\n+    cx: &'a CodegenCx<'a, 'tcx>,\n     llfn: ValueRef,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n-    let fn_ty = FnType::new(ccx, sig, &[]);\n+    let fn_ty = FnType::new(cx, sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n-        debuginfo::create_function_debug_context(ccx, instance, sig, llfn, mir);\n-    let bcx = Builder::new_block(ccx, llfn, \"start\");\n+        debuginfo::create_function_debug_context(cx, instance, sig, llfn, mir);\n+    let bcx = Builder::new_block(cx, llfn, \"start\");\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n-        bcx.set_personality_fn(ccx.eh_personality());\n+        bcx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n@@ -221,14 +221,14 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = debuginfo::create_mir_scopes(ccx, mir, &debug_context);\n+    let scopes = debuginfo::create_mir_scopes(cx, mir, &debug_context);\n     let (landing_pads, funclets) = create_funclets(&bcx, &cleanup_kinds, &block_bcxs);\n \n     let mut mircx = MirContext {\n         mir,\n         llfn,\n         fn_ty,\n-        ccx,\n+        cx,\n         personality_slot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,\n@@ -252,7 +252,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bcx.ccx.layout_of(mircx.monomorphize(&decl.ty));\n+            let layout = bcx.cx.layout_of(mircx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if let Some(name) = decl.name {\n@@ -262,7 +262,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n                 if !memory_locals.contains(local.index()) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(bcx.ccx, layout);\n+                    return LocalRef::new_operand(bcx.cx, layout);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n@@ -288,7 +288,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                     // alloca in advance. Instead we wait until we see the\n                     // definition and update the operand there.\n                     debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(bcx.ccx, layout)\n+                    LocalRef::new_operand(bcx.cx, layout)\n                 }\n             }\n         };\n@@ -398,7 +398,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let place = PlaceRef::alloca(bcx, bcx.ccx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bcx, bcx.cx.layout_of(arg_ty), &name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n@@ -438,7 +438,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let local = |op| LocalRef::Operand(Some(op));\n             match arg.mode {\n                 PassMode::Ignore => {\n-                    return local(OperandRef::new_zst(bcx.ccx, arg.layout));\n+                    return local(OperandRef::new_zst(bcx.cx, arg.layout));\n                 }\n                 PassMode::Direct(_) => {\n                     let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n@@ -512,7 +512,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n             // Or is it the closure environment?\n             let (closure_layout, env_ref) = match arg.layout.ty.sty {\n-                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (bcx.ccx.layout_of(mt.ty), true),\n+                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (bcx.cx.layout_of(mt.ty), true),\n                 _ => (arg.layout, false)\n             };\n \n@@ -531,7 +531,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n                 let scratch = PlaceRef::alloca(bcx,\n-                    bcx.ccx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n+                    bcx.cx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n                     \"__debuginfo_env_ptr\");\n                 bcx.store(place.llval, scratch.llval, scratch.align);\n                 scratch.llval"}, {"sha": "86e901c3f62586a4990cd921b3b319418f89df37", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -81,11 +81,11 @@ impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n }\n \n impl<'a, 'tcx> OperandRef<'tcx> {\n-    pub fn new_zst(ccx: &CodegenCx<'a, 'tcx>,\n+    pub fn new_zst(cx: &CodegenCx<'a, 'tcx>,\n                    layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(ccx))),\n+            val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(cx))),\n             layout\n         }\n     }\n@@ -99,15 +99,15 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn deref(self, ccx: &CodegenCx<'a, 'tcx>) -> PlaceRef<'tcx> {\n+    pub fn deref(self, cx: &CodegenCx<'a, 'tcx>) -> PlaceRef<'tcx> {\n         let projected_ty = self.layout.ty.builtin_deref(true, ty::NoPreference)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n             OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n-        let layout = ccx.layout_of(projected_ty);\n+        let layout = cx.layout_of(projected_ty);\n         PlaceRef {\n             llval: llptr,\n             llextra,\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     /// For other cases, see `immediate`.\n     pub fn immediate_or_packed_pair(self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n         if let OperandValue::Pair(a, b) = self.val {\n-            let llty = self.layout.llvm_type(bcx.ccx);\n+            let llty = self.layout.llvm_type(bcx.cx);\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n@@ -152,14 +152,14 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     }\n \n     pub fn extract_field(&self, bcx: &Builder<'a, 'tcx>, i: usize) -> OperandRef<'tcx> {\n-        let field = self.layout.field(bcx.ccx, i);\n+        let field = self.layout.field(bcx.cx, i);\n         let offset = self.layout.fields.offset(i);\n \n         let mut val = match (self.val, &self.layout.abi) {\n             // If we're uninhabited, or the field is ZST, it has no data.\n             _ if self.layout.abi == layout::Abi::Uninhabited || field.is_zst() => {\n                 return OperandRef {\n-                    val: OperandValue::Immediate(C_undef(field.immediate_llvm_type(bcx.ccx))),\n+                    val: OperandValue::Immediate(C_undef(field.immediate_llvm_type(bcx.cx))),\n                     layout: field\n                 };\n             }\n@@ -174,20 +174,20 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n             // Extract a scalar component from a pair.\n             (OperandValue::Pair(a_llval, b_llval), &layout::Abi::ScalarPair(ref a, ref b)) => {\n                 if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(bcx.ccx));\n+                    assert_eq!(field.size, a.value.size(bcx.cx));\n                     OperandValue::Immediate(a_llval)\n                 } else {\n-                    assert_eq!(offset, a.value.size(bcx.ccx)\n-                        .abi_align(b.value.align(bcx.ccx)));\n-                    assert_eq!(field.size, b.value.size(bcx.ccx));\n+                    assert_eq!(offset, a.value.size(bcx.cx)\n+                        .abi_align(b.value.align(bcx.cx)));\n+                    assert_eq!(field.size, b.value.size(bcx.cx));\n                     OperandValue::Immediate(b_llval)\n                 }\n             }\n \n             // `#[repr(simd)]` types are also immediate.\n             (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n                 OperandValue::Immediate(\n-                    bcx.extract_element(llval, C_usize(bcx.ccx, i as u64)))\n+                    bcx.extract_element(llval, C_usize(bcx.cx, i as u64)))\n             }\n \n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n@@ -196,11 +196,11 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n         match val {\n             OperandValue::Immediate(ref mut llval) => {\n-                *llval = bcx.bitcast(*llval, field.immediate_llvm_type(bcx.ccx));\n+                *llval = bcx.bitcast(*llval, field.immediate_llvm_type(bcx.cx));\n             }\n             OperandValue::Pair(ref mut a, ref mut b) => {\n-                *a = bcx.bitcast(*a, field.scalar_pair_element_llvm_type(bcx.ccx, 0));\n-                *b = bcx.bitcast(*b, field.scalar_pair_element_llvm_type(bcx.ccx, 1));\n+                *a = bcx.bitcast(*a, field.scalar_pair_element_llvm_type(bcx.cx, 0));\n+                *b = bcx.bitcast(*b, field.scalar_pair_element_llvm_type(bcx.cx, 1));\n             }\n             OperandValue::Ref(..) => bug!()\n         }\n@@ -231,8 +231,8 @@ impl<'a, 'tcx> OperandValue {\n                 for (i, &x) in [a, b].iter().enumerate() {\n                     let mut llptr = bcx.struct_gep(dest.llval, i as u64);\n                     // Make sure to always store i1 as i8.\n-                    if common::val_ty(x) == Type::i1(bcx.ccx) {\n-                        llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n+                    if common::val_ty(x) == Type::i1(bcx.cx) {\n+                        llptr = bcx.pointercast(llptr, Type::i8p(bcx.cx));\n                     }\n                     bcx.store(base::from_immediate(bcx, x), llptr, dest.align);\n                 }\n@@ -277,9 +277,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // ZSTs don't require any actual memory access.\n                         // FIXME(eddyb) deduplicate this with the identical\n                         // checks in `trans_consume` and `extract_field`.\n-                        let elem = o.layout.field(bcx.ccx, 0);\n+                        let elem = o.layout.field(bcx.cx, 0);\n                         if elem.is_zst() {\n-                            return Some(OperandRef::new_zst(bcx.ccx, elem));\n+                            return Some(OperandRef::new_zst(bcx.cx, elem));\n                         }\n                     }\n                     _ => {}\n@@ -298,11 +298,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         debug!(\"trans_consume(place={:?})\", place);\n \n         let ty = self.monomorphized_place_ty(place);\n-        let layout = bcx.ccx.layout_of(ty);\n+        let layout = bcx.cx.layout_of(ty);\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n-            return OperandRef::new_zst(bcx.ccx, layout);\n+            return OperandRef::new_zst(bcx.cx, layout);\n         }\n \n         if let Some(o) = self.maybe_trans_consume_direct(bcx, place) {\n@@ -329,7 +329,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Operand::Constant(ref constant) => {\n                 let val = self.trans_constant(&bcx, constant);\n-                let operand = val.to_operand(bcx.ccx);\n+                let operand = val.to_operand(bcx.cx);\n                 if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it.\n                     PlaceRef::new_sized(ptr, operand.layout, align).load(bcx)"}, {"sha": "984ae788531b0f8c38db6f800b569f977ce818bc", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -59,18 +59,18 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n-        let tmp = bcx.alloca(layout.llvm_type(bcx.ccx), name, layout.align);\n+        let tmp = bcx.alloca(layout.llvm_type(bcx.cx), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n-    pub fn len(&self, ccx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n+    pub fn len(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert!(self.has_extra());\n                 assert_eq!(count, 0);\n                 self.llextra\n             } else {\n-                C_usize(ccx, count)\n+                C_usize(cx, count)\n             }\n         } else {\n             bug!(\"unexpected layout `{:#?}` in PlaceRef::len\", self.layout)\n@@ -87,13 +87,13 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         assert!(!self.has_extra());\n \n         if self.layout.is_zst() {\n-            return OperandRef::new_zst(bcx.ccx, self.layout);\n+            return OperandRef::new_zst(bcx.cx, self.layout);\n         }\n \n         let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n             let (min, max) = (scalar.valid_range.start, scalar.valid_range.end);\n             let max_next = max.wrapping_add(1);\n-            let bits = scalar.value.size(bcx.ccx).bits();\n+            let bits = scalar.value.size(bcx.cx).bits();\n             assert!(bits <= 128);\n             let mask = !0u128 >> (128 - bits);\n             // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n@@ -139,12 +139,12 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 let mut llptr = bcx.struct_gep(self.llval, i as u64);\n                 // Make sure to always load i1 as i8.\n                 if scalar.is_bool() {\n-                    llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n+                    llptr = bcx.pointercast(llptr, Type::i8p(bcx.cx));\n                 }\n                 let load = bcx.load(llptr, self.align);\n                 scalar_load_metadata(load, scalar);\n                 if scalar.is_bool() {\n-                    bcx.trunc(load, Type::i1(bcx.ccx))\n+                    bcx.trunc(load, Type::i1(bcx.cx))\n                 } else {\n                     load\n                 }\n@@ -159,8 +159,8 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n     /// Access a field, at a point when the value's case is known.\n     pub fn project_field(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> PlaceRef<'tcx> {\n-        let ccx = bcx.ccx;\n-        let field = self.layout.field(ccx, ix);\n+        let cx = bcx.cx;\n+        let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n         let align = self.align.min(self.layout.align).min(field.align);\n \n@@ -170,15 +170,15 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 self.llval\n             } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n                 // Offsets have to match either first or second field.\n-                assert_eq!(offset, a.value.size(ccx).abi_align(b.value.align(ccx)));\n+                assert_eq!(offset, a.value.size(cx).abi_align(b.value.align(cx)));\n                 bcx.struct_gep(self.llval, 1)\n             } else {\n                 bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n             };\n             PlaceRef {\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                llval: bcx.pointercast(llval, field.llvm_type(ccx).ptr_to()),\n-                llextra: if ccx.type_has_metadata(field.ty) {\n+                llval: bcx.pointercast(llval, field.llvm_type(cx).ptr_to()),\n+                llextra: if cx.type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n                     ptr::null_mut()\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n         let meta = self.llextra;\n \n-        let unaligned_offset = C_usize(ccx, offset.bytes());\n+        let unaligned_offset = C_usize(cx, offset.bytes());\n \n         // Get the alignment of the field\n         let (_, unsized_align) = glue::size_and_align_of_dst(bcx, field.ty, meta);\n@@ -239,18 +239,18 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(unsized_align, C_usize(ccx, 1u64));\n+        let align_sub_1 = bcx.sub(unsized_align, C_usize(cx, 1u64));\n         let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n         bcx.neg(unsized_align));\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n         // Cast and adjust pointer\n-        let byte_ptr = bcx.pointercast(self.llval, Type::i8p(ccx));\n+        let byte_ptr = bcx.pointercast(self.llval, Type::i8p(cx));\n         let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n-        let ll_fty = field.llvm_type(ccx);\n+        let ll_fty = field.llvm_type(cx);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n         PlaceRef {\n@@ -263,7 +263,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n     /// Obtain the actual discriminant of a value.\n     pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n-        let cast_to = bcx.ccx.layout_of(cast_to).immediate_llvm_type(bcx.ccx);\n+        let cast_to = bcx.cx.layout_of(cast_to).immediate_llvm_type(bcx.cx);\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 return C_uint(cast_to, index as u64);\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 niche_start,\n                 ..\n             } => {\n-                let niche_llty = discr.layout.immediate_llvm_type(bcx.ccx);\n+                let niche_llty = discr.layout.immediate_llvm_type(bcx.cx);\n                 if niche_variants.start == niche_variants.end {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn trans_set_discr(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize) {\n-        if self.layout.for_variant(bcx.ccx, variant_index).abi == layout::Abi::Uninhabited {\n+        if self.layout.for_variant(bcx.cx, variant_index).abi == layout::Abi::Uninhabited {\n             return;\n         }\n         match self.layout.variants {\n@@ -329,7 +329,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 let to = self.layout.ty.ty_adt_def().unwrap()\n                     .discriminant_for_variant(bcx.tcx(), variant_index)\n                     .to_u128_unchecked() as u64;\n-                bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n+                bcx.store(C_int(ptr.layout.llvm_type(bcx.cx), to as i64),\n                     ptr.llval, ptr.align);\n             }\n             layout::Variants::NicheFilling {\n@@ -343,16 +343,16 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                        bcx.sess().target.target.arch == \"aarch64\" {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n-                        let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n-                        let fill_byte = C_u8(bcx.ccx, 0);\n+                        let llptr = bcx.pointercast(self.llval, Type::i8(bcx.cx).ptr_to());\n+                        let fill_byte = C_u8(bcx.cx, 0);\n                         let (size, align) = self.layout.size_and_align();\n-                        let size = C_usize(bcx.ccx, size.bytes());\n-                        let align = C_u32(bcx.ccx, align.abi() as u32);\n+                        let size = C_usize(bcx.cx, size.bytes());\n+                        let align = C_u32(bcx.cx, align.abi() as u32);\n                         base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                     }\n \n                     let niche = self.project_field(bcx, 0);\n-                    let niche_llty = niche.layout.immediate_llvm_type(bcx.ccx);\n+                    let niche_llty = niche.layout.immediate_llvm_type(bcx.cx);\n                     let niche_value = ((variant_index - niche_variants.start) as u128)\n                         .wrapping_add(niche_start);\n                     // FIXME(eddyb) Check the actual primitive type here.\n@@ -371,20 +371,20 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef)\n                          -> PlaceRef<'tcx> {\n         PlaceRef {\n-            llval: bcx.inbounds_gep(self.llval, &[C_usize(bcx.ccx, 0), llindex]),\n+            llval: bcx.inbounds_gep(self.llval, &[C_usize(bcx.cx, 0), llindex]),\n             llextra: ptr::null_mut(),\n-            layout: self.layout.field(bcx.ccx, 0),\n+            layout: self.layout.field(bcx.cx, 0),\n             align: self.align\n         }\n     }\n \n     pub fn project_downcast(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize)\n                             -> PlaceRef<'tcx> {\n         let mut downcast = *self;\n-        downcast.layout = self.layout.for_variant(bcx.ccx, variant_index);\n+        downcast.layout = self.layout.for_variant(bcx.cx, variant_index);\n \n         // Cast to the appropriate variant struct type.\n-        let variant_ty = downcast.layout.llvm_type(bcx.ccx);\n+        let variant_ty = downcast.layout.llvm_type(bcx.cx);\n         downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n \n         downcast\n@@ -406,8 +406,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         -> PlaceRef<'tcx> {\n         debug!(\"trans_place(place={:?})\", place);\n \n-        let ccx = bcx.ccx;\n-        let tcx = ccx.tcx;\n+        let cx = bcx.cx;\n+        let tcx = cx.tcx;\n \n         if let mir::Place::Local(index) = *place {\n             match self.locals[index] {\n@@ -423,15 +423,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let result = match *place {\n             mir::Place::Local(_) => bug!(), // handled above\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n-                let layout = ccx.layout_of(self.monomorphize(&ty));\n-                PlaceRef::new_sized(consts::get_static(ccx, def_id), layout, layout.align)\n+                let layout = cx.layout_of(self.monomorphize(&ty));\n+                PlaceRef::new_sized(consts::get_static(cx, def_id), layout, layout.align)\n             },\n             mir::Place::Projection(box mir::Projection {\n                 ref base,\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n-                self.trans_consume(bcx, base).deref(bcx.ccx)\n+                self.trans_consume(bcx, base).deref(bcx.cx)\n             }\n             mir::Place::Projection(ref projection) => {\n                 let tr_base = self.trans_place(bcx, &projection.base);\n@@ -450,34 +450,34 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = C_usize(bcx.ccx, offset as u64);\n+                        let lloffset = C_usize(bcx.cx, offset as u64);\n                         tr_base.project_index(bcx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = C_usize(bcx.ccx, offset as u64);\n-                        let lllen = tr_base.len(bcx.ccx);\n+                        let lloffset = C_usize(bcx.cx, offset as u64);\n+                        let lllen = tr_base.len(bcx.cx);\n                         let llindex = bcx.sub(lllen, lloffset);\n                         tr_base.project_index(bcx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = tr_base.project_index(bcx,\n-                            C_usize(bcx.ccx, from as u64));\n+                            C_usize(bcx.cx, from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: tr_base.layout.ty }\n                             .projection_ty(tcx, &projection.elem).to_ty(bcx.tcx());\n-                        subslice.layout = bcx.ccx.layout_of(self.monomorphize(&projected_ty));\n+                        subslice.layout = bcx.cx.layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             assert!(tr_base.has_extra());\n                             subslice.llextra = bcx.sub(tr_base.llextra,\n-                                C_usize(bcx.ccx, (from as u64) + (to as u64)));\n+                                C_usize(bcx.cx, (from as u64) + (to as u64)));\n                         }\n \n                         // Cast the place pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n                         subslice.llval = bcx.pointercast(subslice.llval,\n-                            subslice.layout.llvm_type(bcx.ccx).ptr_to());\n+                            subslice.layout.llvm_type(bcx.cx).ptr_to());\n \n                         subslice\n                     }\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n-        let tcx = self.ccx.tcx;\n+        let tcx = self.cx.tcx;\n         let place_ty = place.ty(self.mir, tcx);\n         self.monomorphize(&place_ty.to_ty(tcx))\n     }"}, {"sha": "334ca226ac8520950205ea8e594ce8ae96f3cdf7", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -101,29 +101,29 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return bcx;\n                 }\n \n-                let start = dest.project_index(&bcx, C_usize(bcx.ccx, 0)).llval;\n+                let start = dest.project_index(&bcx, C_usize(bcx.cx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n-                    let align = C_i32(bcx.ccx, dest.align.abi() as i32);\n-                    let size = C_usize(bcx.ccx, dest.layout.size.bytes());\n+                    let align = C_i32(bcx.cx, dest.align.abi() as i32);\n+                    let size = C_usize(bcx.cx, dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n-                        let fill = C_u8(bcx.ccx, 0);\n+                        let fill = C_u8(bcx.cx, 0);\n                         base::call_memset(&bcx, start, fill, size, align, false);\n                         return bcx;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = base::from_immediate(&bcx, v);\n-                    if common::val_ty(v) == Type::i8(bcx.ccx) {\n+                    if common::val_ty(v) == Type::i8(bcx.cx) {\n                         base::call_memset(&bcx, start, v, size, align, false);\n                         return bcx;\n                     }\n                 }\n \n                 let count = count.as_u64();\n-                let count = C_usize(bcx.ccx, count);\n+                let count = C_usize(bcx.cx, count);\n                 let end = dest.project_index(&bcx, count).llval;\n \n                 let header_bcx = bcx.build_sibling_block(\"repeat_loop_header\");\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 tr_elem.val.store(&body_bcx,\n                     PlaceRef::new_sized(current, tr_elem.layout, dest.align));\n \n-                let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.ccx, 1)]);\n+                let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.cx, 1)]);\n                 body_bcx.br(header_bcx.llbb());\n                 header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n \n@@ -189,14 +189,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n                 let operand = self.trans_operand(&bcx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n-                let cast = bcx.ccx.layout_of(self.monomorphize(&mir_cast_ty));\n+                let cast = bcx.cx.layout_of(self.monomorphize(&mir_cast_ty));\n \n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.layout.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n                                 OperandValue::Immediate(\n-                                    callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n+                                    callee::resolve_and_get_fn(bcx.cx, def_id, substs))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.layout.ty)\n@@ -207,8 +207,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         match operand.layout.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n-                                    bcx.ccx.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n-                                OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n+                                    bcx.cx.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n+                                OperandValue::Immediate(callee::get_fn(bcx.cx, instance))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.layout.ty)\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 // HACK(eddyb) have to bitcast pointers\n                                 // until LLVM removes pointee types.\n                                 let lldata = bcx.pointercast(lldata,\n-                                    cast.scalar_pair_element_llvm_type(bcx.ccx, 0));\n+                                    cast.scalar_pair_element_llvm_type(bcx.cx, 0));\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n@@ -250,12 +250,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n                             if cast.is_llvm_scalar_pair() {\n                                 let data_cast = bcx.pointercast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(bcx.ccx, 0));\n+                                    cast.scalar_pair_element_llvm_type(bcx.cx, 0));\n                                 OperandValue::Pair(data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = cast.immediate_llvm_type(bcx.ccx);\n+                                let llcast_ty = cast.immediate_llvm_type(bcx.cx);\n                                 let llval = bcx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n@@ -268,8 +268,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let r_t_in = CastTy::from_ty(operand.layout.ty)\n                             .expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = operand.layout.immediate_llvm_type(bcx.ccx);\n-                        let ll_t_out = cast.immediate_llvm_type(bcx.ccx);\n+                        let ll_t_in = operand.layout.immediate_llvm_type(bcx.cx);\n+                        let ll_t_out = cast.immediate_llvm_type(bcx.cx);\n                         let llval = operand.immediate();\n \n                         let mut signed = false;\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             (CastTy::FnPtr, CastTy::Int(_)) =>\n                                 bcx.ptrtoint(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                let usize_llval = bcx.intcast(llval, bcx.ccx.isize_ty, signed);\n+                                let usize_llval = bcx.intcast(llval, bcx.cx.isize_ty, signed);\n                                 bcx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Int(_), CastTy::Float) =>\n@@ -341,15 +341,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Note: places are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                let val = if !bcx.ccx.type_has_metadata(ty) {\n+                let val = if !bcx.cx.type_has_metadata(ty) {\n                     OperandValue::Immediate(tr_place.llval)\n                 } else {\n                     OperandValue::Pair(tr_place.llval, tr_place.llextra)\n                 };\n                 (bcx, OperandRef {\n                     val,\n-                    layout: self.ccx.layout_of(self.ccx.tcx.mk_ref(\n-                        self.ccx.tcx.types.re_erased,\n+                    layout: self.cx.layout_of(self.cx.tcx.mk_ref(\n+                        self.cx.tcx.types.re_erased,\n                         ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n                     )),\n                 })\n@@ -359,7 +359,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let size = self.evaluate_array_len(&bcx, place);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n-                    layout: bcx.ccx.layout_of(bcx.tcx().types.usize),\n+                    layout: bcx.cx.layout_of(bcx.tcx().types.usize),\n                 };\n                 (bcx, operand)\n             }\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    layout: bcx.ccx.layout_of(\n+                    layout: bcx.cx.layout_of(\n                         op.ty(bcx.tcx(), lhs.layout.ty, rhs.layout.ty)),\n                 };\n                 (bcx, operand)\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let operand_ty = bcx.tcx().intern_tup(&[val_ty, bcx.tcx().types.bool], false);\n                 let operand = OperandRef {\n                     val: result,\n-                    layout: bcx.ccx.layout_of(operand_ty)\n+                    layout: bcx.cx.layout_of(operand_ty)\n                 };\n \n                 (bcx, operand)\n@@ -430,27 +430,27 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     .trans_get_discr(&bcx, discr_ty);\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n-                    layout: self.ccx.layout_of(discr_ty)\n+                    layout: self.cx.layout_of(discr_ty)\n                 })\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(bcx.ccx.type_is_sized(ty));\n-                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty).bytes());\n+                assert!(bcx.cx.type_is_sized(ty));\n+                let val = C_usize(bcx.cx, bcx.cx.size_of(ty).bytes());\n                 let tcx = bcx.tcx();\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(val),\n-                    layout: self.ccx.layout_of(tcx.types.usize),\n+                    layout: self.cx.layout_of(tcx.types.usize),\n                 })\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let (size, align) = bcx.ccx.size_and_align_of(content_ty);\n-                let llsize = C_usize(bcx.ccx, size.bytes());\n-                let llalign = C_usize(bcx.ccx, align.abi());\n-                let box_layout = bcx.ccx.layout_of(bcx.tcx().mk_box(content_ty));\n-                let llty_ptr = box_layout.llvm_type(bcx.ccx);\n+                let (size, align) = bcx.cx.size_and_align_of(content_ty);\n+                let llsize = C_usize(bcx.cx, size.bytes());\n+                let llalign = C_usize(bcx.cx, align.abi());\n+                let box_layout = bcx.cx.layout_of(bcx.tcx().mk_box(content_ty));\n+                let llty_ptr = box_layout.llvm_type(bcx.cx);\n \n                 // Allocate space:\n                 let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n                 };\n                 let instance = ty::Instance::mono(bcx.tcx(), def_id);\n-                let r = callee::get_fn(bcx.ccx, instance);\n+                let r = callee::get_fn(bcx.cx, instance);\n                 let val = bcx.pointercast(bcx.call(r, &[llsize, llalign], None), llty_ptr);\n \n                 let operand = OperandRef {\n@@ -477,9 +477,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(self.mir, self.ccx.tcx);\n-                (bcx, OperandRef::new_zst(self.ccx,\n-                    self.ccx.layout_of(self.monomorphize(&ty))))\n+                let ty = rvalue.ty(self.mir, self.cx.tcx);\n+                (bcx, OperandRef::new_zst(self.cx,\n+                    self.cx.layout_of(self.monomorphize(&ty))))\n             }\n         }\n     }\n@@ -494,13 +494,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::TyArray(_, n) = op.layout.ty.sty {\n                     let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-                    return common::C_usize(bcx.ccx, n);\n+                    return common::C_usize(bcx.cx, n);\n                 }\n             }\n         }\n         // use common size calculation for non zero-sized types\n         let tr_value = self.trans_place(&bcx, place);\n-        return tr_value.len(bcx.ccx);\n+        return tr_value.len(bcx.cx);\n     }\n \n     pub fn trans_scalar_binop(&mut self,\n@@ -551,7 +551,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::BinOp::Shr => common::build_unchecked_rshift(bcx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_nil {\n-                C_bool(bcx.ccx, match op {\n+                C_bool(bcx.cx, match op {\n                     mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n                     mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n                     _ => unreachable!()\n@@ -565,8 +565,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (lhs, rhs) = if is_bool {\n                     // FIXME(#36856) -- extend the bools into `i8` because\n                     // LLVM's i1 comparisons are broken.\n-                    (bcx.zext(lhs, Type::i8(bcx.ccx)),\n-                     bcx.zext(rhs, Type::i8(bcx.ccx)))\n+                    (bcx.zext(lhs, Type::i8(bcx.cx)),\n+                     bcx.zext(rhs, Type::i8(bcx.cx)))\n                 } else {\n                     (lhs, rhs)\n                 };\n@@ -636,17 +636,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n-        if !bcx.ccx.check_overflow {\n+        if !bcx.cx.check_overflow {\n             let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, C_bool(bcx.ccx, false));\n+            return OperandValue::Pair(val, C_bool(bcx.cx, false));\n         }\n \n         // First try performing the operation on constants, which\n         // will only succeed if both operands are constant.\n         // This is necessary to determine when an overflow Assert\n         // will always panic at runtime, and produce a warning.\n         if let Some((val, of)) = const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n-            return OperandValue::Pair(val, C_bool(bcx.ccx, of));\n+            return OperandValue::Pair(val, C_bool(bcx.cx, of));\n         }\n \n         let (val, of) = match op {\n@@ -697,9 +697,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(self.mir, self.ccx.tcx);\n+                let ty = rvalue.ty(self.mir, self.cx.tcx);\n                 let ty = self.monomorphize(&ty);\n-                self.ccx.layout_of(ty).is_zst()\n+                self.cx.layout_of(ty).is_zst()\n             }\n         }\n \n@@ -784,7 +784,7 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n         },\n     };\n \n-    bcx.ccx.get_intrinsic(&name)\n+    bcx.cx.get_intrinsic(&name)\n }\n \n fn cast_int_to_float(bcx: &Builder,\n@@ -801,7 +801,7 @@ fn cast_int_to_float(bcx: &Builder,\n         // and for everything else LLVM's uitofp works just fine.\n         let max = C_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bcx.icmp(llvm::IntUGE, x, max);\n-        let infinity_bits = C_u32(bcx.ccx, ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity_bits = C_u32(bcx.cx, ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);\n         bcx.select(overflow, infinity, bcx.uitofp(x, float_ty))\n     } else {\n@@ -870,8 +870,8 @@ fn cast_float_to_int(bcx: &Builder,\n     }\n     let float_bits_to_llval = |bits| {\n         let bits_llval = match float_ty.float_width() {\n-            32 => C_u32(bcx.ccx, bits as u32),\n-            64 => C_u64(bcx.ccx, bits as u64),\n+            32 => C_u32(bcx.cx, bits as u32),\n+            64 => C_u64(bcx.cx, bits as u64),\n             n => bug!(\"unsupported float width {}\", n),\n         };\n         consts::bitcast(bits_llval, float_ty)"}, {"sha": "cc270ab5f2d25264f9d50ca79a794105bd493fe4", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -38,18 +38,18 @@ pub use rustc_mir::monomorphize::item::*;\n pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n \n pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n-    fn define(&self, ccx: &CodegenCx<'a, 'tcx>) {\n+    fn define(&self, cx: &CodegenCx<'a, 'tcx>) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx),\n+               self.to_string(cx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit.name());\n+               cx.codegen_unit.name());\n \n         match *self.as_mono_item() {\n             MonoItem::Static(node_id) => {\n-                let tcx = ccx.tcx;\n+                let tcx = cx.tcx;\n                 let item = tcx.hir.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, _) = item.node {\n-                    match consts::trans_static(&ccx, m, item.id, &item.attrs) {\n+                    match consts::trans_static(&cx, m, item.id, &item.attrs) {\n                         Ok(_) => { /* Cool, everything's alright. */ },\n                         Err(err) => {\n                             err.report(tcx, item.span, \"static\");\n@@ -60,51 +60,51 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                 }\n             }\n             MonoItem::GlobalAsm(node_id) => {\n-                let item = ccx.tcx.hir.expect_item(node_id);\n+                let item = cx.tcx.hir.expect_item(node_id);\n                 if let hir::ItemGlobalAsm(ref ga) = item.node {\n-                    asm::trans_global_asm(ccx, ga);\n+                    asm::trans_global_asm(cx, ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n                 }\n             }\n             MonoItem::Fn(instance) => {\n-                base::trans_instance(&ccx, instance);\n+                base::trans_instance(&cx, instance);\n             }\n         }\n \n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx),\n+               self.to_string(cx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit.name());\n+               cx.codegen_unit.name());\n     }\n \n     fn predefine(&self,\n-                 ccx: &CodegenCx<'a, 'tcx>,\n+                 cx: &CodegenCx<'a, 'tcx>,\n                  linkage: Linkage,\n                  visibility: Visibility) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx),\n+               self.to_string(cx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit.name());\n+               cx.codegen_unit.name());\n \n-        let symbol_name = self.symbol_name(ccx.tcx);\n+        let symbol_name = self.symbol_name(cx.tcx);\n \n         debug!(\"symbol {}\", &symbol_name);\n \n         match *self.as_mono_item() {\n             MonoItem::Static(node_id) => {\n-                predefine_static(ccx, node_id, linkage, visibility, &symbol_name);\n+                predefine_static(cx, node_id, linkage, visibility, &symbol_name);\n             }\n             MonoItem::Fn(instance) => {\n-                predefine_fn(ccx, instance, linkage, visibility, &symbol_name);\n+                predefine_fn(cx, instance, linkage, visibility, &symbol_name);\n             }\n             MonoItem::GlobalAsm(..) => {}\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx),\n+               self.to_string(cx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit.name());\n+               cx.codegen_unit.name());\n     }\n \n     fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n@@ -138,18 +138,18 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n \n impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n \n-fn predefine_static<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn predefine_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                               node_id: ast::NodeId,\n                               linkage: Linkage,\n                               visibility: Visibility,\n                               symbol_name: &str) {\n-    let def_id = ccx.tcx.hir.local_def_id(node_id);\n-    let instance = Instance::mono(ccx.tcx, def_id);\n-    let ty = instance.ty(ccx.tcx);\n-    let llty = ccx.layout_of(ty).llvm_type(ccx);\n+    let def_id = cx.tcx.hir.local_def_id(node_id);\n+    let instance = Instance::mono(cx.tcx, def_id);\n+    let ty = instance.ty(cx.tcx);\n+    let llty = cx.layout_of(ty).llvm_type(cx);\n \n-    let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n-        ccx.sess().span_fatal(ccx.tcx.hir.span(node_id),\n+    let g = declare::define_global(cx, symbol_name, llty).unwrap_or_else(|| {\n+        cx.sess().span_fatal(cx.tcx.hir.span(node_id),\n             &format!(\"symbol `{}` is already defined\", symbol_name))\n     });\n \n@@ -158,34 +158,34 @@ fn predefine_static<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n     }\n \n-    ccx.instances.borrow_mut().insert(instance, g);\n-    ccx.statics.borrow_mut().insert(g, def_id);\n+    cx.instances.borrow_mut().insert(instance, g);\n+    cx.statics.borrow_mut().insert(g, def_id);\n }\n \n-fn predefine_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn predefine_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                           instance: Instance<'tcx>,\n                           linkage: Linkage,\n                           visibility: Visibility,\n                           symbol_name: &str) {\n     assert!(!instance.substs.needs_infer() &&\n             !instance.substs.has_param_types());\n \n-    let mono_ty = instance.ty(ccx.tcx);\n-    let attrs = instance.def.attrs(ccx.tcx);\n-    let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n+    let mono_ty = instance.ty(cx.tcx);\n+    let attrs = instance.def.attrs(cx.tcx);\n+    let lldecl = declare::declare_fn(cx, symbol_name, mono_ty);\n     unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n-    base::set_link_section(ccx, lldecl, &attrs);\n+    base::set_link_section(cx, lldecl, &attrs);\n     if linkage == Linkage::LinkOnceODR ||\n         linkage == Linkage::WeakODR {\n-        llvm::SetUniqueComdat(ccx.llmod, lldecl);\n+        llvm::SetUniqueComdat(cx.llmod, lldecl);\n     }\n \n     // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n     // compiler-rt, then we want to implicitly compile everything with hidden\n     // visibility as we're going to link this object all over the place but\n     // don't want the symbols to get exported.\n     if linkage != Linkage::Internal && linkage != Linkage::Private &&\n-       attr::contains_name(ccx.tcx.hir.krate_attrs(), \"compiler_builtins\") {\n+       attr::contains_name(cx.tcx.hir.krate_attrs(), \"compiler_builtins\") {\n         unsafe {\n             llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n         }\n@@ -196,10 +196,10 @@ fn predefine_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n     }\n \n     debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n-    if instance.def.is_inline(ccx.tcx) {\n+    if instance.def.is_inline(cx.tcx) {\n         attributes::inline(lldecl, attributes::InlineAttr::Hint);\n     }\n-    attributes::from_fn_attrs(ccx, lldecl, instance.def.def_id());\n+    attributes::from_fn_attrs(cx, lldecl, instance.def.def_id());\n \n-    ccx.instances.borrow_mut().insert(instance, lldecl);\n+    cx.instances.borrow_mut().insert(instance, lldecl);\n }"}, {"sha": "a77acc4f1756f016de71784f726a9a9c64412302", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -62,115 +62,115 @@ impl Type {\n         unsafe { mem::transmute(slice) }\n     }\n \n-    pub fn void(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx))\n+    pub fn void(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMVoidTypeInContext(cx.llcx))\n     }\n \n-    pub fn metadata(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMRustMetadataTypeInContext(ccx.llcx))\n+    pub fn metadata(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMRustMetadataTypeInContext(cx.llcx))\n     }\n \n-    pub fn i1(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx))\n+    pub fn i1(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt1TypeInContext(cx.llcx))\n     }\n \n-    pub fn i8(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx))\n+    pub fn i8(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(cx.llcx))\n     }\n \n     pub fn i8_llcx(llcx: ContextRef) -> Type {\n         ty!(llvm::LLVMInt8TypeInContext(llcx))\n     }\n \n-    pub fn i16(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx))\n+    pub fn i16(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt16TypeInContext(cx.llcx))\n     }\n \n-    pub fn i32(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx))\n+    pub fn i32(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt32TypeInContext(cx.llcx))\n     }\n \n-    pub fn i64(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx))\n+    pub fn i64(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt64TypeInContext(cx.llcx))\n     }\n \n-    pub fn i128(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(ccx.llcx, 128))\n+    pub fn i128(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMIntTypeInContext(cx.llcx, 128))\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix(ccx: &CodegenCx, num_bits: u64) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(ccx.llcx, num_bits as c_uint))\n+    pub fn ix(cx: &CodegenCx, num_bits: u64) -> Type {\n+        ty!(llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint))\n     }\n \n-    pub fn f32(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx))\n+    pub fn f32(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMFloatTypeInContext(cx.llcx))\n     }\n \n-    pub fn f64(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx))\n+    pub fn f64(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMDoubleTypeInContext(cx.llcx))\n     }\n \n-    pub fn bool(ccx: &CodegenCx) -> Type {\n-        Type::i8(ccx)\n+    pub fn bool(cx: &CodegenCx) -> Type {\n+        Type::i8(cx)\n     }\n \n-    pub fn char(ccx: &CodegenCx) -> Type {\n-        Type::i32(ccx)\n+    pub fn char(cx: &CodegenCx) -> Type {\n+        Type::i32(cx)\n     }\n \n-    pub fn i8p(ccx: &CodegenCx) -> Type {\n-        Type::i8(ccx).ptr_to()\n+    pub fn i8p(cx: &CodegenCx) -> Type {\n+        Type::i8(cx).ptr_to()\n     }\n \n     pub fn i8p_llcx(llcx: ContextRef) -> Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn isize(ccx: &CodegenCx) -> Type {\n-        match &ccx.tcx.sess.target.target.target_pointer_width[..] {\n-            \"16\" => Type::i16(ccx),\n-            \"32\" => Type::i32(ccx),\n-            \"64\" => Type::i64(ccx),\n+    pub fn isize(cx: &CodegenCx) -> Type {\n+        match &cx.tcx.sess.target.target.target_pointer_width[..] {\n+            \"16\" => Type::i16(cx),\n+            \"32\" => Type::i32(cx),\n+            \"64\" => Type::i64(cx),\n             tws => bug!(\"Unsupported target word size for int: {}\", tws),\n         }\n     }\n \n-    pub fn c_int(ccx: &CodegenCx) -> Type {\n-        match &ccx.tcx.sess.target.target.target_c_int_width[..] {\n-            \"16\" => Type::i16(ccx),\n-            \"32\" => Type::i32(ccx),\n-            \"64\" => Type::i64(ccx),\n+    pub fn c_int(cx: &CodegenCx) -> Type {\n+        match &cx.tcx.sess.target.target.target_c_int_width[..] {\n+            \"16\" => Type::i16(cx),\n+            \"32\" => Type::i32(cx),\n+            \"64\" => Type::i64(cx),\n             width => bug!(\"Unsupported target_c_int_width: {}\", width),\n         }\n     }\n \n-    pub fn int_from_ty(ccx: &CodegenCx, t: ast::IntTy) -> Type {\n+    pub fn int_from_ty(cx: &CodegenCx, t: ast::IntTy) -> Type {\n         match t {\n-            ast::IntTy::Isize => ccx.isize_ty,\n-            ast::IntTy::I8 => Type::i8(ccx),\n-            ast::IntTy::I16 => Type::i16(ccx),\n-            ast::IntTy::I32 => Type::i32(ccx),\n-            ast::IntTy::I64 => Type::i64(ccx),\n-            ast::IntTy::I128 => Type::i128(ccx),\n+            ast::IntTy::Isize => cx.isize_ty,\n+            ast::IntTy::I8 => Type::i8(cx),\n+            ast::IntTy::I16 => Type::i16(cx),\n+            ast::IntTy::I32 => Type::i32(cx),\n+            ast::IntTy::I64 => Type::i64(cx),\n+            ast::IntTy::I128 => Type::i128(cx),\n         }\n     }\n \n-    pub fn uint_from_ty(ccx: &CodegenCx, t: ast::UintTy) -> Type {\n+    pub fn uint_from_ty(cx: &CodegenCx, t: ast::UintTy) -> Type {\n         match t {\n-            ast::UintTy::Usize => ccx.isize_ty,\n-            ast::UintTy::U8 => Type::i8(ccx),\n-            ast::UintTy::U16 => Type::i16(ccx),\n-            ast::UintTy::U32 => Type::i32(ccx),\n-            ast::UintTy::U64 => Type::i64(ccx),\n-            ast::UintTy::U128 => Type::i128(ccx),\n+            ast::UintTy::Usize => cx.isize_ty,\n+            ast::UintTy::U8 => Type::i8(cx),\n+            ast::UintTy::U16 => Type::i16(cx),\n+            ast::UintTy::U32 => Type::i32(cx),\n+            ast::UintTy::U64 => Type::i64(cx),\n+            ast::UintTy::U128 => Type::i128(cx),\n         }\n     }\n \n-    pub fn float_from_ty(ccx: &CodegenCx, t: ast::FloatTy) -> Type {\n+    pub fn float_from_ty(cx: &CodegenCx, t: ast::FloatTy) -> Type {\n         match t {\n-            ast::FloatTy::F32 => Type::f32(ccx),\n-            ast::FloatTy::F64 => Type::f64(ccx),\n+            ast::FloatTy::F32 => Type::f32(cx),\n+            ast::FloatTy::F64 => Type::f64(cx),\n         }\n     }\n \n@@ -186,16 +186,16 @@ impl Type {\n                                    args.len() as c_uint, True))\n     }\n \n-    pub fn struct_(ccx: &CodegenCx, els: &[Type], packed: bool) -> Type {\n+    pub fn struct_(cx: &CodegenCx, els: &[Type], packed: bool) -> Type {\n         let els: &[TypeRef] = Type::to_ref_slice(els);\n-        ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n+        ty!(llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool))\n     }\n \n-    pub fn named_struct(ccx: &CodegenCx, name: &str) -> Type {\n+    pub fn named_struct(cx: &CodegenCx, name: &str) -> Type {\n         let name = CString::new(name).unwrap();\n-        ty!(llvm::LLVMStructCreateNamed(ccx.llcx, name.as_ptr()))\n+        ty!(llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr()))\n     }\n \n \n@@ -278,23 +278,23 @@ impl Type {\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// as a conservative approximation for unknown pointee types.\n-    pub fn pointee_for_abi_align(ccx: &CodegenCx, align: Align) -> Type {\n+    pub fn pointee_for_abi_align(cx: &CodegenCx, align: Align) -> Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_abi_align(ccx, align);\n-        Type::from_integer(ccx, ity)\n+        let ity = layout::Integer::approximate_abi_align(cx, align);\n+        Type::from_integer(cx, ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    pub fn padding_filler(ccx: &CodegenCx, size: Size, align: Align) -> Type {\n-        let unit = layout::Integer::approximate_abi_align(ccx, align);\n+    pub fn padding_filler(cx: &CodegenCx, size: Size, align: Align) -> Type {\n+        let unit = layout::Integer::approximate_abi_align(cx, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n-        Type::array(&Type::from_integer(ccx, unit), size / unit_size)\n+        Type::array(&Type::from_integer(cx, unit), size / unit_size)\n     }\n \n-    pub fn x86_mmx(ccx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMX86MMXTypeInContext(ccx.llcx))\n+    pub fn x86_mmx(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMX86MMXTypeInContext(cx.llcx))\n     }\n }"}, {"sha": "b1533cfad19f524fd6e0e8baa5bb237fbbc8f0ff", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=e69dacb431fb65dfb1ed099c9e9ae74a212fbfa1", "patch": "@@ -19,7 +19,7 @@ use type_::Type;\n \n use std::fmt::Write;\n \n-fn uncached_llvm_type<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 layout: TyLayout<'tcx>,\n                                 defer: &mut Option<(Type, TyLayout<'tcx>)>)\n                                 -> Type {\n@@ -34,19 +34,19 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n             // one-element SIMD vectors, so it's assumed this won't clash with\n             // much else.\n             let use_x86_mmx = count == 1 && layout.size.bits() == 64 &&\n-                (ccx.sess().target.target.arch == \"x86\" ||\n-                 ccx.sess().target.target.arch == \"x86_64\");\n+                (cx.sess().target.target.arch == \"x86\" ||\n+                 cx.sess().target.target.arch == \"x86_64\");\n             if use_x86_mmx {\n-                return Type::x86_mmx(ccx)\n+                return Type::x86_mmx(cx)\n             } else {\n-                let element = layout.scalar_llvm_type_at(ccx, element, Size::from_bytes(0));\n+                let element = layout.scalar_llvm_type_at(cx, element, Size::from_bytes(0));\n                 return Type::vector(&element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n-            return Type::struct_(ccx, &[\n-                layout.scalar_pair_element_llvm_type(ccx, 0),\n-                layout.scalar_pair_element_llvm_type(ccx, 1),\n+            return Type::struct_(cx, &[\n+                layout.scalar_pair_element_llvm_type(cx, 0),\n+                layout.scalar_pair_element_llvm_type(cx, 1),\n             ], false);\n         }\n         layout::Abi::Uninhabited |\n@@ -61,7 +61,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         ty::TyForeign(..) |\n         ty::TyStr => {\n             let mut name = String::with_capacity(32);\n-            let printer = DefPathBasedNames::new(ccx.tcx, true, true);\n+            let printer = DefPathBasedNames::new(cx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name);\n             match (&layout.ty.sty, &layout.variants) {\n                 (&ty::TyAdt(def, _), &layout::Variants::Single { index }) => {\n@@ -78,30 +78,30 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let fill = Type::padding_filler(ccx, layout.size, layout.align);\n+            let fill = Type::padding_filler(cx, layout.size, layout.align);\n             let packed = false;\n             match name {\n                 None => {\n-                    Type::struct_(ccx, &[fill], packed)\n+                    Type::struct_(cx, &[fill], packed)\n                 }\n                 Some(ref name) => {\n-                    let mut llty = Type::named_struct(ccx, name);\n+                    let mut llty = Type::named_struct(cx, name);\n                     llty.set_struct_body(&[fill], packed);\n                     llty\n                 }\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(&layout.field(ccx, 0).llvm_type(ccx), count)\n+            Type::array(&layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n                 None => {\n-                    let (llfields, packed) = struct_llfields(ccx, layout);\n-                    Type::struct_(ccx, &llfields, packed)\n+                    let (llfields, packed) = struct_llfields(cx, layout);\n+                    Type::struct_(cx, &llfields, packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = Type::named_struct(ccx, name);\n+                    let llty = Type::named_struct(cx, name);\n                     *defer = Some((llty, layout));\n                     llty\n                 }\n@@ -110,7 +110,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n     }\n }\n \n-fn struct_llfields<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n+fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              layout: TyLayout<'tcx>)\n                              -> (Vec<Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n@@ -121,7 +121,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n     let mut prev_align = layout.align;\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n-        let field = layout.field(ccx, i);\n+        let field = layout.field(cx, i);\n         packed |= layout.align.abi() < field.align.abi();\n \n         let target_offset = layout.fields.offset(i as usize);\n@@ -131,10 +131,10 @@ fn struct_llfields<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         let padding = target_offset - offset;\n         let padding_align = layout.align.min(prev_align).min(field.align);\n         assert_eq!(offset.abi_align(padding_align) + padding, target_offset);\n-        result.push(Type::padding_filler(ccx, padding, padding_align));\n+        result.push(Type::padding_filler(cx, padding, padding_align));\n         debug!(\"    padding before: {:?}\", padding);\n \n-        result.push(field.llvm_type(ccx));\n+        result.push(field.llvm_type(cx));\n         offset = target_offset + field.size;\n         prev_align = field.align;\n     }\n@@ -148,7 +148,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n         assert_eq!(offset.abi_align(padding_align) + padding, layout.size);\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n-        result.push(Type::padding_filler(ccx, padding, padding_align));\n+        result.push(Type::padding_filler(cx, padding, padding_align));\n         assert!(result.len() == 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n@@ -197,14 +197,14 @@ pub struct PointeeInfo {\n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn is_llvm_scalar_pair<'a>(&self) -> bool;\n-    fn llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type;\n-    fn immediate_llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type;\n-    fn scalar_llvm_type_at<'a>(&self, ccx: &CodegenCx<'a, 'tcx>,\n+    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> Type;\n-    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>,\n+    fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                          index: usize) -> Type;\n     fn llvm_field_index(&self, index: usize) -> u64;\n-    fn pointee_info_at<'a>(&self, ccx: &CodegenCx<'a, 'tcx>, offset: Size)\n+    fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo>;\n }\n \n@@ -240,28 +240,28 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    fn llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n-            if let Some(&llty) = ccx.scalar_lltypes.borrow().get(&self.ty) {\n+            if let Some(&llty) = cx.scalar_lltypes.borrow().get(&self.ty) {\n                 return llty;\n             }\n             let llty = match self.ty.sty {\n                 ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n                 ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    ccx.layout_of(ty).llvm_type(ccx).ptr_to()\n+                    cx.layout_of(ty).llvm_type(cx).ptr_to()\n                 }\n                 ty::TyAdt(def, _) if def.is_box() => {\n-                    ccx.layout_of(self.ty.boxed_ty()).llvm_type(ccx).ptr_to()\n+                    cx.layout_of(self.ty.boxed_ty()).llvm_type(cx).ptr_to()\n                 }\n                 ty::TyFnPtr(sig) => {\n-                    let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n-                    FnType::new(ccx, sig, &[]).llvm_type(ccx).ptr_to()\n+                    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+                    FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n                 }\n-                _ => self.scalar_llvm_type_at(ccx, scalar, Size::from_bytes(0))\n+                _ => self.scalar_llvm_type_at(cx, scalar, Size::from_bytes(0))\n             };\n-            ccx.scalar_lltypes.borrow_mut().insert(self.ty, llty);\n+            cx.scalar_lltypes.borrow_mut().insert(self.ty, llty);\n             return llty;\n         }\n \n@@ -271,7 +271,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             layout::Variants::Single { index } => Some(index),\n             _ => None\n         };\n-        if let Some(&llty) = ccx.lltypes.borrow().get(&(self.ty, variant_index)) {\n+        if let Some(&llty) = cx.lltypes.borrow().get(&(self.ty, variant_index)) {\n             return llty;\n         }\n \n@@ -281,69 +281,69 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         // Make sure lifetimes are erased, to avoid generating distinct LLVM\n         // types for Rust types that only differ in the choice of lifetimes.\n-        let normal_ty = ccx.tcx.erase_regions(&self.ty);\n+        let normal_ty = cx.tcx.erase_regions(&self.ty);\n \n         let mut defer = None;\n         let llty = if self.ty != normal_ty {\n-            let mut layout = ccx.layout_of(normal_ty);\n+            let mut layout = cx.layout_of(normal_ty);\n             if let Some(v) = variant_index {\n-                layout = layout.for_variant(ccx, v);\n+                layout = layout.for_variant(cx, v);\n             }\n-            layout.llvm_type(ccx)\n+            layout.llvm_type(cx)\n         } else {\n-            uncached_llvm_type(ccx, *self, &mut defer)\n+            uncached_llvm_type(cx, *self, &mut defer)\n         };\n         debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n \n-        ccx.lltypes.borrow_mut().insert((self.ty, variant_index), llty);\n+        cx.lltypes.borrow_mut().insert((self.ty, variant_index), llty);\n \n         if let Some((mut llty, layout)) = defer {\n-            let (llfields, packed) = struct_llfields(ccx, layout);\n+            let (llfields, packed) = struct_llfields(cx, layout);\n             llty.set_struct_body(&llfields, packed)\n         }\n \n         llty\n     }\n \n-    fn immediate_llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n-                return Type::i1(ccx);\n+                return Type::i1(cx);\n             }\n         }\n-        self.llvm_type(ccx)\n+        self.llvm_type(cx)\n     }\n \n-    fn scalar_llvm_type_at<'a>(&self, ccx: &CodegenCx<'a, 'tcx>,\n+    fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> Type {\n         match scalar.value {\n-            layout::Int(i, _) => Type::from_integer(ccx, i),\n-            layout::F32 => Type::f32(ccx),\n-            layout::F64 => Type::f64(ccx),\n+            layout::Int(i, _) => Type::from_integer(cx, i),\n+            layout::F32 => Type::f32(cx),\n+            layout::F64 => Type::f64(cx),\n             layout::Pointer => {\n                 // If we know the alignment, pick something better than i8.\n-                let pointee = if let Some(pointee) = self.pointee_info_at(ccx, offset) {\n-                    Type::pointee_for_abi_align(ccx, pointee.align)\n+                let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n+                    Type::pointee_for_abi_align(cx, pointee.align)\n                 } else {\n-                    Type::i8(ccx)\n+                    Type::i8(cx)\n                 };\n                 pointee.ptr_to()\n             }\n         }\n     }\n \n-    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>,\n+    fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                          index: usize) -> Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.sty {\n             ty::TyRef(..) |\n             ty::TyRawPtr(_) => {\n-                return self.field(ccx, index).llvm_type(ccx);\n+                return self.field(cx, index).llvm_type(cx);\n             }\n             ty::TyAdt(def, _) if def.is_box() => {\n-                let ptr_ty = ccx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n-                return ccx.layout_of(ptr_ty).scalar_pair_element_llvm_type(ccx, index);\n+                let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n+                return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index);\n             }\n             _ => {}\n         }\n@@ -362,15 +362,15 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         // load/store `bool` as `i8` to avoid crippling LLVM optimizations,\n         // `i1` in a LLVM aggregate is valid and mostly equivalent to `i8`.\n         if scalar.is_bool() {\n-            return Type::i1(ccx);\n+            return Type::i1(cx);\n         }\n \n         let offset = if index == 0 {\n             Size::from_bytes(0)\n         } else {\n-            a.value.size(ccx).abi_align(b.value.align(ccx))\n+            a.value.size(cx).abi_align(b.value.align(cx))\n         };\n-        self.scalar_llvm_type_at(ccx, scalar, offset)\n+        self.scalar_llvm_type_at(cx, scalar, offset)\n     }\n \n     fn llvm_field_index(&self, index: usize) -> u64 {\n@@ -396,16 +396,16 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn pointee_info_at<'a>(&self, ccx: &CodegenCx<'a, 'tcx>, offset: Size)\n+    fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo> {\n-        if let Some(&pointee) = ccx.pointee_infos.borrow().get(&(self.ty, offset)) {\n+        if let Some(&pointee) = cx.pointee_infos.borrow().get(&(self.ty, offset)) {\n             return pointee;\n         }\n \n         let mut result = None;\n         match self.ty.sty {\n             ty::TyRawPtr(mt) if offset.bytes() == 0 => {\n-                let (size, align) = ccx.size_and_align_of(mt.ty);\n+                let (size, align) = cx.size_and_align_of(mt.ty);\n                 result = Some(PointeeInfo {\n                     size,\n                     align,\n@@ -414,17 +414,17 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             }\n \n             ty::TyRef(_, mt) if offset.bytes() == 0 => {\n-                let (size, align) = ccx.size_and_align_of(mt.ty);\n+                let (size, align) = cx.size_and_align_of(mt.ty);\n \n                 let kind = match mt.mutbl {\n-                    hir::MutImmutable => if ccx.type_is_freeze(mt.ty) {\n+                    hir::MutImmutable => if cx.type_is_freeze(mt.ty) {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared\n                     },\n                     hir::MutMutable => {\n-                        if ccx.tcx.sess.opts.debugging_opts.mutable_noalias ||\n-                           ccx.tcx.sess.panic_strategy() == PanicStrategy::Abort {\n+                        if cx.tcx.sess.opts.debugging_opts.mutable_noalias ||\n+                           cx.tcx.sess.panic_strategy() == PanicStrategy::Abort {\n                             PointerKind::UniqueBorrowed\n                         } else {\n                             PointerKind::Shared\n@@ -454,7 +454,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         // niches than just null (e.g. the first page\n                         // of the address space, or unaligned pointers).\n                         if self.fields.offset(0) == offset {\n-                            Some(self.for_variant(ccx, dataful_variant))\n+                            Some(self.for_variant(cx, dataful_variant))\n                         } else {\n                             None\n                         }\n@@ -470,14 +470,14 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 }\n \n                 if let Some(variant) = data_variant {\n-                    let ptr_end = offset + layout::Pointer.size(ccx);\n+                    let ptr_end = offset + layout::Pointer.size(cx);\n                     for i in 0..variant.fields.count() {\n                         let field_start = variant.fields.offset(i);\n                         if field_start <= offset {\n-                            let field = variant.field(ccx, i);\n+                            let field = variant.field(cx, i);\n                             if ptr_end <= field_start + field.size {\n                                 // We found the right field, look inside it.\n-                                result = field.pointee_info_at(ccx, offset - field_start);\n+                                result = field.pointee_info_at(cx, offset - field_start);\n                                 break;\n                             }\n                         }\n@@ -495,7 +495,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             }\n         }\n \n-        ccx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n+        cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result\n     }\n }"}]}