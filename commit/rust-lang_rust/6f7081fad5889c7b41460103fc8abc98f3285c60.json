{"sha": "6f7081fad5889c7b41460103fc8abc98f3285c60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNzA4MWZhZDU4ODljN2I0MTQ2MDEwM2ZjOGFiYzk4ZjMyODVjNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-14T05:37:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-14T05:37:17Z"}, "message": "auto merge of #18827 : bjz/rust/rfc369-numerics, r=alexcrichton\n\nThis implements a considerable portion of rust-lang/rfcs#369 (tracked in #18640). Some interpretations had to be made in order to get this to work. The breaking changes are listed below:\r\n\r\n[breaking-change]\r\n\r\n- `core::num::{Num, Unsigned, Primitive}` have been deprecated and their re-exports removed from the `{std, core}::prelude`.\r\n- `core::num::{Zero, One, Bounded}` have been deprecated. Use the static methods on `core::num::{Float, Int}` instead. There is no equivalent to `Zero::is_zero`. Use `(==)` with `{Float, Int}::zero` instead.\r\n- `Signed::abs_sub` has been moved to `std::num::FloatMath`, and is no longer implemented for signed integers.\r\n- `core::num::Signed` has been removed, and its methods have been moved to `core::num::Float` and a new trait, `core::num::SignedInt`. The methods now take the `self` parameter by value.\r\n- `core::num::{Saturating, CheckedAdd, CheckedSub, CheckedMul, CheckedDiv}` have been removed, and their methods moved to `core::num::Int`. Their parameters are now taken by value. This means that\r\n- `std::time::Duration` no longer implements `core::num::{Zero, CheckedAdd, CheckedSub}` instead defining the required methods non-polymorphically.\r\n- `core::num::{zero, one, abs, signum}` have been deprecated. Use their respective methods instead.\r\n- The `core::num::{next_power_of_two, is_power_of_two, checked_next_power_of_two}` functions have been deprecated in favor of methods defined a new trait, `core::num::UnsignedInt`\r\n- `core::iter::{AdditiveIterator, MultiplicativeIterator}` are now only implemented for the built-in numeric types.\r\n- `core::iter::{range, range_inclusive, range_step, range_step_inclusive}` now require `core::num::Int` to be implemented for the type they a re parametrized over.", "tree": {"sha": "1c6785eb621540294408e54c1e811ba81e9412de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c6785eb621540294408e54c1e811ba81e9412de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f7081fad5889c7b41460103fc8abc98f3285c60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f7081fad5889c7b41460103fc8abc98f3285c60", "html_url": "https://github.com/rust-lang/rust/commit/6f7081fad5889c7b41460103fc8abc98f3285c60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f7081fad5889c7b41460103fc8abc98f3285c60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a58fc68223f177b6790a6b4027bb6761031e9fa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a58fc68223f177b6790a6b4027bb6761031e9fa8", "html_url": "https://github.com/rust-lang/rust/commit/a58fc68223f177b6790a6b4027bb6761031e9fa8"}, {"sha": "c9e6bda9c758538e795ab387915543e076c35805", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e6bda9c758538e795ab387915543e076c35805", "html_url": "https://github.com/rust-lang/rust/commit/c9e6bda9c758538e795ab387915543e076c35805"}], "stats": {"total": 2173, "additions": 1137, "deletions": 1036}, "files": [{"sha": "e3c050f0e90160f28ae6744521557805e1e62254", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -51,6 +51,7 @@ expensive. So we'd like to define a function that takes the points just as\n a reference.\n \n ~~~\n+# use std::num::Float;\n # struct Point {x: f64, y: f64}\n # fn sqrt(f: f64) -> f64 { 0.0 }\n fn compute_distance(p1: &Point, p2: &Point) -> f64 {"}, {"sha": "c2309ba479ea605dc3373a3456bff698221f1f51", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -225,6 +225,7 @@ Here is another example showing how futures allow you to background\n computations. The workload will be distributed on the available cores.\n \n ```{rust}\n+# use std::num::Float;\n # use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n@@ -262,6 +263,7 @@ several computations on a single large vector of floats. Each task needs the\n full vector to perform its duty.\n \n ```{rust}\n+use std::num::Float;\n use std::rand;\n use std::sync::Arc;\n "}, {"sha": "710092a3e5f37e168898774fcd7c8a806351fe2a", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -97,8 +97,7 @@ syn keyword rustTrait FromIterator IntoIterator Extend ExactSize\n syn keyword rustTrait Iterator DoubleEndedIterator\n syn keyword rustTrait RandomAccessIterator CloneableIterator\n syn keyword rustTrait OrdIterator MutableDoubleEndedIterator\n-syn keyword rustTrait Num NumCast CheckedAdd CheckedSub CheckedMul CheckedDiv\n-syn keyword rustTrait Signed Unsigned Primitive Int Float\n+syn keyword rustTrait NumCast Int SignedInt UnsignedInt Float\n syn keyword rustTrait FloatMath ToPrimitive FromPrimitive\n syn keyword rustTrait Box\n syn keyword rustTrait GenericPath Path PosixPath WindowsPath"}, {"sha": "33d4406b733c1e8ae3629f5d217d78a64fcf2b44", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -38,7 +38,7 @@ use std::cmp;\n use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n use std::mem;\n-use std::num;\n+use std::num::{Int, UnsignedInt};\n use std::ptr;\n use std::rc::Rc;\n use std::rt::heap::{allocate, deallocate};\n@@ -132,7 +132,7 @@ impl Drop for Arena {\n \n #[inline]\n fn round_up(base: uint, align: uint) -> uint {\n-    (base.checked_add(&(align - 1))).unwrap() & !(align - 1)\n+    (base.checked_add(align - 1)).unwrap() & !(align - 1)\n }\n \n // Walk down a chunk, running the destructors for any objects stored\n@@ -187,7 +187,7 @@ impl Arena {\n         self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n \n         *self.copy_head.borrow_mut() =\n-            chunk(num::next_power_of_two(new_min_chunk_size + 1u), true);\n+            chunk((new_min_chunk_size + 1u).next_power_of_two(), true);\n \n         return self.alloc_copy_inner(n_bytes, align);\n     }\n@@ -228,7 +228,7 @@ impl Arena {\n         self.chunks.borrow_mut().push(self.head.borrow().clone());\n \n         *self.head.borrow_mut() =\n-            chunk(num::next_power_of_two(new_min_chunk_size + 1u), false);\n+            chunk((new_min_chunk_size + 1u).next_power_of_two(), false);\n \n         return self.alloc_noncopy_inner(n_bytes, align);\n     }\n@@ -376,8 +376,8 @@ fn calculate_size<T>(capacity: uint) -> uint {\n     let mut size = mem::size_of::<TypedArenaChunk<T>>();\n     size = round_up(size, mem::min_align_of::<T>());\n     let elem_size = mem::size_of::<T>();\n-    let elems_size = elem_size.checked_mul(&capacity).unwrap();\n-    size = size.checked_add(&elems_size).unwrap();\n+    let elems_size = elem_size.checked_mul(capacity).unwrap();\n+    size = size.checked_add(elems_size).unwrap();\n     size\n }\n \n@@ -432,7 +432,7 @@ impl<T> TypedArenaChunk<T> {\n     #[inline]\n     fn end(&self) -> *const u8 {\n         unsafe {\n-            let size = mem::size_of::<T>().checked_mul(&self.capacity).unwrap();\n+            let size = mem::size_of::<T>().checked_mul(self.capacity).unwrap();\n             self.start().offset(size as int)\n         }\n     }\n@@ -481,7 +481,7 @@ impl<T> TypedArena<T> {\n     fn grow(&self) {\n         unsafe {\n             let chunk = *self.first.borrow_mut();\n-            let new_capacity = (*chunk).capacity.checked_mul(&2).unwrap();\n+            let new_capacity = (*chunk).capacity.checked_mul(2).unwrap();\n             let chunk = TypedArenaChunk::<T>::new(chunk, new_capacity);\n             self.ptr.set((*chunk).start() as *const T);\n             self.end.set((*chunk).end() as *const T);"}, {"sha": "bfb5a010ed80dbc36432cec575f1454cda020a6f", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -22,6 +22,7 @@\n //!\n //! ```\n //! use std::collections::{BitvSet, Bitv};\n+//! use std::num::Float;\n //! use std::iter;\n //!\n //! let max_prime = 10000;\n@@ -69,6 +70,7 @@ use core::default::Default;\n use core::fmt;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take};\n use core::iter;\n+use core::num::Int;\n use core::slice;\n use core::u32;\n use std::hash;"}, {"sha": "ac8e45f9f9417aeca85d67f7e1c6873e11fe4e58", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -15,6 +15,7 @@\n \n use core::prelude::*;\n use core::fmt;\n+use core::num::Int;\n \n // FIXME(contentions): implement union family of methods? (general design may be wrong here)\n "}, {"sha": "6082a0ca0137cc0f0997ab38419b33d591dc9315", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -69,6 +69,7 @@ use alloc::boxed::Box;\n use alloc::rc::Rc;\n use core::intrinsics::TypeId;\n use core::mem;\n+use core::num::Int;\n \n use vec::Vec;\n "}, {"sha": "ca9a44a15f20547c47d58d5c34ad7d2e445a1e66", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -21,7 +21,7 @@ use core::default::Default;\n use core::fmt;\n use core::kinds::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n-use core::num;\n+use core::num::{Int, UnsignedInt};\n use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n@@ -161,7 +161,7 @@ impl<T> Vec<T> {\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n-            let size = capacity.checked_mul(&mem::size_of::<T>())\n+            let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             Vec { ptr: ptr as *mut T, len: 0, cap: capacity }\n@@ -587,11 +587,11 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n-            match self.len.checked_add(&additional) {\n+            match self.len.checked_add(additional) {\n                 None => panic!(\"Vec::reserve: `uint` overflow\"),\n                 // if the checked_add\n                 Some(new_cap) => {\n-                    let amort_cap = num::next_power_of_two(new_cap);\n+                    let amort_cap = new_cap.next_power_of_two();\n                     // next_power_of_two will overflow to exactly 0 for really big capacities\n                     if amort_cap == 0 {\n                         self.grow_capacity(new_cap);\n@@ -624,7 +624,7 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n-            match self.len.checked_add(&additional) {\n+            match self.len.checked_add(additional) {\n                 None => panic!(\"Vec::reserve: `uint` overflow\"),\n                 Some(new_cap) => self.grow_capacity(new_cap)\n             }\n@@ -957,7 +957,7 @@ impl<T> Vec<T> {\n     pub fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the address space running out\n-            self.len = self.len.checked_add(&1).expect(\"length overflow\");\n+            self.len = self.len.checked_add(1).expect(\"length overflow\");\n             unsafe { mem::forget(value); }\n             return\n         }\n@@ -1050,7 +1050,7 @@ impl<T> Vec<T> {\n         if mem::size_of::<T>() == 0 { return }\n \n         if capacity > self.cap {\n-            let size = capacity.checked_mul(&mem::size_of::<T>())\n+            let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n                 self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);"}, {"sha": "dfa339433c846ff110708844c5f6f9ce7df7dda5", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -19,6 +19,8 @@\n //! operators, you could do the following:\n //!\n //! ```rust\n+//! use core::num::SignedInt;\n+//!\n //! // Our type.\n //! struct SketchyNum {\n //!     num : int"}, {"sha": "ec920ddc6dbc584407c4d1e18b47a351da97fcb8", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -13,8 +13,8 @@\n use char;\n use fmt;\n use iter::{range, DoubleEndedIterator};\n-use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n-use num::{Zero, One, cast};\n+use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n+use num::cast;\n use result::Ok;\n use slice::{mod, SlicePrelude};\n use str::StrPrelude;\n@@ -79,7 +79,7 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n-pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n+pub fn float_to_str_bytes_common<T: Float, U>(\n     num: T,\n     radix: uint,\n     negative_zero: bool,\n@@ -97,8 +97,8 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         _ => ()\n     }\n \n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n+    let _0: T = Float::zero();\n+    let _1: T = Float::one();\n \n     match num.classify() {\n         FPNaN => return f(\"NaN\".as_bytes()),"}, {"sha": "380ca82783adb5829e46c6c469069f955de47880", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -620,7 +620,7 @@ impl<'a, T> Pointer for &'a mut T {\n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::{Float, Signed};\n+            use num::Float;\n \n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),\n@@ -641,7 +641,7 @@ macro_rules! floating(($ty:ident) => {\n \n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::{Float, Signed};\n+            use num::Float;\n \n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),\n@@ -662,7 +662,7 @@ macro_rules! floating(($ty:ident) => {\n \n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::{Float, Signed};\n+            use num::Float;\n \n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),"}, {"sha": "0a5af56217c8ddbab8e8297bd15fd0bf6e6348a7", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -16,7 +16,7 @@\n \n use fmt;\n use iter::DoubleEndedIterator;\n-use num::{Int, cast, zero};\n+use num::{Int, cast};\n use slice::SlicePrelude;\n \n /// A type that represents a specific radix\n@@ -35,10 +35,11 @@ trait GenericRadix {\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n         // The radix can be as low as 2, so we need a buffer of at least 64\n         // characters for a base 2 number.\n+        let zero = Int::zero();\n+        let is_positive = x >= zero;\n         let mut buf = [0u8, ..64];\n-        let base = cast(self.base()).unwrap();\n         let mut curr = buf.len();\n-        let is_positive = x >= zero();\n+        let base = cast(self.base()).unwrap();\n         if is_positive {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n@@ -47,16 +48,16 @@ trait GenericRadix {\n                 x = x / base;                             // Deaccumulate the number.\n                 *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero() { break; }                 // No more digits left to accumulate.\n+                if x == zero { break };                   // No more digits left to accumulate.\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n             for byte in buf.iter_mut().rev() {\n-                let n = -(x % base);                      // Get the current place value.\n+                let n = zero - (x % base);                // Get the current place value.\n                 x = x / base;                             // Deaccumulate the number.\n                 *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero() { break; }                 // No more digits left to accumulate.\n+                if x == zero { break };                   // No more digits left to accumulate.\n             }\n         }\n         f.pad_integral(is_positive, self.prefix(), buf[curr..])"}, {"sha": "774aa8a66d2886cd5e5e2e45513bdd5000a6e94e", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 90, "deletions": 47, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -60,10 +60,10 @@ This `for` loop syntax can be applied to any iterator over any type.\n \n use clone::Clone;\n use cmp;\n-use cmp::{PartialEq, PartialOrd, Ord};\n+use cmp::Ord;\n use mem;\n-use num::{Zero, One, CheckedAdd, CheckedSub, Saturating, ToPrimitive, Int};\n-use ops::{Add, Mul, Sub};\n+use num::{ToPrimitive, Int};\n+use ops::Add;\n use option::{Option, Some, None};\n use uint;\n #[deprecated = \"renamed to Extend\"] pub use self::Extend as Extendable;\n@@ -573,6 +573,8 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// use core::num::SignedInt;\n+    ///\n     /// let xs = [-3i, 0, 1, 5, -10];\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n@@ -597,6 +599,8 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// use core::num::SignedInt;\n+    ///\n     /// let xs = [-3i, 0, 1, 5, -10];\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n@@ -785,13 +789,28 @@ pub trait AdditiveIterator<A> {\n     fn sum(&mut self) -> A;\n }\n \n-impl<A: Add<A, A> + Zero, T: Iterator<A>> AdditiveIterator<A> for T {\n-    #[inline]\n-    fn sum(&mut self) -> A {\n-        let zero: A = Zero::zero();\n-        self.fold(zero, |s, x| s + x)\n-    }\n-}\n+macro_rules! impl_additive {\n+    ($A:ty, $init:expr) => {\n+        impl<T: Iterator<$A>> AdditiveIterator<$A> for T {\n+            #[inline]\n+            fn sum(&mut self) -> $A {\n+                self.fold($init, |acc, x| acc + x)\n+            }\n+        }\n+    };\n+}\n+impl_additive!(i8,   0)\n+impl_additive!(i16,  0)\n+impl_additive!(i32,  0)\n+impl_additive!(i64,  0)\n+impl_additive!(int,  0)\n+impl_additive!(u8,   0)\n+impl_additive!(u16,  0)\n+impl_additive!(u32,  0)\n+impl_additive!(u64,  0)\n+impl_additive!(uint, 0)\n+impl_additive!(f32,  0.0)\n+impl_additive!(f64,  0.0)\n \n /// A trait for iterators over elements which can be multiplied together.\n pub trait MultiplicativeIterator<A> {\n@@ -812,13 +831,28 @@ pub trait MultiplicativeIterator<A> {\n     fn product(&mut self) -> A;\n }\n \n-impl<A: Mul<A, A> + One, T: Iterator<A>> MultiplicativeIterator<A> for T {\n-    #[inline]\n-    fn product(&mut self) -> A {\n-        let one: A = One::one();\n-        self.fold(one, |p, x| p * x)\n-    }\n-}\n+macro_rules! impl_multiplicative {\n+    ($A:ty, $init:expr) => {\n+        impl<T: Iterator<$A>> MultiplicativeIterator<$A> for T {\n+            #[inline]\n+            fn product(&mut self) -> $A {\n+                self.fold($init, |acc, x| acc * x)\n+            }\n+        }\n+    };\n+}\n+impl_multiplicative!(i8,   1)\n+impl_multiplicative!(i16,  1)\n+impl_multiplicative!(i32,  1)\n+impl_multiplicative!(i64,  1)\n+impl_multiplicative!(int,  1)\n+impl_multiplicative!(u8,   1)\n+impl_multiplicative!(u16,  1)\n+impl_multiplicative!(u32,  1)\n+impl_multiplicative!(u64,  1)\n+impl_multiplicative!(uint, 1)\n+impl_multiplicative!(f32,  1.0)\n+impl_multiplicative!(f64,  1.0)\n \n /// A trait for iterators over elements which can be compared to one another.\n pub trait OrdIterator<A> {\n@@ -1093,7 +1127,7 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n         let lower = a_lower.saturating_add(b_lower);\n \n         let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => x.checked_add(&y),\n+            (Some(x), Some(y)) => x.checked_add(y),\n             _ => None\n         };\n \n@@ -1415,7 +1449,7 @@ impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n         if self.peeked.is_some() {\n             let lo = lo.saturating_add(1);\n             let hi = match hi {\n-                Some(x) => x.checked_add(&1),\n+                Some(x) => x.checked_add(1),\n                 None => None\n             };\n             (lo, hi)\n@@ -1680,7 +1714,7 @@ impl<'a, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'a, A, T,\n         let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n-            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(&b)),\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n             _ => (lo, None)\n         }\n     }\n@@ -1905,7 +1939,7 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n pub struct Range<A> {\n     state: A,\n     stop: A,\n-    one: A\n+    one: A,\n }\n \n /// Returns an iterator over the given range [start, stop) (that is, starting\n@@ -1922,12 +1956,16 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n-pub fn range<A: Add<A, A> + PartialOrd + Clone + One>(start: A, stop: A) -> Range<A> {\n-    Range{state: start, stop: stop, one: One::one()}\n+pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n+    Range {\n+        state: start,\n+        stop: stop,\n+        one: Int::one(),\n+    }\n }\n \n // FIXME: #10414: Unfortunate type bound\n-impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for Range<A> {\n+impl<A: Int + ToPrimitive> Iterator<A> for Range<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.state < self.stop {\n@@ -1946,15 +1984,15 @@ impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for Range<A> {\n         // the i64/u64 might lie within their range.\n         let bound = match self.state.to_i64() {\n             Some(a) => {\n-                let sz = self.stop.to_i64().map(|b| b.checked_sub(&a));\n+                let sz = self.stop.to_i64().map(|b| b.checked_sub(a));\n                 match sz {\n                     Some(Some(bound)) => bound.to_uint(),\n                     _ => None,\n                 }\n             },\n             None => match self.state.to_u64() {\n                 Some(a) => {\n-                    let sz = self.stop.to_u64().map(|b| b.checked_sub(&a));\n+                    let sz = self.stop.to_u64().map(|b| b.checked_sub(a));\n                     match sz {\n                         Some(Some(bound)) => bound.to_uint(),\n                         _ => None\n@@ -1974,7 +2012,7 @@ impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-impl<A: Int + PartialOrd + Clone + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n+impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.stop > self.state {\n@@ -1995,12 +2033,14 @@ pub struct RangeInclusive<A> {\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-pub fn range_inclusive<A: Add<A, A> + PartialOrd + Clone + One>(start: A, stop: A)\n-    -> RangeInclusive<A> {\n-    RangeInclusive{range: range(start, stop), done: false}\n+pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n+    RangeInclusive {\n+        range: range(start, stop),\n+        done: false,\n+    }\n }\n \n-impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n+impl<A: Int + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.range.next() {\n@@ -2024,16 +2064,15 @@ impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for RangeInclu\n         } else {\n             let lo = lo.saturating_add(1);\n             let hi = match hi {\n-                Some(x) => x.checked_add(&1),\n+                Some(x) => x.checked_add(1),\n                 None => None\n             };\n             (lo, hi)\n         }\n     }\n }\n \n-impl<A: Sub<A, A> + Int + PartialOrd + Clone + ToPrimitive> DoubleEndedIterator<A>\n-    for RangeInclusive<A> {\n+impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.range.stop > self.range.state {\n@@ -2060,18 +2099,17 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-pub fn range_step<A: CheckedAdd + PartialOrd +\n-                  Clone + Zero>(start: A, stop: A, step: A) -> RangeStep<A> {\n-    let rev = step < Zero::zero();\n+pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n+    let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-impl<A: CheckedAdd + PartialOrd + Clone> Iterator<A> for RangeStep<A> {\n+impl<A: Int> Iterator<A> for RangeStep<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if (self.rev && self.state > self.stop) || (!self.rev && self.state < self.stop) {\n-            let result = self.state.clone();\n-            match self.state.checked_add(&self.step) {\n+            let result = self.state;\n+            match self.state.checked_add(self.step) {\n                 Some(x) => self.state = x,\n                 None => self.state = self.stop.clone()\n             }\n@@ -2094,19 +2132,24 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-pub fn range_step_inclusive<A: CheckedAdd + PartialOrd + Clone + Zero>(start: A, stop: A,\n-                                                                step: A) -> RangeStepInclusive<A> {\n-    let rev = step < Zero::zero();\n-    RangeStepInclusive{state: start, stop: stop, step: step, rev: rev, done: false}\n+pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n+    let rev = step < Int::zero();\n+    RangeStepInclusive {\n+        state: start,\n+        stop: stop,\n+        step: step,\n+        rev: rev,\n+        done: false,\n+    }\n }\n \n-impl<A: CheckedAdd + PartialOrd + Clone + PartialEq> Iterator<A> for RangeStepInclusive<A> {\n+impl<A: Int> Iterator<A> for RangeStepInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if !self.done && ((self.rev && self.state >= self.stop) ||\n                           (!self.rev && self.state <= self.stop)) {\n-            let result = self.state.clone();\n-            match self.state.checked_add(&self.step) {\n+            let result = self.state;\n+            match self.state.checked_add(self.step) {\n                 Some(x) => self.state = x,\n                 None => self.done = true\n             }"}, {"sha": "ba03bb8f3d5c1146b3dacfe38dccf4026cdb0eaa", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -114,9 +114,15 @@ impl Float for f32 {\n     #[inline]\n     fn neg_infinity() -> f32 { NEG_INFINITY }\n \n+    #[inline]\n+    fn zero() -> f32 { 0.0 }\n+\n     #[inline]\n     fn neg_zero() -> f32 { -0.0 }\n \n+    #[inline]\n+    fn one() -> f32 { 1.0 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n@@ -177,9 +183,15 @@ impl Float for f32 {\n     #[inline]\n     fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n \n+    #[inline]\n+    fn min_value() -> f32 { MIN_VALUE }\n+\n     #[inline]\n     fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n \n+    #[inline]\n+    fn max_value() -> f32 { MAX_VALUE }\n+\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u32 = unsafe { mem::transmute(self) };\n@@ -222,12 +234,49 @@ impl Float for f32 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```rust\n+    /// use core::num::Float;\n+    ///\n     /// let x = 1.65f32;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```\n     #[inline]\n     fn fract(self) -> f32 { self - self.trunc() }\n \n+    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n+    /// number is `Float::nan()`.\n+    #[inline]\n+    fn abs(self) -> f32 {\n+        unsafe { intrinsics::fabsf32(self) }\n+    }\n+\n+    /// Returns a number that represents the sign of `self`.\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n+    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n+    /// - `Float::nan()` if the number is `Float::nan()`\n+    #[inline]\n+    fn signum(self) -> f32 {\n+        if self.is_nan() {\n+            Float::nan()\n+        } else {\n+            unsafe { intrinsics::copysignf32(1.0, self) }\n+        }\n+    }\n+\n+    /// Returns `true` if `self` is positive, including `+0.0` and\n+    /// `Float::infinity()`.\n+    #[inline]\n+    fn is_positive(self) -> bool {\n+        self > 0.0 || (1.0 / self) == Float::infinity()\n+    }\n+\n+    /// Returns `true` if `self` is negative, including `-0.0` and\n+    /// `Float::neg_infinity()`.\n+    #[inline]\n+    fn is_negative(self) -> bool {\n+        self < 0.0 || (1.0 / self) == Float::neg_infinity()\n+    }\n+\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n@@ -240,6 +289,7 @@ impl Float for f32 {\n     #[inline]\n     fn recip(self) -> f32 { 1.0 / self }\n \n+    #[inline]\n     fn powi(self, n: i32) -> f32 {\n         unsafe { intrinsics::powif32(self, n) }\n     }"}, {"sha": "f1af4f0272c6bba9db9d54d904c2ecca3b127551", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -120,9 +120,15 @@ impl Float for f64 {\n     #[inline]\n     fn neg_infinity() -> f64 { NEG_INFINITY }\n \n+    #[inline]\n+    fn zero() -> f64 { 0.0 }\n+\n     #[inline]\n     fn neg_zero() -> f64 { -0.0 }\n \n+    #[inline]\n+    fn one() -> f64 { 1.0 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n@@ -183,9 +189,15 @@ impl Float for f64 {\n     #[inline]\n     fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n \n+    #[inline]\n+    fn min_value() -> f64 { MIN_VALUE }\n+\n     #[inline]\n     fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n \n+    #[inline]\n+    fn max_value() -> f64 { MAX_VALUE }\n+\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u64 = unsafe { mem::transmute(self) };\n@@ -228,12 +240,49 @@ impl Float for f64 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```rust\n+    /// use core::num::Float;\n+    ///\n     /// let x = 1.65f64;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```\n     #[inline]\n     fn fract(self) -> f64 { self - self.trunc() }\n \n+    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n+    /// number is `Float::nan()`.\n+    #[inline]\n+    fn abs(self) -> f64 {\n+        unsafe { intrinsics::fabsf64(self) }\n+    }\n+\n+    /// Returns a number that represents the sign of `self`.\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n+    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n+    /// - `Float::nan()` if the number is `Float::nan()`\n+    #[inline]\n+    fn signum(self) -> f64 {\n+        if self.is_nan() {\n+            Float::nan()\n+        } else {\n+            unsafe { intrinsics::copysignf64(1.0, self) }\n+        }\n+    }\n+\n+    /// Returns `true` if `self` is positive, including `+0.0` and\n+    /// `Float::infinity()`.\n+    #[inline]\n+    fn is_positive(self) -> bool {\n+        self > 0.0 || (1.0 / self) == Float::infinity()\n+    }\n+\n+    /// Returns `true` if `self` is negative, including `-0.0` and\n+    /// `Float::neg_infinity()`.\n+    #[inline]\n+    fn is_negative(self) -> bool {\n+        self < 0.0 || (1.0 / self) == Float::neg_infinity()\n+    }\n+\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add."}, {"sha": "d15cff3a8a9e38731789ac1551ad4d6e54c688e3", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -13,6 +13,7 @@\n \n macro_rules! assert_approx_eq(\n     ($a:expr, $b:expr) => ({\n+        use num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "216d140ac48974474b7ca081424bbf613ee8e161", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 581, "deletions": 638, "changes": 1219, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -10,7 +10,7 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-//! Numeric traits and functions for generic mathematics\n+//! Numeric traits and functions for the built-in numeric types.\n \n #![allow(missing_docs)]\n \n@@ -19,298 +19,21 @@ use {int, i8, i16, i32, i64};\n use {uint, u8, u16, u32, u64};\n use {f32, f64};\n use clone::Clone;\n-use cmp::{Ord, PartialEq, PartialOrd};\n+use cmp::{PartialEq, Eq};\n+use cmp::{PartialOrd, Ord};\n use kinds::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n \n-/// The base trait for numeric types\n-pub trait Num: PartialEq + Zero + One\n-             + Neg<Self>\n-             + Add<Self,Self>\n-             + Sub<Self,Self>\n-             + Mul<Self,Self>\n-             + Div<Self,Self>\n-             + Rem<Self,Self> {}\n-\n-macro_rules! trait_impl(\n-    ($name:ident for $($t:ty)*) => ($(\n-        impl $name for $t {}\n-    )*)\n-)\n-\n-trait_impl!(Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n-\n /// Simultaneous division and remainder\n #[inline]\n pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n     (x / y, x % y)\n }\n \n-/// Defines an additive identity element for `Self`.\n-///\n-/// # Deriving\n-///\n-/// This trait can be automatically be derived using `#[deriving(Zero)]`\n-/// attribute. If you choose to use this, make sure that the laws outlined in\n-/// the documentation for `Zero::zero` still hold.\n-pub trait Zero: Add<Self, Self> {\n-    /// Returns the additive identity element of `Self`, `0`.\n-    ///\n-    /// # Laws\n-    ///\n-    /// ```{.text}\n-    /// a + 0 = a       \u2200 a \u2208 Self\n-    /// 0 + a = a       \u2200 a \u2208 Self\n-    /// ```\n-    ///\n-    /// # Purity\n-    ///\n-    /// This function should return the same result at all times regardless of\n-    /// external mutable state, for example values stored in TLS or in\n-    /// `static mut`s.\n-    // FIXME (#5527): This should be an associated constant\n-    fn zero() -> Self;\n-\n-    /// Returns `true` if `self` is equal to the additive identity.\n-    #[inline]\n-    fn is_zero(&self) -> bool;\n-}\n-\n-macro_rules! zero_impl(\n-    ($t:ty, $v:expr) => {\n-        impl Zero for $t {\n-            #[inline]\n-            fn zero() -> $t { $v }\n-            #[inline]\n-            fn is_zero(&self) -> bool { *self == $v }\n-        }\n-    }\n-)\n-\n-zero_impl!(uint, 0u)\n-zero_impl!(u8,   0u8)\n-zero_impl!(u16,  0u16)\n-zero_impl!(u32,  0u32)\n-zero_impl!(u64,  0u64)\n-\n-zero_impl!(int, 0i)\n-zero_impl!(i8,  0i8)\n-zero_impl!(i16, 0i16)\n-zero_impl!(i32, 0i32)\n-zero_impl!(i64, 0i64)\n-\n-zero_impl!(f32, 0.0f32)\n-zero_impl!(f64, 0.0f64)\n-\n-/// Returns the additive identity, `0`.\n-#[inline(always)] pub fn zero<T: Zero>() -> T { Zero::zero() }\n-\n-/// Defines a multiplicative identity element for `Self`.\n-pub trait One: Mul<Self, Self> {\n-    /// Returns the multiplicative identity element of `Self`, `1`.\n-    ///\n-    /// # Laws\n-    ///\n-    /// ```{.text}\n-    /// a * 1 = a       \u2200 a \u2208 Self\n-    /// 1 * a = a       \u2200 a \u2208 Self\n-    /// ```\n-    ///\n-    /// # Purity\n-    ///\n-    /// This function should return the same result at all times regardless of\n-    /// external mutable state, for example values stored in TLS or in\n-    /// `static mut`s.\n-    // FIXME (#5527): This should be an associated constant\n-    fn one() -> Self;\n-}\n-\n-macro_rules! one_impl(\n-    ($t:ty, $v:expr) => {\n-        impl One for $t {\n-            #[inline]\n-            fn one() -> $t { $v }\n-        }\n-    }\n-)\n-\n-one_impl!(uint, 1u)\n-one_impl!(u8,  1u8)\n-one_impl!(u16, 1u16)\n-one_impl!(u32, 1u32)\n-one_impl!(u64, 1u64)\n-\n-one_impl!(int, 1i)\n-one_impl!(i8,  1i8)\n-one_impl!(i16, 1i16)\n-one_impl!(i32, 1i32)\n-one_impl!(i64, 1i64)\n-\n-one_impl!(f32, 1.0f32)\n-one_impl!(f64, 1.0f64)\n-\n-/// Returns the multiplicative identity, `1`.\n-#[inline(always)] pub fn one<T: One>() -> T { One::one() }\n-\n-/// Useful functions for signed numbers (i.e. numbers that can be negative).\n-pub trait Signed: Num + Neg<Self> {\n-    /// Computes the absolute value.\n-    ///\n-    /// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`.\n-    ///\n-    /// For signed integers, `::MIN` will be returned if the number is `::MIN`.\n-    fn abs(&self) -> Self;\n-\n-    /// The positive difference of two numbers.\n-    ///\n-    /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference\n-    /// between `self` and `other` is returned.\n-    fn abs_sub(&self, other: &Self) -> Self;\n-\n-    /// Returns the sign of the number.\n-    ///\n-    /// For `f32` and `f64`:\n-    ///\n-    /// * `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// * `NaN` if the number is `NaN`\n-    ///\n-    /// For signed integers:\n-    ///\n-    /// * `0` if the number is zero\n-    /// * `1` if the number is positive\n-    /// * `-1` if the number is negative\n-    fn signum(&self) -> Self;\n-\n-    /// Returns true if the number is positive and false if the number is zero or negative.\n-    fn is_positive(&self) -> bool;\n-\n-    /// Returns true if the number is negative and false if the number is zero or positive.\n-    fn is_negative(&self) -> bool;\n-}\n-\n-macro_rules! signed_impl(\n-    ($($t:ty)*) => ($(\n-        impl Signed for $t {\n-            #[inline]\n-            fn abs(&self) -> $t {\n-                if self.is_negative() { -*self } else { *self }\n-            }\n-\n-            #[inline]\n-            fn abs_sub(&self, other: &$t) -> $t {\n-                if *self <= *other { 0 } else { *self - *other }\n-            }\n-\n-            #[inline]\n-            fn signum(&self) -> $t {\n-                match *self {\n-                    n if n > 0 => 1,\n-                    0 => 0,\n-                    _ => -1,\n-                }\n-            }\n-\n-            #[inline]\n-            fn is_positive(&self) -> bool { *self > 0 }\n-\n-            #[inline]\n-            fn is_negative(&self) -> bool { *self < 0 }\n-        }\n-    )*)\n-)\n-\n-signed_impl!(int i8 i16 i32 i64)\n-\n-macro_rules! signed_float_impl(\n-    ($t:ty, $nan:expr, $inf:expr, $neg_inf:expr, $fabs:path, $fcopysign:path, $fdim:ident) => {\n-        impl Signed for $t {\n-            /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n-            #[inline]\n-            fn abs(&self) -> $t {\n-                unsafe { $fabs(*self) }\n-            }\n-\n-            /// The positive difference of two numbers. Returns `0.0` if the number is\n-            /// less than or equal to `other`, otherwise the difference between`self`\n-            /// and `other` is returned.\n-            #[inline]\n-            fn abs_sub(&self, other: &$t) -> $t {\n-                extern { fn $fdim(a: $t, b: $t) -> $t; }\n-                unsafe { $fdim(*self, *other) }\n-            }\n-\n-            /// # Returns\n-            ///\n-            /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-            /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-            /// - `NAN` if the number is NaN\n-            #[inline]\n-            fn signum(&self) -> $t {\n-                if self != self { $nan } else {\n-                    unsafe { $fcopysign(1.0, *self) }\n-                }\n-            }\n-\n-            /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n-            #[inline]\n-            fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == $inf }\n-\n-            /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n-            #[inline]\n-            fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == $neg_inf }\n-        }\n-    }\n-)\n-\n-signed_float_impl!(f32, f32::NAN, f32::INFINITY, f32::NEG_INFINITY,\n-                   intrinsics::fabsf32, intrinsics::copysignf32, fdimf)\n-signed_float_impl!(f64, f64::NAN, f64::INFINITY, f64::NEG_INFINITY,\n-                   intrinsics::fabsf64, intrinsics::copysignf64, fdim)\n-\n-/// Computes the absolute value.\n-///\n-/// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`\n-///\n-/// For signed integers, `::MIN` will be returned if the number is `::MIN`.\n-#[inline(always)]\n-pub fn abs<T: Signed>(value: T) -> T {\n-    value.abs()\n-}\n-\n-/// The positive difference of two numbers.\n-///\n-/// Returns zero if `x` is less than or equal to `y`, otherwise the difference\n-/// between `x` and `y` is returned.\n-#[inline(always)]\n-pub fn abs_sub<T: Signed>(x: T, y: T) -> T {\n-    x.abs_sub(&y)\n-}\n-\n-/// Returns the sign of the number.\n-///\n-/// For `f32` and `f64`:\n-///\n-/// * `1.0` if the number is positive, `+0.0` or `INFINITY`\n-/// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-/// * `NaN` if the number is `NaN`\n-///\n-/// For signed integers:\n-///\n-/// * `0` if the number is zero\n-/// * `1` if the number is positive\n-/// * `-1` if the number is negative\n-#[inline(always)] pub fn signum<T: Signed>(value: T) -> T { value.signum() }\n-\n-/// A trait for values which cannot be negative\n-pub trait Unsigned: Num {}\n-\n-trait_impl!(Unsigned for uint u8 u16 u32 u64)\n-\n-/// Raises a value to the power of exp, using exponentiation by squaring.\n+/// Raises a `base` to the power of `exp`, using exponentiation by squaring.\n ///\n /// # Example\n ///\n@@ -320,10 +43,10 @@ trait_impl!(Unsigned for uint u8 u16 u32 u64)\n /// assert_eq!(num::pow(2i, 4), 16);\n /// ```\n #[inline]\n-pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n+pub fn pow<T: Int>(mut base: T, mut exp: uint) -> T {\n     if exp == 1 { base }\n     else {\n-        let mut acc = one::<T>();\n+        let mut acc: T = Int::one();\n         while exp > 0 {\n             if (exp & 1) == 1 {\n                 acc = acc * base;\n@@ -335,85 +58,60 @@ pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n     }\n }\n \n-/// Numbers which have upper and lower bounds\n-pub trait Bounded {\n-    // FIXME (#5527): These should be associated constants\n-    /// returns the smallest finite number this type can represent\n-    fn min_value() -> Self;\n-    /// returns the largest finite number this type can represent\n-    fn max_value() -> Self;\n-}\n-\n-macro_rules! bounded_impl(\n-    ($t:ty, $min:expr, $max:expr) => {\n-        impl Bounded for $t {\n-            #[inline]\n-            fn min_value() -> $t { $min }\n-\n-            #[inline]\n-            fn max_value() -> $t { $max }\n-        }\n-    }\n-)\n-\n-bounded_impl!(uint, uint::MIN, uint::MAX)\n-bounded_impl!(u8, u8::MIN, u8::MAX)\n-bounded_impl!(u16, u16::MIN, u16::MAX)\n-bounded_impl!(u32, u32::MIN, u32::MAX)\n-bounded_impl!(u64, u64::MIN, u64::MAX)\n-\n-bounded_impl!(int, int::MIN, int::MAX)\n-bounded_impl!(i8, i8::MIN, i8::MAX)\n-bounded_impl!(i16, i16::MIN, i16::MAX)\n-bounded_impl!(i32, i32::MIN, i32::MAX)\n-bounded_impl!(i64, i64::MIN, i64::MAX)\n+/// A built-in signed or unsigned integer.\n+pub trait Int\n+    : Copy + Clone\n+    + NumCast\n+    + PartialOrd + Ord\n+    + PartialEq + Eq\n+    + Add<Self,Self>\n+    + Sub<Self,Self>\n+    + Mul<Self,Self>\n+    + Div<Self,Self>\n+    + Rem<Self,Self>\n+    + Not<Self>\n+    + BitAnd<Self,Self>\n+    + BitOr<Self,Self>\n+    + BitXor<Self,Self>\n+    + Shl<uint,Self>\n+    + Shr<uint,Self>\n+{\n+    /// Returns the `0` value of this integer type.\n+    // FIXME (#5527): Should be an associated constant\n+    fn zero() -> Self;\n \n-bounded_impl!(f32, f32::MIN_VALUE, f32::MAX_VALUE)\n-bounded_impl!(f64, f64::MIN_VALUE, f64::MAX_VALUE)\n+    /// Returns the `1` value of this integer type.\n+    // FIXME (#5527): Should be an associated constant\n+    fn one() -> Self;\n \n-/// Specifies the available operations common to all of Rust's core numeric primitives.\n-/// These may not always make sense from a purely mathematical point of view, but\n-/// may be useful for systems programming.\n-pub trait Primitive: Copy\n-                   + Clone\n-                   + Num\n-                   + NumCast\n-                   + PartialOrd\n-                   + Bounded {}\n+    /// Returns the smallest value that can be represented by this integer type.\n+    // FIXME (#5527): Should be and associated constant\n+    fn min_value() -> Self;\n \n-trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+    /// Returns the largest value that can be represented by this integer type.\n+    // FIXME (#5527): Should be and associated constant\n+    fn max_value() -> Self;\n \n-/// A primitive signed or unsigned integer equipped with various bitwise\n-/// operators, bit counting methods, and endian conversion functions.\n-pub trait Int: Primitive\n-             + Ord\n-             + CheckedAdd\n-             + CheckedSub\n-             + CheckedMul\n-             + CheckedDiv\n-             + Bounded\n-             + Not<Self>\n-             + BitAnd<Self,Self>\n-             + BitOr<Self,Self>\n-             + BitXor<Self,Self>\n-             + Shl<uint,Self>\n-             + Shr<uint,Self> {\n-    /// Returns the number of ones in the binary representation of the integer.\n+    /// Returns the number of ones in the binary representation of `self`.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0b01001100u8;\n     ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n     fn count_ones(self) -> uint;\n \n-    /// Returns the number of zeros in the binary representation of the integer.\n+    /// Returns the number of zeros in the binary representation of `self`.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0b01001100u8;\n     ///\n     /// assert_eq!(n.count_zeros(), 5);\n@@ -424,23 +122,27 @@ pub trait Int: Primitive\n     }\n \n     /// Returns the number of leading zeros in the binary representation\n-    /// of the integer.\n+    /// of `self`.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0b0101000u16;\n     ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n     fn leading_zeros(self) -> uint;\n \n     /// Returns the number of trailing zeros in the binary representation\n-    /// of the integer.\n+    /// of `self`.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0b0101000u16;\n     ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n@@ -453,6 +155,8 @@ pub trait Int: Primitive\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     /// let m = 0x3456789ABCDEF012u64;\n     ///\n@@ -466,6 +170,8 @@ pub trait Int: Primitive\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     /// let m = 0xDEF0123456789ABCu64;\n     ///\n@@ -478,6 +184,8 @@ pub trait Int: Primitive\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     /// let m = 0xEFCDAB8967452301u64;\n     ///\n@@ -492,6 +200,8 @@ pub trait Int: Primitive\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     ///\n     /// if cfg!(target_endian = \"big\") {\n@@ -512,6 +222,8 @@ pub trait Int: Primitive\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     ///\n     /// if cfg!(target_endian = \"little\") {\n@@ -525,13 +237,15 @@ pub trait Int: Primitive\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n     }\n \n-    /// Convert the integer to big endian from the target's endianness.\n+    /// Convert `self` to big endian from the target's endianness.\n     ///\n     /// On big endian this is a no-op. On little endian the bytes are swapped.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     ///\n     /// if cfg!(target_endian = \"big\") {\n@@ -545,13 +259,15 @@ pub trait Int: Primitive\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n     }\n \n-    /// Convert the integer to little endian from the target's endianness.\n+    /// Convert `self` to little endian from the target's endianness.\n     ///\n     /// On little endian this is a no-op. On big endian the bytes are swapped.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::num::Int;\n+    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     ///\n     /// if cfg!(target_endian = \"little\") {\n@@ -564,19 +280,121 @@ pub trait Int: Primitive\n     fn to_le(self) -> Self {\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n     }\n+\n+    /// Checked integer addition. Computes `self + other`, returning `None` if\n+    /// overflow occurred.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Int;\n+    ///\n+    /// assert_eq!(5u16.checked_add(65530), Some(65535));\n+    /// assert_eq!(6u16.checked_add(65530), None);\n+    /// ```\n+    fn checked_add(self, other: Self) -> Option<Self>;\n+\n+    /// Checked integer subtraction. Computes `self + other`, returning `None`\n+    /// if underflow occurred.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Int;\n+    ///\n+    /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n+    /// assert_eq!((-128i8).checked_sub(1), None);\n+    /// ```\n+    fn checked_sub(self, other: Self) -> Option<Self>;\n+\n+    /// Checked integer multiplication. Computes `self + other`, returning\n+    /// `None` if underflow or overflow occurred.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Int;\n+    ///\n+    /// assert_eq!(5u8.checked_mul(51), Some(255));\n+    /// assert_eq!(5u8.checked_mul(52), None);\n+    /// ```\n+    fn checked_mul(self, other: Self) -> Option<Self>;\n+\n+    /// Checked integer division. Computes `self + other` returning `None` if\n+    /// `self == 0` or the operation results in underflow or overflow.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Int;\n+    ///\n+    /// assert_eq!((-127i8).checked_div(-1), Some(127));\n+    /// assert_eq!((-128i8).checked_div(-1), None);\n+    /// assert_eq!((1i8).checked_div(0), None);\n+    /// ```\n+    #[inline]\n+    fn checked_div(self, other: Self) -> Option<Self>;\n+\n+    /// Saturating integer addition. Computes `self + other`, saturating at\n+    /// the numeric bounds instead of overflowing.\n+    #[inline]\n+    fn saturating_add(self, other: Self) -> Self {\n+        match self.checked_add(other) {\n+            Some(x)                      => x,\n+            None if other >= Int::zero() => Int::max_value(),\n+            None                         => Int::min_value(),\n+        }\n+    }\n+\n+    /// Saturating integer subtraction. Computes `self - other`, saturating at\n+    /// the numeric bounds instead of overflowing.\n+    #[inline]\n+    fn saturating_sub(self, other: Self) -> Self {\n+        match self.checked_sub(other) {\n+            Some(x)                      => x,\n+            None if other >= Int::zero() => Int::min_value(),\n+            None                         => Int::max_value(),\n+        }\n+    }\n }\n \n-macro_rules! int_impl {\n-    ($T:ty, $BITS:expr, $ctpop:path, $ctlz:path, $cttz:path, $bswap:path) => {\n+macro_rules! checked_op {\n+    ($T:ty, $U:ty, $op:path, $x:expr, $y:expr) => {{\n+        let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n+        if overflowed { None } else { Some(result as $T) }\n+    }}\n+}\n+\n+macro_rules! uint_impl {\n+    ($T:ty = $ActualT:ty, $BITS:expr,\n+     $ctpop:path,\n+     $ctlz:path,\n+     $cttz:path,\n+     $bswap:path,\n+     $add_with_overflow:path,\n+     $sub_with_overflow:path,\n+     $mul_with_overflow:path) => {\n         impl Int for $T {\n             #[inline]\n-            fn count_ones(self) -> uint { unsafe { $ctpop(self) as uint } }\n+            fn zero() -> $T { 0 }\n+\n+            #[inline]\n+            fn one() -> $T { 1 }\n+\n+            #[inline]\n+            fn min_value() -> $T { 0 }\n+\n+            #[inline]\n+            fn max_value() -> $T { -1 }\n+\n+            #[inline]\n+            fn count_ones(self) -> uint { unsafe { $ctpop(self as $ActualT) as uint } }\n \n             #[inline]\n-            fn leading_zeros(self) -> uint { unsafe { $ctlz(self) as uint } }\n+            fn leading_zeros(self) -> uint { unsafe { $ctlz(self as $ActualT) as uint } }\n \n             #[inline]\n-            fn trailing_zeros(self) -> uint { unsafe { $cttz(self) as uint } }\n+            fn trailing_zeros(self) -> uint { unsafe { $cttz(self as $ActualT) as uint } }\n \n             #[inline]\n             fn rotate_left(self, n: uint) -> $T {\n@@ -593,7 +411,30 @@ macro_rules! int_impl {\n             }\n \n             #[inline]\n-            fn swap_bytes(self) -> $T { unsafe { $bswap(self) } }\n+            fn swap_bytes(self) -> $T { unsafe { $bswap(self as $ActualT) as $T } }\n+\n+            #[inline]\n+            fn checked_add(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_sub(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_mul(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_div(self, v: $T) -> Option<$T> {\n+                match v {\n+                    0 => None,\n+                    v => Some(self / v),\n+                }\n+            }\n         }\n     }\n }\n@@ -602,98 +443,256 @@ macro_rules! int_impl {\n /// consistency with the other `bswap` intrinsics.\n unsafe fn bswap8(x: u8) -> u8 { x }\n \n-int_impl!(u8, 8,\n+uint_impl!(u8 = u8, 8,\n     intrinsics::ctpop8,\n     intrinsics::ctlz8,\n     intrinsics::cttz8,\n-    bswap8)\n+    bswap8,\n+    intrinsics::u8_add_with_overflow,\n+    intrinsics::u8_sub_with_overflow,\n+    intrinsics::u8_mul_with_overflow)\n \n-int_impl!(u16, 16,\n+uint_impl!(u16 = u16, 16,\n     intrinsics::ctpop16,\n     intrinsics::ctlz16,\n     intrinsics::cttz16,\n-    intrinsics::bswap16)\n+    intrinsics::bswap16,\n+    intrinsics::u16_add_with_overflow,\n+    intrinsics::u16_sub_with_overflow,\n+    intrinsics::u16_mul_with_overflow)\n+\n+uint_impl!(u32 = u32, 32,\n+    intrinsics::ctpop32,\n+    intrinsics::ctlz32,\n+    intrinsics::cttz32,\n+    intrinsics::bswap32,\n+    intrinsics::u32_add_with_overflow,\n+    intrinsics::u32_sub_with_overflow,\n+    intrinsics::u32_mul_with_overflow)\n+\n+uint_impl!(u64 = u64, 64,\n+    intrinsics::ctpop64,\n+    intrinsics::ctlz64,\n+    intrinsics::cttz64,\n+    intrinsics::bswap64,\n+    intrinsics::u64_add_with_overflow,\n+    intrinsics::u64_sub_with_overflow,\n+    intrinsics::u64_mul_with_overflow)\n \n-int_impl!(u32, 32,\n+#[cfg(target_word_size = \"32\")]\n+uint_impl!(uint = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n     intrinsics::cttz32,\n-    intrinsics::bswap32)\n+    intrinsics::bswap32,\n+    intrinsics::u32_add_with_overflow,\n+    intrinsics::u32_sub_with_overflow,\n+    intrinsics::u32_mul_with_overflow)\n \n-int_impl!(u64, 64,\n+#[cfg(target_word_size = \"64\")]\n+uint_impl!(uint = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n     intrinsics::cttz64,\n-    intrinsics::bswap64)\n+    intrinsics::bswap64,\n+    intrinsics::u64_add_with_overflow,\n+    intrinsics::u64_sub_with_overflow,\n+    intrinsics::u64_mul_with_overflow)\n \n-macro_rules! int_cast_impl {\n-    ($T:ty, $U:ty) => {\n+macro_rules! int_impl {\n+    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+     $add_with_overflow:path,\n+     $sub_with_overflow:path,\n+     $mul_with_overflow:path) => {\n         impl Int for $T {\n             #[inline]\n-            fn count_ones(self) -> uint { (self as $U).count_ones() }\n+            fn zero() -> $T { 0 }\n+\n+            #[inline]\n+            fn one() -> $T { 1 }\n+\n+            #[inline]\n+            fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n+\n+            #[inline]\n+            fn max_value() -> $T { let min: $T = Int::min_value(); !min }\n+\n+            #[inline]\n+            fn count_ones(self) -> uint { (self as $UnsignedT).count_ones() }\n+\n+            #[inline]\n+            fn leading_zeros(self) -> uint { (self as $UnsignedT).leading_zeros() }\n+\n+            #[inline]\n+            fn trailing_zeros(self) -> uint { (self as $UnsignedT).trailing_zeros() }\n+\n+            #[inline]\n+            fn rotate_left(self, n: uint) -> $T { (self as $UnsignedT).rotate_left(n) as $T }\n+\n+            #[inline]\n+            fn rotate_right(self, n: uint) -> $T { (self as $UnsignedT).rotate_right(n) as $T }\n \n             #[inline]\n-            fn leading_zeros(self) -> uint { (self as $U).leading_zeros() }\n+            fn swap_bytes(self) -> $T { (self as $UnsignedT).swap_bytes() as $T }\n \n             #[inline]\n-            fn trailing_zeros(self) -> uint { (self as $U).trailing_zeros() }\n+            fn checked_add(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+            }\n \n             #[inline]\n-            fn rotate_left(self, n: uint) -> $T { (self as $U).rotate_left(n) as $T }\n+            fn checked_sub(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+            }\n \n             #[inline]\n-            fn rotate_right(self, n: uint) -> $T { (self as $U).rotate_right(n) as $T }\n+            fn checked_mul(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+            }\n \n             #[inline]\n-            fn swap_bytes(self) -> $T { (self as $U).swap_bytes() as $T }\n+            fn checked_div(self, v: $T) -> Option<$T> {\n+                match v {\n+                    0   => None,\n+                   -1 if self == Int::min_value()\n+                        => None,\n+                    v   => Some(self / v),\n+                }\n+            }\n         }\n     }\n }\n \n-int_cast_impl!(i8, u8)\n-int_cast_impl!(i16, u16)\n-int_cast_impl!(i32, u32)\n-int_cast_impl!(i64, u64)\n+int_impl!(i8 = i8, u8, 8,\n+    intrinsics::i8_add_with_overflow,\n+    intrinsics::i8_sub_with_overflow,\n+    intrinsics::i8_mul_with_overflow)\n \n-#[cfg(target_word_size = \"32\")] int_cast_impl!(uint, u32)\n-#[cfg(target_word_size = \"64\")] int_cast_impl!(uint, u64)\n-#[cfg(target_word_size = \"32\")] int_cast_impl!(int, u32)\n-#[cfg(target_word_size = \"64\")] int_cast_impl!(int, u64)\n+int_impl!(i16 = i16, u16, 16,\n+    intrinsics::i16_add_with_overflow,\n+    intrinsics::i16_sub_with_overflow,\n+    intrinsics::i16_mul_with_overflow)\n \n-/// Returns the smallest power of 2 greater than or equal to `n`.\n-#[inline]\n-pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {\n-    let halfbits = size_of::<T>() * 4;\n-    let mut tmp: T = n - one();\n-    let mut shift = 1u;\n-    while shift <= halfbits {\n-        tmp = tmp | (tmp >> shift);\n-        shift = shift << 1u;\n-    }\n-    tmp + one()\n+int_impl!(i32 = i32, u32, 32,\n+    intrinsics::i32_add_with_overflow,\n+    intrinsics::i32_sub_with_overflow,\n+    intrinsics::i32_mul_with_overflow)\n+\n+int_impl!(i64 = i64, u64, 64,\n+    intrinsics::i64_add_with_overflow,\n+    intrinsics::i64_sub_with_overflow,\n+    intrinsics::i64_mul_with_overflow)\n+\n+#[cfg(target_word_size = \"32\")]\n+int_impl!(int = i32, u32, 32,\n+    intrinsics::i32_add_with_overflow,\n+    intrinsics::i32_sub_with_overflow,\n+    intrinsics::i32_mul_with_overflow)\n+\n+#[cfg(target_word_size = \"64\")]\n+int_impl!(int = i64, u64, 64,\n+    intrinsics::i64_add_with_overflow,\n+    intrinsics::i64_sub_with_overflow,\n+    intrinsics::i64_mul_with_overflow)\n+\n+/// A built-in two's complement integer.\n+pub trait SignedInt\n+    : Int\n+    + Neg<Self>\n+{\n+    /// Computes the absolute value of `self`. `Int::min_value()` will be\n+    /// returned if the number is `Int::min_value()`.\n+    fn abs(self) -> Self;\n+\n+    /// Returns a number representing sign of `self`.\n+    ///\n+    /// - `0` if the number is zero\n+    /// - `1` if the number is positive\n+    /// - `-1` if the number is negative\n+    fn signum(self) -> Self;\n+\n+    /// Returns `true` if `self` is positive and `false` if the number\n+    /// is zero or negative.\n+    fn is_positive(self) -> bool;\n+\n+    /// Returns `true` if `self` is negative and `false` if the number\n+    /// is zero or positive.\n+    fn is_negative(self) -> bool;\n }\n \n-// Returns `true` iff `n == 2^k` for some k.\n-#[inline]\n-pub fn is_power_of_two<T: Unsigned + Int>(n: T) -> bool {\n-    (n - one()) & n == zero()\n+macro_rules! signed_int_impl {\n+    ($T:ty) => {\n+        impl SignedInt for $T {\n+            #[inline]\n+            fn abs(self) -> $T {\n+                if self.is_negative() { -self } else { self }\n+            }\n+\n+            #[inline]\n+            fn signum(self) -> $T {\n+                match self {\n+                    n if n > 0 =>  1,\n+                    0          =>  0,\n+                    _          => -1,\n+                }\n+            }\n+\n+            #[inline]\n+            fn is_positive(self) -> bool { self > 0 }\n+\n+            #[inline]\n+            fn is_negative(self) -> bool { self < 0 }\n+        }\n+    }\n }\n \n-/// Returns the smallest power of 2 greater than or equal to `n`. If the next\n-/// power of two is greater than the type's maximum value, `None` is returned,\n-/// otherwise the power of 2 is wrapped in `Some`.\n-#[inline]\n-pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> {\n-    let halfbits = size_of::<T>() * 4;\n-    let mut tmp: T = n - one();\n-    let mut shift = 1u;\n-    while shift <= halfbits {\n-        tmp = tmp | (tmp >> shift);\n-        shift = shift << 1u;\n+signed_int_impl!(i8)\n+signed_int_impl!(i16)\n+signed_int_impl!(i32)\n+signed_int_impl!(i64)\n+signed_int_impl!(int)\n+\n+/// A built-in unsigned integer.\n+pub trait UnsignedInt: Int {\n+    /// Returns `true` iff `self == 2^k` for some `k`.\n+    fn is_power_of_two(self) -> bool {\n+        (self - Int::one()) & self == Int::zero()\n+    }\n+\n+    /// Returns the smallest power of two greater than or equal to `self`.\n+    #[inline]\n+    fn next_power_of_two(self) -> Self {\n+        let halfbits = size_of::<Self>() * 4;\n+        let mut tmp = self - Int::one();\n+        let mut shift = 1u;\n+        while shift <= halfbits {\n+            tmp = tmp | (tmp >> shift);\n+            shift = shift << 1u;\n+        }\n+        tmp + Int::one()\n+    }\n+\n+    /// Returns the smallest power of two greater than or equal to `n`. If the\n+    /// next power of two is greater than the type's maximum value, `None` is\n+    /// returned, otherwise the power of two is wrapped in `Some`.\n+    fn checked_next_power_of_two(self) -> Option<Self> {\n+        let halfbits = size_of::<Self>() * 4;\n+        let mut tmp = self - Int::one();\n+        let mut shift = 1u;\n+        while shift <= halfbits {\n+            tmp = tmp | (tmp >> shift);\n+            shift = shift << 1u;\n+        }\n+        tmp.checked_add(Int::one())\n     }\n-    tmp.checked_add(&one())\n }\n \n+impl UnsignedInt for uint {}\n+impl UnsignedInt for u8 {}\n+impl UnsignedInt for u16 {}\n+impl UnsignedInt for u32 {}\n+impl UnsignedInt for u64 {}\n+\n /// A generic trait for converting a value to a number.\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`.\n@@ -771,8 +770,8 @@ macro_rules! impl_to_primitive_int_to_int(\n                 Some($slf as $DstT)\n             } else {\n                 let n = $slf as i64;\n-                let min_value: $DstT = Bounded::min_value();\n-                let max_value: $DstT = Bounded::max_value();\n+                let min_value: $DstT = Int::min_value();\n+                let max_value: $DstT = Int::max_value();\n                 if min_value as i64 <= n && n <= max_value as i64 {\n                     Some($slf as $DstT)\n                 } else {\n@@ -786,8 +785,8 @@ macro_rules! impl_to_primitive_int_to_int(\n macro_rules! impl_to_primitive_int_to_uint(\n     ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n-            let zero: $SrcT = Zero::zero();\n-            let max_value: $DstT = Bounded::max_value();\n+            let zero: $SrcT = Int::zero();\n+            let max_value: $DstT = Int::max_value();\n             if zero <= $slf && $slf as u64 <= max_value as u64 {\n                 Some($slf as $DstT)\n             } else {\n@@ -839,7 +838,7 @@ impl_to_primitive_int!(i64)\n macro_rules! impl_to_primitive_uint_to_int(\n     ($DstT:ty, $slf:expr) => (\n         {\n-            let max_value: $DstT = Bounded::max_value();\n+            let max_value: $DstT = Int::max_value();\n             if $slf as u64 <= max_value as u64 {\n                 Some($slf as $DstT)\n             } else {\n@@ -855,8 +854,8 @@ macro_rules! impl_to_primitive_uint_to_uint(\n             if size_of::<$SrcT>() <= size_of::<$DstT>() {\n                 Some($slf as $DstT)\n             } else {\n-                let zero: $SrcT = Zero::zero();\n-                let max_value: $DstT = Bounded::max_value();\n+                let zero: $SrcT = Int::zero();\n+                let max_value: $DstT = Int::max_value();\n                 if zero <= $slf && $slf as u64 <= max_value as u64 {\n                     Some($slf as $DstT)\n                 } else {\n@@ -912,7 +911,7 @@ macro_rules! impl_to_primitive_float_to_float(\n             Some($slf as $DstT)\n         } else {\n             let n = $slf as f64;\n-            let max_value: $SrcT = Bounded::max_value();\n+            let max_value: $SrcT = Float::max_value();\n             if -max_value as f64 <= n && n <= max_value as f64 {\n                 Some($slf as $DstT)\n             } else {\n@@ -1182,229 +1181,6 @@ impl_num_cast!(int,   to_int)\n impl_num_cast!(f32,   to_f32)\n impl_num_cast!(f64,   to_f64)\n \n-/// Saturating math operations\n-pub trait Saturating {\n-    /// Saturating addition operator.\n-    /// Returns a+b, saturating at the numeric bounds instead of overflowing.\n-    fn saturating_add(self, v: Self) -> Self;\n-\n-    /// Saturating subtraction operator.\n-    /// Returns a-b, saturating at the numeric bounds instead of overflowing.\n-    fn saturating_sub(self, v: Self) -> Self;\n-}\n-\n-impl<T: CheckedAdd + CheckedSub + Zero + PartialOrd + Bounded> Saturating for T {\n-    #[inline]\n-    fn saturating_add(self, v: T) -> T {\n-        match self.checked_add(&v) {\n-            Some(x) => x,\n-            None => if v >= Zero::zero() {\n-                Bounded::max_value()\n-            } else {\n-                Bounded::min_value()\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn saturating_sub(self, v: T) -> T {\n-        match self.checked_sub(&v) {\n-            Some(x) => x,\n-            None => if v >= Zero::zero() {\n-                Bounded::min_value()\n-            } else {\n-                Bounded::max_value()\n-            }\n-        }\n-    }\n-}\n-\n-/// Performs addition that returns `None` instead of wrapping around on overflow.\n-pub trait CheckedAdd: Add<Self, Self> {\n-    /// Adds two numbers, checking for overflow. If overflow happens, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::CheckedAdd;\n-    /// assert_eq!(5u16.checked_add(&65530), Some(65535));\n-    /// assert_eq!(6u16.checked_add(&65530), None);\n-    /// ```\n-    fn checked_add(&self, v: &Self) -> Option<Self>;\n-}\n-\n-macro_rules! checked_impl(\n-    ($trait_name:ident, $method:ident, $t:ty, $op:path) => {\n-        impl $trait_name for $t {\n-            #[inline]\n-            fn $method(&self, v: &$t) -> Option<$t> {\n-                unsafe {\n-                    let (x, y) = $op(*self, *v);\n-                    if y { None } else { Some(x) }\n-                }\n-            }\n-        }\n-    }\n-)\n-macro_rules! checked_cast_impl(\n-    ($trait_name:ident, $method:ident, $t:ty, $cast:ty, $op:path) => {\n-        impl $trait_name for $t {\n-            #[inline]\n-            fn $method(&self, v: &$t) -> Option<$t> {\n-                unsafe {\n-                    let (x, y) = $op(*self as $cast, *v as $cast);\n-                    if y { None } else { Some(x as $t) }\n-                }\n-            }\n-        }\n-    }\n-)\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedAdd, checked_add, uint, u32, intrinsics::u32_add_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedAdd, checked_add, uint, u64, intrinsics::u64_add_with_overflow)\n-\n-checked_impl!(CheckedAdd, checked_add, u8,  intrinsics::u8_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, u16, intrinsics::u16_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, u32, intrinsics::u32_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, u64, intrinsics::u64_add_with_overflow)\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedAdd, checked_add, int, i32, intrinsics::i32_add_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedAdd, checked_add, int, i64, intrinsics::i64_add_with_overflow)\n-\n-checked_impl!(CheckedAdd, checked_add, i8,  intrinsics::i8_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, i16, intrinsics::i16_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, i32, intrinsics::i32_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, i64, intrinsics::i64_add_with_overflow)\n-\n-/// Performs subtraction that returns `None` instead of wrapping around on underflow.\n-pub trait CheckedSub: Sub<Self, Self> {\n-    /// Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::CheckedSub;\n-    /// assert_eq!((-127i8).checked_sub(&1), Some(-128));\n-    /// assert_eq!((-128i8).checked_sub(&1), None);\n-    /// ```\n-    fn checked_sub(&self, v: &Self) -> Option<Self>;\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedSub, checked_sub, uint, u32, intrinsics::u32_sub_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedSub, checked_sub, uint, u64, intrinsics::u64_sub_with_overflow)\n-\n-checked_impl!(CheckedSub, checked_sub, u8,  intrinsics::u8_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, u16, intrinsics::u16_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, u32, intrinsics::u32_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, u64, intrinsics::u64_sub_with_overflow)\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedSub, checked_sub, int, i32, intrinsics::i32_sub_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedSub, checked_sub, int, i64, intrinsics::i64_sub_with_overflow)\n-\n-checked_impl!(CheckedSub, checked_sub, i8,  intrinsics::i8_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, i16, intrinsics::i16_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, i32, intrinsics::i32_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, i64, intrinsics::i64_sub_with_overflow)\n-\n-/// Performs multiplication that returns `None` instead of wrapping around on underflow or\n-/// overflow.\n-pub trait CheckedMul: Mul<Self, Self> {\n-    /// Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\n-    /// happens, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::CheckedMul;\n-    /// assert_eq!(5u8.checked_mul(&51), Some(255));\n-    /// assert_eq!(5u8.checked_mul(&52), None);\n-    /// ```\n-    fn checked_mul(&self, v: &Self) -> Option<Self>;\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedMul, checked_mul, uint, u32, intrinsics::u32_mul_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedMul, checked_mul, uint, u64, intrinsics::u64_mul_with_overflow)\n-\n-checked_impl!(CheckedMul, checked_mul, u8,  intrinsics::u8_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, u16, intrinsics::u16_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, u32, intrinsics::u32_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, u64, intrinsics::u64_mul_with_overflow)\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedMul, checked_mul, int, i32, intrinsics::i32_mul_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedMul, checked_mul, int, i64, intrinsics::i64_mul_with_overflow)\n-\n-checked_impl!(CheckedMul, checked_mul, i8,  intrinsics::i8_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, i16, intrinsics::i16_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, i32, intrinsics::i32_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, i64, intrinsics::i64_mul_with_overflow)\n-\n-/// Performs division that returns `None` instead of panicking on division by zero and instead of\n-/// wrapping around on underflow and overflow.\n-pub trait CheckedDiv: Div<Self, Self> {\n-    /// Divides two numbers, checking for underflow, overflow and division by zero. If any of that\n-    /// happens, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::CheckedDiv;\n-    /// assert_eq!((-127i8).checked_div(&-1), Some(127));\n-    /// assert_eq!((-128i8).checked_div(&-1), None);\n-    /// assert_eq!((1i8).checked_div(&0), None);\n-    /// ```\n-    fn checked_div(&self, v: &Self) -> Option<Self>;\n-}\n-\n-macro_rules! checkeddiv_int_impl(\n-    ($t:ty, $min:expr) => {\n-        impl CheckedDiv for $t {\n-            #[inline]\n-            fn checked_div(&self, v: &$t) -> Option<$t> {\n-                if *v == 0 || (*self == $min && *v == -1) {\n-                    None\n-                } else {\n-                    Some(*self / *v)\n-                }\n-            }\n-        }\n-    }\n-)\n-\n-checkeddiv_int_impl!(int, int::MIN)\n-checkeddiv_int_impl!(i8, i8::MIN)\n-checkeddiv_int_impl!(i16, i16::MIN)\n-checkeddiv_int_impl!(i32, i32::MIN)\n-checkeddiv_int_impl!(i64, i64::MIN)\n-\n-macro_rules! checkeddiv_uint_impl(\n-    ($($t:ty)*) => ($(\n-        impl CheckedDiv for $t {\n-            #[inline]\n-            fn checked_div(&self, v: &$t) -> Option<$t> {\n-                if *v == 0 {\n-                    None\n-                } else {\n-                    Some(*self / *v)\n-                }\n-            }\n-        }\n-    )*)\n-)\n-\n-checkeddiv_uint_impl!(uint u8 u16 u32 u64)\n-\n /// Used for representing the classification of floating point numbers\n #[deriving(PartialEq, Show)]\n pub enum FPCategory {\n@@ -1420,21 +1196,36 @@ pub enum FPCategory {\n     FPNormal,\n }\n \n-/// Operations on primitive floating point numbers.\n+/// A built-in floating point number.\n // FIXME(#5527): In a future version of Rust, many of these functions will\n //               become constants.\n //\n // FIXME(#8888): Several of these functions have a parameter named\n //               `unused_self`. Removing it requires #8888 to be fixed.\n-pub trait Float: Signed + Primitive {\n+pub trait Float\n+    : Copy + Clone\n+    + NumCast\n+    + PartialOrd\n+    + PartialEq\n+    + Neg<Self>\n+    + Add<Self,Self>\n+    + Sub<Self,Self>\n+    + Mul<Self,Self>\n+    + Div<Self,Self>\n+    + Rem<Self,Self>\n+{\n     /// Returns the NaN value.\n     fn nan() -> Self;\n     /// Returns the infinite value.\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n     fn neg_infinity() -> Self;\n+    /// Returns the `0` value.\n+    fn zero() -> Self;\n     /// Returns -0.0.\n     fn neg_zero() -> Self;\n+    /// Returns the `1` value.\n+    fn one() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n     fn is_nan(self) -> bool;\n@@ -1464,8 +1255,12 @@ pub trait Float: Signed + Primitive {\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum base-10 exponent that this type can represent.\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the smallest finite value that this type can represent.\n+    fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n+    /// Returns the largest finite value that this type can represent.\n+    fn max_value() -> Self;\n \n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n@@ -1482,6 +1277,22 @@ pub trait Float: Signed + Primitive {\n     /// Return the fractional part of a number.\n     fn fract(self) -> Self;\n \n+    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n+    /// number is `Float::nan()`.\n+    fn abs(self) -> Self;\n+    /// Returns a number that represents the sign of `self`.\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n+    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n+    /// - `Float::nan()` if the number is `Float::nan()`\n+    fn signum(self) -> Self;\n+    /// Returns `true` if `self` is positive, including `+0.0` and\n+    /// `Float::infinity()`.\n+    fn is_positive(self) -> bool;\n+    /// Returns `true` if `self` is negative, including `-0.0` and\n+    /// `Float::neg_infinity()`.\n+    fn is_negative(self) -> bool;\n+\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n@@ -1560,3 +1371,135 @@ pub trait Float: Signed + Primitive {\n     /// Convert degrees to radians.\n     fn to_radians(self) -> Self;\n }\n+\n+// DEPRECATED\n+\n+macro_rules! trait_impl {\n+    ($name:ident for $($t:ty)*) => {\n+        $(#[allow(deprecated)] impl $name for $t {})*\n+    };\n+}\n+\n+#[deprecated = \"Generalised numbers are no longer supported\"]\n+#[allow(deprecated)]\n+pub trait Num: PartialEq + Zero + One\n+             + Neg<Self>\n+             + Add<Self,Self>\n+             + Sub<Self,Self>\n+             + Mul<Self,Self>\n+             + Div<Self,Self>\n+             + Rem<Self,Self> {}\n+trait_impl!(Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n+#[deprecated = \"Generalised unsigned numbers are no longer supported\"]\n+#[allow(deprecated)]\n+pub trait Unsigned: Num {}\n+trait_impl!(Unsigned for uint u8 u16 u32 u64)\n+\n+#[deprecated = \"Use `Float` or `Int`\"]\n+#[allow(deprecated)]\n+pub trait Primitive: Copy + Clone + Num + NumCast + PartialOrd {}\n+trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n+#[deprecated = \"The generic `Zero` trait will be removed soon.\"]\n+pub trait Zero: Add<Self, Self> {\n+    #[deprecated = \"Use `Int::zero()` or `Float::zero()`.\"]\n+    fn zero() -> Self;\n+    #[deprecated = \"Use `x == Int::zero()` or `x == Float::zero()`.\"]\n+    fn is_zero(&self) -> bool;\n+}\n+#[deprecated = \"Use `Int::zero()` or `Float::zero()`.\"]\n+#[allow(deprecated)]\n+pub fn zero<T: Zero>() -> T { Zero::zero() }\n+macro_rules! zero_impl {\n+    ($t:ty, $v:expr) => {\n+        impl Zero for $t {\n+            fn zero() -> $t { $v }\n+            fn is_zero(&self) -> bool { *self == $v }\n+        }\n+    }\n+}\n+zero_impl!(uint, 0u)\n+zero_impl!(u8,   0u8)\n+zero_impl!(u16,  0u16)\n+zero_impl!(u32,  0u32)\n+zero_impl!(u64,  0u64)\n+zero_impl!(int, 0i)\n+zero_impl!(i8,  0i8)\n+zero_impl!(i16, 0i16)\n+zero_impl!(i32, 0i32)\n+zero_impl!(i64, 0i64)\n+zero_impl!(f32, 0.0f32)\n+zero_impl!(f64, 0.0f64)\n+\n+#[deprecated = \"The generic `One` trait will be removed soon.\"]\n+pub trait One: Mul<Self, Self> {\n+    #[deprecated = \"Use `Int::one()` or `Float::one()`.\"]\n+    fn one() -> Self;\n+}\n+#[deprecated = \"Use `Int::one()` or `Float::one()`.\"]\n+#[allow(deprecated)]\n+pub fn one<T: One>() -> T { One::one() }\n+macro_rules! one_impl {\n+    ($t:ty, $v:expr) => {\n+        impl One for $t {\n+            fn one() -> $t { $v }\n+        }\n+    }\n+}\n+one_impl!(uint, 1u)\n+one_impl!(u8,  1u8)\n+one_impl!(u16, 1u16)\n+one_impl!(u32, 1u32)\n+one_impl!(u64, 1u64)\n+one_impl!(int, 1i)\n+one_impl!(i8,  1i8)\n+one_impl!(i16, 1i16)\n+one_impl!(i32, 1i32)\n+one_impl!(i64, 1i64)\n+one_impl!(f32, 1.0f32)\n+one_impl!(f64, 1.0f64)\n+\n+#[deprecated = \"Use `UnsignedInt::next_power_of_two`\"]\n+pub fn next_power_of_two<T: UnsignedInt>(n: T) -> T {\n+    n.next_power_of_two()\n+}\n+#[deprecated = \"Use `UnsignedInt::is_power_of_two`\"]\n+pub fn is_power_of_two<T: UnsignedInt>(n: T) -> bool {\n+    n.is_power_of_two()\n+}\n+#[deprecated = \"Use `UnsignedInt::checked_next_power_of_two`\"]\n+pub fn checked_next_power_of_two<T: UnsignedInt>(n: T) -> Option<T> {\n+    n.checked_next_power_of_two()\n+}\n+\n+#[deprecated = \"Generalised bounded values are no longer supported\"]\n+pub trait Bounded {\n+    #[deprecated = \"Use `Int::min_value` or `Float::min_value`\"]\n+    fn min_value() -> Self;\n+    #[deprecated = \"Use `Int::max_value` or `Float::max_value`\"]\n+    fn max_value() -> Self;\n+}\n+macro_rules! bounded_impl {\n+    ($T:ty, $min:expr, $max:expr) => {\n+        impl Bounded for $T {\n+            #[inline]\n+            fn min_value() -> $T { $min }\n+\n+            #[inline]\n+            fn max_value() -> $T { $max }\n+        }\n+    };\n+}\n+bounded_impl!(uint, uint::MIN, uint::MAX)\n+bounded_impl!(u8, u8::MIN, u8::MAX)\n+bounded_impl!(u16, u16::MIN, u16::MAX)\n+bounded_impl!(u32, u32::MIN, u32::MAX)\n+bounded_impl!(u64, u64::MIN, u64::MAX)\n+bounded_impl!(int, int::MIN, int::MAX)\n+bounded_impl!(i8, i8::MIN, i8::MAX)\n+bounded_impl!(i16, i16::MIN, i16::MAX)\n+bounded_impl!(i32, i32::MIN, i32::MAX)\n+bounded_impl!(i64, i64::MIN, i64::MAX)\n+bounded_impl!(f32, f32::MIN_VALUE, f32::MAX_VALUE)\n+bounded_impl!(f64, f64::MIN_VALUE, f64::MAX_VALUE)"}, {"sha": "60012ab149f2ad07bd1c454d32af253c1dc9fd85", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -51,9 +51,7 @@ pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n pub use iter::{FromIterator, Extend};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n-pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n-pub use num::{Signed, Unsigned, Float};\n-pub use num::{Primitive, Int, ToPrimitive, FromPrimitive};\n+pub use num::{ToPrimitive, FromPrimitive};\n pub use option::{Option, Some, None};\n pub use ptr::RawPtr;\n pub use result::{Result, Ok, Err};"}, {"sha": "665b6705dad1a2f350b03efb8a13ebb8fd82d2dd", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -40,7 +40,7 @@ use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Less, Equal, Greater, Equiv}\n use cmp;\n use default::Default;\n use iter::*;\n-use num::{CheckedAdd, Saturating, div_rem};\n+use num::{Int, div_rem};\n use ops;\n use option::{None, Option, Some};\n use ptr;\n@@ -1346,7 +1346,7 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n             (0, Some(0))\n         } else {\n             let x = self.v.len() - self.size;\n-            (x.saturating_add(1), x.checked_add(&1u))\n+            (x.saturating_add(1), x.checked_add(1u))\n         }\n     }\n }"}, {"sha": "8b1d80f4a6a50821ee211492e521ddb197a1a390", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -25,7 +25,7 @@ use iter::{Map, Iterator};\n use iter::{DoubleEndedIterator, ExactSize};\n use iter::range;\n use kinds::Sized;\n-use num::{CheckedMul, Saturating};\n+use num::Int;\n use option::{Option, None, Some};\n use raw::Repr;\n use slice::{mod, SlicePrelude};\n@@ -750,7 +750,7 @@ impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n         // every char gets either one u16 or two u16,\n         // so this iterator is between 1 or 2 times as\n         // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(&2)))\n+        (low, high.and_then(|n| n.checked_mul(2)))\n     }\n }\n "}, {"sha": "716300f652d674c5a2a2cf2a401e4d66b1ded1c1", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -109,6 +109,8 @@ fn test_partial_max() {\n \n #[test]\n fn test_user_defined_eq() {\n+    use core::num::SignedInt;\n+\n     // Our type.\n     struct SketchyNum {\n         num : int"}, {"sha": "7764fb26c11c46ead3304470e6d0e7a8d4160c5e", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -10,9 +10,9 @@\n \n use core::iter::*;\n use core::iter::order::*;\n+use core::num::SignedInt;\n use core::uint;\n use core::cmp;\n-use core::num;\n use core::ops::Slice;\n \n use test::Bencher;\n@@ -689,50 +689,6 @@ fn test_double_ended_range() {\n \n #[test]\n fn test_range() {\n-    /// A mock type to check Range when ToPrimitive returns None\n-    struct Foo;\n-\n-    impl ToPrimitive for Foo {\n-        fn to_i64(&self) -> Option<i64> { None }\n-        fn to_u64(&self) -> Option<u64> { None }\n-    }\n-\n-    impl Add<Foo, Foo> for Foo {\n-        fn add(&self, _: &Foo) -> Foo {\n-            Foo\n-        }\n-    }\n-\n-    impl PartialEq for Foo {\n-        fn eq(&self, _: &Foo) -> bool {\n-            true\n-        }\n-    }\n-\n-    impl PartialOrd for Foo {\n-        fn partial_cmp(&self, _: &Foo) -> Option<Ordering> {\n-            None\n-        }\n-    }\n-\n-    impl Clone for Foo {\n-        fn clone(&self) -> Foo {\n-            Foo\n-        }\n-    }\n-\n-    impl Mul<Foo, Foo> for Foo {\n-        fn mul(&self, _: &Foo) -> Foo {\n-            Foo\n-        }\n-    }\n-\n-    impl num::One for Foo {\n-        fn one() -> Foo {\n-            Foo\n-        }\n-    }\n-\n     assert!(range(0i, 5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n     assert!(range(-10i, -1).collect::<Vec<int>>() ==\n                vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n@@ -746,7 +702,6 @@ fn test_range() {\n     // this test is only meaningful when sizeof uint < sizeof u64\n     assert_eq!(range(uint::MAX - 1, uint::MAX).size_hint(), (1, Some(1)));\n     assert_eq!(range(-10i, -1).size_hint(), (9, Some(9)));\n-    assert_eq!(range(Foo, Foo).size_hint(), (0, None));\n }\n \n #[test]"}, {"sha": "5e2530ef2a92b40692f965ed49288306e9ccdd70", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -15,8 +15,8 @@ macro_rules! int_module (($T:ty, $T_i:ident) => (\n mod tests {\n     use core::$T_i::*;\n     use core::int;\n+    use core::num::{Int, SignedInt};\n     use num;\n-    use core::num::CheckedDiv;\n \n     #[test]\n     fn test_overflows() {\n@@ -37,14 +37,6 @@ mod tests {\n         assert!((-1 as $T).abs() == 1 as $T);\n     }\n \n-    #[test]\n-    fn test_abs_sub() {\n-        assert!((-1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n-        assert!((1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n-        assert!((1 as $T).abs_sub(&(0 as $T)) == 1 as $T);\n-        assert!((1 as $T).abs_sub(&(-1 as $T)) == 2 as $T);\n-    }\n-\n     #[test]\n     fn test_signum() {\n         assert!((1 as $T).signum() == 1 as $T);\n@@ -160,9 +152,9 @@ mod tests {\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert!(10i.checked_div(&2) == Some(5));\n-        assert!(5i.checked_div(&0) == None);\n-        assert!(int::MIN.checked_div(&-1) == None);\n+        assert!(10i.checked_div(2) == Some(5));\n+        assert!(5i.checked_div(0) == None);\n+        assert!(int::MIN.checked_div(-1) == None);\n     }\n }\n "}, {"sha": "38502321c1d217faec7c91946c21fc0738b5e6e6", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::num::cast;\n+use core::cmp::PartialEq;\n+use core::fmt::Show;\n+use core::num::{NumCast, cast};\n+use core::ops::{Add, Sub, Mul, Div, Rem};\n \n mod int_macros;\n mod i8;\n@@ -24,7 +27,12 @@ mod u64;\n mod uint;\n \n /// Helper function for testing numeric operations\n-pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n+pub fn test_num<T>(ten: T, two: T) where\n+    T: PartialEq + NumCast\n+     + Add<T, T> + Sub<T, T>\n+     + Mul<T, T> + Div<T, T>\n+     + Rem<T, T> + Show\n+{\n     assert_eq!(ten.add(&two),  cast(12i).unwrap());\n     assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n     assert_eq!(ten.mul(&two),  cast(20i).unwrap());"}, {"sha": "01a88119b6470a425e438852a4d2b90d0046e7da", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -14,8 +14,8 @@ macro_rules! uint_module (($T:ty, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n+    use core::num::Int;\n     use num;\n-    use core::num::CheckedDiv;\n \n     #[test]\n     fn test_overflows() {\n@@ -120,8 +120,8 @@ mod tests {\n \n     #[test]\n     fn test_unsigned_checked_div() {\n-        assert!(10u.checked_div(&2) == Some(5));\n-        assert!(5u.checked_div(&0) == None);\n+        assert!(10u.checked_div(2) == Some(5));\n+        assert!(5u.checked_div(0) == None);\n     }\n }\n ))"}, {"sha": "2693f183644309c3454c1ebd503c9b7a569d56fb", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -11,6 +11,7 @@\n //! The ChaCha random number generator.\n \n use core::prelude::*;\n+use core::num::Int;\n \n use {Rng, SeedableRng, Rand};\n "}, {"sha": "7d54422601b775f75ba3f991e39131e46ec7ceb4", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -23,7 +23,7 @@ that do not need to record state.\n #![experimental]\n \n use core::prelude::*;\n-use core::num;\n+use core::num::{Float, Int};\n \n use {Rng, Rand};\n \n@@ -127,7 +127,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         // weights so we can binary search. This *could* drop elements\n         // with weight == 0 as an optimisation.\n         for item in items.iter_mut() {\n-            running_total = match running_total.checked_add(&item.weight) {\n+            running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n                 None => panic!(\"WeightedChoice::new called with a total weight \\\n                                larger than a uint can contain\")\n@@ -243,7 +243,7 @@ fn ziggurat<R:Rng>(\n         let u = if symmetric {2.0 * f - 1.0} else {f};\n         let x = u * x_tab[i];\n \n-        let test_x = if symmetric {num::abs(x)} else {x};\n+        let test_x = if symmetric { x.abs() } else {x};\n \n         // algebraically equivalent to |u| < x_tab[i+1]/x_tab[i] (or u < x_tab[i+1]/x_tab[i])\n         if test_x < x_tab[i + 1] {"}, {"sha": "03270ff3c60137fbecf01e910ee22f9ea4b8ba4e", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -13,7 +13,7 @@\n // this is surprisingly complicated to be both generic & correct\n \n use core::prelude::*;\n-use core::num::Bounded;\n+use core::num::Int;\n \n use Rng;\n use distributions::{Sample, IndependentSample};\n@@ -98,7 +98,7 @@ macro_rules! integer_impl {\n \n             fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n                 let range = high as $unsigned - low as $unsigned;\n-                let unsigned_max: $unsigned = Bounded::max_value();\n+                let unsigned_max: $unsigned = Int::max_value();\n \n                 // this is the largest number that fits into $unsigned\n                 // that `range` divides evenly, so, if we've sampled\n@@ -163,10 +163,10 @@ float_impl! { f64 }\n \n #[cfg(test)]\n mod tests {\n+    use std::num::Int;\n     use std::prelude::*;\n     use distributions::{Sample, IndependentSample};\n     use super::Range;\n-    use std::num::Bounded;\n \n     #[should_fail]\n     #[test]\n@@ -187,7 +187,7 @@ mod tests {\n                 $(\n                    let v: &[($ty, $ty)] = [(0, 10),\n                                            (10, 127),\n-                                           (Bounded::min_value(), Bounded::max_value())];\n+                                           (Int::min_value(), Int::max_value())];\n                    for &(low, high) in v.iter() {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in range(0u, 1000) {"}, {"sha": "90cd7920e688cbdbe0c412d63cc4ae5324d7f1fb", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -114,10 +114,11 @@ pub enum Error {\n pub mod reader {\n     use std::char;\n \n-    use std::mem::transmute;\n     use std::int;\n-    use std::option::{None, Option, Some};\n     use std::io::extensions::u64_from_be_bytes;\n+    use std::mem::transmute;\n+    use std::num::Int;\n+    use std::option::{None, Option, Some};\n \n     use serialize;\n "}, {"sha": "3fbf830485b28866f7319950eb46ba234128ad66", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -23,6 +23,7 @@ use flate;\n \n use std::iter;\n use std::mem;\n+use std::num::Int;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[String]) {"}, {"sha": "86dd967026b846604711107812320574483de9b3", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -37,6 +37,7 @@ use lint::{Context, LintPass, LintArray};\n \n use std::cmp;\n use std::collections::hash_map::{Occupied, Vacant};\n+use std::num::SignedInt;\n use std::slice;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::abi;"}, {"sha": "a893f8e89598dc75984b70620789e3cacbc23941", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -21,6 +21,7 @@ use middle::ty;\n use std::fmt;\n use std::iter::AdditiveIterator;\n use std::iter::range_inclusive;\n+use std::num::Float;\n use std::slice;\n use syntax::ast::*;\n use syntax::ast_util::walk_pat;"}, {"sha": "a597325015c708cd2aa320d435ba8c6d3d2fbbd6", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -21,18 +21,17 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use std::num::Int;\n use syntax::abi;\n use syntax::ast;\n \n-use std::num::CheckedMul;\n-\n // LLVM doesn't like objects that are too big. Issue #17913\n fn ensure_array_fits_in_address_space(ccx: &CrateContext,\n                                       llet: Type,\n                                       size: machine::llsize,\n                                       scapegoat: ty::t) {\n     let esz = machine::llsize_of_alloc(ccx, llet);\n-    match esz.checked_mul(&size) {\n+    match esz.checked_mul(size) {\n         Some(n) if n < ccx.max_obj_size() => {}\n         _ => { ccx.report_overbig_object(scapegoat) }\n     }"}, {"sha": "4319cd791b84f493cdc38b016b796021427f492c", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -15,7 +15,7 @@\n #![allow(deprecated)] // to_be32\n \n use std::iter::range_step;\n-use std::num::Zero;\n+use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n \n@@ -61,14 +61,14 @@ impl ToBits for u64 {\n \n /// Adds the specified number of bytes to the bit count. panic!() if this would cause numeric\n /// overflow.\n-fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n+fn add_bytes_to_bits<T: Int + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n-    if new_high_bits > Zero::zero() {\n+    if new_high_bits > Int::zero() {\n         panic!(\"numeric overflow occurred.\")\n     }\n \n-    match bits.checked_add(&new_low_bits) {\n+    match bits.checked_add(new_low_bits) {\n         Some(x) => return x,\n         None => panic!(\"numeric overflow occurred.\")\n     }\n@@ -528,10 +528,10 @@ mod tests {\n     extern crate rand;\n \n     use super::{Digest, Sha256, FixedBuffer};\n-    use std::num::Bounded;\n     use self::rand::isaac::IsaacRng;\n     use self::rand::Rng;\n     use serialize::hex::FromHex;\n+    use std::num::Int;\n \n     // A normal addition - no overflow occurs\n     #[test]\n@@ -543,7 +543,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_add_bytes_to_bits_overflow() {\n-        super::add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n+        super::add_bytes_to_bits::<u64>(Int::max_value(), 1);\n     }\n \n     struct Test {"}, {"sha": "b0e1aeea3a182b84278a39dba63548ca27d865a6", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -15,7 +15,6 @@\n \n use std::ops::Add;\n use std::num::Zero;\n-use std::iter::AdditiveIterator;\n \n use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n use syntax::ast::Public;\n@@ -55,6 +54,18 @@ impl Add<Counts, Counts> for Counts {\n }\n \n impl Counts {\n+    fn zero() -> Counts {\n+        Counts {\n+            deprecated:   0,\n+            experimental: 0,\n+            unstable:     0,\n+            stable:       0,\n+            frozen:       0,\n+            locked:       0,\n+            unmarked:     0,\n+        }\n+    }\n+\n     pub fn total(&self) -> uint {\n         self.deprecated + self.experimental + self.unstable + self.stable +\n             self.frozen + self.locked + self.unmarked\n@@ -92,14 +103,14 @@ fn visible(item: &Item) -> bool {\n \n fn count_stability(stab: Option<&Stability>) -> Counts {\n     match stab {\n-        None             => Counts { unmarked: 1,     .. Zero::zero() },\n+        None             => Counts { unmarked: 1,     .. Counts::zero() },\n         Some(ref stab) => match stab.level {\n-            Deprecated   => Counts { deprecated: 1,   .. Zero::zero() },\n-            Experimental => Counts { experimental: 1, .. Zero::zero() },\n-            Unstable     => Counts { unstable: 1,     .. Zero::zero() },\n-            Stable       => Counts { stable: 1,       .. Zero::zero() },\n-            Frozen       => Counts { frozen: 1,       .. Zero::zero() },\n-            Locked       => Counts { locked: 1,       .. Zero::zero() },\n+            Deprecated   => Counts { deprecated: 1,   .. Counts::zero() },\n+            Experimental => Counts { experimental: 1, .. Counts::zero() },\n+            Unstable     => Counts { unstable: 1,     .. Counts::zero() },\n+            Stable       => Counts { stable: 1,       .. Counts::zero() },\n+            Frozen       => Counts { frozen: 1,       .. Counts::zero() },\n+            Locked       => Counts { locked: 1,       .. Counts::zero() },\n         }\n     }\n }\n@@ -108,15 +119,19 @@ fn summarize_methods(item: &Item) -> Counts {\n     match cache_key.get().unwrap().impls.get(&item.def_id) {\n         Some(v) => {\n             v.iter().map(|i| {\n-                let mut count = count_stability(i.stability.as_ref());\n+                let count = count_stability(i.stability.as_ref());\n                 if i.impl_.trait_.is_none() {\n-                    count = count +\n-                        i.impl_.items.iter().map(|ti| summarize_item(ti).0).sum();\n+                    count + i.impl_.items.iter()\n+                        .map(|ti| summarize_item(ti).0)\n+                        .fold(Counts::zero(), |acc, c| acc + c)\n+                } else {\n+                    count\n                 }\n-                count\n-            }).sum()\n-        }\n-        None    => Zero::zero()\n+            }).fold(Counts::zero(), |acc, c| acc + c)\n+        },\n+        None => {\n+            Counts::zero()\n+        },\n     }\n }\n \n@@ -136,14 +151,14 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             let subcounts = subitems.iter().filter(|i| visible(*i))\n                                            .map(summarize_item)\n                                            .map(|s| s.val0())\n-                                           .sum();\n+                                           .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n         // `pub` automatically\n         EnumItem(Enum { variants: ref subitems, .. }) => {\n             let subcounts = subitems.iter().map(summarize_item)\n                                            .map(|s| s.val0())\n-                                           .sum();\n+                                           .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n         TraitItem(Trait {\n@@ -161,7 +176,7 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n                                        .map(extract_item)\n                                        .map(summarize_item)\n                                        .map(|s| s.val0())\n-                                       .sum();\n+                                       .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n         ModuleItem(Module { ref items, .. }) => {\n@@ -182,7 +197,7 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             }))\n         }\n         // no stability information for the following items:\n-        ViewItemItem(_) | PrimitiveItem(_) => (Zero::zero(), None),\n+        ViewItemItem(_) | PrimitiveItem(_) => (Counts::zero(), None),\n         _ => (item_counts, None)\n     }\n }\n@@ -192,7 +207,7 @@ pub fn build(krate: &Crate) -> ModuleSummary {\n     match krate.module {\n         None => ModuleSummary {\n             name: krate.name.clone(),\n-            counts: Zero::zero(),\n+            counts: Counts::zero(),\n             submodules: Vec::new(),\n         },\n         Some(ref item) => ModuleSummary {"}, {"sha": "524638155ac16f597bcb7733bffc36b624a00cb5", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -199,7 +199,7 @@ use std::collections::{HashMap, TreeMap};\n use std::{char, f64, fmt, io, num, str};\n use std::io::MemWriter;\n use std::mem::{swap, transmute};\n-use std::num::{FPNaN, FPInfinite};\n+use std::num::{Float, FPNaN, FPInfinite, Int};\n use std::str::ScalarValue;\n use std::string;\n use std::vec::Vec;\n@@ -609,7 +609,7 @@ impl<'a> PrettyEncoder<'a> {\n     /// This is safe to set during encoding.\n     pub fn set_indent<'a>(&mut self, indent: uint) {\n         // self.indent very well could be 0 so we need to use checked division.\n-        let level = self.curr_indent.checked_div(&self.indent).unwrap_or(0);\n+        let level = self.curr_indent.checked_div(self.indent).unwrap_or(0);\n         self.indent = indent;\n         self.curr_indent = level * self.indent;\n     }\n@@ -1484,7 +1484,7 @@ impl<T: Iterator<char>> Parser<T> {\n             }\n         }\n \n-        let exp = num::pow(10_f64, exp);\n+        let exp = 10_f64.powi(exp as i32);\n         if neg_exp {\n             res /= exp;\n         } else {\n@@ -2417,6 +2417,7 @@ mod tests {\n                 TrailingCharacters, TrailingComma};\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::TreeMap;\n+    use std::num::Float;\n     use std::string;\n \n     #[deriving(Decodable, Eq, PartialEq, Show)]"}, {"sha": "68c428f456db2b21d35b142177d7d7b8ba30699e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -18,7 +18,7 @@ use hash::{Hash, Hasher, RandomSipHasher};\n use iter::{mod, Iterator, FromIterator, Extend};\n use kinds::Sized;\n use mem::{mod, replace};\n-use num;\n+use num::UnsignedInt;\n use ops::{Deref, Index, IndexMut};\n use option::{Some, None, Option};\n use result::{Result, Ok, Err};\n@@ -549,7 +549,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n-        let cap = num::next_power_of_two(max(INITIAL_CAPACITY, capacity));\n+        let cap = max(INITIAL_CAPACITY, capacity).next_power_of_two();\n         HashMap {\n             hasher:        hasher,\n             resize_policy: DefaultResizePolicy::new(cap),\n@@ -572,8 +572,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// map.reserve(10);\n     /// ```\n     pub fn reserve(&mut self, new_minimum_capacity: uint) {\n-        let cap = num::next_power_of_two(\n-            max(INITIAL_CAPACITY, new_minimum_capacity));\n+        let cap = max(INITIAL_CAPACITY, new_minimum_capacity).next_power_of_two();\n \n         self.resize_policy.reserve(cap);\n \n@@ -588,7 +587,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///   2) Ensure new_capacity is a power of two.\n     fn resize(&mut self, new_capacity: uint) {\n         assert!(self.table.size() <= new_capacity);\n-        assert!(num::is_power_of_two(new_capacity));\n+        assert!(new_capacity.is_power_of_two());\n \n         let mut old_table = replace(&mut self.table, RawTable::new(new_capacity));\n         let old_size = old_table.size();"}, {"sha": "4838d3d73f1e09f18ad892e21aae7d486cdabc5c", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -17,7 +17,7 @@ use iter::{Iterator, count};\n use kinds::{Sized, marker};\n use mem::{min_align_of, size_of};\n use mem;\n-use num::{CheckedAdd, CheckedMul, is_power_of_two};\n+use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::{Some, None, Option};\n use ptr::{RawPtr, copy_nonoverlapping_memory, zero_memory};\n@@ -493,7 +493,7 @@ impl<K, V, M: Deref<RawTable<K, V>>> GapThenFull<K, V, M> {\n ///\n /// Fails if `target_alignment` is not a power of two.\n fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n-    assert!(is_power_of_two(target_alignment));\n+    assert!(target_alignment.is_power_of_two());\n     (unrounded + target_alignment - 1) & !(target_alignment - 1)\n }\n \n@@ -581,9 +581,9 @@ impl<K, V> RawTable<K, V> {\n                 vals_size,   min_align_of::< V >());\n \n         // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<u64>().checked_add(&size_of::<K>()).unwrap()\n-                                             .checked_add(&size_of::<V>()).unwrap();\n-        assert!(size >= capacity.checked_mul(&size_of_bucket)\n+        let size_of_bucket = size_of::<u64>().checked_add(size_of::<K>()).unwrap()\n+                                             .checked_add(size_of::<V>()).unwrap();\n+        assert!(size >= capacity.checked_mul(size_of_bucket)\n                                 .expect(\"capacity overflow\"),\n                 \"capacity overflow\");\n "}, {"sha": "eb81935a8c903e99b0b3f0fc3f2b5393d0ed242e", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -190,6 +190,7 @@ like:\n ```rust\n use std::fmt;\n use std::f64;\n+use std::num::Float;\n \n struct Vector2D {\n     x: int,"}, {"sha": "3f46cc8af50b198fa60521e7fac01015d9cfdf72", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -20,6 +20,7 @@ use prelude::*;\n use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n+use num::{Float, FloatMath};\n use num::strconv;\n use num;\n \n@@ -108,6 +109,11 @@ impl FloatMath for f32 {\n         unsafe { cmath::fminf(self, other) }\n     }\n \n+    #[inline]\n+    fn abs_sub(self, other: f32) -> f32 {\n+        unsafe { cmath::fdimf(self, other) }\n+    }\n+\n     #[inline]\n     fn cbrt(self) -> f32 {\n         unsafe { cmath::cbrtf(self) }\n@@ -593,20 +599,20 @@ mod tests {\n \n     #[test]\n     fn test_abs_sub() {\n-        assert_eq!((-1f32).abs_sub(&1f32), 0f32);\n-        assert_eq!(1f32.abs_sub(&1f32), 0f32);\n-        assert_eq!(1f32.abs_sub(&0f32), 1f32);\n-        assert_eq!(1f32.abs_sub(&-1f32), 2f32);\n-        assert_eq!(NEG_INFINITY.abs_sub(&0f32), 0f32);\n-        assert_eq!(INFINITY.abs_sub(&1f32), INFINITY);\n-        assert_eq!(0f32.abs_sub(&NEG_INFINITY), INFINITY);\n-        assert_eq!(0f32.abs_sub(&INFINITY), 0f32);\n+        assert_eq!((-1f32).abs_sub(1f32), 0f32);\n+        assert_eq!(1f32.abs_sub(1f32), 0f32);\n+        assert_eq!(1f32.abs_sub(0f32), 1f32);\n+        assert_eq!(1f32.abs_sub(-1f32), 2f32);\n+        assert_eq!(NEG_INFINITY.abs_sub(0f32), 0f32);\n+        assert_eq!(INFINITY.abs_sub(1f32), INFINITY);\n+        assert_eq!(0f32.abs_sub(NEG_INFINITY), INFINITY);\n+        assert_eq!(0f32.abs_sub(INFINITY), 0f32);\n     }\n \n     #[test]\n     fn test_abs_sub_nowin() {\n-        assert!(NAN.abs_sub(&-1f32).is_nan());\n-        assert!(1f32.abs_sub(&NAN).is_nan());\n+        assert!(NAN.abs_sub(-1f32).is_nan());\n+        assert!(1f32.abs_sub(NAN).is_nan());\n     }\n \n     #[test]\n@@ -650,7 +656,7 @@ mod tests {\n         let nan: f32 = Float::nan();\n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Zero::zero();\n+        let zero: f32 = Float::zero();\n         let neg_zero: f32 = Float::neg_zero();\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n@@ -667,7 +673,7 @@ mod tests {\n         let nan: f32 = Float::nan();\n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Zero::zero();\n+        let zero: f32 = Float::zero();\n         let neg_zero: f32 = Float::neg_zero();\n         assert_eq!(nan.classify(), FPNaN);\n         assert_eq!(inf.classify(), FPInfinite);"}, {"sha": "4d691fc967698bde8a09bc8e17c70dfd4cbd6638", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -19,6 +19,7 @@ use prelude::*;\n use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n+use num::{Float, FloatMath};\n use num::strconv;\n use num;\n \n@@ -116,6 +117,11 @@ impl FloatMath for f64 {\n         unsafe { cmath::fmin(self, other) }\n     }\n \n+    #[inline]\n+    fn abs_sub(self, other: f64) -> f64 {\n+        unsafe { cmath::fdim(self, other) }\n+    }\n+\n     #[inline]\n     fn cbrt(self) -> f64 {\n         unsafe { cmath::cbrt(self) }\n@@ -591,20 +597,20 @@ mod tests {\n \n     #[test]\n     fn test_abs_sub() {\n-        assert_eq!((-1f64).abs_sub(&1f64), 0f64);\n-        assert_eq!(1f64.abs_sub(&1f64), 0f64);\n-        assert_eq!(1f64.abs_sub(&0f64), 1f64);\n-        assert_eq!(1f64.abs_sub(&-1f64), 2f64);\n-        assert_eq!(NEG_INFINITY.abs_sub(&0f64), 0f64);\n-        assert_eq!(INFINITY.abs_sub(&1f64), INFINITY);\n-        assert_eq!(0f64.abs_sub(&NEG_INFINITY), INFINITY);\n-        assert_eq!(0f64.abs_sub(&INFINITY), 0f64);\n+        assert_eq!((-1f64).abs_sub(1f64), 0f64);\n+        assert_eq!(1f64.abs_sub(1f64), 0f64);\n+        assert_eq!(1f64.abs_sub(0f64), 1f64);\n+        assert_eq!(1f64.abs_sub(-1f64), 2f64);\n+        assert_eq!(NEG_INFINITY.abs_sub(0f64), 0f64);\n+        assert_eq!(INFINITY.abs_sub(1f64), INFINITY);\n+        assert_eq!(0f64.abs_sub(NEG_INFINITY), INFINITY);\n+        assert_eq!(0f64.abs_sub(INFINITY), 0f64);\n     }\n \n     #[test]\n     fn test_abs_sub_nowin() {\n-        assert!(NAN.abs_sub(&-1f64).is_nan());\n-        assert!(1f64.abs_sub(&NAN).is_nan());\n+        assert!(NAN.abs_sub(-1f64).is_nan());\n+        assert!(1f64.abs_sub(NAN).is_nan());\n     }\n \n     #[test]\n@@ -648,7 +654,7 @@ mod tests {\n         let nan: f64 = Float::nan();\n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Zero::zero();\n+        let zero: f64 = Float::zero();\n         let neg_zero: f64 = Float::neg_zero();\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n@@ -665,7 +671,7 @@ mod tests {\n         let nan: f64 = Float::nan();\n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Zero::zero();\n+        let zero: f64 = Float::zero();\n         let neg_zero: f64 = Float::neg_zero();\n         assert_eq!(nan.classify(), FPNaN);\n         assert_eq!(inf.classify(), FPInfinite);"}, {"sha": "4b3727ead6148982e27545fefa86004caed1a741", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -14,6 +14,7 @@\n \n macro_rules! assert_approx_eq(\n     ($a:expr, $b:expr) => ({\n+        use num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "0afc8ce0452c8cc05bf6e3950cdd1884afb37827", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -18,13 +18,13 @@\n \n use option::Option;\n \n+#[cfg(test)] use cmp::PartialEq;\n #[cfg(test)] use fmt::Show;\n+#[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n \n pub use core::num::{Num, div_rem, Zero, zero, One, one};\n-pub use core::num::{Signed, abs, abs_sub, signum};\n pub use core::num::{Unsigned, pow, Bounded};\n-pub use core::num::{Primitive, Int, Saturating};\n-pub use core::num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+pub use core::num::{Primitive, Int, SignedInt, UnsignedInt};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n pub use core::num::{next_power_of_two, is_power_of_two};\n pub use core::num::{checked_next_power_of_two};\n@@ -58,6 +58,11 @@ pub trait FloatMath: Float {\n     /// Returns the minimum of the two numbers.\n     fn min(self, other: Self) -> Self;\n \n+    /// The positive difference of two numbers. Returns `0.0` if the number is\n+    /// less than or equal to `other`, otherwise the difference between`self`\n+    /// and `other` is returned.\n+    fn abs_sub(self, other: Self) -> Self;\n+\n     /// Take the cubic root of a number.\n     fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n@@ -122,9 +127,21 @@ pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n+// DEPRECATED\n+\n+#[deprecated = \"Use `FloatMath::abs_sub`\"]\n+pub fn abs_sub<T: FloatMath>(x: T, y: T) -> T {\n+    x.abs_sub(y)\n+}\n+\n /// Helper function for testing numeric operations\n #[cfg(test)]\n-pub fn test_num<T:Num + NumCast + Show>(ten: T, two: T) {\n+pub fn test_num<T>(ten: T, two: T) where\n+    T: PartialEq + NumCast\n+     + Add<T, T> + Sub<T, T>\n+     + Mul<T, T> + Div<T, T>\n+     + Rem<T, T> + Show\n+{\n     assert_eq!(ten.add(&two),  cast(12i).unwrap());\n     assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n     assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n@@ -624,46 +641,46 @@ mod tests {\n     #[test]\n     fn test_checked_add() {\n         let five_less = uint::MAX - 5;\n-        assert_eq!(five_less.checked_add(&0), Some(uint::MAX - 5));\n-        assert_eq!(five_less.checked_add(&1), Some(uint::MAX - 4));\n-        assert_eq!(five_less.checked_add(&2), Some(uint::MAX - 3));\n-        assert_eq!(five_less.checked_add(&3), Some(uint::MAX - 2));\n-        assert_eq!(five_less.checked_add(&4), Some(uint::MAX - 1));\n-        assert_eq!(five_less.checked_add(&5), Some(uint::MAX));\n-        assert_eq!(five_less.checked_add(&6), None);\n-        assert_eq!(five_less.checked_add(&7), None);\n+        assert_eq!(five_less.checked_add(0), Some(uint::MAX - 5));\n+        assert_eq!(five_less.checked_add(1), Some(uint::MAX - 4));\n+        assert_eq!(five_less.checked_add(2), Some(uint::MAX - 3));\n+        assert_eq!(five_less.checked_add(3), Some(uint::MAX - 2));\n+        assert_eq!(five_less.checked_add(4), Some(uint::MAX - 1));\n+        assert_eq!(five_less.checked_add(5), Some(uint::MAX));\n+        assert_eq!(five_less.checked_add(6), None);\n+        assert_eq!(five_less.checked_add(7), None);\n     }\n \n     #[test]\n     fn test_checked_sub() {\n-        assert_eq!(5u.checked_sub(&0), Some(5));\n-        assert_eq!(5u.checked_sub(&1), Some(4));\n-        assert_eq!(5u.checked_sub(&2), Some(3));\n-        assert_eq!(5u.checked_sub(&3), Some(2));\n-        assert_eq!(5u.checked_sub(&4), Some(1));\n-        assert_eq!(5u.checked_sub(&5), Some(0));\n-        assert_eq!(5u.checked_sub(&6), None);\n-        assert_eq!(5u.checked_sub(&7), None);\n+        assert_eq!(5u.checked_sub(0), Some(5));\n+        assert_eq!(5u.checked_sub(1), Some(4));\n+        assert_eq!(5u.checked_sub(2), Some(3));\n+        assert_eq!(5u.checked_sub(3), Some(2));\n+        assert_eq!(5u.checked_sub(4), Some(1));\n+        assert_eq!(5u.checked_sub(5), Some(0));\n+        assert_eq!(5u.checked_sub(6), None);\n+        assert_eq!(5u.checked_sub(7), None);\n     }\n \n     #[test]\n     fn test_checked_mul() {\n         let third = uint::MAX / 3;\n-        assert_eq!(third.checked_mul(&0), Some(0));\n-        assert_eq!(third.checked_mul(&1), Some(third));\n-        assert_eq!(third.checked_mul(&2), Some(third * 2));\n-        assert_eq!(third.checked_mul(&3), Some(third * 3));\n-        assert_eq!(third.checked_mul(&4), None);\n+        assert_eq!(third.checked_mul(0), Some(0));\n+        assert_eq!(third.checked_mul(1), Some(third));\n+        assert_eq!(third.checked_mul(2), Some(third * 2));\n+        assert_eq!(third.checked_mul(3), Some(third * 3));\n+        assert_eq!(third.checked_mul(4), None);\n     }\n \n     macro_rules! test_next_power_of_two(\n         ($test_name:ident, $T:ident) => (\n             fn $test_name() {\n                 #![test]\n-                assert_eq!(next_power_of_two::<$T>(0), 0);\n+                assert_eq!((0 as $T).next_power_of_two(), 0);\n                 let mut next_power = 1;\n                 for i in range::<$T>(1, 40) {\n-                     assert_eq!(next_power_of_two(i), next_power);\n+                     assert_eq!(i.next_power_of_two(), next_power);\n                      if i == next_power { next_power *= 2 }\n                 }\n             }\n@@ -680,15 +697,15 @@ mod tests {\n         ($test_name:ident, $T:ident) => (\n             fn $test_name() {\n                 #![test]\n-                assert_eq!(checked_next_power_of_two::<$T>(0), None);\n+                assert_eq!((0 as $T).checked_next_power_of_two(), None);\n                 let mut next_power = 1;\n                 for i in range::<$T>(1, 40) {\n-                     assert_eq!(checked_next_power_of_two(i), Some(next_power));\n+                     assert_eq!(i.checked_next_power_of_two(), Some(next_power));\n                      if i == next_power { next_power *= 2 }\n                 }\n-                assert!(checked_next_power_of_two::<$T>($T::MAX / 2).is_some());\n-                assert_eq!(checked_next_power_of_two::<$T>($T::MAX - 1), None);\n-                assert_eq!(checked_next_power_of_two::<$T>($T::MAX), None);\n+                assert!(($T::MAX / 2).checked_next_power_of_two().is_some());\n+                assert_eq!(($T::MAX - 1).checked_next_power_of_two(), None);\n+                assert_eq!($T::MAX.checked_next_power_of_two(), None);\n             }\n         )\n     )\n@@ -760,10 +777,7 @@ mod tests {\n         assert_pow!((3i,     0 ) => 1);\n         assert_pow!((5i,     1 ) => 5);\n         assert_pow!((-4i,    2 ) => 16);\n-        assert_pow!((0.5f64, 5 ) => 0.03125);\n         assert_pow!((8i,     3 ) => 512);\n-        assert_pow!((8.0f64, 5 ) => 32768.0);\n-        assert_pow!((8.5f64, 5 ) => 44370.53125);\n         assert_pow!((2u64,   50) => 1125899906842624);\n     }\n }"}, {"sha": "06d2f0ef028e1b2013b94d0f8ada1b0195c5644a", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -17,8 +17,7 @@ use char::Char;\n use from_str::from_str;\n use iter::Iterator;\n use num;\n-use num::{Int, Bounded};\n-use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n+use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n use option::{None, Option, Some};\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n use str::StrPrelude;\n@@ -95,7 +94,7 @@ pub enum SignFormat {\n fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n-    let _0: T = num::zero();\n+    let _0: T = Int::zero();\n \n     let neg = num < _0;\n     let radix_gen: T = num::cast(radix).unwrap();\n@@ -117,7 +116,7 @@ fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8\n         // numbers [-35 .. 0] we always have [0 .. 35].\n         let current_digit_signed = deccum % radix_gen;\n         let current_digit = if current_digit_signed < _0 {\n-            -current_digit_signed\n+            _0 - current_digit_signed\n         } else {\n             current_digit_signed\n         };\n@@ -195,8 +194,8 @@ pub fn float_to_str_bytes_common<T: Float>(\n         _ => ()\n     }\n \n-    let _0: T = num::zero();\n-    let _1: T = num::one();\n+    let _0: T = Float::zero();\n+    let _1: T = Float::one();\n \n     match num.classify() {\n         FPNaN => { return (b\"NaN\".to_vec(), true); }\n@@ -431,8 +430,8 @@ pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n            \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n            radix);\n \n-    let _0: T = num::zero();\n-    let _1: T = num::one();\n+    let _0: T = Float::zero();\n+    let _1: T = Float::one();\n     let radix_t: T = num::cast(radix as int).unwrap();\n \n     // Special values\n@@ -559,8 +558,8 @@ pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n             };\n \n             match (is_positive, exp) {\n-                (true,  Some(exp)) => num::pow(base, exp),\n-                (false, Some(exp)) => _1 / num::pow(base, exp),\n+                (true,  Some(exp)) => base.powi(exp as i32),\n+                (false, Some(exp)) => _1 / base.powi(exp as i32),\n                 (_, None)          => return None,\n             }\n         },\n@@ -579,9 +578,9 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n         num::cast(x).unwrap()\n     }\n \n-    let _0: T = num::zero();\n-    let _1: T = num::one();\n-    let is_signed = _0 > Bounded::min_value();\n+    let _0: T = Int::zero();\n+    let _1: T = Int::one();\n+    let is_signed = _0 > Int::min_value();\n \n     let (is_positive, src) =  match src.slice_shift_char() {\n         (Some('-'), src) if is_signed => (false, src),\n@@ -601,11 +600,11 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n                 Some(x) => x,\n                 None => return None,\n             };\n-            result = match result.checked_mul(&radix) {\n+            result = match result.checked_mul(radix) {\n                 Some(result) => result,\n                 None => return None,\n             };\n-            result = match result.checked_add(&x) {\n+            result = match result.checked_add(x) {\n                 Some(result) => result,\n                 None => return None,\n             };\n@@ -616,11 +615,11 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n                 Some(x) => x,\n                 None => return None,\n             };\n-            result = match result.checked_mul(&radix) {\n+            result = match result.checked_mul(radix) {\n                 Some(result) => result,\n                 None => return None,\n             };\n-            result = match result.checked_sub(&x) {\n+            result = match result.checked_sub(x) {\n                 Some(result) => result,\n                 None => return None,\n             };"}, {"sha": "158e7a59f6dba381f0804ca32fbb6035a2c0dca8", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -67,9 +67,7 @@\n #[doc(no_inline)] pub use iter::{Iterator, DoubleEndedIterator};\n #[doc(no_inline)] pub use iter::{RandomAccessIterator, CloneableIterator};\n #[doc(no_inline)] pub use iter::{OrdIterator, MutableDoubleEndedIterator};\n-#[doc(no_inline)] pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n-#[doc(no_inline)] pub use num::{Signed, Unsigned, Primitive, Int, Float};\n-#[doc(no_inline)] pub use num::{FloatMath, ToPrimitive, FromPrimitive};\n+#[doc(no_inline)] pub use num::{ToPrimitive, FromPrimitive};\n #[doc(no_inline)] pub use boxed::Box;\n #[doc(no_inline)] pub use option::{Option, Some, None};\n #[doc(no_inline)] pub use path::{GenericPath, Path, PosixPath, WindowsPath};"}, {"sha": "ab3216e93a09e1e5e6988b4ecb420f796a8c9bca", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -78,6 +78,7 @@ mod test {\n \n     use super::ReaderRng;\n     use io::MemReader;\n+    use num::Int;\n     use rand::Rng;\n \n     #[test]"}, {"sha": "cacb128faa560438f5447a50112be3d3a96f0dea", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -13,9 +13,9 @@\n \n use io::{mod, IoError, IoResult};\n use prelude::*;\n-use num;\n use sys::{last_error, retry, fs};\n use c_str::CString;\n+use num::Int;\n use path::BytesContainer;\n use collections;\n \n@@ -57,8 +57,8 @@ pub fn unimpl() -> IoError {\n }\n \n // unix has nonzero values as errors\n-pub fn mkerr_libc<Int: num::Zero>(ret: Int) -> IoResult<()> {\n-    if !ret.is_zero() {\n+pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> {\n+    if ret != Int::zero() {\n         Err(last_error())\n     } else {\n         Ok(())"}, {"sha": "7bb3c6b0ec95a83a162852e8a6a5bd18b2ecdc80", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -11,6 +11,7 @@\n use alloc::arc::Arc;\n use libc::{mod, c_char, c_int};\n use mem;\n+use num::Int;\n use ptr::{mod, null, null_mut};\n use rt::mutex;\n use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};"}, {"sha": "4db9e8a9df8b5a98a2c7a989df6c83773342b2b1", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -18,6 +18,7 @@\n extern crate libc;\n \n use num;\n+use num::{Int, SignedInt};\n use prelude::*;\n use io::{mod, IoResult, IoError};\n use sys_common::mkerr_libc;\n@@ -116,11 +117,11 @@ pub fn decode_error_detailed(errno: i32) -> IoError {\n }\n \n #[inline]\n-pub fn retry<I: PartialEq + num::One + Neg<I>> (f: || -> I) -> I {\n-    let minus_one = -num::one::<I>();\n+pub fn retry<T: SignedInt> (f: || -> T) -> T {\n+    let one: T = Int::one();\n     loop {\n         let n = f();\n-        if n == minus_one && os::errno() == libc::EINTR as int { }\n+        if n == -one && os::errno() == libc::EINTR as int { }\n         else { return n }\n     }\n }"}, {"sha": "5c4e8bda84c87c062b549f12525d0fbab40c4bbc", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 60, "deletions": 71, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -15,8 +15,7 @@\n use {fmt, i64};\n use ops::{Add, Sub, Mul, Div, Neg};\n use option::{Option, Some, None};\n-use num;\n-use num::{CheckedAdd, CheckedMul};\n+use num::Int;\n use result::{Result, Ok, Err};\n \n /// The number of nanoseconds in a microsecond.\n@@ -69,7 +68,7 @@ impl Duration {\n     /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn weeks(weeks: i64) -> Duration {\n-        let secs = weeks.checked_mul(&SECS_PER_WEEK).expect(\"Duration::weeks out of bounds\");\n+        let secs = weeks.checked_mul(SECS_PER_WEEK).expect(\"Duration::weeks out of bounds\");\n         Duration::seconds(secs)\n     }\n \n@@ -78,7 +77,7 @@ impl Duration {\n     /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn days(days: i64) -> Duration {\n-        let secs = days.checked_mul(&SECS_PER_DAY).expect(\"Duration::days out of bounds\");\n+        let secs = days.checked_mul(SECS_PER_DAY).expect(\"Duration::days out of bounds\");\n         Duration::seconds(secs)\n     }\n \n@@ -87,7 +86,7 @@ impl Duration {\n     /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn hours(hours: i64) -> Duration {\n-        let secs = hours.checked_mul(&SECS_PER_HOUR).expect(\"Duration::hours ouf of bounds\");\n+        let secs = hours.checked_mul(SECS_PER_HOUR).expect(\"Duration::hours ouf of bounds\");\n         Duration::seconds(secs)\n     }\n \n@@ -96,7 +95,7 @@ impl Duration {\n     /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn minutes(minutes: i64) -> Duration {\n-        let secs = minutes.checked_mul(&SECS_PER_MINUTE).expect(\"Duration::minutes out of bounds\");\n+        let secs = minutes.checked_mul(SECS_PER_MINUTE).expect(\"Duration::minutes out of bounds\");\n         Duration::seconds(secs)\n     }\n \n@@ -199,33 +198,64 @@ impl Duration {\n     /// Returns the total number of whole microseconds in the duration,\n     /// or `None` on overflow (exceeding 2^63 microseconds in either direction).\n     pub fn num_microseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(&MICROS_PER_SEC));\n+        let secs_part = try_opt!(self.num_seconds().checked_mul(MICROS_PER_SEC));\n         let nanos_part = self.nanos_mod_sec() / NANOS_PER_MICRO;\n-        secs_part.checked_add(&(nanos_part as i64))\n+        secs_part.checked_add(nanos_part as i64)\n     }\n \n     /// Returns the total number of whole nanoseconds in the duration,\n     /// or `None` on overflow (exceeding 2^63 nanoseconds in either direction).\n     pub fn num_nanoseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(&(NANOS_PER_SEC as i64)));\n+        let secs_part = try_opt!(self.num_seconds().checked_mul(NANOS_PER_SEC as i64));\n         let nanos_part = self.nanos_mod_sec();\n-        secs_part.checked_add(&(nanos_part as i64))\n+        secs_part.checked_add(nanos_part as i64)\n     }\n-}\n \n-impl num::Bounded for Duration {\n-    #[inline] fn min_value() -> Duration { MIN }\n-    #[inline] fn max_value() -> Duration { MAX }\n-}\n+    /// Add two durations, returning `None` if overflow occured.\n+    pub fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n+        let mut secs = try_opt!(self.secs.checked_add(rhs.secs));\n+        let mut nanos = self.nanos + rhs.nanos;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n+            secs = try_opt!(secs.checked_add(1));\n+        }\n+        let d = Duration { secs: secs, nanos: nanos };\n+        // Even if d is within the bounds of i64 seconds,\n+        // it might still overflow i64 milliseconds.\n+        if d < MIN || d > MAX { None } else { Some(d) }\n+    }\n+\n+    /// Subtract two durations, returning `None` if overflow occured.\n+    pub fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n+        let mut secs = try_opt!(self.secs.checked_sub(rhs.secs));\n+        let mut nanos = self.nanos - rhs.nanos;\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs = try_opt!(secs.checked_sub(1));\n+        }\n+        let d = Duration { secs: secs, nanos: nanos };\n+        // Even if d is within the bounds of i64 seconds,\n+        // it might still overflow i64 milliseconds.\n+        if d < MIN || d > MAX { None } else { Some(d) }\n+    }\n \n-impl num::Zero for Duration {\n+    /// The minimum possible `Duration`: `i64::MIN` milliseconds.\n     #[inline]\n-    fn zero() -> Duration {\n+    pub fn min_value() -> Duration { MIN }\n+\n+    /// The maximum possible `Duration`: `i64::MAX` milliseconds.\n+    #[inline]\n+    pub fn max_value() -> Duration { MAX }\n+\n+    /// A duration where the stored seconds and nanoseconds are equal to zero.\n+    #[inline]\n+    pub fn zero() -> Duration {\n         Duration { secs: 0, nanos: 0 }\n     }\n \n+    /// Returns `true` if the duration equals `Duration::zero()`.\n     #[inline]\n-    fn is_zero(&self) -> bool {\n+    pub fn is_zero(&self) -> bool {\n         self.secs == 0 && self.nanos == 0\n     }\n }\n@@ -253,21 +283,6 @@ impl Add<Duration,Duration> for Duration {\n     }\n }\n \n-impl num::CheckedAdd for Duration {\n-    fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut secs = try_opt!(self.secs.checked_add(&rhs.secs));\n-        let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs = try_opt!(secs.checked_add(&1));\n-        }\n-        let d = Duration { secs: secs, nanos: nanos };\n-        // Even if d is within the bounds of i64 seconds,\n-        // it might still overflow i64 milliseconds.\n-        if d < MIN || d > MAX { None } else { Some(d) }\n-    }\n-}\n-\n impl Sub<Duration,Duration> for Duration {\n     fn sub(&self, rhs: &Duration) -> Duration {\n         let mut secs = self.secs - rhs.secs;\n@@ -280,21 +295,6 @@ impl Sub<Duration,Duration> for Duration {\n     }\n }\n \n-impl num::CheckedSub for Duration {\n-    fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut secs = try_opt!(self.secs.checked_sub(&rhs.secs));\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs = try_opt!(secs.checked_sub(&1));\n-        }\n-        let d = Duration { secs: secs, nanos: nanos };\n-        // Even if d is within the bounds of i64 seconds,\n-        // it might still overflow i64 milliseconds.\n-        if d < MIN || d > MAX { None } else { Some(d) }\n-    }\n-}\n-\n impl Mul<i32,Duration> for Duration {\n     fn mul(&self, rhs: &i32) -> Duration {\n         // Multiply nanoseconds as i64, because it cannot overflow that way.\n@@ -387,15 +387,12 @@ fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n mod tests {\n     use super::{Duration, MIN, MAX};\n     use {i32, i64};\n-    use num::{Zero, CheckedAdd, CheckedSub};\n     use option::{Some, None};\n     use to_string::ToString;\n \n     #[test]\n     fn test_duration() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d, Zero::zero());\n-        assert!(Duration::seconds(1) != Zero::zero());\n+        assert!(Duration::seconds(1) != Duration::zero());\n         assert_eq!(Duration::seconds(1) + Duration::seconds(2), Duration::seconds(3));\n         assert_eq!(Duration::seconds(86399) + Duration::seconds(4),\n                    Duration::days(1) + Duration::seconds(3));\n@@ -411,8 +408,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_days() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_days(), 0);\n+        assert_eq!(Duration::zero().num_days(), 0);\n         assert_eq!(Duration::days(1).num_days(), 1);\n         assert_eq!(Duration::days(-1).num_days(), -1);\n         assert_eq!(Duration::seconds(86399).num_days(), 0);\n@@ -425,8 +421,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_seconds() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_seconds(), 0);\n+        assert_eq!(Duration::zero().num_seconds(), 0);\n         assert_eq!(Duration::seconds(1).num_seconds(), 1);\n         assert_eq!(Duration::seconds(-1).num_seconds(), -1);\n         assert_eq!(Duration::milliseconds(999).num_seconds(), 0);\n@@ -437,8 +432,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_milliseconds() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_milliseconds(), 0);\n+        assert_eq!(Duration::zero().num_milliseconds(), 0);\n         assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n         assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n         assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n@@ -453,8 +447,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_microseconds() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_microseconds(), Some(0));\n+        assert_eq!(Duration::zero().num_microseconds(), Some(0));\n         assert_eq!(Duration::microseconds(1).num_microseconds(), Some(1));\n         assert_eq!(Duration::microseconds(-1).num_microseconds(), Some(-1));\n         assert_eq!(Duration::nanoseconds(999).num_microseconds(), Some(0));\n@@ -478,8 +471,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_nanoseconds() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_nanoseconds(), Some(0));\n+        assert_eq!(Duration::zero().num_nanoseconds(), Some(0));\n         assert_eq!(Duration::nanoseconds(1).num_nanoseconds(), Some(1));\n         assert_eq!(Duration::nanoseconds(-1).num_nanoseconds(), Some(-1));\n         assert_eq!(Duration::nanoseconds(i64::MAX).num_nanoseconds(), Some(i64::MAX));\n@@ -512,10 +504,9 @@ mod tests {\n \n     #[test]\n     fn test_duration_mul() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d * i32::MAX, d);\n-        assert_eq!(d * i32::MIN, d);\n-        assert_eq!(Duration::nanoseconds(1) * 0, Zero::zero());\n+        assert_eq!(Duration::zero() * i32::MAX, Duration::zero());\n+        assert_eq!(Duration::zero() * i32::MIN, Duration::zero());\n+        assert_eq!(Duration::nanoseconds(1) * 0, Duration::zero());\n         assert_eq!(Duration::nanoseconds(1) * 1, Duration::nanoseconds(1));\n         assert_eq!(Duration::nanoseconds(1) * 1_000_000_000, Duration::seconds(1));\n         assert_eq!(Duration::nanoseconds(1) * -1_000_000_000, -Duration::seconds(1));\n@@ -530,9 +521,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_div() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d / i32::MAX, d);\n-        assert_eq!(d / i32::MIN, d);\n+        assert_eq!(Duration::zero() / i32::MAX, Duration::zero());\n+        assert_eq!(Duration::zero() / i32::MIN, Duration::zero());\n         assert_eq!(Duration::nanoseconds(123_456_789) / 1, Duration::nanoseconds(123_456_789));\n         assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n         assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n@@ -548,8 +538,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_fmt() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.to_string(), \"PT0S\".to_string());\n+        assert_eq!(Duration::zero().to_string(), \"PT0S\".to_string());\n         assert_eq!(Duration::days(42).to_string(), \"P42D\".to_string());\n         assert_eq!(Duration::days(-42).to_string(), \"-P42D\".to_string());\n         assert_eq!(Duration::seconds(42).to_string(), \"PT42S\".to_string());"}, {"sha": "4414f710b15646376acdc140067c42fd6840bed0", "filename": "src/libsync/mpmc_bounded_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpmc_bounded_queue.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -34,7 +34,7 @@ use core::prelude::*;\n \n use alloc::arc::Arc;\n use collections::Vec;\n-use core::num::next_power_of_two;\n+use core::num::UnsignedInt;\n use core::cell::UnsafeCell;\n \n use atomic::{AtomicUint,Relaxed,Release,Acquire};\n@@ -66,7 +66,7 @@ impl<T: Send> State<T> {\n                 2u\n             } else {\n                 // use next power of 2 as capacity\n-                next_power_of_two(capacity)\n+                capacity.next_power_of_two()\n             }\n         } else {\n             capacity"}, {"sha": "7c5de627d0807ec139c306f8b986539268243556", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -19,8 +19,8 @@ use parse::token;\n use ptr::P;\n \n use std::fmt;\n-use std::num::Zero;\n use std::fmt::Show;\n+use std::num::Int;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -857,9 +857,9 @@ pub enum Sign {\n     Plus\n }\n \n-impl<T: PartialOrd+Zero> Sign {\n+impl<T: Int> Sign {\n     pub fn new(n: T) -> Sign {\n-        if n < Zero::zero() {\n+        if n < Int::zero() {\n             Minus\n         } else {\n             Plus"}, {"sha": "51738ece80f53a220ef1355b173bdaa551e639a2", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -20,6 +20,7 @@ use ptr::P;\n use std::cell::{Cell, RefCell};\n use std::io::File;\n use std::rc::Rc;\n+use std::num::Int;\n use std::str;\n use std::iter;\n \n@@ -63,7 +64,7 @@ impl ParseSess {\n     pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n         let v = self.node_id.get();\n \n-        match v.checked_add(&count) {\n+        match v.checked_add(count) {\n             Some(next) => { self.node_id.set(next); }\n             None => panic!(\"Input too large, ran out of node ids!\")\n         }"}, {"sha": "42ec1e8034269c50f23493083d762db629955df6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -87,6 +87,7 @@ use std::collections::HashSet;\n use std::io::fs::PathExtensions;\n use std::mem::replace;\n use std::mem;\n+use std::num::Float;\n use std::rc::Rc;\n use std::iter;\n "}, {"sha": "7a17b28234fe2eba93e6e212f5675e27e65468ea", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -58,6 +58,7 @@ use std::io::fs::PathExtensions;\n use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n+use std::num::{Float, FloatMath, Int};\n use std::os;\n use std::string::String;\n use std::task::TaskBuilder;\n@@ -105,7 +106,6 @@ enum NamePadding { PadNone, PadOnLeft, PadOnRight }\n \n impl TestDesc {\n     fn padded_name(&self, column_count: uint, align: NamePadding) -> String {\n-        use std::num::Saturating;\n         let mut name = String::from_str(self.name.as_slice());\n         let fill = column_count.saturating_sub(name.len());\n         let mut pad = \" \".repeat(fill);"}, {"sha": "adf58dc875c433f13e342af7e9b60abb568d2078", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -16,8 +16,7 @@ use std::fmt::Show;\n use std::hash::Hash;\n use std::io;\n use std::mem;\n-use std::num::Zero;\n-use std::num;\n+use std::num::{Float, FloatMath};\n \n fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -145,7 +144,6 @@ pub struct Summary<T> {\n }\n \n impl<T: FloatMath + FromPrimitive> Summary<T> {\n-\n     /// Construct a new summary of a sample set.\n     pub fn new(samples: &[T]) -> Summary<T> {\n         Summary {\n@@ -166,7 +164,6 @@ impl<T: FloatMath + FromPrimitive> Summary<T> {\n }\n \n impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n-\n     // FIXME #11059 handle NaN, inf and overflow\n     fn sum(self) -> T {\n         let mut partials = vec![];\n@@ -176,15 +173,15 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact.\n             for i in range(0, partials.len()) {\n-                let mut y = partials[i];\n-                if num::abs(x) < num::abs(y) {\n+                let mut y: T = partials[i];\n+                if x.abs() < y.abs() {\n                     mem::swap(&mut x, &mut y);\n                 }\n                 // Rounded `x+y` is stored in `hi` with round-off stored in\n                 // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n-                if !lo.is_zero() {\n+                if lo != Float::zero() {\n                     partials[j] = lo;\n                     j += 1;\n                 }\n@@ -197,7 +194,7 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n                 partials.truncate(j+1);\n             }\n         }\n-        let zero: T = Zero::zero();\n+        let zero: T = Float::zero();\n         partials.iter().fold(zero, |p, q| p + *q)\n     }\n \n@@ -222,10 +219,10 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n \n     fn var(self) -> T {\n         if self.len() < 2 {\n-            Zero::zero()\n+            Float::zero()\n         } else {\n             let mean = self.mean();\n-            let mut v: T = Zero::zero();\n+            let mut v: T = Float::zero();\n             for s in self.iter() {\n                 let x = *s - mean;\n                 v = v + x*x;\n@@ -249,7 +246,7 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n \n     fn median_abs_dev(self) -> T {\n         let med = self.median();\n-        let abs_devs: Vec<T> = self.iter().map(|&v| num::abs(med - v)).collect();\n+        let abs_devs: Vec<T> = self.iter().map(|&v| (med - v).abs()).collect();\n         // This constant is derived by smarter statistics brains than me, but it is\n         // consistent with how R and other packages treat the MAD.\n         let number = FromPrimitive::from_f64(1.4826).unwrap();\n@@ -294,7 +291,7 @@ fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n     if sorted_samples.len() == 1 {\n         return sorted_samples[0];\n     }\n-    let zero: T = Zero::zero();\n+    let zero: T = Float::zero();\n     assert!(zero <= pct);\n     let hundred = FromPrimitive::from_uint(100).unwrap();\n     assert!(pct <= hundred);\n@@ -370,14 +367,14 @@ pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n     let himag = ten.powf(s.max.abs().log10().floor());\n \n     // need to consider when the limit is zero\n-    let zero: T = Zero::zero();\n-    let lo = if lomag.is_zero() {\n+    let zero: T = Float::zero();\n+    let lo = if lomag == Float::zero() {\n         zero\n     } else {\n         (s.min / lomag).floor() * lomag\n     };\n \n-    let hi = if himag.is_zero() {\n+    let hi = if himag == Float::zero() {\n         zero\n     } else {\n         (s.max / himag).ceil() * himag\n@@ -464,6 +461,7 @@ mod tests {\n \n     macro_rules! assert_approx_eq(\n         ($a:expr, $b:expr) => ({\n+            use std::num::Float;\n             let (a, b) = (&$a, &$b);\n             assert!((*a - *b).abs() < 1.0e-6,\n                     \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "59061178145e6fda48aa2fe0696db9c35f1e411b", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -31,7 +31,7 @@ extern crate libc;\n use std::fmt::Show;\n use std::fmt;\n use std::io::BufReader;\n-use std::num;\n+use std::num::SignedInt;\n use std::string::String;\n use std::time::Duration;\n \n@@ -758,7 +758,7 @@ impl<'a> fmt::Show for TmFmt<'a> {\n               'Z' => if tm.tm_gmtoff == 0_i32 { \"GMT\"} else { \"\" }, // FIXME (#2350): support locale\n               'z' => {\n                 let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n-                let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n+                let mut m = tm.tm_gmtoff.abs() / 60_i32;\n                 let h = m / 60_i32;\n                 m -= h * 60_i32;\n                 return write!(fmt, \"{}{:02d}{:02d}\", sign, h, m);\n@@ -800,7 +800,7 @@ impl<'a> fmt::Show for TmFmt<'a> {\n                         format: FmtStr(\"%Y-%m-%dT%H:%M:%S\"),\n                     };\n                     let sign = if self.tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n-                    let mut m = num::abs(self.tm.tm_gmtoff) / 60_i32;\n+                    let mut m = self.tm.tm_gmtoff.abs() / 60_i32;\n                     let h = m / 60_i32;\n                     m -= h * 60_i32;\n                     write!(fmt, \"{}{}{:02d}:{:02d}\", s, sign, h as int, m as int)"}, {"sha": "4ad77a695dd5c0790af42c88831cae5467cecb50", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -13,6 +13,7 @@\n // ignore-lexer-test FIXME #15679\n \n use std::f32::consts::PI;\n+use std::num::{Float, FloatMath};\n use std::rand::{Rng, StdRng};\n \n struct Vec2 {"}, {"sha": "f9fafa977acab0e7d41a40c30d169fcf45e90ed1", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -43,6 +43,7 @@\n use std::io;\n use std::io::{BufferedWriter, File};\n use std::cmp::min;\n+use std::num::Float;\n use std::os;\n \n const LINE_LENGTH: uint = 60;"}, {"sha": "e40c477ec66effb5f91dc4cecb977cffe9a6cd64", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -19,6 +19,7 @@ extern crate collections;\n \n use std::collections::HashMap;\n use std::mem::replace;\n+use std::num::Float;\n use std::option;\n use std::os;\n use std::string::String;"}, {"sha": "3bcc0c25df8acd4a47c0f4b9273d810bfae95f7a", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+use std::num::Float;\n+\n const PI: f64 = 3.141592653589793;\n const SOLAR_MASS: f64 = 4.0 * PI * PI;\n const YEAR: f64 = 365.24;"}, {"sha": "c5f2fbb18901726b16f4596030c9d0b06dd1ffc6", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -45,6 +45,7 @@\n \n use std::iter::AdditiveIterator;\n use std::mem;\n+use std::num::Float;\n use std::os;\n use std::raw::Repr;\n use std::simd::f64x2;"}, {"sha": "6664eeecd5d85d5b7bc3d3cf06d2fa2e2aa89a50", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -15,6 +15,7 @@\n use std::io;\n use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n+use std::num::Int;\n use std::os;\n \n // Computes a single solution to a given 9x9 sudoku"}, {"sha": "34367f06793fce469405167f49829bc6cff05eb6", "filename": "src/test/compile-fail/implicit-method-bind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::num::SignedInt;\n+\n fn main() {\n     let _f = 10i.abs; //~ ERROR attempted to take value of method\n }"}, {"sha": "66479202e1253e6172fdbcd814b2727d966a7098", "filename": "src/test/compile-fail/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::Num;\n+use std::num::Int;\n \n-trait BrokenAdd: Num {\n+trait BrokenAdd: Int {\n     fn broken_add<T>(&self, rhs: T) -> Self {\n         *self + rhs //~ ERROR expected `Self`, found `T`\n     }\n }\n \n-impl<T: Num> BrokenAdd for T {}\n+impl<T: Int> BrokenAdd for T {}\n \n pub fn main() {\n     let foo: u8 = 0u8;"}, {"sha": "f4dba3f6c7f5ba51aa4c90438adc356eeaf26f27", "filename": "src/test/run-pass/const-binops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-binops.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -12,6 +12,7 @@\n \n macro_rules! assert_approx_eq(\n     ($a:expr, $b:expr) => ({\n+        use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "6e3d19b05d4b1d9272fb0c03ad338132849d8f91", "filename": "src/test/run-pass/generic-extern-mangle.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::num::Int;\n+\n extern \"C\" fn foo<T: Int>(a: T, b: T) -> T { a + b }\n \n fn main() {"}, {"sha": "c3ba7ca12d02e83304b05627b8c2f19a0ebd928d", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -13,6 +13,7 @@\n \n macro_rules! assert_approx_eq(\n     ($a:expr, $b:expr) => ({\n+        use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "912a62b5b0f6ae46b51c0d1b72005b87dfd5a666", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -11,6 +11,7 @@\n extern crate collections;\n \n use std::collections::Bitv;\n+use std::num::Float;\n \n fn main() {\n     // Generate sieve of Eratosthenes for n up to 1e6"}, {"sha": "e606018feb9c32e5d6107f38d25fafe388377e1e", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -12,11 +12,11 @@\n use std::cmp::{PartialEq, PartialOrd};\n use std::num::NumCast;\n \n-pub trait NumExt: Num + NumCast + PartialEq + PartialOrd {}\n+pub trait NumExt: NumCast + PartialEq + PartialOrd {}\n \n pub trait FloatExt: NumExt {}\n \n-fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > NumCast::from(1i).unwrap() }\n-fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > NumCast::from(1i).unwrap() }\n+fn greater_than_one<T: NumExt>(n: &T) -> bool { *n > NumCast::from(1i).unwrap() }\n+fn greater_than_one_float<T: FloatExt>(n: &T) -> bool { *n > NumCast::from(1i).unwrap() }\n \n pub fn main() {}"}, {"sha": "42eaaa09fcdccc3bf1ad611e59c909993989c50d", "filename": "src/test/run-pass/trait-inheritance-num0.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -11,14 +11,15 @@\n \n // Extending Num and using inherited static methods\n \n+use std::cmp::PartialOrd;\n use std::num::NumCast;\n \n pub trait Num {\n     fn from_int(i: int) -> Self;\n     fn gt(&self, other: &Self) -> bool;\n }\n \n-pub trait NumExt: Num + NumCast { }\n+pub trait NumExt: NumCast + PartialOrd { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n     n.gt(&NumCast::from(1i).unwrap())"}, {"sha": "9407afbdd6b9c8af52be0891be9c3e2b4f16f9e6", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -11,7 +11,7 @@\n use std::cmp::PartialOrd;\n use std::num::NumCast;\n \n-pub trait NumExt: Num + NumCast + PartialOrd { }\n+pub trait NumExt: NumCast + PartialOrd { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n     *n > NumCast::from(1i).unwrap()"}, {"sha": "1e6e7227a067cc5fc915a973dd9748f69cd33723", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -12,6 +12,7 @@\n // A more complex example of numeric extensions\n \n use std::cmp::{PartialEq, PartialOrd};\n+use std::num::NumCast;\n \n pub trait TypeExt {}\n \n@@ -32,7 +33,7 @@ impl TypeExt for f32 {}\n impl TypeExt for f64 {}\n \n \n-pub trait NumExt: TypeExt + PartialEq + PartialOrd + Num + NumCast {}\n+pub trait NumExt: TypeExt + PartialEq + PartialOrd + NumCast {}\n \n impl NumExt for u8 {}\n impl NumExt for u16 {}"}, {"sha": "bd93223093ad24c49619739825928e840663b237", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -11,11 +11,11 @@\n use std::cmp::{PartialEq, PartialOrd};\n use std::num::NumCast;\n \n-pub trait NumExt: PartialEq + PartialOrd + Num + NumCast {}\n+pub trait NumExt: PartialEq + PartialOrd + NumCast {}\n \n impl NumExt for f32 {}\n \n-fn num_eq_one<T:NumExt>(n: T) {\n+fn num_eq_one<T: NumExt>(n: T) {\n     println!(\"{}\", n == NumCast::from(1i).unwrap())\n }\n "}, {"sha": "4c79600e2e9bae33b1c20e02d43d7045609b6f08", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -11,7 +11,7 @@\n use std::cmp::PartialEq;\n use std::num::NumCast;\n \n-pub trait NumExt: PartialEq + Num + NumCast {}\n+pub trait NumExt: PartialEq + NumCast {}\n \n impl NumExt for f32 {}\n impl NumExt for int {}"}, {"sha": "96f1c940dcf2cdabaf617be2e50683e08ae178e0", "filename": "src/test/run-pass/trait-inheritance-self-in-supertype.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -10,7 +10,7 @@\n \n // Test for issue #4183: use of Self in supertraits.\n \n-use std::num;\n+use std::num::Float as StdFloat;\n \n pub static FUZZY_EPSILON: f64 = 0.1;\n \n@@ -29,7 +29,7 @@ impl FuzzyEq<f32> for f32 {\n     }\n \n     fn fuzzy_eq_eps(&self, other: &f32, epsilon: &f32) -> bool {\n-        num::abs(*self - *other) < *epsilon\n+        (*self - *other).abs() < *epsilon\n     }\n }\n \n@@ -43,7 +43,7 @@ impl FuzzyEq<f64> for f64 {\n     }\n \n     fn fuzzy_eq_eps(&self, other: &f64, epsilon: &f64) -> bool {\n-        num::abs(*self - *other) < *epsilon\n+        (*self - *other).abs() < *epsilon\n     }\n }\n "}, {"sha": "c99c394969cf34779fd41ff109e0d0fdd53ffba8", "filename": "src/test/run-pass/utf8_idents.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Futf8_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f7081fad5889c7b41460103fc8abc98f3285c60/src%2Ftest%2Frun-pass%2Futf8_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_idents.rs?ref=6f7081fad5889c7b41460103fc8abc98f3285c60", "patch": "@@ -10,16 +10,15 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-\n #![feature(non_ascii_idents)]\n \n-use std::num;\n+use std::num::Float;\n \n pub fn main() {\n     let \u03b5 = 0.00001f64;\n     let \u03a0 = 3.14f64;\n     let \u0932\u0902\u091a = \u03a0 * \u03a0 + 1.54;\n-    assert!(num::abs((\u0932\u0902\u091a - 1.54) - (\u03a0 * \u03a0)) < \u03b5);\n+    assert!(((\u0932\u0902\u091a - 1.54) - (\u03a0 * \u03a0)).abs() < \u03b5);\n     assert_eq!(\u10e1\u10d0\u10ed\u10db\u10d4\u10da\u10d0\u10d3_\u10d2\u10d4\u10db\u10e0\u10d8\u10d4\u10da\u10d8_\u10e1\u10d0\u10d3\u10d8\u10da\u10d8(), 0);\n }\n "}]}