{"sha": "8fd48e7d59a01da7d631695cfea06027cb96c06a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZDQ4ZTdkNTlhMDFkYTdkNjMxNjk1Y2ZlYTA2MDI3Y2I5NmMwNmE=", "commit": {"author": {"name": "Christopher Vittal", "email": "christopher.vittal@gmail.com", "date": "2017-11-10T17:23:59Z"}, "committer": {"name": "Christopher Vittal", "email": "christopher.vittal@gmail.com", "date": "2017-11-15T20:46:01Z"}, "message": "Split hir::TyImplTrait, move checks to HIR lowering\n\nReplace hir::TyImplTrait with TyImplTraitUniversal and\nTyImplTraitExistential.\n\nAdd an ImplTraitContext enum to rustc::hir::lowering to track the kind\nand allowedness of an impl Trait.\n\nSignificantly alter lowering to thread ImplTraitContext and one other\nboolean parameter described below throughought much of lowering.\n\nThe other parameter is for tracking if lowering a function is in a trait\nimpl, as there is not enough information to otherwise know this\ninformation during lowering otherwise.\n\nThis change also removes the checks from ast_ty_to_ty for impl trait\nallowedness as they are now all taking place in HIR lowering.", "tree": {"sha": "87a6538446792c2d05185242e472df80c30c6fa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87a6538446792c2d05185242e472df80c30c6fa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fd48e7d59a01da7d631695cfea06027cb96c06a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd48e7d59a01da7d631695cfea06027cb96c06a", "html_url": "https://github.com/rust-lang/rust/commit/8fd48e7d59a01da7d631695cfea06027cb96c06a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fd48e7d59a01da7d631695cfea06027cb96c06a/comments", "author": {"login": "chrisvittal", "id": 15916123, "node_id": "MDQ6VXNlcjE1OTE2MTIz", "avatar_url": "https://avatars.githubusercontent.com/u/15916123?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisvittal", "html_url": "https://github.com/chrisvittal", "followers_url": "https://api.github.com/users/chrisvittal/followers", "following_url": "https://api.github.com/users/chrisvittal/following{/other_user}", "gists_url": "https://api.github.com/users/chrisvittal/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisvittal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisvittal/subscriptions", "organizations_url": "https://api.github.com/users/chrisvittal/orgs", "repos_url": "https://api.github.com/users/chrisvittal/repos", "events_url": "https://api.github.com/users/chrisvittal/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisvittal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chrisvittal", "id": 15916123, "node_id": "MDQ6VXNlcjE1OTE2MTIz", "avatar_url": "https://avatars.githubusercontent.com/u/15916123?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisvittal", "html_url": "https://github.com/chrisvittal", "followers_url": "https://api.github.com/users/chrisvittal/followers", "following_url": "https://api.github.com/users/chrisvittal/following{/other_user}", "gists_url": "https://api.github.com/users/chrisvittal/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisvittal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisvittal/subscriptions", "organizations_url": "https://api.github.com/users/chrisvittal/orgs", "repos_url": "https://api.github.com/users/chrisvittal/repos", "events_url": "https://api.github.com/users/chrisvittal/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisvittal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "779fc372c794057816951f2583985c512b0c6387", "url": "https://api.github.com/repos/rust-lang/rust/commits/779fc372c794057816951f2583985c512b0c6387", "html_url": "https://github.com/rust-lang/rust/commit/779fc372c794057816951f2583985c512b0c6387"}], "stats": {"total": 359, "additions": 211, "deletions": 148}, "files": [{"sha": "84be68cb197652a147d7c4568c0b1e46d7b99ca7", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -591,7 +591,10 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyImplTrait(ref bounds) => {\n+        TyImplTraitExistential(ref bounds) => {\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+        }\n+        TyImplTraitUniversal(_, ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyTypeof(expression) => {"}, {"sha": "2fab130895c54acf4798978e31279533f70ee1b5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 176, "deletions": 86, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -123,6 +123,24 @@ pub trait Resolver {\n     fn definitions(&mut self) -> &mut Definitions;\n }\n \n+#[derive(Clone, Copy, Debug)]\n+enum ImplTraitContext {\n+    /// Treat `impl Trait` as shorthand for a new universal generic parameter.\n+    /// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually\n+    /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n+    ///\n+    /// We store a DefId here so we can look up necessary information later\n+    Universal(DefId),\n+\n+    /// Treat `impl Trait` as shorthand for a new universal existential parameter.\n+    /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n+    /// equivalent to a fresh existential parameter like `abstract type T; fn foo() -> T`.\n+    Existential,\n+\n+    /// `impl Trait` is not accepted in this position.\n+    Disallowed,\n+}\n+\n pub fn lower_crate(sess: &Session,\n                    cstore: &CrateStore,\n                    dep_graph: &DepGraph,\n@@ -644,48 +662,48 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n+    fn lower_ty_binding(&mut self, b: &TypeBinding, itctx: ImplTraitContext) -> hir::TypeBinding {\n         hir::TypeBinding {\n             id: self.lower_node_id(b.id).node_id,\n             name: self.lower_ident(b.ident),\n-            ty: self.lower_ty(&b.ty),\n+            ty: self.lower_ty(&b.ty, itctx),\n             span: b.span,\n         }\n     }\n \n-    fn lower_ty(&mut self, t: &Ty) -> P<hir::Ty> {\n+    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext) -> P<hir::Ty> {\n         let kind = match t.node {\n             TyKind::Infer => hir::TyInfer,\n             TyKind::Err => hir::TyErr,\n-            TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n-            TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n+            TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty, itctx)),\n+            TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n                 let span = t.span.with_hi(t.span.lo());\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n                     None => self.elided_lifetime(span)\n                 };\n-                hir::TyRptr(lifetime, self.lower_mt(mt))\n+                hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => {\n                 hir::TyBareFn(P(hir::BareFnTy {\n                     lifetimes: self.lower_lifetime_defs(&f.lifetimes),\n                     unsafety: self.lower_unsafety(f.unsafety),\n                     abi: f.abi,\n-                    decl: self.lower_fn_decl(&f.decl),\n+                    decl: self.lower_fn_decl(&f.decl, None, false),\n                     arg_names: self.lower_fn_args_to_names(&f.decl),\n                 }))\n             }\n             TyKind::Never => hir::TyNever,\n             TyKind::Tup(ref tys) => {\n-                hir::TyTup(tys.iter().map(|ty| self.lower_ty(ty)).collect())\n+                hir::TyTup(tys.iter().map(|ty| self.lower_ty(ty, itctx)).collect())\n             }\n             TyKind::Paren(ref ty) => {\n-                return self.lower_ty(ty);\n+                return self.lower_ty(ty, itctx);\n             }\n             TyKind::Path(ref qself, ref path) => {\n                 let id = self.lower_node_id(t.id);\n-                let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n+                let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit, itctx);\n                 return self.ty_path(id, t.span, qpath);\n             }\n             TyKind::ImplicitSelf => {\n@@ -699,7 +717,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             TyKind::Array(ref ty, ref length) => {\n                 let length = self.lower_body(None, |this| this.lower_expr(length));\n-                hir::TyArray(self.lower_ty(ty), length)\n+                hir::TyArray(self.lower_ty(ty, itctx), length)\n             }\n             TyKind::Typeof(ref expr) => {\n                 let expr = self.lower_body(None, |this| this.lower_expr(expr));\n@@ -710,7 +728,7 @@ impl<'a> LoweringContext<'a> {\n                 let bounds = bounds.iter().filter_map(|bound| {\n                     match *bound {\n                         TraitTyParamBound(ref ty, TraitBoundModifier::None) => {\n-                            Some(self.lower_poly_trait_ref(ty))\n+                            Some(self.lower_poly_trait_ref(ty, itctx))\n                         }\n                         TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n                         RegionTyParamBound(ref lifetime) => {\n@@ -727,7 +745,21 @@ impl<'a> LoweringContext<'a> {\n                 hir::TyTraitObject(bounds, lifetime_bound)\n             }\n             TyKind::ImplTrait(ref bounds) => {\n-                hir::TyImplTrait(self.lower_bounds(bounds))\n+                use syntax::feature_gate::{emit_feature_err, GateIssue};\n+                match itctx {\n+                    ImplTraitContext::Existential => {\n+                        hir::TyImplTraitExistential(self.lower_bounds(bounds, itctx))\n+                    },\n+                    ImplTraitContext::Universal(def_id) => {\n+                        hir::TyImplTraitUniversal(def_id, self.lower_bounds(bounds, itctx))\n+                    },\n+                    ImplTraitContext::Disallowed => {\n+                        span_err!(self.sess, t.span, E0562,\n+                                  \"`impl Trait` not allowed outside of function \\\n+                                  and inherent method return types\");\n+                        hir::TyErr\n+                    }\n+                }\n             }\n             TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n         };\n@@ -773,10 +805,11 @@ impl<'a> LoweringContext<'a> {\n                    id: NodeId,\n                    qself: &Option<QSelf>,\n                    p: &Path,\n-                   param_mode: ParamMode)\n+                   param_mode: ParamMode,\n+                   itctx: ImplTraitContext)\n                    -> hir::QPath {\n         let qself_position = qself.as_ref().map(|q| q.position);\n-        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty));\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx));\n \n         let resolution = self.resolver.get_resolution(id)\n                                       .unwrap_or(PathResolution::new(Def::Err));\n@@ -846,7 +879,7 @@ impl<'a> LoweringContext<'a> {\n                     n\n                 });\n                 self.lower_path_segment(p.span, segment, param_mode, num_lifetimes,\n-                                        parenthesized_generic_args)\n+                                        parenthesized_generic_args, itctx)\n             }).collect(),\n             span: p.span,\n         });\n@@ -882,7 +915,8 @@ impl<'a> LoweringContext<'a> {\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n             let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0,\n-                                                    ParenthesizedGenericArgs::Warn));\n+                                                    ParenthesizedGenericArgs::Warn,\n+                                                    itctx));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n             // It's finished, return the extension of the right node type.\n@@ -916,7 +950,8 @@ impl<'a> LoweringContext<'a> {\n             def: self.expect_full_def(id),\n             segments: segments.map(|segment| {\n                 self.lower_path_segment(p.span, segment, param_mode, 0,\n-                                        ParenthesizedGenericArgs::Err)\n+                                        ParenthesizedGenericArgs::Err,\n+                                        ImplTraitContext::Disallowed)\n             }).chain(name.map(|name| hir::PathSegment::from_name(name)))\n               .collect(),\n             span: p.span,\n@@ -937,16 +972,18 @@ impl<'a> LoweringContext<'a> {\n                           segment: &PathSegment,\n                           param_mode: ParamMode,\n                           expected_lifetimes: usize,\n-                          parenthesized_generic_args: ParenthesizedGenericArgs)\n+                          parenthesized_generic_args: ParenthesizedGenericArgs,\n+                          itctx: ImplTraitContext)\n                           -> hir::PathSegment {\n         let (mut parameters, infer_types) = if let Some(ref parameters) = segment.parameters {\n             let msg = \"parenthesized parameters may only be used with a trait\";\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n-                    self.lower_angle_bracketed_parameter_data(data, param_mode)\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 PathParameters::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Ok =>\n+                        self.lower_parenthesized_parameter_data(data, itctx),\n                     ParenthesizedGenericArgs::Warn => {\n                         self.sess.buffer_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                                               CRATE_NODE_ID, data.span, msg.into());\n@@ -960,7 +997,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n         } else {\n-            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode)\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n         };\n \n         if !parameters.parenthesized && parameters.lifetimes.is_empty() {\n@@ -978,22 +1015,25 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_angle_bracketed_parameter_data(&mut self,\n                                             data: &AngleBracketedParameterData,\n-                                            param_mode: ParamMode)\n+                                            param_mode: ParamMode,\n+                                            itctx: ImplTraitContext)\n                                             -> (hir::PathParameters, bool) {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings, .. } = data;\n         (hir::PathParameters {\n             lifetimes: self.lower_lifetimes(lifetimes),\n-            types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n-            bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n+            types: types.iter().map(|ty| self.lower_ty(ty, itctx)).collect(),\n+            bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx)).collect(),\n             parenthesized: false,\n         }, types.is_empty() && param_mode == ParamMode::Optional)\n     }\n \n     fn lower_parenthesized_parameter_data(&mut self,\n-                                          data: &ParenthesizedParameterData)\n+                                          data: &ParenthesizedParameterData,\n+                                          itctx: ImplTraitContext)\n                                           -> (hir::PathParameters, bool) {\n+        const DISALLOWED: ImplTraitContext = ImplTraitContext::Disallowed;\n         let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n-        let inputs = inputs.iter().map(|ty| self.lower_ty(ty)).collect();\n+        let inputs = inputs.iter().map(|ty| self.lower_ty(ty, DISALLOWED)).collect();\n         let mk_tup = |this: &mut Self, tys, span| {\n             let LoweredNodeId { node_id, hir_id } = this.next_id();\n             P(hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span })\n@@ -1005,7 +1045,7 @@ impl<'a> LoweringContext<'a> {\n             bindings: hir_vec![hir::TypeBinding {\n                 id: self.next_id().node_id,\n                 name: Symbol::intern(FN_OUTPUT_NAME),\n-                ty: output.as_ref().map(|ty| self.lower_ty(&ty))\n+                ty: output.as_ref().map(|ty| self.lower_ty(&ty, itctx))\n                                    .unwrap_or_else(|| mk_tup(self, hir::HirVec::new(), span)),\n                 span: output.as_ref().map_or(span, |ty| ty.span),\n             }],\n@@ -1018,7 +1058,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::Local {\n             id: node_id,\n             hir_id,\n-            ty: l.ty.as_ref().map(|t| self.lower_ty(t)),\n+            ty: l.ty.as_ref().map(|t| self.lower_ty(t, ImplTraitContext::Disallowed)),\n             pat: self.lower_pat(&l.pat),\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n@@ -1055,11 +1095,24 @@ impl<'a> LoweringContext<'a> {\n         }).collect()\n     }\n \n-    fn lower_fn_decl(&mut self, decl: &FnDecl) -> P<hir::FnDecl> {\n+    fn lower_fn_decl(&mut self,\n+                     decl: &FnDecl,\n+                     fn_def_id: Option<DefId>,\n+                     impl_trait_return_allow: bool)\n+                     -> P<hir::FnDecl> {\n         P(hir::FnDecl {\n-            inputs: decl.inputs.iter().map(|arg| self.lower_ty(&arg.ty)).collect(),\n+            inputs: decl.inputs.iter()\n+                .map(|arg| if let Some(def_id) = fn_def_id {\n+                    self.lower_ty(&arg.ty, ImplTraitContext::Universal(def_id))\n+                } else {\n+                    self.lower_ty(&arg.ty, ImplTraitContext::Disallowed)\n+                }).collect(),\n             output: match decl.output {\n-                FunctionRetTy::Ty(ref ty) => hir::Return(self.lower_ty(ty)),\n+                FunctionRetTy::Ty(ref ty) => match (impl_trait_return_allow, fn_def_id) {\n+                    (false, _) => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n+                    (_, Some(_)) => hir::Return(self.lower_ty(ty, ImplTraitContext::Existential)),\n+                    _ => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n+                },\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n             },\n             variadic: decl.variadic,\n@@ -1073,10 +1126,11 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_ty_param_bound(&mut self, tpb: &TyParamBound) -> hir::TyParamBound {\n+    fn lower_ty_param_bound(&mut self, tpb: &TyParamBound, itctx: ImplTraitContext)\n+                            -> hir::TyParamBound {\n         match *tpb {\n             TraitTyParamBound(ref ty, modifier) => {\n-                hir::TraitTyParamBound(self.lower_poly_trait_ref(ty),\n+                hir::TraitTyParamBound(self.lower_poly_trait_ref(ty, itctx),\n                                        self.lower_trait_bound_modifier(modifier))\n             }\n             RegionTyParamBound(ref lifetime) => {\n@@ -1095,16 +1149,19 @@ impl<'a> LoweringContext<'a> {\n             name = Symbol::gensym(\"Self\");\n         }\n \n-        let mut bounds = self.lower_bounds(&tp.bounds);\n+        let itctx = ImplTraitContext::Universal(self.resolver.definitions().local_def_id(tp.id));\n+        let mut bounds = self.lower_bounds(&tp.bounds, itctx);\n         if !add_bounds.is_empty() {\n-            bounds = bounds.into_iter().chain(self.lower_bounds(add_bounds).into_iter()).collect();\n+            bounds = bounds.into_iter().chain(\n+                self.lower_bounds(add_bounds, itctx).into_iter()\n+            ).collect();\n         }\n \n         hir::TyParam {\n             id: self.lower_node_id(tp.id).node_id,\n             name,\n             bounds,\n-            default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n+            default: tp.default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n             span: tp.span,\n             pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n             synthetic: tp.attrs.iter()\n@@ -1215,11 +1272,11 @@ impl<'a> LoweringContext<'a> {\n                                                                 span}) => {\n                 hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     bound_lifetimes: self.lower_lifetime_defs(bound_lifetimes),\n-                    bounded_ty: self.lower_ty(bounded_ty),\n+                    bounded_ty: self.lower_ty(bounded_ty, ImplTraitContext::Disallowed),\n                     bounds: bounds.iter().filter_map(|bound| match *bound {\n                         // Ignore `?Trait` bounds, they were copied into type parameters already.\n                         TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n-                        _ => Some(self.lower_ty_param_bound(bound))\n+                        _ => Some(self.lower_ty_param_bound(bound, ImplTraitContext::Disallowed))\n                     }).collect(),\n                     span,\n                 })\n@@ -1239,8 +1296,8 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: self.lower_node_id(id).node_id,\n-                    lhs_ty: self.lower_ty(lhs_ty),\n-                    rhs_ty: self.lower_ty(rhs_ty),\n+                    lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::Disallowed),\n+                    rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::Disallowed),\n                     span,\n                 })\n             }\n@@ -1267,8 +1324,8 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n-        let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit) {\n+    fn lower_trait_ref(&mut self, p: &TraitRef, itctx: ImplTraitContext) -> hir::TraitRef {\n+        let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path.and_then(|path| path),\n             qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath)\n         };\n@@ -1278,10 +1335,13 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_poly_trait_ref(&mut self, p: &PolyTraitRef) -> hir::PolyTraitRef {\n+    fn lower_poly_trait_ref(&mut self,\n+                            p: &PolyTraitRef,\n+                            itctx: ImplTraitContext)\n+                            -> hir::PolyTraitRef {\n         hir::PolyTraitRef {\n             bound_lifetimes: self.lower_lifetime_defs(&p.bound_lifetimes),\n-            trait_ref: self.lower_trait_ref(&p.trait_ref),\n+            trait_ref: self.lower_trait_ref(&p.trait_ref, itctx),\n             span: p.span,\n         }\n     }\n@@ -1296,7 +1356,7 @@ impl<'a> LoweringContext<'a> {\n                 None => Ident { name: Symbol::intern(&index.to_string()), ctxt: f.span.ctxt() },\n             }),\n             vis: self.lower_visibility(&f.vis, None),\n-            ty: self.lower_ty(&f.ty),\n+            ty: self.lower_ty(&f.ty, ImplTraitContext::Disallowed),\n             attrs: self.lower_attrs(&f.attrs),\n         }\n     }\n@@ -1310,15 +1370,16 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_mt(&mut self, mt: &MutTy) -> hir::MutTy {\n+    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext) -> hir::MutTy {\n         hir::MutTy {\n-            ty: self.lower_ty(&mt.ty),\n+            ty: self.lower_ty(&mt.ty, itctx),\n             mutbl: self.lower_mutability(mt.mutbl),\n         }\n     }\n \n-    fn lower_bounds(&mut self, bounds: &[TyParamBound]) -> hir::TyParamBounds {\n-        bounds.iter().map(|bound| self.lower_ty_param_bound(bound)).collect()\n+    fn lower_bounds(&mut self, bounds: &[TyParamBound], itctx: ImplTraitContext)\n+                    -> hir::TyParamBounds {\n+        bounds.iter().map(|bound| self.lower_ty_param_bound(bound, itctx)).collect()\n     }\n \n     fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n@@ -1437,33 +1498,35 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemStatic(self.lower_ty(t),\n+                hir::ItemStatic(self.lower_ty(t, ImplTraitContext::Disallowed),\n                                 self.lower_mutability(m),\n                                 value)\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemConst(self.lower_ty(t), value)\n+                hir::ItemConst(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+                let fn_def_id = self.resolver.definitions().opt_local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     let body_id = this.lower_body(Some(decl), |this| {\n                         let body = this.lower_block(body, false);\n                         this.expr_block(body, ThinVec::new())\n                     });\n-                    hir::ItemFn(this.lower_fn_decl(decl),\n-                                              this.lower_unsafety(unsafety),\n-                                              this.lower_constness(constness),\n-                                              abi,\n-                                              this.lower_generics(generics),\n-                                              body_id)\n+                    hir::ItemFn(this.lower_fn_decl(decl, fn_def_id, true),\n+                                this.lower_unsafety(unsafety),\n+                                this.lower_constness(constness),\n+                                abi,\n+                                this.lower_generics(generics),\n+                                body_id)\n                 })\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemGlobalAsm(self.lower_global_asm(ga)),\n             ItemKind::Ty(ref t, ref generics) => {\n-                hir::ItemTy(self.lower_ty(t), self.lower_generics(generics))\n+                hir::ItemTy(self.lower_ty(t, ImplTraitContext::Disallowed),\n+                            self.lower_generics(generics))\n             }\n             ItemKind::Enum(ref enum_definition, ref generics) => {\n                 hir::ItemEnum(hir::EnumDef {\n@@ -1483,7 +1546,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemUnion(vdata, self.lower_generics(generics))\n             }\n             ItemKind::AutoImpl(unsafety, ref trait_ref) => {\n-                let trait_ref = self.lower_trait_ref(trait_ref);\n+                let trait_ref = self.lower_trait_ref(trait_ref, ImplTraitContext::Disallowed);\n \n                 if let Def::Trait(def_id) = trait_ref.path.def {\n                     self.trait_auto_impl.insert(def_id, id);\n@@ -1502,7 +1565,9 @@ impl<'a> LoweringContext<'a> {\n                 let new_impl_items = impl_items.iter()\n                                                .map(|item| self.lower_impl_item_ref(item))\n                                                .collect();\n-                let ifce = ifce.as_ref().map(|trait_ref| self.lower_trait_ref(trait_ref));\n+                let ifce = ifce.as_ref().map(|trait_ref| {\n+                    self.lower_trait_ref(trait_ref, ImplTraitContext::Disallowed)\n+                });\n \n                 if let Some(ref trait_ref) = ifce {\n                     if let Def::Trait(def_id) = trait_ref.path.def {\n@@ -1515,11 +1580,11 @@ impl<'a> LoweringContext<'a> {\n                               self.lower_defaultness(defaultness, true /* [1] */),\n                               self.lower_generics(generics),\n                               ifce,\n-                              self.lower_ty(ty),\n+                              self.lower_ty(ty, ImplTraitContext::Disallowed),\n                               new_impl_items)\n             }\n             ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n-                let bounds = self.lower_bounds(bounds);\n+                let bounds = self.lower_bounds(bounds, ImplTraitContext::Disallowed);\n                 let items = items.iter().map(|item| self.lower_trait_item_ref(item)).collect();\n                 hir::ItemTrait(self.lower_is_auto(is_auto),\n                                self.lower_unsafety(unsafety),\n@@ -1537,6 +1602,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n             let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+            let fn_def_id = this.resolver.definitions().opt_local_def_id(node_id);\n \n             hir::TraitItem {\n                 id: node_id,\n@@ -1546,27 +1612,30 @@ impl<'a> LoweringContext<'a> {\n                 generics: this.lower_generics(&i.generics),\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n-                        hir::TraitItemKind::Const(this.lower_ty(ty),\n+                        hir::TraitItemKind::Const(this.lower_ty(ty, ImplTraitContext::Disallowed),\n                                                   default.as_ref().map(|x| {\n                             this.lower_body(None, |this| this.lower_expr(x))\n                         }))\n                     }\n                     TraitItemKind::Method(ref sig, None) => {\n                         let names = this.lower_fn_args_to_names(&sig.decl);\n-                        hir::TraitItemKind::Method(this.lower_method_sig(sig),\n+                        hir::TraitItemKind::Method(this.lower_method_sig(sig, fn_def_id, false),\n                                                    hir::TraitMethod::Required(names))\n                     }\n                     TraitItemKind::Method(ref sig, Some(ref body)) => {\n                         let body_id = this.lower_body(Some(&sig.decl), |this| {\n                             let body = this.lower_block(body, false);\n                             this.expr_block(body, ThinVec::new())\n                         });\n-                        hir::TraitItemKind::Method(this.lower_method_sig(sig),\n+                        hir::TraitItemKind::Method(this.lower_method_sig(sig, fn_def_id, false),\n                                                    hir::TraitMethod::Provided(body_id))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n-                        hir::TraitItemKind::Type(this.lower_bounds(bounds),\n-                                                 default.as_ref().map(|x| this.lower_ty(x)))\n+                        hir::TraitItemKind::Type(this.lower_bounds(bounds,\n+                                                                   ImplTraitContext::Disallowed),\n+                                                 default.as_ref().map(|x| {\n+                                                     this.lower_ty(x, ImplTraitContext::Disallowed)\n+                                                 }))\n                     }\n                     TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n                 },\n@@ -1602,6 +1671,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n             let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+            let fn_def_id = this.resolver.definitions().opt_local_def_id(node_id);\n \n             hir::ImplItem {\n                 id: node_id,\n@@ -1614,16 +1684,23 @@ impl<'a> LoweringContext<'a> {\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n                         let body_id = this.lower_body(None, |this| this.lower_expr(expr));\n-                        hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n+                        hir::ImplItemKind::Const(\n+                            this.lower_ty(ty, ImplTraitContext::Disallowed),\n+                            body_id\n+                        )\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body_id = this.lower_body(Some(&sig.decl), |this| {\n                             let body = this.lower_block(body, false);\n                             this.expr_block(body, ThinVec::new())\n                         });\n-                        hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n+                        let impl_trait_return_allow = !this.is_in_trait_impl;\n+                        hir::ImplItemKind::Method(this.lower_method_sig(sig, fn_def_id,\n+                                                                        impl_trait_return_allow),\n+                                                  body_id)\n                     }\n-                    ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n+                    ImplItemKind::Type(ref ty) =>\n+                        hir::ImplItemKind::Type(this.lower_ty(ty, ImplTraitContext::Disallowed)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n                 },\n                 span: i.span,\n@@ -1643,8 +1720,10 @@ impl<'a> LoweringContext<'a> {\n             kind: match i.node {\n                 ImplItemKind::Const(..) => hir::AssociatedItemKind::Const,\n                 ImplItemKind::Type(..) => hir::AssociatedItemKind::Type,\n-                ImplItemKind::Method(ref sig, _) => hir::AssociatedItemKind::Method {\n-                    has_self: sig.decl.has_self(),\n+                ImplItemKind::Method(ref sig, _) => {\n+                    hir::AssociatedItemKind::Method {\n+                        has_self: sig.decl.has_self(),\n+                    }\n                 },\n                 ImplItemKind::Macro(..) => unimplemented!(),\n             },\n@@ -1719,12 +1798,13 @@ impl<'a> LoweringContext<'a> {\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n                     ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                        hir::ForeignItemFn(this.lower_fn_decl(fdec),\n+                        let fn_def_id = this.resolver.definitions().opt_local_def_id(i.id);\n+                        hir::ForeignItemFn(this.lower_fn_decl(fdec, fn_def_id, true),\n                                            this.lower_fn_args_to_names(fdec),\n                                            this.lower_generics(generics))\n                     }\n                     ForeignItemKind::Static(ref t, m) => {\n-                        hir::ForeignItemStatic(this.lower_ty(t), m)\n+                        hir::ForeignItemStatic(this.lower_ty(t, ImplTraitContext::Disallowed), m)\n                     }\n                     ForeignItemKind::Ty => {\n                         hir::ForeignItemType\n@@ -1736,12 +1816,16 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n+    fn lower_method_sig(&mut self,\n+                        sig: &MethodSig,\n+                        fn_def_id: Option<DefId>,\n+                        impl_trait_return_allow: bool)\n+                        -> hir::MethodSig {\n         hir::MethodSig {\n             abi: sig.abi,\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n-            decl: self.lower_fn_decl(&sig.decl),\n+            decl: self.lower_fn_decl(&sig.decl, fn_def_id, impl_trait_return_allow),\n         }\n     }\n \n@@ -1834,16 +1918,19 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                 ImplTraitContext::Disallowed);\n                     hir::PatKind::TupleStruct(qpath,\n                                               pats.iter().map(|x| self.lower_pat(x)).collect(),\n                                               ddpos)\n                 }\n                 PatKind::Path(ref qself, ref path) => {\n-                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional))\n+                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional,\n+                                                        ImplTraitContext::Disallowed))\n                 }\n                 PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                 ImplTraitContext::Disallowed);\n \n                     let fs = fields.iter()\n                                    .map(|f| {\n@@ -2020,7 +2107,8 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n                 let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0,\n-                                                      ParenthesizedGenericArgs::Err);\n+                                                      ParenthesizedGenericArgs::Err,\n+                                                      ImplTraitContext::Disallowed);\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprMethodCall(hir_seg, seg.span, args)\n             }\n@@ -2038,11 +2126,11 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Lit(ref l) => hir::ExprLit(P((**l).clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprCast(expr, self.lower_ty(ty))\n+                hir::ExprCast(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprType(expr, self.lower_ty(ty))\n+                hir::ExprType(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n             }\n             ExprKind::AddrOf(m, ref ohs) => {\n                 let m = self.lower_mutability(m);\n@@ -2119,7 +2207,7 @@ impl<'a> LoweringContext<'a> {\n                             this.sess.abort_if_errors();\n                         }\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n-                                         this.lower_fn_decl(decl),\n+                                         this.lower_fn_decl(decl, None, false),\n                                          body_id,\n                                          fn_decl_span,\n                                          is_generator)\n@@ -2193,7 +2281,8 @@ impl<'a> LoweringContext<'a> {\n                 };\n             }\n             ExprKind::Path(ref qself, ref path) => {\n-                hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n+                hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional,\n+                                               ImplTraitContext::Disallowed))\n             }\n             ExprKind::Break(opt_ident, ref opt_expr) => {\n                 let label_result = if self.is_in_loop_condition && opt_ident.is_none() {\n@@ -2246,7 +2335,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n             }\n             ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                hir::ExprStruct(self.lower_qpath(e.id, &None, path, ParamMode::Optional),\n+                hir::ExprStruct(self.lower_qpath(e.id, &None, path, ParamMode::Optional,\n+                                                 ImplTraitContext::Disallowed),\n                                 fields.iter().map(|x| self.lower_field(x)).collect(),\n                                 maybe_expr.as_ref().map(|x| P(self.lower_expr(x))))\n             }"}, {"sha": "ee83000c44003a92fb144c5c0da5d9c33260afe7", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -1461,9 +1461,12 @@ pub enum Ty_ {\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n-    /// An `impl Bound1 + Bound2 + Bound3` type\n-    /// where `Bound` is a trait or a lifetime.\n-    TyImplTrait(TyParamBounds),\n+    /// An exsitentially quantified (there exists a type satisfying) `impl\n+    /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n+    TyImplTraitExistential(TyParamBounds),\n+    /// An universally quantified (for all types satisfying) `impl\n+    /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n+    TyImplTraitUniversal(DefId, TyParamBounds),\n     /// Unused for now\n     TyTypeof(BodyId),\n     /// TyInfer means the type should be inferred instead of it having been"}, {"sha": "5d8e732b17c78c976bbee230acc58c4730f25b6a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -421,7 +421,8 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime)?;\n                 }\n             }\n-            hir::TyImplTrait(ref bounds) => {\n+            hir::TyImplTraitExistential(ref bounds) |\n+                hir::TyImplTraitUniversal(_, ref bounds) => {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n             }\n             hir::TyArray(ref ty, v) => {"}, {"sha": "a04683e1b22000b779c284ef4e7b46c4229e3586", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -287,7 +287,8 @@ impl_stable_hash_for!(enum hir::Ty_ {\n     TyTup(ts),\n     TyPath(qpath),\n     TyTraitObject(trait_refs, lifetime),\n-    TyImplTrait(bounds),\n+    TyImplTraitExistential(bounds),\n+    TyImplTraitUniversal(def_id, bounds),\n     TyTypeof(body_id),\n     TyErr,\n     TyInfer"}, {"sha": "fc6f6ed9aa8a955c517ee78aaf75171412feba09", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -1698,7 +1698,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         }\n \n         fn visit_ty(&mut self, ty: &hir::Ty) {\n-            if let hir::TyImplTrait(_) = ty.node {\n+            if let hir::TyImplTraitExistential(_) = ty.node {\n                 self.impl_trait = true;\n             }\n             intravisit::walk_ty(self, ty);"}, {"sha": "8c40f303b939a3d047f0311e590c0dd0f84daaf1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -1487,7 +1487,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n-            hir::TyImplTrait(_) => {\n+            hir::TyImplTraitExistential(_) => {\n                 let def_id = self.tcx.hir.local_def_id(ty.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n             }"}, {"sha": "74d92ce1c3e621c66dd568229bd27f99c5babb00", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -373,7 +373,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTrait(..) = ty.node {\n+        if let hir::TyImplTraitExistential(..) = ty.node {\n             if self.get(ty.id).is_some() {\n                 // Reach the (potentially private) type and the API being exposed.\n                 self.reach(ty.id).ty().predicates();\n@@ -1557,7 +1557,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTrait(..) = ty.node {\n+        if let hir::TyImplTraitExistential(..) = ty.node {\n             // Check the traits being exposed, as they're separate,\n             // e.g. `impl Iterator<Item=T>` has two predicates,\n             // `X: Iterator` and `<X as Iterator>::Item == T`,"}, {"sha": "34d617a2054034ad64f685979313d7ad1353c450", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 47, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -30,6 +30,7 @@ use util::nodemap::FxHashSet;\n \n use std::iter;\n use syntax::{abi, ast};\n+use syntax::symbol::keywords;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::Span;\n \n@@ -1033,53 +1034,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyImplTrait(_) => {\n-                // Figure out if we can allow an `impl Trait` here, by walking up\n-                // to a `fn` or inherent `impl` method, going only through `Ty`\n-                // or `TraitRef` nodes (as nothing else should be in types) and\n-                // ensuring that we reach the `fn`/method signature's return type.\n-                let mut node_id = ast_ty.id;\n-                let fn_decl = loop {\n-                    let parent = tcx.hir.get_parent_node(node_id);\n-                    match tcx.hir.get(parent) {\n-                        hir::map::NodeItem(&hir::Item {\n-                            node: hir::ItemFn(ref fn_decl, ..), ..\n-                        }) => break Some(fn_decl),\n-\n-                        hir::map::NodeImplItem(&hir::ImplItem {\n-                            node: hir::ImplItemKind::Method(ref sig, _), ..\n-                        }) => {\n-                            match tcx.hir.expect_item(tcx.hir.get_parent(parent)).node {\n-                                hir::ItemImpl(.., None, _, _) => {\n-                                    break Some(&sig.decl)\n-                                }\n-                                _ => break None\n-                            }\n-                        }\n-\n-                        hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => {}\n-\n-                        _ => break None\n-                    }\n-                    node_id = parent;\n-                };\n-                let allow = fn_decl.map_or(false, |fd| {\n-                    match fd.output {\n-                        hir::DefaultReturn(_) => false,\n-                        hir::Return(ref ty) => ty.id == node_id\n-                    }\n-                });\n-\n-                // Create the anonymized type.\n-                if allow {\n-                    let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                    tcx.mk_anon(def_id, Substs::identity_for_item(tcx, def_id))\n-                } else {\n-                    span_err!(tcx.sess, ast_ty.span, E0562,\n-                              \"`impl Trait` not allowed outside of function \\\n-                               and inherent method return types\");\n-                    tcx.types.err\n-                }\n+            hir::TyImplTraitExistential(_) => {\n+                let def_id = tcx.hir.local_def_id(ast_ty.id);\n+                tcx.mk_anon(def_id, Substs::identity_for_item(tcx, def_id))\n+            }\n+            hir::TyImplTraitUniversal(fn_def_id, _) => {\n+                let impl_trait_def_id = tcx.hir.local_def_id(ast_ty.id);\n+                let generics = tcx.generics_of(fn_def_id);\n+                let index = generics.type_param_to_index[&impl_trait_def_id.index];\n+                tcx.mk_param(index, keywords::Invalid.name() /* FIXME(chrisvittal) invalid? */)\n             }\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);"}, {"sha": "69bdb68945d765cdb50890c0c25d11b0d4edf8ea", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTrait(..) = ty.node {\n+        if let hir::TyImplTraitExistential(..) = ty.node {\n             let def_id = self.tcx.hir.local_def_id(ty.id);\n             self.tcx.generics_of(def_id);\n             self.tcx.predicates_of(def_id);\n@@ -854,7 +854,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n             Some(tcx.closure_base_def_id(def_id))\n         }\n-        NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n+        NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(..), .. }) => {\n             let mut parent_id = node_id;\n             loop {\n                 match tcx.hir.get(parent_id) {\n@@ -1155,7 +1155,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             icx.to_ty(ty)\n         }\n \n-        NodeTy(&hir::Ty { node: TyImplTrait(..), .. }) => {\n+        NodeTy(&hir::Ty { node: TyImplTraitExistential(..), .. }) => {\n             let owner = tcx.hir.get_parent_did(node_id);\n             let hir_id = tcx.hir.node_to_hir_id(node_id);\n             tcx.typeck_tables_of(owner).node_id_to_type(hir_id)\n@@ -1373,7 +1373,7 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        NodeTy(&Ty { node: TyImplTrait(ref bounds), span, .. }) => {\n+        NodeTy(&Ty { node: TyImplTraitExistential(ref bounds), span, .. }) => {\n             let substs = Substs::identity_for_item(tcx, def_id);\n             let anon_ty = tcx.mk_anon(def_id, substs);\n "}, {"sha": "1d107c169b04625dfe3e7c75e8866f931e7c7744", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd48e7d59a01da7d631695cfea06027cb96c06a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8fd48e7d59a01da7d631695cfea06027cb96c06a", "patch": "@@ -1960,7 +1960,9 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyImplTrait(ref bounds) => ImplTrait(bounds.clean(cx)),\n+            TyImplTraitExistential(ref bounds) |\n+                TyImplTraitUniversal(_, ref bounds) =>\n+                    ImplTrait(bounds.clean(cx)),\n             TyInfer | TyErr => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }"}]}