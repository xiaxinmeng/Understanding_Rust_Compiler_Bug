{"sha": "4c2ff0ab1790208e5a81abdcebd29d9e7d5c2ccf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMmZmMGFiMTc5MDIwOGU1YTgxYWJkY2ViZDI5ZDllN2Q1YzJjY2Y=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-07T09:22:42Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-09T08:17:31Z"}, "message": "ast_map: Added iterator over all node id's that match a path suffix.\n\nThis is useful e.g. for tools need a node-id, such as the flowgraph\npretty printer, since it can avoids the need to first pretty-print the\nwhole expanded,identified input in order to find out what the node-id\nactually is.\n\nIt currently only supports path suffixes thst are made up of module\nnames (e.g. you cannot use the type instantiation form `a::<int>::b`\nor `option::Option::unwrap_or` as a path suffix for this tool, though\nthe tool will produce paths that have non-modulues in the portion of\nthe path that is not included in the suffix).\n\n(addressed review feedback too)", "tree": {"sha": "95f43c73738533af476aef53870196b442248c2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95f43c73738533af476aef53870196b442248c2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c2ff0ab1790208e5a81abdcebd29d9e7d5c2ccf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2ff0ab1790208e5a81abdcebd29d9e7d5c2ccf", "html_url": "https://github.com/rust-lang/rust/commit/4c2ff0ab1790208e5a81abdcebd29d9e7d5c2ccf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c2ff0ab1790208e5a81abdcebd29d9e7d5c2ccf/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ba2d042244ba321258deb016d6d6e3a28546e0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba2d042244ba321258deb016d6d6e3a28546e0e", "html_url": "https://github.com/rust-lang/rust/commit/0ba2d042244ba321258deb016d6d6e3a28546e0e"}], "stats": {"total": 133, "additions": 132, "deletions": 1}, "files": [{"sha": "94ffad40c6f5ca078ba95357013a6d77c75ab087", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 132, "deletions": 1, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4c2ff0ab1790208e5a81abdcebd29d9e7d5c2ccf/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2ff0ab1790208e5a81abdcebd29d9e7d5c2ccf/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=4c2ff0ab1790208e5a81abdcebd29d9e7d5c2ccf", "patch": "@@ -11,7 +11,7 @@\n use abi;\n use ast::*;\n use ast_util;\n-use codemap::Span;\n+use codemap::{Span, Spanned};\n use fold::Folder;\n use fold;\n use parse::token;\n@@ -203,6 +203,10 @@ pub struct Map {\n }\n \n impl Map {\n+    fn entry_count(&self) -> uint {\n+        self.map.borrow().len()\n+    }\n+\n     fn find_entry(&self, id: NodeId) -> Option<MapEntry> {\n         let map = self.map.borrow();\n         if map.len() > id as uint {\n@@ -405,6 +409,20 @@ impl Map {\n         f(attrs)\n     }\n \n+    /// Returns an iterator that yields the node id's with paths that\n+    /// match `parts`.  (Requires `parts` is non-empty.)\n+    ///\n+    /// For example, if given `parts` equal to `[\"bar\", \"quux\"]`, then\n+    /// the iterator will produce node id's for items with paths\n+    /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n+    /// any other such items it can find in the map.\n+    pub fn nodes_matching_suffix<'a, S:Str>(&'a self, parts: &'a [S]) -> NodesMatchingSuffix<'a,S> {\n+        NodesMatchingSuffix { map: self,\n+                              item_name: parts.last().unwrap(),\n+                              where: parts.slice_to(parts.len() - 1),\n+                              idx: 0 }\n+    }\n+\n     pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n         let sp = match self.find(id) {\n             Some(NodeItem(item)) => item.span,\n@@ -438,6 +456,119 @@ impl Map {\n     }\n }\n \n+pub struct NodesMatchingSuffix<'a, S> {\n+    map: &'a Map,\n+    item_name: &'a S,\n+    where: &'a [S],\n+    idx: NodeId,\n+}\n+\n+impl<'a,S:Str> NodesMatchingSuffix<'a,S> {\n+    /// Returns true only if some suffix of the module path for parent\n+    /// matches `self.where`.\n+    ///\n+    /// In other words: let `[x_0,x_1,...,x_k]` be `self.where`;\n+    /// returns true if parent's path ends with the suffix\n+    /// `x_0::x_1::...::x_k`.\n+    fn suffix_matches(&self, parent: NodeId) -> bool {\n+        let mut cursor = parent;\n+        for part in self.where.iter().rev() {\n+            let (mod_id, mod_name) = match find_first_mod_parent(self.map, cursor) {\n+                None => return false,\n+                Some((node_id, name)) => (node_id, name),\n+            };\n+            if part.as_slice() != mod_name.as_str() {\n+                return false;\n+            }\n+            cursor = self.map.get_parent(mod_id);\n+        }\n+        return true;\n+\n+        // Finds the first mod in parent chain for `id`, along with\n+        // that mod's name.\n+        //\n+        // If `id` itself is a mod named `m` with parent `p`, then\n+        // returns `Some(id, m, p)`.  If `id` has no mod in its parent\n+        // chain, then returns `None`.\n+        fn find_first_mod_parent<'a>(map: &'a Map, mut id: NodeId) -> Option<(NodeId, Name)> {\n+            loop {\n+                match map.find(id) {\n+                    None => return None,\n+                    Some(NodeItem(item)) if item_is_mod(&*item) =>\n+                        return Some((id, item.ident.name)),\n+                    _ => {}\n+                }\n+                let parent = map.get_parent(id);\n+                if parent == id { return None }\n+                id = parent;\n+            }\n+\n+            fn item_is_mod(item: &Item) -> bool {\n+                match item.node {\n+                    ItemMod(_) => true,\n+                    _ => false,\n+                }\n+            }\n+        }\n+    }\n+\n+    // We are looking at some node `n` with a given name and parent\n+    // id; do their names match what I am seeking?\n+    fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n+        name.as_str() == self.item_name.as_slice() &&\n+            self.suffix_matches(parent_of_n)\n+    }\n+}\n+\n+impl<'a,S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a,S> {\n+    fn next(&mut self) -> Option<NodeId> {\n+        loop {\n+            let idx = self.idx;\n+            if idx as uint >= self.map.entry_count() {\n+                return None;\n+            }\n+            self.idx += 1;\n+            let (p, name) = match self.map.find_entry(idx) {\n+                Some(EntryItem(p, n))        => (p, n.name()),\n+                Some(EntryForeignItem(p, n)) => (p, n.name()),\n+                Some(EntryTraitMethod(p, n)) => (p, n.name()),\n+                Some(EntryMethod(p, n))      => (p, n.name()),\n+                Some(EntryVariant(p, n))     => (p, n.name()),\n+                _ => continue,\n+            };\n+            if self.matches_names(p, name) {\n+                return Some(idx)\n+            }\n+        }\n+    }\n+}\n+\n+trait Named {\n+    fn name(&self) -> Name;\n+}\n+\n+impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() } }\n+\n+impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Variant_ { fn name(&self) -> Name { self.name.name } }\n+impl Named for TraitMethod {\n+    fn name(&self) -> Name {\n+        match *self {\n+            Required(ref tm) => tm.ident.name,\n+            Provided(m) => m.name(),\n+        }\n+    }\n+}\n+impl Named for Method {\n+    fn name(&self) -> Name {\n+        match self.node {\n+            MethDecl(i, _, _, _, _, _, _, _) => i.name,\n+            MethMac(_) => fail!(\"encountered unexpanded method macro.\"),\n+        }\n+    }\n+}\n+\n pub trait FoldOps {\n     fn new_id(&self, id: NodeId) -> NodeId {\n         id"}]}