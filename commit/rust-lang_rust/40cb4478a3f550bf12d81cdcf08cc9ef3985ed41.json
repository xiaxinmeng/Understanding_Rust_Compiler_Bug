{"sha": "40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwY2I0NDc4YTNmNTUwYmYxMmQ4MWNkY2YwOGNjOWVmMzk4NWVkNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T19:42:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T19:42:19Z"}, "message": "Auto merge of #52782 - pnkfelix:issue-45696-dangly-paths-for-box, r=eddyb\n\n[NLL] Dangly paths for box\n\nSpecial-case `Box` in `rustc_mir::borrow_check`.\n\nSince we know dropping a box will not access any `&mut` or `&` references, it is safe to model its destructor as only touching the contents *owned* by the box.\n\n----\n\nThere are three main things going on here:\n\n1. The first main thing, this PR is fixing a bug in NLL where `rustc` previously would issue a diagnostic error in a case like this:\n```rust\nfn foo(x: Box<&mut i32>) -> &mut i32 { &mut **x }\n```\n\nsuch code was accepted by the AST-borrowck in the past, but NLL was rejecting it with the following message ([playground](https://play.rust-lang.org/?gist=13c5560f73bfb16d6dab3ceaad44c0f8&version=nightly&mode=release&edition=2015))\n```\nerror[E0597]: `**x` does not live long enough\n --> src/main.rs:3:40\n  |\n3 | fn foo(x: Box<&mut i32>) -> &mut i32 { &mut **x }\n  |                                        ^^^^^^^^ - `**x` dropped here while still borrowed\n  |                                        |\n  |                                        borrowed value does not live long enough\n  |\nnote: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 3:1...\n --> src/main.rs:3:1\n  |\n3 | fn foo(x: Box<&mut i32>) -> &mut i32 { &mut **x }\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n```\n\n2. The second main thing: The reason such code was previously rejected was because NLL (MIR-borrowck) incorporates a fix for issue #31567, where it models a destructor's execution as potentially accessing any borrows held by the thing being destructed. The tests with `Scribble` model this, showing that the compiler now catches such unsoundness.\n\nHowever, that fix for issue #31567 is too strong, in that NLL (MIR-borrowck) includes `Box` as one of the types with a destructor that potentially accesses any borrows held by the box. This thus was the cause of the main remaining discrepancy between AST-borrowck and MIR-borrowck, as documented in issue #45696, specifically in [the last example of this comment](https://github.com/rust-lang/rust/issues/45696#issuecomment-345367873), which I have adapted into the `fn foo` shown above.\n\nWe did close issue #45696 back in December of 2017, but AFAICT that example was not fixed by PR #46268. (And we did not include a test, etc etc.)\n\nThis PR fixes that case, by trying to model the so-called `DerefPure` semantics of `Box<T>` when we traverse the type of the input to `visit_terminator_drop`.\n\n3. The third main thing is that during a review of the first draft of this PR, @matthewjasper pointed out that the new traversal of `Box<T>` could cause the compiler to infinite loop. I have adjusted the PR to avoid this (by tracking what types we have previously seen), and added a much needed test of this somewhat odd scenario. (Its an odd scenario because the particular case only arises for things like `struct A(Box<A>);`, something which cannot be constructed in practice.)\n\nFix #45696.", "tree": {"sha": "732005252c911d8221ab532f93358e3d5e756053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/732005252c911d8221ab532f93358e3d5e756053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "html_url": "https://github.com/rust-lang/rust/commit/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/03da14ba8cd22acbcfe1cca617f6c274999e5e9e", "html_url": "https://github.com/rust-lang/rust/commit/03da14ba8cd22acbcfe1cca617f6c274999e5e9e"}, {"sha": "c02c00b8455d6ec6eff50ae94bebb4a424c95e02", "url": "https://api.github.com/repos/rust-lang/rust/commits/c02c00b8455d6ec6eff50ae94bebb4a424c95e02", "html_url": "https://github.com/rust-lang/rust/commit/c02c00b8455d6ec6eff50ae94bebb4a424c95e02"}], "stats": {"total": 595, "additions": 586, "deletions": 9}, "files": [{"sha": "4596c7be1c557b728402a4e23b4420225220f4a6", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 146, "deletions": 5, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -22,7 +22,7 @@ use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Pla\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, ParamEnv, TyCtxt};\n+use rustc::ty::{self, ParamEnv, TyCtxt, Ty};\n \n use rustc_errors::{Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::graph::dominators::Dominators;\n@@ -598,7 +598,12 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // that is useful later.\n                 let drop_place_ty = gcx.lift(&drop_place_ty).unwrap();\n \n-                self.visit_terminator_drop(loc, term, flow_state, drop_place, drop_place_ty, span);\n+                debug!(\"visit_terminator_drop \\\n+                        loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n+                       loc, term, drop_place, drop_place_ty, span);\n+\n+                self.visit_terminator_drop(\n+                    loc, term, flow_state, drop_place, drop_place_ty, span, SeenTy(None));\n             }\n             TerminatorKind::DropAndReplace {\n                 location: ref drop_place,\n@@ -832,6 +837,35 @@ impl InitializationRequiringAction {\n     }\n }\n \n+/// A simple linked-list threaded up the stack of recursive calls in `visit_terminator_drop`.\n+#[derive(Copy, Clone, Debug)]\n+struct SeenTy<'a, 'gcx: 'a>(Option<(Ty<'gcx>, &'a SeenTy<'a, 'gcx>)>);\n+\n+impl<'a, 'gcx> SeenTy<'a, 'gcx> {\n+    /// Return a new list with `ty` prepended to the front of `self`.\n+    fn cons(&'a self, ty: Ty<'gcx>) -> Self {\n+        SeenTy(Some((ty, self)))\n+    }\n+\n+    /// True if and only if `ty` occurs on the linked list `self`.\n+    fn have_seen(self, ty: Ty) -> bool {\n+        let mut this = self.0;\n+        loop {\n+            match this {\n+                None => return false,\n+                Some((seen_ty, recur)) => {\n+                    if seen_ty == ty {\n+                        return true;\n+                    } else {\n+                        this = recur.0;\n+                        continue;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Invokes `access_place` as appropriate for dropping the value\n     /// at `drop_place`. Note that the *actual* `Drop` in the MIR is\n@@ -847,14 +881,57 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_place: &Place<'tcx>,\n         erased_drop_place_ty: ty::Ty<'gcx>,\n         span: Span,\n+        prev_seen: SeenTy<'_, 'gcx>,\n     ) {\n+        if prev_seen.have_seen(erased_drop_place_ty) {\n+            // if we have directly seen the input ty `T`, then we must\n+            // have had some *direct* ownership loop between `T` and\n+            // some directly-owned (as in, actually traversed by\n+            // recursive calls below) part that is also of type `T`.\n+            //\n+            // Note: in *all* such cases, the data in question cannot\n+            // be constructed (nor destructed) in finite time/space.\n+            //\n+            // Proper examples, some of which are statically rejected:\n+            //\n+            // * `struct A { field: A, ... }`:\n+            //   statically rejected as infinite size\n+            //\n+            // * `type B = (B, ...);`:\n+            //   statically rejected as cyclic\n+            //\n+            // * `struct C { field: Box<C>, ... }`\n+            // * `struct D { field: Box<(D, D)>, ... }`:\n+            //   *accepted*, though impossible to construct\n+            //\n+            // Here is *NOT* an example:\n+            // * `struct Z { field: Option<Box<Z>>, ... }`:\n+            //   Here, the type is both representable in finite space (due to the boxed indirection)\n+            //   and constructable in finite time (since the recursion can bottom out with `None`).\n+            //   This is an obvious instance of something the compiler must accept.\n+            //\n+            // Since some of the above impossible cases like `C` and\n+            // `D` are accepted by the compiler, we must take care not\n+            // to infinite-loop while processing them. But since such\n+            // cases cannot actually arise, it is sound for us to just\n+            // skip them during drop. If the developer uses unsafe\n+            // code to construct them, they should not be surprised by\n+            // weird drop behavior in their resulting code.\n+            debug!(\"visit_terminator_drop previously seen \\\n+                    erased_drop_place_ty: {:?} on prev_seen: {:?}; returning early.\",\n+                   erased_drop_place_ty, prev_seen);\n+            return;\n+        }\n+\n         let gcx = self.tcx.global_tcx();\n         let drop_field = |mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n                           (index, field): (usize, ty::Ty<'gcx>)| {\n             let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n             let place = drop_place.clone().field(Field::new(index), field_ty);\n \n-            mir.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span);\n+            debug!(\"visit_terminator_drop drop_field place: {:?} field_ty: {:?}\", place, field_ty);\n+            let seen = prev_seen.cons(erased_drop_place_ty);\n+            mir.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span, seen);\n         };\n \n         match erased_drop_place_ty.sty {\n@@ -899,20 +976,84 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n+\n+            // #45696: special-case Box<T> by treating its dtor as\n+            // only deep *across owned content*. Namely, we know\n+            // dropping a box does not touch data behind any\n+            // references it holds; if we were to instead fall into\n+            // the base case below, we would have a Deep Write due to\n+            // the box being `needs_drop`, and that Deep Write would\n+            // touch `&mut` data in the box.\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                // When/if we add a `&own T` type, this action would\n+                // be like running the destructor of the `&own T`.\n+                // (And the owner of backing storage referenced by the\n+                // `&own T` would be responsible for deallocating that\n+                // backing storage.)\n+\n+                // we model dropping any content owned by the box by\n+                // recurring on box contents. This catches cases like\n+                // `Box<Box<ScribbleWhenDropped<&mut T>>>`, while\n+                // still restricting Write to *owned* content.\n+                let ty = erased_drop_place_ty.boxed_ty();\n+                let deref_place = drop_place.clone().deref();\n+                debug!(\"visit_terminator_drop drop-box-content deref_place: {:?} ty: {:?}\",\n+                       deref_place, ty);\n+                let seen = prev_seen.cons(erased_drop_place_ty);\n+                self.visit_terminator_drop(\n+                    loc, term, flow_state, &deref_place, ty, span, seen);\n+            }\n+\n             _ => {\n                 // We have now refined the type of the value being\n                 // dropped (potentially) to just the type of a\n                 // subfield; so check whether that field's type still\n-                // \"needs drop\". If so, we assume that the destructor\n-                // may access any data it likes (i.e., a Deep Write).\n+                // \"needs drop\".\n                 if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n+                    // If so, we assume that the destructor may access\n+                    // any data it likes (i.e., a Deep Write).\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n                         (drop_place, span),\n                         (Deep, Write(WriteKind::StorageDeadOrDrop)),\n                         LocalMutationIsAllowed::Yes,\n                         flow_state,\n                     );\n+                } else {\n+                    // If there is no destructor, we still include a\n+                    // *shallow* write.  This essentially ensures that\n+                    // borrows of the memory directly at `drop_place`\n+                    // cannot continue to be borrowed across the drop.\n+                    //\n+                    // If we were to use a Deep Write here, then any\n+                    // `&mut T` that is reachable from `drop_place`\n+                    // would get invalidated; fixing that is the\n+                    // essence of resolving issue #45696.\n+                    //\n+                    // * Note: In the compiler today, doing a Deep\n+                    //   Write here would not actually break\n+                    //   anything beyond #45696; for example it does not\n+                    //   break this example:\n+                    //\n+                    //   ```rust\n+                    //   fn reborrow(x: &mut i32) -> &mut i32 { &mut *x }\n+                    //   ```\n+                    //\n+                    //   Why? Because we do not schedule/emit\n+                    //   `Drop(x)` in the MIR unless `x` needs drop in\n+                    //   the first place.\n+                    //\n+                    // FIXME: Its possible this logic actually should\n+                    // be attached to the `StorageDead` statement\n+                    // rather than the `Drop`. See discussion on PR\n+                    // #52782.\n+                    self.access_place(\n+                        ContextKind::Drop.new(loc),\n+                        (drop_place, span),\n+                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                        LocalMutationIsAllowed::Yes,\n+                        flow_state,\n+                    );\n                 }\n             }\n         }"}, {"sha": "b49bf81715079006535a47584eeeb1917b104e59", "filename": "src/test/ui/generator/dropck.nll.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -9,8 +9,6 @@ LL | }\n    | |\n    | `*cell` dropped here while still borrowed\n    | borrow later used here, when `gen` is dropped\n-   |\n-   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `ref_` does not live long enough\n   --> $DIR/dropck.rs:22:11"}, {"sha": "881f37c2e0b0e59dc6c68d5ff2e9732af7b182f4", "filename": "src/test/ui/issue-45696-long-live-borrows-in-boxes.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-long-live-borrows-in-boxes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-long-live-borrows-in-boxes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45696-long-live-borrows-in-boxes.rs?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rust-lang/rust#45696: This test is checking that we can return\n+// mutable borrows owned by boxes even when the boxes are dropped.\n+//\n+// We will explicitly test AST-borrowck, NLL, and migration modes;\n+// thus we will also skip the automated compare-mode=nll.\n+\n+// revisions: ast nll migrate\n+// ignore-compare-mode-nll\n+\n+#![cfg_attr(nll, feature(nll))]\n+//[migrate]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+// run-pass\n+\n+// This function shows quite directly what is going on: We have a\n+// reborrow of contents within the box.\n+fn return_borrow_from_dropped_box_1(x: Box<&mut u32>) -> &mut u32 { &mut **x }\n+\n+// This function is the way you'll probably see this in practice (the\n+// reborrow is now implicit).\n+fn return_borrow_from_dropped_box_2(x: Box<&mut u32>) -> &mut u32 { *x }\n+\n+// For the remaining tests we just add some fields or other\n+// indirection to ensure that the compiler isn't just special-casing\n+// the above `Box<&mut T>` as the only type that would work.\n+\n+// Here we add a tuple of indirection between the box and the\n+// reference.\n+type BoxedTup<'a, 'b> = Box<(&'a mut u32, &'b mut u32)>;\n+\n+fn return_borrow_of_field_from_dropped_box_1<'a>(x: BoxedTup<'a, '_>) -> &'a mut u32 {\n+    &mut *x.0\n+}\n+\n+fn return_borrow_of_field_from_dropped_box_2<'a>(x: BoxedTup<'a, '_>) -> &'a mut u32 {\n+    x.0\n+}\n+\n+fn return_borrow_from_dropped_tupled_box_1<'a>(x: (BoxedTup<'a, '_>, &mut u32)) -> &'a mut u32 {\n+    &mut *(x.0).0\n+}\n+\n+fn return_borrow_from_dropped_tupled_box_2<'a>(x: (BoxedTup<'a, '_>, &mut u32)) -> &'a mut u32 {\n+    (x.0).0\n+}\n+\n+fn basic_tests() {\n+    let mut x = 2;\n+    let mut y = 3;\n+    let mut z = 4;\n+    *return_borrow_from_dropped_box_1(Box::new(&mut x)) += 10;\n+    assert_eq!((x, y, z), (12, 3, 4));\n+    *return_borrow_from_dropped_box_2(Box::new(&mut x)) += 10;\n+    assert_eq!((x, y, z), (22, 3, 4));\n+    *return_borrow_of_field_from_dropped_box_1(Box::new((&mut x, &mut y))) += 10;\n+    assert_eq!((x, y, z), (32, 3, 4));\n+    *return_borrow_of_field_from_dropped_box_2(Box::new((&mut x, &mut y))) += 10;\n+    assert_eq!((x, y, z), (42, 3, 4));\n+    *return_borrow_from_dropped_tupled_box_1((Box::new((&mut x, &mut y)), &mut z)) += 10;\n+    assert_eq!((x, y, z), (52, 3, 4));\n+    *return_borrow_from_dropped_tupled_box_2((Box::new((&mut x, &mut y)), &mut z)) += 10;\n+    assert_eq!((x, y, z), (62, 3, 4));\n+}\n+\n+// These scribbling tests have been transcribed from\n+// issue-45696-scribble-on-boxed-borrow.rs\n+//\n+// In the context of that file, these tests are meant to show cases\n+// that should be *accepted* by the compiler, so here we are actually\n+// checking that the code we get when they are compiled matches our\n+// expectations.\n+\n+struct Scribble<'a>(&'a mut u32);\n+\n+impl<'a> Drop for Scribble<'a> { fn drop(&mut self) { *self.0 = 42; } }\n+\n+// this is okay, in both AST-borrowck and NLL: The `Scribble` here *has*\n+// to strictly outlive `'a`\n+fn borrowed_scribble<'a>(s: &'a mut Scribble) -> &'a mut u32 {\n+    &mut *s.0\n+}\n+\n+// this, by analogy to previous case, is also okay.\n+fn boxed_borrowed_scribble<'a>(s: Box<&'a mut Scribble>) -> &'a mut u32 {\n+    &mut *(*s).0\n+}\n+\n+// this, by analogy to previous case, is also okay.\n+fn boxed_boxed_borrowed_scribble<'a>(s: Box<Box<&'a mut Scribble>>) -> &'a mut u32 {\n+    &mut *(**s).0\n+}\n+\n+fn scribbling_tests() {\n+    let mut x = 1;\n+    {\n+        let mut long_lived = Scribble(&mut x);\n+        *borrowed_scribble(&mut long_lived) += 10;\n+        assert_eq!(*long_lived.0, 11);\n+        // (Scribble dtor runs here, after `&mut`-borrow above ends)\n+    }\n+    assert_eq!(x, 42);\n+    x = 1;\n+    {\n+        let mut long_lived = Scribble(&mut x);\n+        *boxed_borrowed_scribble(Box::new(&mut long_lived)) += 10;\n+        assert_eq!(*long_lived.0, 11);\n+        // (Scribble dtor runs here, after `&mut`-borrow above ends)\n+    }\n+    assert_eq!(x, 42);\n+    x = 1;\n+    {\n+        let mut long_lived = Scribble(&mut x);\n+        *boxed_boxed_borrowed_scribble(Box::new(Box::new(&mut long_lived))) += 10;\n+        assert_eq!(*long_lived.0, 11);\n+        // (Scribble dtor runs here, after `&mut`-borrow above ends)\n+    }\n+    assert_eq!(x, 42);\n+}\n+\n+fn main() {\n+    basic_tests();\n+    scribbling_tests();\n+}"}, {"sha": "da42e171fcc5089fdfa8b78d605336e6b88048f8", "filename": "src/test/ui/issue-45696-no-variant-box-recur.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-no-variant-box-recur.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-no-variant-box-recur.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45696-no-variant-box-recur.rs?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rust-lang/rust#45696: This test checks the compiler won't infinite\n+// loop when you declare a variable of type `struct A(Box<A>, ...);`\n+// (which is impossible to construct but *is* possible to declare; see\n+// also issues #4287, #44933, and #52852).\n+//\n+// We will explicitly test AST-borrowck, NLL, and migration modes;\n+// thus we will also skip the automated compare-mode=nll.\n+\n+// revisions: ast nll migrate\n+// ignore-compare-mode-nll\n+\n+#![cfg_attr(nll, feature(nll))]\n+//[migrate]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+// run-pass\n+\n+// This test has structs and functions that are by definiton unusable\n+// all over the place, so just go ahead and allow dead_code\n+#![allow(dead_code)]\n+\n+// direct regular recursion with indirect ownership via box\n+struct C { field: Box<C> }\n+\n+// direct non-regular recursion with indirect ownership via box\n+struct D { field: Box<(D, D)> }\n+\n+// indirect regular recursion with indirect ownership via box.\n+struct E { field: F }\n+struct F { field: Box<E> }\n+\n+// indirect non-regular recursion with indirect ownership via box.\n+struct G { field: (H, H) }\n+struct H { field: Box<G> }\n+\n+// These enums are cases that are not currently hit by the\n+// `visit_terminator_drop` recursion down a type's structural\n+// definition.\n+//\n+// But it seems prudent to include them in this test as variants on\n+// the above, in that they are similarly non-constructable data types\n+// with destructors that would diverge.\n+enum I { One(Box<I>) }\n+enum J { One(Box<J>), Two(Box<J>) }\n+\n+fn impossible_to_call_c(_c: C) { }\n+fn impossible_to_call_d(_d: D) { }\n+fn impossible_to_call_e(_e: E) { }\n+fn impossible_to_call_f(_f: F) { }\n+fn impossible_to_call_g(_g: G) { }\n+fn impossible_to_call_h(_h: H) { }\n+fn impossible_to_call_i(_i: I) { }\n+fn impossible_to_call_j(_j: J) { }\n+\n+fn main() {\n+\n+}"}, {"sha": "6172a5e35a8d9520e1ff84941f0070da53f287d6", "filename": "src/test/ui/issue-45696-scribble-on-boxed-borrow.ast.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.ast.stderr?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -0,0 +1,14 @@\n+error: compilation successful\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:89:1\n+   |\n+LL | / fn main() { //[ast]~ ERROR compilation successful\n+LL | |      //[migrate]~^ ERROR compilation successful\n+LL | |     let mut x = 1;\n+LL | |     {\n+...  |\n+LL | |     *boxed_boxed_scribbled(Box::new(Box::new(Scribble(&mut x)))) += 10;\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "da0dfac2d18b10eae0c023ebd114fac3e35c854b", "filename": "src/test/ui/issue-45696-scribble-on-boxed-borrow.migrate.stderr", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -0,0 +1,69 @@\n+warning[E0597]: `*s.0` does not live long enough\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:63:5\n+   |\n+LL |     &mut *s.0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+   |     ^^^^^^^^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `*s.0` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 62:14...\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:62:14\n+   |\n+LL | fn scribbled<'a>(s: Scribble<'a>) -> &'a mut u32 {\n+   |              ^^\n+   = warning: This error has been downgraded to a warning for backwards compatibility with previous releases.\n+           It represents potential unsoundness in your code.\n+           This warning will become a hard error in the future.\n+\n+warning[E0597]: `*s.0` does not live long enough\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:73:5\n+   |\n+LL |     &mut *(*s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+   |     ^^^^^^^^^^^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `*s.0` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 72:20...\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:72:20\n+   |\n+LL | fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 {\n+   |                    ^^\n+   = warning: This error has been downgraded to a warning for backwards compatibility with previous releases.\n+           It represents potential unsoundness in your code.\n+           This warning will become a hard error in the future.\n+\n+warning[E0597]: `*s.0` does not live long enough\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:83:5\n+   |\n+LL |     &mut *(**s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+   |     ^^^^^^^^^^^^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `*s.0` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 82:26...\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:82:26\n+   |\n+LL | fn boxed_boxed_scribbled<'a>(s: Box<Box<Scribble<'a>>>) -> &'a mut u32 {\n+   |                          ^^\n+   = warning: This error has been downgraded to a warning for backwards compatibility with previous releases.\n+           It represents potential unsoundness in your code.\n+           This warning will become a hard error in the future.\n+\n+error: compilation successful\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:89:1\n+   |\n+LL | / fn main() { //[ast]~ ERROR compilation successful\n+LL | |      //[migrate]~^ ERROR compilation successful\n+LL | |     let mut x = 1;\n+LL | |     {\n+...  |\n+LL | |     *boxed_boxed_scribbled(Box::new(Box::new(Scribble(&mut x)))) += 10;\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "09cbc2f9451291ad6eda4cfebdeb782490878421", "filename": "src/test/ui/issue-45696-scribble-on-boxed-borrow.nll.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -0,0 +1,48 @@\n+error[E0597]: `*s.0` does not live long enough\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:63:5\n+   |\n+LL |     &mut *s.0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+   |     ^^^^^^^^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `*s.0` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 62:14...\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:62:14\n+   |\n+LL | fn scribbled<'a>(s: Scribble<'a>) -> &'a mut u32 {\n+   |              ^^\n+\n+error[E0597]: `*s.0` does not live long enough\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:73:5\n+   |\n+LL |     &mut *(*s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+   |     ^^^^^^^^^^^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `*s.0` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 72:20...\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:72:20\n+   |\n+LL | fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 {\n+   |                    ^^\n+\n+error[E0597]: `*s.0` does not live long enough\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:83:5\n+   |\n+LL |     &mut *(**s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+   |     ^^^^^^^^^^^^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `*s.0` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 82:26...\n+  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:82:26\n+   |\n+LL | fn boxed_boxed_scribbled<'a>(s: Box<Box<Scribble<'a>>>) -> &'a mut u32 {\n+   |                          ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "5a4874249e2f44a5b5fd8780eb66de0ae4253455", "filename": "src/test/ui/issue-45696-scribble-on-boxed-borrow.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45696-scribble-on-boxed-borrow.rs?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rust-lang/rust#45696: This test is checking that we *cannot* return\n+// mutable borrows that would be scribbled over by destructors before\n+// the return occurs.\n+//\n+// We will explicitly test AST-borrowck, NLL, and migration modes;\n+// thus we will also skip the automated compare-mode=nll.\n+\n+// revisions: ast nll migrate\n+// ignore-compare-mode-nll\n+\n+// This test is going to pass in the ast and migrate revisions,\n+// because the AST-borrowck accepted this code in the past (see notes\n+// below). So we use `#[rustc_error]` to keep the outcome as an error\n+// in all scenarios, and rely on the stderr files to show what the\n+// actual behavior is. (See rust-lang/rust#49855.)\n+#![feature(rustc_attrs)]\n+\n+#![cfg_attr(nll, feature(nll))]\n+//[migrate]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+struct Scribble<'a>(&'a mut u32);\n+\n+impl<'a> Drop for Scribble<'a> { fn drop(&mut self) { *self.0 = 42; } }\n+\n+// this is okay, in both AST-borrowck and NLL: The `Scribble` here *has*\n+// to strictly outlive `'a`\n+fn borrowed_scribble<'a>(s: &'a mut Scribble) -> &'a mut u32 {\n+    &mut *s.0\n+}\n+\n+// this, by analogy to previous case, is also okay.\n+fn boxed_borrowed_scribble<'a>(s: Box<&'a mut Scribble>) -> &'a mut u32 {\n+    &mut *(*s).0\n+}\n+\n+// this, by analogy to previous case, is also okay.\n+fn boxed_boxed_borrowed_scribble<'a>(s: Box<Box<&'a mut Scribble>>) -> &'a mut u32 {\n+    &mut *(**s).0\n+}\n+\n+// this is not okay: in between the time that we take the mutable\n+// borrow and the caller receives it as a return value, the drop of\n+// `s` will scribble on it, violating our aliasing guarantees.\n+//\n+// * (Maybe in the future the two-phase borrows system will be\n+//   extended to support this case. But for now, it is an error in\n+//   NLL, even with two-phase borrows.)\n+//\n+// In any case, the AST-borrowck was not smart enough to know that\n+// this should be an error. (Which is perhaps the essence of why\n+// rust-lang/rust#45696 arose in the first place.)\n+fn scribbled<'a>(s: Scribble<'a>) -> &'a mut u32 {\n+    &mut *s.0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+    //[migrate]~^ WARNING `*s.0` does not live long enough [E0597]\n+    //[migrate]~| WARNING This error has been downgraded to a warning for backwards compatibility\n+}\n+\n+// This, by analogy to previous case, is *also* not okay.\n+//\n+// (But again, AST-borrowck was not smart enogh to know that this\n+// should be an error.)\n+fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 {\n+    &mut *(*s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+    //[migrate]~^ WARNING `*s.0` does not live long enough [E0597]\n+    //[migrate]~| WARNING This error has been downgraded to a warning for backwards compatibility\n+}\n+\n+// This, by analogy to previous case, is *also* not okay.\n+//\n+// (But again, AST-borrowck was not smart enogh to know that this\n+// should be an error.)\n+fn boxed_boxed_scribbled<'a>(s: Box<Box<Scribble<'a>>>) -> &'a mut u32 {\n+    &mut *(**s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n+    //[migrate]~^ WARNING `*s.0` does not live long enough [E0597]\n+    //[migrate]~| WARNING This error has been downgraded to a warning for backwards compatibility\n+}\n+\n+#[rustc_error]\n+fn main() { //[ast]~ ERROR compilation successful\n+     //[migrate]~^ ERROR compilation successful\n+    let mut x = 1;\n+    {\n+        let mut long_lived = Scribble(&mut x);\n+        *borrowed_scribble(&mut long_lived) += 10;\n+        // (Scribble dtor runs here, after `&mut`-borrow above ends)\n+    }\n+    {\n+        let mut long_lived = Scribble(&mut x);\n+        *boxed_borrowed_scribble(Box::new(&mut long_lived)) += 10;\n+        // (Scribble dtor runs here, after `&mut`-borrow above ends)\n+    }\n+    {\n+        let mut long_lived = Scribble(&mut x);\n+        *boxed_boxed_borrowed_scribble(Box::new(Box::new(&mut long_lived))) += 10;\n+        // (Scribble dtor runs here, after `&mut`-borrow above ends)\n+    }\n+    *scribbled(Scribble(&mut x)) += 10;\n+    *boxed_scribbled(Box::new(Scribble(&mut x))) += 10;\n+    *boxed_boxed_scribbled(Box::new(Box::new(Scribble(&mut x)))) += 10;\n+}"}, {"sha": "08e4b9ec9faa2b055b1dacda481ac3232639ea48", "filename": "src/test/ui/span/dropck-object-cycle.nll.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fspan%2Fdropck-object-cycle.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41/src%2Ftest%2Fui%2Fspan%2Fdropck-object-cycle.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck-object-cycle.nll.stderr?ref=40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "patch": "@@ -9,8 +9,6 @@ LL | }\n    | |\n    | `*m` dropped here while still borrowed\n    | borrow later used here, when `m` is dropped\n-   |\n-   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}]}