{"sha": "ae6fcab733007b4d59b5b2aac1825bf1f275b0b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNmZjYWI3MzMwMDdiNGQ1OWI1YjJhYWMxODI1YmYxZjI3NWIwYjI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-02-01T19:22:05Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-02-01T19:29:38Z"}, "message": "Make `SubPatSet` clearer by flipping its meaning", "tree": {"sha": "b1142a1b14cfce11f7c8c6700992375bc45d4289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1142a1b14cfce11f7c8c6700992375bc45d4289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae6fcab733007b4d59b5b2aac1825bf1f275b0b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae6fcab733007b4d59b5b2aac1825bf1f275b0b2", "html_url": "https://github.com/rust-lang/rust/commit/ae6fcab733007b4d59b5b2aac1825bf1f275b0b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae6fcab733007b4d59b5b2aac1825bf1f275b0b2/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37e7dd22a990eaffa56da89b4fa988ef5822e59f", "url": "https://api.github.com/repos/rust-lang/rust/commits/37e7dd22a990eaffa56da89b4fa988ef5822e59f", "html_url": "https://github.com/rust-lang/rust/commit/37e7dd22a990eaffa56da89b4fa988ef5822e59f"}], "stats": {"total": 213, "additions": 119, "deletions": 94}, "files": [{"sha": "f3f21b903ea089deff284ac0e4f73ba573c78c6d", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 119, "deletions": 94, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/ae6fcab733007b4d59b5b2aac1825bf1f275b0b2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6fcab733007b4d59b5b2aac1825bf1f275b0b2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=ae6fcab733007b4d59b5b2aac1825bf1f275b0b2", "patch": "@@ -619,34 +619,45 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     }\n }\n \n-/// Given a pattern or a pattern-stack, this struct captures a set of its subpattern branches. We\n-/// use that to track unreachable sub-patterns arising from or-patterns. In the absence of\n-/// or-patterns this will always be either `Empty` or `Full`.\n-/// We support a limited set of operations, so not all possible sets of subpatterns can be\n-/// represented. That's ok, we only want the ones that make sense to capture unreachable\n-/// subpatterns.\n-/// What we're trying to do is illustrated by this:\n+/// Given a pattern or a pattern-stack, this struct captures a set of its subpatterns. We use that\n+/// to track reachable sub-patterns arising from or-patterns. In the absence of or-patterns this\n+/// will always be either `Empty` (the whole pattern is unreachable) or `Full` (the whole pattern\n+/// is reachable). When there are or-patterns, some subpatterns may be reachable while others\n+/// aren't. In this case the whole pattern still counts as reachable, but we will lint the\n+/// unreachable subpatterns.\n+///\n+/// This supports a limited set of operations, so not all possible sets of subpatterns can be\n+/// represented. That's ok, we only want the ones that make sense for our usage.\n+///\n+/// What we're doing is illustrated by this:\n /// ```\n-/// match (true, true) {\n-///     (true, true) => {}\n-///     (true | false, true | false) => {}\n+/// match (true, 0) {\n+///     (true, 0) => {}\n+///     (_, 1) => {}\n+///     (true | false, 0 | 1) => {}\n /// }\n /// ```\n-/// When we try the alternatives of the first or-pattern, the last `true` is unreachable in the\n-/// first alternative but no the other. So we don't want to report it as unreachable. Therefore we\n-/// intersect sets of unreachable patterns coming from different alternatives in order to figure\n-/// out which subpatterns are overall unreachable.\n+/// When we try the alternatives of the `true | false` or-pattern, the last `0` is reachable in the\n+/// `false` alternative but not the `true`. So overall it is reachable. By contrast, the last `1`\n+/// is not reachable in either alternative, so we want to signal this to the user.\n+/// Therefore we take the union of sets of reachable patterns coming from different alternatives in\n+/// order to figure out which subpatterns are overall reachable.\n+///\n+/// Invariant: we try to construct the smallest representation we can. In particular if\n+/// `self.is_empty()` we ensure that `self` is `Empty`, and same with `Full`. This is not important\n+/// for correctness currently.\n #[derive(Debug, Clone)]\n enum SubPatSet<'p, 'tcx> {\n+    /// The empty set. This means the pattern is unreachable.\n+    Empty,\n     /// The set containing the full pattern.\n     Full,\n-    /// The empty set.\n-    Empty,\n     /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n-    /// of its subpatterns. Missing entries in the map are implicitly empty.\n+    /// of its subpatterns. Missing entries in the map are implicitly full, because that's the\n+    /// common case.\n     Seq { subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>> },\n     /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n-    /// entries in the map are implicitly full. Note: we always flatten nested or-patterns.\n+    /// entries in the map are implicitly empty. Note: we always flatten nested or-patterns.\n     Alt {\n         subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>>,\n         /// Counts the total number of alternatives in the pattern\n@@ -657,88 +668,91 @@ enum SubPatSet<'p, 'tcx> {\n }\n \n impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n-    fn empty() -> Self {\n-        SubPatSet::Empty\n-    }\n     fn full() -> Self {\n         SubPatSet::Full\n     }\n+    fn empty() -> Self {\n+        SubPatSet::Empty\n+    }\n \n-    fn is_full(&self) -> bool {\n+    fn is_empty(&self) -> bool {\n         match self {\n-            SubPatSet::Full => true,\n-            SubPatSet::Empty => false,\n+            SubPatSet::Empty => true,\n+            SubPatSet::Full => false,\n             // If any subpattern in a sequence is unreachable, the whole pattern is unreachable.\n-            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_full()),\n-            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_full()),\n+            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_empty()),\n+            // An or-pattern is reachable if any of its alternatives is.\n+            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_empty()),\n         }\n     }\n \n-    fn is_empty(&self) -> bool {\n+    fn is_full(&self) -> bool {\n         match self {\n-            SubPatSet::Full => false,\n-            SubPatSet::Empty => true,\n-            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_empty()),\n+            SubPatSet::Empty => false,\n+            SubPatSet::Full => true,\n+            // The whole pattern is reachable only when all its alternatives are.\n+            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_full()),\n+            // The whole or-pattern is reachable only when all its alternatives are.\n             SubPatSet::Alt { subpats, alt_count, .. } => {\n-                subpats.len() == *alt_count && subpats.values().all(|set| set.is_empty())\n+                subpats.len() == *alt_count && subpats.values().all(|set| set.is_full())\n             }\n         }\n     }\n \n-    /// Intersect `self` with `other`, mutating `self`.\n-    fn intersect(&mut self, other: Self) {\n+    /// Union `self` with `other`, mutating `self`.\n+    fn union(&mut self, other: Self) {\n         use SubPatSet::*;\n-        // Intersecting with empty stays empty; intersecting with full changes nothing.\n-        if self.is_empty() || other.is_full() {\n+        // Union with full stays full; union with empty changes nothing.\n+        if self.is_full() || other.is_empty() {\n             return;\n-        } else if self.is_full() {\n+        } else if self.is_empty() {\n             *self = other;\n             return;\n-        } else if other.is_empty() {\n-            *self = Empty;\n+        } else if other.is_full() {\n+            *self = Full;\n             return;\n         }\n \n         match (&mut *self, other) {\n             (Seq { subpats: s_set }, Seq { subpats: mut o_set }) => {\n-                s_set.retain(|i, s_sub_set| {\n-                    // Missing entries count as empty.\n-                    let o_sub_set = o_set.remove(&i).unwrap_or(Empty);\n-                    s_sub_set.intersect(o_sub_set);\n-                    // We drop empty entries.\n-                    !s_sub_set.is_empty()\n-                });\n-                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n-                // intersecting with empty returns empty, we can drop those entries.\n-            }\n-            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n                 s_set.retain(|i, s_sub_set| {\n                     // Missing entries count as full.\n                     let o_sub_set = o_set.remove(&i).unwrap_or(Full);\n-                    s_sub_set.intersect(o_sub_set);\n+                    s_sub_set.union(o_sub_set);\n                     // We drop full entries.\n                     !s_sub_set.is_full()\n                 });\n                 // Everything left in `o_set` is missing from `s_set`, i.e. counts as full. Since\n-                // intersecting with full changes nothing, we can take those entries as is.\n+                // unioning with full returns full, we can drop those entries.\n+            }\n+            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as empty.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Empty);\n+                    s_sub_set.union(o_sub_set);\n+                    // We drop empty entries.\n+                    !s_sub_set.is_empty()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n+                // unioning with empty changes nothing, we can take those entries as is.\n                 s_set.extend(o_set);\n             }\n             _ => bug!(),\n         }\n \n-        if self.is_empty() {\n-            *self = Empty;\n+        if self.is_full() {\n+            *self = Full;\n         }\n     }\n \n-    /// Returns a list of the spans of the unreachable subpatterns. If `self` is full we return\n-    /// `None`.\n-    fn to_spans(&self) -> Option<Vec<Span>> {\n-        /// Panics if `set.is_full()`.\n+    /// Returns a list of the spans of the unreachable subpatterns. If `self` is empty (i.e. the\n+    /// whole pattern is unreachable) we return `None`.\n+    fn list_unreachable_spans(&self) -> Option<Vec<Span>> {\n+        /// Panics if `set.is_empty()`.\n         fn fill_spans(set: &SubPatSet<'_, '_>, spans: &mut Vec<Span>) {\n             match set {\n-                SubPatSet::Full => bug!(),\n-                SubPatSet::Empty => {}\n+                SubPatSet::Empty => bug!(),\n+                SubPatSet::Full => {}\n                 SubPatSet::Seq { subpats } => {\n                     for (_, sub_set) in subpats {\n                         fill_spans(sub_set, spans);\n@@ -747,8 +761,9 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n                 SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n                     let expanded = pat.expand_or_pat();\n                     for i in 0..*alt_count {\n-                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Full);\n-                        if sub_set.is_full() {\n+                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n+                        if sub_set.is_empty() {\n+                            // Found a unreachable subpattern.\n                             spans.push(expanded[i].span);\n                         } else {\n                             fill_spans(sub_set, spans);\n@@ -758,10 +773,11 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n             }\n         }\n \n-        if self.is_full() {\n+        if self.is_empty() {\n             return None;\n         }\n-        if self.is_empty() {\n+        if self.is_full() {\n+            // No subpatterns are unreachable.\n             return Some(Vec::new());\n         }\n         let mut spans = Vec::new();\n@@ -790,6 +806,7 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n                         new_subpats.insert(i - arity + 1, sub_set);\n                     }\n                 }\n+                // If `new_subpats_first_col` has no entries it counts as full, so we can omit it.\n                 if !new_subpats_first_col.is_empty() {\n                     new_subpats.insert(0, Seq { subpats: new_subpats_first_col });\n                 }\n@@ -802,54 +819,58 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n     /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n     /// running `unspecialize` it will refer to the original patstack before splitting.\n     ///\n-    /// This case is subtle. Consider:\n+    /// For example:\n     /// ```\n     /// match Some(true) {\n     ///     Some(true) => {}\n     ///     None | Some(true | false) => {}\n     /// }\n     /// ```\n-    /// Imagine we naively preserved the sets of unreachable subpatterns. Here `None` would return\n-    /// the empty set and `Some(true | false)` would return the set containing `true`. Intersecting\n-    /// those two would return the empty set, so we'd miss that the last `true` is unreachable.\n-    /// To fix that, when specializing a given alternative of an or-pattern, we consider all other\n-    /// alternatives as unreachable. That way, intersecting the results will not unduly discard\n-    /// unreachable subpatterns coming from the other alternatives. This is what this function does\n-    /// (remember that missing entries in the `Alt` case count as full; in other words alternatives\n-    /// other than `alt_id` count as unreachable).\n+    /// Here `None` would return the full set and `Some(true | false)` would return the set\n+    /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n+    /// This is what this function does.\n     fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n         use SubPatSet::*;\n-        if self.is_full() {\n-            return Full;\n+        if self.is_empty() {\n+            return Empty;\n         }\n \n+        // Subpatterns coming from inside the or-pattern alternative itself, e.g. in `None | Some(0\n+        // | 1)`.\n         let set_first_col = match &mut self {\n-            Empty => Empty,\n-            Seq { subpats } => subpats.remove(&0).unwrap_or(Empty),\n-            Full => unreachable!(),\n+            Full => Full,\n+            Seq { subpats } => subpats.remove(&0).unwrap_or(Full),\n+            Empty => unreachable!(),\n             Alt { .. } => bug!(), // `self` is a patstack\n         };\n         let mut subpats_first_col = FxHashMap::default();\n         subpats_first_col.insert(alt_id, set_first_col);\n         let set_first_col = Alt { subpats: subpats_first_col, pat, alt_count };\n \n         let mut subpats = match self {\n-            Empty => FxHashMap::default(),\n+            Full => FxHashMap::default(),\n             Seq { subpats } => subpats,\n-            Full => unreachable!(),\n+            Empty => unreachable!(),\n             Alt { .. } => bug!(), // `self` is a patstack\n         };\n         subpats.insert(0, set_first_col);\n         Seq { subpats }\n     }\n }\n \n+/// This carries the results of computing usefulness, as described at the top of the file. When\n+/// checking usefulness of a match branch, we use the `NoWitnesses` variant, which also keeps track\n+/// of potential unreachable sub-patterns (in the presence of or-patterns). When checking\n+/// exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of\n+/// witnesses of non-exhaustiveness when there are any.\n+/// Which variant to use is dictated by `WitnessPreference`.\n #[derive(Clone, Debug)]\n enum Usefulness<'p, 'tcx> {\n-    /// Carries a set of subpatterns that have been found to be unreachable. If full, this\n-    /// indicates the whole pattern is unreachable. If not, this indicates that the pattern is\n-    /// reachable but has some unreachable sub-patterns (due to or-patterns). In the absence of\n-    /// or-patterns, this is either `Empty` or `Full`.\n+    /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n+    /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n+    /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n+    /// or-patterns this will always be either `Empty` (the whole pattern is unreachable) or `Full`\n+    /// (the whole pattern is reachable).\n     NoWitnesses(SubPatSet<'p, 'tcx>),\n     /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n     /// pattern is unreachable.\n@@ -860,13 +881,13 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => WithWitnesses(vec![Witness(vec![])]),\n-            LeaveOutWitness => NoWitnesses(SubPatSet::empty()),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::full()),\n         }\n     }\n     fn new_not_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => WithWitnesses(vec![]),\n-            LeaveOutWitness => NoWitnesses(SubPatSet::full()),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::empty()),\n         }\n     }\n \n@@ -876,7 +897,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n             (WithWitnesses(_), WithWitnesses(o)) if o.is_empty() => {}\n             (WithWitnesses(s), WithWitnesses(o)) if s.is_empty() => *self = WithWitnesses(o),\n             (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n-            (NoWitnesses(s), NoWitnesses(o)) => s.intersect(o),\n+            (NoWitnesses(s), NoWitnesses(o)) => s.union(o),\n             _ => unreachable!(),\n         }\n     }\n@@ -888,8 +909,8 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n         for u in usefulnesses {\n             ret.extend(u);\n             if let NoWitnesses(subpats) = &ret {\n-                if subpats.is_empty() {\n-                    // Once we reach the empty set, more intersections won't change the result.\n+                if subpats.is_full() {\n+                    // Once we reach the full set, more unions won't change the result.\n                     return ret;\n                 }\n             }\n@@ -1098,8 +1119,7 @@ fn is_useful<'p, 'tcx>(\n         let v_head = v.head();\n         let vs: Vec<_> = v.expand_or_pat().collect();\n         let alt_count = vs.len();\n-        // We expand the or pattern, trying each of its branches in turn and keeping careful track\n-        // of possible unreachable sub-branches.\n+        // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n         let usefulnesses = vs.into_iter().enumerate().map(|(i, v)| {\n             let usefulness =\n@@ -1155,11 +1175,14 @@ crate struct MatchArm<'p, 'tcx> {\n     crate has_guard: bool,\n }\n \n+/// Indicates whether or not a given arm is reachable.\n #[derive(Clone, Debug)]\n crate enum Reachability {\n-    /// Potentially carries a set of sub-branches that have been found to be unreachable. Used only\n-    /// in the presence of or-patterns, otherwise it stays empty.\n+    /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n+    /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n+    /// of or-patterns, otherwise it stays empty.\n     Reachable(Vec<Span>),\n+    /// The arm is unreachable.\n     Unreachable,\n }\n \n@@ -1195,8 +1218,10 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n                 matrix.push(v);\n             }\n             let reachability = match usefulness {\n-                NoWitnesses(subpats) if subpats.is_full() => Reachability::Unreachable,\n-                NoWitnesses(subpats) => Reachability::Reachable(subpats.to_spans().unwrap()),\n+                NoWitnesses(subpats) if subpats.is_empty() => Reachability::Unreachable,\n+                NoWitnesses(subpats) => {\n+                    Reachability::Reachable(subpats.list_unreachable_spans().unwrap())\n+                }\n                 WithWitnesses(..) => bug!(),\n             };\n             (arm, reachability)"}]}