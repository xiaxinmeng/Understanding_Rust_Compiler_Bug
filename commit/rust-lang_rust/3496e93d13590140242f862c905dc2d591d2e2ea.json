{"sha": "3496e93d13590140242f862c905dc2d591d2e2ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0OTZlOTNkMTM1OTAxNDAyNDJmODYyYzkwNWRjMmQ1OTFkMmUyZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-15T04:51:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-15T04:51:26Z"}, "message": "auto merge of #12274 : brson/rust/mkfiles, r=alexcrichton\n\nI've been working on binary installers and ended up taking this detour, which does a few things:\r\n\r\n* It expands the documentation on the build system with new comments in Makefile.in\r\n* It displays some of that documentation via `make help`\r\n* Removes some unused and broken snapshot code\r\n* Adds `NO_MKFILE_DEPS` to convenience makefile hacking\r\n* Moves almost all of Makefile.in to files in `mk/`\r\n\r\nThe documentation provided by `make help` and its implementation are somewhat quirky.", "tree": {"sha": "a36c0589da644fa83d243a85ebc88214da4799e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a36c0589da644fa83d243a85ebc88214da4799e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3496e93d13590140242f862c905dc2d591d2e2ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3496e93d13590140242f862c905dc2d591d2e2ea", "html_url": "https://github.com/rust-lang/rust/commit/3496e93d13590140242f862c905dc2d591d2e2ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3496e93d13590140242f862c905dc2d591d2e2ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0bad904a1b53c5c5972e24edd79a96a1d442576", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0bad904a1b53c5c5972e24edd79a96a1d442576", "html_url": "https://github.com/rust-lang/rust/commit/f0bad904a1b53c5c5972e24edd79a96a1d442576"}, {"sha": "8d4b675ced48d3382382a4940dad20615347c29e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d4b675ced48d3382382a4940dad20615347c29e", "html_url": "https://github.com/rust-lang/rust/commit/8d4b675ced48d3382382a4940dad20615347c29e"}], "stats": {"total": 1156, "additions": 671, "deletions": 485}, "files": [{"sha": "ba1879a771327fb8f97cb4a369b02eef80b82a65", "filename": "Makefile.in", "status": "modified", "additions": 134, "deletions": 479, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/3496e93d13590140242f862c905dc2d591d2e2ea/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/3496e93d13590140242f862c905dc2d591d2e2ea/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=3496e93d13590140242f862c905dc2d591d2e2ea", "patch": "@@ -8,7 +8,112 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-# An explanation of how the build is structured:\n+# <help> \\(^o^)/\n+#\n+# Greetings, adventurer! The Rust Build System is at your service.\n+#\n+# Whether you want a genuine copy of `rustc`, access to the latest and\n+# most authoritative Rust documentation, or even to investigate the\n+# most intimate workings of the compiler itself, you've come to the\n+# right place. Let's see what's on the menu.\n+#\n+# First, start with one of these build targets:\n+#\n+#   * all - The default. Builds a complete, bootstrapped compiler.\n+#           `rustc` will be in `${target-triple}/stage2/bin/`. Run it\n+#           directly from the build directory if you like. This also\n+#           comes with docs in `doc/`.\n+#\n+#   * check - Run the complete test suite\n+#\n+#   * install - Install Rust. Note that installation is not necessary\n+#               to use the compiler.\n+#\n+#   * uninstall - Uninstall the binaries\n+#\n+# For tips on working with The Rust Build System, just:\n+#\n+#     run `make tips`\n+#\n+# Otherwise\n+#\n+#     run `make`\n+#\n+# </help>\n+#\n+# <tips>\n+#\n+# # The Rust Build System Tip Line\n+#\n+# There are a bazillion different targets you might want to build. Here\n+# are a few ideas.\n+#\n+#   * docs - Build gobs of HTML documentation and put it into `doc/`\n+#   * check-$(crate) - Test a crate, e.g. `check-std`\n+#   * check-ref - Run the language reference tests\n+#   * check-docs - Test the documentation examples\n+#   * check-stage$(stage)-$(crate) - Test a crate in a specific stage\n+#   * check-stage$(stage)-{rpass,rfail,cfail,rmake,...} - Run tests in src/test/\n+#   * check-stage1-T-$(target)-H-$(host) - Run cross-compiled-tests\n+#\n+# Then mix in some of these environment variables to harness the\n+# ultimate power of The Rust Build System.\n+#\n+#   * `VERBOSE=1` - Print all commands. Use this to see what's going on.\n+#   * `RUSTFLAGS=...` - Add compiler flags to all `rustc` invocations\n+#\n+#   * `TESTNAME=...` - Specify the name of tests to run\n+#   * `CHECK_IGNORED=1` - Run normally-ignored tests\n+#   * `NO_BENCH=1` - Don't run crate benchmarks (disable `--bench` flag)\n+#\n+#   * `CFG_ENABLE_VALGRIND=1` - Run tests under valgrind\n+#   * `VALGRIND_COMPILE=1` - Run the compiler itself under valgrind\n+#                            (may require `CFG_ENABLE_VALGRIND`)\n+#\n+#   * `NO_REBUILD=1` - Don't rebootstrap when testing std\n+#                      (and possibly other crates)\n+#   * `NO_MKFILE_DEPS=1` - Don't rebuild for modified .mk files\n+#\n+#   * `SAVE_TEMPS=1` - Use `--save-temps` flag on all `rustc` invocations\n+#   * `ASM_COMMENTS=1` - Use `-Z asm-comments`\n+#   * `TIME_PASSES=1` - Use `-Z time-passes`\n+#   * `TIME_LLVM_PASSES=1` - Use `-Z time-llvm-passes`\n+#   * `TRACE=1` - Use `-Z trace`\n+#\n+# # Rust recipes for build system success\n+#\n+#     // Modifying libstd? Use this comment to run unit tests just on your change\n+#     make check-stage1-std NO_REBUILD=1 NO_BENCH=1\n+#\n+#     // Added a run-pass test? Use this to test running your test\n+#     make check-stage1-rpass TESTNAME=my-shiny-new-test\n+#\n+#     // Having trouble figuring out which test is failing? Turn off parallel tests\n+#     make check-stage1-std RUST_TEST_TASKS=1\n+#\n+# This is hardly all there is to know of The Rust Build System's\n+# mysteries. The tale continues on the wiki[1][2].\n+#\n+# [1]: https://github.com/mozilla/rust/wiki/Note-build-system\n+# [2]: https://github.com/mozilla/rust/wiki/Note-testsuite\n+#\n+# If you really feel like getting your hands dirty, then:\n+#\n+#     run `make nitty-gritty`\n+#\n+# </tips>\n+#\n+# <nittygritty>\n+#\n+# # The Rust Build System\n+#\n+# Gosh I wish there was something useful here (TODO).\n+#\n+# # An (old) explanation of how the build is structured:\n+#\n+# *Note: Hey, like, this is probably inaccurate, and is definitely\n+# an outdated and insufficient explanation of the remarkable\n+# Rust Build System.*\n #\n # There are multiple build stages (0-3) needed to verify that the\n # compiler is properly self-hosting. Each stage is divided between\n@@ -51,505 +156,49 @@\n # will just link against the libraries in the target lib directory.\n #\n # Admittedly this is a little convoluted.\n-\n-STAGES = 0 1 2 3\n-\n-######################################################################\n-# Residual auto-configuration\n-######################################################################\n-\n-# Recursive wildcard function\n-# http://blog.jgc.org/2011/07/gnu-make-recursive-wildcard-function.html\n-rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) \\\n-  $(filter $(subst *,%,$2),$d))\n-\n-include config.mk\n-\n-# We track all of the object files we might build so that we can find\n-# and include all of the .d files in one fell swoop.\n-ALL_OBJ_FILES :=\n-\n-MKFILE_DEPS := config.stamp $(call rwildcard,$(CFG_SRC_DIR)mk/,*)\n-NON_BUILD_HOST = $(filter-out $(CFG_BUILD),$(CFG_HOST))\n-NON_BUILD_TARGET = $(filter-out $(CFG_BUILD),$(CFG_TARGET))\n-\n-ifneq ($(MAKE_RESTARTS),)\n-CFG_INFO := $(info cfg: make restarts: $(MAKE_RESTARTS))\n-endif\n-\n-CFG_INFO := $(info cfg: build triple $(CFG_BUILD))\n-CFG_INFO := $(info cfg: host triples $(CFG_HOST))\n-CFG_INFO := $(info cfg: target triples $(CFG_TARGET))\n-\n-ifneq ($(wildcard $(NON_BUILD_HOST)),)\n-CFG_INFO := $(info cfg: non-build host triples $(NON_BUILD_HOST))\n-endif\n-ifneq ($(wildcard $(NON_BUILD_TARGET)),)\n-CFG_INFO := $(info cfg: non-build target triples $(NON_BUILD_TARGET))\n-endif\n-\n-CFG_RUSTC_FLAGS := $(RUSTFLAGS)\n-CFG_GCCISH_CFLAGS :=\n-CFG_GCCISH_LINK_FLAGS :=\n-\n-ifdef CFG_DISABLE_OPTIMIZE\n-  $(info cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE))\n-  CFG_RUSTC_FLAGS +=\n-else\n-  # The rtopt cfg turns off runtime sanity checks\n-  CFG_RUSTC_FLAGS += -O --cfg rtopt\n-endif\n-\n-ifdef CFG_DISABLE_DEBUG\n-  CFG_RUSTC_FLAGS += --cfg ndebug\n-  CFG_GCCISH_CFLAGS += -DRUST_NDEBUG\n-else\n-  $(info cfg: enabling more debugging (CFG_ENABLE_DEBUG))\n-  CFG_RUSTC_FLAGS += --cfg debug\n-  CFG_GCCISH_CFLAGS += -DRUST_DEBUG\n-endif\n-\n-ifdef SAVE_TEMPS\n-  CFG_RUSTC_FLAGS += --save-temps\n-endif\n-ifdef ASM_COMMENTS\n-  CFG_RUSTC_FLAGS += -Z asm-comments\n-endif\n-ifdef TIME_PASSES\n-  CFG_RUSTC_FLAGS += -Z time-passes\n-endif\n-ifdef TIME_LLVM_PASSES\n-  CFG_RUSTC_FLAGS += -Z time-llvm-passes\n-endif\n-ifdef TRACE\n-  CFG_RUSTC_FLAGS += -Z trace\n-endif\n-ifdef CFG_DISABLE_RPATH\n-CFG_RUSTC_FLAGS += -C no-rpath\n-endif\n-\n-# The executables crated during this compilation process have no need to include\n-# static copies of libstd and libextra. We also generate dynamic versions of all\n-# libraries, so in the interest of space, prefer dynamic linking throughout the\n-# compilation process.\n-#\n-# Note though that these flags are omitted for stage2+. This means that the\n-# snapshot will be generated with a statically linked rustc so we only have to\n-# worry about the distribution of one file (with its native dynamic\n-# dependencies)\n-RUSTFLAGS_STAGE0 += -C prefer-dynamic\n-RUSTFLAGS_STAGE1 += -C prefer-dynamic\n-\n-# platform-specific auto-configuration\n-include $(CFG_SRC_DIR)mk/platform.mk\n-\n-# Run the stage1/2 compilers under valgrind\n-ifdef VALGRIND_COMPILE\n-  CFG_VALGRIND_COMPILE :=$(CFG_VALGRIND)\n-else\n-  CFG_VALGRIND_COMPILE :=\n-endif\n-\n-# version-string calculation\n-CFG_GIT_DIR := $(CFG_SRC_DIR).git\n-CFG_RELEASE = 0.10-pre\n-CFG_VERSION = $(CFG_RELEASE)\n-# windows exe's need numeric versions - don't use anything but\n-# numbers and dots here\n-CFG_VERSION_WIN = 0.10\n-\n-# since $(CFG_GIT) may contain spaces (especially on Windows),\n-# we need to escape them. (\" \" to r\"\\ \")\n-# Note that $(subst ...) ignores space after `subst`,\n-# so we use a hack: define $(SPACE) which contains space character.\n-SPACE :=\n-SPACE +=\n-ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT))),)\n-ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT_DIR))),)\n-    CFG_VERSION += $(shell git --git-dir='$(CFG_GIT_DIR)' log -1 \\\n-                     --pretty=format:'(%h %ci)')\n-    CFG_VER_HASH = $(shell git --git-dir='$(CFG_GIT_DIR)' rev-parse HEAD)\n-endif\n-endif\n-\n-ifdef CFG_ENABLE_VALGRIND\n-  $(info cfg: enabling valgrind (CFG_ENABLE_VALGRIND))\n-else\n-  CFG_VALGRIND :=\n-endif\n-ifdef CFG_BAD_VALGRIND\n-  $(info cfg: disabling valgrind due to its unreliability on this platform)\n-  CFG_VALGRIND :=\n-endif\n-\n-\n-######################################################################\n-# Target-and-rule \"utility variables\"\n-######################################################################\n-\n-ifdef VERBOSE\n-  Q :=\n-  E =\n-else\n-  Q := @\n-  E = echo $(1)\n-endif\n-\n-S := $(CFG_SRC_DIR)\n-\n-define DEF_X\n-X_$(1) := $(CFG_EXE_SUFFIX_$(1))\n-endef\n-$(foreach target,$(CFG_TARGET),\\\n-  $(eval $(call DEF_X,$(target))))\n-\n-# \"Source\" files we generate in builddir along the way.\n-GENERATED :=\n-\n-# Delete the built-in rules.\n-.SUFFIXES:\n-%:: %,v\n-%:: RCS/%,v\n-%:: RCS/%\n-%:: s.%\n-%:: SCCS/s.%\n-\n-\n-######################################################################\n-# Cleaning out old crates\n-######################################################################\n-\n-# $(1) is the path for directory to match against\n-# $(2) is the glob to use in the match\n-#\n-# Note that a common bug is to accidentally construct the glob denoted\n-# by $(2) with a space character prefix, which invalidates the\n-# construction $(1)$(2).\n-define CHECK_FOR_OLD_GLOB_MATCHES\n-  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: there are previous\" \\'$(notdir $(2))\\' \"libraries:\" $$MATCHES; fi\n-endef\n-\n-# Same interface as above, but deletes rather than just listing the files.\n-ifdef VERBOSE\n-define REMOVE_ALL_OLD_GLOB_MATCHES\n-  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: removing previous\" \\'$(notdir $(1))\\' \"libraries:\" $$MATCHES; rm $$MATCHES ; fi\n-endef\n-else\n-define REMOVE_ALL_OLD_GLOB_MATCHES\n-  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then rm $$MATCHES ; fi\n-endef\n-endif\n-\n-# We use a different strategy for LIST_ALL_OLD_GLOB_MATCHES_EXCEPT\n-# than in the macros above because it needs the result of running the\n-# `ls` command after other rules in the command list have run; the\n-# macro-expander for $(wildcard ...) would deliver its results too\n-# soon. (This is in contrast to the macros above, which are meant to\n-# be run at the outset of a command list in a rule.)\n-ifdef VERBOSE\n-define LIST_ALL_OLD_GLOB_MATCHES\n-  @echo \"info: now are following matches for\" '$(notdir $(1))' \"libraries:\"\n-  @( ls $(1) 2>/dev/null || true )\n-endef\n-else\n-define LIST_ALL_OLD_GLOB_MATCHES\n-endef\n-endif\n-\n-######################################################################\n-# LLVM macros\n-######################################################################\n-\n-# FIXME: x86-ism\n-LLVM_COMPONENTS=x86 arm mips ipo bitreader bitwriter linker asmparser jit mcjit \\\n-                interpreter instrumentation\n-\n-# Only build these LLVM tools\n-LLVM_TOOLS=bugpoint llc llvm-ar llvm-as llvm-dis llvm-mc opt llvm-extract\n-\n-define DEF_LLVM_VARS\n-# The configure script defines these variables with the target triples\n-# separated by Z. This defines new ones with the expected format.\n-CFG_LLVM_BUILD_DIR_$(1):=$$(CFG_LLVM_BUILD_DIR_$(subst -,_,$(1)))\n-CFG_LLVM_INST_DIR_$(1):=$$(CFG_LLVM_INST_DIR_$(subst -,_,$(1)))\n-\n-# Any rules that depend on LLVM should depend on LLVM_CONFIG\n-LLVM_CONFIG_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-config$$(X_$(1))\n-LLVM_MC_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-mc$$(X_$(1))\n-LLVM_VERSION_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --version)\n-LLVM_BINDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --bindir)\n-LLVM_INCDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --includedir)\n-LLVM_LIBDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libdir)\n-LLVM_LIBS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libs $$(LLVM_COMPONENTS))\n-LLVM_LDFLAGS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --ldflags)\n-# On FreeBSD, it may search wrong headers (that are for pre-installed LLVM),\n-# so we replace -I with -iquote to ensure that it searches bundled LLVM first.\n-LLVM_CXXFLAGS_$(1)=$$(subst -I, -iquote , $$(shell \"$$(LLVM_CONFIG_$(1))\" --cxxflags))\n-LLVM_HOST_TRIPLE_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --host-target)\n-\n-LLVM_AS_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-as$$(X_$(1))\n-LLC_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llc$$(X_$(1))\n-\n-endef\n-\n-$(foreach host,$(CFG_HOST), \\\n- $(eval $(call DEF_LLVM_VARS,$(host))))\n-\n-######################################################################\n-# Exports for sub-utilities\n-######################################################################\n-\n-# Note that any variable that re-configure should pick up needs to be\n-# exported\n-\n-export CFG_SRC_DIR\n-export CFG_BUILD_DIR\n-export CFG_VERSION\n-export CFG_VERSION_WIN\n-export CFG_RELEASE\n-export CFG_BUILD\n-export CFG_LLVM_ROOT\n-export CFG_ENABLE_MINGW_CROSS\n-export CFG_PREFIX\n-export CFG_LIBDIR\n-export CFG_RUSTLIBDIR\n-export CFG_LIBDIR_RELATIVE\n-export CFG_DISABLE_INJECT_STD_VERSION\n-\n-######################################################################\n-# Per-stage targets and runner\n-######################################################################\n-\n-include $(CFG_SRC_DIR)mk/crates.mk\n-\n-define SREQ\n-# $(1) is the stage number\n-# $(2) is the target triple\n-# $(3) is the host triple\n-\n-# Destinations of artifacts for the host compiler\n-HROOT$(1)_H_$(3) = $(3)/stage$(1)\n-HBIN$(1)_H_$(3) = $$(HROOT$(1)_H_$(3))/bin\n-HLIB$(1)_H_$(3) = $$(HROOT$(1)_H_$(3))/$$(CFG_LIBDIR_RELATIVE)\n-\n-# Destinations of artifacts for target architectures\n-TROOT$(1)_T_$(2)_H_$(3) = $$(HLIB$(1)_H_$(3))/$$(CFG_RUSTLIBDIR)/$(2)\n-TBIN$(1)_T_$(2)_H_$(3) = $$(TROOT$(1)_T_$(2)_H_$(3))/bin\n-TLIB$(1)_T_$(2)_H_$(3) = $$(TROOT$(1)_T_$(2)_H_$(3))/lib\n-\n-# Preqrequisites for using the stageN compiler\n-ifeq ($(1),0)\n-HSREQ$(1)_H_$(3) = $$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\n-else\n-HSREQ$(1)_H_$(3) = \\\n-\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) \\\n-\t$$(HLIB$(1)_H_$(3))/stamp.rustc \\\n-\t$$(foreach dep,$$(RUST_DEPS_rustc),$$(HLIB$(1)_H_$(3))/stamp.$$(dep)) \\\n-\t$$(MKFILE_DEPS)\n-endif\n-\n-# Prerequisites for using the stageN compiler to build target artifacts\n-TSREQ$(1)_T_$(2)_H_$(3) = \\\n-\t$$(HSREQ$(1)_H_$(3)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n-\n-# Prerequisites for a working stageN compiler and libraries, for a specific\n-# target\n-SREQ$(1)_T_$(2)_H_$(3) = \\\n-\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t$$(foreach dep,$$(TARGET_CRATES),\\\n-\t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep))\n-\n-# Prerequisites for a working stageN compiler and complete set of target\n-# libraries\n-CSREQ$(1)_T_$(2)_H_$(3) = \\\n-\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n-\t$$(foreach dep,$$(CRATES),$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n-\t$$(foreach dep,$$(HOST_CRATES),$$(HLIB$(1)_H_$(3))/stamp.$$(dep))\n-\n-ifeq ($(1),0)\n-# Don't run the the stage0 compiler under valgrind - that ship has sailed\n-CFG_VALGRIND_COMPILE$(1) =\n-else\n-CFG_VALGRIND_COMPILE$(1) = $$(CFG_VALGRIND_COMPILE)\n-endif\n-\n-# Add RUSTFLAGS_STAGEN values to the build command\n-EXTRAFLAGS_STAGE$(1) = $$(RUSTFLAGS_STAGE$(1))\n-\n-CFGFLAG$(1)_T_$(2)_H_$(3) = stage$(1)\n-\n-# Pass --cfg stage0 only for the build->host part of stage0;\n-# if you're building a cross config, the host->* parts are\n-# effectively stage1, since it uses the just-built stage0.\n-ifeq ($(1),0)\n-ifneq ($(strip $(CFG_BUILD)),$(strip $(3)))\n-CFGFLAG$(1)_T_$(2)_H_$(3) = stage1\n-endif\n-endif\n-\n-ifdef CFG_DISABLE_RPATH\n-ifeq ($$(OSTYPE_$(3)),apple-darwin)\n-  RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n-      DYLD_LIBRARY_PATH=\"$$$$DYLD_LIBRARY_PATH:$$(HLIB$(1)_H_$(3))\"\n-else\n-  RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n-      LD_LIBRARY_PATH=\"$$$$LD_LIBRARY_PATH:$$(HLIB$(1)_H_$(3))\"\n-endif\n-else\n-    RPATH_VAR$(1)_T_$(2)_H_$(3) :=\n-endif\n-\n-STAGE$(1)_T_$(2)_H_$(3) := \t\t\t\t\t\t\\\n-\t$$(Q)$$(RPATH_VAR$(1)_T_$(2)_H_$(3))                            \\\n-\t\t$$(call CFG_RUN_TARG_$(3),$(1),\t\t\t\t\\\n-\t\t$$(CFG_VALGRIND_COMPILE$(1))\t\t\t\t\\\n-\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\t\t\t\\\n-\t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3))\t\t\t\\\n-\t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\\n-                $$(RUSTC_FLAGS_$(2))\n-\n-PERF_STAGE$(1)_T_$(2)_H_$(3) :=\t\t\t\t\t\t\\\n-\t$$(Q)$$(call CFG_RUN_TARG_$(3),$(1),\t\t\t\t\\\n-\t\t$$(CFG_PERF_TOOL) \t\t\t\t\t\\\n-\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\t\t\t\\\n-\t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3))\t\t\t\\\n-\t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\\n-                $$(RUSTC_FLAGS_$(2))\n-\n-endef\n-\n-$(foreach build,$(CFG_HOST), \\\n- $(eval $(foreach target,$(CFG_TARGET), \\\n-  $(eval $(foreach stage,$(STAGES), \\\n-   $(eval $(call SREQ,$(stage),$(target),$(build))))))))\n-\n-######################################################################\n-# rustc-H-targets\n #\n-# Builds a functional Rustc for the given host.\n-######################################################################\n-\n-define DEF_RUSTC_STAGE_TARGET\n-# $(1) == architecture\n-# $(2) == stage\n-\n-rustc-stage$(2)-H-$(1):\t\t\t\t\t\t\t\\\n-\t$$(foreach target,$$(CFG_TARGET),$$(SREQ$(2)_T_$$(target)_H_$(1)))\n-\n-endef\n-\n-$(foreach host,$(CFG_HOST),\t\t\t\t\t\t\\\n- $(eval $(foreach stage,1 2 3,\t\t\t\t\t\t\\\n-  $(eval $(call DEF_RUSTC_STAGE_TARGET,$(host),$(stage))))))\n-\n-rustc-stage1: rustc-stage1-H-$(CFG_BUILD)\n-rustc-stage2: rustc-stage2-H-$(CFG_BUILD)\n-rustc-stage3: rustc-stage3-H-$(CFG_BUILD)\n-\n-define DEF_RUSTC_TARGET\n-# $(1) == architecture\n-\n-rustc-H-$(1): rustc-stage2-H-$(1)\n-endef\n-\n-$(foreach host,$(CFG_TARGET),\t\t\t\\\n- $(eval $(call DEF_RUSTC_TARGET,$(host))))\n-\n-rustc-stage1: rustc-stage1-H-$(CFG_BUILD)\n-rustc-stage2: rustc-stage2-H-$(CFG_BUILD)\n-rustc-stage3: rustc-stage3-H-$(CFG_BUILD)\n-rustc: rustc-H-$(CFG_BUILD)\n-\n-rustc-H-all: $(foreach host,$(CFG_HOST),rustc-H-$(host))\n-\n-######################################################################\n-# Entrypoint rule\n-######################################################################\n-\n-.DEFAULT_GOAL := all\n-\n-ifneq ($(CFG_IN_TRANSITION),)\n-\n-CFG_INFO := $(info cfg:)\n-CFG_INFO := $(info cfg: *** compiler is in snapshot transition ***)\n-CFG_INFO := $(info cfg: *** stage2 and later will not be built ***)\n-CFG_INFO := $(info cfg:)\n-\n-#FIXME This is surely busted\n-all: $(SREQ1$(CFG_BUILD)) $(GENERATED) docs\n-\n-else\n-\n-define ALL_TARGET_N\n-ifneq ($$(findstring $(1),$$(CFG_HOST)),)\n-# This is a host\n-all-target-$(1)-host-$(2): $$(CSREQ2_T_$(1)_H_$(2))\n-else\n-# This is a target only\n-all-target-$(1)-host-$(2): $$(SREQ2_T_$(1)_H_$(2))\n-endif\n-endef\n-\n-$(foreach target,$(CFG_TARGET), \\\n- $(foreach host,$(CFG_HOST), \\\n- $(eval $(call ALL_TARGET_N,$(target),$(host)))))\n-\n-ALL_TARGET_RULES = $(foreach target,$(CFG_TARGET), \\\n-\t$(foreach host,$(CFG_HOST), \\\n- all-target-$(target)-host-$(host)))\n-\n-all: $(ALL_TARGET_RULES) $(GENERATED) docs\n-\n-endif\n-\n-\n-######################################################################\n-# Re-configuration\n-######################################################################\n-\n-ifndef CFG_DISABLE_MANAGE_SUBMODULES\n-# This is a pretty expensive operation but I don't see any way to avoid it\n-NEED_GIT_RECONFIG=$(shell cd \"$(CFG_SRC_DIR)\" && \"$(CFG_GIT)\" submodule status | grep -c '^\\(+\\|-\\)')\n-else\n-NEED_GIT_RECONFIG=0\n-endif\n-\n-ifeq ($(NEED_GIT_RECONFIG),0)\n-else\n-# If the submodules have changed then always execute config.mk\n-.PHONY: config.stamp\n-endif\n-\n-Makefile config.mk: config.stamp\n-\n-config.stamp: $(S)configure $(S)Makefile.in $(S)src/snapshots.txt\n-\t@$(call E, cfg: reconfiguring)\n-\t$(Q)$(S)configure $(CFG_CONFIGURE_ARGS)\n-\n+# </nittygritty>\n+#\n \n ######################################################################\n-# Primary-target makefiles\n+# Primary rules\n ######################################################################\n \n # Issue #9531: If you change the order of any of the following (or add\n # new definitions), make sure definitions always precede their uses,\n # especially for the dependency lists of recipes.\n \n+# First, load the variables exported by the configure script\n+include config.mk\n+\n+# Just a few macros used everywhere\n+include $(CFG_SRC_DIR)mk/util.mk\n+# All crates and their dependencies\n+include $(CFG_SRC_DIR)mk/crates.mk\n+# Reconfiguring when the makefiles or submodules change\n+include $(CFG_SRC_DIR)mk/reconfig.mk\n+# Various bits of setup, common macros, and top-level rules\n+include $(CFG_SRC_DIR)mk/main.mk\n+# C and assembly components that are not LLVM\n include $(CFG_SRC_DIR)mk/rt.mk\n+# Rules for crates in the target directories\n include $(CFG_SRC_DIR)mk/target.mk\n+# Rules for crates in the host directories\n include $(CFG_SRC_DIR)mk/host.mk\n+# Special rules for bootstrapping stage0\n include $(CFG_SRC_DIR)mk/stage0.mk\n+# Rust-specific LLVM extensions\n include $(CFG_SRC_DIR)mk/rustllvm.mk\n+# Documentation\n include $(CFG_SRC_DIR)mk/docs.mk\n+# LLVM\n include $(CFG_SRC_DIR)mk/llvm.mk\n \n ######################################################################\n # Secondary makefiles, conditionalized for speed\n ######################################################################\n \n+# Source and binary distribution artifacts\n ifneq ($(strip $(findstring dist,$(MAKECMDGOALS))   \\\n                $(findstring check,$(MAKECMDGOALS))  \\\n                $(findstring test,$(MAKECMDGOALS))   \\\n@@ -559,12 +208,14 @@ ifneq ($(strip $(findstring dist,$(MAKECMDGOALS))   \\\n   include $(CFG_SRC_DIR)mk/dist.mk\n endif\n \n+# Binary snapshots\n ifneq ($(strip $(findstring snap,$(MAKECMDGOALS))   \\\n                $(findstring clean,$(MAKECMDGOALS))),)\n   CFG_INFO := $(info cfg: including snap rules)\n   include $(CFG_SRC_DIR)mk/snap.mk\n endif\n \n+# The test suite\n ifneq ($(strip $(findstring check,$(MAKECMDGOALS)) \\\n                $(findstring test,$(MAKECMDGOALS))  \\\n                $(findstring perf,$(MAKECMDGOALS))  \\\n@@ -573,21 +224,25 @@ ifneq ($(strip $(findstring check,$(MAKECMDGOALS)) \\\n   include $(CFG_SRC_DIR)mk/tests.mk\n endif\n \n+# Performance and benchmarking\n ifneq ($(findstring perf,$(MAKECMDGOALS)),)\n   CFG_INFO := $(info cfg: including perf rules)\n   include $(CFG_SRC_DIR)mk/perf.mk\n endif\n \n+# Cleaning\n ifneq ($(findstring clean,$(MAKECMDGOALS)),)\n   CFG_INFO := $(info cfg: including clean rules)\n   include $(CFG_SRC_DIR)mk/clean.mk\n endif\n \n+# Installation from the build directory\n ifneq ($(findstring install,$(MAKECMDGOALS)),)\n   CFG_INFO := $(info cfg: including install rules)\n   include $(CFG_SRC_DIR)mk/install.mk\n endif\n \n+# CTAGS building\n ifneq ($(strip $(findstring TAGS.emacs,$(MAKECMDGOALS)) \\\n                $(findstring TAGS.vi,$(MAKECMDGOALS))),)\n   CFG_INFO := $(info cfg: including ctags rules)"}, {"sha": "75514ada973b49d1c44eba3ec671dc9cfd76ef03", "filename": "configure", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3496e93d13590140242f862c905dc2d591d2e2ea/configure", "raw_url": "https://github.com/rust-lang/rust/raw/3496e93d13590140242f862c905dc2d591d2e2ea/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=3496e93d13590140242f862c905dc2d591d2e2ea", "patch": "@@ -1071,12 +1071,6 @@ then\n     putvar CFG_PANDOC\n fi\n \n-if head -n 1 ${CFG_SRC_DIR}src/snapshots.txt | grep -q '^T'\n-then\n-    CFG_IN_TRANSITION=1\n-    putvar CFG_IN_TRANSITION\n-fi\n-\n # Valgrind is only reliable on Linux. On Windows it doesn't work at all, and\n # on the Mac the dynamic linker causes Valgrind to emit a huge stream of\n # errors.\n@@ -1109,3 +1103,5 @@ rm -f config.tmp\n touch config.stamp\n \n step_msg \"complete\"\n+msg \"run \\`make help\\`\"\n+msg"}, {"sha": "aa5ae77b3ac7780c2ed71b86925e258b4d012779", "filename": "mk/main.mk", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/3496e93d13590140242f862c905dc2d591d2e2ea/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3496e93d13590140242f862c905dc2d591d2e2ea/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=3496e93d13590140242f862c905dc2d591d2e2ea", "patch": "@@ -0,0 +1,458 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+######################################################################\n+# Version numbers and strings\n+######################################################################\n+\n+# The version number\n+CFG_RELEASE = 0.10-pre\n+\n+# The version string plus commit information\n+CFG_VERSION = $(CFG_RELEASE)\n+CFG_GIT_DIR := $(CFG_SRC_DIR).git\n+# since $(CFG_GIT) may contain spaces (especially on Windows),\n+# we need to escape them. (\" \" to r\"\\ \")\n+# Note that $(subst ...) ignores space after `subst`,\n+# so we use a hack: define $(SPACE) which contains space character.\n+SPACE :=\n+SPACE +=\n+ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT))),)\n+ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT_DIR))),)\n+    CFG_VERSION += $(shell git --git-dir='$(CFG_GIT_DIR)' log -1 \\\n+                     --pretty=format:'(%h %ci)')\n+    CFG_VER_HASH = $(shell git --git-dir='$(CFG_GIT_DIR)' rev-parse HEAD)\n+endif\n+endif\n+\n+# windows exe's need numeric versions - don't use anything but\n+# numbers and dots here\n+CFG_VERSION_WIN = $(subst -pre,,$(CFG_RELEASE))\n+\n+\n+######################################################################\n+# More configuration\n+######################################################################\n+\n+# We track all of the object files we might build so that we can find\n+# and include all of the .d files in one fell swoop.\n+ALL_OBJ_FILES :=\n+\n+ifneq ($(NO_MAKEFILE_DEPS),)\n+MKFILE_DEPS :=\n+else\n+MKFILE_DEPS := config.stamp $(call rwildcard,$(CFG_SRC_DIR)mk/,*)\n+endif\n+NON_BUILD_HOST = $(filter-out $(CFG_BUILD),$(CFG_HOST))\n+NON_BUILD_TARGET = $(filter-out $(CFG_BUILD),$(CFG_TARGET))\n+\n+ifneq ($(MAKE_RESTARTS),)\n+CFG_INFO := $(info cfg: make restarts: $(MAKE_RESTARTS))\n+endif\n+\n+CFG_INFO := $(info cfg: build triple $(CFG_BUILD))\n+CFG_INFO := $(info cfg: host triples $(CFG_HOST))\n+CFG_INFO := $(info cfg: target triples $(CFG_TARGET))\n+\n+ifneq ($(wildcard $(NON_BUILD_HOST)),)\n+CFG_INFO := $(info cfg: non-build host triples $(NON_BUILD_HOST))\n+endif\n+ifneq ($(wildcard $(NON_BUILD_TARGET)),)\n+CFG_INFO := $(info cfg: non-build target triples $(NON_BUILD_TARGET))\n+endif\n+\n+CFG_RUSTC_FLAGS := $(RUSTFLAGS)\n+CFG_GCCISH_CFLAGS :=\n+CFG_GCCISH_LINK_FLAGS :=\n+\n+ifdef CFG_DISABLE_OPTIMIZE\n+  $(info cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE))\n+  CFG_RUSTC_FLAGS +=\n+else\n+  # The rtopt cfg turns off runtime sanity checks\n+  CFG_RUSTC_FLAGS += -O --cfg rtopt\n+endif\n+\n+ifdef CFG_DISABLE_DEBUG\n+  CFG_RUSTC_FLAGS += --cfg ndebug\n+  CFG_GCCISH_CFLAGS += -DRUST_NDEBUG\n+else\n+  $(info cfg: enabling more debugging (CFG_ENABLE_DEBUG))\n+  CFG_RUSTC_FLAGS += --cfg debug\n+  CFG_GCCISH_CFLAGS += -DRUST_DEBUG\n+endif\n+\n+ifdef SAVE_TEMPS\n+  CFG_RUSTC_FLAGS += --save-temps\n+endif\n+ifdef ASM_COMMENTS\n+  CFG_RUSTC_FLAGS += -Z asm-comments\n+endif\n+ifdef TIME_PASSES\n+  CFG_RUSTC_FLAGS += -Z time-passes\n+endif\n+ifdef TIME_LLVM_PASSES\n+  CFG_RUSTC_FLAGS += -Z time-llvm-passes\n+endif\n+ifdef TRACE\n+  CFG_RUSTC_FLAGS += -Z trace\n+endif\n+ifdef CFG_DISABLE_RPATH\n+CFG_RUSTC_FLAGS += -C no-rpath\n+endif\n+\n+# The executables crated during this compilation process have no need to include\n+# static copies of libstd and libextra. We also generate dynamic versions of all\n+# libraries, so in the interest of space, prefer dynamic linking throughout the\n+# compilation process.\n+#\n+# Note though that these flags are omitted for stage2+. This means that the\n+# snapshot will be generated with a statically linked rustc so we only have to\n+# worry about the distribution of one file (with its native dynamic\n+# dependencies)\n+RUSTFLAGS_STAGE0 += -C prefer-dynamic\n+RUSTFLAGS_STAGE1 += -C prefer-dynamic\n+\n+# platform-specific auto-configuration\n+include $(CFG_SRC_DIR)mk/platform.mk\n+\n+# Run the stage1/2 compilers under valgrind\n+ifdef VALGRIND_COMPILE\n+  CFG_VALGRIND_COMPILE :=$(CFG_VALGRIND)\n+else\n+  CFG_VALGRIND_COMPILE :=\n+endif\n+\n+ifdef CFG_ENABLE_VALGRIND\n+  $(info cfg: enabling valgrind (CFG_ENABLE_VALGRIND))\n+else\n+  CFG_VALGRIND :=\n+endif\n+ifdef CFG_BAD_VALGRIND\n+  $(info cfg: disabling valgrind due to its unreliability on this platform)\n+  CFG_VALGRIND :=\n+endif\n+\n+\n+######################################################################\n+# Target-and-rule \"utility variables\"\n+######################################################################\n+\n+define DEF_X\n+X_$(1) := $(CFG_EXE_SUFFIX_$(1))\n+endef\n+$(foreach target,$(CFG_TARGET),\\\n+  $(eval $(call DEF_X,$(target))))\n+\n+# \"Source\" files we generate in builddir along the way.\n+GENERATED :=\n+\n+# Delete the built-in rules.\n+.SUFFIXES:\n+%:: %,v\n+%:: RCS/%,v\n+%:: RCS/%\n+%:: s.%\n+%:: SCCS/s.%\n+\n+\n+######################################################################\n+# Cleaning out old crates\n+######################################################################\n+\n+# $(1) is the path for directory to match against\n+# $(2) is the glob to use in the match\n+#\n+# Note that a common bug is to accidentally construct the glob denoted\n+# by $(2) with a space character prefix, which invalidates the\n+# construction $(1)$(2).\n+define CHECK_FOR_OLD_GLOB_MATCHES\n+  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: there are previous\" \\'$(notdir $(2))\\' \"libraries:\" $$MATCHES; fi\n+endef\n+\n+# Same interface as above, but deletes rather than just listing the files.\n+ifdef VERBOSE\n+define REMOVE_ALL_OLD_GLOB_MATCHES\n+  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: removing previous\" \\'$(notdir $(1))\\' \"libraries:\" $$MATCHES; rm $$MATCHES ; fi\n+endef\n+else\n+define REMOVE_ALL_OLD_GLOB_MATCHES\n+  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then rm $$MATCHES ; fi\n+endef\n+endif\n+\n+# We use a different strategy for LIST_ALL_OLD_GLOB_MATCHES_EXCEPT\n+# than in the macros above because it needs the result of running the\n+# `ls` command after other rules in the command list have run; the\n+# macro-expander for $(wildcard ...) would deliver its results too\n+# soon. (This is in contrast to the macros above, which are meant to\n+# be run at the outset of a command list in a rule.)\n+ifdef VERBOSE\n+define LIST_ALL_OLD_GLOB_MATCHES\n+  @echo \"info: now are following matches for\" '$(notdir $(1))' \"libraries:\"\n+  @( ls $(1) 2>/dev/null || true )\n+endef\n+else\n+define LIST_ALL_OLD_GLOB_MATCHES\n+endef\n+endif\n+\n+######################################################################\n+# LLVM macros\n+######################################################################\n+\n+# FIXME: x86-ism\n+LLVM_COMPONENTS=x86 arm mips ipo bitreader bitwriter linker asmparser jit mcjit \\\n+                interpreter instrumentation\n+\n+# Only build these LLVM tools\n+LLVM_TOOLS=bugpoint llc llvm-ar llvm-as llvm-dis llvm-mc opt llvm-extract\n+\n+define DEF_LLVM_VARS\n+# The configure script defines these variables with the target triples\n+# separated by Z. This defines new ones with the expected format.\n+CFG_LLVM_BUILD_DIR_$(1):=$$(CFG_LLVM_BUILD_DIR_$(subst -,_,$(1)))\n+CFG_LLVM_INST_DIR_$(1):=$$(CFG_LLVM_INST_DIR_$(subst -,_,$(1)))\n+\n+# Any rules that depend on LLVM should depend on LLVM_CONFIG\n+LLVM_CONFIG_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-config$$(X_$(1))\n+LLVM_MC_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-mc$$(X_$(1))\n+LLVM_VERSION_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --version)\n+LLVM_BINDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --bindir)\n+LLVM_INCDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --includedir)\n+LLVM_LIBDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libdir)\n+LLVM_LIBS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libs $$(LLVM_COMPONENTS))\n+LLVM_LDFLAGS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --ldflags)\n+# On FreeBSD, it may search wrong headers (that are for pre-installed LLVM),\n+# so we replace -I with -iquote to ensure that it searches bundled LLVM first.\n+LLVM_CXXFLAGS_$(1)=$$(subst -I, -iquote , $$(shell \"$$(LLVM_CONFIG_$(1))\" --cxxflags))\n+LLVM_HOST_TRIPLE_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --host-target)\n+\n+LLVM_AS_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-as$$(X_$(1))\n+LLC_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llc$$(X_$(1))\n+\n+endef\n+\n+$(foreach host,$(CFG_HOST), \\\n+ $(eval $(call DEF_LLVM_VARS,$(host))))\n+\n+######################################################################\n+# Exports for sub-utilities\n+######################################################################\n+\n+# Note that any variable that re-configure should pick up needs to be\n+# exported\n+\n+export CFG_SRC_DIR\n+export CFG_BUILD_DIR\n+export CFG_VERSION\n+export CFG_VERSION_WIN\n+export CFG_RELEASE\n+export CFG_BUILD\n+export CFG_LLVM_ROOT\n+export CFG_ENABLE_MINGW_CROSS\n+export CFG_PREFIX\n+export CFG_LIBDIR\n+export CFG_RUSTLIBDIR\n+export CFG_LIBDIR_RELATIVE\n+export CFG_DISABLE_INJECT_STD_VERSION\n+\n+######################################################################\n+# Per-stage targets and runner\n+######################################################################\n+\n+STAGES = 0 1 2 3\n+\n+define SREQ\n+# $(1) is the stage number\n+# $(2) is the target triple\n+# $(3) is the host triple\n+\n+# Destinations of artifacts for the host compiler\n+HROOT$(1)_H_$(3) = $(3)/stage$(1)\n+HBIN$(1)_H_$(3) = $$(HROOT$(1)_H_$(3))/bin\n+HLIB$(1)_H_$(3) = $$(HROOT$(1)_H_$(3))/$$(CFG_LIBDIR_RELATIVE)\n+\n+# Destinations of artifacts for target architectures\n+TROOT$(1)_T_$(2)_H_$(3) = $$(HLIB$(1)_H_$(3))/$$(CFG_RUSTLIBDIR)/$(2)\n+TBIN$(1)_T_$(2)_H_$(3) = $$(TROOT$(1)_T_$(2)_H_$(3))/bin\n+TLIB$(1)_T_$(2)_H_$(3) = $$(TROOT$(1)_T_$(2)_H_$(3))/lib\n+\n+# Preqrequisites for using the stageN compiler\n+ifeq ($(1),0)\n+HSREQ$(1)_H_$(3) = $$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\n+else\n+HSREQ$(1)_H_$(3) = \\\n+\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) \\\n+\t$$(HLIB$(1)_H_$(3))/stamp.rustc \\\n+\t$$(foreach dep,$$(RUST_DEPS_rustc),$$(HLIB$(1)_H_$(3))/stamp.$$(dep)) \\\n+\t$$(MKFILE_DEPS)\n+endif\n+\n+# Prerequisites for using the stageN compiler to build target artifacts\n+TSREQ$(1)_T_$(2)_H_$(3) = \\\n+\t$$(HSREQ$(1)_H_$(3)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n+\n+# Prerequisites for a working stageN compiler and libraries, for a specific\n+# target\n+SREQ$(1)_T_$(2)_H_$(3) = \\\n+\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t$$(foreach dep,$$(TARGET_CRATES),\\\n+\t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep))\n+\n+# Prerequisites for a working stageN compiler and complete set of target\n+# libraries\n+CSREQ$(1)_T_$(2)_H_$(3) = \\\n+\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n+\t$$(foreach dep,$$(CRATES),$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n+\t$$(foreach dep,$$(HOST_CRATES),$$(HLIB$(1)_H_$(3))/stamp.$$(dep))\n+\n+ifeq ($(1),0)\n+# Don't run the the stage0 compiler under valgrind - that ship has sailed\n+CFG_VALGRIND_COMPILE$(1) =\n+else\n+CFG_VALGRIND_COMPILE$(1) = $$(CFG_VALGRIND_COMPILE)\n+endif\n+\n+# Add RUSTFLAGS_STAGEN values to the build command\n+EXTRAFLAGS_STAGE$(1) = $$(RUSTFLAGS_STAGE$(1))\n+\n+CFGFLAG$(1)_T_$(2)_H_$(3) = stage$(1)\n+\n+# Pass --cfg stage0 only for the build->host part of stage0;\n+# if you're building a cross config, the host->* parts are\n+# effectively stage1, since it uses the just-built stage0.\n+ifeq ($(1),0)\n+ifneq ($(strip $(CFG_BUILD)),$(strip $(3)))\n+CFGFLAG$(1)_T_$(2)_H_$(3) = stage1\n+endif\n+endif\n+\n+ifdef CFG_DISABLE_RPATH\n+ifeq ($$(OSTYPE_$(3)),apple-darwin)\n+  RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n+      DYLD_LIBRARY_PATH=\"$$$$DYLD_LIBRARY_PATH:$$(HLIB$(1)_H_$(3))\"\n+else\n+  RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n+      LD_LIBRARY_PATH=\"$$$$LD_LIBRARY_PATH:$$(HLIB$(1)_H_$(3))\"\n+endif\n+else\n+    RPATH_VAR$(1)_T_$(2)_H_$(3) :=\n+endif\n+\n+STAGE$(1)_T_$(2)_H_$(3) := \t\t\t\t\t\t\\\n+\t$$(Q)$$(RPATH_VAR$(1)_T_$(2)_H_$(3))                            \\\n+\t\t$$(call CFG_RUN_TARG_$(3),$(1),\t\t\t\t\\\n+\t\t$$(CFG_VALGRIND_COMPILE$(1))\t\t\t\t\\\n+\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\t\t\t\\\n+\t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3))\t\t\t\\\n+\t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\\n+                $$(RUSTC_FLAGS_$(2))\n+\n+PERF_STAGE$(1)_T_$(2)_H_$(3) :=\t\t\t\t\t\t\\\n+\t$$(Q)$$(call CFG_RUN_TARG_$(3),$(1),\t\t\t\t\\\n+\t\t$$(CFG_PERF_TOOL) \t\t\t\t\t\\\n+\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\t\t\t\\\n+\t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3))\t\t\t\\\n+\t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\\n+                $$(RUSTC_FLAGS_$(2))\n+\n+endef\n+\n+$(foreach build,$(CFG_HOST), \\\n+ $(eval $(foreach target,$(CFG_TARGET), \\\n+  $(eval $(foreach stage,$(STAGES), \\\n+   $(eval $(call SREQ,$(stage),$(target),$(build))))))))\n+\n+######################################################################\n+# rustc-H-targets\n+#\n+# Builds a functional Rustc for the given host.\n+######################################################################\n+\n+define DEF_RUSTC_STAGE_TARGET\n+# $(1) == architecture\n+# $(2) == stage\n+\n+rustc-stage$(2)-H-$(1):\t\t\t\t\t\t\t\\\n+\t$$(foreach target,$$(CFG_TARGET),$$(SREQ$(2)_T_$$(target)_H_$(1)))\n+\n+endef\n+\n+$(foreach host,$(CFG_HOST),\t\t\t\t\t\t\\\n+ $(eval $(foreach stage,1 2 3,\t\t\t\t\t\t\\\n+  $(eval $(call DEF_RUSTC_STAGE_TARGET,$(host),$(stage))))))\n+\n+rustc-stage1: rustc-stage1-H-$(CFG_BUILD)\n+rustc-stage2: rustc-stage2-H-$(CFG_BUILD)\n+rustc-stage3: rustc-stage3-H-$(CFG_BUILD)\n+\n+define DEF_RUSTC_TARGET\n+# $(1) == architecture\n+\n+rustc-H-$(1): rustc-stage2-H-$(1)\n+endef\n+\n+$(foreach host,$(CFG_TARGET),\t\t\t\\\n+ $(eval $(call DEF_RUSTC_TARGET,$(host))))\n+\n+rustc-stage1: rustc-stage1-H-$(CFG_BUILD)\n+rustc-stage2: rustc-stage2-H-$(CFG_BUILD)\n+rustc-stage3: rustc-stage3-H-$(CFG_BUILD)\n+rustc: rustc-H-$(CFG_BUILD)\n+\n+rustc-H-all: $(foreach host,$(CFG_HOST),rustc-H-$(host))\n+\n+######################################################################\n+# Entrypoint rule\n+######################################################################\n+\n+.DEFAULT_GOAL := all\n+\n+define ALL_TARGET_N\n+ifneq ($$(findstring $(1),$$(CFG_HOST)),)\n+# This is a host\n+all-target-$(1)-host-$(2): $$(CSREQ2_T_$(1)_H_$(2))\n+else\n+# This is a target only\n+all-target-$(1)-host-$(2): $$(SREQ2_T_$(1)_H_$(2))\n+endif\n+endef\n+\n+$(foreach target,$(CFG_TARGET), \\\n+ $(foreach host,$(CFG_HOST), \\\n+ $(eval $(call ALL_TARGET_N,$(target),$(host)))))\n+\n+ALL_TARGET_RULES = $(foreach target,$(CFG_TARGET), \\\n+\t$(foreach host,$(CFG_HOST), \\\n+ all-target-$(target)-host-$(host)))\n+\n+all: $(ALL_TARGET_RULES) $(GENERATED) docs\n+\n+######################################################################\n+# Build system documentation\n+######################################################################\n+\n+# $(1) is the name of the doc <section> in Makefile.in\n+# pick everything between tags | remove first line | remove last line\n+# | remove extra (?) line | strip leading `#` from lines\n+SHOW_DOCS = $(Q)awk '/$(1)/,/<\\/$(1)>/' $(S)/Makefile.in | sed '1d' | sed '$$d' | sed 's/^\\# \\?//'\n+\n+help:\n+\t$(call SHOW_DOCS,help)\n+\n+hot-tips:\n+\t$(call SHOW_DOCS,hottips)\n+\n+nitty-gritty:\n+\t$(call SHOW_DOCS,nittygritty)"}, {"sha": "8b88fee0ad3d9a009478d5efe83be173195f8dd8", "filename": "mk/reconfig.mk", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3496e93d13590140242f862c905dc2d591d2e2ea/mk%2Freconfig.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3496e93d13590140242f862c905dc2d591d2e2ea/mk%2Freconfig.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Freconfig.mk?ref=3496e93d13590140242f862c905dc2d591d2e2ea", "patch": "@@ -0,0 +1,33 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# Recursive wildcard function\n+# http://blog.jgc.org/2011/07/gnu-make-recursive-wildcard-function.html\n+rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) \\\n+  $(filter $(subst *,%,$2),$d))\n+\n+ifndef CFG_DISABLE_MANAGE_SUBMODULES\n+# This is a pretty expensive operation but I don't see any way to avoid it\n+NEED_GIT_RECONFIG=$(shell cd \"$(CFG_SRC_DIR)\" && \"$(CFG_GIT)\" submodule status | grep -c '^\\(+\\|-\\)')\n+else\n+NEED_GIT_RECONFIG=0\n+endif\n+\n+ifeq ($(NEED_GIT_RECONFIG),0)\n+else\n+# If the submodules have changed then always execute config.mk\n+.PHONY: config.stamp\n+endif\n+\n+Makefile config.mk: config.stamp\n+\n+config.stamp: $(S)configure $(S)Makefile.in $(S)src/snapshots.txt\n+\t@$(call E, cfg: reconfiguring)\n+\t$(S)configure $(CFG_CONFIGURE_ARGS)"}, {"sha": "8ca4da85994fdfa218cb65299632f96296fb918c", "filename": "mk/tests.mk", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3496e93d13590140242f862c905dc2d591d2e2ea/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3496e93d13590140242f862c905dc2d591d2e2ea/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=3496e93d13590140242f862c905dc2d591d2e2ea", "patch": "@@ -190,6 +190,13 @@ check-lite: cleantestlibs cleantmptestlogs \\\n \tcheck-stage2-rfail check-stage2-cfail check-stage2-rmake\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n \n+check-ref: cleantestlibs cleantmptestlogs check-stage2-rpass \\\n+\tcheck-stage2-rfail check-stage2-cfail check-stage2-rmake\n+\t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n+\n+check-docs: cleantestlibs cleantmptestlogs check-stage2-docs\n+\t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n+\n .PHONY: cleantmptestlogs cleantestlibs\n \n cleantmptestlogs:\n@@ -823,6 +830,23 @@ $(foreach stage,$(STAGES), \\\n   $(foreach group,$(TEST_GROUPS), \\\n    $(eval $(call DEF_CHECK_FOR_STAGE_AND_HOSTS_AND_GROUP,$(stage),$(host),$(group))))))\n \n+define DEF_CHECK_DOC_FOR_STAGE\n+check-stage$(1)-docs: $$(foreach docname,$$(DOC_TEST_NAMES),\\\n+                       check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-$$(docname)) \\\n+                     $$(foreach crate,$$(DOC_CRATE_NAMES),\\\n+                       check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-$$(crate))\n+endef\n+\n+$(foreach stage,$(STAGES), \\\n+ $(eval $(call DEF_CHECK_DOC_FOR_STAGE,$(stage))))\n+\n+define DEF_CHECK_CRATE\n+check-$(1): check-stage2-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-$(1)-exec\n+endef\n+\n+$(foreach crate,$(TEST_CRATES), \\\n+ $(eval $(call DEF_CHECK_CRATE,$(crate))))\n+\n ######################################################################\n # check-fast rules\n ######################################################################"}, {"sha": "3bbc8f413aec5c04da07138a0c410bda12f368d5", "filename": "mk/util.mk", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3496e93d13590140242f862c905dc2d591d2e2ea/mk%2Futil.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3496e93d13590140242f862c905dc2d591d2e2ea/mk%2Futil.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Futil.mk?ref=3496e93d13590140242f862c905dc2d591d2e2ea", "patch": "@@ -0,0 +1,20 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+ifdef VERBOSE\n+  Q :=\n+  E =\n+else\n+  Q := @\n+  E = echo $(1)\n+endif\n+\n+S := $(CFG_SRC_DIR)\n+"}]}