{"sha": "ed885dc2b320e26f47b15ef50f442e4e40cce954", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkODg1ZGMyYjMyMGUyNmY0N2IxNWVmNTBmNDQyZTRlNDBjY2U5NTQ=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-05-17T18:17:21Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-05-17T19:12:07Z"}, "message": "Fix ICE for issues 2767, 2499, 1782", "tree": {"sha": "2283d5dd06c3ad16603f4bef215f795a5ab0dd35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2283d5dd06c3ad16603f4bef215f795a5ab0dd35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed885dc2b320e26f47b15ef50f442e4e40cce954", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJa/dQHAAoJELb6Bqbg4mZb0iEP/RGc/SwTyveX0KeB4VBscSMW\nw1WmSyXOKtof2wd2UqjHCZFCMIIVHJo5W0FffLq5n0yzv5hi7tLLkDgCxiUOoCNe\nr8zOBnc38I9oE1FJPewcd1b8d11uLH57tqo24NXKYSha9QkxCTgieZVCJ3OXnIam\nhbo29Z47R/9waFVz35LBE1QixdAFDwKMrQA43zAvVqi332/L3PL0K2EmnSaZ00aX\nih26RH70S9VO9vy/xwlpxJW/qzSrnJjz0PnPiGKOxEejJXqLUZTb8nQp6leqivHA\nHKjvmMMIKCG9ndAKx8m4Z2q4v1aji1xtFtHYdSObHDP1SrCTL79OC5hB7eIoRX4h\nL4ubKgn8m5LiJsMDcRzpVjEizs5hOyZ6RIc7H7cwNMVzwEOFmYyBIfPd5RofaCMq\nZuRu7ql2NprWH7SrBF6AkUyne9RzyvrMU2JlIK9JJls9jTrWtUKGjHurxTsMRHPQ\n+0pMQNmwhyOFK39hD1AtgBBfSTNjjxU/Q8d/b9Jznv5rxyvzKFp0RqWgPD4f/Rik\nr17tYywL6ohwmJ5fe9i/0znZNq9wFlwt/1hab9EobptB9vxR/ib3B4bz34ijECFw\nohvj5gZ1TFo5kImdgvt66WQH7EhvQtFMSdnbn5CKfizwbNaxfrO86oo64+/zyW3Y\n3vbsXTWbIE6OqBKovwhC\n=YXdp\n-----END PGP SIGNATURE-----", "payload": "tree 2283d5dd06c3ad16603f4bef215f795a5ab0dd35\nparent 6eb07cc5b699a28f479012f5271ef9da2f60a6a3\nauthor Philipp Hansch <dev@phansch.net> 1526581041 +0200\ncommitter Philipp Hansch <dev@phansch.net> 1526584327 +0200\n\nFix ICE for issues 2767, 2499, 1782\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed885dc2b320e26f47b15ef50f442e4e40cce954", "html_url": "https://github.com/rust-lang/rust/commit/ed885dc2b320e26f47b15ef50f442e4e40cce954", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed885dc2b320e26f47b15ef50f442e4e40cce954/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6eb07cc5b699a28f479012f5271ef9da2f60a6a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6eb07cc5b699a28f479012f5271ef9da2f60a6a3", "html_url": "https://github.com/rust-lang/rust/commit/6eb07cc5b699a28f479012f5271ef9da2f60a6a3"}], "stats": {"total": 49, "additions": 31, "deletions": 18}, "files": [{"sha": "1ccc5708185e63c7a1a24591fa1ad649f9c33175", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed885dc2b320e26f47b15ef50f442e4e40cce954/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed885dc2b320e26f47b15ef50f442e4e40cce954/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=ed885dc2b320e26f47b15ef50f442e4e40cce954", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> DoubleComparisonPass {\n             }\n             _ => return,\n         };\n-        let spanless_eq = SpanlessEq::new(cx).ignore_fn();\n+        let mut spanless_eq = SpanlessEq::new(cx).ignore_fn();\n         if !(spanless_eq.eq_expr(&llhs, &rlhs) && spanless_eq.eq_expr(&lrhs, &rrhs)) {\n             return;\n         }"}, {"sha": "7d9945cdddceadec31ac07ad5155bc8adbd87ef4", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed885dc2b320e26f47b15ef50f442e4e40cce954/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed885dc2b320e26f47b15ef50f442e4e40cce954/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=ed885dc2b320e26f47b15ef50f442e4e40cce954", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Check whether two statements are the same.\n-    pub fn eq_stmt(&self, left: &Stmt, right: &Stmt) -> bool {\n+    pub fn eq_stmt(&mut self, left: &Stmt, right: &Stmt) -> bool {\n         match (&left.node, &right.node) {\n             (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n                 if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n@@ -58,12 +58,12 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Check whether two blocks are the same.\n-    pub fn eq_block(&self, left: &Block, right: &Block) -> bool {\n+    pub fn eq_block(&mut self, left: &Block, right: &Block) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n-    pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n+    pub fn eq_expr(&mut self, left: &Expr, right: &Expr) -> bool {\n         if self.ignore_fn && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n@@ -144,20 +144,20 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_exprs(&self, left: &P<[Expr]>, right: &P<[Expr]>) -> bool {\n+    fn eq_exprs(&mut self, left: &P<[Expr]>, right: &P<[Expr]>) -> bool {\n         over(left, right, |l, r| self.eq_expr(l, r))\n     }\n \n-    fn eq_field(&self, left: &Field, right: &Field) -> bool {\n+    fn eq_field(&mut self, left: &Field, right: &Field) -> bool {\n         left.name.node == right.name.node && self.eq_expr(&left.expr, &right.expr)\n     }\n \n-    fn eq_lifetime(&self, left: &Lifetime, right: &Lifetime) -> bool {\n+    fn eq_lifetime(&mut self, left: &Lifetime, right: &Lifetime) -> bool {\n         left.name == right.name\n     }\n \n     /// Check whether two patterns are the same.\n-    pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n+    pub fn eq_pat(&mut self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n@@ -184,7 +184,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_qpath(&self, left: &QPath, right: &QPath) -> bool {\n+    fn eq_qpath(&mut self, left: &QPath, right: &QPath) -> bool {\n         match (left, right) {\n             (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n                 both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n@@ -196,12 +196,12 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_path(&self, left: &Path, right: &Path) -> bool {\n+    fn eq_path(&mut self, left: &Path, right: &Path) -> bool {\n         left.is_global() == right.is_global()\n             && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n-    fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n+    fn eq_path_parameters(&mut self, left: &PathParameters, right: &PathParameters) -> bool {\n         if !(left.parenthesized || right.parenthesized) {\n             over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r))\n                 && over(&left.types, &right.types, |l, r| self.eq_ty(l, r))\n@@ -218,7 +218,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_path_segment(&self, left: &PathSegment, right: &PathSegment) -> bool {\n+    fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n         if left.name.as_str() != right.name.as_str() {\n@@ -231,12 +231,23 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n+    fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyArray(ref lt, ll_id), &TyArray(ref rt, rl_id)) => {\n-                self.eq_ty(lt, rt)\n-                    && self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n+                let full_table = self.tables;\n+\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id));\n+                self.tables = self.cx.tcx.body_tables(ll_id);\n+                let ll = celcx.expr(&self.cx.tcx.hir.body(ll_id).value);\n+\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id));\n+                self.tables = self.cx.tcx.body_tables(rl_id);\n+                let rl = celcx.expr(&self.cx.tcx.hir.body(rl_id).value);\n+\n+                let eq_ty = self.eq_ty(lt, rt);\n+                self.tables = full_table;\n+                eq_ty && ll == rl\n             },\n             (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n@@ -249,7 +260,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_type_binding(&self, left: &TypeBinding, right: &TypeBinding) -> bool {\n+    fn eq_type_binding(&mut self, left: &TypeBinding, right: &TypeBinding) -> bool {\n         left.name == right.name && self.eq_ty(&left.ty, &right.ty)\n     }\n }\n@@ -467,8 +478,10 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprRepeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n+                let full_table = self.tables;\n                 self.tables = self.cx.tcx.body_tables(l_id);\n                 self.hash_expr(&self.cx.tcx.hir.body(l_id).value);\n+                self.tables = full_table;\n             },\n             ExprRet(ref e) => {\n                 let c: fn(_) -> _ = ExprRet;"}, {"sha": "01deb7abfc1065d75d3221d260d18865a471b8ad", "filename": "tests/run-pass/ice-2499.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed885dc2b320e26f47b15ef50f442e4e40cce954/tests%2Frun-pass%2Fice-2499.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed885dc2b320e26f47b15ef50f442e4e40cce954/tests%2Frun-pass%2Fice-2499.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fice-2499.rs?ref=ed885dc2b320e26f47b15ef50f442e4e40cce954", "patch": "@@ -1,4 +1,4 @@\n-#![allow(dead_code)]\n+#![allow(dead_code, char_lit_as_u8, needless_bool)]\n \n /// Should not trigger an ICE in `SpanlessHash` / `consts::constant`\n ///\n@@ -9,7 +9,7 @@ fn f(s: &[u8]) -> bool {\n \n     match t {\n         'E' | 'W' => {}\n-        'T' => if &s[0..(0 + 4)] != &['0' as u8; 4] {\n+        'T' => if s[0..4] != ['0' as u8; 4] {\n             return false;\n         } else {\n             return true;"}]}