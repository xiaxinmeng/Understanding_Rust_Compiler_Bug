{"sha": "d617d615e4f310eadde6e3be1c1e970e9608bb81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MTdkNjE1ZTRmMzEwZWFkZGU2ZTNiZTFjMWU5NzBlOTYwOGJiODE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-17T10:54:38Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-17T10:55:45Z"}, "message": "fix non-fatal diagnostics stacktraces", "tree": {"sha": "c93c4564d69de6942a002103468ec1361fde9768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c93c4564d69de6942a002103468ec1361fde9768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d617d615e4f310eadde6e3be1c1e970e9608bb81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d617d615e4f310eadde6e3be1c1e970e9608bb81", "html_url": "https://github.com/rust-lang/rust/commit/d617d615e4f310eadde6e3be1c1e970e9608bb81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d617d615e4f310eadde6e3be1c1e970e9608bb81/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0454dabcfba481d4810a67511319ded727f281de", "url": "https://api.github.com/repos/rust-lang/rust/commits/0454dabcfba481d4810a67511319ded727f281de", "html_url": "https://github.com/rust-lang/rust/commit/0454dabcfba481d4810a67511319ded727f281de"}], "stats": {"total": 107, "additions": 79, "deletions": 28}, "files": [{"sha": "009f8aa29cecf11ebdf1fef0633aca6f6eaf41bc", "filename": "src/diagnostics.rs", "status": "modified", "additions": 74, "deletions": 27, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d617d615e4f310eadde6e3be1c1e970e9608bb81/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d617d615e4f310eadde6e3be1c1e970e9608bb81/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=d617d615e4f310eadde6e3be1c1e970e9608bb81", "patch": "@@ -3,7 +3,8 @@ use std::fmt;\n \n use log::trace;\n \n-use rustc_span::DUMMY_SP;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::{source_map::DUMMY_SP, Span};\n \n use crate::*;\n \n@@ -116,7 +117,17 @@ pub fn report_error<'tcx, 'mir>(\n \n     e.print_backtrace();\n     let msg = e.to_string();\n-    report_msg(ecx, &format!(\"{}: {}\", title, msg), msg, helps, true);\n+    report_msg(*ecx.tcx, /*error*/true, &format!(\"{}: {}\", title, msg), msg, helps, &ecx.generate_stacktrace());\n+\n+    // Debug-dump all locals.\n+    for (i, frame) in ecx.active_thread_stack().iter().enumerate() {\n+        trace!(\"-------------------\");\n+        trace!(\"Frame {}\", i);\n+        trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n+        for (i, local) in frame.locals.iter().enumerate() {\n+            trace!(\"    local {}: {:?}\", i, local.value);\n+        }\n+    }\n \n     // Extra output to help debug specific issues.\n     match e.kind {\n@@ -135,24 +146,21 @@ pub fn report_error<'tcx, 'mir>(\n     None\n }\n \n-/// Report an error or note (depending on the `error` argument) at the current frame's current statement.\n+/// Report an error or note (depending on the `error` argument) with the given stacktrace.\n /// Also emits a full stacktrace of the interpreter stack.\n-fn report_msg<'tcx, 'mir>(\n-    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+fn report_msg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    error: bool,\n     title: &str,\n     span_msg: String,\n     mut helps: Vec<String>,\n-    error: bool,\n+    stacktrace: &[FrameInfo<'tcx>],\n ) {\n-    let span = if let Some(frame) = ecx.active_thread_stack().last() {\n-        frame.current_source_info().unwrap().span\n-    } else {\n-        DUMMY_SP\n-    };\n+    let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n     let mut err = if error {\n-        ecx.tcx.sess.struct_span_err(span, title)\n+        tcx.sess.struct_span_err(span, title)\n     } else {\n-        ecx.tcx.sess.diagnostic().span_note_diag(span, title)\n+        tcx.sess.diagnostic().span_note_diag(span, title)\n     };\n     err.span_label(span, span_msg);\n     if !helps.is_empty() {\n@@ -163,8 +171,7 @@ fn report_msg<'tcx, 'mir>(\n         }\n     }\n     // Add backtrace\n-    let frames = ecx.generate_stacktrace();\n-    for (idx, frame_info) in frames.iter().enumerate() {\n+    for (idx, frame_info) in stacktrace.iter().enumerate() {\n         let is_local = frame_info.instance.def_id().is_local();\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n@@ -175,15 +182,6 @@ fn report_msg<'tcx, 'mir>(\n     }\n \n     err.emit();\n-\n-    for (i, frame) in ecx.active_thread_stack().iter().enumerate() {\n-        trace!(\"-------------------\");\n-        trace!(\"Frame {}\", i);\n-        trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n-        for (i, local) in frame.locals.iter().enumerate() {\n-            trace!(\"    local {}: {:?}\", i, local.value);\n-        }\n-    }\n }\n \n thread_local! {\n@@ -196,13 +194,62 @@ pub fn register_diagnostic(e: NonHaltingDiagnostic) {\n     DIAGNOSTICS.with(|diagnostics| diagnostics.borrow_mut().push(e));\n }\n \n+/// Remember enough about the topmost frame so that we can restore the stack\n+/// after a step was taken.\n+pub struct TopFrameInfo<'tcx> {\n+    stack_size: usize,\n+    instance: ty::Instance<'tcx>,\n+    span: Span,\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn preprocess_diagnostics(&self) -> TopFrameInfo<'tcx> {\n+        // Ensure we have no lingering diagnostics.\n+        DIAGNOSTICS.with(|diagnostics| assert!(diagnostics.borrow().is_empty()));\n+\n+        let this = self.eval_context_ref();\n+        let frame = this.frame();\n+\n+        TopFrameInfo {\n+            stack_size: this.active_thread_stack().len(),\n+            instance: frame.instance,\n+            span: frame.current_source_info().map_or(DUMMY_SP, |si| si.span),\n+        }\n+    }\n+\n     /// Emit all diagnostics that were registed with `register_diagnostics`\n-    fn process_diagnostics(&self) {\n+    fn process_diagnostics(&self, info: TopFrameInfo<'tcx>) {\n         let this = self.eval_context_ref();\n         DIAGNOSTICS.with(|diagnostics| {\n-            for e in diagnostics.borrow_mut().drain(..) {\n+            let mut diagnostics = diagnostics.borrow_mut();\n+            if diagnostics.is_empty() {\n+                return;\n+            }\n+            // We need to fix up the stack trace, because the machine has already\n+            // stepped to the next statement.\n+            let mut stacktrace = this.generate_stacktrace();\n+            // Remove newly pushed frames.\n+            while stacktrace.len() > info.stack_size {\n+                stacktrace.remove(0);\n+            }\n+            // Add popped frame back.\n+            if stacktrace.len() < info.stack_size {\n+                assert!(stacktrace.len() == info.stack_size-1, \"we should never pop more than one frame at once\");\n+                let frame_info = FrameInfo {\n+                    instance: info.instance,\n+                    span: info.span,\n+                    lint_root: None,\n+                };\n+                stacktrace.insert(0, frame_info);\n+            } else {\n+                // Adjust topmost frame.\n+                stacktrace[0].span = info.span;\n+                assert_eq!(stacktrace[0].instance, info.instance, \"we should not pop and push a frame in one step\");\n+            }\n+\n+            // Show diagnostics.\n+            for e in diagnostics.drain(..) {\n                 use NonHaltingDiagnostic::*;\n                 let msg = match e {\n                     PoppedPointerTag(item) =>\n@@ -214,7 +261,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     FreedAlloc(AllocId(id)) =>\n                         format!(\"freed allocation with id {}\", id),\n                 };\n-                report_msg(this, \"tracking was triggered\", msg, vec![], false);\n+                report_msg(*this.tcx, /*error*/false, \"tracking was triggered\", msg, vec![], &stacktrace);\n             }\n         });\n     }"}, {"sha": "79ceb6be806e23ad2bded4cda839614693e53430", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d617d615e4f310eadde6e3be1c1e970e9608bb81/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d617d615e4f310eadde6e3be1c1e970e9608bb81/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=d617d615e4f310eadde6e3be1c1e970e9608bb81", "patch": "@@ -212,7 +212,9 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n         loop {\n             match ecx.schedule()? {\n                 SchedulingAction::ExecuteStep => {\n+                    let info = ecx.preprocess_diagnostics();\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n+                    ecx.process_diagnostics(info);\n                 }\n                 SchedulingAction::ExecuteTimeoutCallback => {\n                     assert!(ecx.machine.communicate,\n@@ -230,7 +232,6 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                     break;\n                 }\n             }\n-            ecx.process_diagnostics();\n         }\n         let return_code = ecx.read_scalar(ret_place.into())?.not_undef()?.to_machine_isize(&ecx)?;\n         Ok(return_code)"}, {"sha": "aee7d395ddfcfb8a151ae7dcbaa0dca272bbfc19", "filename": "src/thread.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d617d615e4f310eadde6e3be1c1e970e9608bb81/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d617d615e4f310eadde6e3be1c1e970e9608bb81/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=d617d615e4f310eadde6e3be1c1e970e9608bb81", "patch": "@@ -373,6 +373,9 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Change the active thread to some enabled thread.\n     fn yield_active_thread(&mut self) {\n+        // We do not immediately, as swapping out the current stack while execution a MIR statement\n+        // could lead to all sorts of confusion.\n+        // We should only switch stacks between steps.\n         self.yield_active_thread = true;\n     }\n "}]}