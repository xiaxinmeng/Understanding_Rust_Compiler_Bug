{"sha": "19c886b4076ebf264ef919b1fd78ebb9f193476c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5Yzg4NmI0MDc2ZWJmMjY0ZWY5MTliMWZkNzhlYmI5ZjE5MzQ3NmM=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T12:09:04Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T12:09:10Z"}, "message": "Remove \"for_loop_arg.rs\"", "tree": {"sha": "4c44bbd73a615174bebdf866cd561632d5703871", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c44bbd73a615174bebdf866cd561632d5703871"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c886b4076ebf264ef919b1fd78ebb9f193476c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c886b4076ebf264ef919b1fd78ebb9f193476c", "html_url": "https://github.com/rust-lang/rust/commit/19c886b4076ebf264ef919b1fd78ebb9f193476c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c886b4076ebf264ef919b1fd78ebb9f193476c/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74bd806b05b16528ff773e469145df215760a88b", "url": "https://api.github.com/repos/rust-lang/rust/commits/74bd806b05b16528ff773e469145df215760a88b", "html_url": "https://github.com/rust-lang/rust/commit/74bd806b05b16528ff773e469145df215760a88b"}], "stats": {"total": 149, "additions": 0, "deletions": 149}, "files": [{"sha": "b33e7183984dabef2e861a96435d0425d6219e46", "filename": "clippy_lints/src/loops/for_loop_arg.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Ffor_loop_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Ffor_loop_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_loop_arg.rs?ref=74bd806b05b16528ff773e469145df215760a88b", "patch": "@@ -1,149 +0,0 @@\n-use crate::utils::{\n-    is_type_diagnostic_item, match_trait_method, match_type, paths, snippet, snippet_with_applicability, span_lint,\n-    span_lint_and_help, span_lint_and_sugg,\n-};\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, Mutability, Pat};\n-use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n-use rustc_span::symbol::sym;\n-\n-pub(super) fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n-    let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n-    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n-        // just the receiver, no arguments\n-        if args.len() == 1 {\n-            let method_name = &*method.ident.as_str();\n-            // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n-            if method_name == \"iter\" || method_name == \"iter_mut\" {\n-                if is_ref_iterable_type(cx, &args[0]) {\n-                    lint_iter_method(cx, args, arg, method_name);\n-                }\n-            } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n-                let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-                if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n-                    let mut applicability = Applicability::MachineApplicable;\n-                    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        super::EXPLICIT_INTO_ITER_LOOP,\n-                        arg.span,\n-                        \"it is more concise to loop over containers instead of using explicit \\\n-                         iteration methods\",\n-                        \"to write this more concisely, try\",\n-                        object.to_string(),\n-                        applicability,\n-                    );\n-                } else {\n-                    let ref_receiver_ty = cx.tcx.mk_ref(\n-                        cx.tcx.lifetimes.re_erased,\n-                        ty::TypeAndMut {\n-                            ty: receiver_ty,\n-                            mutbl: Mutability::Not,\n-                        },\n-                    );\n-                    if TyS::same_type(receiver_ty_adjusted, ref_receiver_ty) {\n-                        lint_iter_method(cx, args, arg, method_name)\n-                    }\n-                }\n-            } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n-                span_lint(\n-                    cx,\n-                    super::ITER_NEXT_LOOP,\n-                    expr.span,\n-                    \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n-                    probably not what you want\",\n-                );\n-                next_loop_linted = true;\n-            }\n-        }\n-    }\n-    if !next_loop_linted {\n-        check_arg_type(cx, pat, arg);\n-    }\n-}\n-\n-/// Checks for `for` loops over `Option`s and `Result`s.\n-fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n-    let ty = cx.typeck_results().expr_ty(arg);\n-    if is_type_diagnostic_item(cx, ty, sym::option_type) {\n-        span_lint_and_help(\n-            cx,\n-            super::FOR_LOOPS_OVER_FALLIBLES,\n-            arg.span,\n-            &format!(\n-                \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n-                `if let` statement\",\n-                snippet(cx, arg.span, \"_\")\n-            ),\n-            None,\n-            &format!(\n-                \"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n-                snippet(cx, pat.span, \"_\"),\n-                snippet(cx, arg.span, \"_\")\n-            ),\n-        );\n-    } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n-        span_lint_and_help(\n-            cx,\n-            super::FOR_LOOPS_OVER_FALLIBLES,\n-            arg.span,\n-            &format!(\n-                \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n-                `if let` statement\",\n-                snippet(cx, arg.span, \"_\")\n-            ),\n-            None,\n-            &format!(\n-                \"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n-                snippet(cx, pat.span, \"_\"),\n-                snippet(cx, arg.span, \"_\")\n-            ),\n-        );\n-    }\n-}\n-\n-fn lint_iter_method(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n-    let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n-    span_lint_and_sugg(\n-        cx,\n-        super::EXPLICIT_ITER_LOOP,\n-        arg.span,\n-        \"it is more concise to loop over references to containers instead of using explicit \\\n-         iteration methods\",\n-        \"to write this more concisely, try\",\n-        format!(\"&{}{}\", muta, object),\n-        applicability,\n-    )\n-}\n-\n-/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n-/// for `&T` and `&mut T`, such as `Vec`.\n-#[rustfmt::skip]\n-fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n-    // will allow further borrows afterwards\n-    let ty = cx.typeck_results().expr_ty(e);\n-    is_iterable_array(ty, cx) ||\n-    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-    match_type(cx, ty, &paths::LINKED_LIST) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n-    match_type(cx, ty, &paths::BINARY_HEAP) ||\n-    match_type(cx, ty, &paths::BTREEMAP) ||\n-    match_type(cx, ty, &paths::BTREESET)\n-}\n-\n-fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n-    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n-    match ty.kind() {\n-        ty::Array(_, n) => n\n-            .try_eval_usize(cx.tcx, cx.param_env)\n-            .map_or(false, |val| (0..=32).contains(&val)),\n-        _ => false,\n-    }\n-}"}]}