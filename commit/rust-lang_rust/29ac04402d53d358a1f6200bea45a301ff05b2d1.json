{"sha": "29ac04402d53d358a1f6200bea45a301ff05b2d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YWMwNDQwMmQ1M2QzNThhMWY2MjAwYmVhNDVhMzAxZmYwNWIyZDE=", "commit": {"author": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2015-03-24T23:53:34Z"}, "committer": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2015-04-15T03:26:03Z"}, "message": "Positive case of `len()` -> `is_empty()`\n\n`s/(?<!\\{ self)(?<=\\.)len\\(\\) == 0/is_empty()/g`", "tree": {"sha": "b54ff9c5f2b99a0197147875cf3c5377d8a09cf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b54ff9c5f2b99a0197147875cf3c5377d8a09cf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29ac04402d53d358a1f6200bea45a301ff05b2d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29ac04402d53d358a1f6200bea45a301ff05b2d1", "html_url": "https://github.com/rust-lang/rust/commit/29ac04402d53d358a1f6200bea45a301ff05b2d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29ac04402d53d358a1f6200bea45a301ff05b2d1/comments", "author": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e1fcead14628701e1b10b9d00c898d748db2ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e1fcead14628701e1b10b9d00c898d748db2ed", "html_url": "https://github.com/rust-lang/rust/commit/16e1fcead14628701e1b10b9d00c898d748db2ed"}], "stats": {"total": 234, "additions": 117, "deletions": 117}, "files": [{"sha": "8ae3639318291a723692c76bf675785458784401", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -864,7 +864,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                 }\n                 first = false;\n             }\n-            if !failed && rest.len() == 0 {\n+            if !failed && rest.is_empty() {\n                 i += 1;\n             }\n             if i == num_check_lines {\n@@ -1662,7 +1662,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n // codegen tests (vs. clang)\n \n fn append_suffix_to_stem(p: &Path, suffix: &str) -> PathBuf {\n-    if suffix.len() == 0 {\n+    if suffix.is_empty() {\n         p.to_path_buf()\n     } else {\n         let mut stem = p.file_stem().unwrap().to_os_string();"}, {"sha": "0ed23dae9b55918cd17d225d5d5e7ab63ecad679", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -3788,7 +3788,7 @@ its type parameters are types:\n \n ```ignore\n fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n-    if xs.len() == 0 {\n+    if xs.is_empty() {\n        return vec![];\n     }\n     let first: B = f(xs[0].clone());"}, {"sha": "859d5ea99bf506876e8c24673bb4d816fe035092", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -692,7 +692,7 @@ mod stack {\n                         // We've reached the root, so no matter what, we're done. We manually\n                         // access the root via the tree itself to avoid creating any dangling\n                         // pointers.\n-                        if self.map.root.len() == 0 && !self.map.root.is_leaf() {\n+                        if self.map.root.is_empty() && !self.map.root.is_leaf() {\n                             // We've emptied out the root, so make its only child the new root.\n                             // If it's a leaf, we just let it become empty.\n                             self.map.depth -= 1;"}, {"sha": "7f269c423f106fbd2e55a0c103cd6c7dcce1edb1", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1097,7 +1097,7 @@ impl<K, V> Node<K, V> {\n     /// When a node has no keys or values and only a single edge, extract that edge.\n     pub fn hoist_lone_child(&mut self) {\n         // Necessary for correctness, but in a private module\n-        debug_assert!(self.len() == 0);\n+        debug_assert!(self.is_empty());\n         debug_assert!(!self.is_leaf());\n \n         unsafe {"}, {"sha": "4b1742a43482a216772721537c07189b952dc4bb", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -204,7 +204,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn first(&self) -> Option<&T> {\n-        if self.len() == 0 { None } else { Some(&self[0]) }\n+        if self.is_empty() { None } else { Some(&self[0]) }\n     }\n \n     #[inline]\n@@ -217,7 +217,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn last(&self) -> Option<&T> {\n-        if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+        if self.is_empty() { None } else { Some(&self[self.len() - 1]) }\n     }\n \n     #[inline]\n@@ -296,7 +296,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn first_mut(&mut self) -> Option<&mut T> {\n-        if self.len() == 0 { None } else { Some(&mut self[0]) }\n+        if self.is_empty() { None } else { Some(&mut self[0]) }\n     }\n \n     #[inline]\n@@ -1306,7 +1306,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             None\n         } else {\n             let chunksz = cmp::min(self.v.len(), self.size);\n@@ -1318,7 +1318,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             (0, Some(0))\n         } else {\n             let n = self.v.len() / self.size;\n@@ -1333,7 +1333,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             None\n         } else {\n             let remainder = self.v.len() % self.size;\n@@ -1384,7 +1384,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n@@ -1397,7 +1397,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             (0, Some(0))\n         } else {\n             let n = self.v.len() / self.chunk_size;\n@@ -1412,7 +1412,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             None\n         } else {\n             let remainder = self.v.len() % self.chunk_size;"}, {"sha": "2d6ef39361e8ad5011f67525f0ae4f5bb20ff40b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1119,7 +1119,7 @@ enum OldSearcher {\n impl OldSearcher {\n     #[allow(dead_code)]\n     fn new(haystack: &[u8], needle: &[u8]) -> OldSearcher {\n-        if needle.len() == 0 {\n+        if needle.is_empty() {\n             // Handle specially\n             unimplemented!()\n         // FIXME: Tune this."}, {"sha": "9a96612195cf8f01c02e347203fc16ae611880ad", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -457,7 +457,7 @@ fn str_search_step<F, G>(mut m: &mut StrSearcher,\n {\n     if m.state.done() {\n         SearchStep::Done\n-    } else if m.needle.len() == 0 && m.start <= m.end {\n+    } else if m.needle.is_empty() && m.start <= m.end {\n         // Case for needle == \"\"\n         if let State::Reject(a, b) = m.state.take() {\n             SearchStep::Reject(a, b)"}, {"sha": "9ea680c7efe7643c8bab6a4717333931bb3d49bd", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -45,7 +45,7 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n         return (dirs, None);\n     }\n     mods.map(|m| { for s in m.split(',') {\n-        if s.len() == 0 { continue }\n+        if s.is_empty() { continue }\n         let mut parts = s.split('=');\n         let (log_level, name) = match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n             (Some(part0), None, None) => {"}, {"sha": "802c5815398f2c4398c25b24dd50d8594c491177", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -80,7 +80,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n             (None, Some(sess)) => sess.err(s),\n         }\n     };\n-    if s.len() == 0 {\n+    if s.is_empty() {\n         say(\"crate name must not be empty\");\n     }\n     for c in s.chars() {"}, {"sha": "6b3bde409f540091d82718b8be3f477b132891ec", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -767,7 +767,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n                         get_type(cdata, field_ty.id.node, tcx).ty\n                     })\n                     .collect();\n-                let arg_names = if arg_names.len() == 0 { None } else { Some(arg_names) };\n+                let arg_names = if arg_names.is_empty() { None } else { Some(arg_names) };\n \n                 (None, arg_tys, arg_names)\n             }\n@@ -1383,7 +1383,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n \n     debug!(\"found dylib deps: {}\", formats.as_str_slice());\n     for spec in formats.as_str_slice().split(',') {\n-        if spec.len() == 0 { continue }\n+        if spec.is_empty() { continue }\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n         let cnum: ast::CrateNum = cnum.parse().unwrap();"}, {"sha": "50ad8526e8c5775eb1f32b59e3863844734801ec", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1751,7 +1751,7 @@ fn encode_codemap(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n     for filemap in &codemap.files.borrow()[..] {\n \n-        if filemap.lines.borrow().len() == 0 || filemap.is_imported() {\n+        if filemap.lines.borrow().is_empty() || filemap.is_imported() {\n             // No need to export empty filemaps, as they can't contain spans\n             // that need translation.\n             // Also no need to re-export imported filemaps, as any downstream"}, {"sha": "97b1dae7223bfd6998e81b9542bafc98035b6f59", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -517,7 +517,7 @@ impl<'a> Context<'a> {\n             //                library's metadata sections. In theory we should\n             //                read both, but reading dylib metadata is quite\n             //                slow.\n-            if m.len() == 0 {\n+            if m.is_empty() {\n                 return None\n             } else if m.len() == 1 {\n                 return Some(m.into_iter().next().unwrap())"}, {"sha": "912854a6d7dfbb7470ece68ce8f483da1eefdc0c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -239,7 +239,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                     if let Some(DefLocal(_)) = def {\n                         if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n                             token::get_name(variant.name) == token::get_name(ident.node.name)\n-                                && variant.args.len() == 0\n+                                && variant.args.is_empty()\n                         ) {\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n@@ -636,19 +636,19 @@ fn is_useful(cx: &MatchCheckCtxt,\n              -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"{:?}\", matrix);\n-    if rows.len() == 0 {\n+    if rows.is_empty() {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec!()),\n             LeaveOutWitness => Useful\n         };\n     }\n-    if rows[0].len() == 0 {\n+    if rows[0].is_empty() {\n         return NotUseful;\n     }\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n     let real_pat = match rows.iter().find(|r| (*r)[0].id != DUMMY_NODE_ID) {\n         Some(r) => raw_pat(r[0]),\n-        None if v.len() == 0 => return NotUseful,\n+        None if v.is_empty() => return NotUseful,\n         None => v[0]\n     };\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {"}, {"sha": "89af7f072d713a0997345986576bccf250db86a8", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let lifetimes =\n                                 path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();\n-                            if lifetimes.len() == 0 {\n+                            if lifetimes.is_empty() {\n                                 let anon = self.cur_anon.get();\n                                 for (i, a) in (anon..anon+expected).enumerate() {\n                                     if anon_nums.contains(&a) {\n@@ -1361,7 +1361,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n             ast::AngleBracketedParameters(ref data) => {\n                 let mut new_lts = Vec::new();\n-                if data.lifetimes.len() == 0 {\n+                if data.lifetimes.is_empty() {\n                     // traverse once to see if there's a need to insert lifetime\n                     let need_insert = (0..expected).any(|i| {\n                         indexes.contains(&i)"}, {"sha": "054cec68745ade14c5abe630742a9f81232cb018", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -88,7 +88,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n             Err(_) => \"/tmp/constraints.node%.dot\".to_string(),\n         };\n \n-        if output_template.len() == 0 {\n+        if output_template.is_empty() {\n             tcx.sess.bug(\"empty string provided as RUST_REGION_GRAPH\");\n         }\n "}, {"sha": "8d9ddfb3d5d5912c485ed3b91c7e981347a8a5da", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -716,7 +716,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                if self.loop_scope.len() == 0 {\n+                if self.loop_scope.is_empty() {\n                     self.ir.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n                     *self.loop_scope.last().unwrap()\n@@ -1586,7 +1586,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name.len() == 0 || name.as_bytes()[0] == ('_' as u8) {\n+        if name.is_empty() || name.as_bytes()[0] == ('_' as u8) {\n             None\n         } else {\n             Some(name)"}, {"sha": "d9cdf0fa1cb3691d5c5eea50a17b0dab3deae403", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -361,7 +361,7 @@ impl<T> VecPerParamSpace<T> {\n     pub fn get_self<'a>(&'a self) -> Option<&'a T> {\n         let v = self.get_slice(SelfSpace);\n         assert!(v.len() <= 1);\n-        if v.len() == 0 { None } else { Some(&v[0]) }\n+        if v.is_empty() { None } else { Some(&v[0]) }\n     }\n \n     pub fn len(&self, space: ParamSpace) -> usize {"}, {"sha": "5938c6df92a66ecb1264051b0c4500d4d9b67f3f", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -298,7 +298,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                self.predicates.len(),\n                errors.len());\n \n-        if errors.len() == 0 {\n+        if errors.is_empty() {\n             Ok(())\n         } else {\n             Err(errors)"}, {"sha": "ed8a6fb0200a46a5bd9d0b2f7c734097b806e3fe", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -698,7 +698,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // is checked for in `evaluate_stack` (and hence users\n         // who might care about this case, like coherence, should use\n         // that function).\n-        if candidates.len() == 0 {\n+        if candidates.is_empty() {\n             return Err(Unimplemented);\n         }\n \n@@ -873,7 +873,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         try!(self.assemble_candidates_from_caller_bounds(stack, &mut candidates));\n         // Default implementations have lower priority, so we only\n         // consider triggering a default if there is no other impl that can apply.\n-        if candidates.vec.len() == 0 {\n+        if candidates.vec.is_empty() {\n             try!(self.assemble_candidates_from_default_impls(obligation, &mut candidates));\n         }\n         debug!(\"candidate list size: {}\", candidates.vec.len());"}, {"sha": "b5b148e491b30f55a032151bdccff6b057a8de8c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -3036,7 +3036,7 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n }\n \n fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n-    bounds.len() == 0 ||\n+    bounds.is_empty() ||\n         bounds[1..].iter().enumerate().all(\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n@@ -3687,7 +3687,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                             if variants.len() == 2 {\n                                 let mut data_idx = 0;\n \n-                                if variants[0].args.len() == 0 {\n+                                if variants[0].args.is_empty() {\n                                     data_idx = 1;\n                                 }\n \n@@ -4200,10 +4200,10 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n     match ty.sty {\n         ty_enum(did, _) => {\n             let variants = enum_variants(cx, did);\n-            if variants.len() == 0 {\n+            if variants.is_empty() {\n                 false\n             } else {\n-                variants.iter().all(|v| v.args.len() == 0)\n+                variants.iter().all(|v| v.args.is_empty())\n             }\n         }\n         _ => false"}, {"sha": "3fb6c191f6ce383d06a2befe022334536d502051", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -902,7 +902,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n     output_types.sort();\n     output_types.dedup();\n-    if output_types.len() == 0 {\n+    if output_types.is_empty() {\n         output_types.push(OutputTypeExe);\n     }\n "}, {"sha": "e6f1c76b2e4731162bb0e1dfa897ce269144fdc6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1269,7 +1269,7 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n         let names: Vec<_> = names.iter().map(|s| &s[..]).collect();\n \n         let value_str = unbound_value.user_string(tcx);\n-        if names.len() == 0 {\n+        if names.is_empty() {\n             value_str\n         } else {\n             format!(\"for<{}> {}\", names.connect(\",\"), value_str)"}, {"sha": "1453c9b784b69ec40e4100c638c6eab005fb22a0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -887,9 +887,9 @@ pub fn collect_crate_types(session: &Session,\n     // command line, then reuse the empty `base` Vec to hold the types that\n     // will be found in crate attributes.\n     let mut base = session.opts.crate_types.clone();\n-    if base.len() == 0 {\n+    if base.is_empty() {\n         base.extend(attr_types.into_iter());\n-        if base.len() == 0 {\n+        if base.is_empty() {\n             base.push(link::default_output_for_target(session));\n         }\n         base.sort();"}, {"sha": "8f21a800d5c4d8c8e6749c5fd5b6361b20a7c7b1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -425,7 +425,7 @@ impl RustcDefaultCalls {\n                         odir: &Option<PathBuf>,\n                         ofile: &Option<PathBuf>)\n                         -> Compilation {\n-        if sess.opts.prints.len() == 0 {\n+        if sess.opts.prints.is_empty() {\n             return Compilation::Continue;\n         }\n "}, {"sha": "00c3450ebb935ac326ca6e904d05f49f8575c3f0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -676,7 +676,7 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n     };\n \n     match code {\n-        _ if variants.len() == 0 => {\n+        _ if variants.is_empty() => {\n             let r = dot::render(&lcfg, &mut out);\n             return expand_err_details(r);\n         }"}, {"sha": "777154f3c9c3b41881f7b2c3849160402dc32853", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -767,7 +767,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 f.name\n             }).collect::<Vec<_>>();\n \n-            if fields.len() == 0 {\n+            if fields.is_empty() {\n                 child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n             }\n "}, {"sha": "1b6af605fb0718328a6e9241ca74610db2bda42f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -2172,7 +2172,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // check that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, arm: &Arm) {\n-        if arm.pats.len() == 0 {\n+        if arm.pats.is_empty() {\n             return\n         }\n         let map_0 = self.binding_mode_map(&*arm.pats[0]);\n@@ -3522,7 +3522,7 @@ fn module_to_string(module: &Module) -> String {\n     }\n     collect_mod(&mut names, module);\n \n-    if names.len() == 0 {\n+    if names.is_empty() {\n         return \"???\".to_string();\n     }\n     names_to_string(&names.into_iter().rev().collect::<Vec<ast::Name>>())"}, {"sha": "4b488981bfbc6af7297b8322ed0399f838058c13", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n-        let container = if module_path.len() == 0 {\n+        let container = if module_path.is_empty() {\n             // Use the crate root.\n             Some((self.resolver.graph_root.get_module(), LastMod(AllPublic)))\n         } else {"}, {"sha": "33fadf804f5aa7eeed43e75ef0298c61c1d63161", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -463,7 +463,7 @@ pub fn filename_for_input(sess: &Session,\n         }\n         config::CrateTypeExecutable => {\n             let suffix = &sess.target.target.options.exe_suffix;\n-            if suffix.len() == 0 {\n+            if suffix.is_empty() {\n                 out_filename.to_path_buf()\n             } else {\n                 out_filename.with_extension(&suffix[1..])"}, {"sha": "21c95f4ce4ad2cf3f5a414818631432cb0ced5af", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -263,7 +263,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n         for arg in formals {\n-            assert!(self.collected_paths.len() == 0 && !self.collecting);\n+            assert!(self.collected_paths.is_empty() && !self.collecting);\n             self.collecting = true;\n             self.visit_pat(&*arg.pat);\n             self.collecting = false;\n@@ -1394,7 +1394,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     }\n \n     fn visit_arm(&mut self, arm: &ast::Arm) {\n-        assert!(self.collected_paths.len() == 0 && !self.collecting);\n+        assert!(self.collected_paths.is_empty() && !self.collecting);\n         self.collecting = true;\n         for pattern in &arm.pats {\n             // collect paths from the arm's patterns\n@@ -1462,7 +1462,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n         // The local could declare multiple new vars, we must walk the\n         // pattern and collect them all.\n-        assert!(self.collected_paths.len() == 0 && !self.collecting);\n+        assert!(self.collected_paths.is_empty() && !self.collecting);\n         self.collecting = true;\n         self.visit_pat(&*l.pat);\n         self.collecting = false;"}, {"sha": "54afeca13edd7d3fed6639c168b97adff32e7595", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -988,7 +988,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n-    if m.len() == 0 {\n+    if m.is_empty() {\n         if chk.is_fallible() {\n             chk.handle_fail(bcx);\n         }\n@@ -1152,7 +1152,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val);\n-    let exhaustive = chk.is_infallible() && defaults.len() == 0;\n+    let exhaustive = chk.is_infallible() && defaults.is_empty();\n     let len = opts.len();\n \n     // Compile subtrees for each option"}, {"sha": "f574b4ed8db90ba60dafba987b94f7056742f2b4", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -235,7 +235,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n \n-            if cases.len() == 0 {\n+            if cases.is_empty() {\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n@@ -244,7 +244,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   dtor_to_init_u8(dtor));\n             }\n \n-            if !dtor && cases.iter().all(|c| c.tys.len() == 0) {\n+            if !dtor && cases.iter().all(|c| c.tys.is_empty()) {\n                 // All bodies empty -> intlike\n                 let discrs: Vec<u64> = cases.iter().map(|c| c.discr).collect();\n                 let bounds = IntBounds {"}, {"sha": "8d946e2743bdf0d5fe90fc726e3b8fcf02962443", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -70,7 +70,7 @@ trait ClassList {\n \n impl ClassList for [RegClass] {\n     fn is_pass_byval(&self) -> bool {\n-        if self.len() == 0 { return false; }\n+        if self.is_empty() { return false; }\n \n         let class = self[0];\n            class == Memory\n@@ -79,7 +79,7 @@ impl ClassList for [RegClass] {\n     }\n \n     fn is_ret_bysret(&self) -> bool {\n-        if self.len() == 0 { return false; }\n+        if self.is_empty() { return false; }\n \n         self[0] == Memory\n     }"}, {"sha": "40cbb909fc15798c540b27fb67d0769246a5d375", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -2017,7 +2017,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        if self.fields.len() == 0 {\n+        if self.fields.is_empty() {\n             return Vec::new();\n         }\n \n@@ -2210,7 +2210,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             adt::Univariant(ref struct_def, _) => {\n                 assert!(self.variants.len() <= 1);\n \n-                if self.variants.len() == 0 {\n+                if self.variants.is_empty() {\n                     vec![]\n                 } else {\n                     let (variant_type_metadata,"}, {"sha": "e346fb0d93189a1b52ea245d54a6441b89df82c8", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -83,7 +83,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     for impl_item in impl_items {\n         match impl_item.node {\n             ast::MethodImplItem(ref sig, ref body) => {\n-                if sig.generics.ty_params.len() == 0 {\n+                if sig.generics.ty_params.is_empty() {\n                     let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, impl_item.id);"}, {"sha": "b3ab58e416f7414864745c3219fac86966982f53", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -69,7 +69,7 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return inputs.iter().cloned().collect()\n     }\n \n-    if inputs.len() == 0 {\n+    if inputs.is_empty() {\n         return Vec::new()\n     }\n "}, {"sha": "6d4b660f30d9ad2b905b13c72d72eaffc571569e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1125,7 +1125,7 @@ fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   span: Span)\n     -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n {\n-    if bounds.len() == 0 {\n+    if bounds.is_empty() {\n         span_err!(tcx.sess, span, E0220,\n                   \"associated type `{}` not found for `{}`\",\n                   assoc_name,\n@@ -2042,7 +2042,7 @@ fn compute_object_lifetime_bound<'tcx>(\n \n     // If there are no derived region bounds, then report back that we\n     // can find no region bound.\n-    if derived_region_bounds.len() == 0 {\n+    if derived_region_bounds.is_empty() {\n         match rscope.object_lifetime_default(span) {\n             Some(r) => { return r; }\n             None => {"}, {"sha": "0959f9d1b9154e4e2df4dcb30d1424e68b339938", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -594,7 +594,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             for (subpat, arg_ty) in subpats.iter().zip(arg_tys.iter()) {\n                 check_pat(pcx, &**subpat, *arg_ty);\n             }\n-        } else if arg_tys.len() == 0 {\n+        } else if arg_tys.is_empty() {\n             span_err!(tcx.sess, pat.span, E0024,\n                       \"this pattern has {} field{}, but the corresponding {} has no fields\",\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);"}, {"sha": "ded9b86e2352a100239d6511beaf0106c8f4d397", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -4719,7 +4719,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n            tps.len(), ppaux::ty_to_string(ccx.tcx, ty));\n \n     // make a vector of booleans initially false, set to true when used\n-    if tps.len() == 0 { return; }\n+    if tps.is_empty() { return; }\n     let mut tps_used: Vec<_> = repeat(false).take(tps.len()).collect();\n \n     ty::walk_ty(ty, |t| {"}, {"sha": "b0c994f7f6405500a582a480510210dcbfc923d4", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -387,7 +387,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         for &impl_did in &*trait_impls.borrow() {\n             let items = impl_items.get(&impl_did).unwrap();\n-            if items.len() < 1 {\n+            if items.is_empty() {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }"}, {"sha": "aa4052253667e78ddccb4922cddd95707af5a0fa", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1035,7 +1035,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     match struct_def.ctor_id {\n         None => {}\n         Some(ctor_id) => {\n-            if struct_def.fields.len() == 0 {\n+            if struct_def.fields.is_empty() {\n                 // Enum-like.\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n@@ -1893,7 +1893,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                   .flat_map(|predicate| {\n                       match *predicate {\n                           ast::WherePredicate::BoundPredicate(ref data) => {\n-                              if data.bound_lifetimes.len() == 0 &&\n+                              if data.bound_lifetimes.is_empty() &&\n                                   is_param(ccx.tcx, &data.bounded_ty, param_id)\n                               {\n                                   from_bounds(ccx, &data.bounds).into_iter()"}, {"sha": "ff364eb69a83bf4393276ae1361c51225ae5c11c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1820,7 +1820,7 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n         let kind = match self.arg_names.as_ref().map(|s| &**s) {\n-            None | Some([]) if self.args.len() == 0 => CLikeVariant,\n+            None | Some([]) if self.args.is_empty() => CLikeVariant,\n             None | Some([]) => {\n                 TupleVariant(self.args.clean(cx))\n             }\n@@ -1874,7 +1874,7 @@ impl Clean<VariantKind> for ast::VariantKind {\n     fn clean(&self, cx: &DocContext) -> VariantKind {\n         match self {\n             &ast::TupleVariantKind(ref args) => {\n-                if args.len() == 0 {\n+                if args.is_empty() {\n                     CLikeVariant\n                 } else {\n                     TupleVariant(args.iter().map(|x| x.ty.clean(cx)).collect())"}, {"sha": "5aded0215e9e6e3cc9fc8987bf3fd203cbeee277", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -94,7 +94,7 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n \n impl fmt::Display for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n+        if self.lifetimes.is_empty() && self.type_params.is_empty() { return Ok(()) }\n         try!(f.write_str(\"&lt;\"));\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n@@ -132,7 +132,7 @@ impl fmt::Display for clean::Generics {\n impl<'a> fmt::Display for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &WhereClause(gens) = self;\n-        if gens.where_predicates.len() == 0 {\n+        if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n         try!(f.write_str(\" <span class='where'>where \"));"}, {"sha": "a53884ca047d16325766712b06c302ea62d18b4d", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -130,7 +130,7 @@ r##\"<!DOCTYPE html>\n     content   = *t,\n     root_path = page.root_path,\n     ty        = page.ty,\n-    logo      = if layout.logo.len() == 0 {\n+    logo      = if layout.logo.is_empty() {\n         \"\".to_string()\n     } else {\n         format!(\"<a href='{}{}/index.html'>\\\n@@ -141,7 +141,7 @@ r##\"<!DOCTYPE html>\n     title     = page.title,\n     description = page.description,\n     keywords = page.keywords,\n-    favicon   = if layout.favicon.len() == 0 {\n+    favicon   = if layout.favicon.is_empty() {\n         \"\".to_string()\n     } else {\n         format!(r#\"<link rel=\"shortcut icon\" href=\"{}\">\"#, layout.favicon)\n@@ -152,7 +152,7 @@ r##\"<!DOCTYPE html>\n     sidebar   = *sidebar,\n     krate     = layout.krate,\n     play_url  = layout.playground_url,\n-    play_js   = if layout.playground_url.len() == 0 {\n+    play_js   = if layout.playground_url.is_empty() {\n         \"\".to_string()\n     } else {\n         format!(r#\"<script src=\"{}playpen.js\"></script>\"#, page.root_path)"}, {"sha": "334f05fb36fa8f0329766b8d8cd93a7827badc27", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -305,7 +305,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         let text = format!(r##\"<h{lvl} id=\"{id}\" class='section-header'><a\n                            href=\"#{id}\">{sec}{}</a></h{lvl}>\"##,\n                            s, lvl = level, id = id,\n-                           sec = if sec.len() == 0 {\n+                           sec = if sec.is_empty() {\n                                sec.to_string()\n                            } else {\n                                format!(\"{} \", sec)\n@@ -491,7 +491,7 @@ impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n-        if md.len() == 0 { return Ok(()) }\n+        if md.is_empty() { return Ok(()) }\n         render(fmt, md, false)\n     }\n }"}, {"sha": "5ee78bf836ee62486749daae4905d6adc6813aa6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -912,7 +912,7 @@ impl DocFolder for Cache {\n                      false)\n                 }\n                 clean::MethodItem(..) => {\n-                    if self.parent_stack.len() == 0 {\n+                    if self.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n                         let last = self.parent_stack.last().unwrap();\n@@ -1115,7 +1115,7 @@ impl Context {\n     fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n         F: FnOnce(&mut Context) -> T,\n     {\n-        if s.len() == 0 {\n+        if s.is_empty() {\n             panic!(\"Unexpected empty destination: {:?}\", self.current);\n         }\n         let prev = self.dst.clone();\n@@ -1343,7 +1343,7 @@ impl Context {\n     fn ignore_private_item(&self, it: &clean::Item) -> bool {\n         match it.inner {\n             clean::ModuleItem(ref m) => {\n-                (m.items.len() == 0 &&\n+                (m.items.is_empty() &&\n                  it.doc_value().is_none() &&\n                  it.visibility != Some(ast::Public)) ||\n                 (self.passes.contains(\"strip-private\") && it.visibility != Some(ast::Public))\n@@ -1690,7 +1690,7 @@ struct Initializer<'a>(&'a str);\n impl<'a> fmt::Display for Initializer<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Initializer(s) = *self;\n-        if s.len() == 0 { return Ok(()); }\n+        if s.is_empty() { return Ok(()); }\n         try!(write!(f, \"<code> = </code>\"));\n         write!(f, \"<code>{}</code>\", s)\n     }\n@@ -1766,7 +1766,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         match m.inner { clean::MethodItem(_) => true, _ => false }\n     }).collect::<Vec<_>>();\n \n-    if t.items.len() == 0 {\n+    if t.items.is_empty() {\n         try!(write!(w, \"{{ }}\"));\n     } else {\n         try!(write!(w, \"{{\\n\"));\n@@ -1986,7 +1986,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                   it.name.as_ref().unwrap(),\n                   e.generics,\n                   WhereClause(&e.generics)));\n-    if e.variants.len() == 0 && !e.variants_stripped {\n+    if e.variants.is_empty() && !e.variants_stripped {\n         try!(write!(w, \" {{}}\"));\n     } else {\n         try!(write!(w, \" {{\\n\"));"}, {"sha": "008da466db0105d29c0122d4a3befc477b3b1cad", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -219,7 +219,7 @@ pub fn main_args(args: &[String]) -> isize {\n         return 0;\n     }\n \n-    if matches.free.len() == 0 {\n+    if matches.free.is_empty() {\n         println!(\"expected an input file to act on\");\n         return 1;\n     } if matches.free.len() > 1 {"}, {"sha": "00de4e3ec53cf6ac458dfd2ab41813fed61d6f2d", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -74,7 +74,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     };\n \n     let (metadata, text) = extract_leading_metadata(&input_str);\n-    if metadata.len() == 0 {\n+    if metadata.is_empty() {\n         let _ = writeln!(&mut io::stderr(),\n                          \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n         return 5;"}, {"sha": "7b8241e9b5baa2ee6ddd87e82fbff5c15ddd346f", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -215,9 +215,9 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 match i.inner {\n                     // emptied modules/impls have no need to exist\n                     clean::ModuleItem(ref m)\n-                        if m.items.len() == 0 &&\n+                        if m.items.is_empty() &&\n                            i.doc_value().is_none() => None,\n-                    clean::ImplItem(ref i) if i.items.len() == 0 => None,\n+                    clean::ImplItem(ref i) if i.items.is_empty() => None,\n                     _ => {\n                         self.retained.insert(i.def_id.node);\n                         Some(i)"}, {"sha": "449f9c79d1d455ca2af8990383999add19e83e2f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -409,7 +409,7 @@ impl Collector {\n impl DocFolder for Collector {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         let pushed = match item.name {\n-            Some(ref name) if name.len() == 0 => false,\n+            Some(ref name) if name.is_empty() => false,\n             Some(ref name) => { self.names.push(name.to_string()); true }\n             None => false\n         };"}, {"sha": "e4f4dbaafbe49516a1307cf5c1770a5bba01bdb4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                      please_inline)\n                 }).collect::<Vec<ast::PathListItem>>();\n \n-                if mine.len() == 0 {\n+                if mine.is_empty() {\n                     None\n                 } else {\n                     Some(ast::ViewPathList(p, mine))"}, {"sha": "8f020d0857d7bcd17f8ef61bffb5330b91e202e8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -3837,7 +3837,7 @@ mod tests {\n         let mut stack = Stack::new();\n \n         assert!(stack.is_empty());\n-        assert!(stack.len() == 0);\n+        assert!(stack.is_empty());\n         assert!(!stack.last_is_index());\n \n         stack.push_index(0);"}, {"sha": "62c03389b24ae8e28c3c81097f899d07dfd44aa4", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -430,7 +430,7 @@ impl<T, S> HashSet<T, S>\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n+    pub fn is_empty(&self) -> bool { self.map.is_empty() }\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]"}, {"sha": "3d5c9867a6f9046f6d86015505f16d46670dbed0", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -381,7 +381,7 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> {\n         // it will be dropped entirely when parsed on the other end.\n         let arg_bytes = &arg.as_inner().inner.as_inner();\n         let quote = arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t')\n-            || arg_bytes.len() == 0;\n+            || arg_bytes.is_empty();\n         if quote {\n             cmd.push('\"' as u16);\n         }"}, {"sha": "f024a3139a611e8e3b200936f142ec1268fa5d6c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -652,7 +652,7 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if self.files.borrow().len() == 0 && sp == DUMMY_SP {\n+        if self.files.borrow().is_empty() && sp == DUMMY_SP {\n             return \"no-location\".to_string();\n         }\n "}, {"sha": "dcfc6b675e3c6a6e5736f2dcd31bc1e5915cec78", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -1248,7 +1248,7 @@ impl<'a> MethodDef<'a> {\n \n             match_arms.push(catch_all_match_arm);\n \n-        } else if variants.len() == 0 {\n+        } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler\n             // will accept `fn (a: &Self) { match   *a   { } }`"}, {"sha": "2ca74644b3bfd01a6c5cd5151792ab19d6e0ceb5", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -65,7 +65,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n-        Some(ref exprs) if exprs.len() == 0 => {\n+        Some(ref exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::expr(sp);\n         }"}, {"sha": "74ec219af15409503ac1f16f38a2c765350ba88c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -841,7 +841,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // expand pats... they might contain macro uses:\n     let expanded_pats = arm.pats.move_map(|pat| fld.fold_pat(pat));\n-    if expanded_pats.len() == 0 {\n+    if expanded_pats.is_empty() {\n         panic!(\"encountered match arm with 0 patterns\");\n     }\n     // all of the pats must have the same set of bindings, so use the\n@@ -1887,7 +1887,7 @@ mod test {\n             let binding_name = mtwt::resolve(bindings[binding_idx]);\n             let binding_marks = mtwt::marksof(bindings[binding_idx].ctxt, invalid_name);\n             // shouldmatch can't name varrefs that don't exist:\n-            assert!((shouldmatch.len() == 0) ||\n+            assert!((shouldmatch.is_empty()) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n             for (idx,varref) in varrefs.iter().enumerate() {\n                 let print_hygiene_debug_info = || {"}, {"sha": "dcbf3c2c892805c41ce2cfe3e4ebd59fe245f2d7", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -472,7 +472,7 @@ pub fn parse(sess: &ParseSess,\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\",\n                     nts, next_eis.len()).to_string());\n-            } else if bb_eis.len() == 0 && next_eis.len() == 0 {\n+            } else if bb_eis.is_empty() && next_eis.is_empty() {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n                             pprust::token_to_string(&tok)).to_string());\n             } else if next_eis.len() > 0 {"}, {"sha": "fe5fbdccf6121e6cfda80ead452a4ca51526aaa8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -449,7 +449,7 @@ impl<'a> Parser<'a> {\n                     (format!(\"expected one of {}, found `{}`\",\n                              expect,\n                              actual))\n-                } else if expected.len() == 0 {\n+                } else if expected.is_empty() {\n                     (format!(\"unexpected token: `{}`\",\n                              actual))\n                 } else {\n@@ -1244,7 +1244,7 @@ impl<'a> Parser<'a> {\n \n         // In type grammar, `+` is treated like a binary operator,\n         // and hence both L and R side are required.\n-        if bounds.len() == 0 {\n+        if bounds.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n                           \"at least one type parameter bound \\\n@@ -2191,7 +2191,7 @@ impl<'a> Parser<'a> {\n                                                  &[token::CloseDelim(token::Brace)]));\n                             }\n \n-                            if fields.len() == 0 && base.is_none() {\n+                            if fields.is_empty() && base.is_none() {\n                                 let last_span = self.last_span;\n                                 self.span_err(last_span,\n                                               \"structure literal must either \\\n@@ -3914,7 +3914,7 @@ impl<'a> Parser<'a> {\n                         let hi = self.span.hi;\n                         let span = mk_sp(lo, hi);\n \n-                        if bounds.len() == 0 {\n+                        if bounds.is_empty() {\n                             self.span_err(span,\n                                           \"each predicate in a `where` clause must have \\\n                                            at least one bound in it\");\n@@ -4572,7 +4572,7 @@ impl<'a> Parser<'a> {\n                 fields.push(try!(self.parse_struct_decl_field(true)));\n             }\n \n-            if fields.len() == 0 {\n+            if fields.is_empty() {\n                 return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n                     token::get_ident(class_name.clone()))));\n@@ -4611,7 +4611,7 @@ impl<'a> Parser<'a> {\n                     Ok(spanned(lo, p.span.hi, struct_field_))\n                 }));\n \n-            if fields.len() == 0 {\n+            if fields.is_empty() {\n                 return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n                     token::get_ident(class_name.clone()))));\n@@ -5023,7 +5023,7 @@ impl<'a> Parser<'a> {\n                 all_nullary = false;\n                 let start_span = self.span;\n                 let struct_def = try!(self.parse_struct_def());\n-                if struct_def.fields.len() == 0 {\n+                if struct_def.fields.is_empty() {\n                     self.span_err(start_span,\n                         &format!(\"unit-like struct variant should be written \\\n                                  without braces, as `{},`\","}, {"sha": "0e9b471393bd18b94068e601307e04327a4499d3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -2546,7 +2546,7 @@ impl<'a> State<'a> {\n \n     pub fn print_where_clause(&mut self, where_clause: &ast::WhereClause)\n                               -> io::Result<()> {\n-        if where_clause.predicates.len() == 0 {\n+        if where_clause.predicates.is_empty() {\n             return Ok(())\n         }\n "}, {"sha": "16062060df087d90d5d349b48c0761b7ceadb3e6", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -20,7 +20,7 @@ use std::path::PathBuf;\n /// Return path to database entry for `term`\n #[allow(deprecated)]\n pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n-    if term.len() == 0 {\n+    if term.is_empty() {\n         return None;\n     }\n "}, {"sha": "701187ed35a6f7c9573c7dcfb6706907eb6b5e61", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -157,7 +157,7 @@ impl<'a> Iterator for Graphemes<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         use tables::grapheme as gr;\n-        if self.string.len() == 0 {\n+        if self.string.is_empty() {\n             return None;\n         }\n \n@@ -257,7 +257,7 @@ impl<'a> DoubleEndedIterator for Graphemes<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         use tables::grapheme as gr;\n-        if self.string.len() == 0 {\n+        if self.string.is_empty() {\n             return None;\n         }\n "}, {"sha": "b777b25243ba6e8b1b48a778e03b640913982721", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -184,7 +184,7 @@ fn main() {\n    for line in rdr.lines() {\n        let line = line.unwrap().trim().to_string();\n \n-       if line.len() == 0 { continue; }\n+       if line.is_empty() { continue; }\n \n        match (line.as_bytes()[0] as char, proc_mode) {\n "}, {"sha": "de7fb737958f2a1f3434b205aa411fe218d10471", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -196,7 +196,7 @@ fn shift_mut_ref<'a, T>(r: &mut &'a mut [T]) -> Option<&'a mut T> {\n     use std::mem;\n     use std::raw::Repr;\n \n-    if r.len() == 0 { return None }\n+    if r.is_empty() { return None }\n     unsafe {\n         let mut raw = r.repr();\n         let ret = raw.data as *mut T;"}, {"sha": "c5da5fc0c1a5e620fff5a1bf5e7e608ac3d331fe", "filename": "src/test/run-pass/dst-struct-sole.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -79,7 +79,7 @@ pub fn main() {\n \n     // Zero size vec.\n     let f5: &Fat<[isize]> = &Fat { ptr: [] };\n-    assert!(f5.ptr.len() == 0);\n+    assert!(f5.ptr.is_empty());\n     let f5: &Fat<[Bar]> = &Fat { ptr: [] };\n-    assert!(f5.ptr.len() == 0);\n+    assert!(f5.ptr.is_empty());\n }"}, {"sha": "92253d815958d0e223c869b182fdeb51e6c6e2bd", "filename": "src/test/run-pass/dst-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac04402d53d358a1f6200bea45a301ff05b2d1/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct.rs?ref=29ac04402d53d358a1f6200bea45a301ff05b2d1", "patch": "@@ -98,9 +98,9 @@ pub fn main() {\n \n     // Zero size vec.\n     let f5: &Fat<[isize]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n-    assert!(f5.ptr.len() == 0);\n+    assert!(f5.ptr.is_empty());\n     let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n-    assert!(f5.ptr.len() == 0);\n+    assert!(f5.ptr.is_empty());\n \n     // Deeply nested.\n     let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };"}]}