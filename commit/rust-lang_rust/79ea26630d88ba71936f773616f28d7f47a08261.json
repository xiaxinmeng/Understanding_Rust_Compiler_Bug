{"sha": "79ea26630d88ba71936f773616f28d7f47a08261", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZWEyNjYzMGQ4OGJhNzE5MzZmNzczNjE2ZjI4ZDdmNDdhMDgyNjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-06T01:17:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-02T00:43:54Z"}, "message": "move docs into doc.rs", "tree": {"sha": "4c49f349b8b00762f46d10266e27de4521279d0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c49f349b8b00762f46d10266e27de4521279d0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79ea26630d88ba71936f773616f28d7f47a08261", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79ea26630d88ba71936f773616f28d7f47a08261", "html_url": "https://github.com/rust-lang/rust/commit/79ea26630d88ba71936f773616f28d7f47a08261", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79ea26630d88ba71936f773616f28d7f47a08261/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42344af71381b7f45de3570e322eaaee59d83229", "url": "https://api.github.com/repos/rust-lang/rust/commits/42344af71381b7f45de3570e322eaaee59d83229", "html_url": "https://github.com/rust-lang/rust/commit/42344af71381b7f45de3570e322eaaee59d83229"}], "stats": {"total": 468, "additions": 235, "deletions": 233}, "files": [{"sha": "16d0f2cc18b02af778275fa4ed24cf41c7d24d4a", "filename": "src/librustc/middle/typeck/infer/doc.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/79ea26630d88ba71936f773616f28d7f47a08261/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ea26630d88ba71936f773616f28d7f47a08261/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs?ref=79ea26630d88ba71936f773616f28d7f47a08261", "patch": "@@ -0,0 +1,233 @@\n+/*!\n+\n+# Type inference engine\n+\n+This is loosely based on standard HM-type inference, but with an\n+extension to try and accommodate subtyping.  There is nothing\n+principled about this extension; it's sound---I hope!---but it's a\n+heuristic, ultimately, and does not guarantee that it finds a valid\n+typing even if one exists (in fact, there are known scenarios where it\n+fails, some of which may eventually become problematic).\n+\n+## Key idea\n+\n+The main change is that each type variable T is associated with a\n+lower-bound L and an upper-bound U.  L and U begin as bottom and top,\n+respectively, but gradually narrow in response to new constraints\n+being introduced.  When a variable is finally resolved to a concrete\n+type, it can (theoretically) select any type that is a supertype of L\n+and a subtype of U.\n+\n+There are several critical invariants which we maintain:\n+\n+- the upper-bound of a variable only becomes lower and the lower-bound\n+  only becomes higher over time;\n+- the lower-bound L is always a subtype of the upper bound U;\n+- the lower-bound L and upper-bound U never refer to other type variables,\n+  but only to types (though those types may contain type variables).\n+\n+> An aside: if the terms upper- and lower-bound confuse you, think of\n+> \"supertype\" and \"subtype\".  The upper-bound is a \"supertype\"\n+> (super=upper in Latin, or something like that anyway) and the lower-bound\n+> is a \"subtype\" (sub=lower in Latin).  I find it helps to visualize\n+> a simple class hierarchy, like Java minus interfaces and\n+> primitive types.  The class Object is at the root (top) and other\n+> types lie in between.  The bottom type is then the Null type.\n+> So the tree looks like:\n+>\n+>             Object\n+>             /    \\\n+>         String   Other\n+>             \\    /\n+>             (null)\n+>\n+> So the upper bound type is the \"supertype\" and the lower bound is the\n+> \"subtype\" (also, super and sub mean upper and lower in Latin, or something\n+> like that anyway).\n+\n+## Satisfying constraints\n+\n+At a primitive level, there is only one form of constraint that the\n+inference understands: a subtype relation.  So the outside world can\n+say \"make type A a subtype of type B\".  If there are variables\n+involved, the inferencer will adjust their upper- and lower-bounds as\n+needed to ensure that this relation is satisfied. (We also allow \"make\n+type A equal to type B\", but this is translated into \"A <: B\" and \"B\n+<: A\")\n+\n+As stated above, we always maintain the invariant that type bounds\n+never refer to other variables.  This keeps the inference relatively\n+simple, avoiding the scenario of having a kind of graph where we have\n+to pump constraints along and reach a fixed point, but it does impose\n+some heuristics in the case where the user is relating two type\n+variables A <: B.\n+\n+Combining two variables such that variable A will forever be a subtype\n+of variable B is the trickiest part of the algorithm because there is\n+often no right choice---that is, the right choice will depend on\n+future constraints which we do not yet know. The problem comes about\n+because both A and B have bounds that can be adjusted in the future.\n+Let's look at some of the cases that can come up.\n+\n+Imagine, to start, the best case, where both A and B have an upper and\n+lower bound (that is, the bounds are not top nor bot respectively). In\n+that case, if we're lucky, A.ub <: B.lb, and so we know that whatever\n+A and B should become, they will forever have the desired subtyping\n+relation.  We can just leave things as they are.\n+\n+### Option 1: Unify\n+\n+However, suppose that A.ub is *not* a subtype of B.lb.  In\n+that case, we must make a decision.  One option is to unify A\n+and B so that they are one variable whose bounds are:\n+\n+    UB = GLB(A.ub, B.ub)\n+    LB = LUB(A.lb, B.lb)\n+\n+(Note that we will have to verify that LB <: UB; if it does not, the\n+types are not intersecting and there is an error) In that case, A <: B\n+holds trivially because A==B.  However, we have now lost some\n+flexibility, because perhaps the user intended for A and B to end up\n+as different types and not the same type.\n+\n+Pictorally, what this does is to take two distinct variables with\n+(hopefully not completely) distinct type ranges and produce one with\n+the intersection.\n+\n+                      B.ub                  B.ub\n+                       /\\                    /\n+               A.ub   /  \\           A.ub   /\n+               /   \\ /    \\              \\ /\n+              /     X      \\              UB\n+             /     / \\      \\            / \\\n+            /     /   /      \\          /   /\n+            \\     \\  /       /          \\  /\n+             \\      X       /             LB\n+              \\    / \\     /             / \\\n+               \\  /   \\   /             /   \\\n+               A.lb    B.lb          A.lb    B.lb\n+\n+\n+### Option 2: Relate UB/LB\n+\n+Another option is to keep A and B as distinct variables but set their\n+bounds in such a way that, whatever happens, we know that A <: B will hold.\n+This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n+are two ways to do that, depicted pictorally here:\n+\n+        Before                Option #1            Option #2\n+\n+                 B.ub                B.ub                B.ub\n+                  /\\                 /  \\                /  \\\n+          A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n+          /   \\ /    \\           \\ /     /           \\ /     /\n+         /     X      \\         __UB____/             UB    /\n+        /     / \\      \\       /  |                   |    /\n+       /     /   /      \\     /   |                   |   /\n+       \\     \\  /       /    /(A')|                   |  /\n+        \\      X       /    /     LB            ______LB/\n+         \\    / \\     /    /     / \\           / (A')/ \\\n+          \\  /   \\   /     \\    /   \\          \\    /   \\\n+          A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n+\n+In these diagrams, UB and LB are defined as before.  As you can see,\n+the new ranges `A'` and `B'` are quite different from the range that\n+would be produced by unifying the variables.\n+\n+### What we do now\n+\n+Our current technique is to *try* (transactionally) to relate the\n+existing bounds of A and B, if there are any (i.e., if `UB(A) != top\n+&& LB(B) != bot`).  If that succeeds, we're done.  If it fails, then\n+we merge A and B into same variable.\n+\n+This is not clearly the correct course.  For example, if `UB(A) !=\n+top` but `LB(B) == bot`, we could conceivably set `LB(B)` to `UB(A)`\n+and leave the variables unmerged.  This is sometimes the better\n+course, it depends on the program.\n+\n+The main case which fails today that I would like to support is:\n+\n+    fn foo<T>(x: T, y: T) { ... }\n+\n+    fn bar() {\n+        let x: @mut int = @mut 3;\n+        let y: @int = @3;\n+        foo(x, y);\n+    }\n+\n+In principle, the inferencer ought to find that the parameter `T` to\n+`foo(x, y)` is `@const int`.  Today, however, it does not; this is\n+because the type variable `T` is merged with the type variable for\n+`X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n+flexibility for `T` to later adjust to accommodate `@int`.\n+\n+### What to do when not all bounds are present\n+\n+In the prior discussion we assumed that A.ub was not top and B.lb was\n+not bot.  Unfortunately this is rarely the case.  Often type variables\n+have \"lopsided\" bounds.  For example, if a variable in the program has\n+been initialized but has not been used, then its corresponding type\n+variable will have a lower bound but no upper bound.  When that\n+variable is then used, we would like to know its upper bound---but we\n+don't have one!  In this case we'll do different things depending on\n+how the variable is being used.\n+\n+## Transactional support\n+\n+Whenever we adjust merge variables or adjust their bounds, we always\n+keep a record of the old value.  This allows the changes to be undone.\n+\n+## Regions\n+\n+I've only talked about type variables here, but region variables\n+follow the same principle.  They have upper- and lower-bounds.  A\n+region A is a subregion of a region B if A being valid implies that B\n+is valid.  This basically corresponds to the block nesting structure:\n+the regions for outer block scopes are superregions of those for inner\n+block scopes.\n+\n+## Integral and floating-point type variables\n+\n+There is a third variety of type variable that we use only for\n+inferring the types of unsuffixed integer literals.  Integral type\n+variables differ from general-purpose type variables in that there's\n+no subtyping relationship among the various integral types, so instead\n+of associating each variable with an upper and lower bound, we just\n+use simple unification.  Each integer variable is associated with at\n+most one integer type.  Floating point types are handled similarly to\n+integral types.\n+\n+## GLB/LUB\n+\n+Computing the greatest-lower-bound and least-upper-bound of two\n+types/regions is generally straightforward except when type variables\n+are involved. In that case, we follow a similar \"try to use the bounds\n+when possible but otherwise merge the variables\" strategy.  In other\n+words, `GLB(A, B)` where `A` and `B` are variables will often result\n+in `A` and `B` being merged and the result being `A`.\n+\n+## Type coercion\n+\n+We have a notion of assignability which differs somewhat from\n+subtyping; in particular it may cause region borrowing to occur.  See\n+the big comment later in this file on Type Coercion for specifics.\n+\n+### In conclusion\n+\n+I showed you three ways to relate `A` and `B`.  There are also more,\n+of course, though I'm not sure if there are any more sensible options.\n+The main point is that there are various options, each of which\n+produce a distinct range of types for `A` and `B`.  Depending on what\n+the correct values for A and B are, one of these options will be the\n+right choice: but of course we don't know the right values for A and B\n+yet, that's what we're trying to find!  In our code, we opt to unify\n+(Option #1).\n+\n+# Implementation details\n+\n+We make use of a trait-like impementation strategy to consolidate\n+duplicated code between subtypes, GLB, and LUB computations.  See the\n+section on \"Type Combining\" below for details.\n+\n+*/\n\\ No newline at end of file"}, {"sha": "caeb65765c6236e0b7f1b22981c7e27abfc4ffd9", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 233, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/79ea26630d88ba71936f773616f28d7f47a08261/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ea26630d88ba71936f773616f28d7f47a08261/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=79ea26630d88ba71936f773616f28d7f47a08261", "patch": "@@ -8,239 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-# Type inference engine\n-\n-This is loosely based on standard HM-type inference, but with an\n-extension to try and accommodate subtyping.  There is nothing\n-principled about this extension; it's sound---I hope!---but it's a\n-heuristic, ultimately, and does not guarantee that it finds a valid\n-typing even if one exists (in fact, there are known scenarios where it\n-fails, some of which may eventually become problematic).\n-\n-## Key idea\n-\n-The main change is that each type variable T is associated with a\n-lower-bound L and an upper-bound U.  L and U begin as bottom and top,\n-respectively, but gradually narrow in response to new constraints\n-being introduced.  When a variable is finally resolved to a concrete\n-type, it can (theoretically) select any type that is a supertype of L\n-and a subtype of U.\n-\n-There are several critical invariants which we maintain:\n-\n-- the upper-bound of a variable only becomes lower and the lower-bound\n-  only becomes higher over time;\n-- the lower-bound L is always a subtype of the upper bound U;\n-- the lower-bound L and upper-bound U never refer to other type variables,\n-  but only to types (though those types may contain type variables).\n-\n-> An aside: if the terms upper- and lower-bound confuse you, think of\n-> \"supertype\" and \"subtype\".  The upper-bound is a \"supertype\"\n-> (super=upper in Latin, or something like that anyway) and the lower-bound\n-> is a \"subtype\" (sub=lower in Latin).  I find it helps to visualize\n-> a simple class hierarchy, like Java minus interfaces and\n-> primitive types.  The class Object is at the root (top) and other\n-> types lie in between.  The bottom type is then the Null type.\n-> So the tree looks like:\n->\n->             Object\n->             /    \\\n->         String   Other\n->             \\    /\n->             (null)\n->\n-> So the upper bound type is the \"supertype\" and the lower bound is the\n-> \"subtype\" (also, super and sub mean upper and lower in Latin, or something\n-> like that anyway).\n-\n-## Satisfying constraints\n-\n-At a primitive level, there is only one form of constraint that the\n-inference understands: a subtype relation.  So the outside world can\n-say \"make type A a subtype of type B\".  If there are variables\n-involved, the inferencer will adjust their upper- and lower-bounds as\n-needed to ensure that this relation is satisfied. (We also allow \"make\n-type A equal to type B\", but this is translated into \"A <: B\" and \"B\n-<: A\")\n-\n-As stated above, we always maintain the invariant that type bounds\n-never refer to other variables.  This keeps the inference relatively\n-simple, avoiding the scenario of having a kind of graph where we have\n-to pump constraints along and reach a fixed point, but it does impose\n-some heuristics in the case where the user is relating two type\n-variables A <: B.\n-\n-Combining two variables such that variable A will forever be a subtype\n-of variable B is the trickiest part of the algorithm because there is\n-often no right choice---that is, the right choice will depend on\n-future constraints which we do not yet know. The problem comes about\n-because both A and B have bounds that can be adjusted in the future.\n-Let's look at some of the cases that can come up.\n-\n-Imagine, to start, the best case, where both A and B have an upper and\n-lower bound (that is, the bounds are not top nor bot respectively). In\n-that case, if we're lucky, A.ub <: B.lb, and so we know that whatever\n-A and B should become, they will forever have the desired subtyping\n-relation.  We can just leave things as they are.\n-\n-### Option 1: Unify\n-\n-However, suppose that A.ub is *not* a subtype of B.lb.  In\n-that case, we must make a decision.  One option is to unify A\n-and B so that they are one variable whose bounds are:\n-\n-    UB = GLB(A.ub, B.ub)\n-    LB = LUB(A.lb, B.lb)\n-\n-(Note that we will have to verify that LB <: UB; if it does not, the\n-types are not intersecting and there is an error) In that case, A <: B\n-holds trivially because A==B.  However, we have now lost some\n-flexibility, because perhaps the user intended for A and B to end up\n-as different types and not the same type.\n-\n-Pictorally, what this does is to take two distinct variables with\n-(hopefully not completely) distinct type ranges and produce one with\n-the intersection.\n-\n-                      B.ub                  B.ub\n-                       /\\                    /\n-               A.ub   /  \\           A.ub   /\n-               /   \\ /    \\              \\ /\n-              /     X      \\              UB\n-             /     / \\      \\            / \\\n-            /     /   /      \\          /   /\n-            \\     \\  /       /          \\  /\n-             \\      X       /             LB\n-              \\    / \\     /             / \\\n-               \\  /   \\   /             /   \\\n-               A.lb    B.lb          A.lb    B.lb\n-\n-\n-### Option 2: Relate UB/LB\n-\n-Another option is to keep A and B as distinct variables but set their\n-bounds in such a way that, whatever happens, we know that A <: B will hold.\n-This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n-are two ways to do that, depicted pictorally here:\n-\n-        Before                Option #1            Option #2\n-\n-                 B.ub                B.ub                B.ub\n-                  /\\                 /  \\                /  \\\n-          A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n-          /   \\ /    \\           \\ /     /           \\ /     /\n-         /     X      \\         __UB____/             UB    /\n-        /     / \\      \\       /  |                   |    /\n-       /     /   /      \\     /   |                   |   /\n-       \\     \\  /       /    /(A')|                   |  /\n-        \\      X       /    /     LB            ______LB/\n-         \\    / \\     /    /     / \\           / (A')/ \\\n-          \\  /   \\   /     \\    /   \\          \\    /   \\\n-          A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n-\n-In these diagrams, UB and LB are defined as before.  As you can see,\n-the new ranges `A'` and `B'` are quite different from the range that\n-would be produced by unifying the variables.\n-\n-### What we do now\n-\n-Our current technique is to *try* (transactionally) to relate the\n-existing bounds of A and B, if there are any (i.e., if `UB(A) != top\n-&& LB(B) != bot`).  If that succeeds, we're done.  If it fails, then\n-we merge A and B into same variable.\n-\n-This is not clearly the correct course.  For example, if `UB(A) !=\n-top` but `LB(B) == bot`, we could conceivably set `LB(B)` to `UB(A)`\n-and leave the variables unmerged.  This is sometimes the better\n-course, it depends on the program.\n-\n-The main case which fails today that I would like to support is:\n-\n-    fn foo<T>(x: T, y: T) { ... }\n-\n-    fn bar() {\n-        let x: @mut int = @mut 3;\n-        let y: @int = @3;\n-        foo(x, y);\n-    }\n-\n-In principle, the inferencer ought to find that the parameter `T` to\n-`foo(x, y)` is `@const int`.  Today, however, it does not; this is\n-because the type variable `T` is merged with the type variable for\n-`X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n-flexibility for `T` to later adjust to accommodate `@int`.\n-\n-### What to do when not all bounds are present\n-\n-In the prior discussion we assumed that A.ub was not top and B.lb was\n-not bot.  Unfortunately this is rarely the case.  Often type variables\n-have \"lopsided\" bounds.  For example, if a variable in the program has\n-been initialized but has not been used, then its corresponding type\n-variable will have a lower bound but no upper bound.  When that\n-variable is then used, we would like to know its upper bound---but we\n-don't have one!  In this case we'll do different things depending on\n-how the variable is being used.\n-\n-## Transactional support\n-\n-Whenever we adjust merge variables or adjust their bounds, we always\n-keep a record of the old value.  This allows the changes to be undone.\n-\n-## Regions\n-\n-I've only talked about type variables here, but region variables\n-follow the same principle.  They have upper- and lower-bounds.  A\n-region A is a subregion of a region B if A being valid implies that B\n-is valid.  This basically corresponds to the block nesting structure:\n-the regions for outer block scopes are superregions of those for inner\n-block scopes.\n-\n-## Integral and floating-point type variables\n-\n-There is a third variety of type variable that we use only for\n-inferring the types of unsuffixed integer literals.  Integral type\n-variables differ from general-purpose type variables in that there's\n-no subtyping relationship among the various integral types, so instead\n-of associating each variable with an upper and lower bound, we just\n-use simple unification.  Each integer variable is associated with at\n-most one integer type.  Floating point types are handled similarly to\n-integral types.\n-\n-## GLB/LUB\n-\n-Computing the greatest-lower-bound and least-upper-bound of two\n-types/regions is generally straightforward except when type variables\n-are involved. In that case, we follow a similar \"try to use the bounds\n-when possible but otherwise merge the variables\" strategy.  In other\n-words, `GLB(A, B)` where `A` and `B` are variables will often result\n-in `A` and `B` being merged and the result being `A`.\n-\n-## Type coercion\n-\n-We have a notion of assignability which differs somewhat from\n-subtyping; in particular it may cause region borrowing to occur.  See\n-the big comment later in this file on Type Coercion for specifics.\n-\n-### In conclusion\n-\n-I showed you three ways to relate `A` and `B`.  There are also more,\n-of course, though I'm not sure if there are any more sensible options.\n-The main point is that there are various options, each of which\n-produce a distinct range of types for `A` and `B`.  Depending on what\n-the correct values for A and B are, one of these options will be the\n-right choice: but of course we don't know the right values for A and B\n-yet, that's what we're trying to find!  In our code, we opt to unify\n-(Option #1).\n-\n-# Implementation details\n-\n-We make use of a trait-like impementation strategy to consolidate\n-duplicated code between subtypes, GLB, and LUB computations.  See the\n-section on \"Type Combining\" below for details.\n-\n-*/\n+/*! See doc.rs for documentation */\n \n \n pub use middle::ty::IntVarValue;\n@@ -277,6 +45,7 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::span;\n \n+pub mod doc;\n pub mod macros;\n pub mod combine;\n pub mod glb;"}]}