{"sha": "65b75788517ad797c1ae86f9d0c550ec620c4dfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1Yjc1Nzg4NTE3YWQ3OTdjMWFlODZmOWQwYzU1MGVjNjIwYzRkZmM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-09T04:27:54Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-14T18:24:25Z"}, "message": "rustc: Remove generalize_ty. Instead, maintain an explicit type parameter substitution list.", "tree": {"sha": "31fed8460b11b6deea72485d60f606a4c4ab8327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31fed8460b11b6deea72485d60f606a4c4ab8327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65b75788517ad797c1ae86f9d0c550ec620c4dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65b75788517ad797c1ae86f9d0c550ec620c4dfc", "html_url": "https://github.com/rust-lang/rust/commit/65b75788517ad797c1ae86f9d0c550ec620c4dfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65b75788517ad797c1ae86f9d0c550ec620c4dfc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec5a60d5e26c9d38755e66660d7913e42f42a1b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5a60d5e26c9d38755e66660d7913e42f42a1b3", "html_url": "https://github.com/rust-lang/rust/commit/ec5a60d5e26c9d38755e66660d7913e42f42a1b3"}], "stats": {"total": 906, "additions": 548, "deletions": 358}, "files": [{"sha": "13f3792812e9f306d8cd34e528c1e23627d88c8a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=65b75788517ad797c1ae86f9d0c550ec620c4dfc", "patch": "@@ -742,6 +742,10 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n         case (ty.ty_param(_)) {\n             llty = T_i8();\n         }\n+        case (ty.ty_bound_param(_)) {\n+            log \"ty_bound_param in trans.type_of\";\n+            fail;\n+        }\n         case (ty.ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n     }\n \n@@ -1144,6 +1148,7 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n         auto tup_ty = ty.plain_tup_ty(args);\n \n         // Perform any type parameter substitutions.\n+        tup_ty = ty.bind_params_in_type(tup_ty);\n         tup_ty = ty.substitute_type_params(subtys, tup_ty);\n \n         // Here we possibly do a recursive call.\n@@ -1216,7 +1221,8 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n                 let vec[@ty.t] raw_tys = variant.args;\n                 let vec[@ty.t] tys = vec();\n                 for (@ty.t raw_ty in raw_tys) {\n-                    auto t = ty.substitute_type_params(tps, raw_ty);\n+                    auto t = ty.bind_params_in_type(raw_ty);\n+                    t = ty.substitute_type_params(tps, t);\n                     tys += vec(t);\n                 }\n \n@@ -1390,7 +1396,8 @@ fn GEP_tag(@block_ctxt cx,\n     auto i = 0;\n     let vec[@ty.t] true_arg_tys = vec();\n     for (@ty.t aty in arg_tys) {\n-        auto arg_ty = ty.substitute_type_params(ty_substs, aty);\n+        auto arg_ty = ty.bind_params_in_type(aty);\n+        arg_ty = ty.substitute_type_params(ty_substs, arg_ty);\n         true_arg_tys += vec(arg_ty);\n         if (i == ix) {\n             elem_ty = arg_ty;\n@@ -2118,8 +2125,9 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n-                                auto ty_subst =\n-                                    ty.substitute_type_params(tps, a.ty);\n+                                auto ty_subst = ty.bind_params_in_type(a.ty);\n+                                ty_subst =\n+                                    ty.substitute_type_params(tps, ty_subst);\n \n                                 auto llfld_a =\n                                     load_if_immediate(variant_cx,\n@@ -2501,15 +2509,10 @@ fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     ret t;\n }\n \n+\n+// Converts an annotation to a type\n fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @ty.t {\n-    alt (a) {\n-        case (ast.ann_none) {\n-            cx.sess.bug(\"missing type annotation\");\n-        }\n-        case (ast.ann_type(?t, _, _)) {\n-            ret target_type(cx, t);\n-        }\n-    }\n+    ret target_type(cx, ty.ann_to_monotype(a));\n }\n \n fn node_ann_ty_params(&ast.ann a) -> vec[@ty.t] {"}, {"sha": "ccbf766607b9836d54464fb2a0e6dae088d53777", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 222, "deletions": 93, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=65b75788517ad797c1ae86f9d0c550ec620c4dfc", "patch": "@@ -15,6 +15,7 @@ import front.creader;\n import util.common;\n import util.common.new_def_hash;\n import util.common.span;\n+import util.typestate_ann.ts_ann;\n \n // Data types\n \n@@ -59,6 +60,7 @@ tag sty {\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n     ty_param(uint);                                 // fn/tag type param\n+    ty_bound_param(uint);                           // bound param, only paths\n     ty_type;\n     ty_native;\n     // TODO: ty_fn_arg(@t), for a possibly-aliased function argument\n@@ -67,10 +69,9 @@ tag sty {\n // Data structures used in type unification\n \n type unify_handler = obj {\n-    fn resolve_local(ast.def_id id) -> @t;\n-    fn record_local(ast.def_id id, @t ty);\n-    fn unify_expected_param(uint id, @t expected, @t actual) -> unify_result;\n-    fn unify_actual_param(uint id, @t expected, @t actual) -> unify_result;\n+    fn resolve_local(ast.def_id id) -> option.t[@t];\n+    fn record_local(ast.def_id id, @t ty);  // TODO: -> unify_result\n+    fn record_param(uint index, @t binding) -> unify_result;\n };\n \n tag type_err {\n@@ -249,6 +250,10 @@ fn ty_to_str(&@t typ) -> str {\n         case (ty_param(?id)) {\n             s += \"'\" + _str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n         }\n+\n+        case (ty_bound_param(?id)) {\n+            s += \"''\" + _str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n+        }\n     }\n \n     ret s;\n@@ -341,9 +346,10 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n             }\n             ret rewrap(ty, ty_obj(new_methods));\n         }\n-        case (ty_var(_))        { ret fld.fold_simple_ty(ty); }\n-        case (ty_local(_))      { ret fld.fold_simple_ty(ty); }\n-        case (ty_param(_))      { ret fld.fold_simple_ty(ty); }\n+        case (ty_var(_))         { ret fld.fold_simple_ty(ty); }\n+        case (ty_local(_))       { ret fld.fold_simple_ty(ty); }\n+        case (ty_param(_))       { ret fld.fold_simple_ty(ty); }\n+        case (ty_bound_param(_)) { ret fld.fold_simple_ty(ty); }\n     }\n \n     fail;\n@@ -603,6 +609,50 @@ fn ann_to_type(&ast.ann ann) -> @t {\n     }\n }\n \n+fn ann_to_type_params(&ast.ann ann) -> vec[@t] {\n+    alt (ann) {\n+        case (ast.ann_none) {\n+            log \"ann_to_type_params() called on node with no type params\";\n+            fail;\n+        }\n+        case (ast.ann_type(_, ?tps, _)) {\n+            alt (tps) {\n+                case (none[vec[@ty.t]]) {\n+                    let vec[@t] result = vec();\n+                    ret result;\n+                }\n+                case (some[vec[@ty.t]](?tps)) { ret tps; }\n+            }\n+        }\n+    }\n+}\n+\n+// Returns the type of an annotation, with type parameter substitutions\n+// performed if applicable.\n+fn ann_to_monotype(ast.ann a) -> @ty.t {\n+    // TODO: Refactor to use recursive pattern matching when we're more\n+    // confident that it works.\n+    alt (a) {\n+        case (ast.ann_none) {\n+            log \"ann_to_monotype() called on expression with no type!\";\n+            fail;\n+        }\n+        case (ast.ann_type(?typ, ?tps_opt, _)) {\n+            alt (tps_opt) {\n+                case (none[vec[@ty.t]]) { ret typ; }\n+                case (some[vec[@ty.t]](?tps)) {\n+                    ret substitute_type_params(tps, typ);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Turns a type into an ann_type, using defaults for other fields.\n+fn triv_ann(@ty.t typ) -> ast.ann {\n+    ret ast.ann_type(typ, none[vec[@ty.t]], none[@ts_ann]);\n+}\n+\n // Returns the number of distinct type parameters in the given type.\n fn count_ty_params(@t ty) -> uint {\n     state obj ty_param_counter(@mutable vec[uint] param_indices) {\n@@ -631,6 +681,22 @@ fn count_ty_params(@t ty) -> uint {\n     ret _vec.len[uint](*param_indices);\n }\n \n+fn type_contains_vars(@t typ) -> bool {\n+    state obj ty_var_counter(@mutable bool flag) {\n+        fn fold_simple_ty(@t typ) -> @t {\n+            alt (typ.struct) {\n+            case (ty_var(_)) { *flag = true; }\n+            case (_) { /* fall through */ }\n+            }\n+            ret typ;\n+        }\n+    }\n+\n+    let @mutable bool flag = @mutable false;\n+    fold_ty(ty_var_counter(flag), typ);\n+    ret *flag;\n+}\n+\n // Type accessors for substructures of types\n \n fn ty_fn_args(@t fty) -> vec[arg] {\n@@ -739,12 +805,14 @@ fn block_ty(&ast.block b) -> @t {\n     }\n }\n \n+// Returns the type of a pattern as a monotype. Like @expr_ty, this function\n+// doesn't provide type parameter substitutions.\n fn pat_ty(@ast.pat pat) -> @t {\n     alt (pat.node) {\n-        case (ast.pat_wild(?ann))           { ret ann_to_type(ann); }\n-        case (ast.pat_lit(_, ?ann))         { ret ann_to_type(ann); }\n-        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_type(ann); }\n-        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_type(ann); }\n+        case (ast.pat_wild(?ann))           { ret ann_to_monotype(ann); }\n+        case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(ann); }\n+        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_monotype(ann); }\n+        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_monotype(ann); }\n     }\n     fail;   // not reached\n }\n@@ -795,10 +863,83 @@ fn expr_ann(@ast.expr expr) -> option.t[ast.ann] {\n     fail;\n }\n \n+// Returns the type of an expression as a monotype.\n+//\n+// NB: This type doesn't provide type parameter substitutions; e.g. if you\n+// ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n+// instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n+// expr_ty_params_and_ty() below.\n fn expr_ty(@ast.expr expr) -> @t {\n     alt (expr_ann(expr)) {\n-        case (none[ast.ann])     { ret plain_ty(ty_nil); }\n-        case (some[ast.ann](?a)) { ret ann_to_type(a); }\n+        case (none[ast.ann])     { ret plain_ty(ty_nil);   }\n+        case (some[ast.ann](?a)) { ret ann_to_monotype(a); }\n+    }\n+}\n+\n+fn expr_ty_params_and_ty(@ast.expr expr) -> tup(vec[@t], @t) {\n+    alt (expr_ann(expr)) {\n+        case (none[ast.ann]) {\n+            let vec[@t] tps = vec();\n+            ret tup(tps, plain_ty(ty_nil));\n+        }\n+        case (some[ast.ann](?a)) {\n+            ret tup(ann_to_type_params(a), ann_to_type(a));\n+        }\n+    }\n+}\n+\n+fn expr_has_ty_params(@ast.expr expr) -> bool {\n+    // FIXME: Rewrite using complex patterns when they're trustworthy.\n+    alt (expr_ann(expr)) {\n+        case (none[ast.ann]) { fail; }\n+        case (some[ast.ann](?a)) {\n+            alt (a) {\n+                case (ast.ann_none) { fail; }\n+                case (ast.ann_type(_, ?tps_opt, _)) {\n+                    ret !option.is_none[vec[@t]](tps_opt);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// FIXME: At the moment this works only for call, bind, and path expressions.\n+fn replace_expr_type(@ast.expr expr, tup(vec[@t], @t) new_tyt) -> @ast.expr {\n+    auto new_tps;\n+    if (expr_has_ty_params(expr)) {\n+        new_tps = some[vec[@t]](new_tyt._0);\n+    } else {\n+        new_tps = none[vec[@t]];\n+    }\n+\n+    auto ann = ast.ann_type(new_tyt._1, new_tps, none[@ts_ann]);\n+\n+    alt (expr.node) {\n+        case (ast.expr_call(?callee, ?args, _)) {\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_call(callee, args, ann));\n+        }\n+        case (ast.expr_self_method(?ident, _)) {\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_self_method(ident, ann));\n+        }\n+        case (ast.expr_bind(?callee, ?args, _)) {\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_bind(callee, args, ann));\n+        }\n+        case (ast.expr_field(?e, ?i, _)) {\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_field(e, i, ann));\n+        }\n+        case (ast.expr_path(?p, ?dopt, _)) {\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_path(p, dopt, ann));\n+        }\n+        case (_) {\n+            log \"unhandled expr type in replace_expr_type(): \" +\n+                pretty.pprust.expr_to_str(expr);\n+            fail;\n+        }\n     }\n }\n \n@@ -1135,31 +1276,33 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 ret ures_ok(actual);\n             }\n             case (ty.ty_local(?actual_id)) {\n-                auto actual_ty = handler.resolve_local(actual_id);\n-                auto result = unify_step(bindings,\n-                                         expected,\n-                                         actual_ty,\n-                                         handler);\n-                alt (result) {\n-                    case (ures_ok(?result_ty)) {\n-                        handler.record_local(actual_id, result_ty);\n+                auto result_ty;\n+                alt (handler.resolve_local(actual_id)) {\n+                    case (none[@ty.t]) { result_ty = expected; }\n+                    case (some[@ty.t](?actual_ty)) {\n+                        auto result = unify_step(bindings,\n+                                                 expected,\n+                                                 actual_ty,\n+                                                 handler);\n+                        alt (result) {\n+                            case (ures_ok(?rty)) { result_ty = rty; }\n+                            case (_) { ret result; }\n+                        }\n                     }\n-                    case (_) { /* empty */ }\n                 }\n-                ret result;\n+\n+                handler.record_local(actual_id, result_ty);\n+                ret ures_ok(result_ty);\n             }\n-            case (ty.ty_param(?actual_id)) {\n+            case (ty.ty_bound_param(?actual_id)) {\n                 alt (expected.struct) {\n+                    case (ty.ty_local(_)) {\n+                        log \"TODO: bound param unifying with local\";\n+                        fail;\n+                    }\n \n-                    // These two unify via logic lower down. Fall through.\n-                    case (ty.ty_local(_)) { }\n-                    case (ty.ty_var(_)) { }\n-\n-                    // More-concrete types can unify against params here.\n                     case (_) {\n-                        ret handler.unify_actual_param(actual_id,\n-                                                       expected,\n-                                                       actual);\n+                        ret handler.record_param(actual_id, expected);\n                     }\n                 }\n             }\n@@ -1177,6 +1320,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             case (ty.ty_str)        { ret struct_cmp(expected, actual); }\n             case (ty.ty_type)       { ret struct_cmp(expected, actual); }\n             case (ty.ty_native)     { ret struct_cmp(expected, actual); }\n+            case (ty.ty_param(_))   { ret struct_cmp(expected, actual); }\n \n             case (ty.ty_tag(?expected_id, ?expected_tps)) {\n                 alt (actual.struct) {\n@@ -1510,23 +1654,27 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             }\n \n             case (ty.ty_local(?expected_id)) {\n-                auto expected_ty = handler.resolve_local(expected_id);\n-                auto result = unify_step(bindings,\n-                                         expected_ty,\n-                                         actual,\n-                                         handler);\n-                alt (result) {\n-                    case (ures_ok(?result_ty)) {\n-                        handler.record_local(expected_id, result_ty);\n+                auto result_ty;\n+                alt (handler.resolve_local(expected_id)) {\n+                    case (none[@ty.t]) { result_ty = actual; }\n+                    case (some[@ty.t](?expected_ty)) {\n+                        auto result = unify_step(bindings,\n+                                                 expected_ty,\n+                                                 actual,\n+                                                 handler);\n+                        alt (result) {\n+                            case (ures_ok(?rty)) { result_ty = rty; }\n+                            case (_) { ret result; }\n+                        }\n                     }\n-                    case (_) { /* empty */ }\n                 }\n-                ret result;\n+\n+                handler.record_local(expected_id, result_ty);\n+                ret ures_ok(result_ty);\n             }\n \n-            case (ty.ty_param(?expected_id)) {\n-                ret handler.unify_expected_param(expected_id, expected,\n-                                                 actual);\n+            case (ty.ty_bound_param(?expected_id)) {\n+                ret handler.record_param(expected_id, actual);\n             }\n         }\n \n@@ -1599,7 +1747,8 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n     alt (ures) {\n     case (ures_ok(?t)) {\n         auto set_types = unify_sets(bindings);\n-        ret ures_ok(substitute(bindings, set_types, t));\n+        auto t2 = substitute(bindings, set_types, t);\n+        ret ures_ok(t2);\n     }\n     case (_) { ret ures; }\n     }\n@@ -1652,58 +1801,15 @@ fn type_err_to_str(&ty.type_err err) -> str {\n     }\n }\n \n-// Type parameter resolution, used in translation and typechecking\n-\n-fn resolve_ty_params(ty_param_count_and_ty ty_params_and_polyty,\n-                     @t monoty) -> vec[@t] {\n-    // TODO: Use a vector, not a hashmap here.\n-    obj resolve_ty_params_handler(@hashmap[uint,@t] bindings) {\n-        fn resolve_local(ast.def_id id) -> @t { log \"resolve local\"; fail; }\n-        fn record_local(ast.def_id id, @t ty) { log \"record local\"; fail; }\n-        fn unify_expected_param(uint id, @t expected, @t actual)\n-                -> unify_result {\n-            bindings.insert(id, actual);\n-            ret ures_ok(actual);\n-        }\n-        fn unify_actual_param(uint id, @t expected, @t actual)\n-                -> unify_result {\n-            bindings.insert(id, expected);\n-            ret ures_ok(expected);\n-        }\n-    }\n-\n-    auto bindings = @common.new_uint_hash[@t]();\n-    auto handler = resolve_ty_params_handler(bindings);\n-\n-    auto unify_res = unify(ty_params_and_polyty._1, monoty, handler);\n-    alt (unify_res) {\n-        case (ures_ok(_))       { /* fall through */ }\n-        case (ures_err(_,?exp,?act))  {\n-            log \"resolve_ty_params mismatch: \" + ty_to_str(exp) + \" \" +\n-                ty_to_str(act);\n-            fail;\n-        }\n-    }\n-\n-    let vec[@t] result_tys = vec();\n-    auto ty_param_count = ty_params_and_polyty._0;\n-    auto i = 0u;\n-    while (i < ty_param_count) {\n-        check (bindings.contains_key(i));\n-        result_tys += vec(bindings.get(i));\n-        i += 1u;\n-    }\n-\n-    ret result_tys;\n-}\n-\n-// Performs type parameter replacement using the supplied mapping from\n+// Performs bound type parameter replacement using the supplied mapping from\n // parameter IDs to types.\n fn substitute_type_params(vec[@t] bindings, @t typ) -> @t {\n     state obj param_replacer(vec[@t] bindings) {\n         fn fold_simple_ty(@t typ) -> @t {\n             alt (typ.struct) {\n-                case (ty_param(?param_index)) { ret bindings.(param_index); }\n+                case (ty_bound_param(?param_index)) {\n+                    ret bindings.(param_index);\n+                }\n                 case (_) { ret typ; }\n             }\n         }\n@@ -1712,6 +1818,29 @@ fn substitute_type_params(vec[@t] bindings, @t typ) -> @t {\n     ret fold_ty(replacer, typ);\n }\n \n+// Converts type parameters in a type to bound type parameters.\n+fn bind_params_in_type(@t typ) -> @t {\n+    state obj folder(() env) {\n+        fn fold_simple_ty(@t typ) -> @t {\n+            alt (typ.struct) {\n+                case (ty_bound_param(?index)) {\n+                    log \"bind_params_in_type() called on type that already \" +\n+                        \"has bound params in it\";\n+                    fail;\n+                }\n+                case (ty_param(?index)) {\n+                    ret plain_ty(ty_bound_param(index));\n+                }\n+                case (_) {\n+                    ret typ;\n+                }\n+            }\n+        }\n+    }\n+\n+    ret fold_ty(folder(()), typ);\n+}\n+\n \n fn def_has_ty_params(&ast.def def) -> bool {\n     alt (def) {"}, {"sha": "4fb685ec685c5afee49be3b06a8ca77549ffe267", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 285, "deletions": 253, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=65b75788517ad797c1ae86f9d0c550ec620c4dfc", "patch": "@@ -11,6 +11,7 @@ import util.common.span;\n import middle.ty;\n import middle.ty.ann_to_type;\n import middle.ty.arg;\n+import middle.ty.bind_params_in_type;\n import middle.ty.block_ty;\n import middle.ty.expr_ty;\n import middle.ty.field;\n@@ -19,6 +20,7 @@ import middle.ty.mode_is_alias;\n import middle.ty.pat_ty;\n import middle.ty.path_to_str;\n import middle.ty.plain_ty;\n+import middle.ty.triv_ann;\n import middle.ty.ty_to_str;\n import middle.ty.type_is_integral;\n import middle.ty.type_is_scalar;\n@@ -61,41 +63,12 @@ type fn_ctxt = rec(@ty.t ret_ty,\n // Used for ast_ty_to_ty() below.\n type ty_getter = fn(ast.def_id) -> ty.ty_param_count_and_ty;\n \n-// Turns a type into an ann_type, using defaults for other fields.\n-fn triv_ann(@ty.t t) -> ann {\n-    ret ast.ann_type(t, none[vec[@ty.t]], none[@ts_ann]);\n-}\n-\n // Used to fill in the annotation for things that have uninteresting\n // types\n fn boring_ann() -> ann {\n     ret triv_ann(plain_ty(ty_nil));\n }\n \n-// Replaces parameter types inside a type with type variables.\n-fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n-    state obj ty_generalizer(@crate_ctxt cx,\n-                             @hashmap[uint,@ty.t] ty_params_to_ty_vars) {\n-        fn fold_simple_ty(@ty.t t) -> @ty.t {\n-            alt (t.struct) {\n-                case (ty.ty_param(?pid)) {\n-                    if (ty_params_to_ty_vars.contains_key(pid)) {\n-                        ret ty_params_to_ty_vars.get(pid);\n-                    }\n-                    auto var_ty = next_ty_var(cx);\n-                    ty_params_to_ty_vars.insert(pid, var_ty);\n-                    ret var_ty;\n-                }\n-                case (_) { /* fall through */ }\n-            }\n-            ret t;\n-        }\n-    }\n-\n-    auto generalizer = ty_generalizer(cx, @common.new_uint_hash[@ty.t]());\n-    ret ty.fold_ty(generalizer, t);\n-}\n-\n // Substitutes the user's explicit types for the parameters in a path\n // expression.\n fn substitute_ty_params(&@crate_ctxt ccx,\n@@ -106,7 +79,7 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n     state obj ty_substituter(@crate_ctxt ccx, vec[@ty.t] supplied) {\n         fn fold_simple_ty(@ty.t typ) -> @ty.t {\n             alt (typ.struct) {\n-                case (ty.ty_param(?pid)) { ret supplied.(pid); }\n+                case (ty.ty_bound_param(?pid)) { ret supplied.(pid); }\n                 case (_) { ret typ; }\n             }\n         }\n@@ -190,7 +163,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n         &span sp) -> ast.ann {\n     auto ty_param_count = tpt._0;\n-    auto t = tpt._1;\n+    auto t = bind_params_in_type(tpt._1);\n \n     auto ty_substs_opt;\n     auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n@@ -208,15 +181,15 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n                                   \"parameters\");\n             fail;\n         }\n-\n-        t = substitute_ty_params(fcx.ccx, t, ty_param_count, ty_substs, sp);\n     } else {\n-        ty_substs_opt = none[vec[@ty.t]];\n-\n-        if (ty_param_count > 0u) {\n-            // We will acquire the type parameters through unification.\n-            t = generalize_ty(fcx.ccx, t);\n+        // We will acquire the type parameters through unification.\n+        let vec[@ty.t] ty_substs = vec();\n+        auto i = 0u;\n+        while (i < ty_param_count) {\n+            ty_substs += vec(next_ty_var(fcx.ccx));\n+            i += 1u;\n         }\n+        ty_substs_opt = some[vec[@ty.t]](ty_substs);\n     }\n \n     ret ast.ann_type(t, ty_substs_opt, none[@ts_ann]);\n@@ -249,11 +222,12 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         //\n         // TODO: Make sure the number of supplied bindings matches the number\n         // of type parameters in the typedef. Emit a friendly error otherwise.\n+        auto bound_ty = bind_params_in_type(params_opt_and_ty._1);\n         let vec[@ty.t] param_bindings = vec();\n         for (@ast.ty ast_ty in args) {\n             param_bindings += vec(ast_ty_to_ty(getter, ast_ty));\n         }\n-        ret ty.substitute_type_params(param_bindings, params_opt_and_ty._1);\n+        ret ty.substitute_type_params(param_bindings, bound_ty);\n     }\n \n     auto mut = ast.imm;\n@@ -337,7 +311,8 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         }\n     }\n \n-    ret @rec(struct=sty, cname=cname);\n+    auto typ = @rec(struct=sty, cname=cname);\n+    ret typ;\n }\n \n // A convenience function to use a crate_ctxt to resolve names for\n@@ -843,43 +818,72 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     ret tup(crate_, type_cache, id_to_ty_item);\n }\n \n-fn unify(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n-    obj unify_handler(@fn_ctxt fcx) {\n-        fn resolve_local(ast.def_id id) -> @ty.t {\n-            if (!fcx.locals.contains_key(id)) {\n-                ret next_ty_var(fcx.ccx);\n+\n+// Type unification\n+\n+mod Unify {\n+    fn simple(@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n+        // FIXME: horrid botch\n+        let vec[mutable @ty.t] param_substs =\n+            vec(mutable plain_ty(ty.ty_nil));\n+        _vec.pop[mutable @ty.t](param_substs);\n+        ret with_params(fcx, expected, actual, param_substs);\n+    }\n+\n+    fn with_params(@fn_ctxt fcx, @ty.t expected, @ty.t actual,\n+                   vec[mutable @ty.t] param_substs) -> ty.unify_result {\n+        obj unify_handler(@fn_ctxt fcx, vec[mutable @ty.t] param_substs) {\n+            fn resolve_local(ast.def_id id) -> option.t[@ty.t] {\n+                alt (fcx.locals.find(id)) {\n+                    case (none[@ty.t]) { ret none[@ty.t]; }\n+                    case (some[@ty.t](?existing_type)) {\n+                        if (ty.type_contains_vars(existing_type)) {\n+                            // Not fully resolved yet. The writeback phase\n+                            // will mop up.\n+                            ret none[@ty.t];\n+                        }\n+                        ret some[@ty.t](existing_type);\n+                    }\n+                }\n             }\n-            ret fcx.locals.get(id);\n-        }\n-        fn record_local(ast.def_id id, @ty.t t) {\n-            fcx.locals.insert(id, t);\n-        }\n-        fn unify_expected_param(uint id, @ty.t expected, @ty.t actual)\n-                -> ty.unify_result {\n-            alt (actual.struct) {\n-                case (ty.ty_param(?actual_id)) {\n-                    if (id == actual_id) { ret ty.ures_ok(expected); }\n+            fn record_local(ast.def_id id, @ty.t new_type) {\n+                auto unified_type;\n+                alt (fcx.locals.find(id)) {\n+                    case (none[@ty.t]) { unified_type = new_type; }\n+                    case (some[@ty.t](?old_type)) {\n+                        alt (with_params(fcx, old_type, new_type,\n+                                         param_substs)) {\n+                            case (ty.ures_ok(?ut)) { unified_type = ut; }\n+                            case (_) { fail; /* FIXME */ }\n+                        }\n+                    }\n                 }\n-                case (_) { /* fall through */ }\n+                fcx.locals.insert(id, unified_type);\n             }\n-            ret ty.ures_err(ty.terr_mismatch, expected, actual);\n-        }\n-        fn unify_actual_param(uint id, @ty.t expected, @ty.t actual)\n-                -> ty.unify_result {\n-            alt (expected.struct) {\n-                case (ty.ty_param(?expected_id)) {\n-                    if (id == expected_id) { ret ty.ures_ok(actual); }\n+            fn record_param(uint index, @ty.t binding) -> ty.unify_result {\n+                // Unify with the appropriate type in the parameter\n+                // substitution list.\n+                auto old_subst = param_substs.(index);\n+\n+                auto result = with_params(fcx, old_subst, binding,\n+                                          param_substs);\n+                alt (result) {\n+                    case (ty.ures_ok(?new_subst)) {\n+                        param_substs.(index) = new_subst;\n+                        ret ty.ures_ok(plain_ty(ty.ty_bound_param(index)));\n+                    }\n+                    case (_) { ret result; }\n                 }\n-                case (_) { /* fall through */ }\n             }\n-            ret ty.ures_err(ty.terr_mismatch, expected, actual);\n         }\n-    }\n \n-    auto handler = unify_handler(fcx);\n-    ret ty.unify(expected, actual, handler);\n+\n+        auto handler = unify_handler(fcx, param_substs);\n+        ret ty.unify(expected, actual, handler);\n+    }\n }\n \n+\n tag autoderef_kind {\n     AUTODEREF_OK;\n     NO_AUTODEREF;\n@@ -919,51 +923,107 @@ fn count_boxes(@ty.t t) -> uint {\n }\n \n \n-fn demand(&@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n-    be demand_full(fcx, sp, expected, actual, NO_AUTODEREF);\n-}\n+// Demands - procedures that require that two types unify and emit an error\n+// message if they don't.\n \n+type ty_param_substs_and_ty = tup(vec[@ty.t], @ty.t);\n \n-// Requires that the two types unify, and prints an error message if they\n-// don't. Returns the unified type.\n+mod Demand {\n+    fn simple(@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n+        let vec[@ty.t] tps = vec();\n+        ret full(fcx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n+    }\n \n-fn demand_full(&@fn_ctxt fcx, &span sp,\n-               @ty.t expected, @ty.t actual, autoderef_kind adk) -> @ty.t {\n+    fn autoderef(@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual,\n+                 autoderef_kind adk) -> @ty.t {\n+        let vec[@ty.t] tps = vec();\n+        ret full(fcx, sp, expected, actual, tps, adk)._1;\n+    }\n \n-    auto expected_1 = expected;\n-    auto actual_1 = actual;\n-    auto implicit_boxes = 0u;\n+    // Requires that the two types unify, and prints an error message if they\n+    // don't. Returns the unified type and the type parameter substitutions.\n \n-    if (adk == AUTODEREF_OK) {\n-        expected_1 = strip_boxes(expected);\n-        actual_1 = strip_boxes(actual);\n-        implicit_boxes = count_boxes(actual);\n-    }\n+    fn full(@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual,\n+            vec[@ty.t] ty_param_substs_0, autoderef_kind adk)\n+            -> ty_param_substs_and_ty {\n \n-    alt (unify(fcx, expected_1, actual_1)) {\n-        case (ty.ures_ok(?t)) { ret add_boxes(implicit_boxes, t); }\n+        auto expected_1 = expected;\n+        auto actual_1 = actual;\n+        auto implicit_boxes = 0u;\n \n-        case (ty.ures_err(?err, ?expected, ?actual)) {\n-            fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n-                                  + ty_to_str(expected) + \" but found \"\n-                                  + ty_to_str(actual) + \" (\" +\n-                                  ty.type_err_to_str(err) + \")\");\n+        if (adk == AUTODEREF_OK) {\n+            expected_1 = strip_boxes(expected_1);\n+            actual_1 = strip_boxes(actual_1);\n+            implicit_boxes = count_boxes(actual);\n+        }\n \n-            // TODO: In the future, try returning \"expected\", reporting the\n-            // error, and continue.\n-            fail;\n+        let vec[mutable @ty.t] ty_param_substs =\n+            vec(mutable plain_ty(ty.ty_nil));\n+        _vec.pop[mutable @ty.t](ty_param_substs);   // FIXME: horrid botch\n+        for (@ty.t ty_param_subst in ty_param_substs_0) {\n+            ty_param_substs += vec(mutable ty_param_subst);\n+        }\n+\n+        alt (Unify.with_params(fcx, expected_1, actual_1, ty_param_substs)) {\n+            case (ty.ures_ok(?t)) {\n+                // TODO: Use \"freeze\", when we have it.\n+                let vec[@ty.t] result_ty_param_substs = vec();\n+                for (mutable @ty.t ty_param_subst in ty_param_substs) {\n+                    result_ty_param_substs += vec(ty_param_subst);\n+                }\n+\n+                ret tup(result_ty_param_substs, add_boxes(implicit_boxes, t));\n+            }\n+\n+            case (ty.ures_err(?err, ?expected, ?actual)) {\n+                fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n+                                      + ty_to_str(expected) + \" but found \"\n+                                      + ty_to_str(actual) + \" (\" +\n+                                      ty.type_err_to_str(err) + \")\");\n+\n+                // TODO: In the future, try returning \"expected\", reporting\n+                // the error, and continue.\n+                fail;\n+            }\n         }\n     }\n }\n \n+\n // Returns true if the two types unify and false if they don't.\n fn are_compatible(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n-    alt (unify(fcx, expected, actual)) {\n+    alt (Unify.simple(fcx, expected, actual)) {\n         case (ty.ures_ok(_))        { ret true;  }\n         case (ty.ures_err(_, _, _)) { ret false; }\n     }\n }\n \n+// Returns the types of the arguments to a tag variant.\n+fn variant_arg_types(@crate_ctxt ccx, &span sp, ast.def_id vid,\n+                     vec[@ty.t] tag_ty_params) -> vec[@ty.t] {\n+    auto ty_param_count = _vec.len[@ty.t](tag_ty_params);\n+\n+    let vec[@ty.t] result = vec();\n+\n+    auto tpt = ty.lookup_item_type(ccx.sess, ccx.type_cache, vid);\n+    alt (tpt._1.struct) {\n+        case (ty.ty_fn(_, ?ins, _)) {\n+            // N-ary variant.\n+            for (ty.arg arg in ins) {\n+                auto arg_ty = bind_params_in_type(arg.ty);\n+                arg_ty = substitute_ty_params(ccx, arg_ty, ty_param_count,\n+                                              tag_ty_params, sp);\n+                result += vec(arg_ty);\n+            }\n+        }\n+        case (_) {\n+            // Nullary variant. Do nothing, as there are no arguments.\n+        }\n+    }\n+\n+    ret result;\n+}\n+\n \n // The \"push-down\" phase, which takes a typed grammar production and pushes\n // its type down into its constituent parts.\n@@ -992,83 +1052,51 @@ mod Pushdown {\n \n         alt (pat.node) {\n             case (ast.pat_wild(?ann)) {\n-                auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, pat.span, expected,\n+                                       ann_to_type(ann));\n                 p_1 = ast.pat_wild(ast.ann_type(t, none[vec[@ty.t]],\n                                                 none[@ts_ann]));\n             }\n             case (ast.pat_lit(?lit, ?ann)) {\n-                auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, pat.span, expected,\n+                                       ann_to_type(ann));\n                 p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[@ty.t]],\n                                                     none[@ts_ann]));\n             }\n             case (ast.pat_bind(?id, ?did, ?ann)) {\n-                auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, pat.span, expected,\n+                                       ann_to_type(ann));\n                 fcx.locals.insert(did, t);\n                 p_1 = ast.pat_bind(id, did, ast.ann_type(t,\n                                                          none[vec[@ty.t]],\n                                                          none[@ts_ann]));\n             }\n             case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n-                auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-\n-                // FIXME: This is probably more convoluted than it has to be.\n-                // Refactor to use the type cache.\n-\n-                // Figure out the type parameters of the tag.\n-                auto tag_id = option.get[ast.variant_def](vdef_opt)._0;\n-\n-                auto tpt = ty.lookup_item_type(fcx.ccx.sess,\n-                    fcx.ccx.type_cache, tag_id);\n-                auto ty_params = tpt._0;\n-\n-                // Take the type parameters out of the expected type.\n-                auto ty_param_substs;\n-                alt (t.struct) {\n-                    case (ty.ty_tag(_, ?tps)) { ty_param_substs = tps; }\n+                // Take the variant's type parameters out of the expected\n+                // type.\n+                auto tag_tps;\n+                alt (expected.struct) {\n+                    case (ty.ty_tag(_, ?tps)) { tag_tps = tps; }\n                     case (_) {\n-                        log \"pushdown_pat(): expected type for tag pat \" +\n-                            \"isn't actually a tag?!\";\n+                        log \"tag pattern type not actually a tag?!\";\n                         fail;\n                     }\n                 }\n-                auto tps_opt = some[vec[@ty.t]](ty_param_substs);\n-\n-                // The type of the tag isn't enough; we also have to get the\n-                // type of the variant, which is either a tag type in the case\n-                // of nullary variants or a function type in the case of n-ary\n-                // variants.\n \n+                // Get the types of the arguments of the variant.\n                 auto vdef = option.get[ast.variant_def](vdef_opt);\n-                auto variant_ty = ty.lookup_item_type(fcx.ccx.sess,\n-                                                      fcx.ccx.type_cache,\n-                                                      vdef._1)._1;\n-\n-                auto subpats_len = _vec.len[@ast.pat](subpats);\n-                alt (variant_ty.struct) {\n-                    case (ty.ty_tag(_, _)) {\n-                        // Nullary tag variant.\n-                        check (subpats_len == 0u);\n-                        p_1 = ast.pat_tag(id, subpats, vdef_opt,\n-                                          ast.ann_type(t, tps_opt,\n-                                                       none[@ts_ann]));\n-                    }\n-                    case (ty.ty_fn(_, ?args, ?tag_ty)) {\n-                        // N-ary tag variant.\n-                        let vec[@ast.pat] new_subpats = vec();\n-                        auto i = 0u;\n-                        for (arg a in args) {\n-                            auto subpat_ty = substitute_ty_params(fcx.ccx,\n-                                a.ty, ty_params, ty_param_substs, pat.span);\n-                            auto new_subpat = pushdown_pat(fcx, subpat_ty,\n-                                                           subpats.(i));\n-                            new_subpats += vec(new_subpat);\n-                            i += 1u;\n-                        }\n-                        p_1 = ast.pat_tag(id, new_subpats, vdef_opt,\n-                                          ast.ann_type(tag_ty, tps_opt,\n-                                                       none[@ts_ann]));\n-                    }\n+                auto arg_tys = variant_arg_types(fcx.ccx, pat.span, vdef._1,\n+                                                 tag_tps);\n+\n+                let vec[@ast.pat] subpats_1 = vec();\n+                auto i = 0u;\n+                for (@ast.pat subpat in subpats) {\n+                    subpats_1 += vec(pushdown_pat(fcx, arg_tys.(i), subpat));\n+                    i += 1u;\n                 }\n+\n+                // TODO: push down type from \"expected\".\n+                p_1 = ast.pat_tag(id, subpats_1, vdef_opt, ann);\n             }\n         }\n \n@@ -1087,14 +1115,15 @@ mod Pushdown {\n     }\n \n     fn pushdown_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n-                        autoderef_kind adk) -> @ast.expr {\n+                          autoderef_kind adk) -> @ast.expr {\n         auto e_1;\n \n         alt (e.node) {\n             case (ast.expr_vec(?es_0, ?mut, ?ann)) {\n                 // TODO: enforce mutability\n \n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 let vec[@ast.expr] es_1 = vec();\n                 alt (t.struct) {\n                     case (ty.ty_vec(?mt)) {\n@@ -1110,7 +1139,8 @@ mod Pushdown {\n                 e_1 = ast.expr_vec(es_1, mut, triv_ann(t));\n             }\n             case (ast.expr_tup(?es_0, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 let vec[ast.elt] elts_1 = vec();\n                 alt (t.struct) {\n                     case (ty.ty_tup(?mts)) {\n@@ -1133,7 +1163,8 @@ mod Pushdown {\n \n                 auto base_1 = base_0;\n \n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 let vec[ast.field] fields_1 = vec();\n                 alt (t.struct) {\n                     case (ty.ty_rec(?field_mts)) {\n@@ -1186,43 +1217,49 @@ mod Pushdown {\n                 e_1 = ast.expr_rec(fields_1, base_1, triv_ann(t));\n             }\n             case (ast.expr_bind(?sube, ?es, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_bind(sube, es, triv_ann(t));\n             }\n             case (ast.expr_call(?sube, ?es, ?ann)) {\n-                // NB: we call 'demand_full' and pass in adk only in cases\n-                // where e is an expression that could *possibly* produce a\n-                // box; things like expr_binary or expr_bind can't, so there's\n-                // no need.\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                // NB: we call 'Demand.autoderef' and pass in adk only in\n+                // cases where e is an expression that could *possibly*\n+                // produce a box; things like expr_binary or expr_bind can't,\n+                // so there's no need.\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 e_1 = ast.expr_call(sube, es, triv_ann(t));\n             }\n             case (ast.expr_self_method(?id, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_self_method(id, triv_ann(t));\n             }\n             case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_binary(bop, lhs, rhs, triv_ann(t));\n             }\n             case (ast.expr_unary(?uop, ?sube, ?ann)) {\n-                // See note in expr_unary for why we're calling demand_full.\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                // See note in expr_unary for why we're calling\n+                // Demand.autoderef.\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 e_1 = ast.expr_unary(uop, sube, triv_ann(t));\n             }\n             case (ast.expr_lit(?lit, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_lit(lit, triv_ann(t));\n             }\n             case (ast.expr_cast(?sube, ?ast_ty, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_cast(sube, ast_ty, triv_ann(t));\n             }\n             case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 auto then_1 = pushdown_block(fcx, expected, then_0);\n \n                 auto else_1;\n@@ -1236,53 +1273,61 @@ mod Pushdown {\n                 e_1 = ast.expr_if(cond, then_1, else_1, triv_ann(t));\n             }\n             case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_for(decl, seq, bloc, triv_ann(t));\n             }\n             case (ast.expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_for_each(decl, seq, bloc, triv_ann(t));\n             }\n             case (ast.expr_while(?cond, ?bloc, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_while(cond, bloc, triv_ann(t));\n             }\n             case (ast.expr_do_while(?bloc, ?cond, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_do_while(bloc, cond, triv_ann(t));\n             }\n             case (ast.expr_block(?bloc, ?ann)) {\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 e_1 = ast.expr_block(bloc, triv_ann(t));\n             }\n             case (ast.expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n                 e_1 = ast.expr_assign(lhs_1, rhs_1, triv_ann(t));\n             }\n             case (ast.expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n                 e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, triv_ann(t));\n             }\n             case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 e_1 = ast.expr_field(lhs, rhs, triv_ann(t));\n             }\n             case (ast.expr_index(?base, ?index, ?ann)) {\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 e_1 = ast.expr_index(base, index, triv_ann(t));\n             }\n             case (ast.expr_path(?pth, ?d, ?ann)) {\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                auto tp_substs_0 = ty.ann_to_type_params(ann);\n+                auto t_0 = ann_to_type(ann);\n+\n+                auto result_0 = Demand.full(fcx, e.span, expected, t_0,\n+                                            tp_substs_0, adk);\n+                auto t = result_0._1;\n \n                 // Fill in the type parameter substitutions if they weren't\n                 // provided by the programmer.\n@@ -1296,11 +1341,7 @@ mod Pushdown {\n                     case (ast.ann_type(_, ?tps_opt, _)) {\n                         alt (tps_opt) {\n                             case (none[vec[@ty.t]]) {\n-                                auto defn = option.get[ast.def](d);\n-                                auto tpt =\n-                                    ty_param_count_and_ty_for_def(fcx, defn);\n-                                auto tps = ty.resolve_ty_params(tpt, t);\n-                                ty_params_opt = some[vec[@ty.t]](tps);\n+                                ty_params_opt = none[vec[@ty.t]];\n                             }\n                             case (some[vec[@ty.t]](?tps)) {\n                                 ty_params_opt = some[vec[@ty.t]](tps);\n@@ -1314,8 +1355,8 @@ mod Pushdown {\n                                                  none[@ts_ann]));\n             }\n             case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n-                auto t = demand_full(fcx, e.span, expected,\n-                                     ann_to_type(ann), adk);\n+                auto t = Demand.autoderef(fcx, e.span, expected,\n+                                          ann_to_type(ann), adk);\n                 e_1 = ast.expr_ext(p, args, body, expanded, triv_ann(t));\n             }\n             /* FIXME: should this check the type annotations? */\n@@ -1329,12 +1370,14 @@ mod Pushdown {\n             case (ast.expr_check_expr(_,_)) { e_1 = e.node; }\n \n             case (ast.expr_port(?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 e_1 = ast.expr_port(triv_ann(t));\n             }\n \n             case (ast.expr_chan(?es, ?ann)) {\n-                auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+                auto t = Demand.simple(fcx, e.span, expected,\n+                                       ann_to_type(ann));\n                 let @ast.expr es_1;\n                 alt (t.struct) {\n                     case (ty.ty_chan(?subty)) {\n@@ -1354,7 +1397,7 @@ mod Pushdown {\n                 let vec[ast.arm] arms_1 = vec();\n                 for (ast.arm arm_0 in arms_0) {\n                     auto block_1 = pushdown_block(fcx, expected, arm_0.block);\n-                    t = demand(fcx, e.span, t, block_ty(block_1));\n+                    t = Demand.simple(fcx, e.span, t, block_ty(block_1));\n                     auto arm_1 = rec(pat=arm_0.pat, block=block_1,\n                                      index=arm_0.index);\n                     arms_1 += vec(arm_1);\n@@ -1404,7 +1447,7 @@ mod Pushdown {\n                 ret fold.respan[ast.block_](bloc.span, block_);\n             }\n             case (none[@ast.expr]) {\n-                demand(fcx, bloc.span, expected, plain_ty(ty.ty_nil));\n+                Demand.simple(fcx, bloc.span, expected, plain_ty(ty.ty_nil));\n                 ret bloc;\n             }\n         }\n@@ -1443,14 +1486,14 @@ fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n \n     auto fcx = option.get[@fn_ctxt](env);\n     alt (ann) {\n-    case (ast.ann_none) {\n-        log \"warning: no type for expression\";\n-        ret ann;\n-    }\n-    case (ast.ann_type(?typ, ?tps, ?ts_info)) {\n-        auto new_type = ty.fold_ty(folder(fcx), ann_to_type(ann));\n-        ret ast.ann_type(new_type, tps, ts_info);\n-    }\n+        case (ast.ann_none) {\n+            log \"warning: no type for expression\";\n+            ret ann;\n+        }\n+        case (ast.ann_type(?typ, ?tps, ?ts_info)) {\n+            auto new_type = ty.fold_ty(folder(fcx), ann_to_type(ann));\n+            ret ast.ann_type(new_type, tps, ts_info);\n+        }\n     }\n }\n \n@@ -1623,42 +1666,13 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n         }\n \n-        // Unify and write back to the function.\n-        auto f_1 = Pushdown.pushdown_expr(fcx, t_0, f_0);\n-\n-        // Take the argument types out of the resulting function type.\n-        auto t_1 = expr_ty(f_1);\n-\n-        if (!ty.is_fn_ty(t_1)) {\n-            fcx.ccx.sess.span_err(f_1.span,\n-                                  \"mismatched types: callee has \" +\n-                                  \"non-function type: \" +\n-                                  ty_to_str(t_1));\n-        }\n-\n-        let vec[arg] arg_tys_1 = ty.ty_fn_args(t_1);\n-        let @ty.t rt_1 = ty.ty_fn_ret(t_1);\n-\n-        // Unify and write back to the arguments.\n-        auto i = 0u;\n-        let vec[option.t[@ast.expr]] args_1 = vec();\n-        while (i < _vec.len[option.t[@ast.expr]](args_0)) {\n-            alt (args_0.(i)) {\n-                case (some[@ast.expr](?e_0)) {\n-                    auto arg_ty_1 = arg_tys_1.(i);\n-                    auto e_1 = Pushdown.pushdown_expr(fcx, arg_ty_1.ty, e_0);\n-                    _vec.push[option.t[@ast.expr]](args_1,\n-                                                   some[@ast.expr](e_1));\n-                }\n-                case (none[@ast.expr]) {\n-                    _vec.push[option.t[@ast.expr]](args_1, none[@ast.expr]);\n-                }\n-            }\n-\n-            i += 1u;\n-        }\n+        // Unify the callee and arguments.\n+        auto tpt_0 = ty.expr_ty_params_and_ty(f_0);\n+        auto tpt_1 = Demand.full(fcx, f.span, tpt_0._1, t_0, tpt_0._0,\n+                                 NO_AUTODEREF);\n+        auto f_1 = ty.replace_expr_type(f_0, tpt_1);\n \n-        ret tup(f_1, args_1);\n+        ret tup(f_1, args_0);\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1767,10 +1781,25 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto t = plain_ty(ty.ty_nil);\n             check (defopt != none[ast.def]);\n             auto defn = option.get[ast.def](defopt);\n+\n             auto tpt = ty_param_count_and_ty_for_def(fcx, defn);\n-            auto ann = instantiate_path(fcx, pth, tpt, expr.span);\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_path(pth, defopt, ann));\n+\n+            if (ty.def_has_ty_params(defn)) {\n+                auto ann = instantiate_path(fcx, pth, tpt, expr.span);\n+                ret @fold.respan[ast.expr_](expr.span,\n+                                            ast.expr_path(pth, defopt, ann));\n+            }\n+\n+            // The definition doesn't take type parameters. If the programmer\n+            // supplied some, that's an error.\n+            if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n+                fcx.ccx.sess.span_err(expr.span, \"this kind of value does \" +\n+                                      \"not take type parameters\");\n+                fail;\n+            }\n+\n+            auto e = ast.expr_path(pth, defopt, triv_ann(tpt._1));\n+            ret @fold.respan[ast.expr_](expr.span, e);\n         }\n \n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, _)) {\n@@ -1863,7 +1892,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_check_expr(?e, _)) {\n             auto expr_t = check_expr(fcx, e);\n-            demand(fcx, expr.span, plain_ty(ty.ty_bool), expr_ty(expr_t));\n+            Demand.simple(fcx, expr.span, plain_ty(ty.ty_bool),\n+                          expr_ty(expr_t));\n             ret @fold.respan[ast.expr_]\n                 (expr.span, ast.expr_check_expr(expr_t, boring_ann()));\n         }\n@@ -2020,8 +2050,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             let vec[@ast.pat] pats_0 = vec();\n             for (ast.arm arm in arms) {\n                 auto pat_0 = check_pat(fcx, arm.pat);\n-                pattern_ty = demand(fcx, pat_0.span, pattern_ty,\n-                                    pat_ty(pat_0));\n+                pattern_ty = Demand.simple(fcx, pat_0.span, pattern_ty,\n+                                           pat_ty(pat_0));\n                 pats_0 += vec(pat_0);\n             }\n \n@@ -2036,8 +2066,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             let vec[ast.block] blocks_0 = vec();\n             for (ast.arm arm in arms) {\n                 auto block_0 = check_block(fcx, arm.block);\n-                result_ty = demand(fcx, block_0.span, result_ty,\n-                                   block_ty(block_0));\n+                result_ty = Demand.simple(fcx, block_0.span, result_ty,\n+                                          block_ty(block_0));\n                 blocks_0 += vec(block_0);\n             }\n \n@@ -2232,7 +2262,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             for (@ast.expr e in args) {\n                 auto expr_1 = check_expr(fcx, e);\n                 auto expr_t = expr_ty(expr_1);\n-                demand(fcx, expr.span, t, expr_t);\n+                Demand.simple(fcx, expr.span, t, expr_t);\n                 _vec.push[@ast.expr](args_1,expr_1);\n             }\n \n@@ -2310,7 +2340,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         auto found = false;\n                         for (ty.field bf in base_fields) {\n                             if (_str.eq(f.ident, bf.ident)) {\n-                                demand(fcx, expr.span, f.mt.ty, bf.mt.ty);\n+                                Demand.simple(fcx, expr.span, f.mt.ty,\n+                                              bf.mt.ty);\n                                 found = true;\n                             }\n                         }\n@@ -2378,9 +2409,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n \n                 case (_) {\n-                    fcx.ccx.sess.unimpl(\"base type for expr_field \"\n-                                        + \"in typeck.check_expr: \"\n-                                        + ty_to_str(base_t));\n+                    fcx.ccx.sess.span_unimpl(expr.span,\n+                        \"base type for expr_field in typeck.check_expr: \" +\n+                        ty_to_str(base_t));\n                 }\n             }\n         }\n@@ -2512,6 +2543,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n                                                             expr_0);\n                         }\n                     }\n+\n                     auto init_0 = rec(expr = expr_1 with init);\n                     initopt = some[ast.initializer](init_0);\n                 }"}, {"sha": "c4c50845a7a4e658eb068392e7f27c5fe0c002a7", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=65b75788517ad797c1ae86f9d0c550ec620c4dfc", "patch": "@@ -50,6 +50,15 @@ fn expr_to_str(&@ast.expr e) -> str {\n     ret writer.get_str();\n }\n \n+fn pat_to_str(&@ast.pat p) -> str {\n+    auto writer = io.string_writer();\n+    auto s = @rec(s=pp.mkstate(writer.get_writer(), 78u),\n+                  comments=option.none[vec[lexer.cmnt]],\n+                  mutable cur_cmnt=0u);\n+    print_pat(s, p);\n+    ret writer.get_str();\n+}\n+\n impure fn hbox(ps s) {\n     pp.hbox(s.s, indent_unit);\n }"}, {"sha": "053d36105522658af47f307fa7eb18079e9bbf57", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/65b75788517ad797c1ae86f9d0c550ec620c4dfc/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=65b75788517ad797c1ae86f9d0c550ec620c4dfc", "patch": "@@ -252,6 +252,23 @@ rust_task::start(uintptr_t exit_task_glue,\n     transition(&dom->newborn_tasks, &dom->running_tasks);\n }\n \n+#if 0\n+void\n+rust_task::print_stack_trace()\n+{\n+    void *addrs[256];\n+    uintptr_t sp = this->rust_sp;\n+\n+    // We need to be careful to not use any Rust stack space here, since this\n+    // may be called on stack overflow.\n+    asm(\"xchgl %0, %%esp\\n\"\n+        \"pushl $256\\n\"\n+        \"pushl %1\\n\"\n+        \"calll %3\\n\"\n+        \"xchgl %%esp, %0\\n\"\n+}\n+#endif\n+\n void\n rust_task::grow(size_t n_frame_bytes)\n {"}]}