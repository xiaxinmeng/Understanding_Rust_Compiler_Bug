{"sha": "2180591593b4285b1765eb105c285c82727b2a6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxODA1OTE1OTNiNDI4NWIxNzY1ZWIxMDVjMjg1YzgyNzI3YjJhNmY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-27T08:32:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-27T08:32:44Z"}, "message": "Merge #3335\n\n3335: Refactor highlighting a bit r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ea276adbcf0c3fac4b457a2af49a2a7782585b87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea276adbcf0c3fac4b457a2af49a2a7782585b87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2180591593b4285b1765eb105c285c82727b2a6f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeV36sCRBK7hj4Ov3rIwAAdHIIAI06CkQ7SBWCyWjCMi04Abwy\npi4SbHLhntppoKZKUN3z1yb38a5Y9EmRkhqP6BI+VEI4jkC8Zhhtp1FL2lZqeR/t\nOLT2J9YtlvGJOhah3laCtvIlbl1whZy76AoqUSlW/8dYvtEyQcZ/yCvOQgreYw7K\nKBUkLOZD0S3uj2Ili4SIoz35cc8vLmONM0B8/nlSVouTkytgSHN1WhOmB/gbmt80\nRNCHUsIIO8kRXOtWlYk9q/qMOXbnkM48l1vK0qo/8nMRwWKsebqPu9O5xCw/wpF2\npHCTriaxpOLZhM3FNhE+s5JrFU3VgxvQFghkkDl5CADO862sWSUHx0MSLNbzgB0=\n=Lha6\n-----END PGP SIGNATURE-----\n", "payload": "tree ea276adbcf0c3fac4b457a2af49a2a7782585b87\nparent ac52a4109f6ada3241d84fd89ad28420bdfad335\nparent a8e68ff814801a72ecac6cd918a3e7fbb25d11c0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1582792364 +0000\ncommitter GitHub <noreply@github.com> 1582792364 +0000\n\nMerge #3335\n\n3335: Refactor highlighting a bit r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2180591593b4285b1765eb105c285c82727b2a6f", "html_url": "https://github.com/rust-lang/rust/commit/2180591593b4285b1765eb105c285c82727b2a6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2180591593b4285b1765eb105c285c82727b2a6f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac52a4109f6ada3241d84fd89ad28420bdfad335", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac52a4109f6ada3241d84fd89ad28420bdfad335", "html_url": "https://github.com/rust-lang/rust/commit/ac52a4109f6ada3241d84fd89ad28420bdfad335"}, {"sha": "a8e68ff814801a72ecac6cd918a3e7fbb25d11c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e68ff814801a72ecac6cd918a3e7fbb25d11c0", "html_url": "https://github.com/rust-lang/rust/commit/a8e68ff814801a72ecac6cd918a3e7fbb25d11c0"}], "stats": {"total": 783, "additions": 478, "deletions": 305}, "files": [{"sha": "d509de14e553e5bf81e3e640702c091ab4efc2dd", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -74,7 +74,9 @@ pub use crate::{\n     runnables::{Runnable, RunnableKind, TestId},\n     source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n     ssr::SsrError,\n-    syntax_highlighting::{HighlightTag, HighlightedRange},\n+    syntax_highlighting::{\n+        Highlight, HighlightModifier, HighlightModifiers, HighlightTag, HighlightedRange,\n+    },\n };\n \n pub use hir::Documentation;"}, {"sha": "51851763e85e42e1303e40e33b5fe312f652110e", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -10,63 +10,63 @@\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n-.type\\.builtin     { color: #8CD0D3; }\n-.type\\.param       { color: #20999D; }\n+.type.builtin       { color: #8CD0D3; }\n+.type.param         { color: #20999D; }\n .attribute          { color: #94BFF3; }\n .literal            { color: #BFEBBF; }\n-.literal\\.numeric  { color: #6A8759; }\n+.literal.numeric    { color: #6A8759; }\n .macro              { color: #94BFF3; }\n .module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }\n-.variable\\.mut     { color: #DCDCCC; text-decoration: underline; }\n+.variable.mut       { color: #DCDCCC; text-decoration: underline; }\n \n .keyword            { color: #F0DFAF; }\n-.keyword\\.unsafe   { color: #DFAF8F; }\n-.keyword\\.control  { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #DFAF8F; }\n+.keyword.control    { color: #F0DFAF; font-weight: bold; }\n </style>\n <pre><code><span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"attribute\">derive</span><span class=\"attribute\">(</span><span class=\"attribute\">Clone</span><span class=\"attribute\">,</span><span class=\"attribute\"> </span><span class=\"attribute\">Debug</span><span class=\"attribute\">)</span><span class=\"attribute\">]</span>\n <span class=\"keyword\">struct</span> <span class=\"type\">Foo</span> {\n-    <span class=\"keyword\">pub</span> <span class=\"field\">x</span>: <span class=\"type.builtin\">i32</span>,\n-    <span class=\"keyword\">pub</span> <span class=\"field\">y</span>: <span class=\"type.builtin\">i32</span>,\n+    <span class=\"keyword\">pub</span> <span class=\"field\">x</span>: <span class=\"type builtin\">i32</span>,\n+    <span class=\"keyword\">pub</span> <span class=\"field\">y</span>: <span class=\"type builtin\">i32</span>,\n }\n \n-<span class=\"keyword\">fn</span> <span class=\"function\">foo</span>&lt;<span class=\"type.param\">T</span>&gt;() -&gt; <span class=\"type.param\">T</span> {\n+<span class=\"keyword\">fn</span> <span class=\"function\">foo</span>&lt;<span class=\"type param\">T</span>&gt;() -&gt; <span class=\"type param\">T</span> {\n     <span class=\"macro\">unimplemented</span><span class=\"macro\">!</span>();\n-    <span class=\"function\">foo</span>::&lt;<span class=\"type.builtin\">i32</span>&gt;();\n+    <span class=\"function\">foo</span>::&lt;<span class=\"type builtin\">i32</span>&gt;();\n }\n \n <span class=\"macro\">macro_rules</span><span class=\"macro\">!</span> def_fn {\n     ($($tt:tt)*) =&gt; {$($tt)*}\n }\n \n <span class=\"macro\">def_fn</span><span class=\"macro\">!</span>{\n-    <span class=\"keyword\">fn</span> <span class=\"function\">bar</span>() -&gt; <span class=\"type.builtin\">u32</span> {\n-        <span class=\"literal.numeric\">100</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function\">bar</span>() -&gt; <span class=\"type builtin\">u32</span> {\n+        <span class=\"literal numeric\">100</span>\n     }\n }\n \n <span class=\"comment\">// comment</span>\n <span class=\"keyword\">fn</span> <span class=\"function\">main</span>() {\n-    <span class=\"macro\">println</span><span class=\"macro\">!</span>(<span class=\"string\">\"Hello, {}!\"</span>, <span class=\"literal.numeric\">92</span>);\n+    <span class=\"macro\">println</span><span class=\"macro\">!</span>(<span class=\"string\">\"Hello, {}!\"</span>, <span class=\"literal numeric\">92</span>);\n \n-    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\">vec</span> = Vec::new();\n-    <span class=\"keyword.control\">if</span> <span class=\"keyword\">true</span> {\n-        <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"literal.numeric\">92</span>;\n-        <span class=\"variable.mut\">vec</span>.push(<span class=\"type\">Foo</span> { <span class=\"field\">x</span>, <span class=\"field\">y</span>: <span class=\"literal.numeric\">1</span> });\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable mutable\">vec</span> = Vec::new();\n+    <span class=\"keyword control\">if</span> <span class=\"keyword\">true</span> {\n+        <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"literal numeric\">92</span>;\n+        <span class=\"variable mutable\">vec</span>.push(<span class=\"type\">Foo</span> { <span class=\"field\">x</span>, <span class=\"field\">y</span>: <span class=\"literal numeric\">1</span> });\n     }\n-    <span class=\"keyword.unsafe\">unsafe</span> { <span class=\"variable.mut\">vec</span>.set_len(<span class=\"literal.numeric\">0</span>); }\n+    <span class=\"keyword unsafe\">unsafe</span> { <span class=\"variable mutable\">vec</span>.set_len(<span class=\"literal numeric\">0</span>); }\n \n-    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\">x</span> = <span class=\"literal.numeric\">42</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable.mut\">y</span> = &<span class=\"keyword\">mut</span> <span class=\"variable.mut\">x</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable\">z</span> = &<span class=\"variable.mut\">y</span>;\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable mutable\">x</span> = <span class=\"literal numeric\">42</span>;\n+    <span class=\"keyword\">let</span> <span class=\"variable mutable\">y</span> = &<span class=\"keyword\">mut</span> <span class=\"variable mutable\">x</span>;\n+    <span class=\"keyword\">let</span> <span class=\"variable\">z</span> = &<span class=\"variable mutable\">y</span>;\n \n-    <span class=\"variable.mut\">y</span>;\n+    <span class=\"variable mutable\">y</span>;\n }\n \n-<span class=\"keyword\">enum</span> <span class=\"type\">E</span>&lt;<span class=\"type.param\">X</span>&gt; {\n-    <span class=\"constant\">V</span>(<span class=\"type.param\">X</span>)\n+<span class=\"keyword\">enum</span> <span class=\"type\">E</span>&lt;<span class=\"type param\">X</span>&gt; {\n+    <span class=\"constant\">V</span>(<span class=\"type param\">X</span>)\n }\n \n-<span class=\"keyword\">impl</span>&lt;<span class=\"type.param\">X</span>&gt; <span class=\"type\">E</span>&lt;<span class=\"type.param\">X</span>&gt; {\n-    <span class=\"keyword\">fn</span> <span class=\"function\">new</span>&lt;<span class=\"type.param\">T</span>&gt;() -&gt; <span class=\"type\">E</span>&lt;<span class=\"type.param\">T</span>&gt; {}\n+<span class=\"keyword\">impl</span>&lt;<span class=\"type param\">X</span>&gt; <span class=\"type\">E</span>&lt;<span class=\"type param\">X</span>&gt; {\n+    <span class=\"keyword\">fn</span> <span class=\"function\">new</span>&lt;<span class=\"type param\">T</span>&gt;() -&gt; <span class=\"type\">E</span>&lt;<span class=\"type param\">T</span>&gt; {}\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "1f869867f528414d6ccfe13ea1792b9d51bf3816", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -10,19 +10,19 @@\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n-.type\\.builtin     { color: #8CD0D3; }\n-.type\\.param       { color: #20999D; }\n+.type.builtin       { color: #8CD0D3; }\n+.type.param         { color: #20999D; }\n .attribute          { color: #94BFF3; }\n .literal            { color: #BFEBBF; }\n-.literal\\.numeric  { color: #6A8759; }\n+.literal.numeric    { color: #6A8759; }\n .macro              { color: #94BFF3; }\n .module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }\n-.variable\\.mut     { color: #DCDCCC; text-decoration: underline; }\n+.variable.mut       { color: #DCDCCC; text-decoration: underline; }\n \n .keyword            { color: #F0DFAF; }\n-.keyword\\.unsafe   { color: #DFAF8F; }\n-.keyword\\.control  { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #DFAF8F; }\n+.keyword.control    { color: #F0DFAF; font-weight: bold; }\n </style>\n <pre><code><span class=\"keyword\">fn</span> <span class=\"function\">main</span>() {\n     <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"8121853618659664005\" style=\"color: hsl(261,57%,61%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n@@ -34,5 +34,5 @@\n }\n \n <span class=\"keyword\">fn</span> <span class=\"function\">bar</span>() {\n-    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\" data-binding-hash=\"8121853618659664005\" style=\"color: hsl(261,57%,61%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable mutable\" data-binding-hash=\"8121853618659664005\" style=\"color: hsl(261,57%,61%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "4e95b9ce5630d772e2595b98f4df4651dcacafad", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 58, "deletions": 139, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -1,9 +1,9 @@\n //! FIXME: write short doc here\n \n-mod highlight_tag;\n+mod highlight;\n+mod html;\n \n use hir::{Name, Semantics};\n-use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, NameDefinition},\n     RootDatabase,\n@@ -17,12 +17,14 @@ use rustc_hash::FxHashMap;\n \n use crate::{references::classify_name_ref, FileId};\n \n-pub use highlight_tag::HighlightTag;\n+pub use highlight::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n+\n+pub(crate) use html::highlight_as_html;\n \n #[derive(Debug)]\n pub struct HighlightedRange {\n     pub range: TextRange,\n-    pub tag: HighlightTag,\n+    pub highlight: Highlight,\n     pub binding_hash: Option<u64>,\n }\n \n@@ -79,33 +81,33 @@ pub(crate) fn highlight(\n                         if let Some(range) = highlight_macro(node) {\n                             res.push(HighlightedRange {\n                                 range,\n-                                tag: HighlightTag::MACRO,\n+                                highlight: HighlightTag::Macro.into(),\n                                 binding_hash: None,\n                             });\n                         }\n                     }\n                     _ if in_macro_call.is_some() => {\n                         if let Some(token) = node.as_token() {\n-                            if let Some((tag, binding_hash)) = highlight_token_tree(\n+                            if let Some((highlight, binding_hash)) = highlight_token_tree(\n                                 &sema,\n                                 &mut bindings_shadow_count,\n                                 token.clone(),\n                             ) {\n                                 res.push(HighlightedRange {\n                                     range: node.text_range(),\n-                                    tag,\n+                                    highlight,\n                                     binding_hash,\n                                 });\n                             }\n                         }\n                     }\n                     _ => {\n-                        if let Some((tag, binding_hash)) =\n+                        if let Some((highlight, binding_hash)) =\n                             highlight_node(&sema, &mut bindings_shadow_count, node.clone())\n                         {\n                             res.push(HighlightedRange {\n                                 range: node.text_range(),\n-                                tag,\n+                                highlight,\n                                 binding_hash,\n                             });\n                         }\n@@ -150,7 +152,7 @@ fn highlight_token_tree(\n     sema: &Semantics<RootDatabase>,\n     bindings_shadow_count: &mut FxHashMap<Name, u32>,\n     token: SyntaxToken,\n-) -> Option<(HighlightTag, Option<u64>)> {\n+) -> Option<(Highlight, Option<u64>)> {\n     if token.parent().kind() != TOKEN_TREE {\n         return None;\n     }\n@@ -171,19 +173,21 @@ fn highlight_node(\n     sema: &Semantics<RootDatabase>,\n     bindings_shadow_count: &mut FxHashMap<Name, u32>,\n     node: SyntaxElement,\n-) -> Option<(HighlightTag, Option<u64>)> {\n+) -> Option<(Highlight, Option<u64>)> {\n     let db = sema.db;\n     let mut binding_hash = None;\n-    let tag = match node.kind() {\n+    let highlight: Highlight = match node.kind() {\n         FN_DEF => {\n             bindings_shadow_count.clear();\n             return None;\n         }\n-        COMMENT => HighlightTag::LITERAL_COMMENT,\n-        STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => HighlightTag::LITERAL_STRING,\n-        ATTR => HighlightTag::LITERAL_ATTRIBUTE,\n+        COMMENT => HighlightTag::Comment.into(),\n+        STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => HighlightTag::LiteralString.into(),\n+        ATTR => HighlightTag::Attribute.into(),\n         // Special-case field init shorthand\n-        NAME_REF if node.parent().and_then(ast::RecordField::cast).is_some() => HighlightTag::FIELD,\n+        NAME_REF if node.parent().and_then(ast::RecordField::cast).is_some() => {\n+            HighlightTag::Field.into()\n+        }\n         NAME_REF if node.ancestors().any(|it| it.kind() == ATTR) => return None,\n         NAME_REF => {\n             let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n@@ -217,26 +221,30 @@ fn highlight_node(\n \n             match name_kind {\n                 Some(name_kind) => highlight_name(db, name_kind),\n-                None => name.syntax().parent().map_or(HighlightTag::FUNCTION, |x| match x.kind() {\n-                    STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => HighlightTag::TYPE,\n-                    TYPE_PARAM => HighlightTag::TYPE_PARAM,\n-                    RECORD_FIELD_DEF => HighlightTag::FIELD,\n-                    _ => HighlightTag::FUNCTION,\n+                None => name.syntax().parent().map_or(HighlightTag::Function.into(), |x| {\n+                    match x.kind() {\n+                        STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => {\n+                            HighlightTag::Type.into()\n+                        }\n+                        TYPE_PARAM => HighlightTag::TypeParam.into(),\n+                        RECORD_FIELD_DEF => HighlightTag::Field.into(),\n+                        _ => HighlightTag::Function.into(),\n+                    }\n                 }),\n             }\n         }\n-        INT_NUMBER | FLOAT_NUMBER => HighlightTag::LITERAL_NUMERIC,\n-        BYTE => HighlightTag::LITERAL_BYTE,\n-        CHAR => HighlightTag::LITERAL_CHAR,\n-        LIFETIME => HighlightTag::TYPE_LIFETIME,\n-        T![unsafe] => HighlightTag::KEYWORD_UNSAFE,\n-        k if is_control_keyword(k) => HighlightTag::KEYWORD_CONTROL,\n-        k if k.is_keyword() => HighlightTag::KEYWORD,\n+        INT_NUMBER | FLOAT_NUMBER => HighlightTag::LiteralNumeric.into(),\n+        BYTE => HighlightTag::LiteralByte.into(),\n+        CHAR => HighlightTag::LiteralChar.into(),\n+        LIFETIME => HighlightTag::TypeLifetime.into(),\n+        T![unsafe] => HighlightTag::Keyword | HighlightModifier::Unsafe,\n+        k if is_control_keyword(k) => HighlightTag::Keyword | HighlightModifier::Control,\n+        k if k.is_keyword() => HighlightTag::Keyword.into(),\n \n         _ => return None,\n     };\n \n-    return Some((tag, binding_hash));\n+    return Some((highlight, binding_hash));\n \n     fn calc_binding_hash(name: &Name, shadow_count: u32) -> u64 {\n         fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n@@ -251,123 +259,34 @@ fn highlight_node(\n     }\n }\n \n-pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: bool) -> String {\n-    let parse = db.parse(file_id);\n-\n-    fn rainbowify(seed: u64) -> String {\n-        use rand::prelude::*;\n-        let mut rng = SmallRng::seed_from_u64(seed);\n-        format!(\n-            \"hsl({h},{s}%,{l}%)\",\n-            h = rng.gen_range::<u16, _, _>(0, 361),\n-            s = rng.gen_range::<u16, _, _>(42, 99),\n-            l = rng.gen_range::<u16, _, _>(40, 91),\n-        )\n-    }\n-\n-    let mut ranges = highlight(db, file_id, None);\n-    ranges.sort_by_key(|it| it.range.start());\n-    // quick non-optimal heuristic to intersect token ranges and highlighted ranges\n-    let mut frontier = 0;\n-    let mut could_intersect: Vec<&HighlightedRange> = Vec::new();\n-\n-    let mut buf = String::new();\n-    buf.push_str(&STYLE);\n-    buf.push_str(\"<pre><code>\");\n-    let tokens = parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.into_token());\n-    for token in tokens {\n-        could_intersect.retain(|it| token.text_range().start() <= it.range.end());\n-        while let Some(r) = ranges.get(frontier) {\n-            if r.range.start() <= token.text_range().end() {\n-                could_intersect.push(r);\n-                frontier += 1;\n-            } else {\n-                break;\n-            }\n-        }\n-        let text = html_escape(&token.text());\n-        let ranges = could_intersect\n-            .iter()\n-            .filter(|it| token.text_range().is_subrange(&it.range))\n-            .collect::<Vec<_>>();\n-        if ranges.is_empty() {\n-            buf.push_str(&text);\n-        } else {\n-            let classes = ranges.iter().map(|x| x.tag.to_string()).collect::<Vec<_>>().join(\" \");\n-            let binding_hash = ranges.first().and_then(|x| x.binding_hash);\n-            let color = match (rainbow, binding_hash) {\n-                (true, Some(hash)) => format!(\n-                    \" data-binding-hash=\\\"{}\\\" style=\\\"color: {};\\\"\",\n-                    hash,\n-                    rainbowify(hash)\n-                ),\n-                _ => \"\".into(),\n-            };\n-            buf.push_str(&format!(\"<span class=\\\"{}\\\"{}>{}</span>\", classes, color, text));\n-        }\n-    }\n-    buf.push_str(\"</code></pre>\");\n-    buf\n-}\n-\n-fn highlight_name(db: &RootDatabase, def: NameDefinition) -> HighlightTag {\n+fn highlight_name(db: &RootDatabase, def: NameDefinition) -> Highlight {\n     match def {\n-        NameDefinition::Macro(_) => HighlightTag::MACRO,\n-        NameDefinition::StructField(_) => HighlightTag::FIELD,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Module(_)) => HighlightTag::MODULE,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Function(_)) => HighlightTag::FUNCTION,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Adt(_)) => HighlightTag::TYPE,\n-        NameDefinition::ModuleDef(hir::ModuleDef::EnumVariant(_)) => HighlightTag::CONSTANT,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Const(_)) => HighlightTag::CONSTANT,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Static(_)) => HighlightTag::CONSTANT,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Trait(_)) => HighlightTag::TYPE,\n-        NameDefinition::ModuleDef(hir::ModuleDef::TypeAlias(_)) => HighlightTag::TYPE,\n-        NameDefinition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => HighlightTag::TYPE_BUILTIN,\n-        NameDefinition::SelfType(_) => HighlightTag::TYPE_SELF,\n-        NameDefinition::TypeParam(_) => HighlightTag::TYPE_PARAM,\n+        NameDefinition::Macro(_) => HighlightTag::Macro,\n+        NameDefinition::StructField(_) => HighlightTag::Field,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Module(_)) => HighlightTag::Module,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Function(_)) => HighlightTag::Function,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Adt(_)) => HighlightTag::Type,\n+        NameDefinition::ModuleDef(hir::ModuleDef::EnumVariant(_)) => HighlightTag::Constant,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Const(_)) => HighlightTag::Constant,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Static(_)) => HighlightTag::Constant,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Trait(_)) => HighlightTag::Type,\n+        NameDefinition::ModuleDef(hir::ModuleDef::TypeAlias(_)) => HighlightTag::Type,\n+        NameDefinition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+            return HighlightTag::Type | HighlightModifier::Builtin\n+        }\n+        NameDefinition::SelfType(_) => HighlightTag::TypeSelf,\n+        NameDefinition::TypeParam(_) => HighlightTag::TypeParam,\n         NameDefinition::Local(local) => {\n+            let mut h = Highlight::new(HighlightTag::Variable);\n             if local.is_mut(db) || local.ty(db).is_mutable_reference() {\n-                HighlightTag::VARIABLE_MUT\n-            } else {\n-                HighlightTag::VARIABLE\n+                h |= HighlightModifier::Mutable;\n             }\n+            return h;\n         }\n     }\n+    .into()\n }\n \n-//FIXME: like, real html escaping\n-fn html_escape(text: &str) -> String {\n-    text.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n-}\n-\n-const STYLE: &str = \"\n-<style>\n-body                { margin: 0; }\n-pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n-\n-.comment            { color: #7F9F7F; }\n-.string             { color: #CC9393; }\n-.field              { color: #94BFF3; }\n-.function           { color: #93E0E3; }\n-.parameter          { color: #94BFF3; }\n-.text               { color: #DCDCCC; }\n-.type               { color: #7CB8BB; }\n-.type\\\\.builtin     { color: #8CD0D3; }\n-.type\\\\.param       { color: #20999D; }\n-.attribute          { color: #94BFF3; }\n-.literal            { color: #BFEBBF; }\n-.literal\\\\.numeric  { color: #6A8759; }\n-.macro              { color: #94BFF3; }\n-.module             { color: #AFD8AF; }\n-.variable           { color: #DCDCCC; }\n-.variable\\\\.mut     { color: #DCDCCC; text-decoration: underline; }\n-\n-.keyword            { color: #F0DFAF; }\n-.keyword\\\\.unsafe   { color: #DFAF8F; }\n-.keyword\\\\.control  { color: #F0DFAF; font-weight: bold; }\n-</style>\n-\";\n-\n #[cfg(test)]\n mod tests {\n     use std::fs;\n@@ -498,6 +417,6 @@ fn bar() {\n             })\n             .unwrap();\n \n-        assert_eq!(&highlights[0].tag.to_string(), \"field\");\n+        assert_eq!(&highlights[0].highlight.to_string(), \"field\");\n     }\n }"}, {"sha": "383c74c9860458b42b8d869c6442217cbbf28cb6", "filename": "crates/ra_ide/src/syntax_highlighting/highlight.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -0,0 +1,163 @@\n+//! Defines token tags we use for syntax highlighting.\n+//! A tag is not unlike a CSS class.\n+\n+use std::{fmt, ops};\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct Highlight {\n+    pub tag: HighlightTag,\n+    pub modifiers: HighlightModifiers,\n+}\n+\n+#[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct HighlightModifiers(u32);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum HighlightTag {\n+    Field,\n+    Function,\n+    Module,\n+    Constant,\n+    Macro,\n+    Variable,\n+\n+    Type,\n+    TypeSelf,\n+    TypeParam,\n+    TypeLifetime,\n+\n+    LiteralByte,\n+    LiteralNumeric,\n+    LiteralChar,\n+\n+    Comment,\n+    LiteralString,\n+    Attribute,\n+\n+    Keyword,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+#[repr(u8)]\n+pub enum HighlightModifier {\n+    Mutable = 0,\n+    Unsafe,\n+    /// Used with keywords like `if` and `break`.\n+    Control,\n+    Builtin,\n+}\n+\n+impl HighlightTag {\n+    fn as_str(self) -> &'static str {\n+        match self {\n+            HighlightTag::Field => \"field\",\n+            HighlightTag::Function => \"function\",\n+            HighlightTag::Module => \"module\",\n+            HighlightTag::Constant => \"constant\",\n+            HighlightTag::Macro => \"macro\",\n+            HighlightTag::Variable => \"variable\",\n+            HighlightTag::Type => \"type\",\n+            HighlightTag::TypeSelf => \"type.self\",\n+            HighlightTag::TypeParam => \"type.param\",\n+            HighlightTag::TypeLifetime => \"type.lifetime\",\n+            HighlightTag::LiteralByte => \"literal.byte\",\n+            HighlightTag::LiteralNumeric => \"literal.numeric\",\n+            HighlightTag::LiteralChar => \"literal.char\",\n+            HighlightTag::Comment => \"comment\",\n+            HighlightTag::LiteralString => \"string\",\n+            HighlightTag::Attribute => \"attribute\",\n+            HighlightTag::Keyword => \"keyword\",\n+        }\n+    }\n+}\n+\n+impl fmt::Display for HighlightTag {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self.as_str(), f)\n+    }\n+}\n+\n+impl HighlightModifier {\n+    const ALL: &'static [HighlightModifier] = &[\n+        HighlightModifier::Mutable,\n+        HighlightModifier::Unsafe,\n+        HighlightModifier::Control,\n+        HighlightModifier::Builtin,\n+    ];\n+\n+    fn as_str(self) -> &'static str {\n+        match self {\n+            HighlightModifier::Mutable => \"mutable\",\n+            HighlightModifier::Unsafe => \"unsafe\",\n+            HighlightModifier::Control => \"control\",\n+            HighlightModifier::Builtin => \"builtin\",\n+        }\n+    }\n+\n+    fn mask(self) -> u32 {\n+        1 << (self as u32)\n+    }\n+}\n+\n+impl fmt::Display for HighlightModifier {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self.as_str(), f)\n+    }\n+}\n+\n+impl fmt::Display for Highlight {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.tag)?;\n+        for modifier in self.modifiers.iter() {\n+            write!(f, \".{}\", modifier)?\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl From<HighlightTag> for Highlight {\n+    fn from(tag: HighlightTag) -> Highlight {\n+        Highlight::new(tag)\n+    }\n+}\n+\n+impl Highlight {\n+    pub(crate) fn new(tag: HighlightTag) -> Highlight {\n+        Highlight { tag, modifiers: HighlightModifiers::default() }\n+    }\n+}\n+\n+impl ops::BitOr<HighlightModifier> for HighlightTag {\n+    type Output = Highlight;\n+\n+    fn bitor(self, rhs: HighlightModifier) -> Highlight {\n+        Highlight::new(self) | rhs\n+    }\n+}\n+\n+impl ops::BitOrAssign<HighlightModifier> for HighlightModifiers {\n+    fn bitor_assign(&mut self, rhs: HighlightModifier) {\n+        self.0 |= rhs.mask();\n+    }\n+}\n+\n+impl ops::BitOrAssign<HighlightModifier> for Highlight {\n+    fn bitor_assign(&mut self, rhs: HighlightModifier) {\n+        self.modifiers |= rhs;\n+    }\n+}\n+\n+impl ops::BitOr<HighlightModifier> for Highlight {\n+    type Output = Highlight;\n+\n+    fn bitor(mut self, rhs: HighlightModifier) -> Highlight {\n+        self |= rhs;\n+        self\n+    }\n+}\n+\n+impl HighlightModifiers {\n+    pub fn iter(self) -> impl Iterator<Item = HighlightModifier> {\n+        HighlightModifier::ALL.iter().copied().filter(move |it| self.0 & it.mask() == it.mask())\n+    }\n+}"}, {"sha": "af1ac07b3d8e1c4056f3d0ffbfd43a297f7f4afa", "filename": "crates/ra_ide/src/syntax_highlighting/highlight_tag.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ac52a4109f6ada3241d84fd89ad28420bdfad335/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight_tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac52a4109f6ada3241d84fd89ad28420bdfad335/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight_tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight_tag.rs?ref=ac52a4109f6ada3241d84fd89ad28420bdfad335", "patch": "@@ -1,43 +0,0 @@\n-//! Defines token tags we use for syntax highlighting.\n-//! A tag is not unlike a CSS class.\n-\n-use std::fmt;\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub struct HighlightTag(&'static str);\n-\n-impl fmt::Display for HighlightTag {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self.0, f)\n-    }\n-}\n-\n-#[rustfmt::skip]\n-impl HighlightTag {\n-    pub const FIELD: HighlightTag              = HighlightTag(\"field\");\n-    pub const FUNCTION: HighlightTag           = HighlightTag(\"function\");\n-    pub const MODULE: HighlightTag             = HighlightTag(\"module\");\n-    pub const CONSTANT: HighlightTag           = HighlightTag(\"constant\");\n-    pub const MACRO: HighlightTag              = HighlightTag(\"macro\");\n-\n-    pub const VARIABLE: HighlightTag           = HighlightTag(\"variable\");\n-    pub const VARIABLE_MUT: HighlightTag       = HighlightTag(\"variable.mut\");\n-\n-    pub const TYPE: HighlightTag               = HighlightTag(\"type\");\n-    pub const TYPE_BUILTIN: HighlightTag       = HighlightTag(\"type.builtin\");\n-    pub const TYPE_SELF: HighlightTag          = HighlightTag(\"type.self\");\n-    pub const TYPE_PARAM: HighlightTag         = HighlightTag(\"type.param\");\n-    pub const TYPE_LIFETIME: HighlightTag      = HighlightTag(\"type.lifetime\");\n-\n-    pub const LITERAL_BYTE: HighlightTag       = HighlightTag(\"literal.byte\");\n-    pub const LITERAL_NUMERIC: HighlightTag    = HighlightTag(\"literal.numeric\");\n-    pub const LITERAL_CHAR: HighlightTag       = HighlightTag(\"literal.char\");\n-\n-    pub const LITERAL_COMMENT: HighlightTag    = HighlightTag(\"comment\");\n-    pub const LITERAL_STRING: HighlightTag     = HighlightTag(\"string\");\n-    pub const LITERAL_ATTRIBUTE: HighlightTag  = HighlightTag(\"attribute\");\n-\n-    pub const KEYWORD: HighlightTag            = HighlightTag(\"keyword\");\n-    pub const KEYWORD_UNSAFE: HighlightTag     = HighlightTag(\"keyword.unsafe\");\n-    pub const KEYWORD_CONTROL: HighlightTag    = HighlightTag(\"keyword.control\");\n-}"}, {"sha": "210d9a57baea49cdf378a6d11e8685ec97d5f735", "filename": "crates/ra_ide/src/syntax_highlighting/html.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -0,0 +1,104 @@\n+//! Renders a bit of code as HTML.\n+\n+use ra_db::SourceDatabase;\n+use ra_syntax::AstNode;\n+\n+use crate::{FileId, HighlightedRange, RootDatabase};\n+\n+use super::highlight;\n+\n+pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: bool) -> String {\n+    let parse = db.parse(file_id);\n+\n+    fn rainbowify(seed: u64) -> String {\n+        use rand::prelude::*;\n+        let mut rng = SmallRng::seed_from_u64(seed);\n+        format!(\n+            \"hsl({h},{s}%,{l}%)\",\n+            h = rng.gen_range::<u16, _, _>(0, 361),\n+            s = rng.gen_range::<u16, _, _>(42, 99),\n+            l = rng.gen_range::<u16, _, _>(40, 91),\n+        )\n+    }\n+\n+    let mut ranges = highlight(db, file_id, None);\n+    ranges.sort_by_key(|it| it.range.start());\n+    // quick non-optimal heuristic to intersect token ranges and highlighted ranges\n+    let mut frontier = 0;\n+    let mut could_intersect: Vec<&HighlightedRange> = Vec::new();\n+\n+    let mut buf = String::new();\n+    buf.push_str(&STYLE);\n+    buf.push_str(\"<pre><code>\");\n+    let tokens = parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.into_token());\n+    for token in tokens {\n+        could_intersect.retain(|it| token.text_range().start() <= it.range.end());\n+        while let Some(r) = ranges.get(frontier) {\n+            if r.range.start() <= token.text_range().end() {\n+                could_intersect.push(r);\n+                frontier += 1;\n+            } else {\n+                break;\n+            }\n+        }\n+        let text = html_escape(&token.text());\n+        let ranges = could_intersect\n+            .iter()\n+            .filter(|it| token.text_range().is_subrange(&it.range))\n+            .collect::<Vec<_>>();\n+        if ranges.is_empty() {\n+            buf.push_str(&text);\n+        } else {\n+            let classes = ranges\n+                .iter()\n+                .map(|it| it.highlight.to_string().replace('.', \" \"))\n+                .collect::<Vec<_>>()\n+                .join(\" \");\n+            let binding_hash = ranges.first().and_then(|x| x.binding_hash);\n+            let color = match (rainbow, binding_hash) {\n+                (true, Some(hash)) => format!(\n+                    \" data-binding-hash=\\\"{}\\\" style=\\\"color: {};\\\"\",\n+                    hash,\n+                    rainbowify(hash)\n+                ),\n+                _ => \"\".into(),\n+            };\n+            buf.push_str(&format!(\"<span class=\\\"{}\\\"{}>{}</span>\", classes, color, text));\n+        }\n+    }\n+    buf.push_str(\"</code></pre>\");\n+    buf\n+}\n+\n+//FIXME: like, real html escaping\n+fn html_escape(text: &str) -> String {\n+    text.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n+}\n+\n+const STYLE: &str = \"\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.comment            { color: #7F9F7F; }\n+.string             { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.type.builtin       { color: #8CD0D3; }\n+.type.param         { color: #20999D; }\n+.attribute          { color: #94BFF3; }\n+.literal            { color: #BFEBBF; }\n+.literal.numeric    { color: #6A8759; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.variable.mut       { color: #DCDCCC; text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; }\n+.keyword.unsafe     { color: #DFAF8F; }\n+.keyword.control    { color: #F0DFAF; font-weight: bold; }\n+</style>\n+\";"}, {"sha": "759bceb32a1243e2b957b35e9a90eb79cc2036da", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -63,11 +63,8 @@ pub fn server_capabilities() -> ServerCapabilities {\n         semantic_tokens_provider: Some(\n             SemanticTokensOptions {\n                 legend: SemanticTokensLegend {\n-                    token_types: semantic_tokens::supported_token_types().iter().cloned().collect(),\n-                    token_modifiers: semantic_tokens::supported_token_modifiers()\n-                        .iter()\n-                        .cloned()\n-                        .collect(),\n+                    token_types: semantic_tokens::SUPPORTED_TYPES.iter().cloned().collect(),\n+                    token_modifiers: semantic_tokens::SUPPORTED_MODIFIERS.iter().cloned().collect(),\n                 },\n \n                 document_provider: Some(SemanticTokensDocumentProvider::Bool(true)),"}, {"sha": "b012f5dd5e94becf0afbcd9be7ff744275025ec3", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 48, "deletions": 63, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -10,14 +10,21 @@ use lsp_types::{\n };\n use ra_ide::{\n     translate_offset_with_edit, CompletionItem, CompletionItemKind, FileId, FilePosition,\n-    FileRange, FileSystemEdit, Fold, FoldKind, HighlightTag, InsertTextFormat, LineCol, LineIndex,\n-    NavigationTarget, RangeInfo, ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n+    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n+    InsertTextFormat, LineCol, LineIndex, NavigationTarget, RangeInfo, ReferenceAccess, Severity,\n+    SourceChange, SourceFileEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n use ra_vfs::LineEndings;\n \n-use crate::{req, semantic_tokens, world::WorldSnapshot, Result};\n+use crate::{\n+    req,\n+    semantic_tokens::{self, ModifierSet, BUILTIN, CONSTANT, CONTROL, MUTABLE, UNSAFE},\n+    world::WorldSnapshot,\n+    Result,\n+};\n+use semantic_tokens::ATTRIBUTE;\n \n pub trait Conv {\n     type Output;\n@@ -303,74 +310,52 @@ impl ConvWith<&FoldConvCtx<'_>> for Fold {\n     }\n }\n \n-impl Conv for HighlightTag {\n-    type Output = (SemanticTokenType, Vec<SemanticTokenModifier>);\n-\n-    fn conv(self) -> (SemanticTokenType, Vec<SemanticTokenModifier>) {\n-        let token_type: SemanticTokenType = match self {\n-            HighlightTag::FIELD => SemanticTokenType::MEMBER,\n-            HighlightTag::FUNCTION => SemanticTokenType::FUNCTION,\n-            HighlightTag::MODULE => SemanticTokenType::NAMESPACE,\n-            HighlightTag::CONSTANT => {\n-                return (\n-                    SemanticTokenType::VARIABLE,\n-                    vec![SemanticTokenModifier::STATIC, SemanticTokenModifier::READONLY],\n-                )\n-            }\n-            HighlightTag::MACRO => SemanticTokenType::MACRO,\n-\n-            HighlightTag::VARIABLE => {\n-                return (SemanticTokenType::VARIABLE, vec![SemanticTokenModifier::READONLY])\n-            }\n-            HighlightTag::VARIABLE_MUT => SemanticTokenType::VARIABLE,\n+impl Conv for Highlight {\n+    type Output = (u32, u32);\n \n-            HighlightTag::TYPE => SemanticTokenType::TYPE,\n-            HighlightTag::TYPE_BUILTIN => SemanticTokenType::TYPE,\n-            HighlightTag::TYPE_SELF => {\n-                return (SemanticTokenType::TYPE, vec![SemanticTokenModifier::REFERENCE])\n+    fn conv(self) -> Self::Output {\n+        let mut mods = ModifierSet::default();\n+        let type_ = match self.tag {\n+            HighlightTag::Field => SemanticTokenType::MEMBER,\n+            HighlightTag::Function => SemanticTokenType::FUNCTION,\n+            HighlightTag::Module => SemanticTokenType::NAMESPACE,\n+            HighlightTag::Constant => {\n+                mods |= SemanticTokenModifier::STATIC;\n+                mods |= SemanticTokenModifier::READONLY;\n+                CONSTANT\n             }\n-            HighlightTag::TYPE_PARAM => SemanticTokenType::TYPE_PARAMETER,\n-            HighlightTag::TYPE_LIFETIME => {\n-                return (SemanticTokenType::LABEL, vec![SemanticTokenModifier::REFERENCE])\n+            HighlightTag::Macro => SemanticTokenType::MACRO,\n+            HighlightTag::Variable => SemanticTokenType::VARIABLE,\n+            HighlightTag::Type => SemanticTokenType::TYPE,\n+            HighlightTag::TypeSelf => {\n+                mods |= SemanticTokenModifier::REFERENCE;\n+                SemanticTokenType::TYPE\n             }\n-\n-            HighlightTag::LITERAL_BYTE => SemanticTokenType::NUMBER,\n-            HighlightTag::LITERAL_NUMERIC => SemanticTokenType::NUMBER,\n-            HighlightTag::LITERAL_CHAR => SemanticTokenType::NUMBER,\n-\n-            HighlightTag::LITERAL_COMMENT => {\n-                return (SemanticTokenType::COMMENT, vec![SemanticTokenModifier::DOCUMENTATION])\n+            HighlightTag::TypeParam => SemanticTokenType::TYPE_PARAMETER,\n+            HighlightTag::TypeLifetime => {\n+                mods |= SemanticTokenModifier::REFERENCE;\n+                SemanticTokenType::LABEL\n             }\n-\n-            HighlightTag::LITERAL_STRING => SemanticTokenType::STRING,\n-            HighlightTag::LITERAL_ATTRIBUTE => SemanticTokenType::KEYWORD,\n-\n-            HighlightTag::KEYWORD => SemanticTokenType::KEYWORD,\n-            HighlightTag::KEYWORD_UNSAFE => SemanticTokenType::KEYWORD,\n-            HighlightTag::KEYWORD_CONTROL => SemanticTokenType::KEYWORD,\n-            unknown => panic!(\"Unknown semantic token: {}\", unknown),\n+            HighlightTag::LiteralByte => SemanticTokenType::NUMBER,\n+            HighlightTag::LiteralNumeric => SemanticTokenType::NUMBER,\n+            HighlightTag::LiteralChar => SemanticTokenType::NUMBER,\n+            HighlightTag::Comment => SemanticTokenType::COMMENT,\n+            HighlightTag::LiteralString => SemanticTokenType::STRING,\n+            HighlightTag::Attribute => ATTRIBUTE,\n+            HighlightTag::Keyword => SemanticTokenType::KEYWORD,\n         };\n \n-        (token_type, vec![])\n-    }\n-}\n-\n-impl Conv for (SemanticTokenType, Vec<SemanticTokenModifier>) {\n-    type Output = (u32, u32);\n-\n-    fn conv(self) -> Self::Output {\n-        let token_index =\n-            semantic_tokens::supported_token_types().iter().position(|it| *it == self.0).unwrap();\n-        let mut token_modifier_bitset = 0;\n-        for modifier in self.1.iter() {\n-            let modifier_index = semantic_tokens::supported_token_modifiers()\n-                .iter()\n-                .position(|it| it == modifier)\n-                .unwrap();\n-            token_modifier_bitset |= 1 << modifier_index;\n+        for modifier in self.modifiers.iter() {\n+            let modifier = match modifier {\n+                HighlightModifier::Mutable => MUTABLE,\n+                HighlightModifier::Unsafe => UNSAFE,\n+                HighlightModifier::Control => CONTROL,\n+                HighlightModifier::Builtin => BUILTIN,\n+            };\n+            mods |= modifier;\n         }\n \n-        (token_index as u32, token_modifier_bitset as u32)\n+        (semantic_tokens::type_index(type_), mods.0)\n     }\n }\n "}, {"sha": "9ed53169c85511d2df7779c4170d81712d4b0670", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -16,9 +16,9 @@ use lsp_types::{\n     CodeAction, CodeActionOrCommand, CodeActionResponse, CodeLens, Command, CompletionItem,\n     Diagnostic, DocumentFormattingParams, DocumentHighlight, DocumentSymbol, FoldingRange,\n     FoldingRangeParams, Hover, HoverContents, Location, MarkupContent, MarkupKind, Position,\n-    PrepareRenameResponse, Range, RenameParams, SemanticTokenModifier, SemanticTokenType,\n-    SemanticTokens, SemanticTokensParams, SemanticTokensRangeParams, SemanticTokensRangeResult,\n-    SemanticTokensResult, SymbolInformation, TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n+    PrepareRenameResponse, Range, RenameParams, SemanticTokens, SemanticTokensParams,\n+    SemanticTokensRangeParams, SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation,\n+    TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n };\n use ra_ide::{\n     AssistId, FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind,\n@@ -954,7 +954,7 @@ fn highlight(world: &WorldSnapshot, file_id: FileId) -> Result<Vec<Decoration>>\n         .into_iter()\n         .map(|h| Decoration {\n             range: h.range.conv_with(&line_index),\n-            tag: h.tag.to_string(),\n+            tag: h.highlight.to_string(),\n             binding_hash: h.binding_hash.map(|x| x.to_string()),\n         })\n         .collect();\n@@ -1082,10 +1082,9 @@ pub fn handle_semantic_tokens(\n \n     let mut builder = SemanticTokensBuilder::default();\n \n-    for h in world.analysis().highlight(file_id)?.into_iter() {\n-        let type_and_modifiers: (SemanticTokenType, Vec<SemanticTokenModifier>) = h.tag.conv();\n-        let (token_type, token_modifiers) = type_and_modifiers.conv();\n-        builder.push(h.range.conv_with(&line_index), token_type, token_modifiers);\n+    for highlight_range in world.analysis().highlight(file_id)?.into_iter() {\n+        let (token_type, token_modifiers) = highlight_range.highlight.conv();\n+        builder.push(highlight_range.range.conv_with(&line_index), token_type, token_modifiers);\n     }\n \n     let tokens = SemanticTokens { data: builder.build(), ..Default::default() };\n@@ -1104,10 +1103,9 @@ pub fn handle_semantic_tokens_range(\n \n     let mut builder = SemanticTokensBuilder::default();\n \n-    for h in world.analysis().highlight_range(frange)?.into_iter() {\n-        let type_and_modifiers: (SemanticTokenType, Vec<SemanticTokenModifier>) = h.tag.conv();\n-        let (token_type, token_modifiers) = type_and_modifiers.conv();\n-        builder.push(h.range.conv_with(&line_index), token_type, token_modifiers);\n+    for highlight_range in world.analysis().highlight_range(frange)?.into_iter() {\n+        let (token_type, token_modifiers) = highlight_range.highlight.conv();\n+        builder.push(highlight_range.range.conv_with(&line_index), token_type, token_modifiers);\n     }\n \n     let tokens = SemanticTokens { data: builder.build(), ..Default::default() };"}, {"sha": "d8362409dc8c257f0ed2df8cabfbb5c8bb1d6a2a", "filename": "crates/rust-analyzer/src/semantic_tokens.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -1,8 +1,18 @@\n //! Semantic Tokens helpers\n \n+use std::ops;\n+\n use lsp_types::{Range, SemanticToken, SemanticTokenModifier, SemanticTokenType};\n \n-const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n+pub(crate) const ATTRIBUTE: SemanticTokenType = SemanticTokenType::new(\"attribute\");\n+pub(crate) const CONSTANT: SemanticTokenType = SemanticTokenType::new(\"constant\");\n+\n+pub(crate) const MUTABLE: SemanticTokenModifier = SemanticTokenModifier::new(\"mutable\");\n+pub(crate) const UNSAFE: SemanticTokenModifier = SemanticTokenModifier::new(\"unsafe\");\n+pub(crate) const CONTROL: SemanticTokenModifier = SemanticTokenModifier::new(\"control\");\n+pub(crate) const BUILTIN: SemanticTokenModifier = SemanticTokenModifier::new(\"builtin\");\n+\n+pub(crate) const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n     SemanticTokenType::COMMENT,\n     SemanticTokenType::KEYWORD,\n     SemanticTokenType::STRING,\n@@ -23,9 +33,11 @@ const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n     SemanticTokenType::VARIABLE,\n     SemanticTokenType::PARAMETER,\n     SemanticTokenType::LABEL,\n+    ATTRIBUTE,\n+    CONSTANT,\n ];\n \n-const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n+pub(crate) const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n     SemanticTokenModifier::DOCUMENTATION,\n     SemanticTokenModifier::DECLARATION,\n     SemanticTokenModifier::DEFINITION,\n@@ -36,16 +48,20 @@ const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n     SemanticTokenModifier::ASYNC,\n     SemanticTokenModifier::VOLATILE,\n     SemanticTokenModifier::READONLY,\n+    MUTABLE,\n+    UNSAFE,\n+    CONTROL,\n+    BUILTIN,\n ];\n \n-/// Token types that the server supports\n-pub(crate) fn supported_token_types() -> &'static [SemanticTokenType] {\n-    SUPPORTED_TYPES\n-}\n+#[derive(Default)]\n+pub(crate) struct ModifierSet(pub(crate) u32);\n \n-/// Token modifiers that the server supports\n-pub(crate) fn supported_token_modifiers() -> &'static [SemanticTokenModifier] {\n-    SUPPORTED_MODIFIERS\n+impl ops::BitOrAssign<SemanticTokenModifier> for ModifierSet {\n+    fn bitor_assign(&mut self, rhs: SemanticTokenModifier) {\n+        let idx = SUPPORTED_MODIFIERS.iter().position(|it| it == &rhs).unwrap();\n+        self.0 |= 1 << idx;\n+    }\n }\n \n /// Tokens are encoded relative to each other.\n@@ -92,3 +108,7 @@ impl SemanticTokensBuilder {\n         self.data\n     }\n }\n+\n+pub fn type_index(type_: SemanticTokenType) -> u32 {\n+    SUPPORTED_TYPES.iter().position(|it| *it == type_).unwrap() as u32\n+}"}, {"sha": "ad1101603b475d56cf9f498849ef9b5e82796375", "filename": "editors/code/package.json", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2180591593b4285b1765eb105c285c82727b2a6f/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/2180591593b4285b1765eb105c285c82727b2a6f/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=2180591593b4285b1765eb105c285c82727b2a6f", "patch": "@@ -380,6 +380,28 @@\n                 }\n             }\n         ],\n+        \"semanticTokenTypes\": [\n+            {\n+                \"id\": \"attribute\"\n+            },\n+            {\n+                \"id\": \"constant\"\n+            }\n+        ],\n+        \"semanticTokenModifiers\": [\n+            {\n+                \"id\": \"mutable\"\n+            },\n+            {\n+                \"id\": \"unsafe\"\n+            },\n+            {\n+                \"id\": \"control\"\n+            },\n+            {\n+                \"id\": \"builtin\"\n+            }\n+        ],\n         \"semanticTokenStyleDefaults\": [\n             {\n                 \"selector\": \"*.mutable\",\n@@ -392,6 +414,12 @@\n                 \"highContrast\": {\n                     \"fontStyle\": \"underline\"\n                 }\n+            },\n+            {\n+                \"selector\": \"constant\",\n+                \"scope\": [\n+                    \"entity.name.constant\"\n+                ]\n             }\n         ]\n     }"}]}