{"sha": "df70060bd6cd4f2a589a83999139600087e7bbc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNzAwNjBiZDZjZDRmMmE1ODlhODM5OTkxMzk2MDAwODdlN2JiYzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-21T20:59:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-22T20:54:52Z"}, "message": "distinguish the three cases where elision occurs", "tree": {"sha": "37a3752489b28b399288aa3e16a4104cd72450c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37a3752489b28b399288aa3e16a4104cd72450c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df70060bd6cd4f2a589a83999139600087e7bbc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df70060bd6cd4f2a589a83999139600087e7bbc9", "html_url": "https://github.com/rust-lang/rust/commit/df70060bd6cd4f2a589a83999139600087e7bbc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df70060bd6cd4f2a589a83999139600087e7bbc9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1488095b08b0b85bff4b3d6d432e3f7cc7cd6d09", "url": "https://api.github.com/repos/rust-lang/rust/commits/1488095b08b0b85bff4b3d6d432e3f7cc7cd6d09", "html_url": "https://github.com/rust-lang/rust/commit/1488095b08b0b85bff4b3d6d432e3f7cc7cd6d09"}], "stats": {"total": 193, "additions": 119, "deletions": 74}, "files": [{"sha": "36eafb617687c0670cff97c427f72246ab3fdede", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/df70060bd6cd4f2a589a83999139600087e7bbc9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df70060bd6cd4f2a589a83999139600087e7bbc9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=df70060bd6cd4f2a589a83999139600087e7bbc9", "patch": "@@ -129,6 +129,7 @@ pub struct LoweringContext<'a> {\n     // This will always be false unless the `in_band_lifetimes` feature is\n     // enabled.\n     is_collecting_in_band_lifetimes: bool,\n+\n     // Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n     // When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n     // against this list to see if it is already in-scope, or if a definition\n@@ -945,7 +946,7 @@ impl<'a> LoweringContext<'a> {\n                 let span = t.span.shrink_to_lo();\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n-                    None => self.elided_lifetime(span),\n+                    None => self.elided_ref_lifetime(span),\n                 };\n                 hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n             }\n@@ -1013,7 +1014,8 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     })\n                     .collect();\n-                let lifetime_bound = lifetime_bound.unwrap_or_else(|| self.elided_lifetime(t.span));\n+                let lifetime_bound =\n+                    lifetime_bound.unwrap_or_else(|| self.elided_dyn_bound(t.span));\n                 if kind != TraitObjectSyntax::Dyn {\n                     self.maybe_lint_bare_trait(t.span, t.id, false);\n                 }\n@@ -1536,9 +1538,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         if !parameters.parenthesized && parameters.lifetimes.is_empty() {\n-            parameters.lifetimes = (0..expected_lifetimes)\n-                .map(|_| self.elided_lifetime(path_span))\n-                .collect();\n+            parameters.lifetimes = self.elided_path_lifetimes(path_span, expected_lifetimes);\n         }\n \n         hir::PathSegment::new(\n@@ -3999,7 +3999,7 @@ impl<'a> LoweringContext<'a> {\n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n                     id = self.next_id();\n-                    hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n+                    hir::TyTraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n                 } else {\n                     hir::TyPath(hir::QPath::Resolved(None, path))\n                 }\n@@ -4014,7 +4014,29 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {\n+    /// Invoked to create the lifetime argument for a type `&T`\n+    /// with no explicit lifetime.\n+    fn elided_ref_lifetime(&mut self, span: Span) -> hir::Lifetime {\n+        self.new_implicit_lifetime(span)\n+    }\n+\n+    /// Invoked to create the lifetime argument(s) for a path like\n+    /// `std::cell::Ref<T>`; note that implicit lifetimes in these\n+    /// sorts of cases are deprecated. This may therefore report a warning or an\n+    /// error, depending on the mode.\n+    fn elided_path_lifetimes(&mut self, span: Span, count: usize) -> P<[hir::Lifetime]> {\n+        (0..count).map(|_| self.new_implicit_lifetime(span)).collect()\n+    }\n+\n+    /// Invoked to create the lifetime argument(s) for an elided trait object\n+    /// bound, like the bound in `Box<dyn Debug>`. This method is not invoked\n+    /// when the bound is written, even if it is written with `'_` like in\n+    /// `Box<dyn Debug + '_>`. In those cases, `lower_lifetime` is invoked.\n+    fn elided_dyn_bound(&mut self, span: Span) -> hir::Lifetime {\n+        self.new_implicit_lifetime(span)\n+    }\n+\n+    fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         hir::Lifetime {\n             id: self.next_id().node_id,\n             span,"}, {"sha": "628cdce0dc7407b879b9621b557af19583ca6e5b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 90, "deletions": 67, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/df70060bd6cd4f2a589a83999139600087e7bbc9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df70060bd6cd4f2a589a83999139600087e7bbc9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=df70060bd6cd4f2a589a83999139600087e7bbc9", "patch": "@@ -31,6 +31,7 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n+use session::Session;\n use std::slice;\n use rustc::lint;\n \n@@ -468,11 +469,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemFn(ref decl, _, _, _, ref generics, _) => {\n-                self.visit_early_late(None,\n-                                      decl,\n-                                      generics,\n-                                      |this| {\n-                                          intravisit::walk_item(this, item);\n+                self.visit_early_late(None, decl, generics, |this| {\n+                    intravisit::walk_item(this, item);\n                 });\n             }\n \n@@ -505,7 +503,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 } else {\n                     0\n                 };\n-                let lifetimes = generics.lifetimes()\n+                let lifetimes = generics\n+                    .lifetimes()\n                     .map(|def| Region::early(&self.tcx.hir, &mut index, def))\n                     .collect();\n                 let next_early_index = index + generics.ty_params().count() as u32;\n@@ -526,12 +525,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         match item.node {\n             hir::ForeignItemFn(ref decl, _, ref generics) => {\n-                self.visit_early_late(None,\n-                                      decl,\n-                                      generics,\n-                                      |this| {\n-                                          intravisit::walk_foreign_item(this, item);\n-                                      })\n+                self.visit_early_late(None, decl, generics, |this| {\n+                    intravisit::walk_foreign_item(this, item);\n+                })\n             }\n             hir::ForeignItemStatic(..) => {\n                 intravisit::walk_foreign_item(self, item);\n@@ -670,7 +666,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 if let Some(elision_region) = elision {\n                     let scope = Scope::Elision {\n                         elide: Elide::Exact(elision_region),\n-                        s: self.scope\n+                        s: self.scope,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         let scope = Scope::Binder {\n@@ -716,12 +712,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n-            },\n+            }\n             Type(ref bounds, ref ty) => {\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.lifetimes()\n+                let lifetimes = generics\n+                    .lifetimes()\n                     .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n                     .collect();\n \n@@ -741,12 +738,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.visit_ty(ty);\n                     }\n                 });\n-            },\n+            }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(trait_item.generics.params.is_empty());\n                 intravisit::walk_trait_item(self, trait_item);\n-            },\n+            }\n         }\n     }\n \n@@ -761,12 +758,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n                 )\n-            },\n+            }\n             Type(ref ty) => {\n                 let generics = &impl_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.lifetimes()\n+                let lifetimes = generics\n+                    .lifetimes()\n                     .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n                     .collect();\n \n@@ -781,12 +779,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n                 });\n-            },\n+            }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(impl_item.generics.params.is_empty());\n                 intravisit::walk_impl_item(self, impl_item);\n-            },\n+            }\n         }\n     }\n \n@@ -822,7 +820,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         check_mixed_explicit_and_in_band_defs(\n             self.tcx,\n-            &generics.lifetimes().cloned().collect::<Vec<_>>()\n+            &generics.lifetimes().cloned().collect::<Vec<_>>(),\n         );\n         for ty_param in generics.ty_params() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n@@ -842,7 +840,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n-                            lifetimes: bound_generic_params.lifetimes()\n+                            lifetimes: bound_generic_params\n+                                .lifetimes()\n                                 .map(|def| Region::late(&self.tcx.hir, def))\n                                 .collect(),\n                             s: self.scope,\n@@ -890,8 +889,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        if !self.trait_ref_hack ||\n-            trait_ref.bound_generic_params.iter().any(|p| p.is_lifetime_param())\n+        if !self.trait_ref_hack\n+            || trait_ref\n+                .bound_generic_params\n+                .iter()\n+                .any(|p| p.is_lifetime_param())\n         {\n             if self.trait_ref_hack {\n                 span_err!(\n@@ -903,7 +905,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref.bound_generic_params\n+                lifetimes: trait_ref\n+                    .bound_generic_params\n                     .lifetimes()\n                     .map(|def| Region::late(&self.tcx.hir, def))\n                     .collect(),\n@@ -1144,7 +1147,8 @@ fn compute_object_lifetime_defaults(\n                         .map(|set| match *set {\n                             Set1::Empty => \"BaseDefault\".to_string(),\n                             Set1::One(Region::Static) => \"'static\".to_string(),\n-                            Set1::One(Region::EarlyBound(i, _, _)) => generics.lifetimes()\n+                            Set1::One(Region::EarlyBound(i, _, _)) => generics\n+                                .lifetimes()\n                                 .nth(i as usize)\n                                 .unwrap()\n                                 .lifetime\n@@ -1182,7 +1186,8 @@ fn object_lifetime_defaults_for_item(\n         }\n     }\n \n-    generics.ty_params()\n+    generics\n+        .ty_params()\n         .map(|param| {\n             let mut set = Set1::Empty;\n \n@@ -1278,17 +1283,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if let hir::map::NodeLifetime(hir_lifetime) = this.tcx.hir.get(node_id) {\n                         let span = hir_lifetime.span;\n                         let id = hir_lifetime.id;\n-                        debug!(\"id ={:?} span = {:?} hir_lifetime = {:?}\",\n-                            node_id,\n-                            span,\n-                            hir_lifetime);\n+                        debug!(\n+                            \"id ={:?} span = {:?} hir_lifetime = {:?}\",\n+                            node_id, span, hir_lifetime\n+                        );\n \n                         this.tcx\n-                            .struct_span_lint_node(lint::builtin::SINGLE_USE_LIFETIME,\n-                                                   id,\n-                                                   span,\n-                                                   &format!(\"lifetime name `{}` only used once\",\n-                                                   hir_lifetime.name.name()))\n+                            .struct_span_lint_node(\n+                                lint::builtin::SINGLE_USE_LIFETIME,\n+                                id,\n+                                span,\n+                                &format!(\n+                                    \"lifetime name `{}` only used once\",\n+                                    hir_lifetime.name.name()\n+                                ),\n+                            )\n                             .emit();\n                     }\n                 }\n@@ -1379,8 +1388,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     abstract_type_parent,\n                     ..\n-                } if (!only_abstract_type_parent || abstract_type_parent)\n-                => return next_early_index,\n+                } if (!only_abstract_type_parent || abstract_type_parent) =>\n+                {\n+                    return next_early_index\n+                }\n \n                 Scope::Binder { s, .. }\n                 | Scope::Body { s, .. }\n@@ -1698,8 +1709,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            hir::map::NodeForeignItem(_) | hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) =>\n-                None,\n+            hir::map::NodeForeignItem(_) | hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {\n@@ -1894,7 +1904,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     lint::builtin::ELIDED_LIFETIME_IN_PATH,\n                     id,\n                     span,\n-                    &format!(\"hidden lifetime parameters are deprecated, try `Foo<'_>`\"))\n+                    &format!(\"hidden lifetime parameters are deprecated, try `Foo<'_>`\"),\n+                )\n                 .emit();\n         }\n         let error = loop {\n@@ -1933,25 +1944,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            span,\n-            E0106,\n-            \"missing lifetime specifier{}\",\n-            if lifetime_refs.len() > 1 { \"s\" } else { \"\" }\n-        );\n-        let msg = if lifetime_refs.len() > 1 {\n-            format!(\"expected {} lifetime parameters\", lifetime_refs.len())\n-        } else {\n-            format!(\"expected lifetime parameter\")\n-        };\n-        err.span_label(span, msg);\n+        let mut err = report_missing_lifetime_specifiers(self.tcx.sess, span, lifetime_refs.len());\n \n         if let Some(params) = error {\n             if lifetime_refs.len() == 1 {\n                 self.report_elision_failure(&mut err, params);\n             }\n         }\n+\n         err.emit();\n     }\n \n@@ -2146,9 +2146,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn check_lifetime_def_for_shadowing(&self,\n-                                        mut old_scope: ScopeRef,\n-                                        lifetime: &'tcx hir::Lifetime) {\n+    fn check_lifetime_def_for_shadowing(\n+        &self,\n+        mut old_scope: ScopeRef,\n+        lifetime: &'tcx hir::Lifetime,\n+    ) {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n             if lifetime.name.name() == label {\n@@ -2216,14 +2218,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.map.defs.insert(lifetime_ref.id, def);\n \n         match def {\n-            Region::LateBoundAnon(..) |\n-            Region::Static => {\n+            Region::LateBoundAnon(..) | Region::Static => {\n                 // These are anonymous lifetimes or lifetimes that are not declared.\n             }\n \n-            Region::Free(_, def_id) |\n-            Region::LateBound(_, def_id, _) |\n-            Region::EarlyBound(_, def_id, _) => {\n+            Region::Free(_, def_id)\n+            | Region::LateBound(_, def_id, _)\n+            | Region::EarlyBound(_, def_id, _) => {\n                 // A lifetime declared by the user.\n                 if !self.lifetime_uses.contains_key(&def_id) {\n                     self.lifetime_uses\n@@ -2255,8 +2256,7 @@ fn insert_late_bound_lifetimes(\n ) {\n     debug!(\n         \"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n-        decl,\n-        generics\n+        decl, generics\n     );\n \n     let mut constrained_by_input = ConstrainedCollector {\n@@ -2335,8 +2335,7 @@ fn insert_late_bound_lifetimes(\n         debug!(\n             \"insert_late_bound_lifetimes: \\\n              lifetime {:?} with id {:?} is late-bound\",\n-            lifetime.lifetime.name,\n-            lifetime.lifetime.id\n+            lifetime.lifetime.name, lifetime.lifetime.id\n         );\n \n         let inserted = map.late_bound.insert(lifetime.lifetime.id);\n@@ -2403,3 +2402,27 @@ fn insert_late_bound_lifetimes(\n         }\n     }\n }\n+\n+pub fn report_missing_lifetime_specifiers(\n+    sess: &Session,\n+    span: Span,\n+    count: usize,\n+) -> DiagnosticBuilder<'_> {\n+    let mut err = struct_span_err!(\n+        sess,\n+        span,\n+        E0106,\n+        \"missing lifetime specifier{}\",\n+        if count > 1 { \"s\" } else { \"\" }\n+    );\n+\n+    let msg = if count > 1 {\n+        format!(\"expected {} lifetime parameters\", count)\n+    } else {\n+        format!(\"expected lifetime parameter\")\n+    };\n+\n+    err.span_label(span, msg);\n+\n+    err\n+}"}]}