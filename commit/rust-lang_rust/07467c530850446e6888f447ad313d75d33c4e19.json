{"sha": "07467c530850446e6888f447ad313d75d33c4e19", "node_id": "C_kwDOAAsO6NoAKDA3NDY3YzUzMDg1MDQ0NmU2ODg4ZjQ0N2FkMzEzZDc1ZDMzYzRlMTk", "commit": {"author": {"name": "fee1-dead", "email": "ent3rm4n@gmail.com", "date": "2022-09-25T14:06:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-25T14:06:38Z"}, "message": "Rollup merge of #101997 - cuviper:drop-legacy-pm, r=nikic\n\nRemove support for legacy PM\n\nThis removes support for optimizing with LLVM's legacy pass manager, as well as the unstable `-Znew-llvm-pass-manager` option. We have been defaulting to the new PM since LLVM 13 (except for s390x that waited for 14), and LLVM 15 removed support altogether. The only place we still use the legacy PM is for writing the output file, just like `llc` does.\n\ncc #74705\nr? ``@nikic``", "tree": {"sha": "0712c42c6a5ede3afd2ec5e862c309dad3f6ea0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0712c42c6a5ede3afd2ec5e862c309dad3f6ea0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07467c530850446e6888f447ad313d75d33c4e19", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjMGBuCRBK7hj4Ov3rIwAAMiQIAC0YQv77v/mQKQl4a81O49Qg\nKqsNTSKPVXqwgV0i+kh8kbFmaoVHPSoAYnIAdHxDBDLalo90BT0AEb2iw2EQ97o/\nsGjPuvwcrxV84zeQ8o8iSN07PZWb3FliI5Y1jUANQ7re8PMbiNaPQ7/5TZ9j+dtk\nS9SSoVtAHba61QCW5sXUJl33F5JRLfyAoSkpEujFu655Frlha0qne3RInxtrKaMi\ncggos4rbBQ6fo3zyjP/oxMHxAZk+elEdMnylLtVmAca24nlKO0h8854SLKUJNvhq\naNsT3gR+doT6VJE/9HFeEqXnRnLm+hRB7ahYPLnblZLk8vzcVxN8BbL0/pBf9Wo=\n=ltKy\n-----END PGP SIGNATURE-----\n", "payload": "tree 0712c42c6a5ede3afd2ec5e862c309dad3f6ea0c\nparent da884d25da54295eca9f21b8ddc0679eef83c761\nparent 00bb9fc2be81b8beb257fdf220ed3f2386ab0930\nauthor fee1-dead <ent3rm4n@gmail.com> 1664114798 +0800\ncommitter GitHub <noreply@github.com> 1664114798 +0800\n\nRollup merge of #101997 - cuviper:drop-legacy-pm, r=nikic\n\nRemove support for legacy PM\n\nThis removes support for optimizing with LLVM's legacy pass manager, as well as the unstable `-Znew-llvm-pass-manager` option. We have been defaulting to the new PM since LLVM 13 (except for s390x that waited for 14), and LLVM 15 removed support altogether. The only place we still use the legacy PM is for writing the output file, just like `llc` does.\n\ncc #74705\nr? ``@nikic``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07467c530850446e6888f447ad313d75d33c4e19", "html_url": "https://github.com/rust-lang/rust/commit/07467c530850446e6888f447ad313d75d33c4e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07467c530850446e6888f447ad313d75d33c4e19/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da884d25da54295eca9f21b8ddc0679eef83c761", "url": "https://api.github.com/repos/rust-lang/rust/commits/da884d25da54295eca9f21b8ddc0679eef83c761", "html_url": "https://github.com/rust-lang/rust/commit/da884d25da54295eca9f21b8ddc0679eef83c761"}, {"sha": "00bb9fc2be81b8beb257fdf220ed3f2386ab0930", "url": "https://api.github.com/repos/rust-lang/rust/commits/00bb9fc2be81b8beb257fdf220ed3f2386ab0930", "html_url": "https://github.com/rust-lang/rust/commit/00bb9fc2be81b8beb257fdf220ed3f2386ab0930"}], "stats": {"total": 713, "additions": 28, "deletions": 685}, "files": [{"sha": "16c0b644e4f709d441658fd2a75c5e3c127cc27f", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -3263,7 +3263,6 @@ dependencies = [\n  \"bitflags\",\n  \"cstr\",\n  \"libc\",\n- \"libloading\",\n  \"measureme\",\n  \"object 0.29.0\",\n  \"rustc-demangle\","}, {"sha": "a068aa2ec6244e5bc1f93e880ac80f9016a0117b", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -11,7 +11,6 @@ doctest = false\n bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n-libloading = \"0.7.1\"\n measureme = \"10.0.0\"\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n tracing = \"0.1\""}, {"sha": "2049422b79a304c523d933f85d2af47ad1e74e2b", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 6, "deletions": 60, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -1,8 +1,6 @@\n-use crate::back::write::{\n-    self, save_temp_bitcode, to_llvm_opt_settings, with_llvm_pmb, DiagnosticHandlers,\n-};\n-use crate::llvm::{self, build_string, False, True};\n-use crate::{llvm_util, LlvmCodegenBackend, ModuleLlvm};\n+use crate::back::write::{self, save_temp_bitcode, DiagnosticHandlers};\n+use crate::llvm::{self, build_string};\n+use crate::{LlvmCodegenBackend, ModuleLlvm};\n use object::read::archive::ArchiveFile;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n@@ -597,61 +595,9 @@ pub(crate) fn run_pass_manager(\n                 1,\n             );\n         }\n-        if llvm_util::should_use_new_llvm_pass_manager(\n-            &config.new_llvm_pass_manager,\n-            &cgcx.target_arch,\n-        ) {\n-            let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n-            let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n-            write::optimize_with_new_llvm_pass_manager(\n-                cgcx,\n-                diag_handler,\n-                module,\n-                config,\n-                opt_level,\n-                opt_stage,\n-            )?;\n-            debug!(\"lto done\");\n-            return Ok(());\n-        }\n-\n-        let pm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMAddAnalysisPasses(module.module_llvm.tm, pm);\n-\n-        if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        let opt_level = config\n-            .opt_level\n-            .map(|x| to_llvm_opt_settings(x).0)\n-            .unwrap_or(llvm::CodeGenOptLevel::None);\n-        with_llvm_pmb(module.module_llvm.llmod(), config, opt_level, false, &mut |b| {\n-            if thin {\n-                llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n-            } else {\n-                llvm::LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-                    b, pm, /* Internalize = */ False, /* RunInliner = */ True,\n-                );\n-            }\n-        });\n-\n-        // We always generate bitcode through ThinLTOBuffers,\n-        // which do not support anonymous globals\n-        if config.bitcode_needed() {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"name-anon-globals\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        llvm::LLVMRunPassManager(pm, module.module_llvm.llmod());\n-\n-        llvm::LLVMDisposePassManager(pm);\n+        let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n+        let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n+        write::llvm_optimize(cgcx, diag_handler, module, config, opt_level, opt_stage)?;\n     }\n     debug!(\"lto done\");\n     Ok(())"}, {"sha": "db526746fa70aeceb4cb61356a6c7be8890dc4f6", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 250, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -21,7 +21,6 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_errors::{FatalError, Handler, Level};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n-use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, Lto, OutputType, Passes, SplitDwarfKind, SwitchWithOptPath};\n use rustc_session::Session;\n@@ -417,7 +416,7 @@ fn get_instr_profile_output_path(config: &ModuleConfig) -> Option<CString> {\n     }\n }\n \n-pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n+pub(crate) unsafe fn llvm_optimize(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n@@ -465,7 +464,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n     // We would have to add upstream support for this first, before we can support\n     // config.inline_threshold and our more aggressive default thresholds.\n-    let result = llvm::LLVMRustOptimizeWithNewPassManager(\n+    let result = llvm::LLVMRustOptimize(\n         module.module_llvm.llmod(),\n         &*module.module_llvm.tm,\n         to_pass_builder_opt_level(opt_level),\n@@ -509,203 +508,29 @@ pub(crate) unsafe fn optimize(\n \n     let llmod = module.module_llvm.llmod();\n     let llcx = &*module.module_llvm.llcx;\n-    let tm = &*module.module_llvm.tm;\n     let _handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n     let module_name = module.name.clone();\n     let module_name = Some(&module_name[..]);\n \n-    if let Some(false) = config.new_llvm_pass_manager && llvm_util::get_version() >= (15, 0, 0) {\n-        diag_handler.warn(\n-            \"ignoring `-Z new-llvm-pass-manager=no`, which is no longer supported with LLVM 15\",\n-        );\n-    }\n-\n     if config.emit_no_opt_bc {\n         let out = cgcx.output_filenames.temp_path_ext(\"no-opt.bc\", module_name);\n         let out = path_to_c_string(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     if let Some(opt_level) = config.opt_level {\n-        if llvm_util::should_use_new_llvm_pass_manager(\n-            &config.new_llvm_pass_manager,\n-            &cgcx.target_arch,\n-        ) {\n-            let opt_stage = match cgcx.lto {\n-                Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n-                Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n-                _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n-                _ => llvm::OptStage::PreLinkNoLTO,\n-            };\n-            return optimize_with_new_llvm_pass_manager(\n-                cgcx,\n-                diag_handler,\n-                module,\n-                config,\n-                opt_level,\n-                opt_stage,\n-            );\n-        }\n-\n-        if cgcx.prof.llvm_recording_enabled() {\n-            diag_handler\n-                .warn(\"`-Z self-profile-events = llvm` requires `-Z new-llvm-pass-manager`\");\n-        }\n-\n-        // Create the two optimizing pass managers. These mirror what clang\n-        // does, and are by populated by LLVM's default PassManagerBuilder.\n-        // Each manager has a different set of passes, but they also share\n-        // some common passes.\n-        let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n-        let mpm = llvm::LLVMCreatePassManager();\n-\n-        {\n-            let find_pass = |pass_name: &str| {\n-                let pass_name = SmallCStr::new(pass_name);\n-                llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr())\n-            };\n-\n-            if config.verify_llvm_ir {\n-                // Verification should run as the very first pass.\n-                llvm::LLVMRustAddPass(fpm, find_pass(\"verify\").unwrap());\n-            }\n-\n-            let mut extra_passes = Vec::new();\n-            let mut have_name_anon_globals_pass = false;\n-\n-            for pass_name in &config.passes {\n-                if pass_name == \"lint\" {\n-                    // Linting should also be performed early, directly on the generated IR.\n-                    llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n-                    continue;\n-                }\n-\n-                if let Some(pass) = find_pass(pass_name) {\n-                    extra_passes.push(pass);\n-                } else {\n-                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass_name));\n-                }\n-\n-                if pass_name == \"name-anon-globals\" {\n-                    have_name_anon_globals_pass = true;\n-                }\n-            }\n-\n-            // Instrumentation must be inserted before optimization,\n-            // otherwise LLVM may optimize some functions away which\n-            // breaks llvm-cov.\n-            //\n-            // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n-            if config.instrument_gcov {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"insert-gcov-profiling\").unwrap());\n-            }\n-            if config.instrument_coverage {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"instrprof\").unwrap());\n-            }\n-            if config.debug_info_for_profiling {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"add-discriminators\").unwrap());\n-            }\n-\n-            add_sanitizer_passes(config, &mut extra_passes);\n-\n-            // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n-            // to make sure we run LLVM's NameAnonGlobals pass when emitting bitcode; otherwise\n-            // we'll get errors in LLVM.\n-            let using_thin_buffers = config.bitcode_needed();\n-            if !config.no_prepopulate_passes {\n-                llvm::LLVMAddAnalysisPasses(tm, fpm);\n-                llvm::LLVMAddAnalysisPasses(tm, mpm);\n-                let opt_level = to_llvm_opt_settings(opt_level).0;\n-                let prepare_for_thin_lto = cgcx.lto == Lto::Thin\n-                    || cgcx.lto == Lto::ThinLocal\n-                    || (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n-                with_llvm_pmb(llmod, config, opt_level, prepare_for_thin_lto, &mut |b| {\n-                    llvm::LLVMRustAddLastExtensionPasses(\n-                        b,\n-                        extra_passes.as_ptr(),\n-                        extra_passes.len() as size_t,\n-                    );\n-                    llvm::LLVMRustPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n-                    llvm::LLVMRustPassManagerBuilderPopulateModulePassManager(b, mpm);\n-                });\n-\n-                have_name_anon_globals_pass = have_name_anon_globals_pass || prepare_for_thin_lto;\n-                if using_thin_buffers && !prepare_for_thin_lto {\n-                    llvm::LLVMRustAddPass(mpm, find_pass(\"name-anon-globals\").unwrap());\n-                    have_name_anon_globals_pass = true;\n-                }\n-            } else {\n-                // If we don't use the standard pipeline, directly populate the MPM\n-                // with the extra passes.\n-                for pass in extra_passes {\n-                    llvm::LLVMRustAddPass(mpm, pass);\n-                }\n-            }\n-\n-            if using_thin_buffers && !have_name_anon_globals_pass {\n-                // As described above, this will probably cause an error in LLVM\n-                if config.no_prepopulate_passes {\n-                    diag_handler.err(\n-                        \"The current compilation is going to use thin LTO buffers \\\n-                                      without running LLVM's NameAnonGlobals pass. \\\n-                                      This will likely cause errors in LLVM. Consider adding \\\n-                                      -C passes=name-anon-globals to the compiler command line.\",\n-                    );\n-                } else {\n-                    bug!(\n-                        \"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n-                          This will likely cause errors in LLVM and should never happen.\"\n-                    );\n-                }\n-            }\n-        }\n-\n-        diag_handler.abort_if_errors();\n-\n-        // Finally, run the actual optimization passes\n-        {\n-            let _timer = cgcx.prof.extra_verbose_generic_activity(\n-                \"LLVM_module_optimize_function_passes\",\n-                &*module.name,\n-            );\n-            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n-        }\n-        {\n-            let _timer = cgcx.prof.extra_verbose_generic_activity(\n-                \"LLVM_module_optimize_module_passes\",\n-                &*module.name,\n-            );\n-            llvm::LLVMRunPassManager(mpm, llmod);\n-        }\n-\n-        // Deallocate managers that we're now done with\n-        llvm::LLVMDisposePassManager(fpm);\n-        llvm::LLVMDisposePassManager(mpm);\n+        let opt_stage = match cgcx.lto {\n+            Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n+            Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n+            _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n+            _ => llvm::OptStage::PreLinkNoLTO,\n+        };\n+        return llvm_optimize(cgcx, diag_handler, module, config, opt_level, opt_stage);\n     }\n     Ok(())\n }\n \n-unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {\n-    if config.sanitizer.contains(SanitizerSet::ADDRESS) {\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::ADDRESS);\n-        passes.push(llvm::LLVMRustCreateAddressSanitizerFunctionPass(recover));\n-        passes.push(llvm::LLVMRustCreateModuleAddressSanitizerPass(recover));\n-    }\n-    if config.sanitizer.contains(SanitizerSet::MEMORY) {\n-        let track_origins = config.sanitizer_memory_track_origins as c_int;\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::MEMORY);\n-        passes.push(llvm::LLVMRustCreateMemorySanitizerPass(track_origins, recover));\n-    }\n-    if config.sanitizer.contains(SanitizerSet::THREAD) {\n-        passes.push(llvm::LLVMRustCreateThreadSanitizerPass());\n-    }\n-    if config.sanitizer.contains(SanitizerSet::HWADDRESS) {\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::HWADDRESS);\n-        passes.push(llvm::LLVMRustCreateHWAddressSanitizerPass(recover));\n-    }\n-}\n-\n pub(crate) fn link(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n@@ -1072,72 +897,6 @@ unsafe fn embed_bitcode(\n     }\n }\n \n-pub unsafe fn with_llvm_pmb(\n-    llmod: &llvm::Module,\n-    config: &ModuleConfig,\n-    opt_level: llvm::CodeGenOptLevel,\n-    prepare_for_thin_lto: bool,\n-    f: &mut dyn FnMut(&llvm::PassManagerBuilder),\n-) {\n-    use std::ptr;\n-\n-    // Create the PassManagerBuilder for LLVM. We configure it with\n-    // reasonable defaults and prepare it to actually populate the pass\n-    // manager.\n-    let builder = llvm::LLVMRustPassManagerBuilderCreate();\n-    let opt_size = config.opt_size.map_or(llvm::CodeGenOptSizeNone, |x| to_llvm_opt_settings(x).1);\n-    let inline_threshold = config.inline_threshold;\n-    let pgo_gen_path = get_pgo_gen_path(config);\n-    let pgo_use_path = get_pgo_use_path(config);\n-    let pgo_sample_use_path = get_pgo_sample_use_path(config);\n-\n-    llvm::LLVMRustConfigurePassManagerBuilder(\n-        builder,\n-        opt_level,\n-        config.merge_functions,\n-        config.vectorize_slp,\n-        config.vectorize_loop,\n-        prepare_for_thin_lto,\n-        pgo_gen_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        pgo_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        pgo_sample_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        opt_size as c_int,\n-    );\n-\n-    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, config.no_builtins);\n-\n-    // Here we match what clang does (kinda). For O0 we only inline\n-    // always-inline functions (but don't add lifetime intrinsics), at O1 we\n-    // inline with lifetime intrinsics, and O2+ we add an inliner with a\n-    // thresholds copied from clang.\n-    match (opt_level, opt_size, inline_threshold) {\n-        (.., Some(t)) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, t);\n-        }\n-        (llvm::CodeGenOptLevel::Aggressive, ..) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n-        }\n-        (_, llvm::CodeGenOptSizeDefault, _) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 75);\n-        }\n-        (_, llvm::CodeGenOptSizeAggressive, _) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n-        }\n-        (llvm::CodeGenOptLevel::None, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n-        }\n-        (llvm::CodeGenOptLevel::Less, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n-        }\n-        (llvm::CodeGenOptLevel::Default, ..) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n-        }\n-    }\n-\n-    f(builder);\n-    llvm::LLVMRustPassManagerBuilderDispose(builder);\n-}\n-\n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n // when using MSVC linker.  We do this only for data, as linker can fix up"}, {"sha": "42cb694c0e75a1b4cc382482bfee138a550b2a30", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 72, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -1792,18 +1792,9 @@ extern \"C\" {\n     /// Writes a module to the specified path. Returns 0 on success.\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n \n-    /// Creates a pass manager.\n+    /// Creates a legacy pass manager -- only used for final codegen.\n     pub fn LLVMCreatePassManager<'a>() -> &'a mut PassManager<'a>;\n \n-    /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: &Module) -> &mut PassManager<'_>;\n-\n-    /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager<'a>(PM: &'a mut PassManager<'a>);\n-\n-    /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager<'a>(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n-\n     pub fn LLVMInitializePasses();\n \n     pub fn LLVMTimeTraceProfilerInitialize();\n@@ -1814,32 +1805,6 @@ extern \"C\" {\n \n     pub fn LLVMAddAnalysisPasses<'a>(T: &'a TargetMachine, PM: &PassManager<'a>);\n \n-    pub fn LLVMRustPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;\n-    pub fn LLVMRustPassManagerBuilderDispose(PMB: &'static mut PassManagerBuilder);\n-    pub fn LLVMRustPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: &PassManagerBuilder,\n-        threshold: c_uint,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateModulePassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-\n-    pub fn LLVMRustPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-        Internalize: Bool,\n-        RunInliner: Bool,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-\n     pub fn LLVMGetHostCPUFeatures() -> *mut c_char;\n \n     pub fn LLVMDisposeMessage(message: *mut c_char);\n@@ -2244,22 +2209,6 @@ extern \"C\" {\n \n     pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&ConstantInt>;\n \n-    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n-    pub fn LLVMRustCreateAddressSanitizerFunctionPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustCreateModuleAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustCreateMemorySanitizerPass(\n-        TrackOrigins: c_int,\n-        Recover: bool,\n-    ) -> &'static mut Pass;\n-    pub fn LLVMRustCreateThreadSanitizerPass() -> &'static mut Pass;\n-    pub fn LLVMRustCreateHWAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustAddPass(PM: &PassManager<'_>, Pass: &'static mut Pass);\n-    pub fn LLVMRustAddLastExtensionPasses(\n-        PMB: &PassManagerBuilder,\n-        Passes: *const &'static mut Pass,\n-        NumPasses: size_t,\n-    );\n-\n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n     pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n@@ -2293,29 +2242,11 @@ extern \"C\" {\n         SplitDwarfFile: *const c_char,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n-    pub fn LLVMRustAddBuilderLibraryInfo<'a>(\n-        PMB: &'a PassManagerBuilder,\n-        M: &'a Module,\n-        DisableSimplifyLibCalls: bool,\n-    );\n-    pub fn LLVMRustConfigurePassManagerBuilder(\n-        PMB: &PassManagerBuilder,\n-        OptLevel: CodeGenOptLevel,\n-        MergeFunctions: bool,\n-        SLPVectorize: bool,\n-        LoopVectorize: bool,\n-        PrepareForThinLTO: bool,\n-        PGOGenPath: *const c_char,\n-        PGOUsePath: *const c_char,\n-        PGOSampleUsePath: *const c_char,\n-        SizeLevel: c_int,\n-    );\n     pub fn LLVMRustAddLibraryInfo<'a>(\n         PM: &PassManager<'a>,\n         M: &'a Module,\n         DisableSimplifyLibCalls: bool,\n     );\n-    pub fn LLVMRustRunFunctionPassManager<'a>(PM: &PassManager<'a>, M: &'a Module);\n     pub fn LLVMRustWriteOutputFile<'a>(\n         T: &'a TargetMachine,\n         PM: &PassManager<'a>,\n@@ -2324,7 +2255,7 @@ extern \"C\" {\n         DwoOutput: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n-    pub fn LLVMRustOptimizeWithNewPassManager<'a>(\n+    pub fn LLVMRustOptimize<'a>(\n         M: &'a Module,\n         TM: &'a TargetMachine,\n         OptLevel: PassBuilderOptLevel,\n@@ -2362,7 +2293,6 @@ extern \"C\" {\n     pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: &Module, triple: *const c_char);\n-    pub fn LLVMRustAddAlwaysInlinePass(P: &PassManagerBuilder, AddLifetimes: bool);\n     pub fn LLVMRustRunRestrictionPass(M: &Module, syms: *const *const c_char, len: size_t);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> Option<&'static mut Archive>;"}, {"sha": "2fd58567c487406d6864849027ddd03ca44ccf07", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -1,7 +1,6 @@\n use crate::back::write::create_informational_target_machine;\n-use crate::{llvm, llvm_util};\n+use crate::llvm;\n use libc::c_int;\n-use libloading::Library;\n use rustc_codegen_ssa::target_features::{\n     supported_target_features, tied_target_features, RUSTC_SPECIFIC_FEATURES,\n };\n@@ -16,7 +15,6 @@ use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use smallvec::{smallvec, SmallVec};\n use std::ffi::{CStr, CString};\n \n-use std::mem;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n@@ -120,22 +118,6 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n-    // Use the legacy plugin registration if we don't use the new pass manager\n-    if !should_use_new_llvm_pass_manager(\n-        &sess.opts.unstable_opts.new_llvm_pass_manager,\n-        &sess.target.arch,\n-    ) {\n-        // Register LLVM plugins by loading them into the compiler process.\n-        for plugin in &sess.opts.unstable_opts.llvm_plugins {\n-            let lib = Library::new(plugin).unwrap_or_else(|e| bug!(\"couldn't load plugin: {}\", e));\n-            debug!(\"LLVM plugin loaded successfully {:?} ({})\", lib, plugin);\n-\n-            // Intentionally leak the dynamic library. We can't ever unload it\n-            // since the library can make things that will live arbitrarily long.\n-            mem::forget(lib);\n-        }\n-    }\n-\n     rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n@@ -539,19 +521,3 @@ pub fn tune_cpu(sess: &Session) -> Option<&str> {\n     let name = sess.opts.unstable_opts.tune_cpu.as_ref()?;\n     Some(handle_native(name))\n }\n-\n-pub(crate) fn should_use_new_llvm_pass_manager(user_opt: &Option<bool>, target_arch: &str) -> bool {\n-    // The new pass manager is enabled by default for LLVM >= 13.\n-    // This matches Clang, which also enables it since Clang 13.\n-\n-    // Since LLVM 15, the legacy pass manager is no longer supported.\n-    if llvm_util::get_version() >= (15, 0, 0) {\n-        return true;\n-    }\n-\n-    // There are some perf issues with the new pass manager when targeting\n-    // s390x with LLVM 13, so enable the new pass manager only with LLVM 14.\n-    // See https://github.com/rust-lang/rust/issues/89609.\n-    let min_version = if target_arch == \"s390x\" { 14 } else { 13 };\n-    user_opt.unwrap_or_else(|| llvm_util::get_version() >= (min_version, 0, 0))\n-}"}, {"sha": "680b9b642d9b279bec3e16689c27787f83db823f", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -113,7 +113,6 @@ pub struct ModuleConfig {\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n     pub inline_threshold: Option<u32>,\n-    pub new_llvm_pass_manager: Option<bool>,\n     pub emit_lifetime_markers: bool,\n     pub llvm_plugins: Vec<String>,\n }\n@@ -265,7 +264,6 @@ impl ModuleConfig {\n             },\n \n             inline_threshold: sess.opts.cg.inline_threshold,\n-            new_llvm_pass_manager: sess.opts.unstable_opts.new_llvm_pass_manager,\n             emit_lifetime_markers: sess.emit_lifetime_markers(),\n             llvm_plugins: if_regular!(sess.opts.unstable_opts.llvm_plugins.clone(), vec![]),\n         }"}, {"sha": "2cd959689e6cf27f0ef24b77be1887c7367ca68d", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -758,7 +758,6 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(mir_opt_level, Some(4));\n     tracked!(move_size_limit, Some(4096));\n     tracked!(mutable_noalias, Some(true));\n-    tracked!(new_llvm_pass_manager, Some(true));\n     tracked!(no_generate_arange_section, true);\n     tracked!(no_link, true);\n     tracked!(no_unique_section_names, true);"}, {"sha": "09f377d349f45b2a78a7e58c923ec4c22374439f", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 5, "deletions": 251, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -31,13 +31,12 @@\n #include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n #include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n #include \"llvm/Transforms/IPO/FunctionImport.h\"\n-#if LLVM_VERSION_GE(15, 0)\n+#include \"llvm/Transforms/IPO/Internalize.h\"\n #include \"llvm/Transforms/IPO/ThinLTOBitcodeWriter.h\"\n-#endif\n #include \"llvm/Transforms/Utils/AddDiscriminators.h\"\n #include \"llvm/Transforms/Utils/FunctionImportUtils.h\"\n #include \"llvm/LTO/LTO.h\"\n-#include \"llvm/Bitcode/BitcodeWriterPass.h\"\n+#include \"llvm/Bitcode/BitcodeWriter.h\"\n #include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n #include \"llvm/Transforms/Instrumentation.h\"\n@@ -93,172 +92,6 @@ extern \"C\" void LLVMTimeTraceProfilerFinish(const char* FileName) {\n   timeTraceProfilerCleanup();\n }\n \n-extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n-#if LLVM_VERSION_LT(15, 0)\n-  StringRef SR(PassName);\n-  PassRegistry *PR = PassRegistry::getPassRegistry();\n-\n-  const PassInfo *PI = PR->getPassInfo(SR);\n-  if (PI) {\n-    return wrap(PI->createPass());\n-  }\n-  return nullptr;\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateAddressSanitizerFunctionPass(bool Recover) {\n-#if LLVM_VERSION_LT(15, 0)\n-  const bool CompileKernel = false;\n-  const bool UseAfterScope = true;\n-\n-  return wrap(createAddressSanitizerFunctionPass(CompileKernel, Recover, UseAfterScope));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateModuleAddressSanitizerPass(bool Recover) {\n-#if LLVM_VERSION_LT(15, 0)\n-  const bool CompileKernel = false;\n-\n-  return wrap(createModuleAddressSanitizerLegacyPassPass(CompileKernel, Recover));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateMemorySanitizerPass(int TrackOrigins, bool Recover) {\n-#if LLVM_VERSION_LT(15, 0)\n-  const bool CompileKernel = false;\n-\n-  return wrap(createMemorySanitizerLegacyPassPass(\n-#if LLVM_VERSION_GE(14, 0)\n-      MemorySanitizerOptions{TrackOrigins, Recover, CompileKernel, /*EagerChecks=*/true}\n-#else\n-      MemorySanitizerOptions{TrackOrigins, Recover, CompileKernel}\n-#endif\n-  ));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateThreadSanitizerPass() {\n-#if LLVM_VERSION_LT(15, 0)\n-  return wrap(createThreadSanitizerLegacyPassPass());\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateHWAddressSanitizerPass(bool Recover) {\n-#if LLVM_VERSION_LT(15, 0)\n-  const bool CompileKernel = false;\n-\n-  return wrap(createHWAddressSanitizerLegacyPassPass(CompileKernel, Recover));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PMR, LLVMPassRef RustPass) {\n-#if LLVM_VERSION_LT(15, 0)\n-  assert(RustPass);\n-  Pass *Pass = unwrap(RustPass);\n-  PassManagerBase *PMB = unwrap(PMR);\n-  PMB->add(Pass);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassManagerBuilderRef LLVMRustPassManagerBuilderCreate() {\n-#if LLVM_VERSION_LT(15, 0)\n-  return LLVMPassManagerBuilderCreate();\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderDispose(LLVMPassManagerBuilderRef PMB) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderDispose(PMB);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderPopulateFunctionPassManager(\n-  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderPopulateFunctionPassManager(PMB, PM);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderPopulateModulePassManager(\n-  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderPopulateModulePassManager(PMB, PM);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM, bool Internalize, bool RunInliner) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderPopulateLTOPassManager(PMB, PM, Internalize, RunInliner);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\"\n-void LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n-  LLVMPassManagerBuilderRef PMBR,\n-  LLVMPassManagerRef PMR\n-) {\n-#if LLVM_VERSION_LT(15, 0)\n-  unwrap(PMBR)->populateThinLTOPassManager(*unwrap(PMR));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderUseInlinerWithThreshold(\n-  LLVMPassManagerBuilderRef PMB, unsigned Threshold) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderUseInlinerWithThreshold(PMB, Threshold);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\"\n-void LLVMRustAddLastExtensionPasses(\n-    LLVMPassManagerBuilderRef PMBR, LLVMPassRef *Passes, size_t NumPasses) {\n-#if LLVM_VERSION_LT(15, 0)\n-  auto AddExtensionPasses = [Passes, NumPasses](\n-      const PassManagerBuilder &Builder, PassManagerBase &PM) {\n-    for (size_t I = 0; I < NumPasses; I++) {\n-      PM.add(unwrap(Passes[I]));\n-    }\n-  };\n-  // Add the passes to both of the pre-finalization extension points,\n-  // so they are run for optimized and non-optimized builds.\n-  unwrap(PMBR)->addExtension(PassManagerBuilder::EP_OptimizerLast,\n-                             AddExtensionPasses);\n-  unwrap(PMBR)->addExtension(PassManagerBuilder::EP_EnabledOnOptLevel0,\n-                             AddExtensionPasses);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n #ifdef LLVM_COMPONENT_X86\n #define SUBTARGET_X86 SUBTARGET(X86)\n #else\n@@ -604,47 +437,6 @@ extern \"C\" void LLVMRustDisposeTargetMachine(LLVMTargetMachineRef TM) {\n   delete unwrap(TM);\n }\n \n-extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n-    LLVMPassManagerBuilderRef PMBR, LLVMRustCodeGenOptLevel OptLevel,\n-    bool MergeFunctions, bool SLPVectorize, bool LoopVectorize, bool PrepareForThinLTO,\n-    const char* PGOGenPath, const char* PGOUsePath, const char* PGOSampleUsePath,\n-    int SizeLevel) {\n-#if LLVM_VERSION_LT(15, 0)\n-  unwrap(PMBR)->MergeFunctions = MergeFunctions;\n-  unwrap(PMBR)->SLPVectorize = SLPVectorize;\n-  unwrap(PMBR)->OptLevel = fromRust(OptLevel);\n-  unwrap(PMBR)->LoopVectorize = LoopVectorize;\n-  unwrap(PMBR)->PrepareForThinLTO = PrepareForThinLTO;\n-  unwrap(PMBR)->SizeLevel = SizeLevel;\n-  unwrap(PMBR)->DisableUnrollLoops = SizeLevel != 0;\n-\n-  if (PGOGenPath) {\n-    assert(!PGOUsePath && !PGOSampleUsePath);\n-    unwrap(PMBR)->EnablePGOInstrGen = true;\n-    unwrap(PMBR)->PGOInstrGen = PGOGenPath;\n-  } else if (PGOUsePath) {\n-    assert(!PGOSampleUsePath);\n-    unwrap(PMBR)->PGOInstrUse = PGOUsePath;\n-  } else if (PGOSampleUsePath) {\n-    unwrap(PMBR)->PGOSampleUse = PGOSampleUsePath;\n-  }\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-// Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n-// field of a PassManagerBuilder, we expose our own method of doing so.\n-extern \"C\" void LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMBR,\n-                                              LLVMModuleRef M,\n-                                              bool DisableSimplifyLibCalls) {\n-  Triple TargetTriple(unwrap(M)->getTargetTriple());\n-  TargetLibraryInfoImpl *TLI = new TargetLibraryInfoImpl(TargetTriple);\n-  if (DisableSimplifyLibCalls)\n-    TLI->disableAllFunctions();\n-  unwrap(PMBR)->LibraryInfo = TLI;\n-}\n-\n // Unfortunately, the LLVM C API doesn't provide a way to create the\n // TargetLibraryInfo pass, so we use this method to do so.\n extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMR, LLVMModuleRef M,\n@@ -656,27 +448,6 @@ extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMR, LLVMModuleRef M,\n   unwrap(PMR)->add(new TargetLibraryInfoWrapperPass(TLII));\n }\n \n-// Unfortunately, the LLVM C API doesn't provide an easy way of iterating over\n-// all the functions in a module, so we do that manually here. You'll find\n-// similar code in clang's BackendUtil.cpp file.\n-extern \"C\" void LLVMRustRunFunctionPassManager(LLVMPassManagerRef PMR,\n-                                               LLVMModuleRef M) {\n-  llvm::legacy::FunctionPassManager *P =\n-      unwrap<llvm::legacy::FunctionPassManager>(PMR);\n-  P->doInitialization();\n-\n-  // Upgrade all calls to old intrinsics first.\n-  for (Module::iterator I = unwrap(M)->begin(), E = unwrap(M)->end(); I != E;)\n-    UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n-\n-  for (Module::iterator I = unwrap(M)->begin(), E = unwrap(M)->end(); I != E;\n-       ++I)\n-    if (!I->isDeclaration())\n-      P->run(*I);\n-\n-  P->doFinalization();\n-}\n-\n extern \"C\" void LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n   // Initializing the command-line options more than once is not allowed. So,\n   // check if they've already been initialized.  (This could happen if we're\n@@ -820,7 +591,7 @@ struct LLVMRustSanitizerOptions {\n };\n \n extern \"C\" LLVMRustResult\n-LLVMRustOptimizeWithNewPassManager(\n+LLVMRustOptimize(\n     LLVMModuleRef ModuleRef,\n     LLVMTargetMachineRef TMRef,\n     LLVMRustPassBuilderOptLevel OptLevelRust,\n@@ -1241,15 +1012,8 @@ extern \"C\" void LLVMRustPrintPasses() {\n   PR->enumerateWith(&Listener);\n }\n \n-extern \"C\" void LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMBR,\n-                                            bool AddLifetimes) {\n-  unwrap(PMBR)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n-}\n-\n extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **Symbols,\n                                            size_t Len) {\n-  llvm::legacy::PassManager passes;\n-\n   auto PreserveFunctions = [=](const GlobalValue &GV) {\n     for (size_t I = 0; I < Len; I++) {\n       if (GV.getName() == Symbols[I]) {\n@@ -1259,9 +1023,7 @@ extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **Symbols,\n     return false;\n   };\n \n-  passes.add(llvm::createInternalizePass(PreserveFunctions));\n-\n-  passes.run(*unwrap(M));\n+  internalizeModule(*unwrap(M), PreserveFunctions);\n }\n \n extern \"C\" void\n@@ -1610,11 +1372,6 @@ LLVMRustThinLTOBufferCreate(LLVMModuleRef M, bool is_thin) {\n     raw_string_ostream OS(Ret->data);\n     {\n       if (is_thin) {\n-#if LLVM_VERSION_LT(15, 0)\n-        legacy::PassManager PM;\n-        PM.add(createWriteThinLTOBitcodePass(OS));\n-        PM.run(*unwrap(M));\n-#else\n         PassBuilder PB;\n         LoopAnalysisManager LAM;\n         FunctionAnalysisManager FAM;\n@@ -1628,11 +1385,8 @@ LLVMRustThinLTOBufferCreate(LLVMModuleRef M, bool is_thin) {\n         ModulePassManager MPM;\n         MPM.addPass(ThinLTOBitcodeWriterPass(OS, nullptr));\n         MPM.run(*unwrap(M), MAM);\n-#endif\n       } else {\n-        legacy::PassManager PM;\n-        PM.add(createBitcodeWriterPass(OS));\n-        PM.run(*unwrap(M));\n+        WriteBitcodeToFile(*unwrap(M), OS);\n       }\n     }\n   }"}, {"sha": "6f36281af23cc7abfff8aa0b78c44ca113c3efe0", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -12,7 +12,7 @@\n #include \"llvm/Object/COFFImportFile.h\"\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Pass.h\"\n-#include \"llvm/Bitcode/BitcodeWriterPass.h\"\n+#include \"llvm/Bitcode/BitcodeWriter.h\"\n #include \"llvm/Support/Signals.h\"\n #include \"llvm/ADT/Optional.h\"\n \n@@ -1670,11 +1670,7 @@ LLVMRustModuleBufferCreate(LLVMModuleRef M) {\n   auto Ret = std::make_unique<LLVMRustModuleBuffer>();\n   {\n     raw_string_ostream OS(Ret->data);\n-    {\n-      legacy::PassManager PM;\n-      PM.add(createBitcodeWriterPass(OS));\n-      PM.run(*unwrap(M));\n-    }\n+    WriteBitcodeToFile(*unwrap(M), OS);\n   }\n   return Ret.release();\n }"}, {"sha": "486c514a4f5c21842befb145c8aa95d7bdc274fb", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -1409,8 +1409,6 @@ options! {\n         \"the size at which the `large_assignments` lint starts to be emitted\"),\n     mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"emit noalias metadata for mutable references (default: yes)\"),\n-    new_llvm_pass_manager: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"use new LLVM pass manager (default: no)\"),\n     nll_facts: bool = (false, parse_bool, [UNTRACKED],\n         \"dump facts from NLL analysis into side files (default: no)\"),\n     nll_facts_dir: String = (\"nll-facts\".to_string(), parse_string, [UNTRACKED],"}, {"sha": "3e644f786f678cf0d44020088913fa77d28de257", "filename": "src/doc/unstable-book/src/compiler-flags/self-profile-events.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile-events.md", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile-events.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile-events.md?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -41,7 +41,7 @@ $ rustc -Zself-profile -Zself-profile-events=default,args\n \n - `llvm`\n   - Adds tracing information about LLVM passes and codegeneration.\n-  - Disabled by default because this only works when `-Znew-llvm-pass-manager` is enabled.\n+  - Disabled by default because this significantly increases the trace file size.\n \n ## Event synonyms\n "}, {"sha": "25d5c6e4ad2b980b2250acb79e038edd4ea949d2", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -82,7 +82,6 @@\n     -Z                           mir-opt-level=val -- MIR optimization level (0-4; default: 1 in non optimized builds and 2 in optimized builds)\n     -Z                         move-size-limit=val -- the size at which the `large_assignments` lint starts to be emitted\n     -Z                         mutable-noalias=val -- emit noalias metadata for mutable references (default: yes)\n-    -Z                   new-llvm-pass-manager=val -- use new LLVM pass manager (default: no)\n     -Z                               nll-facts=val -- dump facts from NLL analysis into side files (default: no)\n     -Z                           nll-facts-dir=val -- the directory the NLL facts are dumped into (default: `nll-facts`)\n     -Z                             no-analysis=val -- parse and expand the source, but run no analysis"}, {"sha": "ee28f5eb6d665fe80e15f379b6c62fdc50f933b6", "filename": "src/test/ui/invalid/invalid-llvm-passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-llvm-passes.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -1,4 +1,4 @@\n // build-fail\n-// compile-flags: -Cpasses=unknown-pass -Z new-llvm-pass-manager=yes\n+// compile-flags: -Cpasses=unknown-pass\n \n fn main() {}"}, {"sha": "33e18e35522ec2b93cec0f3bf499e3b98e18bcf1", "filename": "src/test/ui/sanitize/new-llvm-pass-manager-thin-lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07467c530850446e6888f447ad313d75d33c4e19/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07467c530850446e6888f447ad313d75d33c4e19/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs?ref=07467c530850446e6888f447ad313d75d33c4e19", "patch": "@@ -7,7 +7,7 @@\n //\n // no-prefer-dynamic\n // revisions: opt0 opt1\n-// compile-flags: -Znew-llvm-pass-manager=yes -Zsanitizer=address -Clto=thin\n+// compile-flags: -Zsanitizer=address -Clto=thin\n //[opt0]compile-flags: -Copt-level=0\n //[opt1]compile-flags: -Copt-level=1\n // run-fail"}]}