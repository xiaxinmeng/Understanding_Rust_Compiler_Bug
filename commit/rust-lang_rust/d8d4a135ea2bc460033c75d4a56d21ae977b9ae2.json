{"sha": "d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "node_id": "C_kwDOAAsO6NoAKGQ4ZDRhMTM1ZWEyYmM0NjAwMzNjNzVkNGE1NmQyMWFlOTc3YjlhZTI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-06T03:22:58Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-19T14:54:55Z"}, "message": "Move `UnnecessarySortBy` into `Methods` lint pass", "tree": {"sha": "0dddcf53bc17549d6b45c2d025d498fa0c527784", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dddcf53bc17549d6b45c2d025d498fa0c527784"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "html_url": "https://github.com/rust-lang/rust/commit/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb0584dfb425f6c1a8bef9faad9ee36f0bbc19fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb0584dfb425f6c1a8bef9faad9ee36f0bbc19fb", "html_url": "https://github.com/rust-lang/rust/commit/bb0584dfb425f6c1a8bef9faad9ee36f0bbc19fb"}], "stats": {"total": 206, "additions": 106, "deletions": 100}, "files": [{"sha": "bb5b286626858d1742eb50a2cc75088dca49a755", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "patch": "@@ -213,6 +213,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::UNNECESSARY_FIND_MAP),\n     LintId::of(methods::UNNECESSARY_FOLD),\n     LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n+    LintId::of(methods::UNNECESSARY_SORT_BY),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n     LintId::of(methods::USELESS_ASREF),\n@@ -334,7 +335,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n     LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n     LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n-    LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n     LintId::of(unused_unit::UNUSED_UNIT),"}, {"sha": "0f7433a79be300893d4ad90b96ec85ecf20b1e5e", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "patch": "@@ -57,6 +57,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::SKIP_WHILE_NEXT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n     LintId::of(methods::UNNECESSARY_FIND_MAP),\n+    LintId::of(methods::UNNECESSARY_SORT_BY),\n     LintId::of(methods::USELESS_ASREF),\n     LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n     LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n@@ -99,7 +100,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(types::TYPE_COMPLEXITY),\n     LintId::of(types::VEC_BOX),\n     LintId::of(unit_types::UNIT_ARG),\n-    LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unwrap::UNNECESSARY_UNWRAP),\n     LintId::of(useless_conversion::USELESS_CONVERSION),\n     LintId::of(zero_div_zero::ZERO_DIVIDED_BY_ZERO),"}, {"sha": "f5497c6bd6bcad37eb4755c4a14c8fc493f682a8", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "patch": "@@ -364,6 +364,7 @@ store.register_lints(&[\n     methods::UNNECESSARY_FOLD,\n     methods::UNNECESSARY_JOIN,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n+    methods::UNNECESSARY_SORT_BY,\n     methods::UNNECESSARY_TO_OWNED,\n     methods::UNWRAP_OR_ELSE_DEFAULT,\n     methods::UNWRAP_USED,\n@@ -567,7 +568,6 @@ store.register_lints(&[\n     unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n     unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS,\n     unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS,\n-    unnecessary_sort_by::UNNECESSARY_SORT_BY,\n     unnecessary_wraps::UNNECESSARY_WRAPS,\n     unnested_or_patterns::UNNESTED_OR_PATTERNS,\n     unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,"}, {"sha": "cfcd4e3d1419953025a2973f8c6caa5c5f12aa27", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "patch": "@@ -376,7 +376,6 @@ mod unit_types;\n mod unnamed_address;\n mod unnecessary_owned_empty_strings;\n mod unnecessary_self_imports;\n-mod unnecessary_sort_by;\n mod unnecessary_wraps;\n mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n@@ -716,7 +715,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(ptr_offset_with_cast::PtrOffsetWithCast));\n     store.register_late_pass(|| Box::new(redundant_clone::RedundantClone));\n     store.register_late_pass(|| Box::new(slow_vector_initialization::SlowVectorInit));\n-    store.register_late_pass(|| Box::new(unnecessary_sort_by::UnnecessarySortBy));\n     store.register_late_pass(move || Box::new(unnecessary_wraps::UnnecessaryWraps::new(avoid_breaking_exported_api)));\n     store.register_late_pass(|| Box::new(assertions_on_constants::AssertionsOnConstants));\n     store.register_late_pass(|| Box::new(assertions_on_result_states::AssertionsOnResultStates));"}, {"sha": "54a0275da963337bc00209f8dfc4430da9374c77", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "patch": "@@ -84,6 +84,7 @@ mod unnecessary_fold;\n mod unnecessary_iter_cloned;\n mod unnecessary_join;\n mod unnecessary_lazy_eval;\n+mod unnecessary_sort_by;\n mod unnecessary_to_owned;\n mod unwrap_or_else_default;\n mod unwrap_used;\n@@ -2872,6 +2873,40 @@ declare_clippy_lint! {\n     \"hashing a unit value, which does nothing\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects uses of `Vec::sort_by` passing in a closure\n+    /// which compares the two arguments, either directly or indirectly.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n+    /// possible) than to use `Vec::sort_by` and a more complicated\n+    /// closure.\n+    ///\n+    /// ### Known problems\n+    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't already\n+    /// imported by a use statement, then it will need to be added manually.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by_key(|a| a.foo());\n+    /// ```\n+    #[clippy::version = \"1.46.0\"]\n+    pub UNNECESSARY_SORT_BY,\n+    complexity,\n+    \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2990,6 +3025,7 @@ impl_lint_pass!(Methods => [\n     REPEAT_ONCE,\n     STABLE_SORT_PRIMITIVE,\n     UNIT_HASH,\n+    UNNECESSARY_SORT_BY,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -3387,6 +3423,12 @@ impl Methods {\n                 (\"sort\", []) => {\n                     stable_sort_primitive::check(cx, expr, recv);\n                 },\n+                (\"sort_by\", [arg]) => {\n+                    unnecessary_sort_by::check(cx, expr, recv, arg, false);\n+                },\n+                (\"sort_unstable_by\", [arg]) => {\n+                    unnecessary_sort_by::check(cx, expr, recv, arg, true);\n+                },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                     if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);"}, {"sha": "1966990bd774f929a37551329aff18832c326c17", "filename": "clippy_lints/src/methods/unnecessary_sort_by.rs", "status": "renamed", "additions": 61, "deletions": 95, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d4a135ea2bc460033c75d4a56d21ae977b9ae2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs?ref=d8d4a135ea2bc460033c75d4a56d21ae977b9ae2", "patch": "@@ -1,51 +1,17 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_trait_method;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n+use clippy_utils::ty::implements_trait;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Closure, Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n use rustc_span::symbol::Ident;\n use std::iter;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Detects uses of `Vec::sort_by` passing in a closure\n-    /// which compares the two arguments, either directly or indirectly.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n-    /// possible) than to use `Vec::sort_by` and a more complicated\n-    /// closure.\n-    ///\n-    /// ### Known problems\n-    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't already\n-    /// imported by a use statement, then it will need to be added manually.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # struct A;\n-    /// # impl A { fn foo(&self) {} }\n-    /// # let mut vec: Vec<A> = Vec::new();\n-    /// vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # struct A;\n-    /// # impl A { fn foo(&self) {} }\n-    /// # let mut vec: Vec<A> = Vec::new();\n-    /// vec.sort_by_key(|a| a.foo());\n-    /// ```\n-    #[clippy::version = \"1.46.0\"]\n-    pub UNNECESSARY_SORT_BY,\n-    complexity,\n-    \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\"\n-}\n-\n-declare_lint_pass!(UnnecessarySortBy => [UNNECESSARY_SORT_BY]);\n+use super::UNNECESSARY_SORT_BY;\n \n enum LintTrigger {\n     Sort(SortDetection),\n@@ -54,15 +20,13 @@ enum LintTrigger {\n \n struct SortDetection {\n     vec_name: String,\n-    unstable: bool,\n }\n \n struct SortByKeyDetection {\n     vec_name: String,\n     closure_arg: String,\n     closure_body: String,\n     reverse: bool,\n-    unstable: bool,\n }\n \n /// Detect if the two expressions are mirrored (identical, except one\n@@ -150,20 +114,20 @@ fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident\n     }\n }\n \n-fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n+fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Expr<'_>) -> Option<LintTrigger> {\n     if_chain! {\n-        if let ExprKind::MethodCall(name_ident, args, _) = &expr.kind;\n-        if let name = name_ident.ident.name.to_ident_string();\n-        if name == \"sort_by\" || name == \"sort_unstable_by\";\n-        if let [vec, Expr { kind: ExprKind::Closure(Closure { body: closure_body_id, .. }), .. }] = args;\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(vec), sym::Vec);\n-        if let closure_body = cx.tcx.hir().body(*closure_body_id);\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if cx.tcx.type_of(impl_id).is_slice();\n+        if let ExprKind::Closure(&Closure { body, .. }) = arg.kind;\n+        if let closure_body = cx.tcx.hir().body(body);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n-        if let ExprKind::MethodCall(method_path, [ref left_expr, ref right_expr], _) = &closure_body.value.kind;\n+        if let ExprKind::MethodCall(method_path, [left_expr, right_expr], _) = closure_body.value.kind;\n         if method_path.ident.name == sym::cmp;\n+        if is_trait_method(cx, &closure_body.value, sym::Ord);\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n                 left_expr,\n@@ -177,19 +141,18 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             } else {\n                 return None;\n             };\n-            let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n-            let unstable = name == \"sort_unstable_by\";\n+            let vec_name = Sugg::hir(cx, recv, \"..\").to_string();\n \n             if_chain! {\n-            if let ExprKind::Path(QPath::Resolved(_, Path {\n-                segments: [PathSegment { ident: left_name, .. }], ..\n-            })) = &left_expr.kind;\n-            if left_name == left_ident;\n-            if cx.tcx.get_diagnostic_item(sym::Ord).map_or(false, |id| {\n-                implements_trait(cx, cx.typeck_results().expr_ty(left_expr), id, &[])\n-            });\n+                if let ExprKind::Path(QPath::Resolved(_, Path {\n+                    segments: [PathSegment { ident: left_name, .. }], ..\n+                })) = &left_expr.kind;\n+                if left_name == left_ident;\n+                if cx.tcx.get_diagnostic_item(sym::Ord).map_or(false, |id| {\n+                    implements_trait(cx, cx.typeck_results().expr_ty(left_expr), id, &[])\n+                });\n                 then {\n-                    return Some(LintTrigger::Sort(SortDetection { vec_name, unstable }));\n+                    return Some(LintTrigger::Sort(SortDetection { vec_name }));\n                 }\n             }\n \n@@ -199,7 +162,6 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n                     closure_arg,\n                     closure_body,\n                     reverse,\n-                    unstable,\n                 }));\n             }\n         }\n@@ -213,46 +175,50 @@ fn expr_borrows(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     matches!(ty.kind(), ty::Ref(..)) || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n-impl LateLintPass<'_> for UnnecessarySortBy {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        match detect_lint(cx, expr) {\n-            Some(LintTrigger::SortByKey(trigger)) => span_lint_and_sugg(\n-                cx,\n-                UNNECESSARY_SORT_BY,\n-                expr.span,\n-                \"use Vec::sort_by_key here instead\",\n-                \"try\",\n-                format!(\n-                    \"{}.sort{}_by_key(|{}| {})\",\n-                    trigger.vec_name,\n-                    if trigger.unstable { \"_unstable\" } else { \"\" },\n-                    trigger.closure_arg,\n-                    if trigger.reverse {\n-                        format!(\"std::cmp::Reverse({})\", trigger.closure_body)\n-                    } else {\n-                        trigger.closure_body.to_string()\n-                    },\n-                ),\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    recv: &'tcx Expr<'_>,\n+    arg: &'tcx Expr<'_>,\n+    is_unstable: bool,\n+) {\n+    match detect_lint(cx, expr, recv, arg) {\n+        Some(LintTrigger::SortByKey(trigger)) => span_lint_and_sugg(\n+            cx,\n+            UNNECESSARY_SORT_BY,\n+            expr.span,\n+            \"use Vec::sort_by_key here instead\",\n+            \"try\",\n+            format!(\n+                \"{}.sort{}_by_key(|{}| {})\",\n+                trigger.vec_name,\n+                if is_unstable { \"_unstable\" } else { \"\" },\n+                trigger.closure_arg,\n                 if trigger.reverse {\n-                    Applicability::MaybeIncorrect\n+                    format!(\"std::cmp::Reverse({})\", trigger.closure_body)\n                 } else {\n-                    Applicability::MachineApplicable\n+                    trigger.closure_body.to_string()\n                 },\n             ),\n-            Some(LintTrigger::Sort(trigger)) => span_lint_and_sugg(\n-                cx,\n-                UNNECESSARY_SORT_BY,\n-                expr.span,\n-                \"use Vec::sort here instead\",\n-                \"try\",\n-                format!(\n-                    \"{}.sort{}()\",\n-                    trigger.vec_name,\n-                    if trigger.unstable { \"_unstable\" } else { \"\" },\n-                ),\n-                Applicability::MachineApplicable,\n+            if trigger.reverse {\n+                Applicability::MaybeIncorrect\n+            } else {\n+                Applicability::MachineApplicable\n+            },\n+        ),\n+        Some(LintTrigger::Sort(trigger)) => span_lint_and_sugg(\n+            cx,\n+            UNNECESSARY_SORT_BY,\n+            expr.span,\n+            \"use Vec::sort here instead\",\n+            \"try\",\n+            format!(\n+                \"{}.sort{}()\",\n+                trigger.vec_name,\n+                if is_unstable { \"_unstable\" } else { \"\" },\n             ),\n-            None => {},\n-        }\n+            Applicability::MachineApplicable,\n+        ),\n+        None => {},\n     }\n }", "previous_filename": "clippy_lints/src/unnecessary_sort_by.rs"}]}