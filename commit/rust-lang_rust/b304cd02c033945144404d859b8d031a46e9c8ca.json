{"sha": "b304cd02c033945144404d859b8d031a46e9c8ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMDRjZDAyYzAzMzk0NTE0NDQwNGQ4NTliOGQwMzFhNDZlOWM4Y2E=", "commit": {"author": {"name": "Andreas Jonson", "email": "andjo403@users.noreply.github.com", "date": "2019-08-29T21:15:31Z"}, "committer": {"name": "Andreas Jonson", "email": "andjo403@users.noreply.github.com", "date": "2019-08-29T21:15:31Z"}, "message": "Run doctests via out-of-process rustc", "tree": {"sha": "afb236ad3628889b781af6c389e744441c21c88c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afb236ad3628889b781af6c389e744441c21c88c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b304cd02c033945144404d859b8d031a46e9c8ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b304cd02c033945144404d859b8d031a46e9c8ca", "html_url": "https://github.com/rust-lang/rust/commit/b304cd02c033945144404d859b8d031a46e9c8ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b304cd02c033945144404d859b8d031a46e9c8ca/comments", "author": {"login": "andjo403", "id": 844398, "node_id": "MDQ6VXNlcjg0NDM5OA==", "avatar_url": "https://avatars.githubusercontent.com/u/844398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andjo403", "html_url": "https://github.com/andjo403", "followers_url": "https://api.github.com/users/andjo403/followers", "following_url": "https://api.github.com/users/andjo403/following{/other_user}", "gists_url": "https://api.github.com/users/andjo403/gists{/gist_id}", "starred_url": "https://api.github.com/users/andjo403/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andjo403/subscriptions", "organizations_url": "https://api.github.com/users/andjo403/orgs", "repos_url": "https://api.github.com/users/andjo403/repos", "events_url": "https://api.github.com/users/andjo403/events{/privacy}", "received_events_url": "https://api.github.com/users/andjo403/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andjo403", "id": 844398, "node_id": "MDQ6VXNlcjg0NDM5OA==", "avatar_url": "https://avatars.githubusercontent.com/u/844398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andjo403", "html_url": "https://github.com/andjo403", "followers_url": "https://api.github.com/users/andjo403/followers", "following_url": "https://api.github.com/users/andjo403/following{/other_user}", "gists_url": "https://api.github.com/users/andjo403/gists{/gist_id}", "starred_url": "https://api.github.com/users/andjo403/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andjo403/subscriptions", "organizations_url": "https://api.github.com/users/andjo403/orgs", "repos_url": "https://api.github.com/users/andjo403/repos", "events_url": "https://api.github.com/users/andjo403/events{/privacy}", "received_events_url": "https://api.github.com/users/andjo403/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56ab485fbe61add87ac8febea421e2a576edca26", "url": "https://api.github.com/repos/rust-lang/rust/commits/56ab485fbe61add87ac8febea421e2a576edca26", "html_url": "https://github.com/rust-lang/rust/commit/56ab485fbe61add87ac8febea421e2a576edca26"}], "stats": {"total": 233, "additions": 82, "deletions": 151}, "files": [{"sha": "30b1706f29464f28bc0074495a548927f8c2ea83", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b304cd02c033945144404d859b8d031a46e9c8ca/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b304cd02c033945144404d859b8d031a46e9c8ca/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=b304cd02c033945144404d859b8d031a46e9c8ca", "patch": "@@ -39,12 +39,18 @@ pub struct Options {\n     pub error_format: ErrorOutputType,\n     /// Library search paths to hand to the compiler.\n     pub libs: Vec<SearchPath>,\n+    /// Library search paths strings to hand to the compiler.\n+    pub lib_strs: Vec<String>,\n     /// The list of external crates to link against.\n     pub externs: Externs,\n+    /// The list of external crates strings to link against.\n+    pub extern_strs: Vec<String>,\n     /// List of `cfg` flags to hand to the compiler. Always includes `rustdoc`.\n     pub cfgs: Vec<String>,\n     /// Codegen options to hand to the compiler.\n     pub codegen_options: CodegenOptions,\n+    /// Codegen options strings to hand to the compiler.\n+    pub codegen_options_strs: Vec<String>,\n     /// Debugging (`-Z`) options to pass to the compiler.\n     pub debugging_options: DebuggingOptions,\n     /// The target used to compile the crate against.\n@@ -461,6 +467,9 @@ impl Options {\n         let generate_search_filter = !matches.opt_present(\"disable-per-crate-search\");\n         let persist_doctests = matches.opt_str(\"persist-doctests\").map(PathBuf::from);\n         let generate_redirect_pages = matches.opt_present(\"generate-redirect-pages\");\n+        let codegen_options_strs = matches.opt_strs(\"C\");\n+        let lib_strs = matches.opt_strs(\"L\");\n+        let extern_strs = matches.opt_strs(\"extern\");\n \n         let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n \n@@ -470,9 +479,12 @@ impl Options {\n             proc_macro_crate,\n             error_format,\n             libs,\n+            lib_strs,\n             externs,\n+            extern_strs,\n             cfgs,\n             codegen_options,\n+            codegen_options_strs,\n             debugging_options,\n             target,\n             edition,"}, {"sha": "a30fc05f36acde4e5cfca763bc921d734473ae73", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b304cd02c033945144404d859b8d031a46e9c8ca/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b304cd02c033945144404d859b8d031a46e9c8ca/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=b304cd02c033945144404d859b8d031a46e9c8ca", "patch": "@@ -142,11 +142,8 @@ pub fn test(mut options: Options, diag: &errors::Handler) -> i32 {\n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n     opts.display_warnings = options.display_warnings;\n-    let mut collector = Collector::new(options.input.display().to_string(), options.cfgs,\n-                                       options.libs, options.codegen_options, options.externs,\n-                                       true, opts, options.maybe_sysroot, None,\n-                                       Some(options.input),\n-                                       options.linker, options.edition, options.persist_doctests);\n+    let mut collector = Collector::new(options.input.display().to_string(), options.clone(),\n+                                       true, opts, None, Some(options.input));\n     collector.set_position(DUMMY_SP);\n     let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n "}, {"sha": "70511131e5302ab20178d64f3b44a6c051536d6b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 68, "deletions": 146, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/b304cd02c033945144404d859b8d031a46e9c8ca/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b304cd02c033945144404d859b8d031a46e9c8ca/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=b304cd02c033945144404d859b8d031a46e9c8ca", "patch": "@@ -2,24 +2,19 @@ use rustc_data_structures::sync::Lrc;\n use rustc_interface::interface;\n use rustc::hir;\n use rustc::hir::intravisit;\n-use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::{self, config, DiagnosticOutput};\n-use rustc::session::config::{OutputType, OutputTypes, Externs, CodegenOptions};\n-use rustc::session::search_paths::SearchPath;\n use rustc::util::common::ErrorReported;\n use syntax::ast;\n use syntax::with_globals;\n use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use std::env;\n-use std::io::prelude::*;\n-use std::io;\n-use std::panic::{self, AssertUnwindSafe};\n+use std::io::{self, Write};\n+use std::panic;\n use std::path::PathBuf;\n-use std::process::{self, Command};\n+use std::process::{self, Command, Stdio};\n use std::str;\n-use std::sync::{Arc, Mutex};\n use syntax::symbol::sym;\n use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n use tempfile::Builder as TempFileBuilder;\n@@ -89,18 +84,11 @@ pub fn run(options: Options) -> i32 {\n         opts.display_warnings |= options.display_warnings;\n         let mut collector = Collector::new(\n             compiler.crate_name()?.peek().to_string(),\n-            options.cfgs,\n-            options.libs,\n-            options.codegen_options,\n-            options.externs,\n+            options,\n             false,\n             opts,\n-            options.maybe_sysroot,\n             Some(compiler.source_map().clone()),\n             None,\n-            options.linker,\n-            options.edition,\n-            options.persist_doctests,\n         );\n \n         let mut global_ctxt = compiler.global_ctxt()?.take();\n@@ -189,20 +177,14 @@ fn run_test(\n     cratename: &str,\n     filename: &FileName,\n     line: usize,\n-    cfgs: Vec<String>,\n-    libs: Vec<SearchPath>,\n-    cg: CodegenOptions,\n-    externs: Externs,\n+    options: Options,\n     should_panic: bool,\n     no_run: bool,\n     as_test_harness: bool,\n     compile_fail: bool,\n     mut error_codes: Vec<String>,\n     opts: &TestOptions,\n-    maybe_sysroot: Option<PathBuf>,\n-    linker: Option<PathBuf>,\n     edition: Edition,\n-    persist_doctests: Option<PathBuf>,\n ) -> Result<(), TestFailure> {\n     let (test, line_offset) = match panic::catch_unwind(|| {\n         make_test(test, Some(cratename), as_test_harness, opts, edition)\n@@ -223,61 +205,6 @@ fn run_test(\n         _ => PathBuf::from(r\"doctest.rs\"),\n     };\n \n-    let input = config::Input::Str {\n-        name: FileName::DocTest(path, line as isize - line_offset as isize),\n-        input: test,\n-    };\n-    let outputs = OutputTypes::new(&[(OutputType::Exe, None)]);\n-\n-    let sessopts = config::Options {\n-        maybe_sysroot,\n-        search_paths: libs,\n-        crate_types: vec![config::CrateType::Executable],\n-        output_types: outputs,\n-        externs,\n-        cg: config::CodegenOptions {\n-            linker,\n-            ..cg\n-        },\n-        test: as_test_harness,\n-        unstable_features: UnstableFeatures::from_environment(),\n-        debugging_opts: config::DebuggingOptions {\n-            ..config::basic_debugging_options()\n-        },\n-        edition,\n-        ..config::Options::default()\n-    };\n-\n-    // Shuffle around a few input and output handles here. We're going to pass\n-    // an explicit handle into rustc to collect output messages, but we also\n-    // want to catch the error message that rustc prints when it fails.\n-    //\n-    // We take our thread-local stderr (likely set by the test runner) and replace\n-    // it with a sink that is also passed to rustc itself. When this function\n-    // returns the output of the sink is copied onto the output of our own thread.\n-    //\n-    // The basic idea is to not use a default Handler for rustc, and then also\n-    // not print things by default to the actual stderr.\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n-        }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-    struct Bomb(Arc<Mutex<Vec<u8>>>, Option<Box<dyn Write+Send>>);\n-    impl Drop for Bomb {\n-        fn drop(&mut self) {\n-            let mut old = self.1.take().unwrap();\n-            let _ = old.write_all(&self.0.lock().unwrap());\n-            io::set_panic(Some(old));\n-        }\n-    }\n-    let data = Arc::new(Mutex::new(Vec::new()));\n-\n-    let old = io::set_panic(Some(box Sink(data.clone())));\n-    let _bomb = Bomb(data.clone(), Some(old.unwrap_or(box io::stdout())));\n-\n     enum DirState {\n         Temp(tempfile::TempDir),\n         Perm(PathBuf),\n@@ -292,7 +219,7 @@ fn run_test(\n         }\n     }\n \n-    let outdir = if let Some(mut path) = persist_doctests {\n+    let outdir = if let Some(mut path) = options.persist_doctests {\n         path.push(format!(\"{}_{}\",\n             filename\n                 .to_string()\n@@ -314,49 +241,73 @@ fn run_test(\n     };\n     let output_file = outdir.path().join(\"rust_out\");\n \n-    let config = interface::Config {\n-        opts: sessopts,\n-        crate_cfg: config::parse_cfgspecs(cfgs),\n-        input,\n-        input_path: None,\n-        output_file: Some(output_file.clone()),\n-        output_dir: None,\n-        file_loader: None,\n-        diagnostic_output: DiagnosticOutput::Raw(box Sink(data.clone())),\n-        stderr: Some(data.clone()),\n-        crate_name: None,\n-        lint_caps: Default::default(),\n-    };\n+    let mut compiler = Command::new(std::env::current_exe().unwrap().with_file_name(\"rustc\"));\n+    compiler.arg(\"--crate-type\").arg(\"bin\");\n+    for cfg in &options.cfgs {\n+        compiler.arg(\"--cfg\").arg(&cfg);\n+    }\n+    if let Some(sysroot) = options.maybe_sysroot {\n+        compiler.arg(\"--sysroot\").arg(sysroot);\n+    }\n+    compiler.arg(\"--edition\").arg(&edition.to_string());\n+    compiler.env(\"UNSTABLE_RUSTDOC_TEST_PATH\", path);\n+    compiler.env(\"UNSTABLE_RUSTDOC_TEST_LINE\",\n+                 format!(\"{}\", line as isize - line_offset as isize));\n+    compiler.arg(\"-o\").arg(&output_file);\n+    if as_test_harness {\n+        compiler.arg(\"--test\");\n+    }\n+    for lib_str in &options.lib_strs {\n+        compiler.arg(\"-L\").arg(&lib_str);\n+    }\n+    for extern_str in &options.extern_strs {\n+        compiler.arg(\"--extern\").arg(&extern_str);\n+    }\n+    for codegen_options_str in &options.codegen_options_strs {\n+        compiler.arg(\"-C\").arg(&codegen_options_str);\n+    }\n+    if let Some(linker) = options.linker {\n+        compiler.arg(&format!(\"-C linker={:?}\", linker));\n+    }\n+    if no_run {\n+        compiler.arg(\"--emit=metadata\");\n+    }\n \n-    let compile_result = panic::catch_unwind(AssertUnwindSafe(|| {\n-        interface::run_compiler(config, |compiler| {\n-            if no_run {\n-                compiler.global_ctxt().and_then(|global_ctxt| global_ctxt.take().enter(|tcx| {\n-                    tcx.analysis(LOCAL_CRATE)\n-                })).ok();\n-            } else {\n-                compiler.compile().ok();\n-            };\n-            compiler.session().compile_status()\n-        })\n-    })).map_err(|_| ()).and_then(|s| s.map_err(|_| ()));\n+    compiler.arg(\"-\");\n+    compiler.stdin(Stdio::piped());\n+    compiler.stderr(Stdio::piped());\n+\n+    let mut child = compiler.spawn().expect(\"Failed to spawn rustc process\");\n+    {\n+        let stdin = child.stdin.as_mut().expect(\"Failed to open stdin\");\n+        stdin.write_all(test.as_bytes()).expect(\"could write out test sources\");\n+    }\n+    let output = child.wait_with_output().expect(\"Failed to read stdout\");\n \n-    match (compile_result, compile_fail) {\n-        (Ok(()), true) => {\n+    struct Bomb<'a>(&'a str);\n+    impl Drop for Bomb<'_> {\n+        fn drop(&mut self) {\n+            eprint!(\"{}\",self.0);\n+        }\n+    }\n+\n+    let out = str::from_utf8(&output.stderr).unwrap();\n+    let _bomb = Bomb(&out);\n+    match (output.status.success(), compile_fail) {\n+        (true, true) => {\n             return Err(TestFailure::UnexpectedCompilePass);\n         }\n-        (Ok(()), false) => {}\n-        (Err(_), true) => {\n+        (true, false) => {}\n+        (false, true) => {\n             if !error_codes.is_empty() {\n-                let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n                 error_codes.retain(|err| !out.contains(err));\n \n                 if !error_codes.is_empty() {\n                     return Err(TestFailure::MissingErrorCodes(error_codes));\n                 }\n             }\n         }\n-        (Err(_), false) => {\n+        (false, false) => {\n             return Err(TestFailure::CompileError);\n         }\n     }\n@@ -652,45 +603,28 @@ pub struct Collector {\n     // the `names` vector of that test will be `[\"Title\", \"Subtitle\"]`.\n     names: Vec<String>,\n \n-    cfgs: Vec<String>,\n-    libs: Vec<SearchPath>,\n-    cg: CodegenOptions,\n-    externs: Externs,\n+    options: Options,\n     use_headers: bool,\n     cratename: String,\n     opts: TestOptions,\n-    maybe_sysroot: Option<PathBuf>,\n     position: Span,\n     source_map: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n-    linker: Option<PathBuf>,\n-    edition: Edition,\n-    persist_doctests: Option<PathBuf>,\n }\n \n impl Collector {\n-    pub fn new(cratename: String, cfgs: Vec<String>, libs: Vec<SearchPath>, cg: CodegenOptions,\n-               externs: Externs, use_headers: bool, opts: TestOptions,\n-               maybe_sysroot: Option<PathBuf>, source_map: Option<Lrc<SourceMap>>,\n-               filename: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition,\n-               persist_doctests: Option<PathBuf>) -> Collector {\n+    pub fn new(cratename: String, options: Options, use_headers: bool, opts: TestOptions,\n+               source_map: Option<Lrc<SourceMap>>, filename: Option<PathBuf>,) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n-            cfgs,\n-            libs,\n-            cg,\n-            externs,\n+            options,\n             use_headers,\n             cratename,\n             opts,\n-            maybe_sysroot,\n             position: DUMMY_SP,\n             source_map,\n             filename,\n-            linker,\n-            edition,\n-            persist_doctests,\n         }\n     }\n \n@@ -725,16 +659,10 @@ impl Tester for Collector {\n     fn add_test(&mut self, test: String, config: LangString, line: usize) {\n         let filename = self.get_filename();\n         let name = self.generate_name(line, &filename);\n-        let cfgs = self.cfgs.clone();\n-        let libs = self.libs.clone();\n-        let cg = self.cg.clone();\n-        let externs = self.externs.clone();\n         let cratename = self.cratename.to_string();\n         let opts = self.opts.clone();\n-        let maybe_sysroot = self.maybe_sysroot.clone();\n-        let linker = self.linker.clone();\n-        let edition = config.edition.unwrap_or(self.edition);\n-        let persist_doctests = self.persist_doctests.clone();\n+        let edition = config.edition.unwrap_or(self.options.edition.clone());\n+        let options = self.options.clone();\n \n         debug!(\"creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n@@ -751,20 +679,14 @@ impl Tester for Collector {\n                     &cratename,\n                     &filename,\n                     line,\n-                    cfgs,\n-                    libs,\n-                    cg,\n-                    externs,\n+                    options,\n                     config.should_panic,\n                     config.no_run,\n                     config.test_harness,\n                     config.compile_fail,\n                     config.error_codes,\n                     &opts,\n-                    maybe_sysroot,\n-                    linker,\n                     edition,\n-                    persist_doctests\n                 );\n \n                 if let Err(err) = res {"}]}