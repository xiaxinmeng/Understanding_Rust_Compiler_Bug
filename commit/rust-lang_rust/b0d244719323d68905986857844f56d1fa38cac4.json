{"sha": "b0d244719323d68905986857844f56d1fa38cac4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZDI0NDcxOTMyM2Q2ODkwNTk4Njg1Nzg0NGY1NmQxZmEzOGNhYzQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-02T10:02:48Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-02T10:02:48Z"}, "message": "Merge #1088\n\n1088: add minimal comments r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "32ae51ee2d96c526bcfb9eb3f3a8adf18aca39c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32ae51ee2d96c526bcfb9eb3f3a8adf18aca39c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0d244719323d68905986857844f56d1fa38cac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0d244719323d68905986857844f56d1fa38cac4", "html_url": "https://github.com/rust-lang/rust/commit/b0d244719323d68905986857844f56d1fa38cac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0d244719323d68905986857844f56d1fa38cac4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "370dbc7867719662f26db5684ac82cfc25b5b8cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/370dbc7867719662f26db5684ac82cfc25b5b8cb", "html_url": "https://github.com/rust-lang/rust/commit/370dbc7867719662f26db5684ac82cfc25b5b8cb"}, {"sha": "ab19ff16e55d4d64445fc2809e52d913ad492040", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab19ff16e55d4d64445fc2809e52d913ad492040", "html_url": "https://github.com/rust-lang/rust/commit/ab19ff16e55d4d64445fc2809e52d913ad492040"}], "stats": {"total": 1194, "additions": 612, "deletions": 582}, "files": [{"sha": "2b451f08d6d8137c82ff38b1a80f68b9ad9051b4", "filename": "crates/ra_assists/src/replace_if_let_with_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -11,8 +11,8 @@ pub(crate) fn replace_if_let_with_match(mut ctx: AssistCtx<impl HirDatabase>) ->\n     let expr = cond.expr()?;\n     let then_block = if_expr.then_branch()?;\n     let else_block = match if_expr.else_branch()? {\n-        ast::ElseBranchFlavor::Block(it) => it,\n-        ast::ElseBranchFlavor::IfExpr(_) => return None,\n+        ast::ElseBranch::Block(it) => it,\n+        ast::ElseBranch::IfExpr(_) => return None,\n     };\n \n     ctx.add_action(AssistId(\"replace_if_let_with_match\"), \"replace with match\", |edit| {"}, {"sha": "e027eedd9c937cfeb2cbaec7769e565f348f7ab2", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -6,7 +6,7 @@ use std::sync::Arc;\n use ra_arena::{RawId, Arena, impl_arena_id};\n use ra_syntax::{\n     TreeArc,\n-    ast::{self, NameOwner, StructFlavor, TypeAscriptionOwner}\n+    ast::{self, NameOwner, StructKind, TypeAscriptionOwner}\n };\n \n use crate::{\n@@ -47,7 +47,7 @@ pub struct StructData {\n impl StructData {\n     fn new(struct_def: &ast::StructDef) -> StructData {\n         let name = struct_def.name().map(|n| n.as_name());\n-        let variant_data = VariantData::new(struct_def.flavor());\n+        let variant_data = VariantData::new(struct_def.kind());\n         let variant_data = Arc::new(variant_data);\n         StructData { name, variant_data }\n     }\n@@ -94,7 +94,7 @@ impl EnumData {\n         let variants = variants(&*enum_def)\n             .map(|var| EnumVariantData {\n                 name: var.name().map(|it| it.as_name()),\n-                variant_data: Arc::new(VariantData::new(var.flavor())),\n+                variant_data: Arc::new(VariantData::new(var.kind())),\n             })\n             .collect();\n         Arc::new(EnumData { name, variants })\n@@ -143,9 +143,9 @@ impl VariantData {\n }\n \n impl VariantData {\n-    fn new(flavor: StructFlavor) -> Self {\n+    fn new(flavor: StructKind) -> Self {\n         let inner = match flavor {\n-            ast::StructFlavor::Tuple(fl) => {\n+            ast::StructKind::Tuple(fl) => {\n                 let fields = fl\n                     .fields()\n                     .enumerate()\n@@ -156,7 +156,7 @@ impl VariantData {\n                     .collect();\n                 VariantDataInner::Tuple(fields)\n             }\n-            ast::StructFlavor::Named(fl) => {\n+            ast::StructKind::Named(fl) => {\n                 let fields = fl\n                     .fields()\n                     .map(|fd| StructFieldData {\n@@ -166,7 +166,7 @@ impl VariantData {\n                     .collect();\n                 VariantDataInner::Struct(fields)\n             }\n-            ast::StructFlavor::Unit => VariantDataInner::Unit,\n+            ast::StructKind::Unit => VariantDataInner::Unit,\n         };\n         VariantData(inner)\n     }\n@@ -200,27 +200,27 @@ impl StructField {\n         let fields = var_data.fields().unwrap();\n         let ss;\n         let es;\n-        let (file_id, struct_flavor) = match self.parent {\n+        let (file_id, struct_kind) = match self.parent {\n             VariantDef::Struct(s) => {\n                 let (file_id, source) = s.source(db);\n                 ss = source;\n-                (file_id, ss.flavor())\n+                (file_id, ss.kind())\n             }\n             VariantDef::EnumVariant(e) => {\n                 let (file_id, source) = e.source(db);\n                 es = source;\n-                (file_id, es.flavor())\n+                (file_id, es.kind())\n             }\n         };\n \n-        let field_sources = match struct_flavor {\n-            ast::StructFlavor::Tuple(fl) => {\n+        let field_sources = match struct_kind {\n+            ast::StructKind::Tuple(fl) => {\n                 fl.fields().map(|it| FieldSource::Pos(it.to_owned())).collect()\n             }\n-            ast::StructFlavor::Named(fl) => {\n+            ast::StructKind::Named(fl) => {\n                 fl.fields().map(|it| FieldSource::Named(it.to_owned())).collect()\n             }\n-            ast::StructFlavor::Unit => Vec::new(),\n+            ast::StructKind::Unit => Vec::new(),\n         };\n         let field = field_sources\n             .into_iter()"}, {"sha": "f8bd0f7847728258ace86b6987292bed4e4a8e70", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -20,12 +20,12 @@ impl FnSignature {\n                     TypeRef::from_ast(type_ref)\n                 } else {\n                     let self_type = TypeRef::Path(Name::self_type().into());\n-                    match self_param.flavor() {\n-                        ast::SelfParamFlavor::Owned => self_type,\n-                        ast::SelfParamFlavor::Ref => {\n+                    match self_param.kind() {\n+                        ast::SelfParamKind::Owned => self_type,\n+                        ast::SelfParamKind::Ref => {\n                             TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n                         }\n-                        ast::SelfParamFlavor::MutRef => {\n+                        ast::SelfParamKind::MutRef => {\n                             TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n                         }\n                     }"}, {"sha": "45012827f45f66a93cc26081dd7bf6790bd2cf4f", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -6,7 +6,7 @@ use rustc_hash::FxHashMap;\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_syntax::{\n     SyntaxNodePtr, AstPtr, AstNode,\n-    ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor, TypeAscriptionOwner}\n+    ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralKind, TypeAscriptionOwner}\n };\n \n use crate::{\n@@ -516,8 +516,8 @@ impl ExprCollector {\n                     let else_branch = e\n                         .else_branch()\n                         .map(|b| match b {\n-                            ast::ElseBranchFlavor::Block(it) => self.collect_block(it),\n-                            ast::ElseBranchFlavor::IfExpr(elif) => {\n+                            ast::ElseBranch::Block(it) => self.collect_block(it),\n+                            ast::ElseBranch::IfExpr(elif) => {\n                                 let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n                                 self.collect_expr(expr)\n                             }\n@@ -533,8 +533,8 @@ impl ExprCollector {\n                     let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()));\n                     let then_branch = self.collect_block_opt(e.then_branch());\n                     let else_branch = e.else_branch().map(|b| match b {\n-                        ast::ElseBranchFlavor::Block(it) => self.collect_block(it),\n-                        ast::ElseBranchFlavor::IfExpr(elif) => {\n+                        ast::ElseBranch::Block(it) => self.collect_block(it),\n+                        ast::ElseBranch::IfExpr(elif) => {\n                             let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n                             self.collect_expr(expr)\n                         }\n@@ -726,8 +726,8 @@ impl ExprCollector {\n                 self.alloc_expr(Expr::Array { exprs }, syntax_ptr)\n             }\n             ast::ExprKind::Literal(e) => {\n-                let lit = match e.flavor() {\n-                    LiteralFlavor::IntNumber { suffix } => {\n+                let lit = match e.kind() {\n+                    LiteralKind::IntNumber { suffix } => {\n                         let known_name = suffix\n                             .and_then(|it| IntTy::from_suffix(&it).map(UncertainIntTy::Known));\n \n@@ -736,7 +736,7 @@ impl ExprCollector {\n                             known_name.unwrap_or(UncertainIntTy::Unknown),\n                         )\n                     }\n-                    LiteralFlavor::FloatNumber { suffix } => {\n+                    LiteralKind::FloatNumber { suffix } => {\n                         let known_name = suffix\n                             .and_then(|it| FloatTy::from_suffix(&it).map(UncertainFloatTy::Known));\n \n@@ -745,13 +745,13 @@ impl ExprCollector {\n                             known_name.unwrap_or(UncertainFloatTy::Unknown),\n                         )\n                     }\n-                    LiteralFlavor::ByteString => Literal::ByteString(Default::default()),\n-                    LiteralFlavor::String => Literal::String(Default::default()),\n-                    LiteralFlavor::Byte => {\n+                    LiteralKind::ByteString => Literal::ByteString(Default::default()),\n+                    LiteralKind::String => Literal::String(Default::default()),\n+                    LiteralKind::Byte => {\n                         Literal::Int(Default::default(), UncertainIntTy::Known(IntTy::u8()))\n                     }\n-                    LiteralFlavor::Bool => Literal::Bool(Default::default()),\n-                    LiteralFlavor::Char => Literal::Char(Default::default()),\n+                    LiteralKind::Bool => Literal::Bool(Default::default()),\n+                    LiteralKind::Char => Literal::Char(Default::default()),\n                 };\n                 self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n             }"}, {"sha": "9f5c41b0cd22a0f8bba8cf4d842858c3a61393a1", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 18, "deletions": 549, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -1,22 +1,24 @@\n //! Abstract Syntax Tree, layered on top of untyped `SyntaxNode`s\n+\n mod generated;\n mod traits;\n mod tokens;\n+mod extensions;\n+mod expr_extensions;\n \n use std::marker::PhantomData;\n \n-use itertools::Itertools;\n-\n use crate::{\n-    syntax_node::{SyntaxNode, SyntaxNodeChildren, TreeArc, RaTypes, SyntaxToken, SyntaxElement},\n+    syntax_node::{SyntaxNode, SyntaxNodeChildren, TreeArc, RaTypes, SyntaxToken},\n     SmolStr,\n-    SyntaxKind::*,\n };\n \n pub use self::{\n     generated::*,\n     traits::*,\n     tokens::*,\n+    extensions::{PathSegmentKind, StructKind, SelfParamKind},\n+    expr_extensions::{ElseBranch, PrefixOp, BinOp, LiteralKind},\n };\n \n /// The main trait to go from untyped `SyntaxNode`  to a typed ast. The\n@@ -32,6 +34,18 @@ pub trait AstNode:\n     fn syntax(&self) -> &SyntaxNode;\n }\n \n+/// Like `AstNode`, but wraps tokens rather than interior nodes.\n+pub trait AstToken<'a> {\n+    fn cast(token: SyntaxToken<'a>) -> Option<Self>\n+    where\n+        Self: Sized;\n+    fn syntax(&self) -> SyntaxToken<'a>;\n+    fn text(&self) -> &'a SmolStr {\n+        self.syntax().text()\n+    }\n+}\n+\n+/// An iterator over `SyntaxNode` children of a particular AST type.\n #[derive(Debug)]\n pub struct AstChildren<'a, N> {\n     inner: SyntaxNodeChildren<'a>,\n@@ -51,215 +65,6 @@ impl<'a, N: AstNode + 'a> Iterator for AstChildren<'a, N> {\n     }\n }\n \n-pub trait AstToken<'a> {\n-    fn cast(token: SyntaxToken<'a>) -> Option<Self>\n-    where\n-        Self: Sized;\n-    fn syntax(&self) -> SyntaxToken<'a>;\n-    fn text(&self) -> &'a SmolStr {\n-        self.syntax().text()\n-    }\n-}\n-\n-impl Attr {\n-    pub fn is_inner(&self) -> bool {\n-        let tt = match self.value() {\n-            None => return false,\n-            Some(tt) => tt,\n-        };\n-\n-        let prev = match tt.syntax().prev_sibling() {\n-            None => return false,\n-            Some(prev) => prev,\n-        };\n-\n-        prev.kind() == EXCL\n-    }\n-\n-    pub fn as_atom(&self) -> Option<SmolStr> {\n-        let tt = self.value()?;\n-        let (_bra, attr, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n-        if attr.kind() == IDENT {\n-            Some(attr.as_token()?.text().clone())\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn as_call(&self) -> Option<(SmolStr, &TokenTree)> {\n-        let tt = self.value()?;\n-        let (_bra, attr, args, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n-        let args = TokenTree::cast(args.as_node()?)?;\n-        if attr.kind() == IDENT {\n-            Some((attr.as_token()?.text().clone(), args))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn as_named(&self) -> Option<SmolStr> {\n-        let tt = self.value()?;\n-        let attr = tt.syntax().children_with_tokens().nth(1)?;\n-        if attr.kind() == IDENT {\n-            Some(attr.as_token()?.text().clone())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl Name {\n-    pub fn text(&self) -> &SmolStr {\n-        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n-        ident.text()\n-    }\n-}\n-\n-impl NameRef {\n-    pub fn text(&self) -> &SmolStr {\n-        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n-        ident.text()\n-    }\n-}\n-\n-impl ImplBlock {\n-    pub fn target_type(&self) -> Option<&TypeRef> {\n-        match self.target() {\n-            (Some(t), None) | (_, Some(t)) => Some(t),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n-        match self.target() {\n-            (Some(t), Some(_)) => Some(t),\n-            _ => None,\n-        }\n-    }\n-\n-    fn target(&self) -> (Option<&TypeRef>, Option<&TypeRef>) {\n-        let mut types = children(self);\n-        let first = types.next();\n-        let second = types.next();\n-        (first, second)\n-    }\n-}\n-\n-impl Module {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == SEMI,\n-        }\n-    }\n-}\n-\n-impl LetStmt {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == SEMI,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum ElseBranchFlavor<'a> {\n-    Block(&'a Block),\n-    IfExpr(&'a IfExpr),\n-}\n-\n-impl IfExpr {\n-    pub fn then_branch(&self) -> Option<&Block> {\n-        self.blocks().nth(0)\n-    }\n-    pub fn else_branch(&self) -> Option<ElseBranchFlavor> {\n-        let res = match self.blocks().nth(1) {\n-            Some(block) => ElseBranchFlavor::Block(block),\n-            None => {\n-                let elif: &IfExpr = child_opt(self)?;\n-                ElseBranchFlavor::IfExpr(elif)\n-            }\n-        };\n-        Some(res)\n-    }\n-\n-    fn blocks(&self) -> AstChildren<Block> {\n-        children(self)\n-    }\n-}\n-\n-impl ExprStmt {\n-    pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == SEMI,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum PathSegmentKind<'a> {\n-    Name(&'a NameRef),\n-    SelfKw,\n-    SuperKw,\n-    CrateKw,\n-}\n-\n-impl PathSegment {\n-    pub fn parent_path(&self) -> &Path {\n-        self.syntax().parent().and_then(Path::cast).expect(\"segments are always nested in paths\")\n-    }\n-\n-    pub fn kind(&self) -> Option<PathSegmentKind> {\n-        let res = if let Some(name_ref) = self.name_ref() {\n-            PathSegmentKind::Name(name_ref)\n-        } else {\n-            match self.syntax().first_child_or_token()?.kind() {\n-                SELF_KW => PathSegmentKind::SelfKw,\n-                SUPER_KW => PathSegmentKind::SuperKw,\n-                CRATE_KW => PathSegmentKind::CrateKw,\n-                _ => return None,\n-            }\n-        };\n-        Some(res)\n-    }\n-\n-    pub fn has_colon_colon(&self) -> bool {\n-        match self.syntax.first_child_or_token().map(|s| s.kind()) {\n-            Some(COLONCOLON) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl Path {\n-    pub fn parent_path(&self) -> Option<&Path> {\n-        self.syntax().parent().and_then(Path::cast)\n-    }\n-}\n-\n-impl UseTree {\n-    pub fn has_star(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == STAR)\n-    }\n-}\n-\n-impl UseTreeList {\n-    pub fn parent_use_tree(&self) -> &UseTree {\n-        self.syntax()\n-            .parent()\n-            .and_then(UseTree::cast)\n-            .expect(\"UseTreeLists are always nested in UseTrees\")\n-    }\n-}\n-\n-impl RefPat {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-}\n-\n fn child_opt<P: AstNode, C: AstNode>(parent: &P) -> Option<&C> {\n     children(parent).next()\n }\n@@ -268,342 +73,6 @@ fn children<P: AstNode, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum StructFlavor<'a> {\n-    Tuple(&'a PosFieldDefList),\n-    Named(&'a NamedFieldDefList),\n-    Unit,\n-}\n-\n-impl StructFlavor<'_> {\n-    fn from_node<N: AstNode>(node: &N) -> StructFlavor {\n-        if let Some(nfdl) = child_opt::<_, NamedFieldDefList>(node) {\n-            StructFlavor::Named(nfdl)\n-        } else if let Some(pfl) = child_opt::<_, PosFieldDefList>(node) {\n-            StructFlavor::Tuple(pfl)\n-        } else {\n-            StructFlavor::Unit\n-        }\n-    }\n-}\n-\n-impl StructDef {\n-    pub fn flavor(&self) -> StructFlavor {\n-        StructFlavor::from_node(self)\n-    }\n-}\n-\n-impl EnumVariant {\n-    pub fn parent_enum(&self) -> &EnumDef {\n-        self.syntax()\n-            .parent()\n-            .and_then(|it| it.parent())\n-            .and_then(EnumDef::cast)\n-            .expect(\"EnumVariants are always nested in Enums\")\n-    }\n-    pub fn flavor(&self) -> StructFlavor {\n-        StructFlavor::from_node(self)\n-    }\n-}\n-\n-impl PointerType {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-}\n-\n-impl ReferenceType {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-}\n-\n-impl RefExpr {\n-    pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum PrefixOp {\n-    /// The `*` operator for dereferencing\n-    Deref,\n-    /// The `!` operator for logical inversion\n-    Not,\n-    /// The `-` operator for negation\n-    Neg,\n-}\n-\n-impl PrefixExpr {\n-    pub fn op_kind(&self) -> Option<PrefixOp> {\n-        match self.op_token()?.kind() {\n-            STAR => Some(PrefixOp::Deref),\n-            EXCL => Some(PrefixOp::Not),\n-            MINUS => Some(PrefixOp::Neg),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn op_token(&self) -> Option<SyntaxToken> {\n-        self.syntax().first_child_or_token()?.as_token()\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum BinOp {\n-    /// The `||` operator for boolean OR\n-    BooleanOr,\n-    /// The `&&` operator for boolean AND\n-    BooleanAnd,\n-    /// The `==` operator for equality testing\n-    EqualityTest,\n-    /// The `!=` operator for equality testing\n-    NegatedEqualityTest,\n-    /// The `<=` operator for lesser-equal testing\n-    LesserEqualTest,\n-    /// The `>=` operator for greater-equal testing\n-    GreaterEqualTest,\n-    /// The `<` operator for comparison\n-    LesserTest,\n-    /// The `>` operator for comparison\n-    GreaterTest,\n-    /// The `+` operator for addition\n-    Addition,\n-    /// The `*` operator for multiplication\n-    Multiplication,\n-    /// The `-` operator for subtraction\n-    Subtraction,\n-    /// The `/` operator for division\n-    Division,\n-    /// The `%` operator for remainder after division\n-    Remainder,\n-    /// The `<<` operator for left shift\n-    LeftShift,\n-    /// The `>>` operator for right shift\n-    RightShift,\n-    /// The `^` operator for bitwise XOR\n-    BitwiseXor,\n-    /// The `|` operator for bitwise OR\n-    BitwiseOr,\n-    /// The `&` operator for bitwise AND\n-    BitwiseAnd,\n-    /// The `..` operator for right-open ranges\n-    RangeRightOpen,\n-    /// The `..=` operator for right-closed ranges\n-    RangeRightClosed,\n-    /// The `=` operator for assignment\n-    Assignment,\n-    /// The `+=` operator for assignment after addition\n-    AddAssign,\n-    /// The `/=` operator for assignment after division\n-    DivAssign,\n-    /// The `*=` operator for assignment after multiplication\n-    MulAssign,\n-    /// The `%=` operator for assignment after remainders\n-    RemAssign,\n-    /// The `>>=` operator for assignment after shifting right\n-    ShrAssign,\n-    /// The `<<=` operator for assignment after shifting left\n-    ShlAssign,\n-    /// The `-=` operator for assignment after subtraction\n-    SubAssign,\n-    /// The `|=` operator for assignment after bitwise OR\n-    BitOrAssign,\n-    /// The `&=` operator for assignment after bitwise AND\n-    BitAndAssign,\n-    /// The `^=` operator for assignment after bitwise XOR\n-    BitXorAssign,\n-}\n-\n-impl BinExpr {\n-    fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n-        self.syntax().children_with_tokens().filter_map(|it| it.as_token()).find_map(|c| {\n-            match c.kind() {\n-                PIPEPIPE => Some((c, BinOp::BooleanOr)),\n-                AMPAMP => Some((c, BinOp::BooleanAnd)),\n-                EQEQ => Some((c, BinOp::EqualityTest)),\n-                NEQ => Some((c, BinOp::NegatedEqualityTest)),\n-                LTEQ => Some((c, BinOp::LesserEqualTest)),\n-                GTEQ => Some((c, BinOp::GreaterEqualTest)),\n-                L_ANGLE => Some((c, BinOp::LesserTest)),\n-                R_ANGLE => Some((c, BinOp::GreaterTest)),\n-                PLUS => Some((c, BinOp::Addition)),\n-                STAR => Some((c, BinOp::Multiplication)),\n-                MINUS => Some((c, BinOp::Subtraction)),\n-                SLASH => Some((c, BinOp::Division)),\n-                PERCENT => Some((c, BinOp::Remainder)),\n-                SHL => Some((c, BinOp::LeftShift)),\n-                SHR => Some((c, BinOp::RightShift)),\n-                CARET => Some((c, BinOp::BitwiseXor)),\n-                PIPE => Some((c, BinOp::BitwiseOr)),\n-                AMP => Some((c, BinOp::BitwiseAnd)),\n-                DOTDOT => Some((c, BinOp::RangeRightOpen)),\n-                DOTDOTEQ => Some((c, BinOp::RangeRightClosed)),\n-                EQ => Some((c, BinOp::Assignment)),\n-                PLUSEQ => Some((c, BinOp::AddAssign)),\n-                SLASHEQ => Some((c, BinOp::DivAssign)),\n-                STAREQ => Some((c, BinOp::MulAssign)),\n-                PERCENTEQ => Some((c, BinOp::RemAssign)),\n-                SHREQ => Some((c, BinOp::ShrAssign)),\n-                SHLEQ => Some((c, BinOp::ShlAssign)),\n-                MINUSEQ => Some((c, BinOp::SubAssign)),\n-                PIPEEQ => Some((c, BinOp::BitOrAssign)),\n-                AMPEQ => Some((c, BinOp::BitAndAssign)),\n-                CARETEQ => Some((c, BinOp::BitXorAssign)),\n-                _ => None,\n-            }\n-        })\n-    }\n-\n-    pub fn op_kind(&self) -> Option<BinOp> {\n-        self.op_details().map(|t| t.1)\n-    }\n-\n-    pub fn op_token(&self) -> Option<SyntaxToken> {\n-        self.op_details().map(|t| t.0)\n-    }\n-\n-    pub fn lhs(&self) -> Option<&Expr> {\n-        children(self).nth(0)\n-    }\n-\n-    pub fn rhs(&self) -> Option<&Expr> {\n-        children(self).nth(1)\n-    }\n-\n-    pub fn sub_exprs(&self) -> (Option<&Expr>, Option<&Expr>) {\n-        let mut children = children(self);\n-        let first = children.next();\n-        let second = children.next();\n-        (first, second)\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum SelfParamFlavor {\n-    /// self\n-    Owned,\n-    /// &self\n-    Ref,\n-    /// &mut self\n-    MutRef,\n-}\n-\n-impl SelfParam {\n-    pub fn self_kw_token(&self) -> SyntaxToken {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n-            .find(|it| it.kind() == SELF_KW)\n-            .expect(\"invalid tree: self param must have self\")\n-    }\n-\n-    pub fn flavor(&self) -> SelfParamFlavor {\n-        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == AMP);\n-        if borrowed {\n-            // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n-            if self\n-                .syntax()\n-                .children_with_tokens()\n-                .skip_while(|n| n.kind() != AMP)\n-                .any(|n| n.kind() == MUT_KW)\n-            {\n-                SelfParamFlavor::MutRef\n-            } else {\n-                SelfParamFlavor::Ref\n-            }\n-        } else {\n-            SelfParamFlavor::Owned\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum LiteralFlavor {\n-    String,\n-    ByteString,\n-    Char,\n-    Byte,\n-    IntNumber { suffix: Option<SmolStr> },\n-    FloatNumber { suffix: Option<SmolStr> },\n-    Bool,\n-}\n-\n-impl Literal {\n-    pub fn token(&self) -> SyntaxToken {\n-        match self.syntax().first_child_or_token().unwrap() {\n-            SyntaxElement::Token(token) => token,\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    pub fn flavor(&self) -> LiteralFlavor {\n-        match self.token().kind() {\n-            INT_NUMBER => {\n-                let allowed_suffix_list = [\n-                    \"isize\", \"i128\", \"i64\", \"i32\", \"i16\", \"i8\", \"usize\", \"u128\", \"u64\", \"u32\",\n-                    \"u16\", \"u8\",\n-                ];\n-                let text = self.token().text().to_string();\n-                let suffix = allowed_suffix_list\n-                    .iter()\n-                    .find(|&s| text.ends_with(s))\n-                    .map(|&suf| SmolStr::new(suf));\n-                LiteralFlavor::IntNumber { suffix }\n-            }\n-            FLOAT_NUMBER => {\n-                let allowed_suffix_list = [\"f64\", \"f32\"];\n-                let text = self.token().text().to_string();\n-                let suffix = allowed_suffix_list\n-                    .iter()\n-                    .find(|&s| text.ends_with(s))\n-                    .map(|&suf| SmolStr::new(suf));\n-                LiteralFlavor::FloatNumber { suffix: suffix }\n-            }\n-            STRING | RAW_STRING => LiteralFlavor::String,\n-            TRUE_KW | FALSE_KW => LiteralFlavor::Bool,\n-            BYTE_STRING | RAW_BYTE_STRING => LiteralFlavor::ByteString,\n-            CHAR => LiteralFlavor::Char,\n-            BYTE => LiteralFlavor::Byte,\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-impl NamedField {\n-    pub fn parent_struct_lit(&self) -> &StructLit {\n-        self.syntax().ancestors().find_map(StructLit::cast).unwrap()\n-    }\n-}\n-\n-impl BindPat {\n-    pub fn is_mutable(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n-    }\n-\n-    pub fn is_ref(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == REF_KW)\n-    }\n-}\n-\n-impl LifetimeParam {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n-            .find(|it| it.kind() == LIFETIME)\n-    }\n-}\n-\n-impl WherePred {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n-            .find(|it| it.kind() == LIFETIME)\n-    }\n-}\n-\n #[test]\n fn test_doc_comment_none() {\n     let file = SourceFile::parse("}, {"sha": "1d83138102f8d404481f30ea2a5306387b8a69b3", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -0,0 +1,252 @@\n+//! Various extension methods to ast Expr Nodes, which are hard to code-generate.\n+\n+use crate::{\n+    SyntaxToken, SyntaxElement, SmolStr,\n+    ast::{self, AstNode, AstChildren, children, child_opt},\n+    SyntaxKind::*\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ElseBranch<'a> {\n+    Block(&'a ast::Block),\n+    IfExpr(&'a ast::IfExpr),\n+}\n+\n+impl ast::IfExpr {\n+    pub fn then_branch(&self) -> Option<&ast::Block> {\n+        self.blocks().nth(0)\n+    }\n+    pub fn else_branch(&self) -> Option<ElseBranch> {\n+        let res = match self.blocks().nth(1) {\n+            Some(block) => ElseBranch::Block(block),\n+            None => {\n+                let elif: &ast::IfExpr = child_opt(self)?;\n+                ElseBranch::IfExpr(elif)\n+            }\n+        };\n+        Some(res)\n+    }\n+\n+    fn blocks(&self) -> AstChildren<ast::Block> {\n+        children(self)\n+    }\n+}\n+\n+impl ast::RefExpr {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum PrefixOp {\n+    /// The `*` operator for dereferencing\n+    Deref,\n+    /// The `!` operator for logical inversion\n+    Not,\n+    /// The `-` operator for negation\n+    Neg,\n+}\n+\n+impl ast::PrefixExpr {\n+    pub fn op_kind(&self) -> Option<PrefixOp> {\n+        match self.op_token()?.kind() {\n+            STAR => Some(PrefixOp::Deref),\n+            EXCL => Some(PrefixOp::Not),\n+            MINUS => Some(PrefixOp::Neg),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn op_token(&self) -> Option<SyntaxToken> {\n+        self.syntax().first_child_or_token()?.as_token()\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum BinOp {\n+    /// The `||` operator for boolean OR\n+    BooleanOr,\n+    /// The `&&` operator for boolean AND\n+    BooleanAnd,\n+    /// The `==` operator for equality testing\n+    EqualityTest,\n+    /// The `!=` operator for equality testing\n+    NegatedEqualityTest,\n+    /// The `<=` operator for lesser-equal testing\n+    LesserEqualTest,\n+    /// The `>=` operator for greater-equal testing\n+    GreaterEqualTest,\n+    /// The `<` operator for comparison\n+    LesserTest,\n+    /// The `>` operator for comparison\n+    GreaterTest,\n+    /// The `+` operator for addition\n+    Addition,\n+    /// The `*` operator for multiplication\n+    Multiplication,\n+    /// The `-` operator for subtraction\n+    Subtraction,\n+    /// The `/` operator for division\n+    Division,\n+    /// The `%` operator for remainder after division\n+    Remainder,\n+    /// The `<<` operator for left shift\n+    LeftShift,\n+    /// The `>>` operator for right shift\n+    RightShift,\n+    /// The `^` operator for bitwise XOR\n+    BitwiseXor,\n+    /// The `|` operator for bitwise OR\n+    BitwiseOr,\n+    /// The `&` operator for bitwise AND\n+    BitwiseAnd,\n+    /// The `..` operator for right-open ranges\n+    RangeRightOpen,\n+    /// The `..=` operator for right-closed ranges\n+    RangeRightClosed,\n+    /// The `=` operator for assignment\n+    Assignment,\n+    /// The `+=` operator for assignment after addition\n+    AddAssign,\n+    /// The `/=` operator for assignment after division\n+    DivAssign,\n+    /// The `*=` operator for assignment after multiplication\n+    MulAssign,\n+    /// The `%=` operator for assignment after remainders\n+    RemAssign,\n+    /// The `>>=` operator for assignment after shifting right\n+    ShrAssign,\n+    /// The `<<=` operator for assignment after shifting left\n+    ShlAssign,\n+    /// The `-=` operator for assignment after subtraction\n+    SubAssign,\n+    /// The `|=` operator for assignment after bitwise OR\n+    BitOrAssign,\n+    /// The `&=` operator for assignment after bitwise AND\n+    BitAndAssign,\n+    /// The `^=` operator for assignment after bitwise XOR\n+    BitXorAssign,\n+}\n+\n+impl ast::BinExpr {\n+    fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n+        self.syntax().children_with_tokens().filter_map(|it| it.as_token()).find_map(|c| {\n+            match c.kind() {\n+                PIPEPIPE => Some((c, BinOp::BooleanOr)),\n+                AMPAMP => Some((c, BinOp::BooleanAnd)),\n+                EQEQ => Some((c, BinOp::EqualityTest)),\n+                NEQ => Some((c, BinOp::NegatedEqualityTest)),\n+                LTEQ => Some((c, BinOp::LesserEqualTest)),\n+                GTEQ => Some((c, BinOp::GreaterEqualTest)),\n+                L_ANGLE => Some((c, BinOp::LesserTest)),\n+                R_ANGLE => Some((c, BinOp::GreaterTest)),\n+                PLUS => Some((c, BinOp::Addition)),\n+                STAR => Some((c, BinOp::Multiplication)),\n+                MINUS => Some((c, BinOp::Subtraction)),\n+                SLASH => Some((c, BinOp::Division)),\n+                PERCENT => Some((c, BinOp::Remainder)),\n+                SHL => Some((c, BinOp::LeftShift)),\n+                SHR => Some((c, BinOp::RightShift)),\n+                CARET => Some((c, BinOp::BitwiseXor)),\n+                PIPE => Some((c, BinOp::BitwiseOr)),\n+                AMP => Some((c, BinOp::BitwiseAnd)),\n+                DOTDOT => Some((c, BinOp::RangeRightOpen)),\n+                DOTDOTEQ => Some((c, BinOp::RangeRightClosed)),\n+                EQ => Some((c, BinOp::Assignment)),\n+                PLUSEQ => Some((c, BinOp::AddAssign)),\n+                SLASHEQ => Some((c, BinOp::DivAssign)),\n+                STAREQ => Some((c, BinOp::MulAssign)),\n+                PERCENTEQ => Some((c, BinOp::RemAssign)),\n+                SHREQ => Some((c, BinOp::ShrAssign)),\n+                SHLEQ => Some((c, BinOp::ShlAssign)),\n+                MINUSEQ => Some((c, BinOp::SubAssign)),\n+                PIPEEQ => Some((c, BinOp::BitOrAssign)),\n+                AMPEQ => Some((c, BinOp::BitAndAssign)),\n+                CARETEQ => Some((c, BinOp::BitXorAssign)),\n+                _ => None,\n+            }\n+        })\n+    }\n+\n+    pub fn op_kind(&self) -> Option<BinOp> {\n+        self.op_details().map(|t| t.1)\n+    }\n+\n+    pub fn op_token(&self) -> Option<SyntaxToken> {\n+        self.op_details().map(|t| t.0)\n+    }\n+\n+    pub fn lhs(&self) -> Option<&ast::Expr> {\n+        children(self).nth(0)\n+    }\n+\n+    pub fn rhs(&self) -> Option<&ast::Expr> {\n+        children(self).nth(1)\n+    }\n+\n+    pub fn sub_exprs(&self) -> (Option<&ast::Expr>, Option<&ast::Expr>) {\n+        let mut children = children(self);\n+        let first = children.next();\n+        let second = children.next();\n+        (first, second)\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum LiteralKind {\n+    String,\n+    ByteString,\n+    Char,\n+    Byte,\n+    IntNumber { suffix: Option<SmolStr> },\n+    FloatNumber { suffix: Option<SmolStr> },\n+    Bool,\n+}\n+\n+impl ast::Literal {\n+    pub fn token(&self) -> SyntaxToken {\n+        match self.syntax().first_child_or_token().unwrap() {\n+            SyntaxElement::Token(token) => token,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    pub fn kind(&self) -> LiteralKind {\n+        match self.token().kind() {\n+            INT_NUMBER => {\n+                let allowed_suffix_list = [\n+                    \"isize\", \"i128\", \"i64\", \"i32\", \"i16\", \"i8\", \"usize\", \"u128\", \"u64\", \"u32\",\n+                    \"u16\", \"u8\",\n+                ];\n+                let text = self.token().text().to_string();\n+                let suffix = allowed_suffix_list\n+                    .iter()\n+                    .find(|&s| text.ends_with(s))\n+                    .map(|&suf| SmolStr::new(suf));\n+                LiteralKind::IntNumber { suffix }\n+            }\n+            FLOAT_NUMBER => {\n+                let allowed_suffix_list = [\"f64\", \"f32\"];\n+                let text = self.token().text().to_string();\n+                let suffix = allowed_suffix_list\n+                    .iter()\n+                    .find(|&s| text.ends_with(s))\n+                    .map(|&suf| SmolStr::new(suf));\n+                LiteralKind::FloatNumber { suffix: suffix }\n+            }\n+            STRING | RAW_STRING => LiteralKind::String,\n+            TRUE_KW | FALSE_KW => LiteralKind::Bool,\n+            BYTE_STRING | RAW_BYTE_STRING => LiteralKind::ByteString,\n+            CHAR => LiteralKind::Char,\n+            BYTE => LiteralKind::Byte,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl ast::NamedField {\n+    pub fn parent_struct_lit(&self) -> &ast::StructLit {\n+        self.syntax().ancestors().find_map(ast::StructLit::cast).unwrap()\n+    }\n+}"}, {"sha": "aec57c3807af0285eae419787341dcbbd200f1e3", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -0,0 +1,303 @@\n+//! Various extension methods to ast Nodes, which are hard to code-generate.\n+//! Extensions for various expressions live in a sibling `expr_extensions` module.\n+\n+use itertools::Itertools;\n+\n+use crate::{\n+    SmolStr, SyntaxToken,\n+    ast::{self, AstNode, children, child_opt},\n+    SyntaxKind::*,\n+};\n+\n+impl ast::Name {\n+    pub fn text(&self) -> &SmolStr {\n+        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n+        ident.text()\n+    }\n+}\n+\n+impl ast::NameRef {\n+    pub fn text(&self) -> &SmolStr {\n+        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n+        ident.text()\n+    }\n+}\n+\n+impl ast::Attr {\n+    pub fn is_inner(&self) -> bool {\n+        let tt = match self.value() {\n+            None => return false,\n+            Some(tt) => tt,\n+        };\n+\n+        let prev = match tt.syntax().prev_sibling() {\n+            None => return false,\n+            Some(prev) => prev,\n+        };\n+\n+        prev.kind() == EXCL\n+    }\n+\n+    pub fn as_atom(&self) -> Option<SmolStr> {\n+        let tt = self.value()?;\n+        let (_bra, attr, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n+        if attr.kind() == IDENT {\n+            Some(attr.as_token()?.text().clone())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn as_call(&self) -> Option<(SmolStr, &ast::TokenTree)> {\n+        let tt = self.value()?;\n+        let (_bra, attr, args, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n+        let args = ast::TokenTree::cast(args.as_node()?)?;\n+        if attr.kind() == IDENT {\n+            Some((attr.as_token()?.text().clone(), args))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn as_named(&self) -> Option<SmolStr> {\n+        let tt = self.value()?;\n+        let attr = tt.syntax().children_with_tokens().nth(1)?;\n+        if attr.kind() == IDENT {\n+            Some(attr.as_token()?.text().clone())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum PathSegmentKind<'a> {\n+    Name(&'a ast::NameRef),\n+    SelfKw,\n+    SuperKw,\n+    CrateKw,\n+}\n+\n+impl ast::PathSegment {\n+    pub fn parent_path(&self) -> &ast::Path {\n+        self.syntax()\n+            .parent()\n+            .and_then(ast::Path::cast)\n+            .expect(\"segments are always nested in paths\")\n+    }\n+\n+    pub fn kind(&self) -> Option<PathSegmentKind> {\n+        let res = if let Some(name_ref) = self.name_ref() {\n+            PathSegmentKind::Name(name_ref)\n+        } else {\n+            match self.syntax().first_child_or_token()?.kind() {\n+                SELF_KW => PathSegmentKind::SelfKw,\n+                SUPER_KW => PathSegmentKind::SuperKw,\n+                CRATE_KW => PathSegmentKind::CrateKw,\n+                _ => return None,\n+            }\n+        };\n+        Some(res)\n+    }\n+\n+    pub fn has_colon_colon(&self) -> bool {\n+        match self.syntax.first_child_or_token().map(|s| s.kind()) {\n+            Some(COLONCOLON) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl ast::Path {\n+    pub fn parent_path(&self) -> Option<&ast::Path> {\n+        self.syntax().parent().and_then(ast::Path::cast)\n+    }\n+}\n+\n+impl ast::Module {\n+    pub fn has_semi(&self) -> bool {\n+        match self.syntax().last_child_or_token() {\n+            None => false,\n+            Some(node) => node.kind() == SEMI,\n+        }\n+    }\n+}\n+\n+impl ast::UseTree {\n+    pub fn has_star(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == STAR)\n+    }\n+}\n+\n+impl ast::UseTreeList {\n+    pub fn parent_use_tree(&self) -> &ast::UseTree {\n+        self.syntax()\n+            .parent()\n+            .and_then(ast::UseTree::cast)\n+            .expect(\"UseTreeLists are always nested in UseTrees\")\n+    }\n+}\n+\n+impl ast::ImplBlock {\n+    pub fn target_type(&self) -> Option<&ast::TypeRef> {\n+        match self.target() {\n+            (Some(t), None) | (_, Some(t)) => Some(t),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn target_trait(&self) -> Option<&ast::TypeRef> {\n+        match self.target() {\n+            (Some(t), Some(_)) => Some(t),\n+            _ => None,\n+        }\n+    }\n+\n+    fn target(&self) -> (Option<&ast::TypeRef>, Option<&ast::TypeRef>) {\n+        let mut types = children(self);\n+        let first = types.next();\n+        let second = types.next();\n+        (first, second)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum StructKind<'a> {\n+    Tuple(&'a ast::PosFieldDefList),\n+    Named(&'a ast::NamedFieldDefList),\n+    Unit,\n+}\n+\n+impl StructKind<'_> {\n+    fn from_node<N: AstNode>(node: &N) -> StructKind {\n+        if let Some(nfdl) = child_opt::<_, ast::NamedFieldDefList>(node) {\n+            StructKind::Named(nfdl)\n+        } else if let Some(pfl) = child_opt::<_, ast::PosFieldDefList>(node) {\n+            StructKind::Tuple(pfl)\n+        } else {\n+            StructKind::Unit\n+        }\n+    }\n+}\n+\n+impl ast::StructDef {\n+    pub fn kind(&self) -> StructKind {\n+        StructKind::from_node(self)\n+    }\n+}\n+\n+impl ast::EnumVariant {\n+    pub fn parent_enum(&self) -> &ast::EnumDef {\n+        self.syntax()\n+            .parent()\n+            .and_then(|it| it.parent())\n+            .and_then(ast::EnumDef::cast)\n+            .expect(\"EnumVariants are always nested in Enums\")\n+    }\n+    pub fn kind(&self) -> StructKind {\n+        StructKind::from_node(self)\n+    }\n+}\n+\n+impl ast::LetStmt {\n+    pub fn has_semi(&self) -> bool {\n+        match self.syntax().last_child_or_token() {\n+            None => false,\n+            Some(node) => node.kind() == SEMI,\n+        }\n+    }\n+}\n+\n+impl ast::ExprStmt {\n+    pub fn has_semi(&self) -> bool {\n+        match self.syntax().last_child_or_token() {\n+            None => false,\n+            Some(node) => node.kind() == SEMI,\n+        }\n+    }\n+}\n+\n+impl ast::RefPat {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+impl ast::BindPat {\n+    pub fn is_mutable(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+\n+    pub fn is_ref(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == REF_KW)\n+    }\n+}\n+\n+impl ast::PointerType {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+impl ast::ReferenceType {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum SelfParamKind {\n+    /// self\n+    Owned,\n+    /// &self\n+    Ref,\n+    /// &mut self\n+    MutRef,\n+}\n+\n+impl ast::SelfParam {\n+    pub fn self_kw_token(&self) -> SyntaxToken {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == SELF_KW)\n+            .expect(\"invalid tree: self param must have self\")\n+    }\n+\n+    pub fn kind(&self) -> SelfParamKind {\n+        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == AMP);\n+        if borrowed {\n+            // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n+            if self\n+                .syntax()\n+                .children_with_tokens()\n+                .skip_while(|n| n.kind() != AMP)\n+                .any(|n| n.kind() == MUT_KW)\n+            {\n+                SelfParamKind::MutRef\n+            } else {\n+                SelfParamKind::Ref\n+            }\n+        } else {\n+            SelfParamKind::Owned\n+        }\n+    }\n+}\n+\n+impl ast::LifetimeParam {\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == LIFETIME)\n+    }\n+}\n+\n+impl ast::WherePred {\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == LIFETIME)\n+    }\n+}"}, {"sha": "da7d507bfda748ef1123f23064049b04968fb513", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -1,3 +1,5 @@\n+//! There are many AstNodes, but only a few tokens, so we hand-write them here.\n+\n use crate::{\n     SyntaxToken,\n     SyntaxKind::{COMMENT, WHITESPACE},"}, {"sha": "aaf07d731ff91b36ee4d6c917af229db4ee9bec5", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d244719323d68905986857844f56d1fa38cac4/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=b0d244719323d68905986857844f56d1fa38cac4", "patch": "@@ -1,3 +1,7 @@\n+//! Various traits that are implemented by ast nodes.\n+//!\n+//! The implementations are usually trivial, and live in generated.rs\n+\n use itertools::Itertools;\n \n use crate::{"}]}