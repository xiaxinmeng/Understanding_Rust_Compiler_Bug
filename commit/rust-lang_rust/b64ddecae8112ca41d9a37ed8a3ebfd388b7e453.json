{"sha": "b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NGRkZWNhZTgxMTJjYTQxZDlhMzdlZDhhM2ViZmQzODhiN2U0NTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-07T18:48:12Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-10T15:46:31Z"}, "message": "use `places_conflict` to handle reassignment\n\nThis fixes the handling of reassignment of struct fields.", "tree": {"sha": "f5bac209b527bc063497be670f52d74cfb9a3aee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5bac209b527bc063497be670f52d74cfb9a3aee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "html_url": "https://github.com/rust-lang/rust/commit/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97c58ed66ca20e849db0dc3942fb9735819909fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/97c58ed66ca20e849db0dc3942fb9735819909fd", "html_url": "https://github.com/rust-lang/rust/commit/97c58ed66ca20e849db0dc3942fb9735819909fd"}], "stats": {"total": 108, "additions": 56, "deletions": 52}, "files": [{"sha": "2ac0ce864d9db70573daf3c2bc76dc4220dea7ab", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "patch": "@@ -605,8 +605,10 @@ enum WriteKind {\n /// - Take flow state into consideration in `is_assignable()` for local variables\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LocalMutationIsAllowed {\n-    Move,\n     Yes,\n+    /// We want use of immutable upvars to cause a \"write to immutable upvar\"\n+    /// error, not an \"reassignment\" error.\n+    ExceptUpvars,\n     No\n }\n \n@@ -802,7 +804,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context,\n             place_span,\n             (kind, Write(WriteKind::Mutate)),\n-            LocalMutationIsAllowed::Yes,\n+            // We want immutable upvars to cause an \"assignment to immutable var\"\n+            // error, not an \"reassignment of immutable var\" error, because the\n+            // latter can't find a good previous assignment span.\n+            //\n+            // There's probably a better way to do this.\n+            LocalMutationIsAllowed::ExceptUpvars,\n             flow_state,\n         );\n \n@@ -922,7 +929,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     context,\n                     (place, span),\n                     (Deep, Write(WriteKind::Move)),\n-                    LocalMutationIsAllowed::Move,\n+                    LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n \n@@ -1009,34 +1016,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n-        let move_data = self.move_data;\n-\n+        debug!(\"check_if_reassignment_to_immutable_state({:?})\", place);\n         // determine if this path has a non-mut owner (and thus needs checking).\n         if let Ok(()) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n             return;\n         }\n-\n-        match self.move_path_closest_to(place) {\n-            Ok(mpi) => for ii in &move_data.init_path_map[mpi] {\n-                if flow_state.ever_inits.contains(ii) {\n-                    let first_assign_span = self.move_data.inits[*ii].span;\n-                    self.report_illegal_reassignment(context, (place, span), first_assign_span);\n-                    break;\n-                }\n-            },\n-            Err(NoMovePathFound::ReachedStatic) => {\n-                let item_msg = match self.describe_place(place) {\n-                    Some(name) => format!(\"immutable static item `{}`\", name),\n-                    None => \"immutable static item\".to_owned(),\n-                };\n-                self.tcx.sess.delay_span_bug(\n-                    span,\n-                    &format!(\n-                        \"cannot assign to {}, should have been caught by \\\n-                         `check_access_permissions()`\",\n-                        item_msg\n-                    ),\n-                );\n+        debug!(\"check_if_reassignment_to_immutable_state({:?}) - is an imm local\", place);\n+\n+        for i in flow_state.ever_inits.elems_incoming() {\n+            let init = self.move_data.inits[i];\n+            let init_place = &self.move_data.move_paths[init.path].place;\n+            if self.places_conflict(&init_place, place, Deep) {\n+                self.report_illegal_reassignment(context, (place, span), init.span);\n+                break;\n             }\n         }\n     }\n@@ -1341,7 +1333,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes |\n-                        LocalMutationIsAllowed::Move => Ok(()),\n+                        LocalMutationIsAllowed::ExceptUpvars => Ok(()),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(()),\n@@ -1410,8 +1402,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                    decl, is_local_mutation_allowed, place);\n                             return match (decl.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No) |\n-                                (Mutability::Not, LocalMutationIsAllowed::Yes) => Err(place),\n-                                (Mutability::Not, LocalMutationIsAllowed::Move) |\n+                                (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars)\n+                                    => Err(place),\n+                                (Mutability::Not, LocalMutationIsAllowed::Yes) |\n                                 (Mutability::Mut, _) => self.is_unique(&proj.base),\n                             };\n                         }\n@@ -1666,13 +1659,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n-    fn borrow_conflicts_with_place(&mut self,\n-                                    borrow: &BorrowData<'tcx>,\n-                                    place: &Place<'tcx>,\n-                                    access: ShallowOrDeep)\n-                                    -> bool\n+\n+    /// Returns whether an access of kind `access` to `access_place` conflicts with\n+    /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n+    /// locations, this function is symmetric between `borrow_place` & `access_place`).\n+    fn places_conflict(&mut self,\n+                       borrow_place: &Place<'tcx>,\n+                       access_place: &Place<'tcx>,\n+                       access: ShallowOrDeep)\n+                       -> bool\n     {\n-        debug!(\"borrow_conflicts_with_place({:?},{:?},{:?})\", borrow, place, access);\n+        debug!(\"places_conflict({:?},{:?},{:?})\", borrow_place, access_place, access);\n \n         // Return all the prefixes of `place` in reverse order, including\n         // downcasts.\n@@ -1694,9 +1691,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        let borrow_components = place_elements(&borrow.place);\n-        let access_components = place_elements(place);\n-        debug!(\"borrow_conflicts_with_place: components {:?} / {:?}\",\n+        let borrow_components = place_elements(borrow_place);\n+        let access_components = place_elements(access_place);\n+        debug!(\"places_conflict: components {:?} / {:?}\",\n                borrow_components, access_components);\n \n         let borrow_components = borrow_components.into_iter()\n@@ -1746,7 +1743,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //  - If we did run out of accesss, the borrow can access a part of it.\n         for (borrow_c, access_c) in borrow_components.zip(access_components) {\n             // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-            debug!(\"borrow_conflicts_with_place: {:?} vs. {:?}\", borrow_c, access_c);\n+            debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n             match (borrow_c, access_c) {\n                 (None, _) => {\n                     // If we didn't run out of access, the borrow can access all of our\n@@ -1759,7 +1756,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     //\n                     // FIXME: Differs from AST-borrowck; includes drive-by fix\n                     // to #38899. Will probably need back-compat mode flag.\n-                    debug!(\"borrow_conflict_with_place: full borrow, CONFLICT\");\n+                    debug!(\"places_conflict: full borrow, CONFLICT\");\n                     return true;\n                 }\n                 (Some(borrow_c), None) => {\n@@ -1784,15 +1781,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             //\n                             // e.g. a (mutable) borrow of `a[5]` while we read the\n                             // array length of `a`.\n-                            debug!(\"borrow_conflicts_with_place: implicit field\");\n+                            debug!(\"places_conflict: implicit field\");\n                             return false;\n                         }\n \n                         (ProjectionElem::Deref, _, Shallow(None)) => {\n                             // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n                             // prefix thereof - the shallow access can't touch anything behind\n                             // the pointer.\n-                            debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n+                            debug!(\"places_conflict: shallow access behind ptr\");\n                             return false;\n                         }\n                         (ProjectionElem::Deref, ty::TyRef(_, ty::TypeAndMut {\n@@ -1803,7 +1800,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // I'm not sure why we are tracking these borrows - shared\n                             // references can *always* be aliased, which means the\n                             // permission check already account for this borrow.\n-                            debug!(\"borrow_conflicts_with_place: behind a shared ref\");\n+                            debug!(\"places_conflict: behind a shared ref\");\n                             return false;\n                         }\n \n@@ -1836,7 +1833,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // idea, at least for now, so just give up and\n                             // report a conflict. This is unsafe code anyway so\n                             // the user could always use raw pointers.\n-                            debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                            debug!(\"places_conflict: arbitrary -> conflict\");\n                             return true;\n                         }\n                         Overlap::EqualOrDisjoint => {\n@@ -1845,7 +1842,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         Overlap::Disjoint => {\n                             // We have proven the borrow disjoint - further\n                             // projections will remain disjoint.\n-                            debug!(\"borrow_conflicts_with_place: disjoint\");\n+                            debug!(\"places_conflict: disjoint\");\n                             return false;\n                         }\n                     }\n@@ -1874,10 +1871,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        'next_borrow: for i in flow_state.borrows.elems_incoming() {\n+        for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n \n-            if self.borrow_conflicts_with_place(borrowed, place, access) {\n+            if self.places_conflict(&borrowed.place, place, access) {\n                 let ctrl = op(self, i, borrowed);\n                 if ctrl == Control::Break { return; }\n             }"}, {"sha": "b32056fcb915a0eacb8d77de39f640e43791bc77", "filename": "src/test/compile-fail/immut-function-arguments.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs?ref=b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n \n fn f(y: Box<isize>) {\n-    *y = 5; //~ ERROR cannot assign\n+    *y = 5; //[ast]~ ERROR cannot assign\n+            //[mir]~^ ERROR cannot assign twice\n }\n \n fn g() {\n-    let _frob = |q: Box<isize>| { *q = 2; }; //~ ERROR cannot assign\n-\n+    let _frob = |q: Box<isize>| { *q = 2; }; //[ast]~ ERROR cannot assign\n+    //[mir]~^ ERROR cannot assign twice\n }\n \n fn main() {}"}, {"sha": "f138ae93f71a2abec4eadfbb8f27be1b849184d6", "filename": "src/test/compile-fail/mutable-class-fields.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64ddecae8112ca41d9a37ed8a3ebfd388b7e453/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs?ref=b64ddecae8112ca41d9a37ed8a3ebfd388b7e453", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n struct cat {\n   meows : usize,\n   how_hungry : isize,\n@@ -22,5 +25,6 @@ fn cat(in_x : usize, in_y : isize) -> cat {\n \n fn main() {\n   let nyan : cat = cat(52, 99);\n-  nyan.how_hungry = 0; //~ ERROR cannot assign\n+  nyan.how_hungry = 0; //[ast]~ ERROR cannot assign\n+  //[mir]~^ ERROR cannot assign\n }"}]}