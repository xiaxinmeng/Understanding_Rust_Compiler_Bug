{"sha": "455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NWQwNDc2YjExYzFhMWEyYWU4MDA1ZTc4MWM2ZWE5YjJmNGQyYWM=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-21T14:58:05Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:14:20Z"}, "message": "Refactor never loop to its own module", "tree": {"sha": "92d03cd0acf090fa65e6070dbcca94e36bff1b3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92d03cd0acf090fa65e6070dbcca94e36bff1b3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac", "html_url": "https://github.com/rust-lang/rust/commit/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "html_url": "https://github.com/rust-lang/rust/commit/5b870e1b36e781d842c7c84290707f2aaf5dc8cf"}], "stats": {"total": 345, "additions": 176, "deletions": 169}, "files": [{"sha": "9a4cbf27c497d2ed13a90486fbe994dfcf2f7d7d", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 4, "deletions": 169, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac", "patch": "@@ -8,6 +8,7 @@ mod infinite_loop;\n mod manual_flatten;\n mod manual_memcpy;\n mod needless_collect;\n+mod never_loop;\n mod same_item_push;\n mod utils;\n \n@@ -16,21 +17,18 @@ use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     get_enclosing_block, get_trait_def_id, higher, implements_trait, is_in_panic_handler, is_no_std_crate,\n     is_refutable, last_path_segment, match_trait_method, path_to_local, path_to_local_id, paths,\n-    snippet_with_applicability, span_lint, span_lint_and_help, span_lint_and_sugg, sugg,\n+    snippet_with_applicability, span_lint_and_help, span_lint_and_sugg, sugg,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{\n-    Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, MatchSource, Node, Pat, PatKind, Stmt, StmtKind,\n-};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n-use std::iter::{once, Iterator};\n use utils::{\n     get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor, LoopNestVisitor, Nesting,\n };\n@@ -567,12 +565,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         }\n \n         // check for never_loop\n-        if let ExprKind::Loop(ref block, _, _, _) = expr.kind {\n-            match never_loop_block(block, expr.hir_id) {\n-                NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n-                NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n-            }\n-        }\n+        never_loop::check_never_loop(cx, expr);\n \n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n@@ -689,164 +682,6 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n     }\n }\n \n-enum NeverLoopResult {\n-    // A break/return always get triggered but not necessarily for the main loop.\n-    AlwaysBreak,\n-    // A continue may occur for the main loop.\n-    MayContinueMainLoop,\n-    Otherwise,\n-}\n-\n-#[must_use]\n-fn absorb_break(arg: &NeverLoopResult) -> NeverLoopResult {\n-    match *arg {\n-        NeverLoopResult::AlwaysBreak | NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n-        NeverLoopResult::MayContinueMainLoop => NeverLoopResult::MayContinueMainLoop,\n-    }\n-}\n-\n-// Combine two results for parts that are called in order.\n-#[must_use]\n-fn combine_seq(first: NeverLoopResult, second: NeverLoopResult) -> NeverLoopResult {\n-    match first {\n-        NeverLoopResult::AlwaysBreak | NeverLoopResult::MayContinueMainLoop => first,\n-        NeverLoopResult::Otherwise => second,\n-    }\n-}\n-\n-// Combine two results where both parts are called but not necessarily in order.\n-#[must_use]\n-fn combine_both(left: NeverLoopResult, right: NeverLoopResult) -> NeverLoopResult {\n-    match (left, right) {\n-        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n-            NeverLoopResult::MayContinueMainLoop\n-        },\n-        (NeverLoopResult::AlwaysBreak, _) | (_, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n-        (NeverLoopResult::Otherwise, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n-    }\n-}\n-\n-// Combine two results where only one of the part may have been executed.\n-#[must_use]\n-fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult {\n-    match (b1, b2) {\n-        (NeverLoopResult::AlwaysBreak, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n-        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n-            NeverLoopResult::MayContinueMainLoop\n-        },\n-        (NeverLoopResult::Otherwise, _) | (_, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n-    }\n-}\n-\n-fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    let stmts = block.stmts.iter().map(stmt_to_expr);\n-    let expr = once(block.expr.as_deref());\n-    let mut iter = stmts.chain(expr).flatten();\n-    never_loop_expr_seq(&mut iter, main_loop_id)\n-}\n-\n-fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    match stmt.kind {\n-        StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n-        StmtKind::Local(ref local) => local.init.as_deref(),\n-        _ => None,\n-    }\n-}\n-\n-fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    match expr.kind {\n-        ExprKind::Box(ref e)\n-        | ExprKind::Unary(_, ref e)\n-        | ExprKind::Cast(ref e, _)\n-        | ExprKind::Type(ref e, _)\n-        | ExprKind::Field(ref e, _)\n-        | ExprKind::AddrOf(_, _, ref e)\n-        | ExprKind::Struct(_, _, Some(ref e))\n-        | ExprKind::Repeat(ref e, _)\n-        | ExprKind::DropTemps(ref e) => never_loop_expr(e, main_loop_id),\n-        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es, _) | ExprKind::Tup(ref es) => {\n-            never_loop_expr_all(&mut es.iter(), main_loop_id)\n-        },\n-        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n-        ExprKind::Binary(_, ref e1, ref e2)\n-        | ExprKind::Assign(ref e1, ref e2, _)\n-        | ExprKind::AssignOp(_, ref e1, ref e2)\n-        | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n-        ExprKind::Loop(ref b, _, _, _) => {\n-            // Break can come from the inner loop so remove them.\n-            absorb_break(&never_loop_block(b, main_loop_id))\n-        },\n-        ExprKind::If(ref e, ref e2, ref e3) => {\n-            let e1 = never_loop_expr(e, main_loop_id);\n-            let e2 = never_loop_expr(e2, main_loop_id);\n-            let e3 = e3\n-                .as_ref()\n-                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n-            combine_seq(e1, combine_branches(e2, e3))\n-        },\n-        ExprKind::Match(ref e, ref arms, _) => {\n-            let e = never_loop_expr(e, main_loop_id);\n-            if arms.is_empty() {\n-                e\n-            } else {\n-                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| &*a.body), main_loop_id);\n-                combine_seq(e, arms)\n-            }\n-        },\n-        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n-        ExprKind::Continue(d) => {\n-            let id = d\n-                .target_id\n-                .expect(\"target ID can only be missing in the presence of compilation errors\");\n-            if id == main_loop_id {\n-                NeverLoopResult::MayContinueMainLoop\n-            } else {\n-                NeverLoopResult::AlwaysBreak\n-            }\n-        },\n-        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n-            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n-        }),\n-        ExprKind::InlineAsm(ref asm) => asm\n-            .operands\n-            .iter()\n-            .map(|(o, _)| match o {\n-                InlineAsmOperand::In { expr, .. }\n-                | InlineAsmOperand::InOut { expr, .. }\n-                | InlineAsmOperand::Const { expr }\n-                | InlineAsmOperand::Sym { expr } => never_loop_expr(expr, main_loop_id),\n-                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n-                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                    never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n-                },\n-            })\n-            .fold(NeverLoopResult::Otherwise, combine_both),\n-        ExprKind::Struct(_, _, None)\n-        | ExprKind::Yield(_, _)\n-        | ExprKind::Closure(_, _, _, _, _)\n-        | ExprKind::LlvmInlineAsm(_)\n-        | ExprKind::Path(_)\n-        | ExprKind::ConstBlock(_)\n-        | ExprKind::Lit(_)\n-        | ExprKind::Err => NeverLoopResult::Otherwise,\n-    }\n-}\n-\n-fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    es.map(|e| never_loop_expr(e, main_loop_id))\n-        .fold(NeverLoopResult::Otherwise, combine_seq)\n-}\n-\n-fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    es.map(|e| never_loop_expr(e, main_loop_id))\n-        .fold(NeverLoopResult::Otherwise, combine_both)\n-}\n-\n-fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    e.map(|e| never_loop_expr(e, main_loop_id))\n-        .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n-}\n-\n fn check_for_loop<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,"}, {"sha": "d51ff81103fd448d9b3a45e5164ee7be3d0d274a", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=455d0476b11c1a1a2ae8005e781c6ea9b2f4d2ac", "patch": "@@ -0,0 +1,172 @@\n+use super::NEVER_LOOP;\n+use crate::utils::span_lint;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Stmt, StmtKind};\n+use rustc_lint::LateContext;\n+use std::iter::{once, Iterator};\n+\n+pub(super) fn check_never_loop(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Loop(ref block, _, _, _) = expr.kind {\n+        match never_loop_block(block, expr.hir_id) {\n+            NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n+            NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n+        }\n+    }\n+}\n+\n+enum NeverLoopResult {\n+    // A break/return always get triggered but not necessarily for the main loop.\n+    AlwaysBreak,\n+    // A continue may occur for the main loop.\n+    MayContinueMainLoop,\n+    Otherwise,\n+}\n+\n+#[must_use]\n+fn absorb_break(arg: &NeverLoopResult) -> NeverLoopResult {\n+    match *arg {\n+        NeverLoopResult::AlwaysBreak | NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n+        NeverLoopResult::MayContinueMainLoop => NeverLoopResult::MayContinueMainLoop,\n+    }\n+}\n+\n+// Combine two results for parts that are called in order.\n+#[must_use]\n+fn combine_seq(first: NeverLoopResult, second: NeverLoopResult) -> NeverLoopResult {\n+    match first {\n+        NeverLoopResult::AlwaysBreak | NeverLoopResult::MayContinueMainLoop => first,\n+        NeverLoopResult::Otherwise => second,\n+    }\n+}\n+\n+// Combine two results where both parts are called but not necessarily in order.\n+#[must_use]\n+fn combine_both(left: NeverLoopResult, right: NeverLoopResult) -> NeverLoopResult {\n+    match (left, right) {\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n+            NeverLoopResult::MayContinueMainLoop\n+        },\n+        (NeverLoopResult::AlwaysBreak, _) | (_, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::Otherwise, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+// Combine two results where only one of the part may have been executed.\n+#[must_use]\n+fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult {\n+    match (b1, b2) {\n+        (NeverLoopResult::AlwaysBreak, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n+            NeverLoopResult::MayContinueMainLoop\n+        },\n+        (NeverLoopResult::Otherwise, _) | (_, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+    let stmts = block.stmts.iter().map(stmt_to_expr);\n+    let expr = once(block.expr.as_deref());\n+    let mut iter = stmts.chain(expr).flatten();\n+    never_loop_expr_seq(&mut iter, main_loop_id)\n+}\n+\n+fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::Otherwise, combine_seq)\n+}\n+\n+fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    match stmt.kind {\n+        StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n+        StmtKind::Local(ref local) => local.init.as_deref(),\n+        _ => None,\n+    }\n+}\n+\n+fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+    match expr.kind {\n+        ExprKind::Box(ref e)\n+        | ExprKind::Unary(_, ref e)\n+        | ExprKind::Cast(ref e, _)\n+        | ExprKind::Type(ref e, _)\n+        | ExprKind::Field(ref e, _)\n+        | ExprKind::AddrOf(_, _, ref e)\n+        | ExprKind::Struct(_, _, Some(ref e))\n+        | ExprKind::Repeat(ref e, _)\n+        | ExprKind::DropTemps(ref e) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es, _) | ExprKind::Tup(ref es) => {\n+            never_loop_expr_all(&mut es.iter(), main_loop_id)\n+        },\n+        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n+        ExprKind::Binary(_, ref e1, ref e2)\n+        | ExprKind::Assign(ref e1, ref e2, _)\n+        | ExprKind::AssignOp(_, ref e1, ref e2)\n+        | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n+        ExprKind::Loop(ref b, _, _, _) => {\n+            // Break can come from the inner loop so remove them.\n+            absorb_break(&never_loop_block(b, main_loop_id))\n+        },\n+        ExprKind::If(ref e, ref e2, ref e3) => {\n+            let e1 = never_loop_expr(e, main_loop_id);\n+            let e2 = never_loop_expr(e2, main_loop_id);\n+            let e3 = e3\n+                .as_ref()\n+                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n+            combine_seq(e1, combine_branches(e2, e3))\n+        },\n+        ExprKind::Match(ref e, ref arms, _) => {\n+            let e = never_loop_expr(e, main_loop_id);\n+            if arms.is_empty() {\n+                e\n+            } else {\n+                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| &*a.body), main_loop_id);\n+                combine_seq(e, arms)\n+            }\n+        },\n+        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Continue(d) => {\n+            let id = d\n+                .target_id\n+                .expect(\"target ID can only be missing in the presence of compilation errors\");\n+            if id == main_loop_id {\n+                NeverLoopResult::MayContinueMainLoop\n+            } else {\n+                NeverLoopResult::AlwaysBreak\n+            }\n+        },\n+        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+        }),\n+        ExprKind::InlineAsm(ref asm) => asm\n+            .operands\n+            .iter()\n+            .map(|(o, _)| match o {\n+                InlineAsmOperand::In { expr, .. }\n+                | InlineAsmOperand::InOut { expr, .. }\n+                | InlineAsmOperand::Const { expr }\n+                | InlineAsmOperand::Sym { expr } => never_loop_expr(expr, main_loop_id),\n+                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n+                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                    never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n+                },\n+            })\n+            .fold(NeverLoopResult::Otherwise, combine_both),\n+        ExprKind::Struct(_, _, None)\n+        | ExprKind::Yield(_, _)\n+        | ExprKind::Closure(_, _, _, _, _)\n+        | ExprKind::LlvmInlineAsm(_)\n+        | ExprKind::Path(_)\n+        | ExprKind::ConstBlock(_)\n+        | ExprKind::Lit(_)\n+        | ExprKind::Err => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::Otherwise, combine_both)\n+}\n+\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    e.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n+}"}]}