{"sha": "d71a4f40d9f82bf4da8012568ddad561613476c7", "node_id": "C_kwDOAAsO6NoAKGQ3MWE0ZjQwZDlmODJiZjRkYTgwMTI1NjhkZGFkNTYxNjEzNDc2Yzc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-12T07:27:17Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-12T07:35:02Z"}, "message": "Regenerate lints", "tree": {"sha": "ae718fd238b1d239fd879b515164ec443ab0f484", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae718fd238b1d239fd879b515164ec443ab0f484"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d71a4f40d9f82bf4da8012568ddad561613476c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d71a4f40d9f82bf4da8012568ddad561613476c7", "html_url": "https://github.com/rust-lang/rust/commit/d71a4f40d9f82bf4da8012568ddad561613476c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d71a4f40d9f82bf4da8012568ddad561613476c7/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed7c2948b3b8861dc479d84b3b29a284a176d4ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed7c2948b3b8861dc479d84b3b29a284a176d4ed", "html_url": "https://github.com/rust-lang/rust/commit/ed7c2948b3b8861dc479d84b3b29a284a176d4ed"}], "stats": {"total": 798, "additions": 448, "deletions": 350}, "files": [{"sha": "5abd6d360e1f2b4f5f53fdb434ed2a5f6e543dbb", "filename": "crates/ide_db/src/helpers/generated_lints.rs", "status": "modified", "additions": 430, "deletions": 160, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/d71a4f40d9f82bf4da8012568ddad561613476c7/crates%2Fide_db%2Fsrc%2Fhelpers%2Fgenerated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d71a4f40d9f82bf4da8012568ddad561613476c7/crates%2Fide_db%2Fsrc%2Fhelpers%2Fgenerated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fgenerated_lints.rs?ref=d71a4f40d9f82bf4da8012568ddad561613476c7", "patch": "@@ -1,4 +1,4 @@\n-//! Generated by `sourcegen_lint_completions`, do not edit by hand.\n+//! Generated by `sourcegen_lints`, do not edit by hand.\n \n pub struct Lint {\n     pub label: &'static str,\n@@ -12,7 +12,10 @@ pub const DEFAULT_LINTS: &[Lint] = &[\n     Lint { label: \"ambiguous_associated_items\", description: r##\"ambiguous associated items\"## },\n     Lint { label: \"anonymous_parameters\", description: r##\"detects anonymous parameters\"## },\n     Lint { label: \"arithmetic_overflow\", description: r##\"arithmetic operation overflows\"## },\n-    Lint { label: \"array_into_iter\", description: r##\"detects calling `into_iter` on arrays\"## },\n+    Lint {\n+        label: \"array_into_iter\",\n+        description: r##\"detects calling `into_iter` on arrays in Rust 2015 and 2018\"##,\n+    },\n     Lint {\n         label: \"asm_sub_register\",\n         description: r##\"using only a subset of a register for inline asm inputs\"##,\n@@ -69,11 +72,11 @@ pub const DEFAULT_LINTS: &[Lint] = &[\n         label: \"deref_nullptr\",\n         description: r##\"detects when an null pointer is dereferenced\"##,\n     },\n+    Lint { label: \"drop_bounds\", description: r##\"bounds of the form `T: Drop` are useless\"## },\n     Lint {\n-        label: \"disjoint_capture_drop_reorder\",\n-        description: r##\"Drop reorder because of `capture_disjoint_fields`\"##,\n+        label: \"dyn_drop\",\n+        description: r##\"trait objects of the form `dyn Drop` are useless\"##,\n     },\n-    Lint { label: \"drop_bounds\", description: r##\"bounds of the form `T: Drop` are useless\"## },\n     Lint {\n         label: \"elided_lifetimes_in_paths\",\n         description: r##\"hidden lifetime parameters in types are deprecated\"##,\n@@ -97,7 +100,7 @@ pub const DEFAULT_LINTS: &[Lint] = &[\n     },\n     Lint {\n         label: \"future_incompatible\",\n-        description: r##\"lint group for: keyword-idents, anonymous-parameters, forbidden-lint-groups, illegal-floating-point-literal-pattern, private-in-public, pub-use-of-private-extern-crate, invalid-type-param-default, const-err, unaligned-references, patterns-in-fns-without-body, missing-fragment-specifier, late-bound-lifetime-arguments, order-dependent-trait-objects, coherence-leak-check, tyvar-behind-raw-pointer, absolute-paths-not-starting-with-crate, unstable-name-collisions, where-clauses-object-safety, proc-macro-derive-resolution-fallback, macro-expanded-macro-exports-accessed-by-absolute-paths, ill-formed-attribute-input, conflicting-repr-hints, ambiguous-associated-items, mutable-borrow-reservation-conflict, indirect-structural-match, pointer-structural-match, nontrivial-structural-match, soft-unstable, cenum-impl-drop-cast, const-evaluatable-unchecked, uninhabited-static, unsupported-naked-functions, semicolon-in-expressions-from-macros, legacy-derive-helpers, proc-macro-back-compat, array-into-iter\"##,\n+        description: r##\"lint group for: forbidden-lint-groups, illegal-floating-point-literal-pattern, private-in-public, pub-use-of-private-extern-crate, invalid-type-param-default, const-err, unaligned-references, patterns-in-fns-without-body, missing-fragment-specifier, late-bound-lifetime-arguments, order-dependent-trait-objects, coherence-leak-check, unstable-name-collisions, where-clauses-object-safety, proc-macro-derive-resolution-fallback, macro-expanded-macro-exports-accessed-by-absolute-paths, ill-formed-attribute-input, conflicting-repr-hints, ambiguous-associated-items, mutable-borrow-reservation-conflict, indirect-structural-match, pointer-structural-match, nontrivial-structural-match, soft-unstable, cenum-impl-drop-cast, const-evaluatable-unchecked, uninhabited-static, unsupported-naked-functions, invalid-doc-attributes, semicolon-in-expressions-from-macros, legacy-derive-helpers, proc-macro-back-compat, unsupported-calling-conventions\"##,\n     },\n     Lint {\n         label: \"ill_formed_attribute_input\",\n@@ -132,13 +135,17 @@ pub const DEFAULT_LINTS: &[Lint] = &[\n         label: \"inline_no_sanitize\",\n         description: r##\"detects incompatible use of `#[inline(always)]` and `#[no_sanitize(...)]`\"##,\n     },\n+    Lint {\n+        label: \"invalid_doc_attributes\",\n+        description: r##\"detects invalid `#[doc(...)]` attributes\"##,\n+    },\n     Lint {\n         label: \"invalid_type_param_default\",\n         description: r##\"type parameter default erroneously allowed in invalid location\"##,\n     },\n     Lint {\n         label: \"invalid_value\",\n-        description: r##\"an invalid value is being created (such as a NULL reference)\"##,\n+        description: r##\"an invalid value is being created (such as a null reference)\"##,\n     },\n     Lint {\n         label: \"irrefutable_let_patterns\",\n@@ -209,7 +216,7 @@ pub const DEFAULT_LINTS: &[Lint] = &[\n         description: r##\"types, variants, traits and type parameters should have camel case names\"##,\n     },\n     Lint {\n-        label: \"non_fmt_panic\",\n+        label: \"non_fmt_panics\",\n         description: r##\"detect single-argument panic!() invocations in which the argument is not a format string\"##,\n     },\n     Lint {\n@@ -236,10 +243,6 @@ pub const DEFAULT_LINTS: &[Lint] = &[\n         label: \"noop_method_call\",\n         description: r##\"detects the use of well-known noop methods\"##,\n     },\n-    Lint {\n-        label: \"or_patterns_back_compat\",\n-        description: r##\"detects usage of old versions of or-patterns\"##,\n-    },\n     Lint {\n         label: \"order_dependent_trait_objects\",\n         description: r##\"trait-object types were treated as different depending on marker-trait order\"##,\n@@ -290,6 +293,26 @@ pub const DEFAULT_LINTS: &[Lint] = &[\n         label: \"rust_2018_idioms\",\n         description: r##\"lint group for: bare-trait-objects, unused-extern-crates, ellipsis-inclusive-range-patterns, elided-lifetimes-in-paths, explicit-outlives-requirements\"##,\n     },\n+    Lint {\n+        label: \"rust_2021_compatibility\",\n+        description: r##\"lint group for: ellipsis-inclusive-range-patterns, bare-trait-objects, rust-2021-incompatible-closure-captures, rust-2021-incompatible-or-patterns, rust-2021-prelude-collisions, rust-2021-prefixes-incompatible-syntax, array-into-iter, non-fmt-panics\"##,\n+    },\n+    Lint {\n+        label: \"rust_2021_incompatible_closure_captures\",\n+        description: r##\"detects closures affected by Rust 2021 changes\"##,\n+    },\n+    Lint {\n+        label: \"rust_2021_incompatible_or_patterns\",\n+        description: r##\"detects usage of old versions of or-patterns\"##,\n+    },\n+    Lint {\n+        label: \"rust_2021_prefixes_incompatible_syntax\",\n+        description: r##\"identifiers that will be parsed as a prefix in Rust 2021\"##,\n+    },\n+    Lint {\n+        label: \"rust_2021_prelude_collisions\",\n+        description: r##\"detects the usage of trait methods which are ambiguous with traits added to the prelude in future editions\"##,\n+    },\n     Lint {\n         label: \"semicolon_in_expressions_from_macros\",\n         description: r##\"trailing semicolon in macro body used as expression\"##,\n@@ -375,6 +398,10 @@ pub const DEFAULT_LINTS: &[Lint] = &[\n         label: \"unstable_name_collisions\",\n         description: r##\"detects name collision with an existing but unstable method\"##,\n     },\n+    Lint {\n+        label: \"unsupported_calling_conventions\",\n+        description: r##\"use of unsupported calling convention\"##,\n+    },\n     Lint {\n         label: \"unsupported_naked_functions\",\n         description: r##\"unsupported naked function definitions\"##,\n@@ -722,47 +749,6 @@ detail of the `global_allocator` feature not intended for use outside the\n compiler.\n \n ------------------------\n-\"##,\n-    },\n-    Lint {\n-        label: \"arbitrary_enum_discriminant\",\n-        description: r##\"# `arbitrary_enum_discriminant`\n-\n-The tracking issue for this feature is: [#60553]\n-\n-[#60553]: https://github.com/rust-lang/rust/issues/60553\n-\n-------------------------\n-\n-The `arbitrary_enum_discriminant` feature permits tuple-like and\n-struct-like enum variants with `#[repr(<int-type>)]` to have explicit discriminants.\n-\n-## Examples\n-\n-```rust\n-#![feature(arbitrary_enum_discriminant)]\n-\n-#[allow(dead_code)]\n-#[repr(u8)]\n-enum Enum {\n-    Unit = 3,\n-    Tuple(u16) = 2,\n-    Struct {\n-        a: u8,\n-        b: u16,\n-    } = 1,\n-}\n-\n-impl Enum {\n-    fn tag(&self) -> u8 {\n-        unsafe { *(self as *const Self as *const u8) }\n-    }\n-}\n-\n-assert_eq!(3, Enum::Unit.tag());\n-assert_eq!(2, Enum::Tuple(5).tag());\n-assert_eq!(1, Enum::Struct{a: 7, b: 11}.tag());\n-```\n \"##,\n     },\n     Lint {\n@@ -800,6 +786,7 @@ Inline assembly is currently supported on the following architectures:\n - MIPS32r2 and MIPS64r2\n - wasm32\n - BPF\n+- SPIR-V\n \n ## Basic usage\n \n@@ -957,8 +944,7 @@ As you can see, this assembly fragment will still work correctly if `a` and `b`\n \n Some instructions require that the operands be in a specific register.\n Therefore, Rust inline assembly provides some more specific constraint specifiers.\n-While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`\n-among others can be addressed by their name.\n+While `reg` is generally available on any architecture, explicit registers are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi` among others can be addressed by their name.\n \n ```rust,allow_fail,no_run\n #![feature(asm)]\n@@ -968,11 +954,9 @@ unsafe {\n }\n ```\n \n-In this example we call the `out` instruction to output the content of the `cmd` variable\n-to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand\n-we had to use the `eax` constraint specifier.\n+In this example we call the `out` instruction to output the content of the `cmd` variable to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand we had to use the `eax` constraint specifier.\n \n-Note that unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n+> **Note**: unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n \n Consider this example which uses the x86 `mul` instruction:\n \n@@ -1006,11 +990,9 @@ The higher 64 bits are stored in `rdx` from which we fill the variable `hi`.\n ## Clobbered registers\n \n In many cases inline assembly will modify state that is not needed as an output.\n-Usually this is either because we have to use a scratch register in the assembly,\n-or instructions modify state that we don't need to further examine.\n+Usually this is either because we have to use a scratch register in the assembly or because instructions modify state that we don't need to further examine.\n This state is generally referred to as being \"clobbered\".\n-We need to tell the compiler about this since it may need to save and restore this state\n-around the inline assembly block.\n+We need to tell the compiler about this since it may need to save and restore this state around the inline assembly block.\n \n ```rust,allow_fail\n #![feature(asm)]\n@@ -1059,44 +1041,40 @@ unsafe {\n assert_eq!(x, 4 * 6);\n ```\n \n-## Symbol operands\n+## Symbol operands and ABI clobbers\n \n A special operand type, `sym`, allows you to use the symbol name of a `fn` or `static` in inline assembly code.\n This allows you to call a function or access a global variable without needing to keep its address in a register.\n \n ```rust,allow_fail\n #![feature(asm)]\n-extern \"C\" fn foo(arg: i32) {\n+extern \"C\" fn foo(arg: i32) -> i32 {\n     println!(\"arg = {}\", arg);\n+    arg * 2\n }\n \n-fn call_foo(arg: i32) {\n+fn call_foo(arg: i32) -> i32 {\n     unsafe {\n+        let result;\n         asm!(\n             \"call {}\",\n             sym foo,\n-            // 1st argument in rdi, which is caller-saved\n-            inout(\"rdi\") arg => _,\n-            // All caller-saved registers must be marked as clobbered\n-            out(\"rax\") _, out(\"rcx\") _, out(\"rdx\") _, out(\"rsi\") _,\n-            out(\"r8\") _, out(\"r9\") _, out(\"r10\") _, out(\"r11\") _,\n-            out(\"xmm0\") _, out(\"xmm1\") _, out(\"xmm2\") _, out(\"xmm3\") _,\n-            out(\"xmm4\") _, out(\"xmm5\") _, out(\"xmm6\") _, out(\"xmm7\") _,\n-            out(\"xmm8\") _, out(\"xmm9\") _, out(\"xmm10\") _, out(\"xmm11\") _,\n-            out(\"xmm12\") _, out(\"xmm13\") _, out(\"xmm14\") _, out(\"xmm15\") _,\n-            // Also mark AVX-512 registers as clobbered. This is accepted by the\n-            // compiler even if AVX-512 is not enabled on the current target.\n-            out(\"xmm16\") _, out(\"xmm17\") _, out(\"xmm18\") _, out(\"xmm19\") _,\n-            out(\"xmm20\") _, out(\"xmm21\") _, out(\"xmm22\") _, out(\"xmm23\") _,\n-            out(\"xmm24\") _, out(\"xmm25\") _, out(\"xmm26\") _, out(\"xmm27\") _,\n-            out(\"xmm28\") _, out(\"xmm29\") _, out(\"xmm30\") _, out(\"xmm31\") _,\n-        )\n+            // 1st argument in rdi\n+            in(\"rdi\") arg,\n+            // Return value in rax\n+            out(\"rax\") result,\n+            // Mark all registers which are not preserved by the \"C\" calling\n+            // convention as clobbered.\n+            clobber_abi(\"C\"),\n+        );\n+        result\n     }\n }\n ```\n \n-Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`:\n-the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n+Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`: the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n+\n+By default, `asm!` assumes that any register not specified as an output will have its contents preserved by the assembly code. The [`clobber_abi`](#abi-clobbers) argument to `asm!` tells the compiler to automatically insert the necessary clobber operands according to the given calling convention ABI: any register which is not fully preserved in that ABI will be treated as clobbered.\n \n ## Register template modifiers\n \n@@ -1127,9 +1105,8 @@ If you use a smaller data type (e.g. `u16`) with an operand and forget the use t\n ## Memory address operands\n \n Sometimes assembly instructions require operands passed via memory addresses/memory locations.\n-You have to manually use the memory address syntax specified by the respectively architectures.\n-For example, in x86/x86_64 and intel assembly syntax, you should wrap inputs/outputs in `[]`\n-to indicate they are memory operands:\n+You have to manually use the memory address syntax specified by the target architecture.\n+For example, on x86/x86_64 using intel assembly syntax, you should wrap inputs/outputs in `[]` to indicate they are memory operands:\n \n ```rust,allow_fail\n #![feature(asm, llvm_asm)]\n@@ -1145,9 +1122,15 @@ unsafe {\n \n ## Labels\n \n-The compiler is allowed to instantiate multiple copies an `asm!` block, for example when the function containing it is inlined in multiple places. As a consequence, you should only use GNU assembler [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n+Any reuse of a named label, local or otherwise, can result in a assembler or linker error or may cause other strange behavior. Reuse of a named label can happen in a variety of ways including:\n+\n+-   explicitly: using a label more than once in one `asm!` block, or multiple times across blocks\n+-   implicitly via inlining: the compiler is allowed to instantiate multiple copies of an `asm!` block, for example when the function containing it is inlined in multiple places.\n+-   implicitly via LTO: LTO can cause code from *other crates* to be placed in the same codegen unit, and so could bring in arbitrary labels\n+\n+As a consequence, you should only use GNU assembler **numeric** [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n \n-Moreover, due to [an llvm bug], you shouldn't use labels exclusively made of `0` and `1` digits, e.g. `0`, `11` or `101010`, as they may end up being interpreted as binary values.\n+Moreover, on x86 when using the default intel syntax, due to [an llvm bug], you shouldn't use labels exclusively made of `0` and `1` digits, e.g. `0`, `11` or `101010`, as they may end up being interpreted as binary values. Using `options(att_syntax)` will avoid any ambiguity, but that affects the syntax of the _entire_ `asm!` block.\n \n ```rust,allow_fail\n #![feature(asm)]\n@@ -1171,7 +1154,7 @@ assert_eq!(a, 5);\n \n This will decrement the `{0}` register value from 10 to 3, then add 2 and store it in `a`.\n \n-This example show a few thing:\n+This example shows a few things:\n \n First that the same number can be used as a label multiple times in the same inline block.\n \n@@ -1182,7 +1165,7 @@ Second, that when a numeric label is used as a reference (as an instruction oper\n \n ## Options\n \n-By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n+By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However, in many cases it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n \n Let's take our previous example of an `add` instruction:\n \n@@ -1225,12 +1208,26 @@ reg_spec := <register class> / \"<explicit register>\"\n operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n operand := reg_operand / \"const\" const_expr / \"sym\" path\n+clobber_abi := \"clobber_abi(\" <abi> \")\"\n option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / \"noreturn\" / \"nostack\" / \"att_syntax\" / \"raw\"\n options := \"options(\" option *[\",\" option] [\",\"] \")\"\n-asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n+asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] operand) [\",\" clobber_abi] *(\",\" options) [\",\"] \")\"\n ```\n \n-The macro will initially be supported only on ARM, AArch64, Hexagon, PowerPC, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n+Inline assembly is currently supported on the following architectures:\n+- x86 and x86-64\n+- ARM\n+- AArch64\n+- RISC-V\n+- NVPTX\n+- PowerPC\n+- Hexagon\n+- MIPS32r2 and MIPS64r2\n+- wasm32\n+- BPF\n+- SPIR-V\n+\n+Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n \n [format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n \n@@ -1314,9 +1311,12 @@ Here is the list of currently supported register classes:\n | x86 | `ymm_reg` | `ymm[0-7]` (x86) `ymm[0-15]` (x86-64) | `x` |\n | x86 | `zmm_reg` | `zmm[0-7]` (x86) `zmm[0-31]` (x86-64) | `v` |\n | x86 | `kreg` | `k[1-7]` | `Yk` |\n+| x86 | `x87_reg` | `st([0-7])` | Only clobbers |\n+| x86 | `mmx_reg` | `mm[0-7]` | Only clobbers |\n | AArch64 | `reg` | `x[0-30]` | `r` |\n | AArch64 | `vreg` | `v[0-31]` | `w` |\n | AArch64 | `vreg_low16` | `v[0-15]` | `x` |\n+| AArch64 | `preg` | `p[0-15]`, `ffr` | Only clobbers |\n | ARM | `reg` | `r[0-12]`, `r14` | `r` |\n | ARM (Thumb) | `reg_thumb` | `r[0-r7]` | `l` |\n | ARM (ARM) | `reg_thumb` | `r[0-r12]`, `r14` | `l` |\n@@ -1335,10 +1335,13 @@ Here is the list of currently supported register classes:\n | NVPTX | `reg64` | None\\* | `l` |\n | RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n | RISC-V | `freg` | `f[0-31]` | `f` |\n+| RISC-V | `vreg` | `v[0-31]` | Only clobbers |\n | Hexagon | `reg` | `r[0-28]` | `r` |\n | PowerPC | `reg` | `r[0-31]` | `r` |\n | PowerPC | `reg_nonzero` | | `r[1-31]` | `b` |\n | PowerPC | `freg` | `f[0-31]` | `f` |\n+| PowerPC | `cr` | `cr[0-7]`, `cr` | Only clobbers |\n+| PowerPC | `xer` | `xer` | Only clobbers |\n | wasm32 | `local` | None\\* | `r` |\n | BPF | `reg` |\u00a0`r[0-10]` | `r` |\n | BPF | `wreg` |\u00a0`w[0-10]` | `w` |\n@@ -1350,6 +1353,8 @@ Here is the list of currently supported register classes:\n > Note #3: NVPTX doesn't have a fixed register set, so named registers are not supported.\n >\n > Note #4: WebAssembly doesn't have registers, so named registers are not supported.\n+>\n+> Note #5: Some register classes are marked as \"Only clobbers\" which means that they cannot be used for inputs or outputs, only clobbers of the form `out(\"reg\") _` or `lateout(\"reg\") _`.\n \n Additional register classes may be added in the future based on demand (e.g. MMX, x87, etc).\n \n@@ -1363,10 +1368,13 @@ Each register class has constraints on which value types they can be used with.\n | x86 | `xmm_reg` | `sse` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n | x86 | `ymm_reg` | `avx` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` |\n | x86 | `zmm_reg` | `avx512f` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` <br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8` |\n-| x86 | `kreg` | `axv512f` | `i8`, `i16` |\n-| x86 | `kreg` | `axv512bw` | `i32`, `i64` |\n+| x86 | `kreg` | `avx512f` | `i8`, `i16` |\n+| x86 | `kreg` | `avx512bw` | `i32`, `i64` |\n+| x86 | `mmx_reg` | N/A | Only clobbers |\n+| x86 | `x87_reg` | N/A | Only clobbers |\n | AArch64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | AArch64 | `vreg` | `fp` | `i8`, `i16`, `i32`, `f32`, `i64`, `f64`, <br> `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2`, `f64x1`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| AArch64 | `preg` | N/A | Only clobbers |\n | ARM | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n | ARM | `sreg` | `vfp2` | `i32`, `f32` |\n | ARM | `dreg` | `vfp2` | `i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2` |\n@@ -1382,10 +1390,13 @@ Each register class has constraints on which value types they can be used with.\n | RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V | `freg` | `f` | `f32` |\n | RISC-V | `freg` | `d` | `f64` |\n+| RISC-V | `vreg` | N/A | Only clobbers |\n | Hexagon | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n | PowerPC | `reg` | None | `i8`, `i16`, `i32` |\n | PowerPC | `reg_nonzero` | None | `i8`, `i16`, `i32` |\n | PowerPC | `freg` | None | `f32`, `f64` |\n+| PowerPC | `cr` | N/A | Only clobbers |\n+| PowerPC | `xer` | N/A | Only clobbers |\n | wasm32 | `local` | None | `i8` `i16` `i32` `i64` `f32` `f64` |\n | BPF |\u00a0`reg` |\u00a0None | `i8` `i16` `i32` `i64` |\n | BPF |\u00a0`wreg` |\u00a0`alu32` | `i8` `i16` `i32` |\n@@ -1539,6 +1550,24 @@ As stated in the previous section, passing an input value smaller than the regis\n \n [llvm-argmod]: http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers\n \n+## ABI clobbers\n+\n+The `clobber_abi` keyword can be used to apply a default set of clobbers to an `asm` block. This will automatically insert the necessary clobber constraints as needed for calling a function with a particular calling convention: if the calling convention does not fully preserve the value of a register across a call then a `lateout(\"reg\") _` is implicitly added to the operands list.\n+\n+Generic register class outputs are disallowed by the compiler when `clobber_abi` is used: all outputs must specify an explicit register. Explicit register outputs have precedence over the implicit clobbers inserted by `clobber_abi`: a clobber will only be inserted for a register if that register is not used as an output.\n+The following ABIs can be used with `clobber_abi`:\n+\n+| Architecture | ABI name | Clobbered registers |\n+| ------------ | -------- | ------------------- |\n+| x86-32 | `\"C\"`, `\"system\"`, `\"efiapi\"`, `\"cdecl\"`, `\"stdcall\"`, `\"fastcall\"` | `ax`, `cx`, `dx`, `xmm[0-7]`, `mm[0-7]`, `k[1-7]`, `st([0-7])` |\n+| x86-64 | `\"C\"`, `\"system\"` (on Windows), `\"efiapi\"`, `\"win64\"` | `ax`, `cx`, `dx`, `r[8-11]`, `xmm[0-31]`, `mm[0-7]`, `k[1-7]`, `st([0-7])` |\n+| x86-64 | `\"C\"`, `\"system\"` (on non-Windows), `\"sysv64\"` | `ax`, `cx`, `dx`, `si`, `di`, `r[8-11]`, `xmm[0-31]`, `mm[0-7]`, `k[1-7]`, `st([0-7])` |\n+| AArch64 | `\"C\"`, `\"system\"`, `\"efiapi\"` | `x[0-17]`, `x30`, `v[0-31]`, `p[0-15]`, `ffr` |\n+| ARM | `\"C\"`, `\"system\"`, `\"efiapi\"`, `\"aapcs\"` | `r[0-3]`, `r12`, `r14`, `s[0-15]`, `d[0-7]`, `d[16-31]` |\n+| RISC-V | `\"C\"`, `\"system\"`, `\"efiapi\"` | `x1`, `x[5-7]`, `x[10-17]`, `x[28-31]`, `f[0-7]`, `f[10-17]`, `f[28-31]`, `v[0-31]` |\n+\n+The list of clobbered registers for each ABI is updated in rustc as architectures gain new registers: this ensures that `asm` clobbers will continue to be correct when LLVM starts using these new registers in its generated code.\n+\n ## Options\n \n Flags are used to further influence the behavior of the inline assembly block.\n@@ -1567,7 +1596,7 @@ The compiler performs some additional checks on options:\n   - Note that a `lateout` may be allocated to the same register as an `in`, in which case this rule does not apply. Code should not rely on this however since it depends on the results of register allocation.\n - Behavior is undefined if execution unwinds out of an asm block.\n   - This also applies if the assembly code calls a function which then unwinds.\n-- The set of memory locations that assembly code is allowed the read and write are the same as those allowed for an FFI function.\n+- The set of memory locations that assembly code is allowed to read and write are the same as those allowed for an FFI function.\n   - Refer to the unsafe code guidelines for the exact rules.\n   - If the `readonly` option is set, then only memory reads are allowed.\n   - If the `nomem` option is set then no reads or writes to memory are allowed.\n@@ -1601,6 +1630,7 @@ The compiler performs some additional checks on options:\n     - Floating-point status (`FPSR` register).\n   - RISC-V\n     - Floating-point exception flags in `fcsr` (`fflags`).\n+    - Vector extension state (`vtype`, `vl`, `vcsr`).\n - On x86, the direction flag (DF in `EFLAGS`) is clear on entry to an asm block and must be clear on exit.\n   - Behavior is undefined if the direction flag is set on exiting an asm block.\n - The requirement of restoring the stack pointer and non-output registers to their original value only applies when exiting an `asm!` block.\n@@ -1998,6 +2028,22 @@ fn b() {\n This feature is internal to the Rust compiler and is not intended for general use.\n \n ------------------------\n+\"##,\n+    },\n+    Lint {\n+        label: \"closure_track_caller\",\n+        description: r##\"# `closure_track_caller`\n+\n+The tracking issue for this feature is: [#87417]\n+\n+[#87417]: https://github.com/rust-lang/rust/issues/87417\n+\n+------------------------\n+\n+Allows using the `#[track_caller]` attribute on closures and generators.\n+Calls made to the closure or generator will have caller information\n+available through `std::panic::Location::caller()`, just like using\n+`#[track_caller]` on a function.\n \"##,\n     },\n     Lint {\n@@ -2418,6 +2464,93 @@ See also its documentation in [the rustdoc book][rustdoc-book-notable_trait].\n [#45040]: https://github.com/rust-lang/rust/issues/45040\n [#45039]: https://github.com/rust-lang/rust/pull/45039\n [rustdoc-book-notable_trait]: ../../rustdoc/unstable-features.html#adding-your-trait-to-the-notable-traits-dialog\n+\"##,\n+    },\n+    Lint {\n+        label: \"exclusive_range_pattern\",\n+        description: r##\"# `exclusive_range_pattern`\n+\n+The tracking issue for this feature is: [#37854].\n+\n+\n+[#67264]: https://github.com/rust-lang/rust/issues/67264\n+[#37854]: https://github.com/rust-lang/rust/issues/37854\n+-----\n+\n+The `exclusive_range_pattern` feature allows non-inclusive range\n+patterns (`0..10`) to be used in appropriate pattern matching\n+contexts. It also can be combined with `#![feature(half_open_range_patterns]`\n+to be able to use RangeTo patterns (`..10`).\n+\n+It also enabled RangeFrom patterns but that has since been\n+stabilized.\n+\n+```rust\n+#![feature(exclusive_range_pattern)]\n+    let x = 5;\n+    match x {\n+        0..10 => println!(\"single digit\"),\n+        10 => println!(\"ten isn't part of the above range\"),\n+        _ => println!(\"nor is everything else.\")\n+    }\n+```\n+\"##,\n+    },\n+    Lint {\n+        label: \"explicit_generic_args_with_impl_trait\",\n+        description: r##\"# `explicit_generic_args_with_impl_trait`\n+\n+The tracking issue for this feature is: [#83701]\n+\n+[#83701]: https://github.com/rust-lang/rust/issues/83701\n+\n+------------------------\n+\n+The `explicit_generic_args_with_impl_trait` feature gate lets you specify generic arguments even\n+when `impl Trait` is used in argument position.\n+\n+A simple example is:\n+\n+```rust\n+#![feature(explicit_generic_args_with_impl_trait)]\n+\n+fn foo<T: ?Sized>(_f: impl AsRef<T>) {}\n+\n+fn main() {\n+    foo::<str>(\"\".to_string());\n+}\n+```\n+\n+This is currently rejected:\n+\n+```text\n+error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n+ --> src/main.rs:6:11\n+  |\n+6 |     foo::<str>(\"\".to_string());\n+  |           ^^^ explicit generic argument not allowed\n+\n+```\n+\n+However it would compile if `explicit_generic_args_with_impl_trait` is enabled.\n+\n+Note that the synthetic type parameters from `impl Trait` are still implicit and you\n+cannot explicitly specify these:\n+\n+```rust,compile_fail\n+#![feature(explicit_generic_args_with_impl_trait)]\n+\n+fn foo<T: ?Sized>(_f: impl AsRef<T>) {}\n+fn bar<T: ?Sized, F: AsRef<T>>(_f: F) {}\n+\n+fn main() {\n+    bar::<str, _>(\"\".to_string()); // Okay\n+    bar::<str, String>(\"\".to_string()); // Okay\n+\n+    foo::<str>(\"\".to_string()); // Okay\n+    foo::<str, String>(\"\".to_string()); // Error, you cannot specify `impl Trait` explicitly\n+}\n+```\n \"##,\n     },\n     Lint {\n@@ -3030,35 +3163,34 @@ assembly to `fn` bodies only, you might try the\n \"##,\n     },\n     Lint {\n-        label: \"impl_trait_in_bindings\",\n-        description: r##\"# `impl_trait_in_bindings`\n+        label: \"half_open_range_patterns\",\n+        description: r##\"# `half_open_range_patterns`\n \n-The tracking issue for this feature is: [#63065]\n+The tracking issue for this feature is: [#67264]\n+It is part of the `#![exclusive_range_pattern]` feature,\n+tracked at [#37854].\n \n-[#63065]: https://github.com/rust-lang/rust/issues/63065\n-\n-------------------------\n+[#67264]: https://github.com/rust-lang/rust/issues/67264\n+[#37854]: https://github.com/rust-lang/rust/issues/37854\n+-----\n \n-The `impl_trait_in_bindings` feature gate lets you use `impl Trait` syntax in\n-`let`, `static`, and `const` bindings.\n+The `half_open_range_patterns` feature allows RangeTo patterns\n+(`..10`) to be used in appropriate pattern matching contexts.\n+This requires also enabling the `exclusive_range_pattern` feature.\n \n-A simple example is:\n+It also enabled RangeFrom patterns but that has since been\n+stabilized.\n \n ```rust\n-#![feature(impl_trait_in_bindings)]\n-\n-use std::fmt::Debug;\n-\n-fn main() {\n-    let a: impl Debug + Clone = 42;\n-    let b = a.clone();\n-    println!(\"{:?}\", b); // prints `42`\n-}\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n+    let x = 5;\n+    match x {\n+        ..0 => println!(\"negative!\"), // \"RangeTo\" pattern. Unstable.\n+        0 => println!(\"zero!\"),\n+        1.. => println!(\"positive!\"), // \"RangeFrom\" pattern. Stable.\n+    }\n ```\n-\n-Note however that because the types of `a` and `b` are opaque in the above\n-example, calling inherent methods or methods outside of the specified traits\n-(e.g., `a.abs()` or `b.abs()`) is not allowed, and yields an error.\n \"##,\n     },\n     Lint {\n@@ -4082,9 +4214,7 @@ The tracking issue for this feature is: [#29597]\n \n \n This feature is part of \"compiler plugins.\" It will often be used with the\n-[`plugin_registrar`] and `rustc_private` features.\n-\n-[`plugin_registrar`]: plugin-registrar.md\n+`rustc_private` feature.\n \n ------------------------\n \n@@ -4115,7 +4245,6 @@ additional checks for code style, safety, etc. Now let's write a plugin\n that warns about any item named `lintme`.\n \n ```rust,ignore (requires-stage-2)\n-#![feature(plugin_registrar)]\n #![feature(box_syntax, rustc_private)]\n \n extern crate rustc_ast;\n@@ -4144,8 +4273,8 @@ impl EarlyLintPass for Pass {\n     }\n }\n \n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n+#[no_mangle]\n+fn __rustc_plugin_registrar(reg: &mut Registry) {\n     reg.lint_store.register_lints(&[&TEST_LINT]);\n     reg.lint_store.register_early_pass(|| box Pass);\n }\n@@ -4193,23 +4322,6 @@ conversion.\n \n You can run `rustc -W help foo.rs` to see a list of lints known to `rustc`,\n including those provided by plugins loaded by `foo.rs`.\n-\"##,\n-    },\n-    Lint {\n-        label: \"plugin_registrar\",\n-        description: r##\"# `plugin_registrar`\n-\n-The tracking issue for this feature is: [#29597]\n-\n-[#29597]: https://github.com/rust-lang/rust/issues/29597\n-\n-This feature is part of \"compiler plugins.\" It will often be used with the\n-[`plugin`] and `rustc_private` features as well. For more details, see\n-their docs.\n-\n-[`plugin`]: plugin.md\n-\n-------------------------\n \"##,\n     },\n     Lint {\n@@ -4237,6 +4349,44 @@ The tracking issue for this feature is: [#42524](https://github.com/rust-lang/ru\n This feature is internal to the Rust compiler and is not intended for general use.\n \n ------------------------\n+\"##,\n+    },\n+    Lint {\n+        label: \"raw_dylib\",\n+        description: r##\"# `raw_dylib`\n+\n+The tracking issue for this feature is: [#58713]\n+\n+[#58713]: https://github.com/rust-lang/rust/issues/58713\n+\n+------------------------\n+\n+The `raw_dylib` feature allows you to link against the implementations of functions in an `extern`\n+block without, on Windows, linking against an import library.\n+\n+```rust,ignore (partial-example)\n+#![feature(raw_dylib)]\n+\n+#[link(name=\"library\", kind=\"raw-dylib\")]\n+extern {\n+    fn extern_function(x: i32);\n+}\n+\n+fn main() {\n+    unsafe {\n+        extern_function(14);\n+    }\n+}\n+```\n+\n+## Limitations\n+\n+Currently, this feature is only supported on `-windows-msvc` targets.  Non-Windows platforms don't have import\n+libraries, and an incompatibility between LLVM and the BFD linker means that it is not currently supported on\n+`-windows-gnu` targets.\n+\n+On the `i686-pc-windows-msvc` target, this feature supports only the `cdecl`, `stdcall`, `system`, and `fastcall`\n+calling conventions.\n \"##,\n     },\n     Lint {\n@@ -4595,6 +4745,37 @@ pub fn main() {\n     println!(\"{:?}\", b);\n }\n ```\n+\"##,\n+    },\n+    Lint {\n+        label: \"trait_upcasting\",\n+        description: r##\"# `trait_upcasting`\n+\n+The tracking issue for this feature is: [#65991]\n+\n+[#65991]: https://github.com/rust-lang/rust/issues/65991\n+\n+------------------------\n+\n+The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\n+trait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\n+so long as `Bar: Foo`.\n+\n+```rust,edition2018\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo {}\n+\n+trait Bar: Foo {}\n+\n+impl Foo for i32 {}\n+\n+impl<T: Foo + ?Sized> Bar for T {}\n+\n+let bar: &dyn Bar = &123;\n+let foo: &dyn Foo = bar;\n+```\n \"##,\n     },\n     Lint {\n@@ -5016,10 +5197,6 @@ checked.\"##,\n         label: \"clippy::almost_swapped\",\n         description: r##\"Checks for `foo = bar; bar = foo` sequences.\"##,\n     },\n-    Lint {\n-        label: \"clippy::append_instead_of_extend\",\n-        description: r##\"Checks for occurrences where one vector gets extended instead of append\"##,\n-    },\n     Lint {\n         label: \"clippy::approx_constant\",\n         description: r##\"Checks for floating point literals that approximate\n@@ -5127,8 +5304,8 @@ contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.) has been borrowed directly.\"##,\n Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\"##,\n     },\n     Lint {\n-        label: \"clippy::box_vec\",\n-        description: r##\"Checks for use of `Box<Vec<_>>` anywhere in the code.\n+        label: \"clippy::box_collection\",\n+        description: r##\"Checks for use of `Box<T>` where T is a collection such as Vec anywhere in the code.\n Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\"##,\n     },\n     Lint {\n@@ -5342,6 +5519,10 @@ field that is not a valid semantic version.\"##,\n         label: \"clippy::deref_addrof\",\n         description: r##\"Checks for usage of `*&` and `*&mut` in expressions.\"##,\n     },\n+    Lint {\n+        label: \"clippy::derivable_impls\",\n+        description: r##\"Detects manual `std::default::Default` implementations that are identical to a derived implementation.\"##,\n+    },\n     Lint {\n         label: \"clippy::derive_hash_xor_eq\",\n         description: r##\"Checks for deriving `Hash` but implementing `PartialEq`\n@@ -5460,6 +5641,10 @@ by the same characters.\"##,\n bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n `||`, `&`, `|`, `^`, `-` and `/`).\"##,\n     },\n+    Lint {\n+        label: \"clippy::equatable_if_let\",\n+        description: r##\"Checks for pattern matchings that can be expressed using equality.\"##,\n+    },\n     Lint {\n         label: \"clippy::erasing_op\",\n         description: r##\"Checks for erasing operations, e.g., `x * 0`.\"##,\n@@ -5530,6 +5715,10 @@ replaced with `(e)print!()` / `(e)println!()`\"##,\n         label: \"clippy::extend_from_slice\",\n         description: r##\"Nothing. This lint has been deprecated.\"##,\n     },\n+    Lint {\n+        label: \"clippy::extend_with_drain\",\n+        description: r##\"Checks for occurrences where one vector gets extended instead of append\"##,\n+    },\n     Lint {\n         label: \"clippy::extra_unused_lifetimes\",\n         description: r##\"Checks for lifetimes in generics that are never used\n@@ -5605,6 +5794,10 @@ bools in function definitions.\"##,\n         label: \"clippy::fn_to_numeric_cast\",\n         description: r##\"Checks for casts of function pointers to something other than usize\"##,\n     },\n+    Lint {\n+        label: \"clippy::fn_to_numeric_cast_any\",\n+        description: r##\"Checks for casts of a function pointer to any integer type.\"##,\n+    },\n     Lint {\n         label: \"clippy::fn_to_numeric_cast_with_truncation\",\n         description: r##\"Checks for casts of a function pointer to a numeric type not wide enough to\n@@ -5672,10 +5865,6 @@ with lock calls in any of the else blocks.\"##,\n         label: \"clippy::if_let_redundant_pattern_matching\",\n         description: r##\"Nothing. This lint has been deprecated.\"##,\n     },\n-    Lint {\n-        label: \"clippy::if_let_some_result\",\n-        description: r##\"* Checks for unnecessary `ok()` in if let.\"##,\n-    },\n     Lint {\n         label: \"clippy::if_not_else\",\n         description: r##\"Checks for usage of `!` or `!=` in an if condition with an\n@@ -5686,6 +5875,10 @@ else branch.\"##,\n         description: r##\"Checks for `if/else` with the same body as the *then* part\n and the *else* part.\"##,\n     },\n+    Lint {\n+        label: \"clippy::if_then_panic\",\n+        description: r##\"Detects `if`-then-`panic!` that can be replaced with `assert!`.\"##,\n+    },\n     Lint {\n         label: \"clippy::if_then_some_else_none\",\n         description: r##\"Checks for if-else that could be written to `bool::then`.\"##,\n@@ -5808,12 +6001,6 @@ attempted.\"##,\n         label: \"clippy::into_iter_on_ref\",\n         description: r##\"Checks for `into_iter` calls on references which should be replaced by `iter`\n or `iter_mut`.\"##,\n-    },\n-    Lint {\n-        label: \"clippy::invalid_atomic_ordering\",\n-        description: r##\"Checks for usage of invalid atomic\n-ordering in atomic loads/stores/exchanges/updates and\n-memory fences.\"##,\n     },\n     Lint {\n         label: \"clippy::invalid_null_ptr_usage\",\n@@ -5853,10 +6040,14 @@ create a `Vec`.\"##,\n         label: \"clippy::iter_next_slice\",\n         description: r##\"Checks for usage of `iter().next()` on a Slice or an Array\"##,\n     },\n+    Lint {\n+        label: \"clippy::iter_not_returning_iterator\",\n+        description: r##\"Detects methods named `iter` or `iter_mut` that do not have a return type that implements `Iterator`.\"##,\n+    },\n     Lint {\n         label: \"clippy::iter_nth\",\n         description: r##\"Checks for use of `.iter().nth()` (and the related\n-`.iter_mut().nth()`) on standard library types with O(1) element access.\"##,\n+`.iter_mut().nth()`) on standard library types with *O*(1) element access.\"##,\n     },\n     Lint {\n         label: \"clippy::iter_nth_zero\",\n@@ -6001,6 +6192,26 @@ be more readably expressed as `(3..8).contains(x)`.\"##,\n         label: \"clippy::manual_saturating_arithmetic\",\n         description: r##\"Checks for `.checked_add/sub(x).unwrap_or(MAX/MIN)`.\"##,\n     },\n+    Lint {\n+        label: \"clippy::manual_split_once\",\n+        description: r##\"**What it does:** Checks for usages of `str::splitn(2, _)`\n+\n+**Why is this bad?** `split_once` is both clearer in intent and slightly more efficient.\n+\n+**Known problems:** None.\n+\n+**Example:**\n+\n+```rust\n+// Bad\n+ let (key, value) = _.splitn(2, '=').next_tuple()?;\n+ let value = _.splitn(2, '=').nth(1)?;\n+\n+// Good\n+let (key, value) = _.split_once('=')?;\n+let value = _.split_once('=')?.1;\n+```\"##,\n+    },\n     Lint {\n         label: \"clippy::manual_str_repeat\",\n         description: r##\"Checks for manual implementations of `str::repeat`\"##,\n@@ -6081,6 +6292,10 @@ suggests to replace the expression with an `if...else` block.\"##,\n suggesting to remove the reference and deref the matched expression\n instead. It also checks for `if let &foo = bar` blocks.\"##,\n     },\n+    Lint {\n+        label: \"clippy::match_result_ok\",\n+        description: r##\"Checks for unnecessary `ok()` in `while let`.\"##,\n+    },\n     Lint {\n         label: \"clippy::match_same_arms\",\n         description: r##\"Checks for `match` with identical arm bodies.\"##,\n@@ -6186,6 +6401,10 @@ unsafe functions and warns if there is no `# Safety` section.\"##,\n         description: r##\"Warns on hexadecimal literals with mixed-case letter\n digits.\"##,\n     },\n+    Lint {\n+        label: \"clippy::mod_module_files\",\n+        description: r##\"Checks that module layout uses only self named module files, bans mod.rs files.\"##,\n+    },\n     Lint {\n         label: \"clippy::module_inception\",\n         description: r##\"Checks for modules that have the same name as their\n@@ -6307,6 +6526,11 @@ rearrangement of code can make the code easier to understand.\"##,\n         label: \"clippy::needless_lifetimes\",\n         description: r##\"Checks for lifetime annotations which can be removed by\n relying on lifetime elision.\"##,\n+    },\n+    Lint {\n+        label: \"clippy::needless_option_as_deref\",\n+        description: r##\"Checks for no-op uses of Option::{as_deref,as_deref_mut},\n+for example, `Option<&T>::as_deref()` returns the same type.\"##,\n     },\n     Lint {\n         label: \"clippy::needless_pass_by_value\",\n@@ -6344,6 +6568,10 @@ This lint is not applied to structs marked with\n         label: \"clippy::neg_multiply\",\n         description: r##\"Checks for multiplication by -1 as a form of negation.\"##,\n     },\n+    Lint {\n+        label: \"clippy::negative_feature_names\",\n+        description: r##\"Checks for negative feature names with prefix `no-` or `not-`\"##,\n+    },\n     Lint {\n         label: \"clippy::never_loop\",\n         description: r##\"Checks for loops that will always `break`, `return` or\n@@ -6371,6 +6599,10 @@ implementation of\n         label: \"clippy::non_octal_unix_permissions\",\n         description: r##\"Checks for non-octal values used to set Unix file permissions.\"##,\n     },\n+    Lint {\n+        label: \"clippy::non_send_fields_in_send_ty\",\n+        description: r##\"Warns about fields in struct implementing `Send` that are neither `Send` nor `Copy`.\"##,\n+    },\n     Lint {\n         label: \"clippy::nonminimal_bool\",\n         description: r##\"Checks for boolean expressions that can be written more\n@@ -6603,6 +6835,10 @@ argument and can be replaced by referencing the method directly.\"##,\n         label: \"clippy::redundant_else\",\n         description: r##\"Checks for `else` blocks that can be removed without changing semantics.\"##,\n     },\n+    Lint {\n+        label: \"clippy::redundant_feature_names\",\n+        description: r##\"Checks for feature names with prefix `use-`, `with-` or suffix `-support`\"##,\n+    },\n     Lint {\n         label: \"clippy::redundant_field_names\",\n         description: r##\"Checks for fields in struct literals where shorthands\n@@ -6653,7 +6889,10 @@ auto dereference.\"##,\n         description: r##\"Checks for usage of `.repeat(1)` and suggest the following method for each types.\n - `.to_string()` for `str`\n - `.clone()` for `String`\n-- `.to_vec()` for `slice`\"##,\n+- `.to_vec()` for `slice`\n+\n+The lint will evaluate constant expressions and values as arguments of `.repeat(..)` and emit a message if\n+they are equivalent to `1`. (Related discussion in [rust-clippy#7306](https://github.com/rust-lang/rust-clippy/issues/7306))\"##,\n     },\n     Lint {\n         label: \"clippy::replace_consts\",\n@@ -6691,6 +6930,11 @@ are constant and `x` is greater or equal to `y`.\"##,\n         label: \"clippy::same_item_push\",\n         description: r##\"Checks whether a for loop is being used to push a constant\n value into a Vec.\"##,\n+    },\n+    Lint {\n+        label: \"clippy::same_name_method\",\n+        description: r##\"It lints if a struct has two method with same time:\n+one from a trait, another not from trait.\"##,\n     },\n     Lint {\n         label: \"clippy::search_is_some\",\n@@ -6701,6 +6945,14 @@ value into a Vec.\"##,\n         label: \"clippy::self_assignment\",\n         description: r##\"Checks for explicit self-assignments.\"##,\n     },\n+    Lint {\n+        label: \"clippy::self_named_constructors\",\n+        description: r##\"Warns when constructors have the same name as their types.\"##,\n+    },\n+    Lint {\n+        label: \"clippy::self_named_module_files\",\n+        description: r##\"Checks that module layout uses only mod.rs files.\"##,\n+    },\n     Lint {\n         label: \"clippy::semicolon_if_nothing_returned\",\n         description: r##\"Looks for blocks of expressions and fires if the last expression returns\n@@ -6723,7 +6975,7 @@ scope, while just changing reference level or mutability.\"##,\n     Lint {\n         label: \"clippy::shadow_unrelated\",\n         description: r##\"Checks for bindings that shadow other bindings already in\n-scope, either without a initialization or with one that does not even use\n+scope, either without an initialization or with one that does not even use\n the original value.\"##,\n     },\n     Lint {\n@@ -6828,6 +7080,11 @@ that contain only ASCII characters.\"##,\n         label: \"clippy::string_to_string\",\n         description: r##\"This lint checks for `.to_string()` method calls on values of type `String`.\"##,\n     },\n+    Lint {\n+        label: \"clippy::strlen_on_c_strings\",\n+        description: r##\"Checks for usage of `libc::strlen` on a `CString` or `CStr` value,\n+and suggest calling `as_bytes().len()` or `to_bytes().len()` respectively instead.\"##,\n+    },\n     Lint {\n         label: \"clippy::struct_excessive_bools\",\n         description: r##\"Checks for excessive\n@@ -6975,6 +7232,12 @@ declarations above a certain complexity threshold.\"##,\n         label: \"clippy::type_repetition_in_bounds\",\n         description: r##\"This lint warns about unnecessary type repetitions in trait bounds\"##,\n     },\n+    Lint {\n+        label: \"clippy::undocumented_unsafe_blocks\",\n+        description: r##\"Checks for `unsafe` blocks without a `// Safety: ` comment\n+explaining why the unsafe operations performed inside\n+the block are safe.\"##,\n+    },\n     Lint {\n         label: \"clippy::undropped_manually_drops\",\n         description: r##\"Prevents the safe `std::mem::drop` function from being called on `std::mem::ManuallyDrop`.\"##,\n@@ -7155,6 +7418,11 @@ by nibble or byte.\"##,\n         label: \"clippy::unwrap_in_result\",\n         description: r##\"Checks for functions of type Result that contain `expect()` or `unwrap()`\"##,\n     },\n+    Lint {\n+        label: \"clippy::unwrap_or_else_default\",\n+        description: r##\"Checks for usages of `_.unwrap_or_else(Default::default)` on `Option` and\n+`Result` values.\"##,\n+    },\n     Lint {\n         label: \"clippy::unwrap_used\",\n         description: r##\"Checks for `.unwrap()` calls on `Option`s and on `Result`s.\"##,\n@@ -7315,6 +7583,8 @@ Clippy can not tell if a type that implements a trait is `Copy` or not.\n The method signature is controlled by the trait and often `&self` is required for all types that implement the trait\n (see e.g. the `std::string::ToString` trait).\n \n+Clippy allows `Pin<&Self>` and `Pin<&mut Self>` if `&self` and `&mut self` is required.\n+\n Please find more info here:\n https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\"##,\n     },"}, {"sha": "eaa9291fce47e1a501baae2bc9d6a5b1564d216d", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d71a4f40d9f82bf4da8012568ddad561613476c7/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d71a4f40d9f82bf4da8012568ddad561613476c7/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=d71a4f40d9f82bf4da8012568ddad561613476c7", "patch": "@@ -165,5 +165,5 @@ pub enum SymbolKind {\n \n #[cfg(test)]\n mod tests {\n-    mod sourcegen_lint_completions;\n+    mod sourcegen_lints;\n }"}, {"sha": "ed3ac7203b9f057b12dfa81cf5c873f562ac336e", "filename": "crates/ide_db/src/tests/sourcegen_lint_completions.rs", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c2948b3b8861dc479d84b3b29a284a176d4ed/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lint_completions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c2948b3b8861dc479d84b3b29a284a176d4ed/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lint_completions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lint_completions.rs?ref=ed7c2948b3b8861dc479d84b3b29a284a176d4ed", "patch": "@@ -1,167 +0,0 @@\n-//! Generates descriptors structure for unstable feature from Unstable Book\n-use std::{borrow::Cow, fs, path::Path};\n-\n-use stdx::format_to;\n-use test_utils::project_root;\n-use xshell::cmd;\n-\n-/// This clones rustc repo, and so is not worth to keep up-to-date. We update\n-/// manually by un-ignoring the test from time to time.\n-#[test]\n-#[ignore]\n-fn sourcegen_lint_completions() {\n-    let rust_repo = project_root().join(\"./target/rust\");\n-    if !rust_repo.exists() {\n-        cmd!(\"git clone --depth=1 https://github.com/rust-lang/rust {rust_repo}\").run().unwrap();\n-    }\n-\n-    let mut contents = r\"\n-pub struct Lint {\n-    pub label: &'static str,\n-    pub description: &'static str,\n-}\n-\"\n-    .to_string();\n-    generate_lint_descriptor(&mut contents);\n-    contents.push('\\n');\n-\n-    generate_feature_descriptor(&mut contents, &rust_repo.join(\"src/doc/unstable-book/src\"));\n-    contents.push('\\n');\n-\n-    let lints_json = project_root().join(\"./target/clippy_lints.json\");\n-    cmd!(\"curl https://rust-lang.github.io/rust-clippy/master/lints.json --output {lints_json}\")\n-        .run()\n-        .unwrap();\n-    generate_descriptor_clippy(&mut contents, &lints_json);\n-\n-    let contents =\n-        sourcegen::add_preamble(\"sourcegen_lint_completions\", sourcegen::reformat(contents));\n-\n-    let destination = project_root().join(\"crates/ide_db/src/helpers/generated_lints.rs\");\n-    sourcegen::ensure_file_contents(destination.as_path(), &contents);\n-}\n-\n-fn generate_lint_descriptor(buf: &mut String) {\n-    let stdout = cmd!(\"rustc -W help\").read().unwrap();\n-    let start_lints = stdout.find(\"----  -------  -------\").unwrap();\n-    let start_lint_groups = stdout.find(\"----  ---------\").unwrap();\n-    let end_lints = stdout.find(\"Lint groups provided by rustc:\").unwrap();\n-    let end_lint_groups = stdout\n-        .find(\"Lint tools like Clippy can provide additional lints and lint groups.\")\n-        .unwrap();\n-    buf.push_str(r#\"pub const DEFAULT_LINTS: &[Lint] = &[\"#);\n-    buf.push('\\n');\n-    let mut lints = stdout[start_lints..end_lints]\n-        .lines()\n-        .skip(1)\n-        .filter(|l| !l.is_empty())\n-        .map(|line| {\n-            let (name, rest) = line.trim().split_once(char::is_whitespace).unwrap();\n-            let (_default_level, description) =\n-                rest.trim().split_once(char::is_whitespace).unwrap();\n-            (name.trim(), Cow::Borrowed(description.trim()))\n-        })\n-        .collect::<Vec<_>>();\n-    lints.extend(\n-        stdout[start_lint_groups..end_lint_groups].lines().skip(1).filter(|l| !l.is_empty()).map(\n-            |line| {\n-                let (name, lints) = line.trim().split_once(char::is_whitespace).unwrap();\n-                (name.trim(), format!(\"lint group for: {}\", lints.trim()).into())\n-            },\n-        ),\n-    );\n-\n-    lints.sort_by(|(ident, _), (ident2, _)| ident.cmp(ident2));\n-    lints.into_iter().for_each(|(name, description)| {\n-        push_lint_completion(buf, &name.replace(\"-\", \"_\"), &description)\n-    });\n-    buf.push_str(\"];\\n\");\n-}\n-\n-fn generate_feature_descriptor(buf: &mut String, src_dir: &Path) {\n-    let mut features = [\"language-features\", \"library-features\"]\n-        .iter()\n-        .flat_map(|it| sourcegen::list_files(&src_dir.join(it)))\n-        .filter(|path| {\n-            // Get all `.md ` files\n-            path.extension().unwrap_or_default().to_str().unwrap_or_default() == \"md\"\n-        })\n-        .map(|path| {\n-            let feature_ident = path.file_stem().unwrap().to_str().unwrap().replace(\"-\", \"_\");\n-            let doc = fs::read_to_string(path).unwrap();\n-            (feature_ident, doc)\n-        })\n-        .collect::<Vec<_>>();\n-    features.sort_by(|(feature_ident, _), (feature_ident2, _)| feature_ident.cmp(feature_ident2));\n-\n-    buf.push_str(r#\"pub const FEATURES: &[Lint] = &[\"#);\n-    for (feature_ident, doc) in features.into_iter() {\n-        push_lint_completion(buf, &feature_ident, &doc)\n-    }\n-    buf.push('\\n');\n-    buf.push_str(\"];\\n\");\n-}\n-\n-#[derive(Default)]\n-struct ClippyLint {\n-    help: String,\n-    id: String,\n-}\n-\n-fn unescape(s: &str) -> String {\n-    s.replace(r#\"\\\"\"#, \"\").replace(r#\"\\n\"#, \"\\n\").replace(r#\"\\r\"#, \"\")\n-}\n-\n-fn generate_descriptor_clippy(buf: &mut String, path: &Path) {\n-    let file_content = std::fs::read_to_string(path).unwrap();\n-    let mut clippy_lints: Vec<ClippyLint> = Vec::new();\n-\n-    for line in file_content.lines().map(|line| line.trim()) {\n-        if line.starts_with(r#\"\"id\":\"#) {\n-            let clippy_lint = ClippyLint {\n-                id: line\n-                    .strip_prefix(r#\"\"id\": \"\"#)\n-                    .expect(\"should be prefixed by id\")\n-                    .strip_suffix(r#\"\",\"#)\n-                    .expect(\"should be suffixed by comma\")\n-                    .into(),\n-                help: String::new(),\n-            };\n-            clippy_lints.push(clippy_lint)\n-        } else if line.starts_with(r#\"\"What it does\":\"#) {\n-            // Typical line to strip: \"What is doest\": \"Here is my useful content\",\n-            let prefix_to_strip = r#\"\"What it does\": \"\"#;\n-            let suffix_to_strip = r#\"\",\"#;\n-\n-            let clippy_lint = clippy_lints.last_mut().expect(\"clippy lint must already exist\");\n-            clippy_lint.help = line\n-                .strip_prefix(prefix_to_strip)\n-                .expect(\"should be prefixed by what it does\")\n-                .strip_suffix(suffix_to_strip)\n-                .map(unescape)\n-                .expect(\"should be suffixed by comma\");\n-        }\n-    }\n-    clippy_lints.sort_by(|lint, lint2| lint.id.cmp(&lint2.id));\n-\n-    buf.push_str(r#\"pub const CLIPPY_LINTS: &[Lint] = &[\"#);\n-    buf.push('\\n');\n-    for clippy_lint in clippy_lints.into_iter() {\n-        let lint_ident = format!(\"clippy::{}\", clippy_lint.id);\n-        let doc = clippy_lint.help;\n-        push_lint_completion(buf, &lint_ident, &doc);\n-    }\n-    buf.push_str(\"];\\n\");\n-}\n-\n-fn push_lint_completion(buf: &mut String, label: &str, description: &str) {\n-    format_to!(\n-        buf,\n-        r###\"    Lint {{\n-        label: \"{}\",\n-        description: r##\"{}\"##\n-    }},\"###,\n-        label,\n-        description\n-    );\n-}"}, {"sha": "96ddce54ba9a112b4304ed3bda4ded98ca56d647", "filename": "crates/ide_db/src/tests/sourcegen_lints.rs", "status": "renamed", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d71a4f40d9f82bf4da8012568ddad561613476c7/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d71a4f40d9f82bf4da8012568ddad561613476c7/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lints.rs?ref=d71a4f40d9f82bf4da8012568ddad561613476c7", "patch": "@@ -15,13 +15,15 @@ fn sourcegen_lint_completions() {\n         cmd!(\"git clone --depth=1 https://github.com/rust-lang/rust {rust_repo}\").run().unwrap();\n     }\n \n-    let mut contents = r\"\n+    let mut contents = String::from(\n+        r\"\n pub struct Lint {\n     pub label: &'static str,\n     pub description: &'static str,\n }\n-\"\n-    .to_string();\n+\",\n+    );\n+\n     generate_lint_descriptor(&mut contents);\n     contents.push('\\n');\n \n@@ -34,8 +36,7 @@ pub struct Lint {\n         .unwrap();\n     generate_descriptor_clippy(&mut contents, &lints_json);\n \n-    let contents =\n-        sourcegen::add_preamble(\"sourcegen_lint_completions\", sourcegen::reformat(contents));\n+    let contents = sourcegen::add_preamble(\"sourcegen_lints\", sourcegen::reformat(contents));\n \n     let destination = project_root().join(\"crates/ide_db/src/helpers/generated_lints.rs\");\n     sourcegen::ensure_file_contents(destination.as_path(), &contents);\n@@ -117,29 +118,23 @@ fn generate_descriptor_clippy(buf: &mut String, path: &Path) {\n     let mut clippy_lints: Vec<ClippyLint> = Vec::new();\n \n     for line in file_content.lines().map(|line| line.trim()) {\n-        if line.starts_with(r#\"\"id\":\"#) {\n+        if let Some(line) = line.strip_prefix(r#\"\"id\": \"\"#) {\n             let clippy_lint = ClippyLint {\n-                id: line\n-                    .strip_prefix(r#\"\"id\": \"\"#)\n-                    .expect(\"should be prefixed by id\")\n-                    .strip_suffix(r#\"\",\"#)\n-                    .expect(\"should be suffixed by comma\")\n-                    .into(),\n+                id: line.strip_suffix(r#\"\",\"#).expect(\"should be suffixed by comma\").into(),\n                 help: String::new(),\n             };\n             clippy_lints.push(clippy_lint)\n-        } else if line.starts_with(r#\"\"What it does\":\"#) {\n-            // Typical line to strip: \"What is doest\": \"Here is my useful content\",\n-            let prefix_to_strip = r#\"\"What it does\": \"\"#;\n-            let suffix_to_strip = r#\"\",\"#;\n+        } else if let Some(line) = line.strip_prefix(r#\"\"docs\": \"\"#) {\n+            let prefix_to_strip = r#\" ### What it does\"#;\n+            // FIXME: replace unwrap_or with expect again, currently there is one lint that uses a different format in the json...\n+            let line = line.strip_prefix(prefix_to_strip).unwrap_or(line);\n+            // Only take the description, any more than this is a lot of additional data we would embed into the exe\n+            // which seems unnecessary\n+            let up_to = line.find(r#\"###\"#).expect(\"no second section found?\");\n+            let line = &line[..up_to];\n \n             let clippy_lint = clippy_lints.last_mut().expect(\"clippy lint must already exist\");\n-            clippy_lint.help = line\n-                .strip_prefix(prefix_to_strip)\n-                .expect(\"should be prefixed by what it does\")\n-                .strip_suffix(suffix_to_strip)\n-                .map(unescape)\n-                .expect(\"should be suffixed by comma\");\n+            clippy_lint.help = unescape(line).trim().to_string();\n         }\n     }\n     clippy_lints.sort_by(|lint, lint2| lint.id.cmp(&lint2.id));", "previous_filename": "crates/ide_completion/src/tests/sourcegen.rs"}]}