{"sha": "b5eae9c44d713779a08e6db352088d45cad3e9b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZWFlOWM0NGQ3MTM3NzlhMDhlNmRiMzUyMDg4ZDQ1Y2FkM2U5YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-01T06:54:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-01T06:54:14Z"}, "message": "Auto merge of #74373 - lcnr:array_chunks, r=withoutboats\n\nadd `slice::array_chunks` to std\n\nNow that #74113 has landed, these methods are suddenly usable. A rebirth of #72334\n\nTests are directly copied from `chunks_exact` and some additional tests for type inference.\n\nr? @withoutboats as you are both part of t-libs and working on const generics. closes #60735", "tree": {"sha": "f421054cf69e97a6534f095192700dc830d84618", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f421054cf69e97a6534f095192700dc830d84618"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5eae9c44d713779a08e6db352088d45cad3e9b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5eae9c44d713779a08e6db352088d45cad3e9b6", "html_url": "https://github.com/rust-lang/rust/commit/b5eae9c44d713779a08e6db352088d45cad3e9b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5eae9c44d713779a08e6db352088d45cad3e9b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18e2a891999e66d856ea13db879e93076de9e237", "url": "https://api.github.com/repos/rust-lang/rust/commits/18e2a891999e66d856ea13db879e93076de9e237", "html_url": "https://github.com/rust-lang/rust/commit/18e2a891999e66d856ea13db879e93076de9e237"}, {"sha": "d51b71a35a816f4be56f77d1d1a6f4095352649e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d51b71a35a816f4be56f77d1d1a6f4095352649e", "html_url": "https://github.com/rust-lang/rust/commit/d51b71a35a816f4be56f77d1d1a6f4095352649e"}], "stats": {"total": 248, "additions": 243, "deletions": 5}, "files": [{"sha": "097db30d634cce9d154a045f00acb38f6dba558a", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=b5eae9c44d713779a08e6db352088d45cad3e9b6", "patch": "@@ -75,6 +75,7 @@\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n #![feature(allocator_api)]\n+#![feature(array_chunks)]\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]"}, {"sha": "b791c775548cda7f8f81f013ad0f38e566e493da", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=b5eae9c44d713779a08e6db352088d45cad3e9b6", "patch": "@@ -95,6 +95,8 @@ use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub use core::slice::ArrayChunks;\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use core::slice::SliceIndex;\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]"}, {"sha": "93608a1ce4864c8180371146e81e05c7b23c979e", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 148, "deletions": 5, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=b5eae9c44d713779a08e6db352088d45cad3e9b6", "patch": "@@ -680,7 +680,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<'_, T> {\n-        assert!(size != 0);\n+        assert_ne!(size, 0);\n         Windows { v: self, size }\n     }\n \n@@ -714,7 +714,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n-        assert!(chunk_size != 0);\n+        assert_ne!(chunk_size, 0);\n         Chunks { v: self, chunk_size }\n     }\n \n@@ -752,7 +752,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<'_, T> {\n-        assert!(chunk_size != 0);\n+        assert_ne!(chunk_size, 0);\n         ChunksMut { v: self, chunk_size }\n     }\n \n@@ -789,7 +789,7 @@ impl<T> [T] {\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n-        assert!(chunk_size != 0);\n+        assert_ne!(chunk_size, 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at(len);\n@@ -834,13 +834,52 @@ impl<T> [T] {\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n-        assert!(chunk_size != 0);\n+        assert_ne!(chunk_size, 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at_mut(len);\n         ChunksExactMut { v: fst, rem: snd, chunk_size }\n     }\n \n+    /// Returns an iterator over `N` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// The chunks are slices and do not overlap. If `N` does not divide the length of the\n+    /// slice, then the last up to `N-1` elements will be omitted and can be retrieved\n+    /// from the `remainder` function of the iterator.\n+    ///\n+    /// This method is the const generic equivalent of [`chunks_exact`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n+    /// error before this method gets stabilized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_chunks)]\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.array_chunks();\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert!(iter.next().is_none());\n+    /// assert_eq!(iter.remainder(), &['m']);\n+    /// ```\n+    ///\n+    /// [`chunks_exact`]: #method.chunks_exact\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    #[inline]\n+    pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n+        assert_ne!(N, 0);\n+        let len = self.len() / N;\n+        let (fst, snd) = self.split_at(len * N);\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        let array_slice: &[[T; N]] = unsafe { from_raw_parts(fst.as_ptr().cast(), len) };\n+        ArrayChunks { iter: array_slice.iter(), rem: snd }\n+    }\n+\n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n     /// of the slice.\n     ///\n@@ -5432,6 +5471,110 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     }\n }\n \n+/// An iterator over a slice in (non-overlapping) chunks (`N` elements at a\n+/// time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`array_chunks`] method on [slices].\n+///\n+/// [`array_chunks`]: ../../std/primitive.slice.html#method.array_chunks\n+/// [`remainder`]: ../../std/slice/struct.ArrayChunks.html#method.remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n+    iter: Iter<'a, [T; N]>,\n+    rem: &'a [T],\n+}\n+\n+impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> Clone for ArrayChunks<'_, T, N> {\n+    fn clone(&self) -> Self {\n+        ArrayChunks { iter: self.iter.clone(), rem: self.rem }\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> Iterator for ArrayChunks<'a, T, N> {\n+    type Item = &'a [T; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T; N]> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        self.iter.last()\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunks<'a, T, N> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T; N]> {\n+        self.iter.next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> ExactSizeIterator for ArrayChunks<'_, T, N> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, const N: usize> TrustedLen for ArrayChunks<'_, T, N> {}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n+        unsafe { self.iter.get_unchecked(i) }\n+    }\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n /// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n /// time), starting at the end of the slice.\n ///"}, {"sha": "6b28a815f033ae1889ee36b9c545bacf7b7738a3", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=b5eae9c44d713779a08e6db352088d45cad3e9b6", "patch": "@@ -1,4 +1,5 @@\n #![feature(alloc_layout_extra)]\n+#![feature(array_chunks)]\n #![feature(bool_to_option)]\n #![feature(bound_cloned)]\n #![feature(box_syntax)]"}, {"sha": "27cc7fce1daa35df798e58cdbcb1a0a7c8711cce", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5eae9c44d713779a08e6db352088d45cad3e9b6/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=b5eae9c44d713779a08e6db352088d45cad3e9b6", "patch": "@@ -473,6 +473,97 @@ fn test_chunks_exact_mut_zip() {\n     assert_eq!(v1, [13, 14, 19, 20, 4]);\n }\n \n+#[test]\n+fn test_array_chunks_infer() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, -4];\n+    let c = v.array_chunks();\n+    for &[a, b, c] in c {\n+        assert_eq!(a + b + c, 3);\n+    }\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let total = v2.array_chunks().map(|&[a, b]| a * b).sum::<i32>();\n+    assert_eq!(total, 2 * 3 + 4 * 5);\n+}\n+\n+#[test]\n+fn test_array_chunks_count() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.array_chunks::<3>();\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.array_chunks::<2>();\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &[i32] = &[];\n+    let c3 = v3.array_chunks::<2>();\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_array_chunks_nth() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.array_chunks::<2>();\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.array_chunks::<3>();\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_array_chunks_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.array_chunks::<2>();\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.array_chunks::<3>();\n+    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c3 = v3.array_chunks::<10>();\n+    assert_eq!(c3.nth_back(0), None);\n+}\n+\n+#[test]\n+fn test_array_chunks_last() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.array_chunks::<2>();\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.array_chunks::<2>();\n+    assert_eq!(c2.last().unwrap(), &[2, 3]);\n+}\n+\n+#[test]\n+fn test_array_chunks_remainder() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4];\n+    let c = v.array_chunks::<2>();\n+    assert_eq!(c.remainder(), &[4]);\n+}\n+\n+#[test]\n+fn test_array_chunks_zip() {\n+    let v1: &[i32] = &[0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let res = v1\n+        .array_chunks::<2>()\n+        .zip(v2.array_chunks::<2>())\n+        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n+        .collect::<Vec<_>>();\n+    assert_eq!(res, vec![14, 22]);\n+}\n+\n #[test]\n fn test_rchunks_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];"}]}