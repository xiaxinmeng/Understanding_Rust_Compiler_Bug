{"sha": "488acf86a75c56d30b16822e953c505a9e4901a7", "node_id": "C_kwDOAAsO6NoAKDQ4OGFjZjg2YTc1YzU2ZDMwYjE2ODIyZTk1M2M1MDVhOWU0OTAxYTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-08T15:20:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-08T15:20:33Z"}, "message": "Auto merge of #90639 - matthewjasper:leaf-def-cache, r=cjgillot\n\nAdd a query for resolving an impl item from the trait item\n\nThis makes finding the item in an impl that implements a given trait item a query. This is for a few reasons:\n\n- To slightly improve performance\n- To avoid having to do name resolution during monomorphisation\n- To make it easier to implement potential future features that create anonymous associated items", "tree": {"sha": "eb2b7b5859c272086f867a431d4aa08eb8db5e8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb2b7b5859c272086f867a431d4aa08eb8db5e8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/488acf86a75c56d30b16822e953c505a9e4901a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/488acf86a75c56d30b16822e953c505a9e4901a7", "html_url": "https://github.com/rust-lang/rust/commit/488acf86a75c56d30b16822e953c505a9e4901a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/488acf86a75c56d30b16822e953c505a9e4901a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66f64a441a05cee8d5d701477b43ed851f778f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/66f64a441a05cee8d5d701477b43ed851f778f3a", "html_url": "https://github.com/rust-lang/rust/commit/66f64a441a05cee8d5d701477b43ed851f778f3a"}, {"sha": "9d625bc9724fcaef8cc74055c576dec6457a4b70", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d625bc9724fcaef8cc74055c576dec6457a4b70", "html_url": "https://github.com/rust-lang/rust/commit/9d625bc9724fcaef8cc74055c576dec6457a4b70"}], "stats": {"total": 931, "additions": 483, "deletions": 448}, "files": [{"sha": "5c2752795793bb74c58e76e5bddb60985cbfd208", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -1008,6 +1008,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.get_impl_data(id).constness\n     }\n \n+    fn get_trait_item_def_id(&self, id: DefIndex) -> Option<DefId> {\n+        self.root.tables.trait_item_def_id.get(self, id).map(|d| d.decode(self))\n+    }\n+\n     fn get_coerce_unsized_info(&self, id: DefIndex) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n@@ -1258,6 +1262,16 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n+    fn get_associated_item_def_ids(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [DefId] {\n+        if let Some(children) = self.root.tables.children.get(self, id) {\n+            tcx.arena.alloc_from_iter(\n+                children.decode((self, tcx.sess)).map(|child_index| self.local_def_id(child_index)),\n+            )\n+        } else {\n+            &[]\n+        }\n+    }\n+\n     fn get_associated_item(&self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n@@ -1279,6 +1293,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n             def_id: self.local_def_id(id),\n+            trait_item_def_id: self.get_trait_item_def_id(id),\n             container: container.with_def_id(parent),\n             fn_has_self_parameter: has_self,\n         }"}, {"sha": "804f277e26e12c94661a42413b702c6498ec332b", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -103,12 +103,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         tcx.calculate_dtor(def_id, |_,_| Ok(()))\n     }\n     variances_of => { tcx.arena.alloc_from_iter(cdata.get_item_variances(def_id.index)) }\n-    associated_item_def_ids => {\n-        let mut result = SmallVec::<[_; 8]>::new();\n-        cdata.each_child_of_item(def_id.index,\n-          |child| result.push(child.res.def_id()), tcx.sess);\n-        tcx.arena.alloc_slice(&result)\n-    }\n+    associated_item_def_ids => { cdata.get_associated_item_def_ids(tcx, def_id.index) }\n     associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n     impl_polarity => { cdata.get_impl_polarity(def_id.index) }"}, {"sha": "11a986f0a7c81693ebbd78229bca806bf1fe1bf9", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -1294,6 +1294,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n         self.encode_ident_span(def_id, impl_item.ident);\n         self.encode_item_type(def_id);\n+        if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n+            record!(self.tables.trait_item_def_id[def_id] <- trait_item_def_id);\n+        }\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }"}, {"sha": "fa44cbc2d55e56cb08771b85cfea7dae4c6e4e1b", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -302,6 +302,7 @@ define_tables! {\n     ty: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n     fn_sig: Table<DefIndex, Lazy!(ty::PolyFnSig<'tcx>)>,\n     impl_trait_ref: Table<DefIndex, Lazy!(ty::TraitRef<'tcx>)>,\n+    trait_item_def_id: Table<DefIndex, Lazy<DefId>>,\n     inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n     variances: Table<DefIndex, Lazy<[ty::Variance]>>,\n     generics: Table<DefIndex, Lazy<ty::Generics>>,"}, {"sha": "f1c2be660bc76eef060939c766e8f3a70cde49f8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -630,6 +630,32 @@ rustc_queries! {\n         desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n     }\n \n+    /// Maps from associated items on a trait to the corresponding associated\n+    /// item on the impl specified by `impl_id`.\n+    ///\n+    /// For example, with the following code\n+    ///\n+    /// ```\n+    /// struct Type {}\n+    ///                         // DefId\n+    /// trait Trait {           // trait_id\n+    ///     fn f();             // trait_f\n+    ///     fn g() {}           // trait_g\n+    /// }\n+    ///\n+    /// impl Trait for Type {   // impl_id\n+    ///     fn f() {}           // impl_f\n+    ///     fn g() {}           // impl_g\n+    /// }\n+    /// ```\n+    ///\n+    /// The map returned for `tcx.impl_item_implementor_ids(impl_id)` would be\n+    ///`{ trait_f: impl_f, trait_g: impl_g }`\n+    query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n+        desc { |tcx| \"comparing impl items against trait for {}\", tcx.def_path_str(impl_id) }\n+        storage(ArenaCacheSelector<'tcx>)\n+    }\n+\n     /// Given an `impl_id`, return the trait it implements.\n     /// Return `None` if this is an inherent impl.\n     query impl_trait_ref(impl_id: DefId) -> Option<ty::TraitRef<'tcx>> {"}, {"sha": "087be313b26def87e4806eac693175ff3780ef97", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -4,7 +4,6 @@ use crate::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::{DefId, DefIdMap};\n-use rustc_span::symbol::Ident;\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -75,34 +74,28 @@ pub enum Node {\n     Trait(DefId),\n }\n \n-impl<'tcx> Node {\n+impl Node {\n     pub fn is_from_trait(&self) -> bool {\n         matches!(self, Node::Trait(..))\n     }\n \n-    /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'tcx>) -> impl 'tcx + Iterator<Item = &'tcx ty::AssocItem> {\n-        tcx.associated_items(self.def_id()).in_definition_order()\n-    }\n-\n-    /// Finds an associated item defined in this node.\n+    /// Trys to find the associated item that implements `trait_item_def_id`\n+    /// defined in this node.\n     ///\n     /// If this returns `None`, the item can potentially still be found in\n     /// parents of this node.\n-    pub fn item(\n+    pub fn item<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        trait_item_name: Ident,\n-        trait_item_kind: ty::AssocKind,\n-        trait_def_id: DefId,\n-    ) -> Option<ty::AssocItem> {\n-        tcx.associated_items(self.def_id())\n-            .filter_by_name_unhygienic(trait_item_name.name)\n-            .find(move |impl_item| {\n-                trait_item_kind == impl_item.kind\n-                    && tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id)\n-            })\n-            .copied()\n+        trait_item_def_id: DefId,\n+    ) -> Option<&'tcx ty::AssocItem> {\n+        match *self {\n+            Node::Trait(_) => Some(tcx.associated_item(trait_item_def_id)),\n+            Node::Impl(impl_def_id) => {\n+                let id = tcx.impl_item_implementor_ids(impl_def_id).get(&trait_item_def_id)?;\n+                Some(tcx.associated_item(*id))\n+            }\n+        }\n     }\n \n     pub fn def_id(&self) -> DefId {\n@@ -181,17 +174,11 @@ impl LeafDef {\n impl<'tcx> Ancestors<'tcx> {\n     /// Finds the bottom-most (ie. most specialized) definition of an associated\n     /// item.\n-    pub fn leaf_def(\n-        mut self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_item_name: Ident,\n-        trait_item_kind: ty::AssocKind,\n-    ) -> Option<LeafDef> {\n-        let trait_def_id = self.trait_def_id;\n+    pub fn leaf_def(mut self, tcx: TyCtxt<'tcx>, trait_item_def_id: DefId) -> Option<LeafDef> {\n         let mut finalizing_node = None;\n \n         self.find_map(|node| {\n-            if let Some(item) = node.item(tcx, trait_item_name, trait_item_kind, trait_def_id) {\n+            if let Some(item) = node.item(tcx, trait_item_def_id) {\n                 if finalizing_node.is_none() {\n                     let is_specializable = item.defaultness.is_default()\n                         || tcx.impl_defaultness(node.def_id()).is_default();\n@@ -201,7 +188,7 @@ impl<'tcx> Ancestors<'tcx> {\n                     }\n                 }\n \n-                Some(LeafDef { item, defining_node: node, finalizing_node })\n+                Some(LeafDef { item: *item, defining_node: node, finalizing_node })\n             } else {\n                 // Item not mentioned. This \"finalizes\" any defaulted item provided by an ancestor.\n                 finalizing_node = Some(node);"}, {"sha": "5af4eef40d4366481088f949b588cda45004e859", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -40,6 +40,7 @@ impl AssocItemContainer {\n     }\n }\n \n+/// Information about an associated item\n #[derive(Copy, Clone, Debug, PartialEq, HashStable, Eq, Hash)]\n pub struct AssocItem {\n     pub def_id: DefId,\n@@ -50,6 +51,10 @@ pub struct AssocItem {\n     pub defaultness: hir::Defaultness,\n     pub container: AssocItemContainer,\n \n+    /// If this is an item in an impl of a trait then this is the `DefId` of\n+    /// the associated item on the trait that this implements.\n+    pub trait_item_def_id: Option<DefId>,\n+\n     /// Whether this is a method with an explicit self\n     /// as its first parameter, allowing method calls.\n     pub fn_has_self_parameter: bool,"}, {"sha": "3e06e7f36d419583a02dc03b48488dd8f7a92562", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -1310,10 +1310,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n             if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n-                let overridden_methods: FxHashSet<_> =\n-                    impl_.items.iter().map(|iiref| iiref.ident.normalize_to_macros_2_0()).collect();\n+                let overridden_methods = tcx.impl_item_implementor_ids(item.def_id);\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains(&method.ident.normalize_to_macros_2_0()) {\n+                    if overridden_methods.contains_key(&method.def_id) {\n                         continue;\n                     }\n "}, {"sha": "b755f686f6aac15e5222a016f1a99ed1081ce7d5", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -93,26 +93,29 @@ impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<\n                     for trait_item in self.tcx.associated_items(trait_def_id).in_definition_order()\n                     {\n                         if let ty::AssocItem {\n-                            kind: ty::AssocKind::Fn, ident, defaultness, ..\n-                        } = trait_item\n+                            kind: ty::AssocKind::Fn,\n+                            defaultness,\n+                            def_id: trait_item_id,\n+                            ..\n+                        } = *trait_item\n                         {\n                             // we can ignore functions that do not have default bodies:\n                             // if those are unimplemented it will be catched by typeck.\n                             if !defaultness.has_value()\n                                 || self\n                                     .tcx\n-                                    .has_attr(trait_item.def_id, sym::default_method_body_is_const)\n+                                    .has_attr(trait_item_id, sym::default_method_body_is_const)\n                             {\n                                 continue;\n                             }\n \n                             let is_implemented = ancestors\n-                                .leaf_def(self.tcx, trait_item.ident, trait_item.kind)\n+                                .leaf_def(self.tcx, trait_item_id)\n                                 .map(|node_item| !node_item.defining_node.is_from_trait())\n                                 .unwrap_or(false);\n \n                             if !is_implemented {\n-                                to_implement.push(ident.to_string());\n+                                to_implement.push(self.tcx.item_name(trait_item_id).to_string());\n                             }\n                         }\n                     }"}, {"sha": "c136411df2712f970a9b55396e5cdefbfdd71b7a", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -794,19 +794,12 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     }\n                 }\n \n-                if let Res::Def(DefKind::Trait, trait_did) = t.path.res {\n-                    for impl_item_ref in items {\n-                        let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                        let trait_item_def_id = self\n-                            .tcx\n-                            .associated_items(trait_did)\n-                            .filter_by_name_unhygienic(impl_item.ident.name)\n-                            .next()\n-                            .map(|item| item.def_id);\n-                        if let Some(def_id) = trait_item_def_id {\n-                            // Pass `None` to skip deprecation warnings.\n-                            self.tcx.check_stability(def_id, None, impl_item.span, None);\n-                        }\n+                for impl_item_ref in items {\n+                    let impl_item = self.tcx.associated_item(impl_item_ref.id.def_id);\n+\n+                    if let Some(def_id) = impl_item.trait_item_def_id {\n+                        // Pass `None` to skip deprecation warnings.\n+                        self.tcx.check_stability(def_id, None, impl_item_ref.span, None);\n                     }\n                 }\n             }"}, {"sha": "a83f02308145e57a704b599d001b1d24706d1fee", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -710,13 +710,11 @@ impl<'tcx> SaveContext<'tcx> {\n             }\n             Res::Def(HirDefKind::AssocFn, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n-                    let ti = self.tcx.associated_item(decl_id);\n-\n-                    self.tcx\n-                        .associated_items(ti.container.id())\n-                        .filter_by_name_unhygienic(ti.ident.name)\n-                        .find(|item| item.defaultness.has_value())\n-                        .map(|item| item.def_id)\n+                    if self.tcx.associated_item(decl_id).defaultness.has_value() {\n+                        Some(decl_id)\n+                    } else {\n+                        None\n+                    }\n                 } else {\n                     None\n                 };"}, {"sha": "51bd505366c778e5b37fcfdbe29d3b802887fe55", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -1883,7 +1883,6 @@ fn assoc_ty_def(\n     assoc_ty_def_id: DefId,\n ) -> Result<specialization_graph::LeafDef, ErrorReported> {\n     let tcx = selcx.tcx();\n-    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n     let trait_def = tcx.trait_def(trait_def_id);\n \n@@ -1893,21 +1892,18 @@ fn assoc_ty_def(\n     // for the associated item at the given impl.\n     // If there is no such item in that impl, this function will fail with a\n     // cycle error if the specialization graph is currently being built.\n-    let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-    for item in impl_node.items(tcx) {\n-        if matches!(item.kind, ty::AssocKind::Type)\n-            && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n-        {\n-            return Ok(specialization_graph::LeafDef {\n-                item: *item,\n-                defining_node: impl_node,\n-                finalizing_node: if item.defaultness.is_default() { None } else { Some(impl_node) },\n-            });\n-        }\n+    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_ty_def_id) {\n+        let item = tcx.associated_item(impl_item_id);\n+        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n+        return Ok(specialization_graph::LeafDef {\n+            item: *item,\n+            defining_node: impl_node,\n+            finalizing_node: if item.defaultness.is_default() { None } else { Some(impl_node) },\n+        });\n     }\n \n     let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n-    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type) {\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_ty_def_id) {\n         Ok(assoc_item)\n     } else {\n         // This is saying that neither the trait nor\n@@ -1916,7 +1912,11 @@ fn assoc_ty_def(\n         // could only arise through a compiler bug --\n         // if the user wrote a bad item name, it\n         // should have failed in astconv.\n-        bug!(\"No associated type `{}` for {}\", assoc_ty_name, tcx.def_path_str(impl_def_id))\n+        bug!(\n+            \"No associated type `{}` for {}\",\n+            tcx.item_name(assoc_ty_def_id),\n+            tcx.def_path_str(impl_def_id)\n+        )\n     }\n }\n "}, {"sha": "72ffe9085cbe779069d17b908d36bf2435aa4c60", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -197,14 +197,13 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     item: Option<&hir::Item<'tcx>>,\n     cause: &mut traits::ObligationCause<'tcx>,\n     pred: &ty::Predicate<'tcx>,\n-    mut trait_assoc_items: impl Iterator<Item = &'tcx ty::AssocItem>,\n ) {\n     debug!(\n         \"extended_cause_with_original_assoc_item_obligation {:?} {:?} {:?} {:?}\",\n         trait_ref, item, cause, pred\n     );\n-    let items = match item {\n-        Some(hir::Item { kind: hir::ItemKind::Impl(impl_), .. }) => impl_.items,\n+    let (items, impl_def_id) = match item {\n+        Some(hir::Item { kind: hir::ItemKind::Impl(impl_), def_id, .. }) => (impl_.items, *def_id),\n         _ => return,\n     };\n     let fix_span =\n@@ -222,11 +221,16 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n             if let ty::Projection(projection_ty) = proj.ty.kind() {\n-                let trait_assoc_item = tcx.associated_item(projection_ty.item_def_id);\n-                if let Some(impl_item_span) =\n-                    items.iter().find(|item| item.ident == trait_assoc_item.ident).map(fix_span)\n+                if let Some(&impl_item_id) =\n+                    tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n                 {\n-                    cause.span = impl_item_span;\n+                    if let Some(impl_item_span) = items\n+                        .iter()\n+                        .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                        .map(fix_span)\n+                    {\n+                        cause.span = impl_item_span;\n+                    }\n                 }\n             }\n         }\n@@ -235,13 +239,16 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n             if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = *pred.self_ty().kind() {\n-                if let Some(impl_item_span) = trait_assoc_items\n-                    .find(|i| i.def_id == item_def_id)\n-                    .and_then(|trait_assoc_item| {\n-                        items.iter().find(|i| i.ident == trait_assoc_item.ident).map(fix_span)\n-                    })\n+                if let Some(&impl_item_id) =\n+                    tcx.impl_item_implementor_ids(impl_def_id).get(&item_def_id)\n                 {\n-                    cause.span = impl_item_span;\n+                    if let Some(impl_item_span) = items\n+                        .iter()\n+                        .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                        .map(fix_span)\n+                    {\n+                        cause.span = impl_item_span;\n+                    }\n                 }\n             }\n         }\n@@ -312,7 +319,6 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 item,\n                 &mut cause,\n                 &obligation.predicate,\n-                tcx.associated_items(trait_ref.def_id).in_definition_order(),\n             );\n             traits::Obligation::with_depth(cause, depth, param_env, obligation.predicate)\n         };"}, {"sha": "3f51442277f5940f16c493959088ab8ec224587f", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -436,23 +436,13 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n         let def_id = associated_ty_id.0;\n         let assoc_item = self.interner.tcx.associated_item(def_id);\n-        let (impl_id, trait_id) = match assoc_item.container {\n-            AssocItemContainer::TraitContainer(def_id) => (def_id, def_id),\n-            AssocItemContainer::ImplContainer(def_id) => {\n-                (def_id, self.interner.tcx.impl_trait_ref(def_id).unwrap().def_id)\n-            }\n-        };\n+        let impl_id = assoc_item.container.id();\n         match assoc_item.kind {\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n \n-        let trait_item = self\n-            .interner\n-            .tcx\n-            .associated_items(trait_id)\n-            .find_by_name_and_kind(self.interner.tcx, assoc_item.ident, assoc_item.kind, trait_id)\n-            .unwrap();\n+        let trait_item_id = assoc_item.trait_item_def_id.expect(\"assoc_ty with no trait version\");\n         let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(self.interner, bound_vars);\n         let ty = self\n@@ -464,7 +454,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyValue {\n             impl_id: chalk_ir::ImplId(impl_id),\n-            associated_ty_id: chalk_ir::AssocTypeId(trait_item.def_id),\n+            associated_ty_id: chalk_ir::AssocTypeId(trait_item_id),\n             value: chalk_ir::Binders::new(\n                 binders,\n                 chalk_solve::rust_ir::AssociatedTyValueBound { ty },"}, {"sha": "b1d47f6c29a21b81f8c9d4a2083b018e64f10e7f", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -0,0 +1,239 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers {\n+        associated_item,\n+        associated_item_def_ids,\n+        associated_items,\n+        impl_item_implementor_ids,\n+        trait_of_item,\n+        ..*providers\n+    };\n+}\n+\n+fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n+    let item = tcx.hir().expect_item(def_id.expect_local());\n+    match item.kind {\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n+            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.def_id.to_def_id()),\n+        ),\n+        hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n+            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.def_id.to_def_id()),\n+        ),\n+        hir::ItemKind::TraitAlias(..) => &[],\n+        _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n+    }\n+}\n+\n+fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n+    let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n+    ty::AssocItems::new(items)\n+}\n+\n+fn impl_item_implementor_ids(tcx: TyCtxt<'_>, impl_id: DefId) -> FxHashMap<DefId, DefId> {\n+    tcx.associated_items(impl_id)\n+        .in_definition_order()\n+        .filter_map(|item| item.trait_item_def_id.map(|trait_item| (trait_item, item.def_id)))\n+        .collect()\n+}\n+\n+/// If the given `DefId` describes an item belonging to a trait,\n+/// returns the `DefId` of the trait that the trait item belongs to;\n+/// otherwise, returns `None`.\n+fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    tcx.opt_associated_item(def_id).and_then(|associated_item| match associated_item.container {\n+        ty::TraitContainer(def_id) => Some(def_id),\n+        ty::ImplContainer(_) => None,\n+    })\n+}\n+\n+fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    let parent_id = tcx.hir().get_parent_item(id);\n+    let parent_def_id = tcx.hir().local_def_id(parent_id);\n+    let parent_item = tcx.hir().expect_item(parent_def_id);\n+    match parent_item.kind {\n+        hir::ItemKind::Impl(ref impl_) => {\n+            if let Some(impl_item_ref) =\n+                impl_.items.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+            {\n+                let assoc_item =\n+                    associated_item_from_impl_item_ref(tcx, parent_def_id, impl_item_ref);\n+                debug_assert_eq!(assoc_item.def_id, def_id);\n+                return assoc_item;\n+            }\n+        }\n+\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            if let Some(trait_item_ref) =\n+                trait_item_refs.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+            {\n+                let assoc_item =\n+                    associated_item_from_trait_item_ref(tcx, parent_def_id, trait_item_ref);\n+                debug_assert_eq!(assoc_item.def_id, def_id);\n+                return assoc_item;\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    span_bug!(\n+        parent_item.span,\n+        \"unexpected parent of trait or impl item or item not found: {:?}\",\n+        parent_item.kind\n+    )\n+}\n+\n+fn associated_item_from_trait_item_ref(\n+    tcx: TyCtxt<'_>,\n+    parent_def_id: LocalDefId,\n+    trait_item_ref: &hir::TraitItemRef,\n+) -> ty::AssocItem {\n+    let def_id = trait_item_ref.id.def_id;\n+    let (kind, has_self) = match trait_item_ref.kind {\n+        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n+        hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n+        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n+    };\n+\n+    ty::AssocItem {\n+        ident: trait_item_ref.ident,\n+        kind,\n+        vis: tcx.visibility(def_id),\n+        defaultness: trait_item_ref.defaultness,\n+        def_id: def_id.to_def_id(),\n+        trait_item_def_id: Some(def_id.to_def_id()),\n+        container: ty::TraitContainer(parent_def_id.to_def_id()),\n+        fn_has_self_parameter: has_self,\n+    }\n+}\n+\n+fn associated_item_from_impl_item_ref(\n+    tcx: TyCtxt<'_>,\n+    parent_def_id: LocalDefId,\n+    impl_item_ref: &hir::ImplItemRef,\n+) -> ty::AssocItem {\n+    let def_id = impl_item_ref.id.def_id;\n+    let (kind, has_self) = match impl_item_ref.kind {\n+        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n+        hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n+        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n+    };\n+\n+    let trait_item_def_id = impl_item_base_id(tcx, parent_def_id, impl_item_ref);\n+\n+    ty::AssocItem {\n+        ident: impl_item_ref.ident,\n+        kind,\n+        vis: tcx.visibility(def_id),\n+        defaultness: impl_item_ref.defaultness,\n+        def_id: def_id.to_def_id(),\n+        trait_item_def_id,\n+        container: ty::ImplContainer(parent_def_id.to_def_id()),\n+        fn_has_self_parameter: has_self,\n+    }\n+}\n+\n+fn impl_item_base_id<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    parent_def_id: LocalDefId,\n+    impl_item: &hir::ImplItemRef,\n+) -> Option<DefId> {\n+    let impl_trait_ref = tcx.impl_trait_ref(parent_def_id)?;\n+\n+    // If the trait reference itself is erroneous (so the compilation is going\n+    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n+    // isn't populated for such impls.\n+    if impl_trait_ref.references_error() {\n+        return None;\n+    }\n+\n+    // Locate trait items\n+    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n+\n+    // Match item against trait\n+    let mut items = associated_items.filter_by_name(tcx, impl_item.ident, impl_trait_ref.def_id);\n+\n+    let mut trait_item = items.next()?;\n+\n+    let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n+        (ty::AssocKind::Const, hir::AssocItemKind::Const) => true,\n+        (ty::AssocKind::Fn, hir::AssocItemKind::Fn { .. }) => true,\n+        (ty::AssocKind::Type, hir::AssocItemKind::Type) => true,\n+        _ => false,\n+    };\n+\n+    // If we don't have a compatible item, we'll use the first one whose name matches\n+    // to report an error.\n+    let mut compatible_kind = is_compatible(&trait_item);\n+\n+    if !compatible_kind {\n+        if let Some(ty_trait_item) = items.find(is_compatible) {\n+            compatible_kind = true;\n+            trait_item = ty_trait_item;\n+        }\n+    }\n+\n+    if compatible_kind {\n+        Some(trait_item.def_id)\n+    } else {\n+        report_mismatch_error(tcx, trait_item.def_id, impl_trait_ref, impl_item);\n+        None\n+    }\n+}\n+\n+#[inline(never)]\n+#[cold]\n+fn report_mismatch_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_item_def_id: DefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item: &hir::ImplItemRef,\n+) {\n+    let mut err = match impl_item.kind {\n+        hir::AssocItemKind::Const => {\n+            // Find associated const definition.\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0323,\n+                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::AssocItemKind::Fn { .. } => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0324,\n+                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::AssocItemKind::Type => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0325,\n+                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+    };\n+\n+    err.span_label(impl_item.span, \"does not match trait\");\n+    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n+        err.span_label(trait_span, \"item in trait\");\n+    }\n+    err.emit();\n+}"}, {"sha": "e0aea786b837a26fb9edb33811d1bbef8cdc92f9", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -152,8 +152,7 @@ fn inner_resolve_instance<'tcx>(\n \n     let result = if let Some(trait_def_id) = tcx.trait_of_item(def.did) {\n         debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n-        let item = tcx.associated_item(def.did);\n-        resolve_associated_item(tcx, &item, param_env, trait_def_id, substs)\n+        resolve_associated_item(tcx, def.did, param_env, trait_def_id, substs)\n     } else {\n         let ty = tcx.type_of(def.def_id_for_type_of());\n         let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, ty);\n@@ -204,19 +203,12 @@ fn inner_resolve_instance<'tcx>(\n \n fn resolve_associated_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    trait_item: &ty::AssocItem,\n+    trait_item_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_id: DefId,\n     rcvr_substs: SubstsRef<'tcx>,\n ) -> Result<Option<Instance<'tcx>>, ErrorReported> {\n-    let def_id = trait_item.def_id;\n-    debug!(\n-        \"resolve_associated_item(trait_item={:?}, \\\n-            param_env={:?}, \\\n-            trait_id={:?}, \\\n-            rcvr_substs={:?})\",\n-        def_id, param_env, trait_id, rcvr_substs\n-    );\n+    debug!(?trait_item_id, ?param_env, ?trait_id, ?rcvr_substs, \"resolve_associated_item\");\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n \n@@ -232,7 +224,7 @@ fn resolve_associated_item<'tcx>(\n         traits::ImplSource::UserDefined(impl_data) => {\n             debug!(\n                 \"resolving ImplSource::UserDefined: {:?}, {:?}, {:?}, {:?}\",\n-                param_env, trait_item, rcvr_substs, impl_data\n+                param_env, trait_item_id, rcvr_substs, impl_data\n             );\n             assert!(!rcvr_substs.needs_infer());\n             assert!(!trait_ref.needs_infer());\n@@ -241,9 +233,9 @@ fn resolve_associated_item<'tcx>(\n             let trait_def = tcx.trait_def(trait_def_id);\n             let leaf_def = trait_def\n                 .ancestors(tcx, impl_data.impl_def_id)?\n-                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n+                .leaf_def(tcx, trait_item_id)\n                 .unwrap_or_else(|| {\n-                    bug!(\"{:?} not found in {:?}\", trait_item, impl_data.impl_def_id);\n+                    bug!(\"{:?} not found in {:?}\", trait_item_id, impl_data.impl_def_id);\n                 });\n \n             let substs = tcx.infer_ctxt().enter(|infcx| {\n@@ -297,22 +289,22 @@ fn resolve_associated_item<'tcx>(\n             // performs (i.e. that the definition's type in the `impl` matches\n             // the declaration in the `trait`), so that we can cheaply check\n             // here if it failed, instead of approximating it.\n-            if trait_item.kind == ty::AssocKind::Const\n-                && trait_item.def_id != leaf_def.item.def_id\n+            if leaf_def.item.kind == ty::AssocKind::Const\n+                && trait_item_id != leaf_def.item.def_id\n                 && leaf_def.item.def_id.is_local()\n             {\n                 let normalized_type_of = |def_id, substs| {\n                     tcx.subst_and_normalize_erasing_regions(substs, param_env, tcx.type_of(def_id))\n                 };\n \n-                let original_ty = normalized_type_of(trait_item.def_id, rcvr_substs);\n+                let original_ty = normalized_type_of(trait_item_id, rcvr_substs);\n                 let resolved_ty = normalized_type_of(leaf_def.item.def_id, substs);\n \n                 if original_ty != resolved_ty {\n                     let msg = format!(\n                         \"Instance::resolve: inconsistent associated `const` type: \\\n                          was `{}: {}` but resolved to `{}: {}`\",\n-                        tcx.def_path_str_with_substs(trait_item.def_id, rcvr_substs),\n+                        tcx.def_path_str_with_substs(trait_item_id, rcvr_substs),\n                         original_ty,\n                         tcx.def_path_str_with_substs(leaf_def.item.def_id, substs),\n                         resolved_ty,\n@@ -343,19 +335,22 @@ fn resolve_associated_item<'tcx>(\n         }\n         traits::ImplSource::FnPointer(ref data) => match data.fn_ty.kind() {\n             ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n-                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n                 substs: rcvr_substs,\n             }),\n             _ => None,\n         },\n         traits::ImplSource::Object(ref data) => {\n-            let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n-            Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n+            let index = traits::get_vtable_index_of_object_method(tcx, data, trait_item_id);\n+            Some(Instance {\n+                def: ty::InstanceDef::Virtual(trait_item_id, index),\n+                substs: rcvr_substs,\n+            })\n         }\n         traits::ImplSource::Builtin(..) => {\n             if Some(trait_ref.def_id) == tcx.lang_items().clone_trait() {\n                 // FIXME(eddyb) use lang items for methods instead of names.\n-                let name = tcx.item_name(def_id);\n+                let name = tcx.item_name(trait_item_id);\n                 if name == sym::clone {\n                     let self_ty = trait_ref.self_ty();\n \n@@ -367,15 +362,15 @@ fn resolve_associated_item<'tcx>(\n                     };\n \n                     Some(Instance {\n-                        def: ty::InstanceDef::CloneShim(def_id, self_ty),\n+                        def: ty::InstanceDef::CloneShim(trait_item_id, self_ty),\n                         substs: rcvr_substs,\n                     })\n                 } else {\n                     assert_eq!(name, sym::clone_from);\n \n                     // Use the default `fn clone_from` from `trait Clone`.\n                     let substs = tcx.erase_regions(rcvr_substs);\n-                    Some(ty::Instance::new(def_id, substs))\n+                    Some(ty::Instance::new(trait_item_id, substs))\n                 }\n             } else {\n                 None"}, {"sha": "55e199907617cb72af846b85a8c6c357cb6492f6", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -16,13 +16,15 @@ extern crate tracing;\n \n use rustc_middle::ty::query::Providers;\n \n+mod assoc;\n mod common_traits;\n pub mod instance;\n mod needs_drop;\n pub mod representability;\n mod ty;\n \n pub fn provide(providers: &mut Providers) {\n+    assoc::provide(providers);\n     common_traits::provide(providers);\n     needs_drop::provide(providers);\n     ty::provide(providers);"}, {"sha": "8f50e3e0fe1ca984883046c497e0687460d0439e", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 118, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n use rustc_span::{sym, Span};\n@@ -71,90 +71,6 @@ fn sized_constraint_for_ty<'tcx>(\n     result\n }\n \n-fn associated_item_from_trait_item_ref(\n-    tcx: TyCtxt<'_>,\n-    parent_def_id: LocalDefId,\n-    trait_item_ref: &hir::TraitItemRef,\n-) -> ty::AssocItem {\n-    let def_id = trait_item_ref.id.def_id;\n-    let (kind, has_self) = match trait_item_ref.kind {\n-        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n-        hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n-        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-    };\n-\n-    ty::AssocItem {\n-        ident: trait_item_ref.ident,\n-        kind,\n-        vis: tcx.visibility(def_id),\n-        defaultness: trait_item_ref.defaultness,\n-        def_id: def_id.to_def_id(),\n-        container: ty::TraitContainer(parent_def_id.to_def_id()),\n-        fn_has_self_parameter: has_self,\n-    }\n-}\n-\n-fn associated_item_from_impl_item_ref(\n-    tcx: TyCtxt<'_>,\n-    parent_def_id: LocalDefId,\n-    impl_item_ref: &hir::ImplItemRef,\n-) -> ty::AssocItem {\n-    let def_id = impl_item_ref.id.def_id;\n-    let (kind, has_self) = match impl_item_ref.kind {\n-        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n-        hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n-        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-    };\n-\n-    ty::AssocItem {\n-        ident: impl_item_ref.ident,\n-        kind,\n-        vis: tcx.visibility(def_id),\n-        defaultness: impl_item_ref.defaultness,\n-        def_id: def_id.to_def_id(),\n-        container: ty::ImplContainer(parent_def_id.to_def_id()),\n-        fn_has_self_parameter: has_self,\n-    }\n-}\n-\n-fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n-    let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let parent_id = tcx.hir().get_parent_item(id);\n-    let parent_def_id = tcx.hir().local_def_id(parent_id);\n-    let parent_item = tcx.hir().expect_item(parent_def_id);\n-    match parent_item.kind {\n-        hir::ItemKind::Impl(ref impl_) => {\n-            if let Some(impl_item_ref) =\n-                impl_.items.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n-            {\n-                let assoc_item =\n-                    associated_item_from_impl_item_ref(tcx, parent_def_id, impl_item_ref);\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n-                return assoc_item;\n-            }\n-        }\n-\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            if let Some(trait_item_ref) =\n-                trait_item_refs.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n-            {\n-                let assoc_item =\n-                    associated_item_from_trait_item_ref(tcx, parent_def_id, trait_item_ref);\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n-                return assoc_item;\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    span_bug!(\n-        parent_item.span,\n-        \"unexpected parent of trait or impl item or item not found: {:?}\",\n-        parent_item.kind\n-    )\n-}\n-\n fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n     let item = tcx.hir().expect_item(def_id.expect_local());\n     if let hir::ItemKind::Impl(impl_) = &item.kind {\n@@ -197,25 +113,6 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n     ty::AdtSizedConstraint(result)\n }\n \n-fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n-    match item.kind {\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n-            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.def_id.to_def_id()),\n-        ),\n-        hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n-            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.def_id.to_def_id()),\n-        ),\n-        hir::ItemKind::TraitAlias(..) => &[],\n-        _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n-    }\n-}\n-\n-fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n-    let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n-    ty::AssocItems::new(items)\n-}\n-\n fn def_ident_span(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Span> {\n     tcx.hir()\n         .get_if_local(def_id)\n@@ -231,16 +128,6 @@ fn def_ident_span(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Span> {\n         .map(|ident| ident.span)\n }\n \n-/// If the given `DefId` describes an item belonging to a trait,\n-/// returns the `DefId` of the trait that the trait item belongs to;\n-/// otherwise, returns `None`.\n-fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    tcx.opt_associated_item(def_id).and_then(|associated_item| match associated_item.container {\n-        ty::TraitContainer(def_id) => Some(def_id),\n-        ty::ImplContainer(_) => None,\n-    })\n-}\n-\n /// See `ParamEnv` struct definition for details.\n #[instrument(level = \"debug\", skip(tcx))]\n fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n@@ -620,14 +507,10 @@ pub fn conservative_is_privately_uninhabited_raw<'tcx>(\n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n         asyncness,\n-        associated_item,\n-        associated_item_def_ids,\n-        associated_items,\n         adt_sized_constraint,\n         def_ident_span,\n         param_env,\n         param_env_reveal_all_normalized,\n-        trait_of_item,\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,"}, {"sha": "dcf42e1aefebc7457e176f1baa41cb09d01b7e39", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 55, "deletions": 153, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -841,14 +841,8 @@ pub(super) fn check_specialization_validity<'tcx>(\n     trait_def: &ty::TraitDef,\n     trait_item: &ty::AssocItem,\n     impl_id: DefId,\n-    impl_item: &hir::ImplItem<'_>,\n+    impl_item: &hir::ImplItemRef,\n ) {\n-    let kind = match impl_item.kind {\n-        hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n-        hir::ImplItemKind::Fn(..) => ty::AssocKind::Fn,\n-        hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n-    };\n-\n     let ancestors = match trait_def.ancestors(tcx, impl_id) {\n         Ok(ancestors) => ancestors,\n         Err(_) => return,\n@@ -857,7 +851,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n         if parent.is_from_trait() {\n             None\n         } else {\n-            Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n+            Some((parent, parent.item(tcx, trait_item.def_id)))\n         }\n     });\n \n@@ -894,7 +888,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n     }\n }\n \n-pub(super) fn check_impl_items_against_trait<'tcx>(\n+fn check_impl_items_against_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     full_impl_span: Span,\n     impl_id: LocalDefId,\n@@ -926,174 +920,82 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n         }\n     }\n \n-    // Locate trait definition and items\n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n-    let impl_items = impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n-    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n-\n-    // Check existing impl methods to see if they are both present in trait\n-    // and compatible with trait signature\n-    for impl_item in impl_items {\n-        let ty_impl_item = tcx.associated_item(impl_item.def_id);\n-\n-        let mut items =\n-            associated_items.filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id);\n-\n-        let (compatible_kind, ty_trait_item) = if let Some(ty_trait_item) = items.next() {\n-            let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n-                (ty::AssocKind::Const, hir::ImplItemKind::Const(..)) => true,\n-                (ty::AssocKind::Fn, hir::ImplItemKind::Fn(..)) => true,\n-                (ty::AssocKind::Type, hir::ImplItemKind::TyAlias(..)) => true,\n-                _ => false,\n-            };\n-\n-            // If we don't have a compatible item, we'll use the first one whose name matches\n-            // to report an error.\n-            let mut compatible_kind = is_compatible(&ty_trait_item);\n-            let mut trait_item = ty_trait_item;\n-\n-            if !compatible_kind {\n-                if let Some(ty_trait_item) = items.find(is_compatible) {\n-                    compatible_kind = true;\n-                    trait_item = ty_trait_item;\n-                }\n-            }\n \n-            (compatible_kind, trait_item)\n+    for impl_item in impl_item_refs {\n+        let ty_impl_item = tcx.associated_item(impl_item.id.def_id);\n+        let ty_trait_item = if let Some(trait_item_id) = ty_impl_item.trait_item_def_id {\n+            tcx.associated_item(trait_item_id)\n         } else {\n+            // Checked in `associated_item`.\n+            tcx.sess.delay_span_bug(impl_item.span, \"missing associated item in trait\");\n             continue;\n         };\n-\n-        if compatible_kind {\n-            match impl_item.kind {\n-                hir::ImplItemKind::Const(..) => {\n-                    // Find associated const definition.\n-                    compare_const_impl(\n-                        tcx,\n-                        &ty_impl_item,\n-                        impl_item.span,\n-                        &ty_trait_item,\n-                        impl_trait_ref,\n-                    );\n-                }\n-                hir::ImplItemKind::Fn(..) => {\n-                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    compare_impl_method(\n-                        tcx,\n-                        &ty_impl_item,\n-                        impl_item.span,\n-                        &ty_trait_item,\n-                        impl_trait_ref,\n-                        opt_trait_span,\n-                    );\n-                }\n-                hir::ImplItemKind::TyAlias(impl_ty) => {\n-                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    compare_ty_impl(\n-                        tcx,\n-                        &ty_impl_item,\n-                        impl_ty.span,\n-                        &ty_trait_item,\n-                        impl_trait_ref,\n-                        opt_trait_span,\n-                    );\n-                }\n+        let impl_item_full = tcx.hir().impl_item(impl_item.id);\n+        match impl_item_full.kind {\n+            hir::ImplItemKind::Const(..) => {\n+                // Find associated const definition.\n+                compare_const_impl(\n+                    tcx,\n+                    &ty_impl_item,\n+                    impl_item.span,\n+                    &ty_trait_item,\n+                    impl_trait_ref,\n+                );\n+            }\n+            hir::ImplItemKind::Fn(..) => {\n+                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n+                compare_impl_method(\n+                    tcx,\n+                    &ty_impl_item,\n+                    impl_item.span,\n+                    &ty_trait_item,\n+                    impl_trait_ref,\n+                    opt_trait_span,\n+                );\n+            }\n+            hir::ImplItemKind::TyAlias(impl_ty) => {\n+                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n+                compare_ty_impl(\n+                    tcx,\n+                    &ty_impl_item,\n+                    impl_ty.span,\n+                    &ty_trait_item,\n+                    impl_trait_ref,\n+                    opt_trait_span,\n+                );\n             }\n-\n-            check_specialization_validity(\n-                tcx,\n-                trait_def,\n-                &ty_trait_item,\n-                impl_id.to_def_id(),\n-                impl_item,\n-            );\n-        } else {\n-            report_mismatch_error(\n-                tcx,\n-                ty_trait_item.def_id,\n-                impl_trait_ref,\n-                impl_item,\n-                &ty_impl_item,\n-            );\n         }\n+\n+        check_specialization_validity(\n+            tcx,\n+            trait_def,\n+            &ty_trait_item,\n+            impl_id.to_def_id(),\n+            impl_item,\n+        );\n     }\n \n     if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n-        let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n-\n         // Check for missing items from trait\n         let mut missing_items = Vec::new();\n-        for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n+        for &trait_item_id in tcx.associated_item_def_ids(impl_trait_ref.def_id) {\n             let is_implemented = ancestors\n-                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n-                .map(|node_item| !node_item.defining_node.is_from_trait())\n-                .unwrap_or(false);\n+                .leaf_def(tcx, trait_item_id)\n+                .map_or(false, |node_item| node_item.item.defaultness.has_value());\n \n             if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n-                if !trait_item.defaultness.has_value() {\n-                    missing_items.push(*trait_item);\n-                }\n+                missing_items.push(tcx.associated_item(trait_item_id));\n             }\n         }\n \n         if !missing_items.is_empty() {\n+            let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n             missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n         }\n     }\n }\n \n-#[inline(never)]\n-#[cold]\n-fn report_mismatch_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_item_def_id: DefId,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item: &hir::ImplItem<'_>,\n-    ty_impl_item: &ty::AssocItem,\n-) {\n-    let mut err = match impl_item.kind {\n-        hir::ImplItemKind::Const(..) => {\n-            // Find associated const definition.\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0323,\n-                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n-                ty_impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-\n-        hir::ImplItemKind::Fn(..) => {\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0324,\n-                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n-                ty_impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-\n-        hir::ImplItemKind::TyAlias(_) => {\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0325,\n-                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n-                ty_impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-    };\n-\n-    err.span_label(impl_item.span, \"does not match trait\");\n-    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n-        err.span_label(trait_span, \"item in trait\");\n-    }\n-    err.emit();\n-}\n-\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded."}, {"sha": "d576154ff9073b1952fca17ebcd53108c9104d9a", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -566,7 +566,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: S\n \n fn report_forbidden_specialization(\n     tcx: TyCtxt<'_>,\n-    impl_item: &hir::ImplItem<'_>,\n+    impl_item: &hir::ImplItemRef,\n     parent_impl: DefId,\n ) {\n     let mut err = struct_span_err!(\n@@ -598,7 +598,7 @@ fn report_forbidden_specialization(\n fn missing_items_err(\n     tcx: TyCtxt<'_>,\n     impl_span: Span,\n-    missing_items: &[ty::AssocItem],\n+    missing_items: &[&ty::AssocItem],\n     full_impl_span: Span,\n ) {\n     let missing_items_msg = missing_items"}, {"sha": "d4d4baa3f71da9c0ee1527eccf3df983451bace6", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -3150,21 +3150,12 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n /// applied to the method prototype.\n fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(impl_item) = tcx.opt_associated_item(def_id) {\n-        if let ty::AssocItemContainer::ImplContainer(impl_def_id) = impl_item.container {\n-            if let Some(trait_def_id) = tcx.trait_id_of_impl(impl_def_id) {\n-                if let Some(trait_item) = tcx\n-                    .associated_items(trait_def_id)\n-                    .filter_by_name_unhygienic(impl_item.ident.name)\n-                    .find(move |trait_item| {\n-                        trait_item.kind == ty::AssocKind::Fn\n-                            && tcx.hygienic_eq(impl_item.ident, trait_item.ident, trait_def_id)\n-                    })\n-                {\n-                    return tcx\n-                        .codegen_fn_attrs(trait_item.def_id)\n-                        .flags\n-                        .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n-                }\n+        if let ty::AssocItemContainer::ImplContainer(_) = impl_item.container {\n+            if let Some(trait_item) = impl_item.trait_item_def_id {\n+                return tcx\n+                    .codegen_fn_attrs(trait_item)\n+                    .flags\n+                    .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n             }\n         }\n     }"}, {"sha": "d805bbc79269015c9c466a22e2b3a38524253951", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -4,6 +4,15 @@ error[E0437]: type `bar` is not a member of trait `Foo`\n LL |     type bar = u64;\n    |     ^^^^^^^^^^^^^^^ not a member of trait `Foo`\n \n+error[E0324]: item `MY_CONST` is an associated method, which doesn't match its trait `Foo`\n+  --> $DIR/impl-wrong-item-for-trait.rs:22:5\n+   |\n+LL |     const MY_CONST: u32;\n+   |     -------------------- item in trait\n+...\n+LL |     fn MY_CONST() {}\n+   |     ^^^^^^^^^^^^^^^^ does not match trait\n+\n error[E0323]: item `bar` is an associated const, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:12:5\n    |\n@@ -13,6 +22,15 @@ LL |     fn bar(&self);\n LL |     const bar: u64 = 1;\n    |     ^^^^^^^^^^^^^^^^^^^ does not match trait\n \n+error[E0325]: item `bar` is an associated type, which doesn't match its trait `Foo`\n+  --> $DIR/impl-wrong-item-for-trait.rs:30:5\n+   |\n+LL |     fn bar(&self);\n+   |     -------------- item in trait\n+...\n+LL |     type bar = u64;\n+   |     ^^^^^^^^^^^^^^^ does not match trait\n+\n error[E0046]: not all trait items implemented, missing: `bar`\n   --> $DIR/impl-wrong-item-for-trait.rs:10:1\n    |\n@@ -22,15 +40,6 @@ LL |     fn bar(&self);\n LL | impl Foo for FooConstForMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `bar` in implementation\n \n-error[E0324]: item `MY_CONST` is an associated method, which doesn't match its trait `Foo`\n-  --> $DIR/impl-wrong-item-for-trait.rs:22:5\n-   |\n-LL |     const MY_CONST: u32;\n-   |     -------------------- item in trait\n-...\n-LL |     fn MY_CONST() {}\n-   |     ^^^^^^^^^^^^^^^^ does not match trait\n-\n error[E0046]: not all trait items implemented, missing: `MY_CONST`\n   --> $DIR/impl-wrong-item-for-trait.rs:19:1\n    |\n@@ -40,15 +49,6 @@ LL |     const MY_CONST: u32;\n LL | impl Foo for FooMethodForConst {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `MY_CONST` in implementation\n \n-error[E0325]: item `bar` is an associated type, which doesn't match its trait `Foo`\n-  --> $DIR/impl-wrong-item-for-trait.rs:30:5\n-   |\n-LL |     fn bar(&self);\n-   |     -------------- item in trait\n-...\n-LL |     type bar = u64;\n-   |     ^^^^^^^^^^^^^^^ does not match trait\n-\n error[E0046]: not all trait items implemented, missing: `bar`\n   --> $DIR/impl-wrong-item-for-trait.rs:28:1\n    |"}, {"sha": "64f6d62fbdcd80c12fac55ad62654d9054f75cee", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -214,14 +214,14 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n         fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n+        let is_empty = sym!(is_empty);\n \n         let is_empty_method_found = current_and_super_traits\n             .iter()\n-            .flat_map(|&i| cx.tcx.associated_items(i).in_definition_order())\n+            .flat_map(|&i| cx.tcx.associated_items(i).filter_by_name_unhygienic(is_empty))\n             .any(|i| {\n                 i.kind == ty::AssocKind::Fn\n                     && i.fn_has_self_parameter\n-                    && i.ident.name == sym!(is_empty)\n                     && cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n             });\n \n@@ -458,7 +458,7 @@ fn is_empty_array(expr: &Expr<'_>) -> bool {\n fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_>, item: &ty::AssocItem) -> bool {\n-        if item.kind == ty::AssocKind::Fn && item.ident.name.as_str() == \"is_empty\" {\n+        if item.kind == ty::AssocKind::Fn {\n             let sig = cx.tcx.fn_sig(item.def_id);\n             let ty = sig.skip_binder();\n             ty.inputs().len() == 1\n@@ -469,20 +469,22 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n \n     /// Checks the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext<'_>, id: DefId) -> bool {\n+        let is_empty = sym!(is_empty);\n         cx.tcx.inherent_impls(id).iter().any(|imp| {\n             cx.tcx\n                 .associated_items(*imp)\n-                .in_definition_order()\n+                .filter_by_name_unhygienic(is_empty)\n                 .any(|item| is_is_empty(cx, item))\n         })\n     }\n \n     let ty = &cx.typeck_results().expr_ty(expr).peel_refs();\n     match ty.kind() {\n         ty::Dynamic(tt, ..) => tt.principal().map_or(false, |principal| {\n+            let is_empty = sym!(is_empty);\n             cx.tcx\n                 .associated_items(principal.def_id())\n-                .in_definition_order()\n+                .filter_by_name_unhygienic(is_empty)\n                 .any(|item| is_is_empty(cx, item))\n         }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),"}, {"sha": "7d2ff083b7e07f95b8c76971933638d3caf175f2", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -12,11 +12,10 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{\n     BodyId, Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n };\n-use rustc_infer::traits::specialization_graph;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{self, AssocKind, Const, Ty};\n+use rustc_middle::ty::{self, Const, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n@@ -293,8 +292,10 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                         // Lint a trait impl item only when the definition is a generic type,\n                         // assuming an assoc const is not meant to be an interior mutable type.\n                         if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n-                        if let Some(of_assoc_item) = specialization_graph::Node::Trait(of_trait_def_id)\n-                            .item(cx.tcx, impl_item.ident, AssocKind::Const, of_trait_def_id);\n+                        if let Some(of_assoc_item) = cx\n+                            .tcx\n+                            .associated_item(impl_item.def_id)\n+                            .trait_item_def_id;\n                         if cx\n                             .tcx\n                             .layout_of(cx.tcx.param_env(of_trait_def_id).and(\n@@ -303,7 +304,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                                 // and, in that case, the definition is *not* generic.\n                                 cx.tcx.normalize_erasing_regions(\n                                     cx.tcx.param_env(of_trait_def_id),\n-                                    cx.tcx.type_of(of_assoc_item.def_id),\n+                                    cx.tcx.type_of(of_assoc_item),\n                                 ),\n                             ))\n                             .is_err();"}, {"sha": "a86db58741eb6ca0a052b2dbf21756dd0ee2d03f", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/488acf86a75c56d30b16822e953c505a9e4901a7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488acf86a75c56d30b16822e953c505a9e4901a7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=488acf86a75c56d30b16822e953c505a9e4901a7", "patch": "@@ -13,7 +13,6 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::AssocKind;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -143,10 +142,10 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 // trait, not in the impl of the trait.\n                 let trait_method = cx\n                     .tcx\n-                    .associated_items(impl_trait_ref.def_id)\n-                    .find_by_name_and_kind(cx.tcx, impl_item.ident, AssocKind::Fn, impl_trait_ref.def_id)\n+                    .associated_item(impl_item.def_id)\n+                    .trait_item_def_id\n                     .expect(\"impl method matches a trait method\");\n-                let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n+                let trait_method_sig = cx.tcx.fn_sig(trait_method);\n                 let trait_method_sig = cx.tcx.erase_late_bound_regions(trait_method_sig);\n \n                 // `impl_inputs_outputs` is an iterator over the types (`hir::Ty`) declared in the"}]}