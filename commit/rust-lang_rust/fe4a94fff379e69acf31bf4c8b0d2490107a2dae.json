{"sha": "fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNGE5NGZmZjM3OWU2OWFjZjMxYmY0YzhiMGQyNDkwMTA3YTJkYWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-13T13:04:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-13T13:04:45Z"}, "message": "Merge #7994\n\n7994: Speed up mbe matching in heavy recursive cases r=edwin0cheng a=edwin0cheng\n\nIn some cases (e.g.  #4186), mbe matching is very slow due to a lot of copy and allocation for bindings, this PR try to solve this problem by introduce a semi \"link-list\" approach for bindings building.\r\n\r\nI used this [test case](https://github.com/weiznich/minimal_example_for_rust_81262) (for `features(32-column-tables)`) to run following command to benchmark:\r\n```\r\ntime rust-analyzer analysis-stats  --load-output-dirs ./ \r\n```\r\n\r\nBefore this PR : 2 mins\r\nAfter this PR: 3 seconds.\r\n\r\nHowever, for 64-column-tables cases, we still need 4 mins to complete. \r\n\r\nI will try to investigate in the following weeks.\r\n\r\nbors r+\r\n\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "65f614b2c839379c294f4ea08564d135f5b7ad4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65f614b2c839379c294f4ea08564d135f5b7ad4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgTLhtCRBK7hj4Ov3rIwAAdHIIAIYInaiN2151/jB+35HK0XlB\nzt0DaaC1uzEztJHPh9Y8eTgFCJ8yc9bw1LX/BEJQM4UrtjbV/xr7eymmsjjwUmsZ\nd792fXbfY5f2RDXRV7h3FNPOr4E/rryxFxxdBjaYhXoBRBitckgaA5f15BLfRkq9\nL0APCnPA+iz8PhHYANa2+ijxN8XTRroUJssGJI6IOL4CiPsN3j/rgZqzTDqYSNAt\n02nz9o6Qgswl/zF/zcKnAonkbph8okqNZ9QZ6OtOW7sMDIqjMqWUX7S7Oz5yvjXK\n6kJ/RVbEO+FKxyXA0+I3I8kZvCEkq1otGCjngqSfzEO+VupDE6Hu1e3y902vzHM=\n=yVuE\n-----END PGP SIGNATURE-----\n", "payload": "tree 65f614b2c839379c294f4ea08564d135f5b7ad4c\nparent 88f78bdb9b64e0ba4ca5924599e42a524f5c3b64\nparent 9117148f42371108f49de84ff765da987dcb5917\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615640685 +0000\ncommitter GitHub <noreply@github.com> 1615640685 +0000\n\nMerge #7994\n\n7994: Speed up mbe matching in heavy recursive cases r=edwin0cheng a=edwin0cheng\n\nIn some cases (e.g.  #4186), mbe matching is very slow due to a lot of copy and allocation for bindings, this PR try to solve this problem by introduce a semi \"link-list\" approach for bindings building.\r\n\r\nI used this [test case](https://github.com/weiznich/minimal_example_for_rust_81262) (for `features(32-column-tables)`) to run following command to benchmark:\r\n```\r\ntime rust-analyzer analysis-stats  --load-output-dirs ./ \r\n```\r\n\r\nBefore this PR : 2 mins\r\nAfter this PR: 3 seconds.\r\n\r\nHowever, for 64-column-tables cases, we still need 4 mins to complete. \r\n\r\nI will try to investigate in the following weeks.\r\n\r\nbors r+\r\n\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "html_url": "https://github.com/rust-lang/rust/commit/fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f78bdb9b64e0ba4ca5924599e42a524f5c3b64", "url": "https://api.github.com/repos/rust-lang/rust/commits/88f78bdb9b64e0ba4ca5924599e42a524f5c3b64", "html_url": "https://github.com/rust-lang/rust/commit/88f78bdb9b64e0ba4ca5924599e42a524f5c3b64"}, {"sha": "9117148f42371108f49de84ff765da987dcb5917", "url": "https://api.github.com/repos/rust-lang/rust/commits/9117148f42371108f49de84ff765da987dcb5917", "html_url": "https://github.com/rust-lang/rust/commit/9117148f42371108f49de84ff765da987dcb5917"}], "stats": {"total": 337, "additions": 270, "deletions": 67}, "files": [{"sha": "9086e6c1769f6bd838fe686fdbc9e1f9528705da", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "patch": "@@ -340,6 +340,8 @@ fn parse_macro_with_arg(\n         None => return ExpandResult { value: None, err: result.err },\n     };\n \n+    log::debug!(\"expanded = {}\", tt.as_debug_string());\n+\n     let fragment_kind = to_fragment_kind(db, macro_call_id);\n \n     let (parse, rev_token_map) = match mbe::token_tree_to_syntax_node(&tt, fragment_kind) {"}, {"sha": "3197c834cf79faea4f4c4384bbb8de533e3075a4", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "patch": "@@ -5,7 +5,7 @@\n mod matcher;\n mod transcriber;\n \n-use smallvec::SmallVec;\n+use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n use crate::{ExpandError, ExpandResult};\n@@ -96,7 +96,7 @@ pub(crate) fn expand_rules(\n /// many is not a plain `usize`, but an `&[usize]`.\n #[derive(Debug, Default, Clone, PartialEq, Eq)]\n struct Bindings {\n-    inner: SmallVec<[(SmolStr, Binding); 4]>,\n+    inner: FxHashMap<SmolStr, Binding>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "54db76d5dc5e6e823022d4b1ec30837d1d8cd2b9", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 215, "deletions": 57, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "patch": "@@ -59,6 +59,8 @@\n //! eof: [a $( a )* a b \u00b7]\n //! ```\n \n+use std::rc::Rc;\n+\n use crate::{\n     expander::{Binding, Bindings, Fragment},\n     parser::{Op, OpDelimited, OpDelimitedIter, RepeatKind, Separator},\n@@ -76,43 +78,15 @@ impl Bindings {\n         // FIXME: Do we have a better way to represent an empty token ?\n         // Insert an empty subtree for empty token\n         let tt = tt::Subtree::default().into();\n-        self.inner.push((name.clone(), Binding::Fragment(Fragment::Tokens(tt))));\n+        self.inner.insert(name.clone(), Binding::Fragment(Fragment::Tokens(tt)));\n     }\n \n     fn push_empty(&mut self, name: &SmolStr) {\n-        self.inner.push((name.clone(), Binding::Empty));\n-    }\n-\n-    fn push_nested(&mut self, idx: usize, nested: Bindings) -> Result<(), ExpandError> {\n-        for (key, value) in nested.inner {\n-            if self.get_mut(&key).is_none() {\n-                self.inner.push((key.clone(), Binding::Nested(Vec::new())));\n-            }\n-            match self.get_mut(&key) {\n-                Some(Binding::Nested(it)) => {\n-                    // insert empty nested bindings before this one\n-                    while it.len() < idx {\n-                        it.push(Binding::Nested(vec![]));\n-                    }\n-                    it.push(value);\n-                }\n-                _ => {\n-                    return Err(ExpandError::BindingError(format!(\n-                        \"could not find binding `{}`\",\n-                        key\n-                    )));\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn get_mut(&mut self, name: &str) -> Option<&mut Binding> {\n-        self.inner.iter_mut().find_map(|(n, b)| if n == name { Some(b) } else { None })\n+        self.inner.insert(name.clone(), Binding::Empty);\n     }\n \n     fn bindings(&self) -> impl Iterator<Item = &Binding> {\n-        self.inner.iter().map(|(_, b)| b)\n+        self.inner.values()\n     }\n }\n \n@@ -162,6 +136,187 @@ pub(super) fn match_(pattern: &MetaTemplate, input: &tt::Subtree) -> Match {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+enum BindingKind {\n+    Empty(SmolStr),\n+    Optional(SmolStr),\n+    Fragment(SmolStr, Fragment),\n+    Nested(usize, usize),\n+}\n+\n+#[derive(Debug, Clone)]\n+struct BindingsIdx(usize, usize);\n+\n+#[derive(Debug, Clone)]\n+enum LinkNode<T> {\n+    Node(T),\n+    Parent { idx: usize, len: usize },\n+}\n+\n+#[derive(Default)]\n+struct BindingsBuilder {\n+    nodes: Vec<Vec<LinkNode<Rc<BindingKind>>>>,\n+    nested: Vec<Vec<LinkNode<usize>>>,\n+}\n+\n+impl BindingsBuilder {\n+    fn alloc(&mut self) -> BindingsIdx {\n+        let idx = self.nodes.len();\n+        self.nodes.push(Vec::with_capacity(8));\n+        let nidx = self.nested.len();\n+        self.nested.push(Vec::with_capacity(8));\n+        BindingsIdx(idx, nidx)\n+    }\n+\n+    fn copy(&mut self, bindings: &BindingsIdx) -> BindingsIdx {\n+        let idx = copy_parent(bindings.0, &mut self.nodes);\n+        let nidx = copy_parent(bindings.1, &mut self.nested);\n+        return BindingsIdx(idx, nidx);\n+\n+        fn copy_parent<T>(idx: usize, target: &mut Vec<Vec<LinkNode<T>>>) -> usize\n+        where\n+            T: Clone,\n+        {\n+            let new_idx = target.len();\n+            let len = target[idx].len();\n+            if len < 4 {\n+                target.push(target[idx].clone())\n+            } else {\n+                let mut item = Vec::with_capacity(8);\n+                item.push(LinkNode::Parent { idx, len });\n+                target.push(item);\n+            }\n+\n+            new_idx\n+        }\n+    }\n+\n+    fn push_empty(&mut self, idx: &mut BindingsIdx, var: &SmolStr) {\n+        self.nodes[idx.0].push(LinkNode::Node(Rc::new(BindingKind::Empty(var.clone()))));\n+    }\n+\n+    fn push_optional(&mut self, idx: &mut BindingsIdx, var: &SmolStr) {\n+        self.nodes[idx.0].push(LinkNode::Node(Rc::new(BindingKind::Optional(var.clone()))));\n+    }\n+\n+    fn push_fragment(&mut self, idx: &mut BindingsIdx, var: &SmolStr, fragment: Fragment) {\n+        self.nodes[idx.0]\n+            .push(LinkNode::Node(Rc::new(BindingKind::Fragment(var.clone(), fragment))));\n+    }\n+\n+    fn push_nested(&mut self, parent: &mut BindingsIdx, child: &BindingsIdx) {\n+        let BindingsIdx(idx, nidx) = self.copy(&child);\n+        self.nodes[parent.0].push(LinkNode::Node(Rc::new(BindingKind::Nested(idx, nidx))));\n+    }\n+\n+    fn push_default(&mut self, idx: &mut BindingsIdx) {\n+        self.nested[idx.1].push(LinkNode::Node(idx.0));\n+        let new_idx = self.nodes.len();\n+        self.nodes.push(Vec::with_capacity(8));\n+        idx.0 = new_idx;\n+    }\n+\n+    fn build(self, idx: &BindingsIdx) -> Bindings {\n+        let mut bindings = Bindings::default();\n+        self.build_recur(&mut bindings, self.nodes[idx.0].clone());\n+        bindings\n+    }\n+\n+    fn build_recur(&self, bindings: &mut Bindings, nodes: Vec<LinkNode<Rc<BindingKind>>>) {\n+        for cmd in self.flatten_nodes(nodes) {\n+            match &*cmd {\n+                BindingKind::Empty(name) => {\n+                    bindings.push_empty(name);\n+                }\n+                BindingKind::Optional(name) => {\n+                    bindings.push_optional(name);\n+                }\n+                BindingKind::Fragment(name, fragment) => {\n+                    bindings.inner.insert(name.clone(), Binding::Fragment(fragment.clone()));\n+                }\n+                BindingKind::Nested(idx, list) => {\n+                    let list = self.flatten_nested(*idx, *list);\n+\n+                    for (idx, iter) in list.enumerate() {\n+                        for (key, value) in &iter.inner {\n+                            let bindings = bindings\n+                                .inner\n+                                .entry(key.clone())\n+                                .or_insert_with(|| Binding::Nested(Vec::new()));\n+\n+                            if let Binding::Nested(it) = bindings {\n+                                // insert empty nested bindings before this one\n+                                while it.len() < idx {\n+                                    it.push(Binding::Nested(Vec::new()));\n+                                }\n+                                it.push(value.clone());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn flatten_nested_ref(&self, id: usize, len: usize) -> Vec<Vec<LinkNode<Rc<BindingKind>>>> {\n+        self.nested[id]\n+            .iter()\n+            .take(len)\n+            .map(|it| match it {\n+                LinkNode::Node(id) => vec![self.nodes[*id].clone()],\n+                LinkNode::Parent { idx, len } => self.flatten_nested_ref(*idx, *len),\n+            })\n+            .flatten()\n+            .collect()\n+    }\n+\n+    fn flatten_nested<'a>(\n+        &'a self,\n+        idx: usize,\n+        list: usize,\n+    ) -> impl Iterator<Item = Bindings> + 'a {\n+        let last = self.nodes[idx].clone();\n+        self.nested[list]\n+            .iter()\n+            .map(move |it| match *it {\n+                LinkNode::Node(idx) => vec![self.nodes[idx].clone()],\n+                LinkNode::Parent { idx, len } => self.flatten_nested_ref(idx, len),\n+            })\n+            .flatten()\n+            .chain(std::iter::once(last))\n+            .map(move |iter| {\n+                let mut child_bindings = Bindings::default();\n+                self.build_recur(&mut child_bindings, iter);\n+                child_bindings\n+            })\n+    }\n+\n+    fn flatten_nodes_ref(&self, id: usize, len: usize) -> Vec<Rc<BindingKind>> {\n+        self.nodes[id]\n+            .iter()\n+            .take(len)\n+            .map(|it| match it {\n+                LinkNode::Node(it) => vec![it.clone()],\n+                LinkNode::Parent { idx, len } => self.flatten_nodes_ref(*idx, *len),\n+            })\n+            .flatten()\n+            .collect()\n+    }\n+\n+    fn flatten_nodes<'a>(\n+        &'a self,\n+        nodes: Vec<LinkNode<Rc<BindingKind>>>,\n+    ) -> impl Iterator<Item = Rc<BindingKind>> + 'a {\n+        nodes\n+            .into_iter()\n+            .map(move |it| match it {\n+                LinkNode::Node(it) => vec![it],\n+                LinkNode::Parent { idx, len } => self.flatten_nodes_ref(idx, len),\n+            })\n+            .flatten()\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n struct MatchState<'t> {\n     /// The position of the \"dot\" in this matcher\n@@ -187,7 +342,7 @@ struct MatchState<'t> {\n     sep_parsed: Option<usize>,\n \n     /// Matched meta variables bindings\n-    bindings: SmallVec<[Bindings; 4]>,\n+    bindings: BindingsIdx,\n \n     /// Cached result of meta variable parsing\n     meta_result: Option<(TtIter<'t>, ExpandResult<Option<Fragment>>)>,\n@@ -218,6 +373,7 @@ fn match_loop_inner<'t>(\n     src: TtIter<'t>,\n     stack: &[TtIter<'t>],\n     res: &mut Match,\n+    bindings_builder: &mut BindingsBuilder,\n     cur_items: &mut SmallVec<[MatchState<'t>; 1]>,\n     bb_items: &mut SmallVec<[MatchState<'t>; 1]>,\n     next_items: &mut Vec<MatchState<'t>>,\n@@ -251,12 +407,10 @@ fn match_loop_inner<'t>(\n                     if item.sep_parsed.is_none() {\n                         // Get the `up` matcher\n                         let mut new_pos = *item.up.clone().unwrap();\n+                        new_pos.bindings = bindings_builder.copy(&new_pos.bindings);\n                         // Add matches from this repetition to the `matches` of `up`\n-                        if let Some(bindings) = new_pos.bindings.last_mut() {\n-                            for (i, b) in item.bindings.iter_mut().enumerate() {\n-                                bindings.push_nested(i, b.clone()).unwrap();\n-                            }\n-                        }\n+                        bindings_builder.push_nested(&mut new_pos.bindings, &item.bindings);\n+\n                         // Move the \"dot\" past the repetition in `up`\n                         new_pos.dot.next();\n                         new_pos.is_error = new_pos.is_error || item.is_error;\n@@ -280,7 +434,7 @@ fn match_loop_inner<'t>(\n                     else if item.sep_kind != Some(RepeatKind::ZeroOrOne) {\n                         item.dot = item.dot.reset();\n                         item.sep_parsed = None;\n-                        item.bindings.push(Bindings::default());\n+                        bindings_builder.push_default(&mut item.bindings);\n                         cur_items.push(item);\n                     }\n                 } else {\n@@ -298,12 +452,12 @@ fn match_loop_inner<'t>(\n             OpDelimited::Op(Op::Repeat { tokens, kind, separator }) => {\n                 if matches!(kind, RepeatKind::ZeroOrMore | RepeatKind::ZeroOrOne) {\n                     let mut new_item = item.clone();\n+                    new_item.bindings = bindings_builder.copy(&new_item.bindings);\n                     new_item.dot.next();\n                     let mut vars = Vec::new();\n-                    let bindings = new_item.bindings.last_mut().unwrap();\n                     collect_vars(&mut vars, tokens);\n                     for var in vars {\n-                        bindings.push_empty(&var);\n+                        bindings_builder.push_empty(&mut new_item.bindings, &var);\n                     }\n                     cur_items.push(new_item);\n                 }\n@@ -314,7 +468,7 @@ fn match_loop_inner<'t>(\n                     sep: separator.clone(),\n                     sep_kind: Some(*kind),\n                     sep_parsed: None,\n-                    bindings: smallvec![Bindings::default()],\n+                    bindings: bindings_builder.alloc(),\n                     meta_result: None,\n                     is_error: false,\n                 })\n@@ -339,7 +493,7 @@ fn match_loop_inner<'t>(\n                                 item.meta_result = Some((fork, match_res));\n                                 try_push!(bb_items, item);\n                             } else {\n-                                item.bindings.last_mut().unwrap().push_optional(name);\n+                                bindings_builder.push_optional(&mut item.bindings, &name);\n                                 item.dot.next();\n                                 cur_items.push(item);\n                             }\n@@ -348,11 +502,11 @@ fn match_loop_inner<'t>(\n                             res.add_err(err);\n                             match match_res.value {\n                                 Some(fragment) => {\n-                                    item.bindings\n-                                        .last_mut()\n-                                        .unwrap()\n-                                        .inner\n-                                        .push((name.clone(), Binding::Fragment(fragment)));\n+                                    bindings_builder.push_fragment(\n+                                        &mut item.bindings,\n+                                        &name,\n+                                        fragment,\n+                                    );\n                                 }\n                                 _ => {}\n                             }\n@@ -394,14 +548,16 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n     let mut res = Match::default();\n     let mut error_reover_item = None;\n \n+    let mut bindings_builder = BindingsBuilder::default();\n+\n     let mut cur_items = smallvec![MatchState {\n         dot: pattern.iter_delimited(None),\n         stack: Default::default(),\n         up: None,\n         sep: None,\n         sep_kind: None,\n         sep_parsed: None,\n-        bindings: smallvec![Bindings::default()],\n+        bindings: bindings_builder.alloc(),\n         is_error: false,\n         meta_result: None,\n     }];\n@@ -419,6 +575,7 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n             src.clone(),\n             &stack,\n             &mut res,\n+            &mut bindings_builder,\n             &mut cur_items,\n             &mut bb_items,\n             &mut next_items,\n@@ -428,9 +585,9 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n         stdx::always!(cur_items.is_empty());\n \n         if error_items.len() > 0 {\n-            error_reover_item = error_items.pop();\n+            error_reover_item = error_items.pop().map(|it| it.bindings);\n         } else if eof_items.len() > 0 {\n-            error_reover_item = Some(eof_items[0].clone());\n+            error_reover_item = Some(eof_items[0].bindings.clone());\n         }\n \n         // We need to do some post processing after the `match_loop_inner`.\n@@ -440,11 +597,11 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n             if eof_items.len() == 1 {\n                 // remove all errors, because it is the correct answer !\n                 res = Match::default();\n-                res.bindings = eof_items[0].bindings[0].clone();\n+                res.bindings = bindings_builder.build(&eof_items[0].bindings);\n             } else {\n                 // Error recovery\n                 if error_reover_item.is_some() {\n-                    res.bindings = error_reover_item.unwrap().bindings[0].clone();\n+                    res.bindings = bindings_builder.build(&error_reover_item.unwrap());\n                 }\n                 res.add_err(ExpandError::UnexpectedToken);\n             }\n@@ -467,8 +624,8 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n             }\n             res.add_err(err!(\"leftover tokens\"));\n \n-            if let Some(mut error_reover_item) = error_reover_item {\n-                res.bindings = error_reover_item.bindings.remove(0);\n+            if let Some(error_reover_item) = error_reover_item {\n+                res.bindings = bindings_builder.build(&error_reover_item);\n             }\n             return res;\n         }\n@@ -494,12 +651,13 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n \n             if let Some(OpDelimited::Op(Op::Var { name, .. })) = item.dot.peek() {\n                 let (iter, match_res) = item.meta_result.take().unwrap();\n-                let bindings = item.bindings.last_mut().unwrap();\n                 match match_res.value {\n                     Some(fragment) => {\n-                        bindings.inner.push((name.clone(), Binding::Fragment(fragment)));\n+                        bindings_builder.push_fragment(&mut item.bindings, &name, fragment);\n+                    }\n+                    None if match_res.err.is_none() => {\n+                        bindings_builder.push_optional(&mut item.bindings, &name);\n                     }\n-                    None if match_res.err.is_none() => bindings.push_optional(name),\n                     _ => {}\n                 }\n                 if let Some(err) = match_res.err {"}, {"sha": "c679e5e5d338ed1592d430ab2aaa99bc38ce53a2", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "patch": "@@ -13,17 +13,13 @@ use crate::{\n \n impl Bindings {\n     fn contains(&self, name: &str) -> bool {\n-        self.inner.iter().any(|(n, _)| n == name)\n+        self.inner.contains_key(name)\n     }\n \n     fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<&Fragment, ExpandError> {\n-        let mut b: &Binding = self\n-            .inner\n-            .iter()\n-            .find_map(|(n, b)| if n == name { Some(b) } else { None })\n-            .ok_or_else(|| {\n-                ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n-            })?;\n+        let mut b: &Binding = self.inner.get(name).ok_or_else(|| {\n+            ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n+        })?;\n         for nesting_state in nesting.iter_mut() {\n             nesting_state.hit = true;\n             b = match b {"}, {"sha": "9d9a01e30a9a2d821a0f1294cfc47a345d7ef80c", "filename": "crates/tt/src/lib.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Ftt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4a94fff379e69acf31bf4c8b0d2490107a2dae/crates%2Ftt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2Fsrc%2Flib.rs?ref=fe4a94fff379e69acf31bf4c8b0d2490107a2dae", "patch": "@@ -227,6 +227,53 @@ impl Subtree {\n     }\n }\n \n+impl Subtree {\n+    /// A simple line string used for debugging\n+    pub fn as_debug_string(&self) -> String {\n+        let delim = match self.delimiter_kind() {\n+            Some(DelimiterKind::Brace) => (\"{\", \"}\"),\n+            Some(DelimiterKind::Bracket) => (\"[\", \"]\"),\n+            Some(DelimiterKind::Parenthesis) => (\"(\", \")\"),\n+            None => (\" \", \" \"),\n+        };\n+\n+        let mut res = String::new();\n+        res.push_str(delim.0);\n+        let mut iter = self.token_trees.iter();\n+        let mut last = None;\n+        while let Some(child) = iter.next() {\n+            let s = match child {\n+                TokenTree::Leaf(it) => {\n+                    let s = match it {\n+                        Leaf::Literal(it) => it.text.to_string(),\n+                        Leaf::Punct(it) => it.char.to_string(),\n+                        Leaf::Ident(it) => it.text.to_string(),\n+                    };\n+                    match (it, last) {\n+                        (Leaf::Ident(_), Some(&TokenTree::Leaf(Leaf::Ident(_)))) => {\n+                            \" \".to_string() + &s\n+                        }\n+                        (Leaf::Punct(_), Some(&TokenTree::Leaf(Leaf::Punct(punct)))) => {\n+                            if punct.spacing == Spacing::Alone {\n+                                \" \".to_string() + &s\n+                            } else {\n+                                s\n+                            }\n+                        }\n+                        _ => s,\n+                    }\n+                }\n+                TokenTree::Subtree(it) => it.as_debug_string(),\n+            };\n+            res.push_str(&s);\n+            last = Some(child);\n+        }\n+\n+        res.push_str(delim.1);\n+        res\n+    }\n+}\n+\n pub mod buffer;\n \n #[derive(Debug, PartialEq, Eq, Clone)]"}]}