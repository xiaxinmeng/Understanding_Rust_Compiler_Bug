{"sha": "24eb1b445dd878c12ca6503a9fa040179b94e614", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZWIxYjQ0NWRkODc4YzEyY2E2NTAzYTlmYTA0MDE3OWI5NGU2MTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-14T07:17:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-19T04:06:39Z"}, "message": "Implement a native mutex type\n\nThis mutex is built on top of pthreads for unix and the related windows apis on\nwindows. This is a straight port of the lock_and_signal type from C++ to rust.\nAlmost all operations on the type are unsafe, and it's definitely not\nrecommended for general use.\n\nCloses #9105", "tree": {"sha": "838edbe46508aea427ce043f0d0d7e5ef341d26a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/838edbe46508aea427ce043f0d0d7e5ef341d26a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24eb1b445dd878c12ca6503a9fa040179b94e614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24eb1b445dd878c12ca6503a9fa040179b94e614", "html_url": "https://github.com/rust-lang/rust/commit/24eb1b445dd878c12ca6503a9fa040179b94e614", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24eb1b445dd878c12ca6503a9fa040179b94e614/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab7fe9dd06e93986f6b11512031c891059474653", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7fe9dd06e93986f6b11512031c891059474653", "html_url": "https://github.com/rust-lang/rust/commit/ab7fe9dd06e93986f6b11512031c891059474653"}], "stats": {"total": 363, "additions": 361, "deletions": 2}, "files": [{"sha": "9b8c81979a90e31d98247f171cccc55f853a248c", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=24eb1b445dd878c12ca6503a9fa040179b94e614", "patch": "@@ -24,6 +24,7 @@ pub mod simd;\n #[cfg(not(test))]\n pub mod lang;\n pub mod sync;\n+pub mod mutex;\n pub mod atomics;\n pub mod raw;\n "}, {"sha": "5be9be7bf8a9907226a720c6442caabfadf005d9", "filename": "src/libstd/unstable/mutex.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=24eb1b445dd878c12ca6503a9fa040179b94e614", "patch": "@@ -0,0 +1,336 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A native mutex and condition variable type\n+//!\n+//! This module contains bindings to the platform's native mutex/condition\n+//! variable primitives. It provides a single type, `Mutex`, which can be\n+//! statically initialized via the `MUTEX_INIT` value. This object serves as both a\n+//! mutex and a condition variable simultaneously.\n+//!\n+//! The lock is lazily initialized, but it can only be unsafely destroyed. A\n+//! statically initialized lock doesn't necessarily have a time at which it can\n+//! get deallocated. For this reason, there is no `Drop` implementation of the\n+//! mutex, but rather the `destroy()` method must be invoked manually if\n+//! destruction of the mutex is desired.\n+//!\n+//! It is not recommended to use this type for idiomatic rust use. This type is\n+//! appropriate where no other options are available, but other rust concurrency\n+//! primitives should be used before this type.\n+//!\n+//! # Example\n+//!\n+//!     use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+//!\n+//!     // Use a statically initialized mutex\n+//!     static mut lock: Mutex = MUTEX_INIT;\n+//!\n+//!     unsafe {\n+//!         lock.lock();\n+//!         lock.unlock();\n+//!     }\n+//!\n+//!     // Use a normally initialied mutex\n+//!     let mut lock = Mutex::new();\n+//!     unsafe {\n+//!         lock.lock();\n+//!         lock.unlock();\n+//!         lock.destroy();\n+//!     }\n+\n+#[allow(non_camel_case_types)];\n+\n+use libc::c_void;\n+use unstable::atomics;\n+\n+pub struct Mutex {\n+    // pointers for the lock/cond handles, atomically updated\n+    priv lock: atomics::AtomicUint,\n+    priv cond: atomics::AtomicUint,\n+}\n+\n+pub static MUTEX_INIT: Mutex = Mutex {\n+    lock: atomics::INIT_ATOMIC_UINT,\n+    cond: atomics::INIT_ATOMIC_UINT,\n+};\n+\n+impl Mutex {\n+    /// Creates a new mutex, with the lock/condition variable pre-initialized\n+    pub unsafe fn new() -> Mutex {\n+        Mutex {\n+            lock: atomics::AtomicUint::new(imp::init_lock() as uint),\n+            cond: atomics::AtomicUint::new(imp::init_cond() as uint),\n+        }\n+    }\n+\n+    /// Creates a new copy of this mutex. This is an unsafe operation because\n+    /// there is no reference counting performed on this type.\n+    ///\n+    /// This function may only be called on mutexes which have had both the\n+    /// internal condition variable and lock initialized. This means that the\n+    /// mutex must have been created via `new`, or usage of it has already\n+    /// initialized the internal handles.\n+    ///\n+    /// This is a dangerous function to call as both this mutex and the returned\n+    /// mutex will share the same handles to the underlying mutex/condition\n+    /// variable. Care must be taken to ensure that deallocation happens\n+    /// accordingly.\n+    pub unsafe fn clone(&self) -> Mutex {\n+        let lock = self.lock.load(atomics::Relaxed);\n+        let cond = self.cond.load(atomics::Relaxed);\n+        assert!(lock != 0);\n+        assert!(cond != 0);\n+        Mutex {\n+            lock: atomics::AtomicUint::new(lock),\n+            cond: atomics::AtomicUint::new(cond),\n+        }\n+    }\n+\n+    /// Acquires this lock. This assumes that the current thread does not\n+    /// already hold the lock.\n+    pub unsafe fn lock(&mut self) { imp::lock(self.getlock()) }\n+\n+    /// Attempts to acquire the lock. The value returned is whether the lock was\n+    /// acquired or not\n+    pub unsafe fn trylock(&mut self) -> bool { imp::trylock(self.getlock()) }\n+\n+    /// Unlocks the lock. This assumes that the current thread already holds the\n+    /// lock.\n+    pub unsafe fn unlock(&mut self) { imp::unlock(self.getlock()) }\n+\n+    /// Block on the internal condition variable.\n+    ///\n+    /// This function assumes that the lock is already held\n+    pub unsafe fn wait(&mut self) { imp::wait(self.getcond(), self.getlock()) }\n+\n+    /// Signals a thread in `wait` to wake up\n+    pub unsafe fn signal(&mut self) { imp::signal(self.getcond()) }\n+\n+    /// This function is especially unsafe because there are no guarantees made\n+    /// that no other thread is currently holding the lock or waiting on the\n+    /// condition variable contained inside.\n+    pub unsafe fn destroy(&mut self) {\n+        imp::free_lock(self.lock.swap(0, atomics::Relaxed));\n+        imp::free_cond(self.cond.swap(0, atomics::Relaxed));\n+    }\n+\n+    unsafe fn getlock(&mut self) -> *c_void {\n+        match self.lock.load(atomics::Relaxed) {\n+            0 => {}\n+            n => return n as *c_void\n+        }\n+        let lock = imp::init_lock();\n+        match self.lock.compare_and_swap(0, lock, atomics::SeqCst) {\n+            0 => return lock as *c_void,\n+            _ => {}\n+        }\n+        imp::free_lock(lock);\n+        return self.lock.load(atomics::Relaxed) as *c_void;\n+    }\n+\n+    unsafe fn getcond(&mut self) -> *c_void {\n+        match self.cond.load(atomics::Relaxed) {\n+            0 => {}\n+            n => return n as *c_void\n+        }\n+        let cond = imp::init_cond();\n+        match self.cond.compare_and_swap(0, cond, atomics::SeqCst) {\n+            0 => return cond as *c_void,\n+            _ => {}\n+        }\n+        imp::free_cond(cond);\n+        return self.cond.load(atomics::Relaxed) as *c_void;\n+    }\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use libc::c_void;\n+    use libc;\n+    use ptr;\n+\n+    type pthread_mutex_t = libc::c_void;\n+    type pthread_mutexattr_t = libc::c_void;\n+    type pthread_cond_t = libc::c_void;\n+    type pthread_condattr_t = libc::c_void;\n+\n+    pub unsafe fn init_lock() -> uint {\n+        let block = libc::malloc(rust_pthread_mutex_t_size() as libc::size_t);\n+        assert!(!block.is_null());\n+        let n = pthread_mutex_init(block, ptr::null());\n+        assert_eq!(n, 0);\n+        return block as uint;\n+    }\n+\n+    pub unsafe fn init_cond() -> uint {\n+        let block = libc::malloc(rust_pthread_cond_t_size() as libc::size_t);\n+        assert!(!block.is_null());\n+        let n = pthread_cond_init(block, ptr::null());\n+        assert_eq!(n, 0);\n+        return block as uint;\n+    }\n+\n+    pub unsafe fn free_lock(h: uint) {\n+        let block = h as *c_void;\n+        assert_eq!(pthread_mutex_destroy(block), 0);\n+        libc::free(block);\n+    }\n+\n+    pub unsafe fn free_cond(h: uint) {\n+        let block = h as *c_void;\n+        assert_eq!(pthread_cond_destroy(block), 0);\n+        libc::free(block);\n+    }\n+\n+    pub unsafe fn lock(l: *pthread_mutex_t) {\n+        assert_eq!(pthread_mutex_lock(l), 0);\n+    }\n+\n+    pub unsafe fn trylock(l: *c_void) -> bool {\n+        pthread_mutex_trylock(l) == 0\n+    }\n+\n+    pub unsafe fn unlock(l: *pthread_mutex_t) {\n+        assert_eq!(pthread_mutex_unlock(l), 0);\n+    }\n+\n+    pub unsafe fn wait(cond: *pthread_cond_t, m: *pthread_mutex_t) {\n+        assert_eq!(pthread_cond_wait(cond, m), 0);\n+    }\n+\n+    pub unsafe fn signal(cond: *pthread_cond_t) {\n+        assert_eq!(pthread_cond_signal(cond), 0);\n+    }\n+\n+    extern {\n+        fn rust_pthread_mutex_t_size() -> libc::c_int;\n+        fn rust_pthread_cond_t_size() -> libc::c_int;\n+    }\n+\n+    extern {\n+        fn pthread_mutex_init(lock: *pthread_mutex_t,\n+                              attr: *pthread_mutexattr_t) -> libc::c_int;\n+        fn pthread_mutex_destroy(lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_init(cond: *pthread_cond_t,\n+                              attr: *pthread_condattr_t) -> libc::c_int;\n+        fn pthread_cond_destroy(cond: *pthread_cond_t) -> libc::c_int;\n+        fn pthread_mutex_lock(lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_mutex_trylock(lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_mutex_unlock(lock: *pthread_mutex_t) -> libc::c_int;\n+\n+        fn pthread_cond_wait(cond: *pthread_cond_t,\n+                             lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_signal(cond: *pthread_cond_t) -> libc::c_int;\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use libc;\n+    use libc::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES, c_void, DWORD, LPCSTR};\n+    use ptr;\n+    type LPCRITICAL_SECTION = *c_void;\n+    static SPIN_COUNT: DWORD = 4000;\n+\n+    pub unsafe fn init_lock() -> uint {\n+        let block = libc::malloc(rust_crit_section_size() as libc::size_t);\n+        assert!(!block.is_null());\n+        InitializeCriticalSectionAndSpinCount(block, SPIN_COUNT);\n+        return block as uint;\n+    }\n+\n+    pub unsafe fn init_cond() -> uint {\n+        return CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n+                            ptr::null()) as uint;\n+    }\n+\n+    pub unsafe fn free_lock(h: uint) {\n+        DeleteCriticalSection(h as LPCRITICAL_SECTION);\n+        libc::free(h as *c_void);\n+    }\n+\n+    pub unsafe fn free_cond(h: uint) {\n+        let block = h as HANDLE;\n+        libc::CloseHandle(block);\n+    }\n+\n+    pub unsafe fn lock(l: *c_void) {\n+        EnterCriticalSection(l as LPCRITICAL_SECTION)\n+    }\n+\n+    pub unsafe fn trylock(l: *c_void) -> bool {\n+        TryEnterCriticalSection(l as LPCRITICAL_SECTION) != 0\n+    }\n+\n+    pub unsafe fn unlock(l: *c_void) {\n+        LeaveCriticalSection(l as LPCRITICAL_SECTION)\n+    }\n+\n+    pub unsafe fn wait(cond: *c_void, m: *c_void) {\n+        unlock(m);\n+        WaitForSingleObject(cond as HANDLE, 0);\n+        lock(m);\n+    }\n+\n+    pub unsafe fn signal(cond: *c_void) {\n+        assert!(SetEvent(cond as HANDLE) != 0);\n+    }\n+\n+    extern {\n+        fn rust_crit_section_size() -> libc::c_int;\n+    }\n+\n+    extern \"system\" {\n+        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                        bManualReset: BOOL,\n+                        bInitialState: BOOL,\n+                        lpName: LPCSTR) -> HANDLE;\n+        fn InitializeCriticalSectionAndSpinCount(\n+                        lpCriticalSection: LPCRITICAL_SECTION,\n+                        dwSpinCount: DWORD) -> BOOL;\n+        fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+        fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+        fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+        fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;\n+        fn SetEvent(hEvent: HANDLE) -> BOOL;\n+        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{Mutex, MUTEX_INIT};\n+    use rt::thread::Thread;\n+\n+    #[test]\n+    fn somke_lock() {\n+        static mut lock: Mutex = MUTEX_INIT;\n+        unsafe {\n+            lock.lock();\n+            lock.unlock();\n+        }\n+    }\n+\n+    #[test]\n+    fn somke_cond() {\n+        static mut lock: Mutex = MUTEX_INIT;\n+        unsafe {\n+            let t = do Thread::start {\n+                lock.lock();\n+                lock.signal();\n+                lock.unlock();\n+            };\n+            lock.lock();\n+            lock.wait();\n+            lock.unlock();\n+            t.join();\n+        }\n+    }\n+}"}, {"sha": "28dd4b51a13138286175f850994fc17affd4ca54", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=24eb1b445dd878c12ca6503a9fa040179b94e614", "patch": "@@ -671,6 +671,27 @@ rust_win32_rand_release() {\n }\n \n #endif\n+\n+#if defined(__WIN32__)\n+\n+extern \"C\" CDECL int\n+rust_crit_section_size() { return sizeof(CRITICAL_SECTION); }\n+extern \"C\" CDECL int\n+rust_pthread_mutex_t_size() { return 0; }\n+extern \"C\" CDECL int\n+rust_pthread_cond_t_size() { return 0; }\n+\n+#else\n+\n+extern \"C\" CDECL int\n+rust_crit_section_size() { return 0; }\n+extern \"C\" CDECL int\n+rust_pthread_mutex_t_size() { return sizeof(pthread_mutex_t); }\n+extern \"C\" CDECL int\n+rust_pthread_cond_t_size() { return sizeof(pthread_cond_t); }\n+\n+#endif\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "d78584f33dfd830b01aa5d707a72a9f62bfd9c08", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/24eb1b445dd878c12ca6503a9fa040179b94e614/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=24eb1b445dd878c12ca6503a9fa040179b94e614", "patch": "@@ -73,5 +73,6 @@ rust_get_global_args_ptr\n rust_take_global_args_lock\n rust_drop_global_args_lock\n rust_get_test_int\n-rust_take_dlerror_lock\n-rust_drop_dlerror_lock\n+rust_pthread_mutex_t_size\n+rust_pthread_cond_t_size\n+rust_crit_section_size"}]}