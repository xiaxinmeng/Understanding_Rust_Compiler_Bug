{"sha": "ac134f7ca435551964996ee88319241cd3c7c110", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMTM0ZjdjYTQzNTU1MTk2NDk5NmVlODgzMTkyNDFjZDNjN2MxMTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-04T12:42:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-04T12:42:40Z"}, "message": "Auto merge of #21499 - P1start:issue-8706, r=huonw\n\nCloses #8706.", "tree": {"sha": "f79e098b6d2dd1bc2c8c9f249639980b6a2a7352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f79e098b6d2dd1bc2c8c9f249639980b6a2a7352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac134f7ca435551964996ee88319241cd3c7c110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac134f7ca435551964996ee88319241cd3c7c110", "html_url": "https://github.com/rust-lang/rust/commit/ac134f7ca435551964996ee88319241cd3c7c110", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac134f7ca435551964996ee88319241cd3c7c110/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3e1f77291803d26b2897c0953dce5cf7e70ab65", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e1f77291803d26b2897c0953dce5cf7e70ab65", "html_url": "https://github.com/rust-lang/rust/commit/c3e1f77291803d26b2897c0953dce5cf7e70ab65"}, {"sha": "d244f099116ce7628ed00f74bc2466de72268cf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d244f099116ce7628ed00f74bc2466de72268cf6", "html_url": "https://github.com/rust-lang/rust/commit/d244f099116ce7628ed00f74bc2466de72268cf6"}], "stats": {"total": 113, "additions": 90, "deletions": 23}, "files": [{"sha": "454209bdba2830943791dc2da4d790bbb973fa9c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ac134f7ca435551964996ee88319241cd3c7c110/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac134f7ca435551964996ee88319241cd3c7c110/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=ac134f7ca435551964996ee88319241cd3c7c110", "patch": "@@ -483,42 +483,61 @@ fn highlight_lines(err: &mut EmitterWriter,\n         // how many digits must be indent past?\n         while num > 0 { num /= 10; digits += 1; }\n \n-        // indent past |name:## | and the 0-offset column location\n-        let left = fm.name.len() + digits + lo.col.to_usize() + 3;\n         let mut s = String::new();\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n-        let skip = fm.name.len() + digits + 3;\n+        let skip = fm.name.width(false) + digits + 3;\n         for _ in 0..skip {\n             s.push(' ');\n         }\n         if let Some(orig) = fm.get_line(lines.lines[0]) {\n-            for pos in 0..left - skip {\n-                let cur_char = orig.as_bytes()[pos] as char;\n+            let mut col = skip;\n+            let mut lastc = ' ';\n+            let mut iter = orig.chars().enumerate();\n+            for (pos, ch) in iter.by_ref() {\n+                lastc = ch;\n+                if pos >= lo.col.to_usize() { break; }\n                 // Whenever a tab occurs on the previous line, we insert one on\n                 // the error-point-squiggly-line as well (instead of a space).\n                 // That way the squiggly line will usually appear in the correct\n                 // position.\n-                match cur_char {\n-                    '\\t' => s.push('\\t'),\n-                    _ => s.push(' '),\n-                };\n+                match ch {\n+                    '\\t' => {\n+                        col += 8 - col%8;\n+                        s.push('\\t');\n+                    },\n+                    c => for _ in 0..c.width(false).unwrap_or(0) {\n+                        col += 1;\n+                        s.push(' ');\n+                    },\n+                }\n             }\n-        }\n \n-        try!(write!(&mut err.dst, \"{}\", s));\n-        let mut s = String::from_str(\"^\");\n-        let hi = cm.lookup_char_pos(sp.hi);\n-        if hi.col != lo.col {\n-            // the ^ already takes up one space\n-            let num_squigglies = hi.col.to_usize() - lo.col.to_usize() - 1;\n-            for _ in 0..num_squigglies {\n-                s.push('~');\n+            try!(write!(&mut err.dst, \"{}\", s));\n+            let mut s = String::from_str(\"^\");\n+            let count = match lastc {\n+                // Most terminals have a tab stop every eight columns by default\n+                '\\t' => 8 - col%8,\n+                _ => lastc.width(false).unwrap_or(1),\n+            };\n+            col += count;\n+            s.extend(::std::iter::repeat('~').take(count - 1));\n+            let hi = cm.lookup_char_pos(sp.hi);\n+            if hi.col != lo.col {\n+                for (pos, ch) in iter {\n+                    if pos >= hi.col.to_usize() { break; }\n+                    let count = match ch {\n+                        '\\t' => 8 - col%8,\n+                        _ => ch.width(false).unwrap_or(0),\n+                    };\n+                    col += count;\n+                    s.extend(::std::iter::repeat('~').take(count));\n+                }\n             }\n+            try!(print_maybe_styled(err,\n+                                    &format!(\"{}\\n\", s)[],\n+                                    term::attr::ForegroundColor(lvl.color())));\n         }\n-        try!(print_maybe_styled(err,\n-                                &format!(\"{}\\n\", s)[],\n-                                term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n }\n@@ -559,12 +578,28 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     }\n     let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n     let hi = cm.lookup_char_pos(sp.hi);\n-    // Span seems to use half-opened interval, so subtract 1\n-    let skip = last_line_start.len() + hi.col.to_usize() - 1;\n+    let skip = last_line_start.width(false);\n     let mut s = String::new();\n     for _ in 0..skip {\n         s.push(' ');\n     }\n+    if let Some(orig) = fm.get_line(lines[0]) {\n+        let iter = orig.chars().enumerate();\n+        for (pos, ch) in iter {\n+            // Span seems to use half-opened interval, so subtract 1\n+            if pos >= hi.col.to_usize() - 1 { break; }\n+            // Whenever a tab occurs on the previous line, we insert one on\n+            // the error-point-squiggly-line as well (instead of a space).\n+            // That way the squiggly line will usually appear in the correct\n+            // position.\n+            match ch {\n+                '\\t' => s.push('\\t'),\n+                c => for _ in 0..c.width(false).unwrap_or(0) {\n+                    s.push(' ');\n+                },\n+            }\n+        }\n+    }\n     s.push('^');\n     s.push('\\n');\n     print_maybe_styled(w,"}, {"sha": "9ee7516c7baeb91eadcf31be2f3e4ba5d4ee3186", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ac134f7ca435551964996ee88319241cd3c7c110/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac134f7ca435551964996ee88319241cd3c7c110/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=ac134f7ca435551964996ee88319241cd3c7c110", "patch": "@@ -65,4 +65,36 @@ fn main() {\n                                                         .collect::<String>());\n         assert!(err.contains(expected_span.as_slice()));\n     }\n+\n+    // Test multi-column characters and tabs\n+    {\n+        let _ = write!(&mut File::create(&main_file).unwrap(),\n+                       r#\"extern \"\uf937\uf922\uf92ba\u0301\u0301\u0301\" fn foo() {{}} extern \"\uf937\uf922\uf92ba\u0301\u0301\" fn bar() {{}}\"#);\n+    }\n+\n+    // Extra characters. Every line is preceded by `filename:lineno <actual code>`\n+    let offset = main_file.as_str().unwrap().len() + 3;\n+\n+    let result = Command::new(\"sh\")\n+                         .arg(\"-c\")\n+                         .arg(format!(\"{} {}\",\n+                                      rustc,\n+                                      main_file.as_str()\n+                                               .unwrap()).as_slice())\n+                         .output().unwrap();\n+\n+    let err = String::from_utf8_lossy(result.error.as_slice());\n+\n+    // Test both the length of the snake and the leading spaces up to it\n+\n+    // First snake is 8 ~s long, with 7 preceding spaces (excluding file name/line offset)\n+    let expected_span = format!(\"\\n{}^{}\\n\",\n+                                repeat(\" \").take(offset + 7).collect::<String>(),\n+                                repeat(\"~\").take(8).collect::<String>());\n+    assert!(err.contains(expected_span.as_slice()));\n+    // Second snake is 8 ~s long, with 36 preceding spaces\n+    let expected_span = format!(\"\\n{}^{}\\n\",\n+                                repeat(\" \").take(offset + 36).collect::<String>(),\n+                                repeat(\"~\").take(8).collect::<String>());\n+    assert!(err.contains(expected_span.as_slice()));\n }"}]}