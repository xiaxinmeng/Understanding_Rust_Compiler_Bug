{"sha": "0081ef383489679e491d99a1978ded16e06906d3", "node_id": "C_kwDOAAsO6NoAKDAwODFlZjM4MzQ4OTY3OWU0OTFkOTlhMTk3OGRlZDE2ZTA2OTA2ZDM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-21T14:05:52Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-22T20:17:13Z"}, "message": "Use ItemTree for modules in attrs_query", "tree": {"sha": "dfeac335def979d885b995c852a5a376ee1d1e46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfeac335def979d885b995c852a5a376ee1d1e46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0081ef383489679e491d99a1978ded16e06906d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0081ef383489679e491d99a1978ded16e06906d3", "html_url": "https://github.com/rust-lang/rust/commit/0081ef383489679e491d99a1978ded16e06906d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0081ef383489679e491d99a1978ded16e06906d3/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f9a5825e0755fe3072679bb6ca59bf3672be343", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f9a5825e0755fe3072679bb6ca59bf3672be343", "html_url": "https://github.com/rust-lang/rust/commit/5f9a5825e0755fe3072679bb6ca59bf3672be343"}], "stats": {"total": 58, "additions": 32, "deletions": 26}, "files": [{"sha": "8a6b6f3effd2ed33e6f121a79f8bf816688b8125", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0081ef383489679e491d99a1978ded16e06906d3/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0081ef383489679e491d99a1978ded16e06906d3/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=0081ef383489679e491d99a1978ded16e06906d3", "patch": "@@ -374,30 +374,23 @@ impl AttrsWithOwner {\n                 let mod_data = &def_map[module.local_id];\n \n                 match mod_data.origin {\n-                    // FIXME: We should be able to leverage the item tree instead of parsing declaration here\n-                    // but we don't save the module's item tree id anywhere\n-                    ModuleOrigin::File { definition, declaration, .. } => {\n-                        let value = declaration.to_node(db.upcast());\n-                        let it = InFile { file_id: declaration.file_id, value };\n-                        let raw_attrs = RawAttrs::from_attrs_owner(\n-                            db,\n-                            it.as_ref().map(|it| it as &dyn ast::HasAttrs),\n-                        );\n+                    ModuleOrigin::File { definition, declaration_tree_id, .. } => {\n+                        let decl_attrs = declaration_tree_id\n+                            .item_tree(db)\n+                            .raw_attrs(AttrOwner::ModItem(declaration_tree_id.value.into()))\n+                            .clone();\n                         let tree = db.file_item_tree(definition.into());\n-                        raw_attrs.merge(tree.raw_attrs(AttrOwner::TopLevel).clone())\n+                        let def_attrs = tree.raw_attrs(AttrOwner::TopLevel).clone();\n+                        decl_attrs.merge(def_attrs)\n                     }\n                     ModuleOrigin::CrateRoot { definition } => {\n                         let tree = db.file_item_tree(definition.into());\n                         tree.raw_attrs(AttrOwner::TopLevel).clone()\n                     }\n-                    // FIXME: We should be able to leverage the item tree instead of parsing here\n-                    // but we don't save the module's item tree id anywhere\n-                    ModuleOrigin::Inline { definition } => RawAttrs::from_attrs_owner(\n-                        db,\n-                        InFile::new(definition.file_id, definition.to_node(db.upcast()))\n-                            .as_ref()\n-                            .map(|it| it as &dyn ast::HasAttrs),\n-                    ),\n+                    ModuleOrigin::Inline { definition_tree_id, .. } => definition_tree_id\n+                        .item_tree(db)\n+                        .raw_attrs(AttrOwner::ModItem(definition_tree_id.value.into()))\n+                        .clone(),\n                     ModuleOrigin::BlockExpr { block } => RawAttrs::from_attrs_owner(\n                         db,\n                         InFile::new(block.file_id, block.to_node(db.upcast()))"}, {"sha": "c67046dfdab55e10fdc72b8469adac10a06f8e87", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0081ef383489679e491d99a1978ded16e06906d3/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0081ef383489679e491d99a1978ded16e06906d3/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=0081ef383489679e491d99a1978ded16e06906d3", "patch": "@@ -70,7 +70,7 @@ use syntax::{ast, SmolStr};\n use crate::{\n     db::DefDatabase,\n     item_scope::{BuiltinShadowMode, ItemScope},\n-    item_tree::TreeId,\n+    item_tree::{ItemTreeId, Mod, TreeId},\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n     path::ModPath,\n     per_ns::PerNs,\n@@ -141,9 +141,11 @@ pub enum ModuleOrigin {\n     File {\n         is_mod_rs: bool,\n         declaration: AstId<ast::Module>,\n+        declaration_tree_id: ItemTreeId<Mod>,\n         definition: FileId,\n     },\n     Inline {\n+        definition_tree_id: ItemTreeId<Mod>,\n         definition: AstId<ast::Module>,\n     },\n     /// Pseudo-module introduced by a block scope (contains only inner items).\n@@ -186,7 +188,7 @@ impl ModuleOrigin {\n                 let sf = db.parse(file_id).tree();\n                 InFile::new(file_id.into(), ModuleSource::SourceFile(sf))\n             }\n-            ModuleOrigin::Inline { definition } => InFile::new(\n+            ModuleOrigin::Inline { definition, .. } => InFile::new(\n                 definition.file_id,\n                 ModuleSource::Module(definition.to_node(db.upcast())),\n             ),"}, {"sha": "743d130d020f7a889df7ffde5d37ca9d024478c7", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0081ef383489679e491d99a1978ded16e06906d3/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0081ef383489679e491d99a1978ded16e06906d3/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=0081ef383489679e491d99a1978ded16e06906d3", "patch": "@@ -1525,7 +1525,7 @@ impl ModCollector<'_, '_> {\n             };\n \n             match item {\n-                ModItem::Mod(m) => self.collect_module(&self.item_tree[m], &attrs),\n+                ModItem::Mod(m) => self.collect_module(m, &attrs),\n                 ModItem::Import(import_id) => {\n                     let imports = Import::from_use(\n                         db,\n@@ -1700,9 +1700,10 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n-    fn collect_module(&mut self, module: &Mod, attrs: &Attrs) {\n+    fn collect_module(&mut self, module_id: FileItemTreeId<Mod>, attrs: &Attrs) {\n         let path_attr = attrs.by_key(\"path\").string_value();\n         let is_macro_use = attrs.by_key(\"macro_use\").exists();\n+        let module = &self.item_tree[module_id];\n         match &module.kind {\n             // inline module, just recurse\n             ModKind::Inline { items } => {\n@@ -1711,6 +1712,7 @@ impl ModCollector<'_, '_> {\n                     AstId::new(self.file_id(), module.ast_id),\n                     None,\n                     &self.item_tree[module.visibility],\n+                    module_id,\n                 );\n \n                 if let Some(mod_dir) = self.mod_dir.descend_into_definition(&module.name, path_attr)\n@@ -1748,6 +1750,7 @@ impl ModCollector<'_, '_> {\n                                 ast_id,\n                                 Some((file_id, is_mod_rs)),\n                                 &self.item_tree[module.visibility],\n+                                module_id,\n                             );\n                             ModCollector {\n                                 def_collector: self.def_collector,\n@@ -1774,6 +1777,7 @@ impl ModCollector<'_, '_> {\n                             ast_id,\n                             None,\n                             &self.item_tree[module.visibility],\n+                            module_id,\n                         );\n                         self.def_collector.def_map.diagnostics.push(\n                             DefDiagnostic::unresolved_module(self.module_id, ast_id, candidates),\n@@ -1790,17 +1794,24 @@ impl ModCollector<'_, '_> {\n         declaration: AstId<ast::Module>,\n         definition: Option<(FileId, bool)>,\n         visibility: &crate::visibility::RawVisibility,\n+        mod_tree_id: FileItemTreeId<Mod>,\n     ) -> LocalModuleId {\n         let def_map = &mut self.def_collector.def_map;\n         let vis = def_map\n             .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n             .unwrap_or(Visibility::Public);\n         let modules = &mut def_map.modules;\n         let origin = match definition {\n-            None => ModuleOrigin::Inline { definition: declaration },\n-            Some((definition, is_mod_rs)) => {\n-                ModuleOrigin::File { declaration, definition, is_mod_rs }\n-            }\n+            None => ModuleOrigin::Inline {\n+                definition: declaration,\n+                definition_tree_id: ItemTreeId::new(self.tree_id, mod_tree_id),\n+            },\n+            Some((definition, is_mod_rs)) => ModuleOrigin::File {\n+                declaration,\n+                definition,\n+                is_mod_rs,\n+                declaration_tree_id: ItemTreeId::new(self.tree_id, mod_tree_id),\n+            },\n         };\n \n         let res = modules.alloc(ModuleData::new(origin, vis));"}]}