{"sha": "649b2164824c47419ffeffa7266f18a9cc84824e", "node_id": "C_kwDOAAsO6NoAKDY0OWIyMTY0ODI0YzQ3NDE5ZmZlZmZhNzI2NmYxOGE5Y2M4NDgyNGU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-23T13:36:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-23T13:39:02Z"}, "message": "add a flag to print a diagnostic when an outdated value is returned from an atomic load", "tree": {"sha": "40d81f277d083403ce6a714148e842556acbd7f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40d81f277d083403ce6a714148e842556acbd7f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/649b2164824c47419ffeffa7266f18a9cc84824e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/649b2164824c47419ffeffa7266f18a9cc84824e", "html_url": "https://github.com/rust-lang/rust/commit/649b2164824c47419ffeffa7266f18a9cc84824e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/649b2164824c47419ffeffa7266f18a9cc84824e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9aad98a3b61e77e31317c6fef86ffff6bac175a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9aad98a3b61e77e31317c6fef86ffff6bac175a", "html_url": "https://github.com/rust-lang/rust/commit/b9aad98a3b61e77e31317c6fef86ffff6bac175a"}], "stats": {"total": 62, "additions": 46, "deletions": 16}, "files": [{"sha": "fa235a45f5093e5a134739e4cc67f51b06fcfbb8", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/649b2164824c47419ffeffa7266f18a9cc84824e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/649b2164824c47419ffeffa7266f18a9cc84824e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=649b2164824c47419ffeffa7266f18a9cc84824e", "patch": "@@ -377,6 +377,9 @@ to Miri failing to detect cases of undefined behavior in a program.\n   happening and where in your code would be a good place to look for it.\n   Specifying this argument multiple times does not overwrite the previous\n   values, instead it appends its values to the list. Listing a tag multiple times has no effect.\n+* `-Zmiri-track-weak-memory-loads` shows a backtrace when weak memory emulation returns an outdated\n+  value from a load. This can help diagnose problems that disappear under\n+  `-Zmiri-disable-weak-memory-emulation`.\n \n [function ABI]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n "}, {"sha": "14694ac7b053678ed8d3546a2d780a0edf9b584b", "filename": "src/bin/miri.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=649b2164824c47419ffeffa7266f18a9cc84824e", "patch": "@@ -358,6 +358,8 @@ fn main() {\n             miri_config.isolated_op = miri::IsolatedOp::Allow;\n         } else if arg == \"-Zmiri-disable-weak-memory-emulation\" {\n             miri_config.weak_memory_emulation = false;\n+        } else if arg == \"-Zmiri-track-weak-memory-loads\" {\n+            miri_config.track_outdated_loads = true;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-isolation-error=\") {\n             if matches!(isolation_enabled, Some(false)) {\n                 panic!(\"-Zmiri-isolation-error cannot be used along with -Zmiri-disable-isolation\");"}, {"sha": "6ea87a82cb924be5079c026e6cc486a493a2dc98", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=649b2164824c47419ffeffa7266f18a9cc84824e", "patch": "@@ -1187,12 +1187,15 @@ pub struct GlobalState {\n \n     /// The timestamp of last SC write performed by each thread\n     last_sc_write: RefCell<VClock>,\n+\n+    /// Track when an outdated (weak memory) load happens.\n+    pub track_outdated_loads: bool,\n }\n \n impl GlobalState {\n     /// Create a new global state, setup with just thread-id=0\n     /// advanced to timestamp = 1.\n-    pub fn new() -> Self {\n+    pub fn new(config: &MiriConfig) -> Self {\n         let mut global_state = GlobalState {\n             multi_threaded: Cell::new(false),\n             ongoing_action_data_race_free: Cell::new(false),\n@@ -1203,6 +1206,7 @@ impl GlobalState {\n             terminated_threads: RefCell::new(FxHashMap::default()),\n             last_sc_fence: RefCell::new(VClock::default()),\n             last_sc_write: RefCell::new(VClock::default()),\n+            track_outdated_loads: config.track_outdated_loads,\n         };\n \n         // Setup the main-thread since it is not explicitly created:"}, {"sha": "317258a028d0b074b3bf01b18b23bc4098e48c6c", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=649b2164824c47419ffeffa7266f18a9cc84824e", "patch": "@@ -82,10 +82,7 @@ use rustc_const_eval::interpret::{\n };\n use rustc_data_structures::fx::FxHashMap;\n \n-use crate::{\n-    AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, Provenance, ThreadManager, VClock, VTimestamp,\n-    VectorIdx,\n-};\n+use crate::*;\n \n use super::{\n     data_race::{GlobalState as DataRaceState, ThreadClockSet},\n@@ -113,6 +110,13 @@ pub(super) struct StoreBuffer {\n     buffer: VecDeque<StoreElement>,\n }\n \n+/// Whether a load returned the latest value or not.\n+#[derive(PartialEq, Eq)]\n+enum LoadRecency {\n+    Latest,\n+    Outdated,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n struct StoreElement {\n     /// The identifier of the vector index, corresponding to a thread\n@@ -254,11 +258,11 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         is_seqcst: bool,\n         rng: &mut (impl rand::Rng + ?Sized),\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+    ) -> InterpResult<'tcx, (ScalarMaybeUninit<Provenance>, LoadRecency)> {\n         // Having a live borrow to store_buffer while calling validate_atomic_load is fine\n         // because the race detector doesn't touch store_buffer\n \n-        let store_elem = {\n+        let (store_elem, recency) = {\n             // The `clocks` we got here must be dropped before calling validate_atomic_load\n             // as the race detector will update it\n             let (.., clocks) = global.current_thread_state(thread_mgr);\n@@ -274,7 +278,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n \n         let (index, clocks) = global.current_thread_state(thread_mgr);\n         let loaded = store_elem.load_impl(index, &clocks);\n-        Ok(loaded)\n+        Ok((loaded, recency))\n     }\n \n     fn buffered_write(\n@@ -296,7 +300,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         is_seqcst: bool,\n         clocks: &ThreadClockSet,\n         rng: &mut R,\n-    ) -> &StoreElement {\n+    ) -> (&StoreElement, LoadRecency) {\n         use rand::seq::IteratorRandom;\n         let mut found_sc = false;\n         // FIXME: we want an inclusive take_while (stops after a false predicate, but\n@@ -359,9 +363,12 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n                 }\n             });\n \n-        candidates\n-            .choose(rng)\n-            .expect(\"store buffer cannot be empty, an element is populated on construction\")\n+        let chosen = candidates.choose(rng).expect(\"store buffer cannot be empty\");\n+        if std::ptr::eq(chosen, self.buffer.back().expect(\"store buffer cannot be empty\")) {\n+            (chosen, LoadRecency::Latest)\n+        } else {\n+            (chosen, LoadRecency::Outdated)\n+        }\n     }\n \n     /// ATOMIC STORE IMPL in the paper (except we don't need the location's vector clock)\n@@ -499,13 +506,16 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                     alloc_range(base_offset, place.layout.size),\n                     latest_in_mo,\n                 )?;\n-                let loaded = buffer.buffered_read(\n+                let (loaded, recency) = buffer.buffered_read(\n                     global,\n                     &this.machine.threads,\n                     atomic == AtomicReadOrd::SeqCst,\n                     &mut *rng,\n                     validate,\n                 )?;\n+                if global.track_outdated_loads && recency == LoadRecency::Outdated {\n+                    register_diagnostic(NonHaltingDiagnostic::WeakMemoryOutdatedLoad);\n+                }\n \n                 return Ok(loaded);\n             }"}, {"sha": "a378df0ad82b461b9bf749004f58dca0214797df", "filename": "src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=649b2164824c47419ffeffa7266f18a9cc84824e", "patch": "@@ -74,6 +74,7 @@ pub enum NonHaltingDiagnostic {\n     Int2Ptr {\n         details: bool,\n     },\n+    WeakMemoryOutdatedLoad,\n }\n \n /// Level of Miri specific diagnostics\n@@ -474,6 +475,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         format!(\"progress report: current operation being executed is here\"),\n                     Int2Ptr { .. } =>\n                         format!(\"integer-to-pointer cast\"),\n+                    WeakMemoryOutdatedLoad =>\n+                        format!(\"weak memory emulation: outdated value returned from load\"),\n                 };\n \n                 let (title, diag_level) = match e {\n@@ -485,7 +488,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     | CreatedCallId(..)\n                     | CreatedAlloc(..)\n                     | FreedAlloc(..)\n-                    | ProgressReport => (\"tracking was triggered\", DiagLevel::Note),\n+                    | ProgressReport\n+                    | WeakMemoryOutdatedLoad =>\n+                        (\"tracking was triggered\", DiagLevel::Note),\n                 };\n \n                 let helps = match e {"}, {"sha": "53264bd465914e943ba5bf4b405dcf73085d5117", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=649b2164824c47419ffeffa7266f18a9cc84824e", "patch": "@@ -102,6 +102,8 @@ pub struct MiriConfig {\n     pub data_race_detector: bool,\n     /// Determine if weak memory emulation should be enabled. Requires data race detection to be enabled\n     pub weak_memory_emulation: bool,\n+    /// Track when an outdated (weak memory) load happens.\n+    pub track_outdated_loads: bool,\n     /// Rate of spurious failures for compare_exchange_weak atomic operations,\n     /// between 0.0 and 1.0, defaulting to 0.8 (80% chance of failure).\n     pub cmpxchg_weak_failure_rate: f64,\n@@ -143,6 +145,7 @@ impl Default for MiriConfig {\n             tracked_alloc_ids: HashSet::default(),\n             data_race_detector: true,\n             weak_memory_emulation: true,\n+            track_outdated_loads: false,\n             cmpxchg_weak_failure_rate: 0.8, // 80%\n             measureme_out: None,\n             panic_on_unsupported: false,"}, {"sha": "c77de4ec51ff2a2e11cb3ded9f0f094715986271", "filename": "src/machine.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b2164824c47419ffeffa7266f18a9cc84824e/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=649b2164824c47419ffeffa7266f18a9cc84824e", "patch": "@@ -376,8 +376,11 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n         } else {\n             None\n         };\n-        let data_race =\n-            if config.data_race_detector { Some(data_race::GlobalState::new()) } else { None };\n+        let data_race = if config.data_race_detector {\n+            Some(data_race::GlobalState::new(config))\n+        } else {\n+            None\n+        };\n         Evaluator {\n             stacked_borrows,\n             data_race,"}]}