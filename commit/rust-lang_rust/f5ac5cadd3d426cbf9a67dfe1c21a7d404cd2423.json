{"sha": "f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1YWM1Y2FkZDNkNDI2Y2JmOWE2N2RmZTFjMjFhN2Q0MDRjZDI0MjM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2021-09-12T10:44:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-12T10:44:56Z"}, "message": "Rollup merge of #88709 - BoxyUwU:thir-abstract-const, r=lcnr\n\ngeneric_const_exprs: use thir for abstract consts instead of mir\n\nChanges `AbstractConst` building to use `thir` instead of `mir` so that there's less chance of consts unifying when they shouldn't because lowering to mir dropped information (see `abstract-consts-as-cast-5.rs` test)\n\nr? `@lcnr`", "tree": {"sha": "6309929aa2d74a733e154b06a113e0336801f450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6309929aa2d74a733e154b06a113e0336801f450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhPdooCRBK7hj4Ov3rIwAAl3UIAHyiSlJI3i0mcvIp71J1U3A3\nqbUr1hdbzpUyT0P4wF7Tk4P06JdRcZ2FFfDI3uU6H2gDyEjSyj6vx4aB7KCLJqvB\nzME3rt8A/wcuOVftvWEBUFFUW3/aNQDq/hj4cjRjqusVWSer7Wp0wINxOSUdz8Yg\n31gvEuEs8essUsRkZX7ZQcrSKnQ0fdhE8F8cRqWPZaoF0LlYGJNo7i5enc1Jhtek\nCgGDfkU+CWgNL/S5yeinOjdOwYW71HpJTDtFKPMzqeDWds/rXvLmoPKfsr/MQe7e\nPPiGGpSuCKYd95+qpC8TACe6F5ZsCvclxpfgepWC6r/a/f5voGhKX2hswUhMMTY=\n=LM1W\n-----END PGP SIGNATURE-----\n", "payload": "tree 6309929aa2d74a733e154b06a113e0336801f450\nparent a8e3afe3720cc4772aa49e1f7f494c60b81f07a1\nparent 8295e4a6cfb12ce74c480172c2854f76d1428b8b\nauthor Manish Goregaokar <manishsmail@gmail.com> 1631443496 -0700\ncommitter GitHub <noreply@github.com> 1631443496 -0700\n\nRollup merge of #88709 - BoxyUwU:thir-abstract-const, r=lcnr\n\ngeneric_const_exprs: use thir for abstract consts instead of mir\n\nChanges `AbstractConst` building to use `thir` instead of `mir` so that there's less chance of consts unifying when they shouldn't because lowering to mir dropped information (see `abstract-consts-as-cast-5.rs` test)\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "html_url": "https://github.com/rust-lang/rust/commit/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8e3afe3720cc4772aa49e1f7f494c60b81f07a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e3afe3720cc4772aa49e1f7f494c60b81f07a1", "html_url": "https://github.com/rust-lang/rust/commit/a8e3afe3720cc4772aa49e1f7f494c60b81f07a1"}, {"sha": "8295e4a6cfb12ce74c480172c2854f76d1428b8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8295e4a6cfb12ce74c480172c2854f76d1428b8b", "html_url": "https://github.com/rust-lang/rust/commit/8295e4a6cfb12ce74c480172c2854f76d1428b8b"}], "stats": {"total": 717, "additions": 351, "deletions": 366}, "files": [{"sha": "2a0332a11242ee757e4cd3ebb45ff3ab034b98fc", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -26,6 +26,7 @@ use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, Body, Promoted};\n+use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt, Visibility};\n use rustc_serialize::{opaque, Decodable, Decoder};\n@@ -541,7 +542,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n         ty::codec::RefDecodable::decode(d)\n     }\n@@ -1196,14 +1197,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_mir_abstract_const(\n+    fn get_thir_abstract_const(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         self.root\n             .tables\n-            .mir_abstract_consts\n+            .thir_abstract_consts\n             .get(self, id)\n             .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }"}, {"sha": "50074803bbeef140c1dfda3f6bb1c70145362740", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -116,7 +116,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n     mir_for_ctfe => { tcx.arena.alloc(cdata.get_mir_for_ctfe(tcx, def_id.index)) }\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n-    mir_abstract_const => { cdata.get_mir_abstract_const(tcx, def_id.index) }\n+    thir_abstract_const => { cdata.get_thir_abstract_const(tcx, def_id.index) }\n     unused_generic_params => { cdata.get_unused_generic_params(def_id.index) }\n     const_param_default => { tcx.mk_const(cdata.get_const_param_default(tcx, def_id.index)) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }"}, {"sha": "1b24e5eae98fba84fb0961609096aeb36a249d42", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -23,6 +23,7 @@ use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportLevel,\n };\n use rustc_middle::mir::interpret;\n+use rustc_middle::thir;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n@@ -344,7 +345,7 @@ impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         (**self).encode(s)\n     }\n@@ -1297,9 +1298,10 @@ impl EncodeContext<'a, 'tcx> {\n             if encode_const {\n                 record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- self.tcx.mir_for_ctfe(def_id));\n \n-                let abstract_const = self.tcx.mir_abstract_const(def_id);\n+                // FIXME(generic_const_exprs): this feels wrong to have in `encode_mir`\n+                let abstract_const = self.tcx.thir_abstract_const(def_id);\n                 if let Ok(Some(abstract_const)) = abstract_const {\n-                    record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n+                    record!(self.tables.thir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n                 }\n             }\n             record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));"}, {"sha": "575ab04ab24c256d1adc8d6580a56a92573d5034", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir;\n+use rustc_middle::thir;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n@@ -305,7 +306,7 @@ define_tables! {\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n-    mir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [mir::abstract_const::Node<'tcx>])>,\n+    thir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n     const_defaults: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a"}, {"sha": "1ef10241143b83ed0ca19f0c51abff8f84ff0419", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a8e3afe3720cc4772aa49e1f7f494c60b81f07a1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e3afe3720cc4772aa49e1f7f494c60b81f07a1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=a8e3afe3720cc4772aa49e1f7f494c60b81f07a1", "patch": "@@ -1,38 +0,0 @@\n-//! A subset of a mir body used for const evaluatability checking.\n-use crate::mir::{self, CastKind};\n-use crate::ty::{self, Ty};\n-\n-rustc_index::newtype_index! {\n-    /// An index into an `AbstractConst`.\n-    pub struct NodeId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"n{}\",\n-    }\n-}\n-\n-/// A node of an `AbstractConst`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum Node<'tcx> {\n-    Leaf(&'tcx ty::Const<'tcx>),\n-    Binop(mir::BinOp, NodeId, NodeId),\n-    UnaryOp(mir::UnOp, NodeId),\n-    FunctionCall(NodeId, &'tcx [NodeId]),\n-    Cast(CastKind, NodeId, Ty<'tcx>),\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum NotConstEvaluatable {\n-    Error(rustc_errors::ErrorReported),\n-    MentionsInfer,\n-    MentionsParam,\n-}\n-\n-impl From<rustc_errors::ErrorReported> for NotConstEvaluatable {\n-    fn from(e: rustc_errors::ErrorReported) -> NotConstEvaluatable {\n-        NotConstEvaluatable::Error(e)\n-    }\n-}\n-\n-TrivialTypeFoldableAndLiftImpls! {\n-    NotConstEvaluatable,\n-}"}, {"sha": "ebdf354b90538c83091ce9e2d4f3edb5bd0b0ffa", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -40,7 +40,6 @@ use self::graph_cyclic_cache::GraphIsCyclicCache;\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n-pub mod abstract_const;\n pub mod coverage;\n mod generic_graph;\n pub mod generic_graphviz;"}, {"sha": "567f65e83d98c5fa3e9e934e028cb2c162d47b35", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -1,6 +1,6 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{abstract_const, Body, Promoted};\n+use crate::mir::{Body, Promoted};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n@@ -431,16 +431,4 @@ impl<'tcx> TyCtxt<'tcx> {\n             self.mir_for_ctfe(def.did)\n         }\n     }\n-\n-    #[inline]\n-    pub fn mir_abstract_const_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<DefId>,\n-    ) -> Result<Option<&'tcx [abstract_const::Node<'tcx>]>, ErrorReported> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            self.mir_abstract_const_of_const_arg((did, param_did))\n-        } else {\n-            self.mir_abstract_const(def.did)\n-        }\n-    }\n }"}, {"sha": "5748e5319e0a6c8a4cd365fc3f6eaf4cdc0a8e52", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -303,17 +303,17 @@ rustc_queries! {\n     }\n \n     /// Try to build an abstract representation of the given constant.\n-    query mir_abstract_const(\n+    query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         desc {\n             |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n         }\n     }\n     /// Try to build an abstract representation of the given constant.\n-    query mir_abstract_const_of_const_arg(\n+    query thir_abstract_const_of_const_arg(\n         key: (LocalDefId, DefId)\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         desc {\n             |tcx|\n             \"building an abstract representation for the const argument {}\","}, {"sha": "8d6fd1e729d3b52b5e4ec75dc6bd775317101924", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -33,6 +33,9 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n+pub mod abstract_const;\n+pub mod visit;\n+\n newtype_index! {\n     /// An index to an [`Arm`] stored in [`Thir::arms`]\n     #[derive(HashStable)]"}, {"sha": "f80beadd6e5515e40d9f956d63301432ecb88782", "filename": "compiler/rustc_middle/src/thir/abstract_const.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -0,0 +1,61 @@\n+//! A subset of a mir body used for const evaluatability checking.\n+use crate::mir;\n+use crate::ty::{self, Ty, TyCtxt};\n+use rustc_errors::ErrorReported;\n+\n+rustc_index::newtype_index! {\n+    /// An index into an `AbstractConst`.\n+    pub struct NodeId {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"n{}\",\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum CastKind {\n+    /// thir::ExprKind::As\n+    As,\n+    /// thir::ExprKind::Use\n+    Use,\n+}\n+\n+/// A node of an `AbstractConst`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum Node<'tcx> {\n+    Leaf(&'tcx ty::Const<'tcx>),\n+    Binop(mir::BinOp, NodeId, NodeId),\n+    UnaryOp(mir::UnOp, NodeId),\n+    FunctionCall(NodeId, &'tcx [NodeId]),\n+    Cast(CastKind, NodeId, Ty<'tcx>),\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum NotConstEvaluatable {\n+    Error(ErrorReported),\n+    MentionsInfer,\n+    MentionsParam,\n+}\n+\n+impl From<ErrorReported> for NotConstEvaluatable {\n+    fn from(e: ErrorReported) -> NotConstEvaluatable {\n+        NotConstEvaluatable::Error(e)\n+    }\n+}\n+\n+TrivialTypeFoldableAndLiftImpls! {\n+    NotConstEvaluatable,\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    #[inline]\n+    pub fn thir_abstract_const_opt_const_arg(\n+        self,\n+        def: ty::WithOptConstParam<rustc_hir::def_id::DefId>,\n+    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorReported> {\n+        if let Some((did, param_did)) = def.as_const_arg() {\n+            self.thir_abstract_const_of_const_arg((did, param_did))\n+        } else {\n+            self.thir_abstract_const(def.did)\n+        }\n+    }\n+}"}, {"sha": "7fc15e02fcd307511041e4743d8e851ca78382e4", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -1,4 +1,6 @@\n-use rustc_middle::thir::{self, *};\n+use super::{\n+    Arm, Block, Expr, ExprKind, Guard, InlineAsmOperand, Pat, PatKind, Stmt, StmtKind, Thir,\n+};\n use rustc_middle::ty::Const;\n \n pub trait Visitor<'a, 'tcx: 'a>: Sized {\n@@ -101,7 +103,7 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n                 visitor.visit_expr(&visitor.thir()[field]);\n             }\n         }\n-        Adt(box thir::Adt {\n+        Adt(box crate::thir::Adt {\n             ref fields,\n             ref base,\n             adt_def: _,", "previous_filename": "compiler/rustc_mir_build/src/thir/visit.rs"}, {"sha": "e21a2d1034cdd3e923e8bba1838fc515dca6832a", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -9,7 +9,7 @@ pub mod specialization_graph;\n mod structural_impls;\n \n use crate::infer::canonical::Canonical;\n-use crate::mir::abstract_const::NotConstEvaluatable;\n+use crate::thir::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n "}, {"sha": "8b70692960df9374645d95e5ab188486c04a26db", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -12,6 +12,7 @@ use crate::mir::{\n     self,\n     interpret::{AllocId, Allocation},\n };\n+use crate::thir;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, List, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n@@ -362,7 +363,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>,\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::Node<'tcx>] {\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::Node<'tcx>] {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         Ok(decoder.tcx().arena.alloc_from_iter(\n             (0..decoder.read_usize()?)\n@@ -372,7 +373,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::N\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::NodeId] {\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::NodeId] {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         Ok(decoder.tcx().arena.alloc_from_iter(\n             (0..decoder.read_usize()?)"}, {"sha": "0ee740a6463593de96e159b1ffd434919aaa75d8", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -47,10 +47,12 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     // Ensure unsafeck is ran before we steal the THIR.\n     match def {\n         ty::WithOptConstParam { did, const_param_did: Some(const_param_did) } => {\n-            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did))\n+            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did));\n+            tcx.ensure().thir_abstract_const_of_const_arg((did, const_param_did));\n         }\n         ty::WithOptConstParam { did, const_param_did: None } => {\n-            tcx.ensure().thir_check_unsafety(did)\n+            tcx.ensure().thir_check_unsafety(did);\n+            tcx.ensure().thir_abstract_const(did);\n         }\n     }\n "}, {"sha": "0e82b187201422d4983f105718266d74e946fb1d", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -1,5 +1,5 @@\n use crate::build::ExprCategory;\n-use crate::thir::visit::{self, Visitor};\n+use rustc_middle::thir::visit::{self, Visitor};\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;"}, {"sha": "ddbe1b0b69c1eb9dba9686063215b7c4086f9618", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -11,4 +11,3 @@ crate mod cx;\n crate mod pattern;\n \n mod util;\n-pub mod visit;"}, {"sha": "90d7cbee976d0d1dcbcec069bcb6eb627da1eb9f", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -306,7 +306,6 @@ fn mir_promoted(\n     // this point, before we steal the mir-const result.\n     // Also this means promotion can rely on all const checks having been done.\n     let _ = tcx.mir_const_qualif_opt_const_arg(def);\n-    let _ = tcx.mir_abstract_const_opt_const_arg(def.to_global());\n     let mut body = tcx.mir_const(def).steal();\n \n     let mut required_consts = Vec::new();"}, {"sha": "391e43054239d2d9929acd6c89ab01eb9989a357", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -19,8 +19,8 @@ use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc_middle::mir::abstract_const::Node as ACNode;\n use rustc_middle::span_bug;\n+use rustc_middle::thir::abstract_const::Node as ACNode;\n use rustc_middle::ty::fold::TypeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{InternalSubsts, Subst};"}, {"sha": "bfd36bfb2db2321902c5c09ba6bcdc14d44cdd8f", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -9,6 +9,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret};\n+use rustc_middle::thir;\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n@@ -921,7 +922,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         RefDecodable::decode(d)\n     }"}, {"sha": "24fa5007f1ecdc446f528a307edd28f11ec0efd7", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 167, "deletions": 258, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -6,16 +6,16 @@\n //! this is not as easy.\n //!\n //! In this case we try to build an abstract representation of this constant using\n-//! `mir_abstract_const` which can then be checked for structural equality with other\n+//! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::mir::abstract_const::{Node, NodeId, NotConstEvaluatable};\n+use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::mir::{self, Rvalue, StatementKind, TerminatorKind};\n+use rustc_middle::thir;\n+use rustc_middle::thir::abstract_const::{self, Node, NodeId, NotConstEvaluatable};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n@@ -196,7 +196,7 @@ impl<'tcx> AbstractConst<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         uv: ty::Unevaluated<'tcx, ()>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n-        let inner = tcx.mir_abstract_const_opt_const_arg(uv.def)?;\n+        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n         debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n         Ok(inner.map(|inner| AbstractConst { inner, substs: uv.substs(tcx) }))\n     }\n@@ -223,35 +223,24 @@ impl<'tcx> AbstractConst<'tcx> {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-struct WorkNode<'tcx> {\n-    node: Node<'tcx>,\n-    span: Span,\n-    used: bool,\n-}\n-\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    body: &'a mir::Body<'tcx>,\n+    body_id: thir::ExprId,\n+    body: &'a thir::Thir<'tcx>,\n     /// The current WIP node tree.\n-    ///\n-    /// We require all nodes to be used in the final abstract const,\n-    /// so we store this here. Note that we also consider nodes as used\n-    /// if they are mentioned in an assert, so some used nodes are never\n-    /// actually reachable by walking the [`AbstractConst`].\n-    nodes: IndexVec<NodeId, WorkNode<'tcx>>,\n-    locals: IndexVec<mir::Local, NodeId>,\n-    /// We only allow field accesses if they access\n-    /// the result of a checked operation.\n-    checked_op_locals: BitSet<mir::Local>,\n+    nodes: IndexVec<NodeId, Node<'tcx>>,\n }\n \n impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n+    fn root_span(&self) -> Span {\n+        self.body.exprs[self.body_id].span\n+    }\n+\n     fn error(&mut self, span: Option<Span>, msg: &str) -> Result<!, ErrorReported> {\n         self.tcx\n             .sess\n-            .struct_span_err(self.body.span, \"overly complex generic constant\")\n-            .span_label(span.unwrap_or(self.body.span), msg)\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span.unwrap_or(self.root_span()), msg)\n             .help(\"consider moving this anonymous constant into a `const` function\")\n             .emit();\n \n@@ -260,98 +249,49 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n+        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n     ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorReported> {\n-        let mut builder = AbstractConstBuilder {\n-            tcx,\n-            body,\n-            nodes: IndexVec::new(),\n-            locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n-            checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n-        };\n-\n-        // We don't have to look at concrete constants, as we\n-        // can just evaluate them.\n-        if !body.is_polymorphic {\n-            return Ok(None);\n-        }\n+        let builder = AbstractConstBuilder { tcx, body_id, body, nodes: IndexVec::new() };\n \n-        // We only allow consts without control flow, so\n-        // we check for cycles here which simplifies the\n-        // rest of this implementation.\n-        if body.is_cfg_cyclic() {\n-            builder.error(None, \"cyclic anonymous constants are forbidden\")?;\n+        struct IsThirPolymorphic<'a, 'tcx> {\n+            is_poly: bool,\n+            thir: &'a thir::Thir<'tcx>,\n+            tcx: TyCtxt<'tcx>,\n         }\n \n-        Ok(Some(builder))\n-    }\n-\n-    fn add_node(&mut self, node: Node<'tcx>, span: Span) -> NodeId {\n-        // Mark used nodes.\n-        match node {\n-            Node::Leaf(_) => (),\n-            Node::Binop(_, lhs, rhs) => {\n-                self.nodes[lhs].used = true;\n-                self.nodes[rhs].used = true;\n-            }\n-            Node::UnaryOp(_, input) => {\n-                self.nodes[input].used = true;\n-            }\n-            Node::FunctionCall(func, nodes) => {\n-                self.nodes[func].used = true;\n-                nodes.iter().for_each(|&n| self.nodes[n].used = true);\n+        use thir::visit;\n+        impl<'a, 'tcx: 'a> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n+            fn thir(&self) -> &'a thir::Thir<'tcx> {\n+                &self.thir\n             }\n-            Node::Cast(_, operand, _) => {\n-                self.nodes[operand].used = true;\n+\n+            fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n+                self.is_poly |= expr.ty.definitely_has_param_types_or_consts(self.tcx);\n+                if self.is_poly == false {\n+                    visit::walk_expr(self, expr)\n+                }\n             }\n-        }\n \n-        // Nodes start as unused.\n-        self.nodes.push(WorkNode { node, span, used: false })\n-    }\n+            fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n+                self.is_poly |= pat.ty.definitely_has_param_types_or_consts(self.tcx);\n+                if self.is_poly == false {\n+                    visit::walk_pat(self, pat);\n+                }\n+            }\n \n-    fn place_to_local(\n-        &mut self,\n-        span: Span,\n-        p: &mir::Place<'tcx>,\n-    ) -> Result<mir::Local, ErrorReported> {\n-        const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n-        // Do not allow any projections.\n-        //\n-        // One exception are field accesses on the result of checked operations,\n-        // which are required to support things like `1 + 2`.\n-        if let Some(p) = p.as_local() {\n-            debug_assert!(!self.checked_op_locals.contains(p));\n-            Ok(p)\n-        } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n-            // Only allow field accesses if the given local\n-            // contains the result of a checked operation.\n-            if self.checked_op_locals.contains(p.local) {\n-                Ok(p.local)\n-            } else {\n-                self.error(Some(span), \"unsupported projection\")?;\n+            fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) {\n+                self.is_poly |= ct.definitely_has_param_types_or_consts(self.tcx);\n             }\n-        } else {\n-            self.error(Some(span), \"unsupported projection\")?;\n         }\n-    }\n \n-    fn operand_to_node(\n-        &mut self,\n-        span: Span,\n-        op: &mir::Operand<'tcx>,\n-    ) -> Result<NodeId, ErrorReported> {\n-        debug!(\"operand_to_node: op={:?}\", op);\n-        match op {\n-            mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                let local = self.place_to_local(span, p)?;\n-                Ok(self.locals[local])\n-            }\n-            mir::Operand::Constant(ct) => match ct.literal {\n-                mir::ConstantKind::Ty(ct) => Ok(self.add_node(Node::Leaf(ct), span)),\n-                mir::ConstantKind::Val(..) => self.error(Some(span), \"unsupported constant\")?,\n-            },\n+        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body, tcx };\n+        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n+        debug!(\"AbstractConstBuilder: is_poly={}\", is_poly_vis.is_poly);\n+        if is_poly_vis.is_poly == false {\n+            return Ok(None);\n         }\n+\n+        Ok(Some(builder))\n     }\n \n     /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n@@ -373,170 +313,126 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n-        debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n-        let span = stmt.source_info.span;\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = self.place_to_local(span, place)?;\n-                match *rvalue {\n-                    Rvalue::Use(ref operand) => {\n-                        self.locals[local] = self.operand_to_node(span, operand)?;\n-                        Ok(())\n-                    }\n-                    Rvalue::BinaryOp(op, box (ref lhs, ref rhs)) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(span, lhs)?;\n-                        let rhs = self.operand_to_node(span, rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n-                        if op.is_checkable() {\n-                            bug!(\"unexpected unchecked checkable binary operation\");\n-                        } else {\n-                            Ok(())\n-                        }\n-                    }\n-                    Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs))\n-                        if Self::check_binop(op) =>\n-                    {\n-                        let lhs = self.operand_to_node(span, lhs)?;\n-                        let rhs = self.operand_to_node(span, rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n-                        self.checked_op_locals.insert(local);\n-                        Ok(())\n-                    }\n-                    Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(span, operand)?;\n-                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand), span);\n-                        Ok(())\n-                    }\n-                    Rvalue::Cast(cast_kind, ref operand, ty) => {\n-                        let operand = self.operand_to_node(span, operand)?;\n-                        self.locals[local] =\n-                            self.add_node(Node::Cast(cast_kind, operand, ty), span);\n-                        Ok(())\n-                    }\n-                    _ => self.error(Some(span), \"unsupported rvalue\")?,\n-                }\n-            }\n-            // These are not actually relevant for us here, so we can ignore them.\n-            StatementKind::AscribeUserType(..)\n-            | StatementKind::StorageLive(_)\n-            | StatementKind::StorageDead(_) => Ok(()),\n-            _ => self.error(Some(stmt.source_info.span), \"unsupported statement\")?,\n-        }\n-    }\n-\n-    /// Possible return values:\n-    ///\n-    /// - `None`: unsupported terminator, stop building\n-    /// - `Some(None)`: supported terminator, finish building\n-    /// - `Some(Some(block))`: support terminator, build `block` next\n-    fn build_terminator(\n-        &mut self,\n-        terminator: &mir::Terminator<'tcx>,\n-    ) -> Result<Option<mir::BasicBlock>, ErrorReported> {\n-        debug!(\"AbstractConstBuilder: terminator={:?}\", terminator);\n-        match terminator.kind {\n-            TerminatorKind::Goto { target } => Ok(Some(target)),\n-            TerminatorKind::Return => Ok(None),\n-            TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                destination: Some((ref place, target)),\n-                // We do not care about `cleanup` here. Any branch which\n-                // uses `cleanup` will fail const-eval and they therefore\n-                // do not matter when checking for const evaluatability.\n-                //\n-                // Do note that even if `panic::catch_unwind` is made const,\n-                // we still do not have to care about this, as we do not look\n-                // into functions.\n-                cleanup: _,\n-                // Do not allow overloaded operators for now,\n-                // we probably do want to allow this in the future.\n-                //\n-                // This is currently fairly irrelevant as it requires `const Trait`s.\n-                from_hir_call: true,\n-                fn_span,\n-            } => {\n-                let local = self.place_to_local(fn_span, place)?;\n-                let func = self.operand_to_node(fn_span, func)?;\n-                let args = self.tcx.arena.alloc_from_iter(\n-                    args.iter()\n-                        .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n-                        .collect::<Result<Vec<NodeId>, _>>()?,\n-                );\n-                self.locals[local] = self.add_node(Node::FunctionCall(func, args), fn_span);\n-                Ok(Some(target))\n-            }\n-            TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n-                let p = match cond {\n-                    mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n-                    mir::Operand::Constant(_) => bug!(\"unexpected assert\"),\n-                };\n-\n-                const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n-                debug!(\"proj: {:?}\", p.projection);\n-                if let Some(p) = p.as_local() {\n-                    debug_assert!(!self.checked_op_locals.contains(p));\n-                    // Mark locals directly used in asserts as used.\n-                    //\n-                    // This is needed because division does not use `CheckedBinop` but instead\n-                    // adds an explicit assert for `divisor != 0`.\n-                    self.nodes[self.locals[p]].used = true;\n-                    return Ok(Some(target));\n-                } else if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n-                    // Only allow asserts checking the result of a checked operation.\n-                    if self.checked_op_locals.contains(p.local) {\n-                        return Ok(Some(target));\n-                    }\n-                }\n-\n-                self.error(Some(terminator.source_info.span), \"unsupported assertion\")?;\n-            }\n-            _ => self.error(Some(terminator.source_info.span), \"unsupported terminator\")?,\n-        }\n-    }\n-\n-    /// Builds the abstract const by walking the mir from start to finish\n-    /// and bailing out when encountering an unsupported operation.\n+    /// Builds the abstract const by walking the thir and bailing out when\n+    /// encountering an unspported operation.\n     fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorReported> {\n-        let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n-        // We checked for a cyclic cfg above, so this should terminate.\n-        loop {\n-            debug!(\"AbstractConstBuilder: block={:?}\", block);\n-            for stmt in block.statements.iter() {\n-                self.build_statement(stmt)?;\n-            }\n+        debug!(\"Abstractconstbuilder::build: body={:?}\", &*self.body);\n+        self.recurse_build(self.body_id)?;\n \n-            if let Some(next) = self.build_terminator(block.terminator())? {\n-                block = &self.body.basic_blocks()[next];\n-            } else {\n-                break;\n-            }\n-        }\n-\n-        assert_eq!(self.locals[mir::RETURN_PLACE], self.nodes.last().unwrap());\n         for n in self.nodes.iter() {\n-            if let Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(ct), ty: _ }) = n.node {\n+            if let Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(ct), ty: _ }) = n {\n                 // `AbstractConst`s should not contain any promoteds as they require references which\n                 // are not allowed.\n                 assert_eq!(ct.promoted, None);\n             }\n         }\n \n-        self.nodes[self.locals[mir::RETURN_PLACE]].used = true;\n-        if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n-            self.error(Some(unused.span), \"dead code\")?;\n-        }\n+        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n+    }\n \n-        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter().map(|n| n.node)))\n+    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorReported> {\n+        use thir::ExprKind;\n+        let node = &self.body.exprs[node];\n+        debug!(\"recurse_build: node={:?}\", node);\n+        Ok(match &node.kind {\n+            // I dont know if handling of these 3 is correct\n+            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n+            &ExprKind::PlaceTypeAscription { source, .. } |\n+            &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n+\n+            // subtle: associated consts are literals this arm handles\n+            // `<T as Trait>::ASSOC` as well as `12`\n+            &ExprKind::Literal { literal, .. } => self.nodes.push(Node::Leaf(literal)),\n+\n+            ExprKind::Call { fun, args,  .. } => {\n+                let fun = self.recurse_build(*fun)?;\n+\n+                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n+                for &id in args.iter() {\n+                    new_args.push(self.recurse_build(id)?);\n+                }\n+                let new_args = self.tcx.arena.alloc_slice(&new_args);\n+                self.nodes.push(Node::FunctionCall(fun, new_args))\n+            },\n+            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n+                let lhs = self.recurse_build(lhs)?;\n+                let rhs = self.recurse_build(rhs)?;\n+                self.nodes.push(Node::Binop(op, lhs, rhs))\n+            }\n+            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n+                let arg = self.recurse_build(arg)?;\n+                self.nodes.push(Node::UnaryOp(op, arg))\n+            },\n+            // This is necessary so that the following compiles:\n+            //\n+            // ```\n+            // fn foo<const N: usize>(a: [(); N + 1]) {\n+            //     bar::<{ N + 1 }>();\n+            // }\n+            // ```\n+            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. }} => self.recurse_build(*e)?,\n+            // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n+            // \"coercion cast\" i.e. using a coercion or is a no-op.\n+            // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n+            &ExprKind::Use { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.nodes.push(Node::Cast(abstract_const::CastKind::Use, arg, node.ty))\n+            },\n+            &ExprKind::Cast { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.nodes.push(Node::Cast(abstract_const::CastKind::As, arg, node.ty))\n+            },\n+\n+            // FIXME(generic_const_exprs): We may want to support these.\n+            ExprKind::AddressOf { .. }\n+            | ExprKind::Borrow { .. }\n+            | ExprKind::Deref { .. }\n+            | ExprKind::Repeat { .. }\n+            | ExprKind::Array { .. }\n+            | ExprKind::Block { .. }\n+            | ExprKind::NeverToAny { .. }\n+            | ExprKind::Tuple { .. }\n+            | ExprKind::Index { .. }\n+            | ExprKind::Field { .. }\n+            | ExprKind::ConstBlock { .. }\n+            | ExprKind::Adt(_) => self.error(\n+                    Some(node.span),\n+                    \"unsupported operation in generic constant, this may be supported in the future\",\n+                )?,\n+\n+            ExprKind::Match { .. }\n+            // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n+            | ExprKind::VarRef { .. }\n+            | ExprKind::UpvarRef { .. }\n+            | ExprKind::Closure { .. }\n+            | ExprKind::Let { .. } // let expressions imply control flow\n+            | ExprKind::Loop { .. }\n+            | ExprKind::Assign { .. }\n+            | ExprKind::StaticRef { .. }\n+            | ExprKind::LogicalOp { .. }\n+            // we handle valid unary/binary ops above\n+            | ExprKind::Unary { .. }\n+            | ExprKind::Binary { .. }\n+            | ExprKind::Break { .. }\n+            | ExprKind::Continue { .. }\n+            | ExprKind::If { .. }\n+            | ExprKind::Pointer { .. } // dont know if this is correct\n+            | ExprKind::ThreadLocalRef(_)\n+            | ExprKind::LlvmInlineAsm { .. }\n+            | ExprKind::Return { .. }\n+            | ExprKind::Box { .. } // allocations not allowed in constants\n+            | ExprKind::AssignOp { .. }\n+            | ExprKind::InlineAsm { .. }\n+            | ExprKind::Yield { .. } => self.error(Some(node.span), \"unsupported operation in generic constant\")?,\n+        })\n     }\n }\n \n /// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n-pub(super) fn mir_abstract_const<'tcx>(\n+pub(super) fn thir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n     if tcx.features().generic_const_exprs {\n         match tcx.def_kind(def.did) {\n             // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n@@ -547,8 +443,16 @@ pub(super) fn mir_abstract_const<'tcx>(\n             DefKind::AnonConst => (),\n             _ => return Ok(None),\n         }\n-        let body = tcx.mir_const(def).borrow();\n-        AbstractConstBuilder::new(tcx, &body)?.map(AbstractConstBuilder::build).transpose()\n+\n+        let body = tcx.thir_body(def);\n+        if body.0.borrow().exprs.is_empty() {\n+            // type error in constant, there is no thir\n+            return Err(ErrorReported);\n+        }\n+\n+        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n+            .map(AbstractConstBuilder::build)\n+            .transpose()\n     } else {\n         Ok(None)\n     }\n@@ -682,11 +586,16 @@ pub(super) fn try_unify<'tcx>(\n                 && iter::zip(a_args, b_args)\n                     .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n         }\n-        (Node::Cast(a_cast_kind, a_operand, a_ty), Node::Cast(b_cast_kind, b_operand, b_ty))\n-            if (a_ty == b_ty) && (a_cast_kind == b_cast_kind) =>\n+        (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n+            if (a_ty == b_ty) && (a_kind == b_kind) =>\n         {\n             try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand))\n         }\n-        _ => false,\n+        // use this over `_ => false` to make adding variants to `Node` less error prone\n+        (Node::Cast(..), _)\n+        | (Node::FunctionCall(..), _)\n+        | (Node::UnaryOp(..), _)\n+        | (Node::Binop(..), _)\n+        | (Node::Leaf(..), _) => false,\n     }\n }"}, {"sha": "761b217c78f4e49c8734b8c638ef963c68763ee9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -19,7 +19,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::{"}, {"sha": "b376f4292924963574d690c85d6426119479fa89", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -5,8 +5,8 @@ use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProce\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitEngineExt as _, TraitObligation};\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ToPredicate;"}, {"sha": "ef208c44471cbadf52d2b5dcdea6af83fc019092", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -827,16 +827,16 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_entries,\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n-        mir_abstract_const: |tcx, def_id| {\n+        thir_abstract_const: |tcx, def_id| {\n             let def_id = def_id.expect_local();\n             if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.mir_abstract_const_of_const_arg(def)\n+                tcx.thir_abstract_const_of_const_arg(def)\n             } else {\n-                const_evaluatable::mir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n+                const_evaluatable::thir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n             }\n         },\n-        mir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n-            const_evaluatable::mir_abstract_const(\n+        thir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n+            const_evaluatable::thir_abstract_const(\n                 tcx,\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )"}, {"sha": "4922cf45a4a109565db5478fb7b53c8a3b5c3e8d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -836,7 +836,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             //\n             // This shouldn't really matter though as we can't really use any\n             // constants which are not considered const evaluatable.\n-            use rustc_middle::mir::abstract_const::Node;\n+            use rustc_middle::thir::abstract_const::Node;\n             if let Ok(Some(ct)) = AbstractConst::new(self.tcx, uv.shrink()) {\n                 const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node.root() {\n                     Node::Leaf(leaf) => {"}, {"sha": "f5be8bf0949e6ff12caff47d9269a7ca6c2519da", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -34,8 +34,8 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;"}, {"sha": "916d60c0e0def2d5b54841668e15d14fa5799258", "filename": "src/test/ui/const-generics/generic_const_exprs/abstract-consts-as-cast-5.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -0,0 +1,11 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn foo<const N: u8>(a: [(); N as usize]) {\n+    bar::<{ N as usize as usize }>();\n+    //~^ error: unconstrained generic constant\n+}\n+\n+fn bar<const N: usize>() {}\n+\n+fn main() {}"}, {"sha": "d48b639dbdee33033719841f0ba082cbda0ec89a", "filename": "src/test/ui/const-generics/generic_const_exprs/abstract-consts-as-cast-5.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.stderr?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained generic constant\n+  --> $DIR/abstract-consts-as-cast-5.rs:5:11\n+   |\n+LL |     bar::<{ N as usize as usize }>();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); { N as usize as usize }]:`\n+\n+error: aborting due to previous error\n+"}, {"sha": "9b3c32a93977906a7900691bc744ffb3c7fc4a7e", "filename": "src/test/ui/const-generics/generic_const_exprs/array-size-in-generic-struct-param.full.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -10,7 +10,7 @@ error: overly complex generic constant\n   --> $DIR/array-size-in-generic-struct-param.rs:19:15\n    |\n LL |     arr: [u8; CFG.arr_size],\n-   |               ^^^^^^^^^^^^ unsupported projection\n+   |               ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "95dae4ecc0431c50915ae669d481376177510eac", "filename": "src/test/ui/const-generics/generic_const_exprs/closures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -4,7 +4,7 @@ error: overly complex generic constant\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n    |                                   ^^^^-------^^\n    |                                       |\n-   |                                       unsupported rvalue\n+   |                                       unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "c9f847995223abd909743e26980a13488c04b7c3", "filename": "src/test/ui/const-generics/generic_const_exprs/let-bindings.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -2,19 +2,15 @@ error: overly complex generic constant\n   --> $DIR/let-bindings.rs:6:68\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                                                    ^^^^^^-^^^^^^^^^^^^^\n-   |                                                                          |\n-   |                                                                          unsupported statement\n+   |                                                                    ^^^^^^^^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n \n error: overly complex generic constant\n   --> $DIR/let-bindings.rs:6:35\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                   ^^^^^^-^^^^^^^^^^^^^\n-   |                                         |\n-   |                                         unsupported statement\n+   |                                   ^^^^^^^^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "c0404d35b08879d5ae9ddb009f38e0b3d1a9b0ce", "filename": "src/test/ui/const-generics/generic_const_exprs/unify-op-with-fn-call.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -0,0 +1,35 @@\n+#![feature(generic_const_exprs, adt_const_params, const_trait_impl)]\n+#![allow(incomplete_features)]\n+\n+// test `N + N` unifies with explicit function calls for non-builtin-types\n+#[derive(PartialEq, Eq)]\n+struct Foo(u8);\n+\n+impl const std::ops::Add for Foo {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self::Output {\n+        self\n+    }\n+}\n+\n+struct Evaluatable<const N: Foo>;\n+\n+fn foo<const N: Foo>(a: Evaluatable<{ N + N }>) {\n+    bar::<{ std::ops::Add::add(N, N) }>();\n+}\n+\n+fn bar<const N: Foo>() {}\n+\n+// test that `N + N` unifies with explicit function calls for builin-types\n+struct Evaluatable2<const N: usize>;\n+\n+fn foo2<const N: usize>(a: Evaluatable2<{ N + N }>) {\n+    bar2::<{ std::ops::Add::add(N, N) }>();\n+    //~^ error: unconstrained generic constant\n+    // FIXME(generic_const_exprs) make this not an error\n+}\n+\n+fn bar2<const N: usize>() {}\n+\n+fn main() {}"}, {"sha": "d18c7916f5f6f3336f611ddb4755db2b308583a7", "filename": "src/test/ui/const-generics/generic_const_exprs/unify-op-with-fn-call.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained generic constant\n+  --> $DIR/unify-op-with-fn-call.rs:28:12\n+   |\n+LL |     bar2::<{ std::ops::Add::add(N, N) }>();\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); { std::ops::Add::add(N, N) }]:`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3da91b19a5ed95c95dc85830599f0972d10a7de3", "filename": "src/test/ui/const-generics/generic_const_exprs/unused_expr.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -2,29 +2,23 @@ error: overly complex generic constant\n   --> $DIR/unused_expr.rs:4:34\n    |\n LL | fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n-   |                                  ^^-----^^^^^\n-   |                                    |\n-   |                                    dead code\n+   |                                  ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:9:34\n    |\n LL | fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n-   |                                  ^^-----^^^^^\n-   |                                    |\n-   |                                    dead code\n+   |                                  ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:16:38\n    |\n LL | fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n-   |                                      ^^------^^^^^\n-   |                                        |\n-   |                                        dead code\n+   |                                      ^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "d7b52063dc4db24c8bfea069cb12a9a6b54a15c3", "filename": "src/test/ui/const-generics/issues/issue-67375.full.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -2,9 +2,9 @@ error: overly complex generic constant\n   --> $DIR/issue-67375.rs:7:17\n    |\n LL |     inner: [(); { [|_: &T| {}; 0].len() }],\n-   |                 ^^^----------^^^^^^^^^^^^\n-   |                    |\n-   |                    unsupported rvalue\n+   |                 ^^---------------^^^^^^^^\n+   |                   |\n+   |                   unsupported operation in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "fe0351a829220368f24a0aaab9d6f0e40d93f76f", "filename": "src/test/ui/const-generics/issues/issue-67945-2.full.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr?ref=f5ac5cadd3d426cbf9a67dfe1c21a7d404cd2423", "patch": "@@ -5,11 +5,10 @@ LL |       A: [(); {\n    |  _____________^\n LL | |\n LL | |         let x: Option<Box<Self>> = None;\n-   | |                                    ---- unsupported rvalue\n LL | |\n LL | |         0\n LL | |     }],\n-   | |_____^\n+   | |_____^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}]}