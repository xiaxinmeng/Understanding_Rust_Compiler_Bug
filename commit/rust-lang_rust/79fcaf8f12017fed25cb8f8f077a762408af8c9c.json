{"sha": "79fcaf8f12017fed25cb8f8f077a762408af8c9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZmNhZjhmMTIwMTdmZWQyNWNiOGY4ZjA3N2E3NjI0MDhhZjhjOWM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-20T22:15:42Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-28T18:52:08Z"}, "message": "Apply proper commit from PR #63934\n\nWhile working on PR #63934, I accidentally reverted to an older version\nof the PR while working on a rebase. The PR was then merged, not with\nthe later, approved changes, but with earlier, unapproved changes.\n\nThis PR applies the changes that were *suppoesd* to be mereged in\nPR #63934. All of the proper tests appear to have been merged\nin PR #63934, so this PR adds no new tests\n\nFixes #66580", "tree": {"sha": "a6b29ef0e25124318843c499e47cc690854e444a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6b29ef0e25124318843c499e47cc690854e444a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79fcaf8f12017fed25cb8f8f077a762408af8c9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl3gF2UACgkQtAh+UQ6Y\nsWRctw//VoKp6modfa6MT0Xj+lkOigWRUwJ3hfB3NMLlSf7D0JsKZYzquvFpVp+9\nRvLoHfhHRLBDio4gvCjnLXIikD1VTd5CHUBI60rstL5sGEawFn/GAeR23H7FNIMs\nJUCDq/mVe8754oVPJAuTJhDYsM5f7U8CcnVrKHzt5nU3R1/ZGZgWMmboj3MZ+r2G\npmk42egCMGiX7jLJF+XD43BQhKdWSxk7mksWKtS1cYHyByWXJjQJMbr0jlVt+1lA\nGWHncs4Ffe+O/wFio9wJA4/pWCLWYfmGdH5PrRJNQMeFkiKx0z9o093MNgp6QV3q\nZRuymwK5l6ZpA2Ub7Nn20sHCa+GJvFNZ1/xv0ZcDnxHdPEUBQ3JKohm9AHk8WhyF\nqVw+4QTMjaAXszpTzhcuOm/TZVytCjhKxIOGoxVEG7v7QUBDVXloXhbn6ZKuIhj5\nLJ+uD11zdoALMuCsPP0vleiGdoRxdkV9oGRghZP031cbJ2Qoa7hHtgAHQDIYYjig\neQO/4VlAQlFIBlXTf1m5vuEHXh2BkUfRWXy9FDxf/vak1UfTh9OdBcpMINmPg2pK\ni1ks7gQ8V2wR/7mR3PgCUHj//VkWNYwFeDTrOOTkZMeESA4sLdQQHh+MQLlx3Ddc\nZk9zYl4atZ+otZMjjdi3G02Ws+YixGQhtVvI6EnvBfGZifePm2U=\n=zrhw\n-----END PGP SIGNATURE-----", "payload": "tree a6b29ef0e25124318843c499e47cc690854e444a\nparent b9cf5417892ef242c783ef963deff5436205b0f6\nauthor Aaron Hill <aa1ronham@gmail.com> 1574288142 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1574967128 -0500\n\nApply proper commit from PR #63934\n\nWhile working on PR #63934, I accidentally reverted to an older version\nof the PR while working on a rebase. The PR was then merged, not with\nthe later, approved changes, but with earlier, unapproved changes.\n\nThis PR applies the changes that were *suppoesd* to be mereged in\nPR #63934. All of the proper tests appear to have been merged\nin PR #63934, so this PR adds no new tests\n\nFixes #66580\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79fcaf8f12017fed25cb8f8f077a762408af8c9c", "html_url": "https://github.com/rust-lang/rust/commit/79fcaf8f12017fed25cb8f8f077a762408af8c9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79fcaf8f12017fed25cb8f8f077a762408af8c9c/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9cf5417892ef242c783ef963deff5436205b0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9cf5417892ef242c783ef963deff5436205b0f6", "html_url": "https://github.com/rust-lang/rust/commit/b9cf5417892ef242c783ef963deff5436205b0f6"}], "stats": {"total": 67, "additions": 52, "deletions": 15}, "files": [{"sha": "933bc06c21efedfd2086cd052a0c119c65815acf", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/79fcaf8f12017fed25cb8f8f077a762408af8c9c/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fcaf8f12017fed25cb8f8f077a762408af8c9c/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=79fcaf8f12017fed25cb8f8f077a762408af8c9c", "patch": "@@ -382,7 +382,7 @@ fn orphan_check_trait_ref<'tcx>(\n         ty: Ty<'tcx>,\n         in_crate: InCrate,\n     ) -> Vec<Ty<'tcx>> {\n-        if fundamental_ty(ty) && ty_is_non_local(tcx, ty, in_crate).is_some() {\n+        if fundamental_ty(ty) && ty_is_non_local(ty, in_crate).is_some() {\n             ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).collect()\n         } else {\n             vec![ty]\n@@ -396,7 +396,7 @@ fn orphan_check_trait_ref<'tcx>(\n         .enumerate()\n     {\n         debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n+        let non_local_tys = ty_is_non_local(input_ty, in_crate);\n         if non_local_tys.is_none() {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n             return Ok(());\n@@ -405,7 +405,7 @@ fn orphan_check_trait_ref<'tcx>(\n             let local_type = trait_ref\n                 .input_types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .filter(|ty| ty_is_non_local_constructor(tcx, ty, in_crate).is_none())\n+                .filter(|ty| ty_is_non_local_constructor(ty, in_crate).is_none())\n                 .next();\n \n             debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n@@ -423,13 +423,13 @@ fn orphan_check_trait_ref<'tcx>(\n     Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-fn ty_is_non_local<'t>(tcx: TyCtxt<'t>, ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {\n-    match ty_is_non_local_constructor(tcx, ty, in_crate) {\n+fn ty_is_non_local<'t>(ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {\n+    match ty_is_non_local_constructor(ty, in_crate) {\n         Some(ty) => if !fundamental_ty(ty) {\n             Some(vec![ty])\n         } else {\n             let tys: Vec<_> = ty.walk_shallow()\n-                .filter_map(|t| ty_is_non_local(tcx, t, in_crate))\n+                .filter_map(|t| ty_is_non_local(t, in_crate))\n                 .flat_map(|i| i)\n                 .collect();\n             if tys.is_empty() {\n@@ -460,7 +460,6 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n }\n \n fn ty_is_non_local_constructor<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     in_crate: InCrate,\n ) -> Option<Ty<'tcx>> {\n@@ -503,14 +502,33 @@ fn ty_is_non_local_constructor<'tcx>(\n         } else {\n             Some(ty)\n         },\n-        ty::Opaque(did, _) => {\n-            // Check the underlying type that this opaque\n-            // type resolves to.\n-            // This recursion will eventually terminate,\n-            // since we've already managed to successfully\n-            // resolve all opaque types by this point\n-            let real_ty = tcx.type_of(did);\n-            ty_is_non_local_constructor(tcx, real_ty, in_crate)\n+        ty::Opaque(..) => {\n+            // This merits some explanation.\n+            // Normally, opaque types are not involed when performing\n+            // coherence checking, since it is illegal to directly\n+            // implement a trait on an opaque type. However, we might\n+            // end up looking at an opaque type during coherence checking\n+            // if an opaque type gets used within another type (e.g. as\n+            // a type parameter). This requires us to decide whether or\n+            // not an opaque type should be considered 'local' or not.\n+            //\n+            // We choose to treat all opaque types as non-local, even\n+            // those that appear within the same crate. This seems\n+            // somewhat suprising at first, but makes sense when\n+            // you consider that opaque types are supposed to hide\n+            // the underlying type *within the same crate*. When an\n+            // opaque type is used from outside the module\n+            // where it is declared, it should be impossible to observe\n+            // anyything about it other than the traits that it implements.\n+            //\n+            // The alternative would be to look at the underlying type\n+            // to determine whether or not the opaque type itself should\n+            // be considered local. However, this could make it a breaking change\n+            // to switch the underlying ('defining') type from a local type\n+            // to a remote type. This would violate the rule that opaque\n+            // types should be completely opaque apart from the traits\n+            // that they implement, so we don't use this behavior.\n+            Some(ty)\n         }\n \n         ty::Dynamic(ref tt, ..) => {"}, {"sha": "1d95cc7530c5e7b37e5e3c9bb37460dd2e8a7566", "filename": "src/test/ui/type-alias-impl-trait/issue-66580-closure-coherence.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/79fcaf8f12017fed25cb8f8f077a762408af8c9c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-66580-closure-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fcaf8f12017fed25cb8f8f077a762408af8c9c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-66580-closure-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-66580-closure-coherence.rs?ref=79fcaf8f12017fed25cb8f8f077a762408af8c9c", "patch": "@@ -0,0 +1,19 @@\n+// Regression test for issue #66580\n+// Ensures that we don't try to determine whether a closure\n+// is foreign when it's the underlying type of an opaque type\n+// check-pass\n+#![feature(type_alias_impl_trait)]\n+\n+type Closure = impl FnOnce();\n+\n+fn closure() -> Closure {\n+    || {}\n+}\n+\n+struct Wrap<T> { f: T }\n+\n+impl Wrap<Closure> {}\n+\n+impl<T> Wrap<T> {}\n+\n+fn main() {}"}]}