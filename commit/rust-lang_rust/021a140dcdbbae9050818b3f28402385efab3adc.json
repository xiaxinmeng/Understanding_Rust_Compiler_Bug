{"sha": "021a140dcdbbae9050818b3f28402385efab3adc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMWExNDBkY2RiYmFlOTA1MDgxOGIzZjI4NDAyMzg1ZWZhYjNhZGM=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-22T14:48:14Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-24T16:09:26Z"}, "message": "hir: remove NodeId from Block", "tree": {"sha": "c0308ea967f0dbfb961fa4394e526ac6e425df80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0308ea967f0dbfb961fa4394e526ac6e425df80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/021a140dcdbbae9050818b3f28402385efab3adc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/021a140dcdbbae9050818b3f28402385efab3adc", "html_url": "https://github.com/rust-lang/rust/commit/021a140dcdbbae9050818b3f28402385efab3adc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/021a140dcdbbae9050818b3f28402385efab3adc/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63b4dd91be31b6565d2b868e5ac9ee0e4e33610b", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b4dd91be31b6565d2b868e5ac9ee0e4e33610b", "html_url": "https://github.com/rust-lang/rust/commit/63b4dd91be31b6565d2b868e5ac9ee0e4e33610b"}], "stats": {"total": 256, "additions": 121, "deletions": 135}, "files": [{"sha": "769cfbe5b4c6dfa30c10809e0525ae8e293ad2b3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -2804,10 +2804,9 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(b.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(b.id);\n \n         P(hir::Block {\n-            id: node_id,\n             hir_id,\n             stmts: stmts.into(),\n             expr,\n@@ -3887,11 +3886,10 @@ impl<'a> LoweringContext<'a> {\n                             // Wrap the `if let` expr in a block.\n                             let span = els.span;\n                             let els = P(self.lower_expr(els));\n-                            let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                            let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                             let blk = P(hir::Block {\n                                 stmts: hir_vec![],\n                                 expr: Some(els),\n-                                id: node_id,\n                                 hir_id,\n                                 rules: hir::DefaultBlock,\n                                 span,\n@@ -4965,12 +4963,11 @@ impl<'a> LoweringContext<'a> {\n         stmts: hir::HirVec<hir::Stmt>,\n         expr: Option<P<hir::Expr>>,\n     ) -> hir::Block {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Block {\n             stmts,\n             expr,\n-            id: node_id,\n             hir_id,\n             rules: hir::DefaultBlock,\n             span,"}, {"sha": "53a63735cefba161b137de6b1d42f8b10e963e74", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -822,7 +822,6 @@ pub struct Block {\n     /// An expression at the end of the block\n     /// without a semicolon, if any.\n     pub expr: Option<P<Expr>>,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,"}, {"sha": "e12a1bc7f191759fef1ff7d560366b1d99ebd7c8", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -415,7 +415,6 @@ impl_stable_hash_for!(struct hir::MacroDef {\n impl_stable_hash_for!(struct hir::Block {\n     stmts,\n     expr,\n-    id -> _,\n     hir_id -> _,\n     rules,\n     span,"}, {"sha": "29cb40a9a67318104b2f4ed73f4f4bb8803ca552", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -629,7 +629,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// Indicates that the value of `blk` will be consumed, meaning either copied or moved\n     /// depending on its type.\n     fn walk_block(&mut self, blk: &hir::Block) {\n-        debug!(\"walk_block(blk.id={})\", blk.id);\n+        debug!(\"walk_block(blk.hir_id={})\", blk.hir_id);\n \n         for stmt in &blk.stmts {\n             self.walk_stmt(stmt);"}, {"sha": "8cbc4bff3e15b4e23f3234cda8bbb207c61a94f7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -950,7 +950,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n         if blk.targeted_by_break {\n-            self.break_ln.insert(blk.id, succ);\n+            let node_id = self.ir.tcx.hir().hir_to_node_id(blk.hir_id);\n+            self.break_ln.insert(node_id, succ);\n         }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n@@ -1386,7 +1387,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, self.ir.tcx.hir().node_to_pretty_string(body.id));\n+               expr.id, self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n \n         self.break_ln.insert(expr.id, succ);"}, {"sha": "3499138fb7915da07eaecdb938a8aac90433fd3f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -745,7 +745,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_, '_>,\n }\n \n fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk: &'tcx hir::Block) {\n-    debug!(\"resolve_block(blk.id={:?})\", blk.id);\n+    debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n \n     let prev_cx = visitor.cx;\n "}, {"sha": "c4e1860bd8333e7985cf16266227f17d3e220c6f", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -1,5 +1,6 @@\n use std::{fmt, env};\n \n+use crate::hir;\n use crate::hir::map::definitions::DefPathData;\n use crate::mir;\n use crate::ty::{self, Ty, layout};\n@@ -14,7 +15,6 @@ use crate::ty::query::TyCtxtAt;\n use errors::DiagnosticBuilder;\n \n use syntax_pos::{Pos, Span};\n-use syntax::ast;\n use syntax::symbol::Symbol;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n@@ -50,7 +50,7 @@ pub struct ConstEvalErr<'tcx> {\n pub struct FrameInfo<'tcx> {\n     pub call_site: Span, // this span is in the caller!\n     pub instance: ty::Instance<'tcx>,\n-    pub lint_root: Option<ast::NodeId>,\n+    pub lint_root: Option<hir::HirId>,\n }\n \n impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     pub fn report_as_lint(&self,\n         tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n         message: &str,\n-        lint_root: ast::NodeId,\n+        lint_root: hir::HirId,\n     ) -> ErrorHandled {\n         let lint = self.struct_generic(\n             tcx,\n@@ -118,7 +118,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         &self,\n         tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n         message: &str,\n-        lint_root: Option<ast::NodeId>,\n+        lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         match self.error {\n             EvalErrorKind::Layout(LayoutError::Unknown(_)) |\n@@ -129,15 +129,15 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         }\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n         let mut err = if let Some(lint_root) = lint_root {\n-            let node_id = self.stacktrace\n+            let hir_id = self.stacktrace\n                 .iter()\n                 .rev()\n                 .filter_map(|frame| frame.lint_root)\n                 .next()\n                 .unwrap_or(lint_root);\n-            tcx.struct_span_lint_node(\n+            tcx.struct_span_lint_hir(\n                 crate::rustc::lint::builtin::CONST_ERR,\n-                node_id,\n+                hir_id,\n                 tcx.span,\n                 message,\n             )"}, {"sha": "f0bf31f47f598d825a11f0ef7841f9a2110b1f4f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -413,7 +413,7 @@ pub enum Safety {\n     /// Unsafe because of an unsafe fn\n     FnUnsafe,\n     /// Unsafe because of an `unsafe` block\n-    ExplicitUnsafe(ast::NodeId),\n+    ExplicitUnsafe(hir::HirId),\n }\n \n impl_stable_hash_for!(struct Mir<'tcx> {\n@@ -2098,8 +2098,8 @@ pub struct SourceScopeData {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct SourceScopeLocalData {\n-    /// A NodeId with lint levels equivalent to this scope's lint levels.\n-    pub lint_root: ast::NodeId,\n+    /// A HirId with lint levels equivalent to this scope's lint levels.\n+    pub lint_root: hir::HirId,\n     /// The unsafe block that contains this node.\n     pub safety: Safety,\n }\n@@ -2849,8 +2849,8 @@ pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted in const fn and regular fns.\n     GeneralAndConstFn,\n-    ExternStatic(ast::NodeId),\n-    BorrowPacked(ast::NodeId),\n+    ExternStatic(hir::HirId),\n+    BorrowPacked(hir::HirId),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -2867,7 +2867,7 @@ pub struct UnsafetyCheckResult {\n     pub violations: Lrc<[UnsafetyViolation]>,\n     /// unsafe blocks in this function, along with whether they are used. This is\n     /// used for the \"unused_unsafe\" lint.\n-    pub unsafe_blocks: Lrc<[(ast::NodeId, bool)]>,\n+    pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n }\n \n /// The layout of generator state"}, {"sha": "5c24b0ebfe05e7c20e7cc64f65972cbe074ed919", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -10,6 +10,7 @@\n \n use super::elaborate_predicates;\n \n+use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::lint;\n use crate::traits::{self, Obligation, ObligationCause};\n@@ -129,7 +130,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                     // It's also hard to get a use site span, so we use the method definition span.\n                     self.lint_node_note(\n                         lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n-                        ast::CRATE_NODE_ID,\n+                        hir::CRATE_HIR_ID,\n                         *span,\n                         &format!(\"the trait `{}` cannot be made into an object\",\n                                  self.item_path_str(trait_def_id)),"}, {"sha": "a71c0d4ab963dd6ec830f6f1f032cd43c0e0e594", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -2859,11 +2859,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn lint_node_note<S: Into<MultiSpan>>(self,\n                                               lint: &'static Lint,\n-                                              id: NodeId,\n+                                              id: hir::HirId,\n                                               span: S,\n                                               msg: &str,\n                                               note: &str) {\n-        let mut err = self.struct_span_lint_node(lint, id, span.into(), msg);\n+        let mut err = self.struct_span_lint_hir(lint, id, span.into(), msg);\n         err.note(note);\n         err.emit()\n     }"}, {"sha": "b0b5594b93eac1bc1bbdd427534f4d178d1cdf60", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -420,8 +420,8 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             }\n             pprust_hir::AnnNode::Block(blk) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"block node_id: {} hir local_id: {}\",\n-                                        blk.id, blk.hir_id.local_id.as_u32()))\n+                s.synth_comment(format!(\"block hir_id: {} hir local_id: {}\",\n+                                        blk.hir_id, blk.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::Expr(expr) => {\n                 s.s.space()?;"}, {"sha": "7fce5f92e0caeeca5f3c2fd2c4e258fa65bdb23e", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -301,7 +301,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             }\n \n             let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n-            tcx.struct_span_lint_node(\n+            tcx.struct_span_lint_hir(\n                 UNUSED_MUT,\n                 vsi[local_decl.source_info.scope].lint_root,\n                 span,"}, {"sha": "499ec1900473f178e0680efc141b395b51363818", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -206,14 +206,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"update_source_scope_for({:?}, {:?})\", span, safety_mode);\n         let new_unsafety = match safety_mode {\n             BlockSafety::Safe => None,\n-            BlockSafety::ExplicitUnsafe(node_id) => {\n+            BlockSafety::ExplicitUnsafe(hir_id) => {\n                 assert_eq!(self.push_unsafe_count, 0);\n                 match self.unpushed_unsafe {\n                     Safety::Safe => {}\n                     _ => return\n                 }\n-                self.unpushed_unsafe = Safety::ExplicitUnsafe(node_id);\n-                Some(Safety::ExplicitUnsafe(node_id))\n+                self.unpushed_unsafe = Safety::ExplicitUnsafe(hir_id);\n+                Some(Safety::ExplicitUnsafe(hir_id))\n             }\n             BlockSafety::PushUnsafe => {\n                 self.push_unsafe_count += 1;"}, {"sha": "5d8dc6ef8e4544bf4decc89b07b8f300528bc7fe", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -72,13 +72,13 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let cx = Cx::new(&infcx, id);\n+        let fn_hir_id = tcx.hir().node_to_hir_id(id);\n+        let cx = Cx::new(&infcx, fn_hir_id);\n         let mut mir = if cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)\n         } else if cx.body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_hir_id = tcx.hir().node_to_hir_id(id);\n             let fn_sig = cx.tables().liberated_fn_sigs()[fn_hir_id].clone();\n             let fn_def_id = tcx.hir().local_def_id(id);\n "}, {"sha": "71acf747d085606e971d635034f9bf0f7efab2d1", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -308,17 +308,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"in_scope(region_scope={:?}, block={:?})\", region_scope, block);\n         let source_scope = self.source_scope;\n         let tcx = self.hir.tcx();\n-        if let LintLevel::Explicit(node_id) = lint_level {\n+        if let LintLevel::Explicit(current_hir_id) = lint_level {\n             let same_lint_scopes = tcx.dep_graph.with_ignore(|| {\n                 let sets = tcx.lint_levels(LOCAL_CRATE);\n-                let parent_hir_id =\n-                    tcx.hir().definitions().node_to_hir_id(\n-                        self.source_scope_local_data[source_scope].lint_root\n-                    );\n-                let current_hir_id =\n-                    tcx.hir().definitions().node_to_hir_id(node_id);\n-                sets.lint_level_set(parent_hir_id) ==\n-                    sets.lint_level_set(current_hir_id)\n+                let parent_hir_id = self.source_scope_local_data[source_scope].lint_root;\n+                sets.lint_level_set(parent_hir_id) == sets.lint_level_set(current_hir_id)\n             });\n \n             if !same_lint_scopes {"}, {"sha": "1eb129c6fc3aceb401fee7392494e355cbfcf837", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -663,11 +663,11 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                 // because any code that existed before validation could not have failed validation\n                 // thus preventing such a hard error from being a backwards compatibility hazard\n                 Some(Def::Const(_)) | Some(Def::AssociatedConst(_)) => {\n-                    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+                    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     err.report_as_lint(\n                         tcx.at(tcx.def_span(def_id)),\n                         \"any use of this value will cause an error\",\n-                        node_id,\n+                        hir_id,\n                     )\n                 },\n                 // promoting runtime code is only allowed to error if it references broken constants\n@@ -683,7 +683,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                         err.report_as_lint(\n                             tcx.at(span),\n                             \"reaching this expression at runtime will panic or abort\",\n-                            tcx.hir().as_local_node_id(def_id).unwrap(),\n+                            tcx.hir().as_local_hir_id(def_id).unwrap(),\n                         )\n                     }\n                 // anything else (array lengths, enum initializers, constant patterns) are reported"}, {"sha": "b63bf4bc2468480b952afc5dfa9af502f7430fb9", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -30,7 +30,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n                 hir::BlockCheckMode::DefaultBlock =>\n                     BlockSafety::Safe,\n                 hir::BlockCheckMode::UnsafeBlock(..) =>\n-                    BlockSafety::ExplicitUnsafe(self.id),\n+                    BlockSafety::ExplicitUnsafe(self.hir_id),\n                 hir::BlockCheckMode::PushUnsafeBlock(..) =>\n                     BlockSafety::PushUnsafe,\n                 hir::BlockCheckMode::PopUnsafeBlock(..) =>"}, {"sha": "d24a70528ec4d3ea7c8f0c7e1dafd8a16f298f14", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -26,7 +26,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n \n-    pub root_lint_level: ast::NodeId,\n+    pub root_lint_level: hir::HirId,\n     pub param_env: ty::ParamEnv<'gcx>,\n \n     /// Identity `Substs` for use with const-evaluation.\n@@ -51,10 +51,10 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               src_id: ast::NodeId) -> Cx<'a, 'gcx, 'tcx> {\n+               src_id: hir::HirId) -> Cx<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n-        let src_def_id = tcx.hir().local_def_id(src_id);\n-        let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n+        let src_def_id = tcx.hir().local_def_id_from_hir_id(src_id);\n+        let body_owner_kind = tcx.hir().body_owner_kind_by_hir_id(src_id);\n \n         let constness = match body_owner_kind {\n             hir::BodyOwnerKind::Const |\n@@ -63,7 +63,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             hir::BodyOwnerKind::Fn => hir::Constness::NotConst,\n         };\n \n-        let attrs = tcx.hir().attrs(src_id);\n+        let attrs = tcx.hir().attrs_by_hir_id(src_id);\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         });\n \n         if has_lint_level {\n-            LintLevel::Explicit(node_id)\n+            LintLevel::Explicit(hir_id)\n         } else {\n             LintLevel::Inherited\n         }\n@@ -237,7 +237,7 @@ impl UserAnnotatedTyHelpers<'gcx, 'tcx> for Cx<'_, 'gcx, 'tcx> {\n     }\n }\n \n-fn lint_level_for_hir_id(tcx: TyCtxt<'_, '_, '_>, mut id: ast::NodeId) -> ast::NodeId {\n+fn lint_level_for_hir_id(tcx: TyCtxt<'_, '_, '_>, mut id: hir::HirId) -> hir::HirId {\n     // Right now we insert a `with_ignore` node in the dep graph here to\n     // ignore the fact that `lint_levels` below depends on the entire crate.\n     // For now this'll prevent false positives of recompiling too much when\n@@ -249,11 +249,10 @@ fn lint_level_for_hir_id(tcx: TyCtxt<'_, '_, '_>, mut id: ast::NodeId) -> ast::N\n     tcx.dep_graph.with_ignore(|| {\n         let sets = tcx.lint_levels(LOCAL_CRATE);\n         loop {\n-            let hir_id = tcx.hir().definitions().node_to_hir_id(id);\n-            if sets.lint_level_set(hir_id).is_some() {\n+            if sets.lint_level_set(id).is_some() {\n                 return id\n             }\n-            let next = tcx.hir().get_parent_node(id);\n+            let next = tcx.hir().get_parent_node_by_hir_id(id);\n             if next == id {\n                 bug!(\"lint traversal reached the root of the crate\");\n             }"}, {"sha": "22e44ae85a463f3559af99bb9e825a2b370269a7", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -28,7 +28,7 @@ mod util;\n #[derive(Copy, Clone, Debug)]\n pub enum LintLevel {\n     Inherited,\n-    Explicit(ast::NodeId)\n+    Explicit(hir::HirId)\n }\n \n impl LintLevel {\n@@ -54,7 +54,7 @@ pub struct Block<'tcx> {\n #[derive(Copy, Clone, Debug)]\n pub enum BlockSafety {\n     Safe,\n-    ExplicitUnsafe(ast::NodeId),\n+    ExplicitUnsafe(hir::HirId),\n     PushUnsafe,\n     PopUnsafe\n }"}, {"sha": "3ed63d749cd3558deefafc72f45e550b948aa798", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -12,7 +12,6 @@ use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSA\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n-use syntax::ast;\n use syntax::symbol::Symbol;\n \n use std::ops::Bound;\n@@ -29,8 +28,8 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     /// Mark an `unsafe` block as used, so we don't lint it.\n-    used_unsafe: FxHashSet<ast::NodeId>,\n-    inherited_blocks: Vec<(ast::NodeId, bool)>,\n+    used_unsafe: FxHashSet<hir::HirId>,\n+    inherited_blocks: Vec<(hir::HirId, bool)>,\n }\n \n impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n@@ -349,7 +348,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n \n     fn register_violations(&mut self,\n                            violations: &[UnsafetyViolation],\n-                           unsafe_blocks: &[(ast::NodeId, bool)]) {\n+                           unsafe_blocks: &[(hir::HirId, bool)]) {\n         let safety = self.source_scope_local_data[self.source_info.scope].safety;\n         let within_unsafe = match safety {\n             // `unsafe` blocks are required in safe code\n@@ -375,10 +374,10 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             }\n             // `unsafe` function bodies allow unsafe without additional unsafe blocks\n             Safety::BuiltinUnsafe | Safety::FnUnsafe => true,\n-            Safety::ExplicitUnsafe(node_id) => {\n+            Safety::ExplicitUnsafe(hir_id) => {\n                 // mark unsafe block as used if there are any unsafe operations inside\n                 if !violations.is_empty() {\n-                    self.used_unsafe.insert(node_id);\n+                    self.used_unsafe.insert(hir_id);\n                 }\n                 // only some unsafety is allowed in const fn\n                 if self.min_const_fn {\n@@ -405,8 +404,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 true\n             }\n         };\n-        self.inherited_blocks.extend(unsafe_blocks.iter().map(|&(node_id, is_used)| {\n-            (node_id, is_used && !within_unsafe)\n+        self.inherited_blocks.extend(unsafe_blocks.iter().map(|&(hir_id, is_used)| {\n+            (hir_id, is_used && !within_unsafe)\n         }));\n     }\n     fn check_mut_borrowing_layout_constrained_field(\n@@ -467,8 +466,8 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n }\n \n struct UnusedUnsafeVisitor<'a> {\n-    used_unsafe: &'a FxHashSet<ast::NodeId>,\n-    unsafe_blocks: &'a mut Vec<(ast::NodeId, bool)>,\n+    used_unsafe: &'a FxHashSet<hir::HirId>,\n+    unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>,\n }\n \n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n@@ -482,19 +481,19 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n         hir::intravisit::walk_block(self, block);\n \n         if let hir::UnsafeBlock(hir::UserProvided) = block.rules {\n-            self.unsafe_blocks.push((block.id, self.used_unsafe.contains(&block.id)));\n+            self.unsafe_blocks.push((block.hir_id, self.used_unsafe.contains(&block.hir_id)));\n         }\n     }\n }\n \n fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  def_id: DefId,\n-                                 used_unsafe: &FxHashSet<ast::NodeId>,\n-                                 unsafe_blocks: &'a mut Vec<(ast::NodeId, bool)>)\n+                                 used_unsafe: &FxHashSet<hir::HirId>,\n+                                 unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>)\n {\n     let body_id =\n-        tcx.hir().as_local_node_id(def_id).and_then(|node_id| {\n-            tcx.hir().maybe_body_owned_by(node_id)\n+        tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| {\n+            tcx.hir().maybe_body_owned_by_by_hir_id(hir_id)\n         });\n \n     let body_id = match body_id {\n@@ -574,18 +573,18 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n                   &message);\n }\n \n-/// Returns the `NodeId` for an enclosing scope that is also `unsafe`.\n+/// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n fn is_enclosed(tcx: TyCtxt<'_, '_, '_>,\n-               used_unsafe: &FxHashSet<ast::NodeId>,\n-               id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n-    let parent_id = tcx.hir().get_parent_node(id);\n+               used_unsafe: &FxHashSet<hir::HirId>,\n+               id: hir::HirId) -> Option<(String, hir::HirId)> {\n+    let parent_id = tcx.hir().get_parent_node_by_hir_id(id);\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n-        })) = tcx.hir().find(parent_id) {\n+        })) = tcx.hir().find_by_hir_id(parent_id) {\n             match header.unsafety {\n                 hir::Unsafety::Unsafe => Some((\"fn\".to_string(), parent_id)),\n                 hir::Unsafety::Normal => None,\n@@ -599,14 +598,14 @@ fn is_enclosed(tcx: TyCtxt<'_, '_, '_>,\n }\n \n fn report_unused_unsafe(tcx: TyCtxt<'_, '_, '_>,\n-                        used_unsafe: &FxHashSet<ast::NodeId>,\n-                        id: ast::NodeId) {\n-    let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n+                        used_unsafe: &FxHashSet<hir::HirId>,\n+                        id: hir::HirId) {\n+    let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id));\n     let msg = \"unnecessary `unsafe` block\";\n-    let mut db = tcx.struct_span_lint_node(UNUSED_UNSAFE, id, span, msg);\n+    let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);\n     db.span_label(span, msg);\n     if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span(id)),\n+        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id)),\n                       format!(\"because it's nested under this `unsafe` {}\", kind));\n     }\n     db.emit();\n@@ -655,20 +654,20 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n                     .note(&details.as_str()[..])\n                     .emit();\n             }\n-            UnsafetyViolationKind::ExternStatic(lint_node_id) => {\n+            UnsafetyViolationKind::ExternStatic(lint_hir_id) => {\n                 tcx.lint_node_note(SAFE_EXTERN_STATICS,\n-                              lint_node_id,\n+                              lint_hir_id,\n                               source_info.span,\n                               &format!(\"{} is unsafe and requires unsafe function or block \\\n                                         (error E0133)\", &description.as_str()[..]),\n                               &details.as_str()[..]);\n             }\n-            UnsafetyViolationKind::BorrowPacked(lint_node_id) => {\n+            UnsafetyViolationKind::BorrowPacked(lint_hir_id) => {\n                 if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n                     tcx.unsafe_derive_on_repr_packed(impl_def_id);\n                 } else {\n                     tcx.lint_node_note(SAFE_PACKED_BORROWS,\n-                                  lint_node_id,\n+                                  lint_hir_id,\n                                   source_info.span,\n                                   &format!(\"{} is unsafe and requires unsafe function or block \\\n                                             (error E0133)\", &description.as_str()[..]),\n@@ -679,7 +678,7 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     }\n \n     let mut unsafe_blocks: Vec<_> = unsafe_blocks.into_iter().collect();\n-    unsafe_blocks.sort();\n+    unsafe_blocks.sort_by_cached_key(|(hir_id, _)| tcx.hir().hir_to_node_id(*hir_id));\n     let used_unsafe: FxHashSet<_> = unsafe_blocks.iter()\n         .flat_map(|&&(id, used)| if used { Some(id) } else { None })\n         .collect();"}, {"sha": "24fe7d43883fe3498f9c6bae4af72fcc184ddc01", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -430,10 +430,10 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                         } else {\n                             \"left\"\n                         };\n-                        let node_id = source_scope_local_data[source_info.scope].lint_root;\n-                        self.tcx.lint_node(\n+                        let hir_id = source_scope_local_data[source_info.scope].lint_root;\n+                        self.tcx.lint_hir(\n                             ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n-                            node_id,\n+                            hir_id,\n                             span,\n                             &format!(\"attempt to shift {} with overflow\", dir));\n                         return None;"}, {"sha": "f602ed24acd4e14ff98d0d9b6cd20cb9e03d00d1", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.param_env,\n             liberated_sig,\n             decl,\n-            expr.id,\n+            expr.hir_id,\n             body,\n             gen,\n         ).1;"}, {"sha": "61fc58ec86182f25f713315e457b9195edfe46d9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -388,14 +388,14 @@ impl Needs {\n \n #[derive(Copy, Clone)]\n pub struct UnsafetyState {\n-    pub def: ast::NodeId,\n+    pub def: hir::HirId,\n     pub unsafety: hir::Unsafety,\n     pub unsafe_push_count: u32,\n     from_fn: bool\n }\n \n impl UnsafetyState {\n-    pub fn function(unsafety: hir::Unsafety, def: ast::NodeId) -> UnsafetyState {\n+    pub fn function(unsafety: hir::Unsafety, def: hir::HirId) -> UnsafetyState {\n         UnsafetyState { def: def, unsafety: unsafety, unsafe_push_count: 0, from_fn: true }\n     }\n \n@@ -410,11 +410,11 @@ impl UnsafetyState {\n             unsafety => {\n                 let (unsafety, def, count) = match blk.rules {\n                     hir::PushUnsafeBlock(..) =>\n-                        (unsafety, blk.id, self.unsafe_push_count.checked_add(1).unwrap()),\n+                        (unsafety, blk.hir_id, self.unsafe_push_count.checked_add(1).unwrap()),\n                     hir::PopUnsafeBlock(..) =>\n-                        (unsafety, blk.id, self.unsafe_push_count.checked_sub(1).unwrap()),\n+                        (unsafety, blk.hir_id, self.unsafe_push_count.checked_sub(1).unwrap()),\n                     hir::UnsafeBlock(..) =>\n-                        (hir::Unsafety::Unsafe, blk.id, self.unsafe_push_count),\n+                        (hir::Unsafety::Unsafe, blk.hir_id, self.unsafe_push_count),\n                     hir::DefaultBlock =>\n                         (unsafety, self.def, self.unsafe_push_count),\n                 };\n@@ -770,10 +770,10 @@ fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// (notably closures), `typeck_tables(def_id)` would wind up\n /// redirecting to the owning function.\n fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             id: ast::NodeId)\n+                             id: hir::HirId)\n                              -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n {\n-    match tcx.hir().get(id) {\n+    match tcx.hir().get_by_hir_id(id) {\n         Node::Item(item) => {\n             match item.node {\n                 hir::ItemKind::Const(_, body) |\n@@ -820,7 +820,7 @@ fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return tcx.has_typeck_tables(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     primary_body_of(tcx, id).is_some()\n }\n \n@@ -840,8 +840,8 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return tcx.typeck_tables_of(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let span = tcx.hir().span(id);\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let span = tcx.hir().span_by_hir_id(id);\n \n     // Figure out what primary body this item has.\n     let (body_id, fn_decl) = primary_body_of(tcx, id).unwrap_or_else(|| {\n@@ -925,8 +925,8 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Consistency check our TypeckTables instance can hold all ItemLocalIds\n     // it will need to hold.\n-    assert_eq!(tables.local_id_root,\n-               Some(DefId::local(tcx.hir().definitions().node_to_hir_id(id).owner)));\n+    assert_eq!(tables.local_id_root, Some(DefId::local(id.owner)));\n+\n     tables\n }\n \n@@ -939,7 +939,7 @@ fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n \n struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    parent_id: ast::NodeId,\n+    parent_id: hir::HirId,\n }\n \n impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n@@ -1051,7 +1051,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             param_env: ty::ParamEnv<'tcx>,\n                             fn_sig: ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n-                            fn_id: ast::NodeId,\n+                            fn_id: hir::HirId,\n                             body: &'gcx hir::Body,\n                             can_be_generator: Option<hir::GeneratorMovability>)\n                             -> (FnCtxt<'a, 'gcx, 'tcx>, Option<GeneratorTypes<'tcx>>)\n@@ -1085,9 +1085,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id(fn_id));\n-    let outer_node_id = fcx.tcx.hir().as_local_node_id(outer_def_id).unwrap();\n-    GatherLocalsVisitor { fcx: &fcx, parent_id: outer_node_id, }.visit_body(body);\n+    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id_from_hir_id(fn_id));\n+    let outer_hir_id = fcx.tcx.hir().as_local_hir_id(outer_def_id).unwrap();\n+    GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id, }.visit_body(body);\n \n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n@@ -1110,8 +1110,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.write_ty(arg.hir_id, arg_ty);\n     }\n \n-    let fn_hir_id = fcx.tcx.hir().node_to_hir_id(fn_id);\n-    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);\n+    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n     fcx.check_return_expr(&body.value);\n \n@@ -1164,14 +1163,13 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // Check that the main return type implements the termination trait.\n     if let Some(term_id) = fcx.tcx.lang_items().termination() {\n         if let Some((def_id, EntryFnType::Main)) = fcx.tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = fcx.tcx.hir().as_local_node_id(def_id).unwrap();\n+            let main_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n             if main_id == fn_id {\n                 let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n                 let return_ty_span = decl.output.span();\n-                let fn_hir_id = fcx.tcx.hir().node_to_hir_id(fn_id);\n                 let cause = traits::ObligationCause::new(\n-                    return_ty_span, fn_hir_id, ObligationCauseCode::MainFunctionType);\n+                    return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n \n                 inherited.register_predicate(\n                     traits::Obligation::new(\n@@ -1182,7 +1180,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n-        if panic_impl_did == fcx.tcx.hir().local_def_id(fn_id) {\n+        if panic_impl_did == fcx.tcx.hir().local_def_id_from_hir_id(fn_id) {\n             if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n                 // at this point we don't care if there are duplicate handlers or if the handler has\n                 // the wrong signature as this value we'll be used when writing metadata and that\n@@ -1197,7 +1195,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = fcx.tcx.hir().span_by_hir_id(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].sty {\n                         ty::Ref(region, ty, mutbl) => match ty.sty {\n@@ -1218,7 +1216,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir().get_by_hir_id(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -1240,7 +1238,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n-        if alloc_error_handler_did == fcx.tcx.hir().local_def_id(fn_id) {\n+        if alloc_error_handler_did == fcx.tcx.hir().local_def_id_from_hir_id(fn_id) {\n             if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.sty != ty::Never {\n                     fcx.tcx.sess.span_err(\n@@ -1250,7 +1248,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = fcx.tcx.hir().span_by_hir_id(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].sty {\n                         ty::Adt(ref adt, _) => {\n@@ -1266,7 +1264,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir().get_by_hir_id(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -2030,7 +2028,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ret_coercion_span: RefCell::new(None),\n             yield_ty: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n-                                                     ast::CRATE_NODE_ID)),\n+                                                     hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             has_errors: Cell::new(false),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {\n@@ -2339,10 +2337,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// `InferCtxt::instantiate_opaque_types` for more details.\n     fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n         &self,\n-        parent_id: ast::NodeId,\n+        parent_id: hir::HirId,\n         value: &T,\n     ) -> T {\n-        let parent_def_id = self.tcx.hir().local_def_id(parent_id);\n+        let parent_def_id = self.tcx.hir().local_def_id_from_hir_id(parent_id);\n         debug!(\"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n                parent_def_id,\n                value);\n@@ -4937,7 +4935,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             may_break: false,\n         };\n \n-        let (ctxt, ()) = self.with_breakable_ctxt(blk.id, ctxt, || {\n+        let blk_node_id = self.tcx.hir().hir_to_node_id(blk.hir_id);\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk_node_id, ctxt, || {\n             for s in &blk.stmts {\n                 self.check_stmt(s);\n             }\n@@ -4947,12 +4946,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n \n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(blk.id);\n+            let ctxt = enclosing_breakables.find_breakable(blk_node_id);\n             let coerce = ctxt.coerce.as_mut().unwrap();\n             if let Some(tail_expr_ty) = tail_expr_ty {\n                 let tail_expr = tail_expr.unwrap();\n                 let cause = self.cause(tail_expr.span,\n-                                       ObligationCauseCode::BlockTailExpression(blk.id));\n+                                       ObligationCauseCode::BlockTailExpression(blk_node_id));\n                 coerce.coerce(self,\n                               &cause,\n                               tail_expr,\n@@ -4976,9 +4975,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // that highlight errors inline.\n                     let mut sp = blk.span;\n                     let mut fn_span = None;\n-                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.id) {\n+                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk_node_id) {\n                         let ret_sp = decl.output.span();\n-                        if let Some(block_sp) = self.parent_item_span(blk.id) {\n+                        if let Some(block_sp) = self.parent_item_span(blk_node_id) {\n                             // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n                             // output would otherwise be incorrect and even misleading. Make sure\n                             // the span we're aiming at correspond to a `fn` body."}, {"sha": "5279fbd9cf6ebf32c466e09535bbaf5fb6a0d05d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021a140dcdbbae9050818b3f28402385efab3adc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=021a140dcdbbae9050818b3f28402385efab3adc", "patch": "@@ -90,7 +90,6 @@ use rustc_data_structures::sync::Lrc;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax_pos::Span;\n \n // a variation on try that just returns unit\n@@ -163,7 +162,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// rest of type check and because sometimes we need type\n     /// inference to have completed before we can determine which\n     /// constraints to add.\n-    pub fn regionck_fn(&self, fn_id: ast::NodeId, body: &'gcx hir::Body) {\n+    pub fn regionck_fn(&self, fn_id: hir::HirId, body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let hir_id = body.value.hir_id;\n@@ -176,9 +175,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         if self.err_count_since_creation() == 0 {\n-            let fn_hir_id = self.tcx.hir().node_to_hir_id(fn_id);\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_hir_id, body, self.tcx.hir().span_by_hir_id(fn_hir_id));\n+            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span_by_hir_id(fn_id));\n         }\n \n         rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));"}]}