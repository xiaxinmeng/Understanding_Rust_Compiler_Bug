{"sha": "321a54d26f1851f64feab6dba19b7af2e9e7c75f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMWE1NGQyNmYxODUxZjY0ZmVhYjZkYmExOWI3YWYyZTllN2M3NWY=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2013-03-17T10:41:03Z"}, "committer": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2013-03-17T23:42:14Z"}, "message": "Refactored sudoku benchmark to use traits and added some tests", "tree": {"sha": "15dcce9af8e92281fce20346532783bf4b9308d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15dcce9af8e92281fce20346532783bf4b9308d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/321a54d26f1851f64feab6dba19b7af2e9e7c75f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/321a54d26f1851f64feab6dba19b7af2e9e7c75f", "html_url": "https://github.com/rust-lang/rust/commit/321a54d26f1851f64feab6dba19b7af2e9e7c75f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/321a54d26f1851f64feab6dba19b7af2e9e7c75f/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a77a1048897a12c9031d3e0b3867f0c6e3673ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a77a1048897a12c9031d3e0b3867f0c6e3673ea", "html_url": "https://github.com/rust-lang/rust/commit/5a77a1048897a12c9031d3e0b3867f0c6e3673ea"}], "stats": {"total": 307, "additions": 201, "deletions": 106}, "files": [{"sha": "92320986ae83b384ae621de1f693d265d765834d", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 201, "deletions": 106, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/321a54d26f1851f64feab6dba19b7af2e9e7c75f/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321a54d26f1851f64feab6dba19b7af2e9e7c75f/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=321a54d26f1851f64feab6dba19b7af2e9e7c75f", "patch": "@@ -12,9 +12,9 @@\n \n extern mod std;\n \n-use std::bitv;\n use core::io::{ReaderUtil, WriterUtil};\n use core::io;\n+use core::unstable::intrinsics::cttz16;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -35,146 +35,241 @@ use core::io;\n // internal type of sudoku grids\n type grid = ~[~[u8]];\n \n-// exported type of sudoku grids\n-pub enum grid_t { grid_ctor(grid), }\n-\n-// read a sudoku problem from file f\n-pub fn read_grid(f: @io::Reader) -> grid_t {\n-    fail_unless!(f.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n-\n-    let mut g = vec::from_fn(10u, {|_i|\n-        vec::from_elem(10u, 0 as u8)\n-    });\n-    while !f.eof() {\n-        let comps = str::split_char(str::trim(f.read_line()), ',');\n-        if vec::len(comps) >= 3u {\n-            let row     = uint::from_str(comps[0]).get() as u8;\n-            let col     = uint::from_str(comps[1]).get() as u8;\n-            g[row][col] = uint::from_str(comps[2]).get() as u8;\n+struct Sudoku {\n+    grid: grid\n+}\n+\n+pub impl Sudoku {\n+    static pub fn new(g: grid) -> Sudoku {\n+        return Sudoku { grid: g }\n+    }\n+\n+    static pub fn from_vec(vec: &[[u8 * 9] * 9]) -> Sudoku {\n+        let mut g = do vec::from_fn(9u) |i| {\n+            do vec::from_fn(9u) |j| { vec[i][j] }\n+        };\n+        return Sudoku::new(g)\n+    }\n+\n+    pub fn equal(&self, other: &Sudoku) -> bool {\n+        for u8::range(0u8, 9u8) |row| {\n+            for u8::range(0u8, 9u8) |col| {\n+                if self.grid[row][col] != other.grid[row][col] {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    static pub fn read(reader: @io::Reader) -> Sudoku {\n+        fail_unless!(reader.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n+\n+        let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n+        while !reader.eof() {\n+            let comps = str::split_char(str::trim(reader.read_line()), ',');\n+            if vec::len(comps) == 3u {\n+                let row     = uint::from_str(comps[0]).get() as u8;\n+                let col     = uint::from_str(comps[1]).get() as u8;\n+                g[row][col] = uint::from_str(comps[2]).get() as u8;\n+            }\n+            else {\n+                fail!(~\"Invalid sudoku file\");\n+            }\n+        }\n+        return Sudoku::new(g)\n+    }\n+\n+    pub fn write(&self, writer: @io::Writer) {\n+        for u8::range(0u8, 9u8) |row| {\n+            writer.write_str(fmt!(\"%u\", self.grid[row][0] as uint));\n+            for u8::range(1u8, 9u8) |col| {\n+                writer.write_str(fmt!(\" %u\", self.grid[row][col] as uint));\n+            }\n+            writer.write_char('\\n');\n+         }\n+    }\n+\n+    // solve sudoku grid\n+    pub fn solve(&mut self) {\n+        let mut work: ~[(u8, u8)] = ~[]; /* queue of uncolored fields */\n+        for u8::range(0u8, 9u8) |row| {\n+            for u8::range(0u8, 9u8) |col| {\n+                let color = self.grid[row][col];\n+                if color == 0u8 { work += ~[(row, col)]; }\n+            }\n+        }\n+\n+        let mut ptr = 0u;\n+        let end = vec::len(work);\n+        while (ptr < end) {\n+            let (row, col) = work[ptr];\n+            // is there another color to try?\n+            if self.next_color(row, col, self.grid[row][col] + (1 as u8)) {\n+                //  yes: advance work list\n+                ptr = ptr + 1u;\n+            } else {\n+                // no: redo this field aft recoloring pred; unless there is none\n+                if ptr == 0u { fail!(~\"No solution found for this sudoku\"); }\n+                ptr = ptr - 1u;\n+            }\n         }\n     }\n-    return grid_ctor(g);\n-}\n \n-// solve sudoku grid\n-pub fn solve_grid(g: grid_t) {\n-    fn next_color(mut g: grid, row: u8, col: u8, start_color: u8) -> bool {\n+    fn next_color(&mut self, row: u8, col: u8, start_color: u8) -> bool {\n         if start_color < 10u8 {\n             // colors not yet used\n-            let mut avail = bitv::Bitv::new(10u, false);\n-            for u8::range(start_color, 10u8) |color| {\n-                avail.set(color as uint, true);\n-            }\n+            let mut avail = ~Colors::new(start_color);\n \n             // drop colors already in use in neighbourhood\n-            drop_colors(copy g, copy avail, row, col);\n+            self.drop_colors(avail, row, col);\n \n             // find first remaining color that is available\n-            for uint::range(1u, 10u) |i| {\n-                if avail.get(i) {\n-                    g[row][col] = i as u8;\n-                    return true;\n-                }\n-            };\n+            let next = avail.next();\n+            self.grid[row][col] = next;\n+            return 0u8 != next;\n         }\n-        g[row][col] = 0u8;\n+        self.grid[row][col] = 0u8;\n         return false;\n     }\n \n     // find colors available in neighbourhood of (row, col)\n-    fn drop_colors(g: grid, avail: bitv::Bitv, row: u8, col: u8) {\n-        fn drop_color(g: grid, mut colors: bitv::Bitv, row: u8, col: u8) {\n-            let color = g[row][col];\n-            if color != 0u8 { colors.set(color as uint, false); }\n-        }\n-\n-        let it = |a,b| drop_color(copy g, copy avail, a, b);\n-\n+    fn drop_colors(&mut self, avail: &mut Colors, row: u8, col: u8) {\n         for u8::range(0u8, 9u8) |idx| {\n-            it(idx, col); /* check same column fields */\n-            it(row, idx); /* check same row fields */\n+            avail.remove(self.grid[idx][col]); /* check same column fields */\n+            avail.remove(self.grid[row][idx]); /* check same row fields */\n         }\n \n         // check same block fields\n         let row0 = (row / 3u8) * 3u8;\n         let col0 = (col / 3u8) * 3u8;\n         for u8::range(row0, row0 + 3u8) |alt_row| {\n-            for u8::range(col0, col0 + 3u8) |alt_col| { it(alt_row, alt_col); }\n+            for u8::range(col0, col0 + 3u8) |alt_col| { avail.remove(self.grid[alt_row][alt_col]); }\n         }\n     }\n+}\n+\n+// Stores available colors as simple bitfield, bit 0 is always unset\n+struct Colors(u16);\n+\n+const heads: u16 = (1u16 << 10) - 1; /* bits 9..0 */\n+\n+impl Colors {\n+    static fn new(start_color: u8) -> Colors {\n+        // Sets bits 9..start_color\n+        let tails = !0u16 << start_color;\n+        return Colors(heads & tails);\n+    }\n \n-    let mut work: ~[(u8, u8)] = ~[]; /* queue of uncolored fields */\n-    for u8::range(0u8, 9u8) |row| {\n-        for u8::range(0u8, 9u8) |col| {\n-            let color = (*g)[row][col];\n-            if color == 0u8 { work += ~[(row, col)]; }\n+    fn next(&self) -> u8 {\n+        let val = **self & heads;\n+        if (0u16 == val) {\n+            return 0u8;\n+        }\n+        else\n+        {\n+            return cttz16(val as i16) as u8;\n         }\n     }\n \n-    let mut ptr = 0u;\n-    let end = vec::len(work);\n-    while (ptr < end) {\n-        let (row, col) = work[ptr];\n-        // is there another color to try?\n-        if next_color(copy *g, row, col, (*g)[row][col] + (1 as u8)) {\n-            //  yes: advance work list\n-            ptr = ptr + 1u;\n-        } else {\n-            // no: redo this field aft recoloring pred; unless there is none\n-            if ptr == 0u { fail!(~\"No solution found for this sudoku\"); }\n-            ptr = ptr - 1u;\n+    fn remove(&mut self, color: u8) {\n+        if color != 0u8 {\n+            let val  = **self;\n+            let mask = !(1u16 << color);\n+            *self    = Colors(val & mask);\n         }\n     }\n }\n \n-pub fn write_grid(f: @io::Writer, g: grid_t) {\n-    for u8::range(0u8, 9u8) |row| {\n-        f.write_str(fmt!(\"%u\", (*g)[row][0] as uint));\n-        for u8::range(1u8, 9u8) |col| {\n-            f.write_str(fmt!(\" %u\", (*g)[row][col] as uint));\n-        }\n-        f.write_char('\\n');\n-     }\n+const default_sudoku: [[u8 * 9] * 9] = [\n+         /* 0    1    2    3    4    5    6    7    8    */\n+  /* 0 */  [0u8, 4u8, 0u8, 6u8, 0u8, 0u8, 0u8, 3u8, 2u8],\n+  /* 1 */  [0u8, 0u8, 8u8, 0u8, 2u8, 0u8, 0u8, 0u8, 0u8],\n+  /* 2 */  [7u8, 0u8, 0u8, 8u8, 0u8, 0u8, 0u8, 0u8, 0u8],\n+  /* 3 */  [0u8, 0u8, 0u8, 5u8, 0u8, 0u8, 0u8, 0u8, 0u8],\n+  /* 4 */  [0u8, 5u8, 0u8, 0u8, 0u8, 3u8, 6u8, 0u8, 0u8],\n+  /* 5 */  [6u8, 8u8, 0u8, 0u8, 0u8, 0u8, 0u8, 9u8, 0u8],\n+  /* 6 */  [0u8, 9u8, 5u8, 0u8, 0u8, 6u8, 0u8, 7u8, 0u8],\n+  /* 7 */  [0u8, 0u8, 0u8, 0u8, 4u8, 0u8, 0u8, 6u8, 0u8],\n+  /* 8 */  [4u8, 0u8, 0u8, 0u8, 0u8, 7u8, 2u8, 0u8, 3u8]\n+];\n+\n+#[cfg(test)]\n+const default_solution: [[u8 * 9] * 9] = [\n+         /* 0    1    2    3    4    5    6    7    8    */\n+  /* 0 */  [1u8, 4u8, 9u8, 6u8, 7u8, 5u8, 8u8, 3u8, 2u8],\n+  /* 1 */  [5u8, 3u8, 8u8, 1u8, 2u8, 9u8, 7u8, 4u8, 6u8],\n+  /* 2 */  [7u8, 2u8, 6u8, 8u8, 3u8, 4u8, 1u8, 5u8, 9u8],\n+  /* 3 */  [9u8, 1u8, 4u8, 5u8, 6u8, 8u8, 3u8, 2u8, 7u8],\n+  /* 4 */  [2u8, 5u8, 7u8, 4u8, 9u8, 3u8, 6u8, 1u8, 8u8],\n+  /* 5 */  [6u8, 8u8, 3u8, 7u8, 1u8, 2u8, 5u8, 9u8, 4u8],\n+  /* 6 */  [3u8, 9u8, 5u8, 2u8, 8u8, 6u8, 4u8, 7u8, 1u8],\n+  /* 7 */  [8u8, 7u8, 2u8, 3u8, 4u8, 1u8, 9u8, 6u8, 5u8],\n+  /* 8 */  [4u8, 6u8, 1u8, 9u8, 5u8, 7u8, 2u8, 8u8, 3u8]\n+];\n+\n+#[test]\n+fn colors_new_works() {\n+    fail_unless!(*Colors::new(1) == 1022u16);\n+    fail_unless!(*Colors::new(2) == 1020u16);\n+    fail_unless!(*Colors::new(3) == 1016u16);\n+    fail_unless!(*Colors::new(4) == 1008u16);\n+    fail_unless!(*Colors::new(5) == 992u16);\n+    fail_unless!(*Colors::new(6) == 960u16);\n+    fail_unless!(*Colors::new(7) == 896u16);\n+    fail_unless!(*Colors::new(8) == 768u16);\n+    fail_unless!(*Colors::new(9) == 512u16);\n+}\n+\n+#[test]\n+fn colors_next_works() {\n+    fail_unless!(Colors(0).next() == 0u8);\n+    fail_unless!(Colors(2).next() == 1u8);\n+    fail_unless!(Colors(4).next() == 2u8);\n+    fail_unless!(Colors(8).next() == 3u8);\n+    fail_unless!(Colors(16).next() == 4u8);\n+    fail_unless!(Colors(32).next() == 5u8);\n+    fail_unless!(Colors(64).next() == 6u8);\n+    fail_unless!(Colors(128).next() == 7u8);\n+    fail_unless!(Colors(256).next() == 8u8);\n+    fail_unless!(Colors(512).next() == 9u8);\n+    fail_unless!(Colors(1024).next() == 0u8);\n+}\n+\n+#[test]\n+fn colors_remove_works() {\n+    // GIVEN\n+    let mut colors = Colors::new(1);\n+\n+    // WHEN\n+    colors.remove(1);\n+\n+    // THEN\n+    fail_unless!(colors.next() == 2u8);\n+}\n+\n+#[test]\n+fn check_default_sudoku_solution() {\n+    // GIVEN\n+    let mut sudoku = Sudoku::from_vec(&default_sudoku);\n+    let solution   = Sudoku::from_vec(&default_solution);\n+\n+    // WHEN\n+    sudoku.solve();\n+\n+    // THEN\n+    fail_unless!(sudoku.equal(&solution));\n }\n \n fn main() {\n-    let args = os::args();\n-    let grid = if vec::len(args) == 1u {\n-        // FIXME create sudoku inline since nested vec consts dont work yet\n-        // (#3733)\n-        let mut g = vec::from_fn(10u, |_i| {\n-            vec::from_elem(10u, 0 as u8)\n-        });\n-        g[0][1] = 4u8;\n-        g[0][3] = 6u8;\n-        g[0][7] = 3u8;\n-        g[0][8] = 2u8;\n-        g[1][2] = 8u8;\n-        g[1][4] = 2u8;\n-        g[2][0] = 7u8;\n-        g[2][3] = 8u8;\n-        g[3][3] = 5u8;\n-        g[4][1] = 5u8;\n-        g[4][5] = 3u8;\n-        g[4][6] = 6u8;\n-        g[5][0] = 6u8;\n-        g[5][1] = 8u8;\n-        g[5][7] = 9u8;\n-        g[6][1] = 9u8;\n-        g[6][2] = 5u8;\n-        g[6][5] = 6u8;\n-        g[6][7] = 7u8;\n-        g[7][4] = 4u8;\n-        g[7][7] = 6u8;\n-        g[8][0] = 4u8;\n-        g[8][5] = 7u8;\n-        g[8][6] = 2u8;\n-        g[8][8] = 3u8;\n-        grid_ctor(g)\n+    let args        = os::args();\n+    let use_default = vec::len(args) == 1u;\n+    let mut sudoku = if use_default {\n+        Sudoku::from_vec(&default_sudoku)\n     } else {\n-        read_grid(io::stdin())\n+        Sudoku::read(io::stdin())\n     };\n-    solve_grid(copy grid);\n-    write_grid(io::stdout(), grid);\n+    sudoku.solve();\n+    sudoku.write(io::stdout());\n }\n "}]}