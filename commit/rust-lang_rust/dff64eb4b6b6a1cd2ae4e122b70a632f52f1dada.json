{"sha": "dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZjY0ZWI0YjZiNmExY2QyYWU0ZTEyMmI3MGE2MzJmNTJmMWRhZGE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2020-01-23T00:41:33Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2020-02-22T00:28:49Z"}, "message": "Make return value of `check_generic_arg_count` semantically clearer", "tree": {"sha": "563b80aa740512086361c1840c6de702502dc0c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/563b80aa740512086361c1840c6de702502dc0c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "html_url": "https://github.com/rust-lang/rust/commit/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9b7b1f73b8d256a0885506d8e7e76cd35067318", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b7b1f73b8d256a0885506d8e7e76cd35067318", "html_url": "https://github.com/rust-lang/rust/commit/c9b7b1f73b8d256a0885506d8e7e76cd35067318"}], "stats": {"total": 39, "additions": 19, "deletions": 20}, "files": [{"sha": "7df1383f86addad33a3759287668c30167c6d6dc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "patch": "@@ -941,7 +941,7 @@ impl GenericParamDefKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenericParamDef {\n     pub name: Symbol,\n     pub def_id: DefId,"}, {"sha": "03ff1b8a3171f6b5af9a9ddc154f1bda741bbcc7", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "patch": "@@ -17,12 +17,6 @@ use std::fmt;\n use std::rc::Rc;\n use std::sync::Arc;\n \n-impl fmt::Debug for ty::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}({}, {:?}, {})\", self.kind.descr(), self.name, self.def_id, self.index)\n-    }\n-}\n-\n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {"}, {"sha": "b3131c159a68d0cbb2707fa73eccfea6645c5a59", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "patch": "@@ -132,6 +132,10 @@ enum GenericArgPosition {\n     MethodCall,\n }\n \n+/// A marker denoting that the generic arguments that were\n+/// provided did not match the respective generic parameters.\n+pub struct GenericArgCountMismatch;\n+\n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn ast_region_to_region(\n         &self,\n@@ -262,7 +266,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def: &ty::Generics,\n         seg: &hir::PathSegment<'_>,\n         is_method_call: bool,\n-    ) -> bool {\n+    ) -> Result<(), GenericArgCountMismatch> {\n         let empty_args = hir::GenericArgs::none();\n         let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n         Self::check_generic_arg_count(\n@@ -287,7 +291,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_args: bool,\n-    ) -> (bool, Vec<Span>) {\n+    ) -> (Result<(), GenericArgCountMismatch>, Vec<Span>) {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n@@ -443,7 +447,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             );\n         }\n \n-        (arg_count_mismatch, unexpected_spans)\n+        (if arg_count_mismatch { Err(GenericArgCountMismatch) } else { Ok(()) }, unexpected_spans)\n     }\n \n     /// Report an error that a generic argument did not match the generic parameter that was\n@@ -495,7 +499,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        arg_count_mismatch: bool,\n+        arg_count_correct: Result<(), GenericArgCountMismatch>,\n         args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n         provided_kind: impl Fn(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n         mut inferred_kind: impl FnMut(\n@@ -589,7 +593,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 // another. This is an error. However, if we already know that\n                                 // the arguments don't match up with the parameters, we won't issue\n                                 // an additional error, as the user already knows what's wrong.\n-                                if !arg_count_mismatch {\n+                                if arg_count_correct.is_ok() {\n                                     Self::generic_arg_mismatch_err(tcx.sess, arg, kind.descr());\n                                 }\n \n@@ -615,7 +619,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         //  2.  We've inferred some lifetimes, which have been provided later (i.e.\n                         //      after a type or const). We want to throw an error in this case.\n \n-                        if !arg_count_mismatch {\n+                        if arg_count_correct.is_ok() {\n                             let kind = arg.descr();\n                             assert_eq!(kind, \"lifetime\");\n                             let provided =\n@@ -706,7 +710,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none() && parent_substs.is_empty());\n         }\n \n-        let (arg_count_mismatch, potential_assoc_types) = Self::check_generic_arg_count(\n+        let (arg_count_correct, potential_assoc_types) = Self::check_generic_arg_count(\n             tcx,\n             span,\n             &generic_params,\n@@ -739,7 +743,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             parent_substs,\n             self_ty.is_some(),\n             self_ty,\n-            arg_count_mismatch,\n+            arg_count_correct,\n             // Provide the generic args, and whether types should be inferred.\n             |did| {\n                 if did == def_id {"}, {"sha": "38773abeef28c5380ee04c31389c088f7ec9c473", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let generics = self.tcx.generics_of(pick.item.def_id);\n-        let arg_count_mismatch = AstConv::check_generic_arg_count_for_call(\n+        let arg_count_correct = AstConv::check_generic_arg_count_for_call(\n             self.tcx, self.span, &generics, &seg, true, // `is_method_call`\n         );\n \n@@ -313,7 +313,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             parent_substs,\n             false,\n             None,\n-            arg_count_mismatch,\n+            arg_count_correct,\n             // Provide the generic args, and whether types should be inferred.\n             |def_id| {\n                 // The last component of the returned tuple here is unimportant."}, {"sha": "426ba0ddaaa4f04e5d3dc903876ebf767f8d8ab2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dff64eb4b6b6a1cd2ae4e122b70a632f52f1dada", "patch": "@@ -87,7 +87,7 @@ mod upvar;\n mod wfcheck;\n pub mod writeback;\n \n-use crate::astconv::{AstConv, PathSeg};\n+use crate::astconv::{AstConv, GenericArgCountMismatch, PathSeg};\n use crate::middle::lang_items;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::Map;\n@@ -5454,7 +5454,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // checking here.\n             let suppress_errors = AstConv::check_generic_arg_count_for_call(\n                 tcx, span, &generics, &seg, false, // `is_method_call`\n-            );\n+            )\n+            .is_err();\n             if suppress_errors {\n                 infer_args_for_err.insert(index);\n                 self.set_tainted_by_errors(); // See issue #53251.\n@@ -5520,7 +5521,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &[][..],\n                 has_self,\n                 self_ty,\n-                !infer_args_for_err.is_empty(),\n+                if infer_args_for_err.is_empty() { Ok(()) } else { Err(GenericArgCountMismatch) },\n                 // Provide the generic args, and whether types should be inferred.\n                 |def_id| {\n                     if let Some(&PathSeg(_, index)) ="}]}