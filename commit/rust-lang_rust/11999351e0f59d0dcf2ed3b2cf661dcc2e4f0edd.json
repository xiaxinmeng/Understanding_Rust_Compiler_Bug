{"sha": "11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTk5MzUxZTBmNTlkMGRjZjJlZDNiMmNmNjYxZGNjMmU0ZjBlZGQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-01T16:35:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-01T16:35:18Z"}, "message": "Fill in the foreign-function part of the tutorial", "tree": {"sha": "76f8dbd8cf19727a8a0393b41a7b5ba331f2a867", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76f8dbd8cf19727a8a0393b41a7b5ba331f2a867"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "html_url": "https://github.com/rust-lang/rust/commit/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fec1798d0d7177c6d15b825d69f2db1a2e814ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fec1798d0d7177c6d15b825d69f2db1a2e814ff", "html_url": "https://github.com/rust-lang/rust/commit/4fec1798d0d7177c6d15b825d69f2db1a2e814ff"}], "stats": {"total": 193, "additions": 191, "deletions": 2}, "files": [{"sha": "ff2589b84430b7e50eea6fb042d45673e35e9a0c", "filename": "doc/tutorial/ext.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Fext.md", "raw_url": "https://github.com/rust-lang/rust/raw/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Fext.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fext.md?ref=11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "patch": "@@ -0,0 +1,3 @@\n+# Syntax extension\n+\n+FIXME to be written"}, {"sha": "797589c3599f44ddc636f6576e9da70f02b89b5b", "filename": "doc/tutorial/ffi.md", "status": "modified", "additions": 184, "deletions": 1, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fffi.md?ref=11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "patch": "@@ -1,3 +1,186 @@\n # Interacting with foreign code\n \n-FIXME to be written\n+On of Rust's aims, as a system programming language, is to\n+interoperate well with C code.\n+\n+We'll start with an example. It's a bit bigger than usual, and\n+contains a number of new concepts. We'll go over it one piece at a\n+time.\n+\n+This is a program that uses OpenSSL's `SHA1` function to compute the\n+hash of its first command-line argument, which it then converts to a\n+hexadecimal string and prints to standard output. If you have the\n+OpenSSL libraries installed, it should 'just work'.\n+\n+    use std;\n+    import std::{vec, str};\n+    \n+    native \"cdecl\" mod ssl {\n+        fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+    }\n+    \n+    fn as_hex(data: [u8]) -> str {\n+        let acc = \"\";\n+        for byte in data { acc += #fmt(\"%02x\", byte as uint); }\n+        ret acc;\n+    }\n+\n+    fn sha1(data: str) -> str unsafe {\n+        let bytes = str::bytes(data);\n+        let hash = ssl::SHA1(vec::unsafe::to_ptr(bytes),\n+                             vec::len(bytes), std::ptr::null());\n+        ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+    }\n+    \n+    fn main(args: [str]) {\n+        std::io::println(sha1(args[1]));\n+    }\n+\n+## Native modules\n+\n+Before we can call `SHA1`, we have to declare it. That is what this\n+part of the program is responsible for:\n+\n+    native \"cdecl\" mod ssl {\n+        fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+    }\n+\n+A `native` module declaration tells the compiler that the program\n+should be linked with a library by that name, and that the given list\n+of functions are available in that library.\n+\n+In this case, it'll change the name `ssl` to a shared library name in\n+a platform-specific way (`libssl.so` on Linux, for example), and link\n+that in. If you want the module to have a different name from the\n+actual library, you can say `native \"cdecl\" mod something = \"ssl\" {\n+... }`.\n+\n+The `\"cdecl\"` word indicates the calling convention to use for\n+functions in this module. Most C libraries use cdecl as their calling\n+convention. You can also specify `\"x86stdcall\"` to use stdcall\n+instead.\n+\n+FIXME: Mention c-stack variants? Are they going to change?\n+\n+## Unsafe pointers\n+\n+The native `SHA1` function is declared to take three arguments, and\n+return a pointer.\n+\n+    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+\n+When declaring the argument types to a foreign function, the Rust\n+compiler has no way to check whether your declaration is correct, so\n+you have to be careful. If you get the number or types of the\n+arguments wrong, you're likely to get a segmentation fault. Or,\n+probably even worse, your code will work on one platform, but break on\n+another.\n+\n+In this case, `SHA1` is defined as taking two `unsigned char*`\n+arguments and one `unsigned long`. The rust equivalents are `*u8`\n+unsafe pointers and an `uint` (which, like `unsigned long`, is a\n+machine-word-sized type).\n+\n+Unsafe pointers can be created through various functions in the\n+standard lib, usually with `unsafe` somewhere in their name. You can\n+dereference an unsafe pointer with `*` operator, but use\n+caution\u2014unlike Rust's other pointer types, unsafe pointers are\n+completely unmanaged, so they might point at invalid memory, or be\n+null pointers.\n+\n+## Unsafe blocks\n+\n+The `sha1` function is the most obscure part of the program.\n+\n+    fn sha1(data: str) -> str unsafe {\n+        let bytes = str::bytes(data);\n+        let hash = ssl::SHA1(vec::unsafe::to_ptr(bytes),\n+                             vec::len(bytes), std::ptr::null());\n+        ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+    }\n+\n+Firstly, what does the `unsafe` keyword at the top of the function\n+mean? `unsafe` is a block modifier\u2014it declares the block following it\n+to be known to be unsafe.\n+\n+Some operations, like dereferencing unsafe pointers or calling\n+functions that have been marked unsafe, are only allowed inside unsafe\n+blocks. With the `unsafe` keyword, you're telling the compiler 'I know\n+what I'm doing'. The main motivation for such an annotation is that\n+when you have a memory error (and you will, if you're using unsafe\n+constructs), you have some idea where to look\u2014it will most likely be\n+caused by some unsafe code.\n+\n+Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,\n+advertise it to the world. An unsafe function is written like this:\n+\n+    unsafe fn kaboom() { log \"I'm harmless!\"; }\n+\n+This function can only be called from an unsafe block or another\n+unsafe function.\n+\n+## Pointer fiddling\n+\n+The standard library defines a number of helper functions for dealing\n+with unsafe data, casting between types, and generally subverting\n+Rust's safety mechanisms.\n+\n+Let's look at our `sha1` function again.\n+\n+    let bytes = str::bytes(data);\n+    let hash = ssl::SHA1(vec::unsafe::to_ptr(bytes),\n+                         vec::len(bytes), std::ptr::null());\n+    ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+\n+The `str::bytes` function is perfectly safe, it converts a string to\n+an `[u8]`. This byte array is then fed to `vec::unsafe::to_ptr`, which\n+returns an unsafe pointer to its contents.\n+\n+This pointer will become invalid as soon as the vector it points into\n+is cleaned up, so you should be very careful how you use it. In this\n+case, the local variable `bytes` outlives the pointer, so we're good.\n+\n+Passing a null pointer as third argument to `SHA1` causes it to use a\n+static buffer, and thus save us the effort of allocating memory\n+ourselves. `ptr::null` is a generic function that will return an\n+unsafe null pointer of the correct type (Rust generics are awesome\n+like that\u2014they can take the right form depending on the type that they\n+are expected to return).\n+\n+Finally, `vec::unsafe::from_buf` builds up a new `[u8]` from the\n+unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n+twenty bytes long, so we can pass `20u` for the length of the new\n+vector.\n+\n+## Passing structures\n+\n+C functions often take pointers to structs as arguments. Since Rust\n+records are binary-compatible with C structs, Rust programs can call\n+such functions directly.\n+\n+This program uses the Posix function `gettimeofday` to get a\n+microsecond-resolution timer.\n+\n+    use std;\n+    type timeval = {tv_sec: u32, tv_usec: u32};\n+    native \"cdecl\" mod libc = \"\" {\n+        fn gettimeofday(tv: *mutable timeval, tz: *()) -> i32;\n+    }\n+    fn unix_time_in_microseconds() -> u64 unsafe {\n+        let x = {tv_sec: 0u32, tv_usec: 0u32};\n+        libc::gettimeofday(std::ptr::addr_of(x), std::ptr::null());\n+        ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n+    }\n+\n+The `libc = \"\"` sets the name of the native module to the empty string\n+to prevent the rust compiler from trying to link it. The standard C\n+library is already linked with Rust programs.\n+\n+A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n+define a record type with the same contents, and declare\n+`gettimeofday` to take a pointer to such a record.\n+\n+The second argument to `gettimeofday` (the time zone) is not used by\n+this program, so it simply declares it to be a pointer to the nil\n+type. Since null pointer look the same, no matter which type they are\n+supposed to point at, this is safe."}, {"sha": "7b66416f2911f655ae0d7055470b46736e295145", "filename": "doc/tutorial/order", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Forder", "raw_url": "https://github.com/rust-lang/rust/raw/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Forder", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Forder?ref=11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "patch": "@@ -8,5 +8,6 @@ args\n generic\n mod\n ffi\n+ext\n task\n test"}, {"sha": "bcdcac68101efc6c74bc4029e0c1871ca38533f4", "filename": "doc/tutorial/syntax.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsyntax.md?ref=11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "patch": "@@ -1,5 +1,7 @@\n # Syntax Basics\n \n+FIXME: briefly mention syntax extentions, #fmt\n+\n ## Braces\n \n Assuming you've programmed in any C-family language (C++, Java,"}, {"sha": "aff4f66f3863563a888ae303a5e2045f22c8cc7c", "filename": "doc/tutorial/web/default.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Fweb%2Fdefault.css", "raw_url": "https://github.com/rust-lang/rust/raw/11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd/doc%2Ftutorial%2Fweb%2Fdefault.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fweb%2Fdefault.css?ref=11999351e0f59d0dcf2ed3b2cf661dcc2e4f0edd", "patch": "@@ -4,7 +4,7 @@\n .cm-s-default span.cm-def {color: #00f;}\n .cm-s-default span.cm-variable {color: black;}\n .cm-s-default span.cm-variable-2 {color: #05a;}\n-.cm-s-default span.cm-variable-3 {color: #0a5;}\n+.cm-s-default span.cm-variable-3 {color: #085;}\n .cm-s-default span.cm-property {color: black;}\n .cm-s-default span.cm-operator {color: black;}\n .cm-s-default span.cm-comment {color: #a50;}"}]}