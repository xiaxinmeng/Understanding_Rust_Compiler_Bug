{"sha": "1c867b4e67126350579d6d598efeb6c03b503ddc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjODY3YjRlNjcxMjYzNTA1NzlkNmQ1OThlZmViNmMwM2I1MDNkZGM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-10T22:26:50Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-10T22:26:50Z"}, "message": "Merge #1390\n\n1390: use single version of either in hir r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "5e0d18e023a095c64a02f1c44c4a82245c89beeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e0d18e023a095c64a02f1c44c4a82245c89beeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c867b4e67126350579d6d598efeb6c03b503ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c867b4e67126350579d6d598efeb6c03b503ddc", "html_url": "https://github.com/rust-lang/rust/commit/1c867b4e67126350579d6d598efeb6c03b503ddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c867b4e67126350579d6d598efeb6c03b503ddc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "75e6c03883c4533b1134c806d166b72200b4837d", "url": "https://api.github.com/repos/rust-lang/rust/commits/75e6c03883c4533b1134c806d166b72200b4837d", "html_url": "https://github.com/rust-lang/rust/commit/75e6c03883c4533b1134c806d166b72200b4837d"}, {"sha": "156b7ee84210583fa2fdc7fb8ae1dccafdf80830", "url": "https://api.github.com/repos/rust-lang/rust/commits/156b7ee84210583fa2fdc7fb8ae1dccafdf80830", "html_url": "https://github.com/rust-lang/rust/commit/156b7ee84210583fa2fdc7fb8ae1dccafdf80830"}], "stats": {"total": 141, "additions": 73, "deletions": 68}, "files": [{"sha": "202c8838cad8ae925cbc79357b6864a1fafe21d0", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c867b4e67126350579d6d598efeb6c03b503ddc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1c867b4e67126350579d6d598efeb6c03b503ddc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1c867b4e67126350579d6d598efeb6c03b503ddc", "patch": "@@ -1079,7 +1079,6 @@ dependencies = [\n  \"chalk-ir 0.1.0 (git+https://github.com/flodiebold/chalk.git?branch=fuel)\",\n  \"chalk-rust-ir 0.1.0 (git+https://github.com/flodiebold/chalk.git?branch=fuel)\",\n  \"chalk-solve 0.1.0 (git+https://github.com/flodiebold/chalk.git?branch=fuel)\",\n- \"either 1.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flexi_logger 0.11.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "12d849f3775a593a0ce9e250d2b1606e1be27e1a", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=1c867b4e67126350579d6d598efeb6c03b503ddc", "patch": "@@ -12,7 +12,6 @@ rustc-hash = \"1.0\"\n parking_lot = \"0.8.0\"\n ena = \"0.11\"\n join_to_string = \"0.1.3\"\n-either = \"1.5.2\"\n once_cell = \"0.2\"\n \n ra_syntax = { path = \"../ra_syntax\" }"}, {"sha": "71c53ebc066226086530aa26c7140c80121bdf77", "filename": "crates/ra_hir/src/either.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Feither.rs?ref=1c867b4e67126350579d6d598efeb6c03b503ddc", "patch": "@@ -25,4 +25,22 @@ impl<A, B> Either<A, B> {\n             Either::B(b) => Either::B(f2(b)),\n         }\n     }\n+    pub fn a(self) -> Option<A> {\n+        match self {\n+            Either::A(it) => Some(it),\n+            Either::B(_) => None,\n+        }\n+    }\n+    pub fn b(self) -> Option<B> {\n+        match self {\n+            Either::A(_) => None,\n+            Either::B(it) => Some(it),\n+        }\n+    }\n+    pub fn as_ref(&self) -> Either<&A, &B> {\n+        match self {\n+            Either::A(it) => Either::A(it),\n+            Either::B(it) => Either::B(it),\n+        }\n+    }\n }"}, {"sha": "d84134877ecc002f5592680a7ee8af3eb571beb6", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=1c867b4e67126350579d6d598efeb6c03b503ddc", "patch": "@@ -56,7 +56,6 @@ mod tests;\n use std::sync::Arc;\n \n use rustc_hash::{FxHashMap, FxHashSet};\n-use either::Either;\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n@@ -70,6 +69,7 @@ use crate::{\n     ids::MacroDefId,\n     diagnostics::DiagnosticSink,\n     nameres::diagnostics::DefDiagnostic,\n+    either::Either,\n     AstId,\n };\n \n@@ -164,8 +164,8 @@ impl ModuleScope {\n     }\n     fn get_item_or_macro(&self, name: &Name) -> Option<ItemOrMacro> {\n         match (self.get(name), self.macros.get(name)) {\n-            (Some(item), _) if !item.def.is_none() => Some(Either::Left(item.def)),\n-            (_, Some(macro_)) => Some(Either::Right(*macro_)),\n+            (Some(item), _) if !item.def.is_none() => Some(Either::A(item.def)),\n+            (_, Some(macro_)) => Some(Either::B(*macro_)),\n             _ => None,\n         }\n     }\n@@ -190,7 +190,7 @@ struct ResolvePathResult {\n \n impl ResolvePathResult {\n     fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(Either::Left(PerNs::none()), reached_fixedpoint, None)\n+        ResolvePathResult::with(Either::A(PerNs::none()), reached_fixedpoint, None)\n     }\n \n     fn with(\n@@ -217,13 +217,13 @@ enum ReachedFixedPoint {\n /// helper function for select item or macro to use\n fn or(left: ItemOrMacro, right: ItemOrMacro) -> ItemOrMacro {\n     match (left, right) {\n-        (Either::Left(s), Either::Left(o)) => Either::Left(s.or(o)),\n-        (Either::Right(s), _) => Either::Right(s),\n-        (Either::Left(s), Either::Right(o)) => {\n+        (Either::A(s), Either::A(o)) => Either::A(s.or(o)),\n+        (Either::B(s), _) => Either::B(s),\n+        (Either::A(s), Either::B(o)) => {\n             if !s.is_none() {\n-                Either::Left(s)\n+                Either::A(s)\n             } else {\n-                Either::Right(o)\n+                Either::B(o)\n             }\n         }\n     }\n@@ -306,7 +306,7 @@ impl CrateDefMap {\n         path: &Path,\n     ) -> (PerNs<ModuleDef>, Option<usize>) {\n         let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n-        (res.resolved_def.left().unwrap_or_else(PerNs::none), res.segment_index)\n+        (res.resolved_def.a().unwrap_or_else(PerNs::none), res.segment_index)\n     }\n \n     pub(crate) fn resolve_path_with_macro(\n@@ -330,10 +330,10 @@ impl CrateDefMap {\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: ItemOrMacro = match path.kind {\n-            PathKind::Crate => Either::Left(PerNs::types(\n-                Module { krate: self.krate, module_id: self.root }.into(),\n-            )),\n-            PathKind::Self_ => Either::Left(PerNs::types(\n+            PathKind::Crate => {\n+                Either::A(PerNs::types(Module { krate: self.krate, module_id: self.root }.into()))\n+            }\n+            PathKind::Self_ => Either::A(PerNs::types(\n                 Module { krate: self.krate, module_id: original_module }.into(),\n             )),\n             // plain import or absolute path in 2015: crate-relative with\n@@ -361,7 +361,7 @@ impl CrateDefMap {\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n-                    Either::Left(PerNs::types(Module { krate: self.krate, module_id: p }.into()))\n+                    Either::A(PerNs::types(Module { krate: self.krate, module_id: p }.into()))\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -375,15 +375,15 @@ impl CrateDefMap {\n                 };\n                 if let Some(def) = self.extern_prelude.get(&segment.name) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    Either::Left(PerNs::types(*def))\n+                    Either::A(PerNs::types(*def))\n                 } else {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n         };\n \n         for (i, segment) in segments {\n-            let curr = match curr_per_ns.as_ref().left().and_then(|m| m.as_ref().take_types()) {\n+            let curr = match curr_per_ns.as_ref().a().and_then(|m| m.as_ref().take_types()) {\n                 Some(r) => r,\n                 None => {\n                     // we still have path segments left, but the path so far\n@@ -424,10 +424,10 @@ impl CrateDefMap {\n                     // enum variant\n                     tested_by!(can_import_enum_variant);\n                     match e.variant(db, &segment.name) {\n-                        Some(variant) => Either::Left(PerNs::both(variant.into(), variant.into())),\n+                        Some(variant) => Either::A(PerNs::both(variant.into(), variant.into())),\n                         None => {\n                             return ResolvePathResult::with(\n-                                Either::Left(PerNs::types((*e).into())),\n+                                Either::A(PerNs::types((*e).into())),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n                             );\n@@ -444,7 +444,7 @@ impl CrateDefMap {\n                     );\n \n                     return ResolvePathResult::with(\n-                        Either::Left(PerNs::types(*s)),\n+                        Either::A(PerNs::types(*s)),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n                     );\n@@ -458,10 +458,10 @@ impl CrateDefMap {\n         let from_crate_root = self[self.root]\n             .scope\n             .get_item_or_macro(name)\n-            .unwrap_or_else(|| Either::Left(PerNs::none()));\n+            .unwrap_or_else(|| Either::A(PerNs::none()));\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n-        or(from_crate_root, Either::Left(from_extern_prelude))\n+        or(from_crate_root, Either::A(from_extern_prelude))\n     }\n \n     pub(crate) fn resolve_name_in_module(\n@@ -470,7 +470,7 @@ impl CrateDefMap {\n         module: CrateModuleId,\n         name: &Name,\n     ) -> PerNs<ModuleDef> {\n-        self.resolve_name_in_module_with_macro(db, module, name).left().unwrap_or_else(PerNs::none)\n+        self.resolve_name_in_module_with_macro(db, module, name).a().unwrap_or_else(PerNs::none)\n     }\n \n     fn resolve_name_in_module_with_macro(\n@@ -483,15 +483,13 @@ impl CrateDefMap {\n         //  - current module / scope\n         //  - extern prelude\n         //  - std prelude\n-        let from_scope = self[module]\n-            .scope\n-            .get_item_or_macro(name)\n-            .unwrap_or_else(|| Either::Left(PerNs::none()));\n+        let from_scope =\n+            self[module].scope.get_item_or_macro(name).unwrap_or_else(|| Either::A(PerNs::none()));\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name);\n \n-        or(from_scope, or(Either::Left(from_extern_prelude), from_prelude))\n+        or(from_scope, or(Either::A(from_extern_prelude), from_prelude))\n     }\n \n     fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n@@ -505,9 +503,9 @@ impl CrateDefMap {\n             } else {\n                 db.crate_def_map(prelude.krate)[prelude.module_id].scope.get_item_or_macro(name)\n             };\n-            resolution.unwrap_or_else(|| Either::Left(PerNs::none()))\n+            resolution.unwrap_or_else(|| Either::A(PerNs::none()))\n         } else {\n-            Either::Left(PerNs::none())\n+            Either::A(PerNs::none())\n         }\n     }\n }"}, {"sha": "b74dc33b17d43a6bdd56e317b3d0a4912f37f681", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=1c867b4e67126350579d6d598efeb6c03b503ddc", "patch": "@@ -1,6 +1,5 @@\n use arrayvec::ArrayVec;\n use rustc_hash::FxHashMap;\n-use either::Either;\n use relative_path::RelativePathBuf;\n use test_utils::tested_by;\n use ra_db::FileId;\n@@ -9,15 +8,15 @@ use ra_syntax::ast;\n use crate::{\n     Function, Module, Struct, Union, Enum, Const, Static, Trait, TypeAlias, MacroDef,\n     DefDatabase, HirFileId, Name, Path, AstDatabase,\n-    KnownName,\n+    KnownName, AstId,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n         CrateDefMap, CrateModuleId, ModuleData, ItemOrMacro,\n         diagnostics::DefDiagnostic,\n         raw,\n     },\n     ids::{AstItemDef, LocationCtx, MacroCallLoc, MacroCallId, MacroDefId, MacroFileKind},\n-    AstId,\n+    either::Either,\n };\n \n pub(super) fn collect_defs(\n@@ -129,12 +128,7 @@ where\n         let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n         // show unresolved imports in completion, etc\n         for (module_id, import, import_data) in unresolved_imports {\n-            self.record_resolved_import(\n-                module_id,\n-                Either::Left(PerNs::none()),\n-                import,\n-                &import_data,\n-            )\n+            self.record_resolved_import(module_id, Either::A(PerNs::none()), import, &import_data)\n         }\n     }\n \n@@ -159,7 +153,7 @@ where\n         // What we should do is that, in CrateDefMap, we should maintain a\n         // separate tower of macro scopes, with ids. Then, for each item in the\n         // module, we need to store it's macro scope.\n-        let def = Either::Right(MacroDef { id: macro_id });\n+        let def = Either::B(MacroDef { id: macro_id });\n \n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n@@ -203,7 +197,7 @@ where\n                     .as_ident()\n                     .expect(\"extern crate should have been desugared to one-element path\"),\n             );\n-            (Either::Left(res), ReachedFixedPoint::Yes)\n+            (Either::A(res), ReachedFixedPoint::Yes)\n         } else {\n             let res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n@@ -225,7 +219,7 @@ where\n     ) {\n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n-            match def.left().and_then(|item| item.take_types()) {\n+            match def.a().and_then(|item| item.take_types()) {\n                 Some(ModuleDef::Module(m)) => {\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n@@ -238,11 +232,11 @@ where\n                         let items = scope\n                             .items\n                             .iter()\n-                            .map(|(name, res)| (name.clone(), Either::Left(res.clone())));\n+                            .map(|(name, res)| (name.clone(), Either::A(res.clone())));\n                         let macros = scope\n                             .macros\n                             .iter()\n-                            .map(|(name, res)| (name.clone(), Either::Right(res.clone())));\n+                            .map(|(name, res)| (name.clone(), Either::B(res.clone())));\n \n                         let all = items.chain(macros).collect::<Vec<_>>();\n                         self.update(module_id, Some(import_id), &all);\n@@ -254,11 +248,11 @@ where\n                         let items = scope\n                             .items\n                             .iter()\n-                            .map(|(name, res)| (name.clone(), Either::Left(res.clone())));\n+                            .map(|(name, res)| (name.clone(), Either::A(res.clone())));\n                         let macros = scope\n                             .macros\n                             .iter()\n-                            .map(|(name, res)| (name.clone(), Either::Right(res.clone())));\n+                            .map(|(name, res)| (name.clone(), Either::B(res.clone())));\n \n                         let all = items.chain(macros).collect::<Vec<_>>();\n \n@@ -282,7 +276,7 @@ where\n                                 import: Some(import_id),\n                             };\n                             let name = variant.name(self.db)?;\n-                            Some((name, Either::Left(res)))\n+                            Some((name, Either::A(res)))\n                         })\n                         .collect::<Vec<_>>();\n                     self.update(module_id, Some(import_id), &resolutions);\n@@ -302,16 +296,16 @@ where\n \n                     // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                     if import.is_extern_crate && module_id == self.def_map.root {\n-                        if let Some(def) = def.left().and_then(|item| item.take_types()) {\n+                        if let Some(def) = def.a().and_then(|item| item.take_types()) {\n                             self.def_map.extern_prelude.insert(name.clone(), def);\n                         }\n                     }\n \n                     let resolution = match def {\n-                        Either::Left(item) => {\n-                            Either::Left(Resolution { def: item, import: Some(import_id) })\n+                        Either::A(item) => {\n+                            Either::A(Resolution { def: item, import: Some(import_id) })\n                         }\n-                        Either::Right(macro_) => Either::Right(macro_),\n+                        Either::B(macro_) => Either::B(macro_),\n                     };\n \n                     self.update(module_id, Some(import_id), &[(name, resolution)]);\n@@ -346,7 +340,7 @@ where\n         for (name, res) in resolutions {\n             match res {\n                 // item\n-                Either::Left(res) => {\n+                Either::A(res) => {\n                     let existing = module_items.items.entry(name.clone()).or_default();\n \n                     if existing.def.types.is_none() && res.def.types.is_some() {\n@@ -369,7 +363,7 @@ where\n                     }\n                 }\n                 // macro\n-                Either::Right(res) => {\n+                Either::B(res) => {\n                     // Always shadowing\n                     module_items.macros.insert(name.clone(), *res);\n                 }\n@@ -404,7 +398,7 @@ where\n                 path,\n             );\n \n-            if let Some(def) = resolved_res.resolved_def.right() {\n+            if let Some(def) = resolved_res.resolved_def.b() {\n                 let call_id = MacroCallLoc { def: def.id, ast_id: *ast_id }.id(self.db);\n                 resolved.push((*module_id, call_id, def.id));\n                 res = ReachedFixedPoint::No;\n@@ -570,7 +564,7 @@ where\n             ),\n             import: None,\n         };\n-        self.def_collector.update(self.module_id, None, &[(name, Either::Left(resolution))]);\n+        self.def_collector.update(self.module_id, None, &[(name, Either::A(resolution))]);\n         res\n     }\n \n@@ -601,7 +595,7 @@ where\n             raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n         };\n         let resolution = Resolution { def, import: None };\n-        self.def_collector.update(self.module_id, None, &[(name, Either::Left(resolution))])\n+        self.def_collector.update(self.module_id, None, &[(name, Either::A(resolution))])\n     }\n \n     fn collect_macro(&mut self, mac: &raw::MacroData) {"}, {"sha": "adac814d913e2183e7cca42cc1bd00a2535a927d", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=1c867b4e67126350579d6d598efeb6c03b503ddc", "patch": "@@ -8,10 +8,9 @@ use std::sync::Arc;\n use ra_db::SourceDatabase;\n use test_utils::covers;\n use insta::assert_snapshot_matches;\n-use either::Either;\n \n use crate::{\n-    Crate,\n+    Crate, Either,\n     mock::{MockDatabase, CrateGraphFixture},\n     nameres::Resolution,\n };\n@@ -37,19 +36,17 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n         *buf += path;\n         *buf += \"\\n\";\n \n-        let items =\n-            map.modules[module].scope.items.iter().map(|(name, it)| (name, Either::Left(it)));\n-        let macros =\n-            map.modules[module].scope.macros.iter().map(|(name, m)| (name, Either::Right(m)));\n+        let items = map.modules[module].scope.items.iter().map(|(name, it)| (name, Either::A(it)));\n+        let macros = map.modules[module].scope.macros.iter().map(|(name, m)| (name, Either::B(m)));\n         let mut entries = items.chain(macros).collect::<Vec<_>>();\n \n         entries.sort_by_key(|(name, _)| *name);\n         for (name, res) in entries {\n             match res {\n-                Either::Left(it) => {\n+                Either::A(it) => {\n                     *buf += &format!(\"{}: {}\\n\", name, dump_resolution(it));\n                 }\n-                Either::Right(_) => {\n+                Either::B(_) => {\n                     *buf += &format!(\"{}: m\\n\", name);\n                 }\n             }"}, {"sha": "7f8b3812c353610364cd3f77e928b0df32f63979", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c867b4e67126350579d6d598efeb6c03b503ddc/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=1c867b4e67126350579d6d598efeb6c03b503ddc", "patch": "@@ -2,7 +2,6 @@\n use std::sync::Arc;\n \n use rustc_hash::{FxHashMap, FxHashSet};\n-use either::Either;\n \n use crate::{\n     ModuleDef, Trait, MacroDef,\n@@ -14,6 +13,7 @@ use crate::{\n     expr::{scope::{ExprScopes, ScopeId}, PatId},\n     impl_block::ImplBlock,\n     path::Path,\n+    either::Either,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -137,7 +137,7 @@ impl Resolver {\n     ) -> Option<MacroDef> {\n         let (item_map, module) = self.module()?;\n         match item_map.resolve_path_with_macro(db, module, path) {\n-            (Either::Right(macro_def), None) => Some(macro_def),\n+            (Either::B(macro_def), None) => Some(macro_def),\n             _ => None,\n         }\n     }"}]}