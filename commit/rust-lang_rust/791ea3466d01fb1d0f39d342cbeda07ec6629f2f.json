{"sha": "791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MWVhMzQ2NmQwMWZiMWQwZjM5ZDM0MmNiZWRhMDdlYzY2MjlmMmY=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-19T22:36:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:23Z"}, "message": "std::uv : cleanup and an isolated test for hand-rolled high_level_loops", "tree": {"sha": "f410c7021a29ce86f05be160d933f608aa5e2acf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f410c7021a29ce86f05be160d933f608aa5e2acf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "html_url": "https://github.com/rust-lang/rust/commit/791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/791ea3466d01fb1d0f39d342cbeda07ec6629f2f/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02057c5a58bd5498c59bbe769bfd327721f4c8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02057c5a58bd5498c59bbe769bfd327721f4c8d", "html_url": "https://github.com/rust-lang/rust/commit/e02057c5a58bd5498c59bbe769bfd327721f4c8d"}], "stats": {"total": 233, "additions": 204, "deletions": 29}, "files": [{"sha": "fbb4ee0a1557b0702fa2c6a798b18b4381d1333b", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/791ea3466d01fb1d0f39d342cbeda07ec6629f2f/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ea3466d01fb1d0f39d342cbeda07ec6629f2f/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "patch": "@@ -21,8 +21,9 @@ native mod rustrt {\n Race-free helper to get access to a global task where a libuv\n loop is running.\n \n-Use `uv::hl::interact`, `uv::hl::ref_handle` and `uv::hl::unref_handle` to\n-do operations against the global loop that this function returns.\n+Use `uv::hl::interact`, `uv::hl::ref`, `uv::hl::unref` and\n+uv `uv::hl::unref_and_close` to do operations against the global\n+loop that this function returns.\n \n # Return\n \n@@ -33,6 +34,7 @@ fn get() -> hl::high_level_loop {\n     ret get_monitor_task_gl();\n }\n \n+// WARNING: USE ONLY ONE get_*_task_gl fn in the scope of a process lifetime.\n #[doc(hidden)]\n fn get_monitor_task_gl() -> hl::high_level_loop {\n     let monitor_loop_chan =\n@@ -51,6 +53,7 @@ fn get_monitor_task_gl() -> hl::high_level_loop {\n         });\n }\n \n+// WARNING: USE ONLY ONE get_*_task_gl fn in the scope of a process lifetime.\n #[doc(hidden)]\n fn get_single_task_gl() -> hl::high_level_loop {\n     let global_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n@@ -323,7 +326,7 @@ mod test {\n         hl::interact(hl_loop) {|loop_ptr|\n             log(debug, \"closing timer\");\n             //ll::close(timer_ptr as *libc::c_void, simple_timer_close_cb);\n-            hl::unref_handle(hl_loop, timer_ptr, simple_timer_close_cb);\n+            hl::unref_and_close(hl_loop, timer_ptr, simple_timer_close_cb);\n             log(debug, \"about to deref exit_ch_ptr\");\n             log(debug, \"after msg sent on deref'd exit_ch\");\n         };\n@@ -342,7 +345,7 @@ mod test {\n             log(debug, \"user code inside interact loop!!!\");\n             let init_status = ll::timer_init(loop_ptr, timer_ptr);\n             if(init_status == 0i32) {\n-                hl::ref_handle(hl_loop, timer_ptr);\n+                hl::ref(hl_loop, timer_ptr);\n                 ll::set_data_for_uv_handle(\n                     timer_ptr as *libc::c_void,\n                     exit_ch_ptr as *libc::c_void);"}, {"sha": "8787b650b25159d06564ee23340d0f30dd279492", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 195, "deletions": 23, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/791ea3466d01fb1d0f39d342cbeda07ec6629f2f/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ea3466d01fb1d0f39d342cbeda07ec6629f2f/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "patch": "@@ -7,7 +7,7 @@ libuv functionality.\n \"];\n \n export high_level_loop, hl_loop_ext, high_level_msg;\n-export run_high_level_loop, interact, ref_handle, unref_handle;\n+export run_high_level_loop, interact, ref, unref, unref_and_close;\n \n import ll = uv_ll;\n \n@@ -23,6 +23,10 @@ the C uv loop to process any pending callbacks\n by the C uv loop\n \"]\n enum high_level_loop {\n+    simple_task_loop({\n+        async_handle: *ll::uv_async_t,\n+        op_chan: comm::chan<high_level_msg>\n+    }),\n     single_task_loop({\n         async_handle: **ll::uv_async_t,\n         op_chan: comm::chan<high_level_msg>\n@@ -52,6 +56,9 @@ impl hl_loop_ext for high_level_loop {\n           monitor_task_loop({op_chan}) {\n             ret op_chan;\n           }\n+          simple_task_loop({async_handle, op_chan}) {\n+            ret op_chan;\n+          }\n         }\n     }\n }\n@@ -61,8 +68,8 @@ Represents the range of interactions with a `high_level_loop`\n \"]\n enum high_level_msg {\n     interaction (fn~(*libc::c_void)),\n-    auto_ref_handle (*libc::c_void),\n-    auto_unref_handle (*libc::c_void, *u8),\n+    ref_handle (*libc::c_void),\n+    manual_unref_handle (*libc::c_void, option<*u8>),\n     tear_down\n }\n \n@@ -96,7 +103,7 @@ unsafe fn run_high_level_loop(loop_ptr: *libc::c_void,\n     ll::async_init(loop_ptr, async_handle, high_level_wake_up_cb);\n \n     // initialize our loop data and store it in the loop\n-    let data: global_loop_data = default_gl_data({\n+    let data: hl_loop_data = default_gl_data({\n         async_handle: async_handle,\n         mut active: true,\n         before_msg_drain: before_msg_drain,\n@@ -159,22 +166,25 @@ resource safe_handle_container<T>(handle_fields: safe_handle_fields<T>) {\n #[doc=\"\n Needs to be encapsulated within `safe_handle`\n \"]\n-fn ref_handle<T>(hl_loop: high_level_loop, handle: *T) unsafe {\n-    send_high_level_msg(hl_loop, auto_ref_handle(handle as *libc::c_void));\n+fn ref<T>(hl_loop: high_level_loop, handle: *T) unsafe {\n+    send_high_level_msg(hl_loop, ref_handle(handle as *libc::c_void));\n }\n #[doc=\"\n Needs to be encapsulated within `safe_handle`\n \"]\n-fn unref_handle<T>(hl_loop: high_level_loop, handle: *T,\n-                   user_close_cb: *u8) unsafe {\n-    send_high_level_msg(hl_loop, auto_unref_handle(handle as *libc::c_void,\n-                                                   user_close_cb));\n+fn unref<T>(hl_loop: high_level_loop, handle: *T) unsafe {\n+    send_high_level_msg(hl_loop, manual_unref_handle(handle as *libc::c_void,\n+                                                   none));\n+}\n+fn unref_and_close<T>(hl_loop: high_level_loop, handle: *T, cb: *u8) unsafe {\n+    send_high_level_msg(hl_loop, manual_unref_handle(handle as *libc::c_void,\n+                                                   some(cb)));\n }\n \n // INTERNAL API\n \n // data that lives for the lifetime of the high-evel oo\n-enum global_loop_data {\n+enum hl_loop_data {\n     default_gl_data({\n         async_handle: *ll::uv_async_t,\n         mut active: bool,\n@@ -203,6 +213,10 @@ unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n             log(debug,\"GLOBAL ASYNC handle == 0\");\n         }\n       }\n+      simple_task_loop({async_handle, op_chan}) {\n+        log(debug,\"simple async handle != 0, waking up loop..\");\n+        ll::async_send((async_handle));\n+      }\n       _ {}\n     }\n }\n@@ -218,7 +232,7 @@ crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n     log(debug, #fmt(\"high_level_wake_up_cb crust.. handle: %? status: %?\",\n                      async_handle, status));\n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n-    let data = ll::get_data_for_uv_handle(async_handle) as *global_loop_data;\n+    let data = ll::get_data_for_uv_handle(async_handle) as *hl_loop_data;\n     // we check to see if the loop is \"active\" (the loop is set to\n     // active = false the first time we realize we need to 'tear down',\n     // set subsequent calls to the global async handle may be triggered\n@@ -245,11 +259,11 @@ crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n                         cb(loop_ptr);\n                         log(debug,\"after calling cb\");\n                       }\n-                      auto_ref_handle(handle) {\n+                      ref_handle(handle) {\n                         high_level_ref(data, handle);\n                       }\n-                      auto_unref_handle(handle, user_close_cb) {\n-                        high_level_unref(data, handle, false, user_close_cb);\n+                      manual_unref_handle(handle, user_close_cb) {\n+                        high_level_unref(data, handle, true, user_close_cb);\n                       }\n                       tear_down {\n                         log(debug,\"incoming hl_msg: got tear_down\");\n@@ -258,6 +272,9 @@ crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n                     continue = comm::peek(msg_po);\n                 }\n             }\n+            else {\n+                log(debug, \"in hl wake_cb, no pending messages\");\n+            }\n         }\n         log(debug, #fmt(\"after on_wake, continue? %?\", continue));\n         if !do_msg_drain {\n@@ -269,50 +286,80 @@ crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n crust fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n     log(debug, #fmt(\"tear_down_close_cb called, closing handle at %?\",\n                     handle));\n-    let data = ll::get_data_for_uv_handle(handle) as *global_loop_data;\n-    if vec::len((*data).refd_handles) > 0 {\n+    let data = ll::get_data_for_uv_handle(handle) as *hl_loop_data;\n+    if vec::len((*data).refd_handles) > 0u {\n         fail \"Didn't unref all high-level handles\";\n     }\n }\n \n-fn high_level_tear_down(data: *global_loop_data) unsafe {\n+fn high_level_tear_down(data: *hl_loop_data) unsafe {\n     log(debug, \"high_level_tear_down() called, close async_handle\");\n     // call user-suppled before_tear_down cb\n     let async_handle = (*data).async_handle;\n     (*data).before_tear_down(async_handle);\n     ll::close(async_handle as *libc::c_void, tear_down_close_cb);\n }\n \n-unsafe fn high_level_ref(data: *global_loop_data, handle: *libc::c_void) {\n-    log(debug,\"incoming hl_msg: got auto_ref_handle\");\n+unsafe fn high_level_ref(data: *hl_loop_data, handle: *libc::c_void) {\n+    log(debug,\"incoming hl_msg: got ..ref_handle\");\n     let mut refd_handles = (*data).refd_handles;\n+    let mut unrefd_handles = (*data).unrefd_handles;\n     let handle_already_refd = refd_handles.contains(handle);\n     if handle_already_refd {\n         fail \"attempt to do a high-level ref an already ref'd handle\";\n     }\n+    let handle_already_unrefd = unrefd_handles.contains(handle);\n+    // if we are ref'ing a handle (by ptr) that was already unref'd,\n+    // probably\n+    if handle_already_unrefd {\n+        let last_idx = vec::len(unrefd_handles) - 1u;\n+        let handle_idx = vec::position_elem(unrefd_handles, handle);\n+        alt handle_idx {\n+          none {\n+            fail \"trying to remove handle that isn't in unrefd_handles\";\n+          }\n+          some(idx) {\n+            unrefd_handles[idx] <-> unrefd_handles[last_idx];\n+            vec::pop(unrefd_handles);\n+          }\n+        }\n+        (*data).unrefd_handles = unrefd_handles;\n+    }\n     refd_handles += [handle];\n     (*data).refd_handles = refd_handles;\n }\n \n-unsafe fn high_level_unref(data: *global_loop_data, handle: *libc::c_void,\n-                   manual_unref: bool, user_close_cb: *u8) {\n+unsafe fn high_level_unref(data: *hl_loop_data, handle: *libc::c_void,\n+                   manual_unref: bool, user_close_cb: option<*u8>) {\n     log(debug,\"incoming hl_msg: got auto_unref_handle\");\n     let mut refd_handles = (*data).refd_handles;\n     let mut unrefd_handles = (*data).unrefd_handles;\n+    log(debug, #fmt(\"refs: %?, unrefs %? handle %?\", vec::len(refd_handles),\n+                    vec::len(unrefd_handles), handle));\n     let handle_already_refd = refd_handles.contains(handle);\n     if !handle_already_refd {\n         fail \"attempting to high-level unref an untracked handle\";\n     }\n     let double_unref = unrefd_handles.contains(handle);\n     if double_unref {\n+        log(debug, \"double unref encountered\");\n         if manual_unref {\n             // will allow a user to manual unref, but only signal\n             // a fail when a double-unref is caused by a user\n             fail \"attempting to high-level unref an unrefd handle\";\n         }\n+        else {\n+            log(debug, \"not failing...\");\n+        }\n     }\n     else {\n-        ll::close(handle, user_close_cb);\n+        log(debug, \"attempting to unref handle\");\n+        alt user_close_cb {\n+          some(cb) {\n+            ll::close(handle, cb);\n+          }\n+          none { }\n+        }\n         let last_idx = vec::len(refd_handles) - 1u;\n         let handle_idx = vec::position_elem(refd_handles, handle);\n         alt handle_idx {\n@@ -337,3 +384,128 @@ unsafe fn high_level_unref(data: *global_loop_data, handle: *libc::c_void,\n     }\n \n }\n+#[cfg(test)]\n+mod test {\n+    crust fn async_close_cb(handle: *ll::uv_async_t) unsafe {\n+        log(debug, #fmt(\"async_close_cb handle %?\", handle));\n+        let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n+                        as *ah_data)).exit_ch;\n+        comm::send(exit_ch, ());\n+    }\n+    crust fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int)\n+        unsafe {\n+        log(debug, #fmt(\"async_handle_cb handle %? status %?\",handle,status));\n+        let hl_loop = (*(ll::get_data_for_uv_handle(handle)\n+                        as *ah_data)).hl_loop;\n+        unref_and_close(hl_loop, handle, async_close_cb);\n+    }\n+    type ah_data = {\n+        hl_loop: high_level_loop,\n+        exit_ch: comm::chan<()>\n+    };\n+    fn impl_uv_hl_async(hl_loop: high_level_loop) unsafe {\n+        let async_handle = ll::async_t();\n+        let ah_ptr = ptr::addr_of(async_handle);\n+        let exit_po = comm::port::<()>();\n+        let exit_ch = comm::chan(exit_po);\n+        let ah_data = {\n+            hl_loop: hl_loop,\n+            exit_ch: exit_ch\n+        };\n+        let ah_data_ptr = ptr::addr_of(ah_data);\n+        interact(hl_loop) {|loop_ptr|\n+            ref(hl_loop, ah_ptr);\n+            ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n+            ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n+            ll::async_send(ah_ptr);\n+        };\n+        comm::recv(exit_po);\n+    }\n+\n+    // this fn documents the bear minimum neccesary to roll your own\n+    // high_level_loop\n+    unsafe fn spawn_test_loop(exit_ch: comm::chan<()>) -> high_level_loop {\n+        let hl_loop_port = comm::port::<high_level_loop>();\n+        let hl_loop_ch = comm::chan(hl_loop_port);\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            let loop_ptr = ll::loop_new();\n+            let msg_po = comm::port::<high_level_msg>();\n+            let msg_ch = comm::chan(msg_po);\n+            run_high_level_loop(\n+                loop_ptr,\n+                msg_po,\n+                // before_run\n+                {|async_handle|\n+                    log(debug,#fmt(\"hltest before_run: async_handle %?\",\n+                                  async_handle));\n+                    // do an async_send with it\n+                    ll::async_send(async_handle);\n+                    comm::send(hl_loop_ch, simple_task_loop({\n+                       async_handle: async_handle,\n+                       op_chan: msg_ch\n+                    }));\n+                },\n+                // before_msg_drain\n+                {|async_handle|\n+                    log(debug,#fmt(\"hltest before_msg_drain: async_handle %?\",\n+                                  async_handle));\n+                    true\n+                },\n+                // before_tear_down\n+                {|async_handle|\n+                    log(debug,#fmt(\"hl test_loop b4_tear_down: async %?\",\n+                                  async_handle));\n+            });\n+            ll::loop_delete(loop_ptr);\n+            comm::send(exit_ch, ());\n+        };\n+        ret comm::recv(hl_loop_port);\n+    }\n+\n+    crust fn lifetime_handle_close(handle: *libc::c_void) unsafe {\n+        log(debug, #fmt(\"lifetime_handle_close ptr %?\", handle));\n+    }\n+\n+    crust fn lifetime_async_callback(handle: *libc::c_void,\n+                                     status: libc::c_int) {\n+        log(debug, #fmt(\"lifetime_handle_close ptr %? status %?\",\n+                        handle, status));\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_hl_async() unsafe {\n+        let exit_po = comm::port::<()>();\n+        let exit_ch = comm::chan(exit_po);\n+        let hl_loop = spawn_test_loop(exit_ch);\n+\n+        // using this handle to manage the lifetime of the high_level_loop,\n+        // as it will exit the first time one of the impl_uv_hl_async() is\n+        // cleaned up with no one ref'd handles on the loop (Which can happen\n+        // under race-condition type situations.. this ensures that the loop\n+        // lives until, at least, all of the impl_uv_hl_async() runs have been\n+        // called, at least.\n+        let lifetime_handle = ll::async_t();\n+        let lifetime_handle_ptr = ptr::addr_of(lifetime_handle);\n+        interact(hl_loop) {|loop_ptr|\n+            ref(hl_loop, lifetime_handle_ptr);\n+            ll::async_init(loop_ptr, lifetime_handle_ptr,\n+                          lifetime_async_callback);\n+        };\n+\n+        iter::repeat(7u) {||\n+            task::spawn_sched(task::manual_threads(1u), {||\n+                impl_uv_hl_async(hl_loop);\n+            });\n+        };\n+        impl_uv_hl_async(hl_loop);\n+        impl_uv_hl_async(hl_loop);\n+        impl_uv_hl_async(hl_loop);\n+        interact(hl_loop) {|loop_ptr|\n+            ll::close(lifetime_handle_ptr, lifetime_handle_close);\n+            unref(hl_loop, lifetime_handle_ptr);\n+            log(debug, \"close and unref lifetime handle\");\n+        };\n+        comm::recv(exit_po);\n+    }\n+}"}, {"sha": "0f52664a8155cd278009cb3e6d758371164f6c1a", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ea3466d01fb1d0f39d342cbeda07ec6629f2f/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ea3466d01fb1d0f39d342cbeda07ec6629f2f/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=791ea3466d01fb1d0f39d342cbeda07ec6629f2f", "patch": "@@ -595,8 +595,8 @@ unsafe fn run(loop_handle: *libc::c_void) {\n     rustrt::rust_uv_run(loop_handle);\n }\n \n-unsafe fn close(handle: *libc::c_void, cb: *u8) {\n-    rustrt::rust_uv_close(handle, cb);\n+unsafe fn close<T>(handle: *T, cb: *u8) {\n+    rustrt::rust_uv_close(handle as *libc::c_void, cb);\n }\n \n unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)"}]}