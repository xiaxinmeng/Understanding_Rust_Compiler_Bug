{"sha": "55d7f736d8c62cc0a03594302538001ef3f3411d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZDdmNzM2ZDhjNjJjYzBhMDM1OTQzMDI1MzgwMDFlZjNmMzQxMWQ=", "commit": {"author": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2020-11-14T03:15:51Z"}, "committer": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2020-11-14T03:15:51Z"}, "message": "Tighten the bounds on atomic Ordering in std::sys::unix::weak", "tree": {"sha": "0364777ac248989e0c69166ecae317298acbe668", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0364777ac248989e0c69166ecae317298acbe668"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55d7f736d8c62cc0a03594302538001ef3f3411d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55d7f736d8c62cc0a03594302538001ef3f3411d", "html_url": "https://github.com/rust-lang/rust/commit/55d7f736d8c62cc0a03594302538001ef3f3411d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55d7f736d8c62cc0a03594302538001ef3f3411d/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89bce3e9080a995c59149cc36962048cd9f56f63", "url": "https://api.github.com/repos/rust-lang/rust/commits/89bce3e9080a995c59149cc36962048cd9f56f63", "html_url": "https://github.com/rust-lang/rust/commit/89bce3e9080a995c59149cc36962048cd9f56f63"}], "stats": {"total": 46, "additions": 40, "deletions": 6}, "files": [{"sha": "cc3f8dbbce7500e5b0c50c78f26b070b1e3d0b92", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/55d7f736d8c62cc0a03594302538001ef3f3411d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d7f736d8c62cc0a03594302538001ef3f3411d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=55d7f736d8c62cc0a03594302538001ef3f3411d", "patch": "@@ -24,7 +24,7 @@\n use crate::ffi::CStr;\n use crate::marker;\n use crate::mem;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::atomic::{self, AtomicUsize, Ordering};\n \n macro_rules! weak {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n@@ -47,15 +47,49 @@ impl<F> Weak<F> {\n     pub fn get(&self) -> Option<F> {\n         assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n         unsafe {\n-            if self.addr.load(Ordering::SeqCst) == 1 {\n-                self.addr.store(fetch(self.name), Ordering::SeqCst);\n-            }\n-            match self.addr.load(Ordering::SeqCst) {\n+            // Relaxed is fine here because we fence before reading through the\n+            // pointer (see the comment below).\n+            match self.addr.load(Ordering::Relaxed) {\n+                1 => self.initialize(),\n                 0 => None,\n-                addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n+                addr => {\n+                    let func = mem::transmute_copy::<usize, F>(&addr);\n+                    // The caller is presumably going to read through this value\n+                    // (by calling the function we've dlsymed). This means we'd\n+                    // need to have loaded it with at least C11's consume\n+                    // ordering in order to be guaranteed that the data we read\n+                    // from the pointer isn't from before the pointer was\n+                    // stored. Rust has no equivalent to memory_order_consume,\n+                    // so we use an acquire fence (sorry, ARM).\n+                    //\n+                    // Now, in practice this likely isn't needed even on CPUs\n+                    // where relaxed and consume mean different things. The\n+                    // symbols we're loading are probably present (or not) at\n+                    // init, and even if they aren't the runtime dynamic loader\n+                    // is extremely likely have sufficient barriers internally\n+                    // (possibly implicitly, for example the ones provided by\n+                    // invoking `mprotect`).\n+                    //\n+                    // That said, none of that's *guaranteed*, and so we fence.\n+                    atomic::fence(Ordering::Acquire);\n+                    Some(func)\n+                }\n             }\n         }\n     }\n+\n+    // Cold because it should only happen during first-time initalization.\n+    #[cold]\n+    unsafe fn initialize(&self) -> Option<F> {\n+        let val = fetch(self.name);\n+        // This synchronizes with the acquire fence in `get`.\n+        self.addr.store(val, Ordering::Release);\n+\n+        match val {\n+            0 => None,\n+            addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n+        }\n+    }\n }\n \n unsafe fn fetch(name: &str) -> usize {"}]}