{"sha": "486f60df8797aa96e0a459227089945d06b88303", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NmY2MGRmODc5N2FhOTZlMGE0NTkyMjcwODk5NDVkMDZiODgzMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T06:50:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T06:50:21Z"}, "message": "auto merge of #20917 : nick29581/rust/plugins, r=huonw", "tree": {"sha": "e409cd1d9c43641e2f31c99c7a41881bc0d5253b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e409cd1d9c43641e2f31c99c7a41881bc0d5253b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/486f60df8797aa96e0a459227089945d06b88303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/486f60df8797aa96e0a459227089945d06b88303", "html_url": "https://github.com/rust-lang/rust/commit/486f60df8797aa96e0a459227089945d06b88303", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/486f60df8797aa96e0a459227089945d06b88303/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aec4db1c09574da2f30e3844de6d252d79d4939", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aec4db1c09574da2f30e3844de6d252d79d4939", "html_url": "https://github.com/rust-lang/rust/commit/0aec4db1c09574da2f30e3844de6d252d79d4939"}, {"sha": "55d5c46d3a87caa1e38f1a3f1489001e35727998", "url": "https://api.github.com/repos/rust-lang/rust/commits/55d5c46d3a87caa1e38f1a3f1489001e35727998", "html_url": "https://github.com/rust-lang/rust/commit/55d5c46d3a87caa1e38f1a3f1489001e35727998"}], "stats": {"total": 349, "additions": 268, "deletions": 81}, "files": [{"sha": "f35f8ab1b40f5cb741392bf2cb3b0390b0e1f0aa", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 194, "deletions": 68, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=486f60df8797aa96e0a459227089945d06b88303", "patch": "@@ -24,7 +24,6 @@ use rustc_borrowck as borrowck;\n use rustc_resolve as resolve;\n use rustc_trans::back::link;\n use rustc_trans::back::write;\n-use rustc_trans::save;\n use rustc_trans::trans;\n use rustc_typeck as typeck;\n \n@@ -47,23 +46,43 @@ pub fn compile_input(sess: Session,\n                      input: &Input,\n                      outdir: &Option<Path>,\n                      output: &Option<Path>,\n-                     addl_plugins: Option<Vec<String>>) {\n+                     addl_plugins: Option<Vec<String>>,\n+                     control: CompileController) {\n+    macro_rules! controller_entry_point{($point: ident, $make_state: expr) => ({\n+        {\n+            let state = $make_state;\n+            (control.$point.callback)(state);\n+        }\n+        if control.$point.stop {\n+            return;\n+        }\n+    })}\n+\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans, sess) = {\n         let (outputs, expanded_crate, id) = {\n             let krate = phase_1_parse_input(&sess, cfg, input);\n-            if stop_after_phase_1(&sess) { return; }\n+\n+            controller_entry_point!(after_parse,\n+                                    CompileState::state_after_parse(input,\n+                                                                    &sess,\n+                                                                    outdir,\n+                                                                    &krate));\n+\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n                                                  &krate.attrs[],\n                                                  &sess);\n-            let id = link::find_crate_name(Some(&sess), &krate.attrs[],\n+            let id = link::find_crate_name(Some(&sess),\n+                                           &krate.attrs[],\n                                            input);\n             let expanded_crate\n-                = match phase_2_configure_and_expand(&sess, krate, &id[],\n+                = match phase_2_configure_and_expand(&sess,\n+                                                     krate,\n+                                                     &id[],\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -72,23 +91,37 @@ pub fn compile_input(sess: Session,\n             (outputs, expanded_crate, id)\n         };\n \n+        controller_entry_point!(after_expand,\n+                                CompileState::state_after_expand(input,\n+                                                                 &sess,\n+                                                                 outdir,\n+                                                                 &expanded_crate,\n+                                                                 &id[]));\n+\n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n         write_out_deps(&sess, input, &outputs, &id[]);\n \n-        if stop_after_phase_2(&sess) { return; }\n-\n         let arenas = ty::CtxtArenas::new();\n-        let analysis = phase_3_run_analysis_passes(sess, ast_map, &arenas, id);\n-        phase_save_analysis(&analysis.ty_cx.sess, analysis.ty_cx.map.krate(), &analysis, outdir);\n+        let analysis = phase_3_run_analysis_passes(sess,\n+                                                   ast_map,\n+                                                   &arenas,\n+                                                   id,\n+                                                   control.make_glob_map);\n+\n+        controller_entry_point!(after_analysis,\n+                                CompileState::state_after_analysis(input,\n+                                                                   &analysis.ty_cx.sess,\n+                                                                   outdir,\n+                                                                   analysis.ty_cx.map.krate(),\n+                                                                   &analysis,\n+                                                                   &analysis.ty_cx));\n \n         if log_enabled!(::log::INFO) {\n             println!(\"Pre-trans\");\n             analysis.ty_cx.print_debug_stats();\n         }\n-\n-        if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n         let (tcx, trans) = phase_4_translate_to_llvm(analysis);\n \n         if log_enabled!(::log::INFO) {\n@@ -102,7 +135,13 @@ pub fn compile_input(sess: Session,\n         (outputs, trans, tcx.sess)\n     };\n     phase_5_run_llvm_passes(&sess, &trans, &outputs);\n-    if stop_after_phase_5(&sess) { return; }\n+\n+    controller_entry_point!(after_llvm,\n+                            CompileState::state_after_llvm(input,\n+                                                           &sess,\n+                                                           outdir,\n+                                                           &trans));\n+\n     phase_6_link_output(&sess, &trans, &outputs);\n }\n \n@@ -120,6 +159,146 @@ pub fn source_name(input: &Input) -> String {\n     }\n }\n \n+/// CompileController is used to customise compilation, it allows compilation to\n+/// be stopped and/or to call arbitrary code at various points in compilation.\n+/// It also allows for various flags to be set to influence what information gets\n+/// colelcted during compilation.\n+///\n+/// This is a somewhat higher level controller than a Session - the Session\n+/// controls what happens in each phase, whereas the CompileController controls\n+/// whether a phase is run at all and whether other code (from outside the\n+/// the compiler) is run between phases.\n+///\n+/// Note that if compilation is set to stop and a callback is provided for a\n+/// given entry point, the callback is called before compilation is stopped.\n+///\n+/// Expect more entry points to be added in the future.\n+pub struct CompileController<'a> {\n+    pub after_parse: PhaseController<'a>,\n+    pub after_expand: PhaseController<'a>,\n+    pub after_analysis: PhaseController<'a>,\n+    pub after_llvm: PhaseController<'a>,\n+\n+    pub make_glob_map: resolve::MakeGlobMap,\n+}\n+\n+impl<'a> CompileController<'a> {\n+    pub fn basic() -> CompileController<'a> {\n+        CompileController {\n+            after_parse: PhaseController::basic(),\n+            after_expand: PhaseController::basic(),\n+            after_analysis: PhaseController::basic(),\n+            after_llvm: PhaseController::basic(),\n+            make_glob_map: resolve::MakeGlobMap::No,\n+        }\n+    }\n+}\n+\n+pub struct PhaseController<'a> {\n+    pub stop: bool,\n+    pub callback: Box<Fn(CompileState) -> () + 'a>,\n+}\n+\n+impl<'a> PhaseController<'a> {\n+    pub fn basic() -> PhaseController<'a> {\n+        PhaseController {\n+            stop: false,\n+            callback: box |&: _| {},\n+        }\n+    }\n+}\n+\n+/// State that is passed to a callback. What state is available depends on when\n+/// during compilation the callback is made. See the various constructor methods\n+/// (`state_*`) in the impl to see which data is provided for any given entry point.\n+pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n+    pub input: &'a Input,\n+    pub session: &'a Session,\n+    pub cfg: Option<&'a ast::CrateConfig>,\n+    pub krate: Option<&'a ast::Crate>,\n+    pub crate_name: Option<&'a str>,\n+    pub output_filenames: Option<&'a OutputFilenames>,\n+    pub out_dir: Option<&'a Path>,\n+    pub expanded_crate: Option<&'a ast::Crate>,\n+    pub ast_map: Option<&'a ast_map::Map<'ast>>,\n+    pub analysis: Option<&'a ty::CrateAnalysis<'tcx>>,\n+    pub tcx: Option<&'a ty::ctxt<'tcx>>,\n+    pub trans: Option<&'a trans::CrateTranslation>,\n+}\n+\n+impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n+    fn empty(input: &'a Input,\n+             session: &'a Session,\n+             out_dir: &'a Option<Path>)\n+             -> CompileState<'a, 'ast, 'tcx> {\n+        CompileState {\n+            input: input,\n+            session: session,\n+            out_dir: out_dir.as_ref(),\n+            cfg: None,\n+            krate: None,\n+            crate_name: None,\n+            output_filenames: None,\n+            expanded_crate: None,\n+            ast_map: None,\n+            analysis: None,\n+            tcx: None,\n+            trans: None,\n+        }\n+    }\n+\n+    fn state_after_parse(input: &'a Input,\n+                         session: &'a Session,\n+                         out_dir: &'a Option<Path>,\n+                         krate: &'a ast::Crate)\n+                         -> CompileState<'a, 'ast, 'tcx> {\n+        CompileState {\n+            krate: Some(krate),\n+            .. CompileState::empty(input, session, out_dir)\n+        }\n+    }\n+\n+    fn state_after_expand(input: &'a Input,\n+                          session: &'a Session,\n+                          out_dir: &'a Option<Path>,\n+                          expanded_crate: &'a ast::Crate,\n+                          crate_name: &'a str)\n+                          -> CompileState<'a, 'ast, 'tcx> {\n+        CompileState {\n+            crate_name: Some(crate_name),\n+            expanded_crate: Some(expanded_crate),\n+            .. CompileState::empty(input, session, out_dir)\n+        }\n+    }\n+\n+    fn state_after_analysis(input: &'a Input,\n+                            session: &'a Session,\n+                            out_dir: &'a Option<Path>,\n+                            krate: &'a ast::Crate,\n+                            analysis: &'a ty::CrateAnalysis<'tcx>,\n+                            tcx: &'a ty::ctxt<'tcx>)\n+                            -> CompileState<'a, 'ast, 'tcx> {\n+        CompileState {\n+            analysis: Some(analysis),\n+            tcx: Some(tcx),\n+            krate: Some(krate),\n+            .. CompileState::empty(input, session, out_dir)\n+        }\n+    }\n+\n+\n+    fn state_after_llvm(input: &'a Input,\n+                        session: &'a Session,\n+                        out_dir: &'a Option<Path>,\n+                        trans: &'a trans::CrateTranslation)\n+                        -> CompileState<'a, 'ast, 'tcx> {\n+        CompileState {\n+            trans: Some(trans),\n+            .. CompileState::empty(input, session, out_dir)\n+        }\n+    }\n+}\n+\n pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     -> ast::Crate {\n     // These may be left in an incoherent state after a previous compile.\n@@ -347,7 +526,9 @@ pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                          ast_map: ast_map::Map<'tcx>,\n                                          arenas: &'tcx ty::CtxtArenas<'tcx>,\n-                                         name: String) -> ty::CrateAnalysis<'tcx> {\n+                                         name: String,\n+                                         make_glob_map: resolve::MakeGlobMap)\n+                                         -> ty::CrateAnalysis<'tcx> {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n \n@@ -357,11 +538,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n                           middle::lang_items::collect_language_items(krate, &sess));\n \n-    let make_glob_map = if save_analysis(&sess) {\n-        resolve::MakeGlobMap::Yes\n-    } else {\n-        resolve::MakeGlobMap::No\n-    };\n     let resolve::CrateMap {\n         def_map,\n         freevars,\n@@ -483,21 +659,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     }\n }\n \n-fn save_analysis(sess: &Session) -> bool {\n-    sess.opts.debugging_opts.save_analysis\n-}\n-\n-pub fn phase_save_analysis(sess: &Session,\n-                           krate: &ast::Crate,\n-                           analysis: &ty::CrateAnalysis,\n-                           odir: &Option<Path>) {\n-    if !save_analysis(sess) {\n-        return;\n-    }\n-    time(sess.time_passes(), \"save analysis\", krate, |krate|\n-         save::process_crate(sess, krate, analysis, odir));\n-}\n-\n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n@@ -559,41 +720,6 @@ pub fn phase_6_link_output(sess: &Session,\n     os::setenv(\"PATH\", old_path);\n }\n \n-pub fn stop_after_phase_3(sess: &Session) -> bool {\n-   if sess.opts.no_trans {\n-        debug!(\"invoked with --no-trans, returning early from compile_input\");\n-        return true;\n-    }\n-    return false;\n-}\n-\n-pub fn stop_after_phase_1(sess: &Session) -> bool {\n-    if sess.opts.parse_only {\n-        debug!(\"invoked with --parse-only, returning early from compile_input\");\n-        return true;\n-    }\n-    if sess.opts.show_span.is_some() {\n-        return true;\n-    }\n-    return sess.opts.debugging_opts.ast_json_noexpand;\n-}\n-\n-pub fn stop_after_phase_2(sess: &Session) -> bool {\n-    if sess.opts.no_analysis {\n-        debug!(\"invoked with --no-analysis, returning early from compile_input\");\n-        return true;\n-    }\n-    return sess.opts.debugging_opts.ast_json;\n-}\n-\n-pub fn stop_after_phase_5(sess: &Session) -> bool {\n-    if !sess.opts.output_types.iter().any(|&i| i == config::OutputTypeExe) {\n-        debug!(\"not building executable, returning early from compile_input\");\n-        return true;\n-    }\n-    return false;\n-}\n-\n fn escape_dep_filename(filename: &str) -> String {\n     // Apparently clang and gcc *only* escape spaces:\n     // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4"}, {"sha": "ce2b03e17448a1398f2b93c34d720b84b2309b40", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=486f60df8797aa96e0a459227089945d06b88303", "patch": "@@ -48,14 +48,19 @@ extern crate \"rustc_llvm\" as llvm;\n \n pub use syntax::diagnostic;\n \n+use driver::CompileController;\n+\n+use rustc_resolve as resolve;\n use rustc_trans::back::link;\n+use rustc_trans::save;\n use rustc::session::{config, Session, build_session};\n use rustc::session::config::{Input, PrintRequest, UnstableFeatures};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc::metadata;\n use rustc::metadata::creader::CrateOrString::Str;\n use rustc::DIAGNOSTICS;\n+use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n use std::io;\n@@ -188,7 +193,43 @@ fn run_compiler(args: &[String]) {\n     }\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n-    driver::compile_input(sess, cfg, &input, &odir, &ofile, Some(plugins));\n+    let control = build_controller(&sess);\n+    driver::compile_input(sess, cfg, &input, &odir, &ofile, Some(plugins), control);\n+}\n+\n+fn build_controller<'a>(sess: &Session) -> CompileController<'a> {\n+    let mut control = CompileController::basic();\n+\n+    if sess.opts.parse_only ||\n+       sess.opts.show_span.is_some() ||\n+       sess.opts.debugging_opts.ast_json_noexpand {\n+        control.after_parse.stop = true;\n+    }\n+\n+    if sess.opts.no_analysis || sess.opts.debugging_opts.ast_json {\n+        control.after_expand.stop = true;\n+    }\n+\n+    if sess.opts.no_trans {\n+        control.after_analysis.stop = true;\n+    }\n+\n+    if !sess.opts.output_types.iter().any(|&i| i == config::OutputTypeExe) {\n+        control.after_llvm.stop = true;\n+    }\n+\n+    if sess.opts.debugging_opts.save_analysis {\n+        control.after_analysis.callback = box |state| {\n+            time(state.session.time_passes(), \"save analysis\", state.krate.unwrap(), |krate|\n+                 save::process_crate(state.session,\n+                                     krate,\n+                                     state.analysis.unwrap(),\n+                                     state.out_dir));\n+        };\n+        control.make_glob_map = resolve::MakeGlobMap::Yes;\n+    }\n+\n+    control\n }\n \n pub fn get_unstable_features_setting() -> UnstableFeatures {"}, {"sha": "6429c5f59856e2394f23cf6ac85a489defb1d003", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=486f60df8797aa96e0a459227089945d06b88303", "patch": "@@ -27,6 +27,7 @@ use rustc::session::config::Input;\n use rustc::util::ppaux;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n+use rustc_resolve as resolve;\n \n use syntax::ast;\n use syntax::ast_map::{self, blocks, NodePrinter};\n@@ -133,7 +134,11 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let analysis = driver::phase_3_run_analysis_passes(sess, ast_map, arenas, id);\n+                let analysis = driver::phase_3_run_analysis_passes(sess,\n+                                                                   ast_map,\n+                                                                   arenas,\n+                                                                   id,\n+                                                                   resolve::MakeGlobMap::No);\n                 let annotation = TypedAnnotation { analysis: analysis };\n                 f(&annotation, payload)\n             }\n@@ -603,7 +608,11 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    let analysis = driver::phase_3_run_analysis_passes(sess, ast_map, &arenas, id);\n+                    let analysis = driver::phase_3_run_analysis_passes(sess,\n+                                                                       ast_map,\n+                                                                       &arenas,\n+                                                                       id,\n+                                                                       resolve::MakeGlobMap::No);\n                     print_flowgraph(variants, analysis, code, out)\n                 }\n                 None => {"}, {"sha": "1bd8e01817485732cf82ad4106c17b97b8c70901", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=486f60df8797aa96e0a459227089945d06b88303", "patch": "@@ -1505,7 +1505,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n pub fn process_crate(sess: &Session,\n                      krate: &ast::Crate,\n                      analysis: &ty::CrateAnalysis,\n-                     odir: &Option<Path>) {\n+                     odir: Option<&Path>) {\n     if generated_code(krate.span) {\n         return;\n     }\n@@ -1524,8 +1524,8 @@ pub fn process_crate(sess: &Session,\n     // find a path to dump our data to\n     let mut root_path = match os::getenv(\"DXR_RUST_TEMP_FOLDER\") {\n         Some(val) => Path::new(val),\n-        None => match *odir {\n-            Some(ref val) => val.join(\"dxr\"),\n+        None => match odir {\n+            Some(val) => val.join(\"dxr\"),\n             None => Path::new(\"dxr-temp\"),\n         },\n     };"}, {"sha": "5bef0195874b64616b8742ddb929847034a50558", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=486f60df8797aa96e0a459227089945d06b88303", "patch": "@@ -16,6 +16,7 @@ use rustc::session::search_paths::SearchPaths;\n use rustc::middle::{privacy, ty};\n use rustc::lint;\n use rustc_trans::back::link;\n+use rustc_resolve as resolve;\n \n use syntax::{ast, ast_map, codemap, diagnostic};\n \n@@ -126,7 +127,11 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let arenas = ty::CtxtArenas::new();\n     let ty::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n-    } = driver::phase_3_run_analysis_passes(sess, ast_map, &arenas, name);\n+    } = driver::phase_3_run_analysis_passes(sess,\n+                                            ast_map,\n+                                            &arenas,\n+                                            name,\n+                                            resolve::MakeGlobMap::No);\n \n     let ctxt = DocContext {\n         krate: ty_cx.map.krate(),"}, {"sha": "e6eed4806338bc53c37221ab9ef03c417a6c6fac", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=486f60df8797aa96e0a459227089945d06b88303", "patch": "@@ -27,6 +27,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_trans;\n extern crate rustc_driver;\n+extern crate rustc_resolve;\n extern crate serialize;\n extern crate syntax;\n extern crate \"test\" as testing;"}, {"sha": "9b8d220acc394010804fd72461591585a055ec20", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486f60df8797aa96e0a459227089945d06b88303/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=486f60df8797aa96e0a459227089945d06b88303", "patch": "@@ -123,7 +123,6 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n         search_paths: libs,\n         crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(config::OutputTypeExe),\n-        no_trans: no_run,\n         externs: externs,\n         cg: config::CodegenOptions {\n             prefer_dynamic: true,\n@@ -170,14 +169,18 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n     let sess = session::build_session_(sessopts,\n-                                      None,\n-                                      span_diagnostic_handler);\n+                                       None,\n+                                       span_diagnostic_handler);\n \n     let outdir = TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\");\n     let out = Some(outdir.path().clone());\n     let cfg = config::build_configuration(&sess);\n     let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n-    driver::compile_input(sess, cfg, &input, &out, &None, None);\n+    let mut control = driver::CompileController::basic();\n+    if no_run {\n+        control.after_analysis.stop = true;\n+    }\n+    driver::compile_input(sess, cfg, &input, &out, &None, None, control);\n \n     if no_run { return }\n "}, {"sha": "fe7df6411599c6a5c8882aaa5e59fb32987cf4a7", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/486f60df8797aa96e0a459227089945d06b88303/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486f60df8797aa96e0a459227089945d06b88303/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=486f60df8797aa96e0a459227089945d06b88303", "patch": "@@ -14,7 +14,7 @@ extern crate syntax;\n \n use rustc::session::{build_session, Session};\n use rustc::session::config::{basic_options, build_configuration, Input, OutputTypeExe};\n-use rustc_driver::driver::{compile_input};\n+use rustc_driver::driver::{compile_input, CompileController};\n use syntax::diagnostics::registry::Registry;\n \n fn main() {\n@@ -52,11 +52,13 @@ fn basic_sess(sysroot: Path) -> Session {\n fn compile(code: String, output: Path, sysroot: Path) {\n     let sess = basic_sess(sysroot);\n     let cfg = build_configuration(&sess);\n+    let control = CompileController::basic();\n \n     compile_input(sess,\n             cfg,\n             &Input::Str(code),\n             &None,\n             &Some(output),\n-            None);\n+            None,\n+            control);\n }"}]}