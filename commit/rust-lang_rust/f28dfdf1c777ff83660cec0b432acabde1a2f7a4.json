{"sha": "f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "node_id": "C_kwDOAAsO6NoAKGYyOGRmZGYxYzc3N2ZmODM2NjBjZWMwYjQzMmFjYWJkZTFhMmY3YTQ", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2021-07-01T21:36:38Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-06-27T02:20:33Z"}, "message": "proc_macro: stop using a remote object handle for Group\n\nThis greatly reduces round-trips to fetch relevant extra information about the\ntoken in proc macro code, and avoids RPC messages to create Group tokens.", "tree": {"sha": "186028e065c0b0445641450668b07aca1ab9661f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/186028e065c0b0445641450668b07aca1ab9661f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "html_url": "https://github.com/rust-lang/rust/commit/f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72bfe618fa06ba09fa898c1fd818b8d5886c6035", "url": "https://api.github.com/repos/rust-lang/rust/commits/72bfe618fa06ba09fa898c1fd818b8d5886c6035", "html_url": "https://github.com/rust-lang/rust/commit/72bfe618fa06ba09fa898c1fd818b8d5886c6035"}], "stats": {"total": 455, "additions": 205, "deletions": 250}, "files": [{"sha": "75731b9071d0758aa0a3e9c49a4410f74cda0275", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 160, "deletions": 214, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "patch": "@@ -2,7 +2,7 @@ use crate::base::ExtCtxt;\n \n use rustc_ast as ast;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{self, DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n+use rustc_ast::tokenstream::{self, Spacing::*, TokenStream};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -14,7 +14,7 @@ use rustc_span::def_id::CrateNum;\n use rustc_span::symbol::{self, kw, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n \n-use pm::bridge::{server, ExpnGlobals, Punct, TokenTree};\n+use pm::bridge::{server, DelimSpan, ExpnGlobals, Group, Punct, TokenTree};\n use pm::{Delimiter, Level, LineColumn};\n use std::ops::Bound;\n use std::{ascii, panic};\n@@ -49,158 +49,179 @@ impl ToInternal<token::Delimiter> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_, '_>)>\n-    for TokenTree<Span, Group, Ident, Literal>\n+impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n+    for Vec<TokenTree<TokenStream, Span, Ident, Literal>>\n {\n-    fn from_internal(\n-        ((tree, spacing), stack, rustc): (TreeAndSpacing, &mut Vec<Self>, &mut Rustc<'_, '_>),\n-    ) -> Self {\n+    fn from_internal((stream, rustc): (TokenStream, &mut Rustc<'_, '_>)) -> Self {\n         use rustc_ast::token::*;\n \n-        let joint = spacing == Joint;\n-        let Token { kind, span } = match tree {\n-            tokenstream::TokenTree::Delimited(span, delim, tts) => {\n-                let delimiter = pm::Delimiter::from_internal(delim);\n-                return TokenTree::Group(Group { delimiter, stream: tts, span, flatten: false });\n-            }\n-            tokenstream::TokenTree::Token(token) => token,\n-        };\n-\n-        macro_rules! tt {\n-            ($ty:ident { $($field:ident $(: $value:expr)*),+ $(,)? }) => (\n-                TokenTree::$ty(self::$ty {\n-                    $($field $(: $value)*,)+\n-                    span,\n-                })\n-            );\n-            ($ty:ident::$method:ident($($value:expr),*)) => (\n-                TokenTree::$ty(self::$ty::$method($($value,)* span))\n-            );\n-        }\n-        macro_rules! op {\n-            ($a:expr) => {\n-                tt!(Punct { ch: $a, joint })\n+        let mut cursor = stream.into_trees();\n+        let mut trees = Vec::new();\n+\n+        while let Some((tree, spacing)) = cursor.next_with_spacing() {\n+            let joint = spacing == Joint;\n+            let Token { kind, span } = match tree {\n+                tokenstream::TokenTree::Delimited(span, delim, tts) => {\n+                    let delimiter = pm::Delimiter::from_internal(delim);\n+                    trees.push(TokenTree::Group(Group {\n+                        delimiter,\n+                        stream: Some(tts),\n+                        span: DelimSpan {\n+                            open: span.open,\n+                            close: span.close,\n+                            entire: span.entire(),\n+                        },\n+                    }));\n+                    continue;\n+                }\n+                tokenstream::TokenTree::Token(token) => token,\n             };\n-            ($a:expr, $b:expr) => {{\n-                stack.push(tt!(Punct { ch: $b, joint }));\n-                tt!(Punct { ch: $a, joint: true })\n-            }};\n-            ($a:expr, $b:expr, $c:expr) => {{\n-                stack.push(tt!(Punct { ch: $c, joint }));\n-                stack.push(tt!(Punct { ch: $b, joint: true }));\n-                tt!(Punct { ch: $a, joint: true })\n-            }};\n-        }\n \n-        match kind {\n-            Eq => op!('='),\n-            Lt => op!('<'),\n-            Le => op!('<', '='),\n-            EqEq => op!('=', '='),\n-            Ne => op!('!', '='),\n-            Ge => op!('>', '='),\n-            Gt => op!('>'),\n-            AndAnd => op!('&', '&'),\n-            OrOr => op!('|', '|'),\n-            Not => op!('!'),\n-            Tilde => op!('~'),\n-            BinOp(Plus) => op!('+'),\n-            BinOp(Minus) => op!('-'),\n-            BinOp(Star) => op!('*'),\n-            BinOp(Slash) => op!('/'),\n-            BinOp(Percent) => op!('%'),\n-            BinOp(Caret) => op!('^'),\n-            BinOp(And) => op!('&'),\n-            BinOp(Or) => op!('|'),\n-            BinOp(Shl) => op!('<', '<'),\n-            BinOp(Shr) => op!('>', '>'),\n-            BinOpEq(Plus) => op!('+', '='),\n-            BinOpEq(Minus) => op!('-', '='),\n-            BinOpEq(Star) => op!('*', '='),\n-            BinOpEq(Slash) => op!('/', '='),\n-            BinOpEq(Percent) => op!('%', '='),\n-            BinOpEq(Caret) => op!('^', '='),\n-            BinOpEq(And) => op!('&', '='),\n-            BinOpEq(Or) => op!('|', '='),\n-            BinOpEq(Shl) => op!('<', '<', '='),\n-            BinOpEq(Shr) => op!('>', '>', '='),\n-            At => op!('@'),\n-            Dot => op!('.'),\n-            DotDot => op!('.', '.'),\n-            DotDotDot => op!('.', '.', '.'),\n-            DotDotEq => op!('.', '.', '='),\n-            Comma => op!(','),\n-            Semi => op!(';'),\n-            Colon => op!(':'),\n-            ModSep => op!(':', ':'),\n-            RArrow => op!('-', '>'),\n-            LArrow => op!('<', '-'),\n-            FatArrow => op!('=', '>'),\n-            Pound => op!('#'),\n-            Dollar => op!('$'),\n-            Question => op!('?'),\n-            SingleQuote => op!('\\''),\n-\n-            Ident(name, false) if name == kw::DollarCrate => tt!(Ident::dollar_crate()),\n-            Ident(name, is_raw) => tt!(Ident::new(rustc.sess(), name, is_raw)),\n-            Lifetime(name) => {\n-                let ident = symbol::Ident::new(name, span).without_first_quote();\n-                stack.push(tt!(Ident::new(rustc.sess(), ident.name, false)));\n-                tt!(Punct { ch: '\\'', joint: true })\n+            macro_rules! tt {\n+                ($ty:ident { $($field:ident $(: $value:expr)*),+ $(,)? }) => (\n+                    trees.push(TokenTree::$ty(self::$ty {\n+                        $($field $(: $value)*,)+\n+                        span,\n+                    }))\n+                );\n+                ($ty:ident::$method:ident($($value:expr),*)) => (\n+                    trees.push(TokenTree::$ty(self::$ty::$method($($value,)* span)))\n+                );\n             }\n-            Literal(lit) => tt!(Literal { lit }),\n-            DocComment(_, attr_style, data) => {\n-                let mut escaped = String::new();\n-                for ch in data.as_str().chars() {\n-                    escaped.extend(ch.escape_debug());\n+            macro_rules! op {\n+                ($a:expr) => {{\n+                    tt!(Punct { ch: $a, joint });\n+                }};\n+                ($a:expr, $b:expr) => {{\n+                    tt!(Punct { ch: $a, joint: true });\n+                    tt!(Punct { ch: $b, joint });\n+                }};\n+                ($a:expr, $b:expr, $c:expr) => {{\n+                    tt!(Punct { ch: $a, joint: true });\n+                    tt!(Punct { ch: $b, joint: true });\n+                    tt!(Punct { ch: $c, joint });\n+                }};\n+            }\n+\n+            match kind {\n+                Eq => op!('='),\n+                Lt => op!('<'),\n+                Le => op!('<', '='),\n+                EqEq => op!('=', '='),\n+                Ne => op!('!', '='),\n+                Ge => op!('>', '='),\n+                Gt => op!('>'),\n+                AndAnd => op!('&', '&'),\n+                OrOr => op!('|', '|'),\n+                Not => op!('!'),\n+                Tilde => op!('~'),\n+                BinOp(Plus) => op!('+'),\n+                BinOp(Minus) => op!('-'),\n+                BinOp(Star) => op!('*'),\n+                BinOp(Slash) => op!('/'),\n+                BinOp(Percent) => op!('%'),\n+                BinOp(Caret) => op!('^'),\n+                BinOp(And) => op!('&'),\n+                BinOp(Or) => op!('|'),\n+                BinOp(Shl) => op!('<', '<'),\n+                BinOp(Shr) => op!('>', '>'),\n+                BinOpEq(Plus) => op!('+', '='),\n+                BinOpEq(Minus) => op!('-', '='),\n+                BinOpEq(Star) => op!('*', '='),\n+                BinOpEq(Slash) => op!('/', '='),\n+                BinOpEq(Percent) => op!('%', '='),\n+                BinOpEq(Caret) => op!('^', '='),\n+                BinOpEq(And) => op!('&', '='),\n+                BinOpEq(Or) => op!('|', '='),\n+                BinOpEq(Shl) => op!('<', '<', '='),\n+                BinOpEq(Shr) => op!('>', '>', '='),\n+                At => op!('@'),\n+                Dot => op!('.'),\n+                DotDot => op!('.', '.'),\n+                DotDotDot => op!('.', '.', '.'),\n+                DotDotEq => op!('.', '.', '='),\n+                Comma => op!(','),\n+                Semi => op!(';'),\n+                Colon => op!(':'),\n+                ModSep => op!(':', ':'),\n+                RArrow => op!('-', '>'),\n+                LArrow => op!('<', '-'),\n+                FatArrow => op!('=', '>'),\n+                Pound => op!('#'),\n+                Dollar => op!('$'),\n+                Question => op!('?'),\n+                SingleQuote => op!('\\''),\n+\n+                Ident(name, false) if name == kw::DollarCrate => tt!(Ident::dollar_crate()),\n+                Ident(name, is_raw) => tt!(Ident::new(rustc.sess(), name, is_raw)),\n+                Lifetime(name) => {\n+                    let ident = symbol::Ident::new(name, span).without_first_quote();\n+                    tt!(Punct { ch: '\\'', joint: true });\n+                    tt!(Ident::new(rustc.sess(), ident.name, false));\n                 }\n-                let stream = [\n-                    Ident(sym::doc, false),\n-                    Eq,\n-                    TokenKind::lit(token::Str, Symbol::intern(&escaped), None),\n-                ]\n-                .into_iter()\n-                .map(|kind| tokenstream::TokenTree::token(kind, span))\n-                .collect();\n-                stack.push(TokenTree::Group(Group {\n-                    delimiter: pm::Delimiter::Bracket,\n-                    stream,\n-                    span: DelimSpan::from_single(span),\n-                    flatten: false,\n-                }));\n-                if attr_style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Punct { ch: '!', joint: false }));\n+                Literal(lit) => tt!(Literal { lit }),\n+                DocComment(_, attr_style, data) => {\n+                    let mut escaped = String::new();\n+                    for ch in data.as_str().chars() {\n+                        escaped.extend(ch.escape_debug());\n+                    }\n+                    let stream = vec![\n+                        Ident(sym::doc, false),\n+                        Eq,\n+                        TokenKind::lit(token::Str, Symbol::intern(&escaped), None),\n+                    ]\n+                    .into_iter()\n+                    .map(|kind| tokenstream::TokenTree::token(kind, span))\n+                    .collect();\n+                    tt!(Punct { ch: '#', joint: false });\n+                    if attr_style == ast::AttrStyle::Inner {\n+                        tt!(Punct { ch: '!', joint: false });\n+                    }\n+                    trees.push(TokenTree::Group(Group {\n+                        delimiter: pm::Delimiter::Bracket,\n+                        stream: Some(stream),\n+                        span: DelimSpan::from_single(span),\n+                    }));\n                 }\n-                tt!(Punct { ch: '#', joint: false })\n-            }\n \n-            Interpolated(nt) if let NtIdent(ident, is_raw) = *nt => {\n-                TokenTree::Ident(Ident::new(rustc.sess(), ident.name, is_raw, ident.span))\n-            }\n-            Interpolated(nt) => {\n-                TokenTree::Group(Group {\n-                    delimiter: pm::Delimiter::None,\n-                    stream: TokenStream::from_nonterminal_ast(&nt),\n-                    span: DelimSpan::from_single(span),\n-                    flatten: crate::base::nt_pretty_printing_compatibility_hack(&nt, rustc.sess()),\n-                })\n-            }\n+                Interpolated(nt) if let NtIdent(ident, is_raw) = *nt => {\n+                    trees.push(TokenTree::Ident(Ident::new(rustc.sess(), ident.name, is_raw, ident.span)))\n+                }\n \n-            OpenDelim(..) | CloseDelim(..) => unreachable!(),\n-            Eof => unreachable!(),\n+                Interpolated(nt) => {\n+                    let stream = TokenStream::from_nonterminal_ast(&nt);\n+                    if crate::base::nt_pretty_printing_compatibility_hack(&nt, rustc.sess()) {\n+                        trees.extend(Self::from_internal((stream, rustc)));\n+                    } else {\n+                        trees.push(TokenTree::Group(Group {\n+                            delimiter: pm::Delimiter::None,\n+                            stream: Some(stream),\n+                            span: DelimSpan::from_single(span),\n+                        }))\n+                    }\n+                }\n+\n+                OpenDelim(..) | CloseDelim(..) => unreachable!(),\n+                Eof => unreachable!(),\n+            }\n         }\n+        trees\n     }\n }\n \n-impl ToInternal<TokenStream> for TokenTree<Span, Group, Ident, Literal> {\n+impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n     fn to_internal(self) -> TokenStream {\n         use rustc_ast::token::*;\n \n         let (ch, joint, span) = match self {\n             TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),\n-            TokenTree::Group(Group { delimiter, stream, span, .. }) => {\n-                return tokenstream::TokenTree::Delimited(span, delimiter.to_internal(), stream)\n-                    .into();\n+            TokenTree::Group(Group { delimiter, stream, span: DelimSpan { open, close, .. } }) => {\n+                return tokenstream::TokenTree::Delimited(\n+                    tokenstream::DelimSpan { open, close },\n+                    delimiter.to_internal(),\n+                    stream.unwrap_or_default(),\n+                )\n+                .into();\n             }\n             TokenTree::Ident(self::Ident { sym, is_raw, span }) => {\n                 return tokenstream::TokenTree::token(Ident(sym, is_raw), span).into();\n@@ -277,17 +298,6 @@ impl ToInternal<rustc_errors::Level> for Level {\n \n pub struct FreeFunctions;\n \n-#[derive(Clone)]\n-pub struct Group {\n-    delimiter: Delimiter,\n-    stream: TokenStream,\n-    span: DelimSpan,\n-    /// A hack used to pass AST fragments to attribute and derive macros\n-    /// as a single nonterminal token instead of a token stream.\n-    /// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-    flatten: bool,\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Ident {\n     sym: Symbol,\n@@ -356,7 +366,6 @@ impl<'a, 'b> Rustc<'a, 'b> {\n impl server::Types for Rustc<'_, '_> {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n-    type Group = Group;\n     type Ident = Ident;\n     type Literal = Literal;\n     type SourceFile = Lrc<SourceFile>;\n@@ -449,15 +458,15 @@ impl server::TokenStream for Rustc<'_, '_> {\n \n     fn from_token_tree(\n         &mut self,\n-        tree: TokenTree<Self::Span, Self::Group, Self::Ident, Self::Literal>,\n+        tree: TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>,\n     ) -> Self::TokenStream {\n         tree.to_internal()\n     }\n \n     fn concat_trees(\n         &mut self,\n         base: Option<Self::TokenStream>,\n-        trees: Vec<TokenTree<Self::Span, Self::Group, Self::Ident, Self::Literal>>,\n+        trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>>,\n     ) -> Self::TokenStream {\n         let mut builder = tokenstream::TokenStreamBuilder::new();\n         if let Some(base) = base {\n@@ -487,71 +496,8 @@ impl server::TokenStream for Rustc<'_, '_> {\n     fn into_trees(\n         &mut self,\n         stream: Self::TokenStream,\n-    ) -> Vec<TokenTree<Self::Span, Self::Group, Self::Ident, Self::Literal>> {\n-        // FIXME: This is a raw port of the previous approach (which had a\n-        // `TokenStreamIter` server-side object with a single `next` method),\n-        // and can probably be optimized (for bulk conversion).\n-        let mut cursor = stream.into_trees();\n-        let mut stack = Vec::new();\n-        let mut tts = Vec::new();\n-        loop {\n-            let next = stack.pop().or_else(|| {\n-                let next = cursor.next_with_spacing()?;\n-                Some(TokenTree::from_internal((next, &mut stack, self)))\n-            });\n-            match next {\n-                Some(TokenTree::Group(group)) => {\n-                    // A hack used to pass AST fragments to attribute and derive\n-                    // macros as a single nonterminal token instead of a token\n-                    // stream.  Such token needs to be \"unwrapped\" and not\n-                    // represented as a delimited group.\n-                    // FIXME: It needs to be removed, but there are some\n-                    // compatibility issues (see #73345).\n-                    if group.flatten {\n-                        tts.append(&mut self.into_trees(group.stream));\n-                    } else {\n-                        tts.push(TokenTree::Group(group));\n-                    }\n-                }\n-                Some(tt) => tts.push(tt),\n-                None => return tts,\n-            }\n-        }\n-    }\n-}\n-\n-impl server::Group for Rustc<'_, '_> {\n-    fn new(&mut self, delimiter: Delimiter, stream: Option<Self::TokenStream>) -> Self::Group {\n-        Group {\n-            delimiter,\n-            stream: stream.unwrap_or_default(),\n-            span: DelimSpan::from_single(self.call_site),\n-            flatten: false,\n-        }\n-    }\n-\n-    fn delimiter(&mut self, group: &Self::Group) -> Delimiter {\n-        group.delimiter\n-    }\n-\n-    fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n-        group.stream.clone()\n-    }\n-\n-    fn span(&mut self, group: &Self::Group) -> Self::Span {\n-        group.span.entire()\n-    }\n-\n-    fn span_open(&mut self, group: &Self::Group) -> Self::Span {\n-        group.span.open\n-    }\n-\n-    fn span_close(&mut self, group: &Self::Group) -> Self::Span {\n-        group.span.close\n-    }\n-\n-    fn set_span(&mut self, group: &mut Self::Group, span: Self::Span) {\n-        group.span = DelimSpan::from_single(span);\n+    ) -> Vec<TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>> {\n+        FromInternal::from_internal((stream, self))\n     }\n }\n "}, {"sha": "8254bd6e5024a5d6232951a21adc9070e7b0df6f", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "patch": "@@ -175,7 +175,6 @@ define_handles! {\n     'owned:\n     FreeFunctions,\n     TokenStream,\n-    Group,\n     Literal,\n     SourceFile,\n     MultiSpan,\n@@ -198,12 +197,6 @@ impl Clone for TokenStream {\n     }\n }\n \n-impl Clone for Group {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n impl Clone for Literal {\n     fn clone(&self) -> Self {\n         self.clone()"}, {"sha": "8995b5de4757dc53c9505ae9957e75786f88cfde", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "patch": "@@ -65,30 +65,19 @@ macro_rules! with_api {\n                 fn from_str(src: &str) -> $S::TokenStream;\n                 fn to_string($self: &$S::TokenStream) -> String;\n                 fn from_token_tree(\n-                    tree: TokenTree<$S::Span, $S::Group, $S::Ident, $S::Literal>,\n+                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>,\n                 ) -> $S::TokenStream;\n                 fn concat_trees(\n                     base: Option<$S::TokenStream>,\n-                    trees: Vec<TokenTree<$S::Span, $S::Group, $S::Ident, $S::Literal>>,\n+                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>,\n                 ) -> $S::TokenStream;\n                 fn concat_streams(\n                     base: Option<$S::TokenStream>,\n                     streams: Vec<$S::TokenStream>,\n                 ) -> $S::TokenStream;\n                 fn into_trees(\n                     $self: $S::TokenStream\n-                ) -> Vec<TokenTree<$S::Span, $S::Group, $S::Ident, $S::Literal>>;\n-            },\n-            Group {\n-                fn drop($self: $S::Group);\n-                fn clone($self: &$S::Group) -> $S::Group;\n-                fn new(delimiter: Delimiter, stream: Option<$S::TokenStream>) -> $S::Group;\n-                fn delimiter($self: &$S::Group) -> Delimiter;\n-                fn stream($self: &$S::Group) -> $S::TokenStream;\n-                fn span($self: &$S::Group) -> $S::Span;\n-                fn span_open($self: &$S::Group) -> $S::Span;\n-                fn span_close($self: &$S::Group) -> $S::Span;\n-                fn set_span($self: &mut $S::Group, span: $S::Span);\n+                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>;\n             },\n             Ident {\n                 fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n@@ -441,6 +430,30 @@ compound_traits!(\n     }\n );\n \n+#[derive(Copy, Clone)]\n+pub struct DelimSpan<S> {\n+    pub open: S,\n+    pub close: S,\n+    pub entire: S,\n+}\n+\n+impl<S: Copy> DelimSpan<S> {\n+    pub fn from_single(span: S) -> Self {\n+        DelimSpan { open: span, close: span, entire: span }\n+    }\n+}\n+\n+compound_traits!(struct DelimSpan<Sp> { open, close, entire });\n+\n+#[derive(Clone)]\n+pub struct Group<T, S> {\n+    pub delimiter: Delimiter,\n+    pub stream: Option<T>,\n+    pub span: DelimSpan<S>,\n+}\n+\n+compound_traits!(struct Group<T, Sp> { delimiter, stream, span });\n+\n #[derive(Clone)]\n pub struct Punct<S> {\n     pub ch: char,\n@@ -451,15 +464,15 @@ pub struct Punct<S> {\n compound_traits!(struct Punct<Sp> { ch, joint, span });\n \n #[derive(Clone)]\n-pub enum TokenTree<S, G, I, L> {\n-    Group(G),\n+pub enum TokenTree<T, S, I, L> {\n+    Group(Group<T, S>),\n     Punct(Punct<S>),\n     Ident(I),\n     Literal(L),\n }\n \n compound_traits!(\n-    enum TokenTree<Sp, G, I, L> {\n+    enum TokenTree<T, Sp, I, L> {\n         Group(tt),\n         Punct(tt),\n         Ident(tt),"}, {"sha": "ea8b833b48fde53109e3eecca3b4a15827bc2093", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "patch": "@@ -8,7 +8,6 @@ use super::client::HandleStore;\n pub trait Types {\n     type FreeFunctions: 'static;\n     type TokenStream: 'static + Clone;\n-    type Group: 'static + Clone;\n     type Ident: 'static + Copy + Eq + Hash;\n     type Literal: 'static + Clone;\n     type SourceFile: 'static + Clone;"}, {"sha": "7f6356953ca1c078b299798ba489f28c6aa06d9f", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28dfdf1c777ff83660cec0b432acabde1a2f7a4/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "patch": "@@ -212,8 +212,8 @@ pub use quote::{quote, quote_span};\n fn tree_to_bridge_tree(\n     tree: TokenTree,\n ) -> bridge::TokenTree<\n+    bridge::client::TokenStream,\n     bridge::client::Span,\n-    bridge::client::Group,\n     bridge::client::Ident,\n     bridge::client::Literal,\n > {\n@@ -238,8 +238,8 @@ impl From<TokenTree> for TokenStream {\n struct ConcatTreesHelper {\n     trees: Vec<\n         bridge::TokenTree<\n+            bridge::client::TokenStream,\n             bridge::client::Span,\n-            bridge::client::Group,\n             bridge::client::Ident,\n             bridge::client::Literal,\n         >,\n@@ -365,8 +365,8 @@ pub mod token_stream {\n     pub struct IntoIter(\n         std::vec::IntoIter<\n             bridge::TokenTree<\n+                bridge::client::TokenStream,\n                 bridge::client::Span,\n-                bridge::client::Group,\n                 bridge::client::Ident,\n                 bridge::client::Literal,\n             >,\n@@ -788,7 +788,7 @@ impl fmt::Display for TokenTree {\n /// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n #[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Group(bridge::client::Group);\n+pub struct Group(bridge::Group<bridge::client::TokenStream, bridge::client::Span>);\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Group {}\n@@ -825,13 +825,17 @@ impl Group {\n     /// method below.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n-        Group(bridge::client::Group::new(delimiter, stream.0))\n+        Group(bridge::Group {\n+            delimiter,\n+            stream: stream.0,\n+            span: bridge::DelimSpan::from_single(Span::call_site().0),\n+        })\n     }\n \n     /// Returns the delimiter of this `Group`\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn delimiter(&self) -> Delimiter {\n-        self.0.delimiter()\n+        self.0.delimiter\n     }\n \n     /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n@@ -840,7 +844,7 @@ impl Group {\n     /// returned above.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn stream(&self) -> TokenStream {\n-        TokenStream(Some(self.0.stream()))\n+        TokenStream(self.0.stream.clone())\n     }\n \n     /// Returns the span for the delimiters of this token stream, spanning the\n@@ -852,7 +856,7 @@ impl Group {\n     /// ```\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        Span(self.0.span())\n+        Span(self.0.span.entire)\n     }\n \n     /// Returns the span pointing to the opening delimiter of this group.\n@@ -863,7 +867,7 @@ impl Group {\n     /// ```\n     #[stable(feature = \"proc_macro_group_span\", since = \"1.55.0\")]\n     pub fn span_open(&self) -> Span {\n-        Span(self.0.span_open())\n+        Span(self.0.span.open)\n     }\n \n     /// Returns the span pointing to the closing delimiter of this group.\n@@ -874,7 +878,7 @@ impl Group {\n     /// ```\n     #[stable(feature = \"proc_macro_group_span\", since = \"1.55.0\")]\n     pub fn span_close(&self) -> Span {\n-        Span(self.0.span_close())\n+        Span(self.0.span.close)\n     }\n \n     /// Configures the span for this `Group`'s delimiters, but not its internal\n@@ -885,7 +889,7 @@ impl Group {\n     /// tokens at the level of the `Group`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.0.set_span(span.0);\n+        self.0.span = bridge::DelimSpan::from_single(span.0);\n     }\n }\n "}]}