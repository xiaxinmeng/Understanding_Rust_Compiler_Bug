{"sha": "4d9d84999e6c0d97f1c445a70085e444d6f11717", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkOWQ4NDk5OWU2YzBkOTdmMWM0NDVhNzAwODVlNDQ0ZDZmMTE3MTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-26T01:50:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-26T01:50:20Z"}, "message": "Rollup merge of #60247 - spastorino:place2_3, r=oli-obk\n\nImplement Debug for Place using Place::iterate\n\nr? @oli-obk", "tree": {"sha": "2ef8a05dfdffa73ee2e0226b7ab61bf570de7e8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ef8a05dfdffa73ee2e0226b7ab61bf570de7e8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d9d84999e6c0d97f1c445a70085e444d6f11717", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcwmPcCRBK7hj4Ov3rIwAAdHIIAFyY/SgHa+I//HuOFL1KGMMs\n5iUc9OJ4ZB0HHGPjXsF/gw3Q6W1ChX4UrY+G5LU8E1F1Zys2EfCCkQLXX2RGD/J6\n8Ai6+90m4KN/RXT6TvfvnB9Nxtfpq+32nPuNwNHu0h0Li6xyQXKf1rErtuBb+Yru\njl7pnw2JKTPXJGX3e9mvQ8qqOgrHBk4Kse3gKL/R0nNsdEHn4SY++YyX5E9NpltE\nB90HfxlvW/+2haLUM2zXxOsDUcITtVESlg4OcVsTX0BtGi+sFWPIU+ZGTwCwKpMu\n/MoVappByj/ZhvzAq8ppFlfypZnJYsOft53kgFO2tTY7FAjj7gEiw3wuWypfQms=\n=saRO\n-----END PGP SIGNATURE-----\n", "payload": "tree 2ef8a05dfdffa73ee2e0226b7ab61bf570de7e8c\nparent 7560c158f684e978654f7dea81eebaf1e53bf653\nparent 72cda98e48e41d5852b4746688cc85d56c22f982\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556243420 +0200\ncommitter GitHub <noreply@github.com> 1556243420 +0200\n\nRollup merge of #60247 - spastorino:place2_3, r=oli-obk\n\nImplement Debug for Place using Place::iterate\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d9d84999e6c0d97f1c445a70085e444d6f11717", "html_url": "https://github.com/rust-lang/rust/commit/4d9d84999e6c0d97f1c445a70085e444d6f11717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d9d84999e6c0d97f1c445a70085e444d6f11717/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7560c158f684e978654f7dea81eebaf1e53bf653", "url": "https://api.github.com/repos/rust-lang/rust/commits/7560c158f684e978654f7dea81eebaf1e53bf653", "html_url": "https://github.com/rust-lang/rust/commit/7560c158f684e978654f7dea81eebaf1e53bf653"}, {"sha": "72cda98e48e41d5852b4746688cc85d56c22f982", "url": "https://api.github.com/repos/rust-lang/rust/commits/72cda98e48e41d5852b4746688cc85d56c22f982", "html_url": "https://github.com/rust-lang/rust/commit/72cda98e48e41d5852b4746688cc85d56c22f982"}], "stats": {"total": 138, "additions": 86, "deletions": 52}, "files": [{"sha": "3d094e72d26aa295288de5c652b51a37d2dbb030", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 86, "deletions": 52, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/4d9d84999e6c0d97f1c445a70085e444d6f11717/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d9d84999e6c0d97f1c445a70085e444d6f11717/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=4d9d84999e6c0d97f1c445a70085e444d6f11717", "patch": "@@ -2156,61 +2156,95 @@ impl<'p, 'tcx> FusedIterator for PlaceProjectionsIter<'p, 'tcx> {}\n \n impl<'tcx> Debug for Place<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        use self::Place::*;\n-\n-        match *self {\n-            Base(PlaceBase::Local(id)) => write!(fmt, \"{:?}\", id),\n-            Base(PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) })) => {\n-                write!(\n-                    fmt,\n-                    \"({}: {:?})\",\n-                    ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n-                    ty\n-                )\n-            },\n-            Base(PlaceBase::Static(\n-                box self::Static { ty, kind: StaticKind::Promoted(promoted) })\n-            ) => {\n-                write!(\n-                    fmt,\n-                    \"({:?}: {:?})\",\n-                    promoted,\n-                    ty\n-                )\n-            },\n-            Projection(ref data) => match data.elem {\n-                ProjectionElem::Downcast(Some(name), _index) => {\n-                    write!(fmt, \"({:?} as {})\", data.base, name)\n-                }\n-                ProjectionElem::Downcast(None, index) => {\n-                    write!(fmt, \"({:?} as variant#{:?})\", data.base, index)\n-                }\n-                ProjectionElem::Deref => write!(fmt, \"(*{:?})\", data.base),\n-                ProjectionElem::Field(field, ty) => {\n-                    write!(fmt, \"({:?}.{:?}: {:?})\", data.base, field.index(), ty)\n-                }\n-                ProjectionElem::Index(ref index) => write!(fmt, \"{:?}[{:?}]\", data.base, index),\n-                ProjectionElem::ConstantIndex {\n-                    offset,\n-                    min_length,\n-                    from_end: false,\n-                } => write!(fmt, \"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n-                ProjectionElem::ConstantIndex {\n-                    offset,\n-                    min_length,\n-                    from_end: true,\n-                } => write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n-                ProjectionElem::Subslice { from, to } if to == 0 => {\n-                    write!(fmt, \"{:?}[{:?}:]\", data.base, from)\n+        self.iterate(|_place_base, place_projections| {\n+            // FIXME: remove this collect once we have migrated to slices\n+            let projs_vec: Vec<_> = place_projections.collect();\n+            for projection in projs_vec.iter().rev() {\n+                match projection.elem {\n+                    ProjectionElem::Downcast(_, _) |\n+                    ProjectionElem::Field(_, _) => {\n+                        write!(fmt, \"(\").unwrap();\n+                    }\n+                    ProjectionElem::Deref => {\n+                        write!(fmt, \"(*\").unwrap();\n+                    }\n+                    ProjectionElem::Index(_) |\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Subslice { .. } => {}\n                 }\n-                ProjectionElem::Subslice { from, to } if from == 0 => {\n-                    write!(fmt, \"{:?}[:-{:?}]\", data.base, to)\n+            }\n+        });\n+\n+        self.iterate(|place_base, place_projections| {\n+            match place_base {\n+                PlaceBase::Local(id) => {\n+                    write!(fmt, \"{:?}\", id)?;\n                 }\n-                ProjectionElem::Subslice { from, to } => {\n-                    write!(fmt, \"{:?}[{:?}:-{:?}]\", data.base, from, to)\n+                PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) }) => {\n+                    write!(\n+                        fmt,\n+                        \"({}: {:?})\",\n+                        ty::tls::with(|tcx| tcx.def_path_str(*def_id)),\n+                        ty\n+                    )?;\n+                },\n+                PlaceBase::Static(\n+                    box self::Static { ty, kind: StaticKind::Promoted(promoted) }\n+                ) => {\n+                    write!(\n+                        fmt,\n+                        \"({:?}: {:?})\",\n+                        promoted,\n+                        ty\n+                    )?;\n+                },\n+            }\n+\n+            for projection in place_projections {\n+                match projection.elem {\n+                    ProjectionElem::Downcast(Some(name), _index) => {\n+                        write!(fmt, \" as {})\", name)?;\n+                    }\n+                    ProjectionElem::Downcast(None, index) => {\n+                        write!(fmt, \" as variant#{:?})\", index)?;\n+                    }\n+                    ProjectionElem::Deref => {\n+                        write!(fmt, \")\")?;\n+                    }\n+                    ProjectionElem::Field(field, ty) => {\n+                        write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n+                    }\n+                    ProjectionElem::Index(ref index) => {\n+                        write!(fmt, \"[{:?}]\", index)?;\n+                    }\n+                    ProjectionElem::ConstantIndex {\n+                        offset,\n+                        min_length,\n+                        from_end: false,\n+                    } => {\n+                        write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n+                    }\n+                    ProjectionElem::ConstantIndex {\n+                        offset,\n+                        min_length,\n+                        from_end: true,\n+                    } => {\n+                        write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n+                    }\n+                    ProjectionElem::Subslice { from, to } if to == 0 => {\n+                        write!(fmt, \"[{:?}:]\", from)?;\n+                    }\n+                    ProjectionElem::Subslice { from, to } if from == 0 => {\n+                        write!(fmt, \"[:-{:?}]\", to)?;\n+                    }\n+                    ProjectionElem::Subslice { from, to } => {\n+                        write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n+                    }\n                 }\n-            },\n-        }\n+            }\n+\n+            Ok(())\n+        })\n     }\n }\n "}]}