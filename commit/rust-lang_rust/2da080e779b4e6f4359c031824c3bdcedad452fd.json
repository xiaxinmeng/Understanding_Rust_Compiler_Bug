{"sha": "2da080e779b4e6f4359c031824c3bdcedad452fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYTA4MGU3NzliNGU2ZjQzNTljMDMxODI0YzNiZGNlZGFkNDUyZmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-11T12:05:00Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-13T14:42:59Z"}, "message": "rustc: treat ReEarlyBound as free without replacing it with ReFree.", "tree": {"sha": "891c3e4d560110edf05dbace4c47d767b13aa06e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/891c3e4d560110edf05dbace4c47d767b13aa06e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2da080e779b4e6f4359c031824c3bdcedad452fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2da080e779b4e6f4359c031824c3bdcedad452fd", "html_url": "https://github.com/rust-lang/rust/commit/2da080e779b4e6f4359c031824c3bdcedad452fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2da080e779b4e6f4359c031824c3bdcedad452fd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbae169ac16de632d21fd3394bc8a939b2524512", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbae169ac16de632d21fd3394bc8a939b2524512", "html_url": "https://github.com/rust-lang/rust/commit/dbae169ac16de632d21fd3394bc8a939b2524512"}], "stats": {"total": 580, "additions": 248, "deletions": 332}, "files": [{"sha": "f9a86c2f010f703bb96903d25cf189b9e486da86", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -54,7 +54,8 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind<'tc\n                 db.depth.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n             }\n-            ty::ReEarlyBound(ty::EarlyBoundRegion { index, name }) => {\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {\n+                def_id.hash_stable(hcx, hasher);\n                 index.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }"}, {"sha": "18909a784d6106298aec4d8ad3b7b5e3b5250bd2", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -423,15 +423,6 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 return Ok(r);\n             }\n \n-            // Early-bound regions should really have been substituted away before\n-            // we get to this point.\n-            ty::ReEarlyBound(..) => {\n-                span_bug!(\n-                    self.span,\n-                    \"Encountered early bound region when generalizing: {:?}\",\n-                    r);\n-            }\n-\n             // Always make a fresh region variable for skolemized regions;\n             // the higher-ranked decision procedures rely on this.\n             ty::ReSkolemized(..) => { }\n@@ -442,6 +433,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n             ty::ReStatic |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n+            ty::ReEarlyBound(..) |\n             ty::ReFree(..) => {\n                 match self.ambient_variance {\n                     ty::Invariant => return Ok(r),"}, {"sha": "da5ff6ff38ac0452c66f37df772e8d6ba277e487", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -172,19 +172,35 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 explain_span(self, scope_decorated_tag, span)\n             }\n \n-            ty::ReFree(ref fr) => {\n-                let prefix = match fr.bound_region {\n-                    ty::BrAnon(idx) => {\n-                        format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+            ty::ReEarlyBound(_) |\n+            ty::ReFree(_) => {\n+                let scope = match *region {\n+                    ty::ReEarlyBound(ref br) => {\n+                        self.parent_def_id(br.def_id).unwrap()\n                     }\n-                    ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n-                    _ => {\n-                        format!(\"the lifetime {} as defined on\",\n-                                fr.bound_region)\n+                    ty::ReFree(ref fr) => fr.scope,\n+                    _ => bug!()\n+                };\n+                let prefix = match *region {\n+                    ty::ReEarlyBound(ref br) => {\n+                        format!(\"the lifetime {} as defined on\", br.name)\n+                    }\n+                    ty::ReFree(ref fr) => {\n+                        match fr.bound_region {\n+                            ty::BrAnon(idx) => {\n+                                format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+                            }\n+                            ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n+                            _ => {\n+                                format!(\"the lifetime {} as defined on\",\n+                                        fr.bound_region)\n+                            }\n+                        }\n                     }\n+                    _ => bug!()\n                 };\n \n-                let node = self.hir.as_local_node_id(fr.scope)\n+                let node = self.hir.as_local_node_id(scope)\n                                    .unwrap_or(DUMMY_NODE_ID);\n                 let unknown;\n                 let tag = match self.hir.find(node) {\n@@ -199,12 +215,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     Some(_) => {\n                         unknown = format!(\"unexpected node ({}) for scope {:?}.  \\\n                                            Please report a bug.\",\n-                                          self.hir.node_to_string(node), fr.scope);\n+                                          self.hir.node_to_string(node), scope);\n                         &unknown\n                     }\n                     None => {\n                         unknown = format!(\"unknown node for scope {:?}.  \\\n-                                           Please report a bug.\", fr.scope);\n+                                           Please report a bug.\", scope);\n                         &unknown\n                     }\n                 };\n@@ -216,8 +232,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-            ty::ReEarlyBound(ref data) => (data.name.to_string(), None),\n-\n             // FIXME(#13998) ReSkolemized should probably print like\n             // ReFree rather than dumping Debug output on the user.\n             //\n@@ -797,6 +811,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut err = match *sub {\n+            ty::ReEarlyBound(_) |\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(self.tcx.sess,"}, {"sha": "a0ef1f65f52eac661ca0000eaed6e99251194426", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -85,13 +85,13 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReEarlyBound(..) |\n             ty::ReLateBound(..) => {\n                 // leave bound regions alone\n                 r\n             }\n \n             ty::ReStatic |\n+            ty::ReEarlyBound(..) |\n             ty::ReFree(_) |\n             ty::ReScope(_) |\n             ty::ReVar(_) |"}, {"sha": "dbbcc6cfbec6b0048cce15c8af31a37110873133", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              -> ty::Region<'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_bound());\n+                assert!(!r0.is_late_bound());\n                 debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n@@ -288,7 +288,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 debug!(\"generalize_region(r0={:?}): \\\n                         non-new-variables found in {:?}\",\n                        r0, tainted);\n-                assert!(!r0.is_bound());\n+                assert!(!r0.is_late_bound());\n                 return r0;\n             }\n \n@@ -371,7 +371,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              r0: ty::Region<'tcx>)\n                                              -> ty::Region<'tcx> {\n             if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_bound());\n+                assert!(!r0.is_late_bound());\n                 return r0;\n             }\n \n@@ -424,7 +424,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 return rev_lookup(infcx, span, a_map, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n-                assert!(!r0.is_bound());\n+                assert!(!r0.is_late_bound());\n                 return r0;\n             } else {\n                 // Other:"}, {"sha": "e42280124a158e960f3eb7d525dfcbbd69d91d48", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -1009,7 +1009,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_given(&self,\n-                     sub: ty::FreeRegion,\n+                     sub: ty::Region<'tcx>,\n                      sup: ty::RegionVid)\n     {\n         self.region_vars.add_given(sub, sup);"}, {"sha": "2e3c2443544f649601743c9174465d7d2a1e5a54", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -29,7 +29,6 @@ use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n \n use std::cell::{Cell, RefCell};\n-use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::fmt;\n use std::mem;\n use std::u32;\n@@ -127,7 +126,7 @@ pub enum UndoLogEntry<'tcx> {\n     AddVerify(usize),\n \n     /// We added the given `given`\n-    AddGiven(ty::FreeRegion, ty::RegionVid),\n+    AddGiven(Region<'tcx>, ty::RegionVid),\n \n     /// We added a GLB/LUB \"combinaton variable\"\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n@@ -213,7 +212,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<FxHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n+    givens: RefCell<FxHashSet<(Region<'tcx>, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n@@ -309,8 +308,7 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n                         self.add_edge(a, b);\n                     }\n                     &AddGiven(a, b) => {\n-                        self.add_edge(tcx.mk_region(ReFree(a)),\n-                                      tcx.mk_region(ReVar(b)));\n+                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n                     }\n                     &AddVerify(i) => {\n                         verifys[i].bound.for_each_region(&mut |b| {\n@@ -661,7 +659,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn add_given(&self, sub: ty::FreeRegion, sup: ty::RegionVid) {\n+    pub fn add_given(&self, sub: Region<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -702,9 +700,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                origin);\n \n         match (sub, sup) {\n-            (&ReEarlyBound(..), _) |\n             (&ReLateBound(..), _) |\n-            (_, &ReEarlyBound(..)) |\n             (_, &ReLateBound(..)) => {\n                 span_bug!(origin.span(),\n                           \"cannot relate bound region: {:?} <= {:?}\",\n@@ -908,8 +904,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         match (a, b) {\n             (&ReLateBound(..), _) |\n             (_, &ReLateBound(..)) |\n-            (&ReEarlyBound(..), _) |\n-            (_, &ReEarlyBound(..)) |\n             (&ReErased, _) |\n             (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n@@ -931,18 +925,32 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                           b);\n             }\n \n-            (&ReFree(ref fr), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReFree(ref fr)) => {\n+            (&ReEarlyBound(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReFree(_)) => {\n                 // A \"free\" region can be interpreted as \"some region\n                 // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n-                let fr_scope = region_rels.region_maps.free_extent(self.tcx, fr);\n+                let fr_scope = match (a, b) {\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n+                        region_rels.region_maps.early_free_extent(self.tcx, br)\n+                    }\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n+                        region_rels.region_maps.free_extent(self.tcx, fr)\n+                    }\n+                    _ => bug!()\n+                };\n                 let r_id = region_rels.region_maps.nearest_common_ancestor(fr_scope, s_id);\n                 if r_id == fr_scope {\n                     // if the free region's scope `fr.scope` is bigger than\n                     // the scope region `s_id`, then the LUB is the free\n                     // region itself:\n-                    return self.tcx.mk_region(ReFree(*fr));\n+                    match (a, b) {\n+                        (_, &ReScope(_)) => return a,\n+                        (&ReScope(_), _) => return b,\n+                        _ => bug!()\n+                    }\n                 }\n \n                 // otherwise, we don't know what the free region is,\n@@ -958,6 +966,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 self.tcx.mk_region(ReScope(lub))\n             }\n \n+            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReEarlyBound(_)) |\n+            (&ReEarlyBound(_), &ReFree(_)) |\n             (&ReFree(_), &ReFree(_)) => {\n                 region_rels.lub_free_regions(a, b)\n             }\n@@ -1040,13 +1051,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         let mut givens = self.givens.borrow_mut();\n         let seeds: Vec<_> = givens.iter().cloned().collect();\n-        for (fr, vid) in seeds {\n+        for (r, vid) in seeds {\n             let seed_index = NodeIndex(vid.index as usize);\n             for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n                 let succ_index = succ_index.0 as u32;\n                 if succ_index < self.num_vars() {\n                     let succ_vid = RegionVid { index: succ_index };\n-                    givens.insert((fr, succ_vid));\n+                    givens.insert((r, succ_vid));\n                 }\n             }\n         }\n@@ -1095,8 +1106,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         // Check if this relationship is implied by a given.\n         match *a_region {\n-            ty::ReFree(fr) => {\n-                if self.givens.borrow().contains(&(fr, b_vid)) {\n+            ty::ReEarlyBound(_) |\n+            ty::ReFree(_) => {\n+                if self.givens.borrow().contains(&(a_region, b_vid)) {\n                     debug!(\"given\");\n                     return false;\n                 }\n@@ -1332,16 +1344,15 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         // We place free regions first because we are special casing\n         // SubSupConflict(ReFree, ReFree) when reporting error, and so\n         // the user will more likely get a specific suggestion.\n-        fn free_regions_first(a: &RegionAndOrigin, b: &RegionAndOrigin) -> Ordering {\n-            match (a.region, b.region) {\n-                (&ReFree(..), &ReFree(..)) => Equal,\n-                (&ReFree(..), _) => Less,\n-                (_, &ReFree(..)) => Greater,\n-                (..) => Equal,\n+        fn region_order_key(x: &RegionAndOrigin) -> u8 {\n+            match *x.region {\n+                ReEarlyBound(_) => 0,\n+                ReFree(_) => 1,\n+                _ => 2\n             }\n         }\n-        lower_bounds.sort_by(|a, b| free_regions_first(a, b));\n-        upper_bounds.sort_by(|a, b| free_regions_first(a, b));\n+        lower_bounds.sort_by_key(region_order_key);\n+        upper_bounds.sort_by_key(region_order_key);\n \n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {"}, {"sha": "8168837b1f5e437cb0a019d9bacc10d4f19727fa", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -71,23 +71,27 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n                 (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n                     self.region_maps.is_subscope_of(sub_scope, super_scope),\n \n+                (&ty::ReScope(sub_scope), &ty::ReEarlyBound(ref br)) => {\n+                    let fr_scope = self.region_maps.early_free_extent(self.tcx, br);\n+                    self.region_maps.is_subscope_of(sub_scope, fr_scope)\n+                }\n+\n                 (&ty::ReScope(sub_scope), &ty::ReFree(ref fr)) => {\n                     let fr_scope = self.region_maps.free_extent(self.tcx, fr);\n-                    self.region_maps.is_subscope_of(sub_scope, fr_scope) ||\n-                        self.is_static(super_region)\n+                    self.region_maps.is_subscope_of(sub_scope, fr_scope)\n                 }\n \n+                (&ty::ReEarlyBound(_), &ty::ReEarlyBound(_)) |\n+                (&ty::ReFree(_), &ty::ReEarlyBound(_)) |\n+                (&ty::ReEarlyBound(_), &ty::ReFree(_)) |\n                 (&ty::ReFree(_), &ty::ReFree(_)) =>\n-                    self.free_regions.relation.contains(&sub_region, &super_region) ||\n-                        self.is_static(super_region),\n-\n-                (&ty::ReStatic, &ty::ReFree(_)) =>\n-                    self.is_static(super_region),\n+                    self.free_regions.relation.contains(&sub_region, &super_region),\n \n                 _ =>\n                     false,\n             }\n         };\n+        let result = result || self.is_static(super_region);\n         debug!(\"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n                sub_region, super_region, result);\n         result\n@@ -98,11 +102,11 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n         debug!(\"is_static(super_region={:?})\", super_region);\n         match *super_region {\n             ty::ReStatic => true,\n-            ty::ReFree(_) => {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n                 let re_static = self.tcx.mk_region(ty::ReStatic);\n                 self.free_regions.relation.contains(&re_static, &super_region)\n             }\n-            _ => bug!(\"only free regions should be given to `is_static`\")\n+            _ => false\n         }\n     }\n \n@@ -139,11 +143,9 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         for implied_bound in implied_bounds {\n             debug!(\"implied bound: {:?}\", implied_bound);\n             match *implied_bound {\n-                ImpliedBound::RegionSubRegion(a @ &ty::ReFree(_), b @ &ty::ReFree(_)) |\n-                ImpliedBound::RegionSubRegion(a @ &ty::ReStatic, b @ &ty::ReFree(_)) => {\n+                ImpliedBound::RegionSubRegion(a, b) => {\n                     self.relate_regions(a, b);\n                 }\n-                ImpliedBound::RegionSubRegion(..) |\n                 ImpliedBound::RegionSubParam(..) |\n                 ImpliedBound::RegionSubProjection(..) => {\n                 }\n@@ -167,41 +169,27 @@ impl<'tcx> FreeRegionMap<'tcx> {\n                     // No region bounds here\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n-                    match (r_a, r_b) {\n-                        // `'static: 'x` is not notable\n-                        (&ty::ReStatic, &ty::ReFree(_)) => {},\n-\n-                        (&ty::ReFree(_), &ty::ReStatic) |\n-                        (&ty::ReFree(_), &ty::ReFree(_)) => {\n-                            // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n-                            self.relate_regions(r_b, r_a);\n-                        }\n-\n-                        _ => {\n-                            // All named regions are instantiated with free regions.\n-                            bug!(\"record_region_bounds: non free region: {:?} / {:?}\",\n-                                 r_a,\n-                                 r_b);\n-                        }\n-                    }\n+                    self.relate_regions(r_b, r_a);\n                 }\n             }\n         }\n     }\n \n+    // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n+    // (with the exception that `'static: 'x` is not notable)\n     fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n-        assert!(match *sub { ty::ReFree(_) | ty::ReStatic => true, _ => false });\n-        assert!(match *sup { ty::ReFree(_) | ty::ReStatic => true, _ => false });\n-        self.relation.add(sub, sup)\n+        if (is_free(sub) || *sub == ty::ReStatic) && is_free(sup) {\n+            self.relation.add(sub, sup)\n+        }\n     }\n \n     pub fn lub_free_regions<'a, 'gcx>(&self,\n                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       r_a: Region<'tcx>,\n                                       r_b: Region<'tcx>)\n                                       -> Region<'tcx> {\n-        assert!(match *r_a { ty::ReFree(_) => true, _ => false });\n-        assert!(match *r_b { ty::ReFree(_) => true, _ => false });\n+        assert!(is_free(r_a));\n+        assert!(is_free(r_b));\n         let result = if r_a == r_b { r_a } else {\n             match self.relation.postdom_upper_bound(&r_a, &r_b) {\n                 None => tcx.mk_region(ty::ReStatic),\n@@ -213,6 +201,13 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     }\n }\n \n+fn is_free(r: Region) -> bool {\n+    match *r {\n+        ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n+        _ => false\n+    }\n+}\n+\n impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n     relation\n });"}, {"sha": "917b21c865a506bce212744e538478d0257285b1", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -606,6 +606,33 @@ impl<'tcx> RegionMaps<'tcx> {\n         }\n     }\n \n+    /// Assuming that the provided region was defined within this `RegionMaps`,\n+    /// returns the outermost `CodeExtent` that the region outlives.\n+    pub fn early_free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       br: &ty::EarlyBoundRegion)\n+                                       -> CodeExtent<'tcx> {\n+        let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n+\n+        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n+        let body_id = tcx.hir.maybe_body_owned_by(param_owner_id).unwrap_or_else(|| {\n+            // The lifetime was defined on node that doesn't own a body,\n+            // which in practice can only mean a trait or an impl, that\n+            // is the parent of a method, and that is enforced below.\n+            assert_eq!(Some(param_owner_id), self.root_parent,\n+                       \"free_extent: {:?} not recognized by the region maps for {:?}\",\n+                       param_owner,\n+                       self.root_body.map(|body| tcx.hir.body_owner_def_id(body)));\n+\n+            // The trait/impl lifetime is in scope for the method's body.\n+            self.root_body.unwrap()\n+        });\n+\n+        tcx.intern_code_extent(CodeExtentData::CallSiteScope {\n+            fn_id: tcx.hir.body_owner(body_id),\n+            body_id: body_id.node_id\n+        })\n+    }\n+\n     /// Assuming that the provided region was defined within this `RegionMaps`,\n     /// returns the outermost `CodeExtent` that the region outlives.\n     pub fn free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n@@ -617,27 +644,12 @@ impl<'tcx> RegionMaps<'tcx> {\n             _ => fr.scope\n         };\n \n-        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let body_id = tcx.hir.maybe_body_owned_by(param_owner_id)\n-        .map(|body| {\n-            assert_eq!(param_owner, fr.scope);\n-            body\n-        })\n-        .unwrap_or_else(|| {\n-            let root = tcx.hir.as_local_node_id(fr.scope).unwrap();\n-\n-            assert_eq!(Some(param_owner_id), self.root_parent,\n-                       \"free_extent: {:?} not recognized by the region maps for {:?}\",\n-                       param_owner, fr.scope);\n-\n-            let root_body = tcx.hir.body_owned_by(root);\n+        // Ensure that the named late-bound lifetimes were defined\n+        // on the same function that they ended up being freed in.\n+        assert_eq!(param_owner, fr.scope);\n \n-            assert!(Some(root_body) == self.root_body,\n-                    \"free_extent: {:?} not inside {:?}\",\n-                    param_owner, self.root_body.map(|body| tcx.hir.body_owner_def_id(body)));\n-\n-            root_body\n-        });\n+        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n+        let body_id = tcx.hir.body_owned_by(param_owner_id);\n \n         tcx.intern_code_extent(CodeExtentData::CallSiteScope {\n             fn_id: tcx.hir.body_owner(body_id),"}, {"sha": "7d7308d73bb048a2b5ed81d8e1166d4606e1788b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -894,7 +894,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         if let Some(mut def) = result {\n-            if let Some(body_id) = outermost_body {\n+            if let Region::EarlyBound(..) = def {\n+                // Do not free early-bound regions, only late-bound ones.\n+            } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.hir_map.body_owner(body_id);\n                 match self.hir_map.get(fn_id) {\n                     hir::map::NodeItem(&hir::Item {"}, {"sha": "66e8e503be40ba462f79fccab07a76268bf8ccba", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -206,9 +206,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let free_substs = self.construct_free_substs(def_id);\n         let predicates = self.predicates_of(def_id);\n-        let predicates = predicates.instantiate(self, free_substs).predicates;\n+        let predicates = predicates.instantiate_identity(self).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n                 match predicate {"}, {"sha": "3882e218241646127edbc6be623c13062bc0699c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -180,9 +180,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n     let penv = tcx.parameter_environment(impl1_def_id);\n-    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n-                             .unwrap()\n-                             .subst(tcx, &penv.free_substs);\n+    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n     let result = tcx.infer_ctxt(penv, Reveal::UserFacing).enter(|infcx| {"}, {"sha": "3f5cf7eca53077bd48c8900e3093d33b3b9799b2", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -197,7 +197,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 // I want to be conservative. --nmatsakis\n                 let ty_max = data.skip_binder().0;\n                 let r_min = data.skip_binder().1;\n-                if r_min.is_bound() {\n+                if r_min.is_late_bound() {\n                     return;\n                 }\n \n@@ -206,7 +206,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                     tcx.outlives_components(ty_max)\n                        .into_iter()\n                        .filter_map(|component| match component {\n-                           Component::Region(r) => if r.is_bound() {\n+                           Component::Region(r) => if r.is_late_bound() {\n                                None\n                            } else {\n                                Some(ty::Predicate::RegionOutlives("}, {"sha": "bd38a6c3fd39a6edad843f3053b95fe8b4325ea4", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -1271,7 +1271,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         let param_env = tcx.parameter_environment(def.did);\n                         let fields = &def.variants[0].fields;\n                         let last_field = &fields[fields.len()-1];\n-                        let always_sized = last_field.ty(tcx, param_env.free_substs)\n+                        let always_sized = tcx.type_of(last_field.did)\n                           .is_sized(tcx, &param_env, DUMMY_SP);\n                         if !always_sized { StructKind::MaybeUnsizedUnivariant }\n                         else { StructKind::AlwaysSizedUnivariant }"}, {"sha": "51bd0b88bac4f600fe11a7c846b8eefa501b2f43", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -731,11 +731,18 @@ pub struct RegionParameterDef {\n impl RegionParameterDef {\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n         ty::EarlyBoundRegion {\n+            def_id: self.def_id,\n             index: self.index,\n             name: self.name,\n         }\n     }\n \n+    pub fn to_bound_region(&self) -> ty::BoundRegion {\n+        self.to_early_bound_region_data().to_bound_region()\n+    }\n+}\n+\n+impl ty::EarlyBoundRegion {\n     pub fn to_bound_region(&self) -> ty::BoundRegion {\n         ty::BoundRegion::BrNamed(self.def_id, self.name)\n     }\n@@ -815,6 +822,21 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n     }\n \n+    pub fn instantiate_identity(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                                -> InstantiatedPredicates<'tcx> {\n+        let mut instantiated = InstantiatedPredicates::empty();\n+        self.instantiate_identity_into(tcx, &mut instantiated);\n+        instantiated\n+    }\n+\n+    fn instantiate_identity_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                 instantiated: &mut InstantiatedPredicates<'tcx>) {\n+        if let Some(def_id) = self.parent {\n+            tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n+        }\n+        instantiated.predicates.extend(&self.predicates)\n+    }\n+\n     pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n@@ -1240,9 +1262,6 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// more distinctions clearer.\n #[derive(Clone)]\n pub struct ParameterEnvironment<'tcx> {\n-    /// See `construct_free_substs` for details.\n-    pub free_substs: &'tcx Substs<'tcx>,\n-\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n@@ -1264,7 +1283,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                               -> ParameterEnvironment<'tcx>\n     {\n         ParameterEnvironment {\n-            free_substs: self.free_substs,\n             caller_bounds: caller_bounds,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n@@ -2372,51 +2390,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n         ty::ParameterEnvironment {\n-            free_substs: self.intern_substs(&[]),\n             caller_bounds: Slice::empty(),\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n-    /// Constructs and returns a substitution that can be applied to move from\n-    /// the \"outer\" view of a type or method to the \"inner\" view.\n-    /// In general, this means converting from bound parameters to\n-    /// free parameters. Since we currently represent bound/free type\n-    /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(self, def_id: DefId) -> &'gcx Substs<'gcx> {\n-        let scope = self.closure_base_def_id(def_id);\n-        let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n-            // map bound 'a => free 'a\n-            self.global_tcx().mk_region(ReFree(FreeRegion {\n-                scope,\n-                bound_region: def.to_bound_region()\n-            }))\n-        }, |def, _| {\n-            // map T => T\n-            self.global_tcx().mk_param_from_def(def)\n-        });\n-\n-        debug!(\"parameter_environment: {:?}\", substs);\n-        substs\n-    }\n-\n     /// See `ParameterEnvironment` struct def'n for details.\n     pub fn parameter_environment(self, def_id: DefId) -> ParameterEnvironment<'gcx> {\n-        //\n-        // Construct the free substs.\n-        //\n-\n-        let free_substs = self.construct_free_substs(def_id);\n-\n         //\n         // Compute the bounds on Self and the type parameters.\n         //\n \n         let tcx = self.global_tcx();\n-        let generic_predicates = tcx.predicates_of(def_id);\n-        let bounds = generic_predicates.instantiate(tcx, free_substs);\n+        let bounds = tcx.predicates_of(def_id).instantiate_identity(tcx);\n         let predicates = bounds.predicates;\n \n         // Finally, we have to normalize the bounds in the environment, in\n@@ -2433,7 +2421,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let unnormalized_env = ty::ParameterEnvironment {\n-            free_substs,\n             caller_bounds: tcx.intern_predicates(&predicates),\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),"}, {"sha": "ab1b1b3857d0035c81695027d48a439a2cc86813", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region<'tcx>>) {\n     for r in regions {\n-        if !r.is_bound() {\n+        if !r.is_late_bound() {\n             out.push(Component::Region(r));\n         }\n     }"}, {"sha": "4faefc0fca94296b7dd74fb44cff2220cbb47b07", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -790,6 +790,7 @@ impl<'tcx> serialize::UseSpecializedDecodable for Region<'tcx> {}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n+    pub def_id: DefId,\n     pub index: u32,\n     pub name: Name,\n }\n@@ -906,9 +907,8 @@ impl DebruijnIndex {\n \n /// Region utilities\n impl<'tcx> RegionKind<'tcx> {\n-    pub fn is_bound(&self) -> bool {\n+    pub fn is_late_bound(&self) -> bool {\n         match *self {\n-            ty::ReEarlyBound(..) => true,\n             ty::ReLateBound(..) => true,\n             _ => false,\n         }"}, {"sha": "c6c6a0e47003dbb40777d056b2ade638c6259eb7", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -688,9 +688,8 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n                 self.hash(db.depth);\n                 self.hash(i);\n             }\n-            ty::ReEarlyBound(ty::EarlyBoundRegion { index, name }) => {\n-                self.hash(index);\n-                self.hash(name.as_str());\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, .. }) => {\n+                self.def_id(def_id);\n             }\n             ty::ReLateBound(..) |\n             ty::ReFree(..) |"}, {"sha": "27cc5faaf20b37ae80b303dbff2942cf8e50ac1d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -506,11 +506,7 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ParameterEnvironment(\\\n-            free_substs={:?}, \\\n-            caller_bounds={:?})\",\n-            self.free_substs,\n-            self.caller_bounds)\n+        write!(f, \"ParameterEnvironment({:?})\", self.caller_bounds)\n     }\n }\n "}, {"sha": "cbb6f7bce50f2431d4a6539f744bc08f1cb3b485", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -353,6 +353,10 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let loan_scope = match *loan_region {\n                     ty::ReScope(scope) => scope,\n \n+                    ty::ReEarlyBound(ref br) => {\n+                        self.bccx.region_maps.early_free_extent(self.tcx(), br)\n+                    }\n+\n                     ty::ReFree(ref fr) => {\n                         self.bccx.region_maps.free_extent(self.tcx(), fr)\n                     }\n@@ -361,7 +365,6 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n                     ty::ReEmpty |\n                     ty::ReLateBound(..) |\n-                    ty::ReEarlyBound(..) |\n                     ty::ReVar(..) |\n                     ty::ReSkolemized(..) |\n                     ty::ReErased => {"}, {"sha": "07fd966f5704b8f247713a05840e77516c62a635", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -513,6 +513,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match (&err.code, &err.cause) {\n             (&err_out_of_scope(&ty::ReScope(_), &ty::ReStatic, _),\n              &BorrowViolation(euv::ClosureCapture(span))) |\n+            (&err_out_of_scope(&ty::ReScope(_), &ty::ReEarlyBound(..), _),\n+             &BorrowViolation(euv::ClosureCapture(span))) |\n             (&err_out_of_scope(&ty::ReScope(_), &ty::ReFree(..), _),\n              &BorrowViolation(euv::ClosureCapture(span))) => {\n                 return self.report_out_of_scope_escaping_closure_capture(&err, span);"}, {"sha": "1de6749200f436cb81418a27a6e02d4747f5260f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -296,8 +296,9 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n         let name = Symbol::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            index: index,\n-            name: name,\n+            def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n+            index,\n+            name,\n         }))\n     }\n "}, {"sha": "6f4480bf6dd16d525bdb54dc8ba02a9f66b2ffa7", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty};\n-use rustc::ty::subst::{Kind, Subst};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -65,7 +65,6 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n             build_call_shim(\n                 tcx,\n-                &param_env,\n                 def_id,\n                 adjustment,\n                 CallKind::Indirect,\n@@ -77,7 +76,6 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             // trans::mir knows to turn to an actual virtual call.\n             build_call_shim(\n                 tcx,\n-                &param_env,\n                 def_id,\n                 Adjustment::Identity,\n                 CallKind::Direct(def_id),\n@@ -93,7 +91,6 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n             build_call_shim(\n                 tcx,\n-                &param_env,\n                 call_once,\n                 Adjustment::RefMut,\n                 CallKind::Direct(call_mut),\n@@ -157,7 +154,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     let substs = if let Some(ty) = ty {\n         tcx.mk_substs(iter::once(Kind::from(ty)))\n     } else {\n-        param_env.free_substs\n+        Substs::identity_for_item(tcx, def_id)\n     };\n     let fn_ty = tcx.type_of(def_id).subst(tcx, substs);\n     let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n@@ -271,7 +268,6 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n /// If `untuple_args` is a vec of types, the second argument of the\n /// function will be untupled as these types.\n fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-                             param_env: &ty::ParameterEnvironment<'tcx>,\n                              def_id: DefId,\n                              rcvr_adjustment: Adjustment,\n                              call_kind: CallKind,\n@@ -282,7 +278,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n \n-    let fn_ty = tcx.type_of(def_id).subst(tcx, param_env.free_substs);\n+    let fn_ty = tcx.type_of(def_id);\n     let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n     let span = tcx.def_span(def_id);\n \n@@ -324,9 +320,10 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         CallKind::Direct(def_id) => (\n             Operand::Constant(box Constant {\n                 span: span,\n-                ty: tcx.type_of(def_id).subst(tcx, param_env.free_substs),\n+                ty: tcx.type_of(def_id),\n                 literal: Literal::Value {\n-                    value: ConstVal::Function(def_id, param_env.free_substs),\n+                    value: ConstVal::Function(def_id,\n+                        Substs::identity_for_item(tcx, def_id)),\n                 },\n             }),\n             vec![rcvr]"}, {"sha": "9e8352fde80617f1d7fb084e66b5ba1811897a15", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -41,12 +41,6 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n \n-    /// Return an (optional) substitution to convert bound type parameters that\n-    /// are in scope into free ones. This function should only return Some\n-    /// within a fn body.\n-    /// See ParameterEnvironment::free_substs for more information.\n-    fn get_free_substs(&self) -> Option<&Substs<'tcx>>;\n-\n     /// What lifetime should we use when a lifetime is omitted (and not elided)?\n     fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n                 -> Option<ty::Region<'tcx>>;\n@@ -121,6 +115,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Some(&rl::Region::EarlyBound(index, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    def_id: tcx.hir.local_def_id(id),\n                     index: index,\n                     name: name\n                 }))\n@@ -857,12 +852,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     }\n                 };\n \n-                let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n-                    trait_ref.subst(tcx, free_substs)\n-                } else {\n-                    trait_ref\n-                };\n-\n                 let candidates =\n                     traits::supertraits(tcx, ty::Binder(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n@@ -1020,12 +1009,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_type_params(&path.segments);\n \n-                let ty = tcx.at(span).type_of(def_id);\n-                if let Some(free_substs) = self.get_free_substs() {\n-                    ty.subst(tcx, free_substs)\n-                } else {\n-                    ty\n-                }\n+                tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait."}, {"sha": "4c3d5c8aaca7fdffc54382d53bb5e65a59eb965c", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -15,6 +15,7 @@ use super::{check_fn, Expectation, FnCtxt};\n use astconv::AstConv;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n+use rustc::ty::subst::Substs;\n use std::cmp;\n use std::iter;\n use syntax::abi::Abi;\n@@ -67,8 +68,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n         // inference phase (`upvar.rs`).\n+        let base_substs = Substs::identity_for_item(self.tcx,\n+            self.tcx.closure_base_def_id(expr_def_id));\n         let closure_type = self.tcx.mk_closure(expr_def_id,\n-            self.parameter_environment.free_substs.extend_to(self.tcx, expr_def_id,\n+            base_substs.extend_to(self.tcx, expr_def_id,\n                 |_, _| span_bug!(expr.span, \"closure has region param\"),\n                 |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n             )"}, {"sha": "d9f77e8f04f1ccbfa595b19195f286a8a942b34a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -170,13 +170,12 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let impl_param_env = tcx.parameter_environment(impl_m.def_id);\n \n     // Create mapping from impl to skolemized.\n-    let impl_to_skol_substs = &impl_param_env.free_substs;\n+    let impl_to_skol_substs = Substs::identity_for_item(tcx, impl_m.def_id);\n \n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n                                                                impl_m.container.id(),\n-                                                               trait_to_impl_substs.subst(tcx,\n-                                                                          impl_to_skol_substs));\n+                                                               trait_to_impl_substs);\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n@@ -191,16 +190,15 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        impl_m,\n                                        &trait_m_generics,\n                                        &impl_m_generics,\n-                                       trait_to_skol_substs,\n-                                       impl_to_skol_substs)?;\n+                                       trait_to_skol_substs)?;\n \n     // Create obligations for each predicate declared by the impl\n     // definition in the context of the trait's parameter\n     // environment. We can't just use `impl_env.caller_bounds`,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n     let impl_predicates = tcx.predicates_of(impl_m_predicates.parent.unwrap());\n-    let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n+    let mut hybrid_preds = impl_predicates.instantiate_identity(tcx);\n \n     debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n \n@@ -273,8 +271,6 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                             infer::HigherRankedType,\n                                                             &m_sig(impl_m));\n-        let impl_sig =\n-            impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n@@ -370,21 +366,18 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 impl_m: &ty::AssociatedItem,\n                                                 trait_generics: &ty::Generics,\n                                                 impl_generics: &ty::Generics,\n-                                                trait_to_skol_substs: &Substs<'tcx>,\n-                                                impl_to_skol_substs: &Substs<'tcx>)\n+                                                trait_to_skol_substs: &Substs<'tcx>)\n                                                 -> Result<(), ErrorReported> {\n     let trait_params = &trait_generics.regions[..];\n     let impl_params = &impl_generics.regions[..];\n \n     debug!(\"check_region_bounds_on_impl_method: \\\n             trait_generics={:?} \\\n             impl_generics={:?} \\\n-            trait_to_skol_substs={:?} \\\n-            impl_to_skol_substs={:?}\",\n+            trait_to_skol_substs={:?}\",\n            trait_generics,\n            impl_generics,\n-           trait_to_skol_substs,\n-           impl_to_skol_substs);\n+           trait_to_skol_substs);\n \n     // Must have same number of early-bound lifetime parameters.\n     // Unfortunately, if the user screws up the bounds, then this\n@@ -739,22 +732,10 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Create a parameter environment that represents the implementation's\n         // method.\n         let impl_c_node_id = tcx.hir.as_local_node_id(impl_c.def_id).unwrap();\n-        let impl_param_env = tcx.parameter_environment(impl_c.def_id);\n-\n-        // Create mapping from impl to skolemized.\n-        let impl_to_skol_substs = &impl_param_env.free_substs;\n-\n-        // Create mapping from trait to skolemized.\n-        let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n-                                                                   impl_c.container.id(),\n-                                                                   trait_to_impl_substs.subst(tcx,\n-                                                                              impl_to_skol_substs));\n-        debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n-               trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n-        let impl_ty = tcx.type_of(impl_c.def_id).subst(tcx, impl_to_skol_substs);\n-        let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n+        let impl_ty = tcx.type_of(impl_c.def_id);\n+        let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_impl_substs);\n         let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n \n         // There is no \"body\" here, so just pass dummy id."}, {"sha": "8e3329e2720b166e419fc92462d9b50341555906", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -85,7 +85,6 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         let named_type = tcx.type_of(self_type_did);\n-        let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n         let fresh_impl_substs ="}, {"sha": "3755dfd3f40e5df13ff35d57469e6b0ab13f1f3f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -817,8 +817,6 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             check_abi(tcx, span, fn_sig.abi());\n \n             // Compute the fty from point of view of inside fn.\n-            let fn_sig =\n-                fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n             let fn_sig =\n                 inh.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n@@ -1555,10 +1553,6 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n-    fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n-        Some(&self.parameter_environment.free_substs)\n-    }\n-\n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n                                  -> ty::GenericPredicates<'tcx>\n     {"}, {"sha": "3da017642436e3cdfe1c7cb691f6df1b675a95a5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -397,9 +397,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             for implication in implied_bounds {\n                 debug!(\"implication: {:?}\", implication);\n                 match implication {\n-                    ImpliedBound::RegionSubRegion(&ty::ReFree(free_a),\n+                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_),\n+                                                  &ty::ReVar(vid_b)) |\n+                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReFree(_),\n                                                   &ty::ReVar(vid_b)) => {\n-                        self.add_given(free_a, vid_b);\n+                        self.add_given(r_a, vid_b);\n                     }\n                     ImpliedBound::RegionSubParam(r_a, param_b) => {\n                         self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n@@ -1664,7 +1666,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut regions = ty.regions();\n-        regions.retain(|r| !r.is_bound()); // ignore late-bound regions\n+        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n         bounds.push(VerifyBound::AllRegions(regions));\n \n         // remove bounds that must hold, since they are not interesting"}, {"sha": "6895d7386256247d96527d88fa6bb42902c5ea13", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -159,8 +159,6 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                              sig_if_method: Option<&hir::MethodSig>) {\n         let code = self.code.clone();\n         self.for_id(item_id, span).with_fcx(|fcx, this| {\n-            let free_substs = &fcx.parameter_environment.free_substs;\n-\n             let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n \n             let (mut implied_bounds, self_ty) = match item.container {\n@@ -172,14 +170,16 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             match item.kind {\n                 ty::AssociatedKind::Const => {\n                     let ty = fcx.tcx.type_of(item.def_id);\n-                    let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n+                    let ty = fcx.normalize_associated_types_in(span, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n                     let method_ty = fcx.tcx.type_of(item.def_id);\n-                    let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n-                    let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n+                    let method_ty = fcx.normalize_associated_types_in(span, &method_ty);\n+                    let predicates = fcx.tcx.predicates_of(item.def_id)\n+                        .instantiate_identity(fcx.tcx);\n+                    let predicates = fcx.normalize_associated_types_in(span, &predicates);\n                     let sig = method_ty.fn_sig();\n                     this.check_fn_or_method(fcx, span, sig, &predicates,\n                                             item.def_id, &mut implied_bounds);\n@@ -189,7 +189,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 ty::AssociatedKind::Type => {\n                     if item.defaultness.has_value() {\n                         let ty = fcx.tcx.type_of(item.def_id);\n-                        let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n+                        let ty = fcx.normalize_associated_types_in(span, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());\n                     }\n                 }\n@@ -239,9 +239,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n             }\n \n-            let free_substs = &fcx.parameter_environment.free_substs;\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n+            let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n+            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n             vec![] // no implied bounds in a struct def'n\n@@ -317,22 +317,22 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         }\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let free_substs = &fcx.parameter_environment.free_substs;\n-            let predicates = fcx.instantiate_bounds(item.span, trait_def_id, free_substs);\n+            let predicates = fcx.tcx.predicates_of(trait_def_id).instantiate_identity(fcx.tcx);\n+            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n             vec![]\n         });\n     }\n \n     fn check_item_fn(&mut self, item: &hir::Item) {\n         self.for_item(item).with_fcx(|fcx, this| {\n-            let free_substs = &fcx.parameter_environment.free_substs;\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n             let ty = fcx.tcx.type_of(def_id);\n-            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &ty);\n+            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n             let sig = item_ty.fn_sig();\n \n-            let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n+            let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n+            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n \n             let mut implied_bounds = vec![];\n             this.check_fn_or_method(fcx, item.span, sig, &predicates,\n@@ -348,10 +348,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         self.for_item(item).with_fcx(|fcx, this| {\n             let ty = fcx.tcx.type_of(fcx.tcx.hir.local_def_id(item.id));\n-            let item_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.parameter_environment\n-                                                          .free_substs,\n-                                                      &ty);\n+            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n \n             fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n \n@@ -367,15 +364,14 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         debug!(\"check_impl: {:?}\", item);\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let free_substs = &fcx.parameter_environment.free_substs;\n             let item_def_id = fcx.tcx.hir.local_def_id(item.id);\n \n             match *ast_trait_ref {\n                 Some(ref ast_trait_ref) => {\n                     let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n                     let trait_ref =\n-                        fcx.instantiate_type_scheme(\n-                            ast_trait_ref.path.span, free_substs, &trait_ref);\n+                        fcx.normalize_associated_types_in(\n+                            ast_trait_ref.path.span, &trait_ref);\n                     let obligations =\n                         ty::wf::trait_obligations(fcx,\n                                                   fcx.body_id,\n@@ -387,12 +383,13 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n                 None => {\n                     let self_ty = fcx.tcx.type_of(item_def_id);\n-                    let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n+                    let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n             }\n \n-            let predicates = fcx.instantiate_bounds(item.span, item_def_id, free_substs);\n+            let predicates = fcx.tcx.predicates_of(item_def_id).instantiate_identity(fcx.tcx);\n+            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n             fcx.impl_implied_bounds(item_def_id, item.span)\n@@ -425,8 +422,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       def_id: DefId,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n-        let free_substs = &fcx.parameter_environment.free_substs;\n-        let sig = fcx.instantiate_type_scheme(span, free_substs, &sig);\n+        let sig = fcx.normalize_associated_types_in(span, &sig);\n         let sig = fcx.liberate_late_bound_regions(def_id, &sig);\n \n         for input_ty in sig.inputs() {\n@@ -459,9 +455,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         let span = method_sig.decl.inputs[0].span;\n \n-        let free_substs = &fcx.parameter_environment.free_substs;\n         let method_ty = fcx.tcx.type_of(method.def_id);\n-        let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n+        let fty = fcx.normalize_associated_types_in(span, &method_ty);\n         let sig = fcx.liberate_late_bound_regions(method.def_id, &fty.fn_sig());\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n@@ -477,7 +472,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             }\n             ExplicitSelf::ByBox => fcx.tcx.mk_box(self_ty)\n         };\n-        let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n+        let rcvr_ty = fcx.normalize_associated_types_in(span, &rcvr_ty);\n         let rcvr_ty = fcx.liberate_late_bound_regions(method.def_id,\n                                                       &ty::Binder(rcvr_ty));\n \n@@ -624,10 +619,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             struct_def.fields().iter()\n             .map(|field| {\n                 let field_ty = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n-                let field_ty = self.instantiate_type_scheme(field.span,\n-                                                            &self.parameter_environment\n-                                                                 .free_substs,\n-                                                            &field_ty);\n+                let field_ty = self.normalize_associated_types_in(field.span,\n+                                                                  &field_ty);\n                 AdtField { ty: field_ty, span: field.span }\n             })\n             .collect();\n@@ -641,19 +634,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n-        let free_substs = &self.parameter_environment.free_substs;\n         match self.tcx.impl_trait_ref(impl_def_id) {\n             Some(ref trait_ref) => {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n-                let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n+                let trait_ref = self.normalize_associated_types_in(span, trait_ref);\n                 trait_ref.substs.types().collect()\n             }\n \n             None => {\n                 // Inherent impl: take implied bounds from the self type.\n                 let self_ty = self.tcx.type_of(impl_def_id);\n-                let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n+                let self_ty = self.normalize_associated_types_in(span, &self_ty);\n                 vec![self_ty]\n             }\n         }"}, {"sha": "b43e2423757d1faef9df751445363881339760d5", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 52, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -19,7 +19,7 @@ use rustc::infer::{InferCtxt};\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n-use rustc::util::nodemap::{DefIdMap, DefIdSet};\n+use rustc::util::nodemap::DefIdSet;\n use syntax::ast;\n use syntax_pos::Span;\n use std::mem;\n@@ -71,55 +71,17 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n \n     tables: ty::TypeckTables<'gcx>,\n \n-    // Mapping from free regions of the function to the\n-    // early-bound versions of them, visible from the\n-    // outside of the function. This is needed by, and\n-    // only populated if there are any `impl Trait`.\n-    free_to_bound_regions: DefIdMap<ty::Region<'gcx>>,\n-\n     body: &'gcx hir::Body,\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, body: &'gcx hir::Body)\n         -> WritebackCx<'cx, 'gcx, 'tcx> {\n-        let mut wbcx = WritebackCx {\n+        WritebackCx {\n             fcx: fcx,\n             tables: ty::TypeckTables::empty(),\n-            free_to_bound_regions: DefIdMap(),\n             body: body\n-        };\n-\n-        // Only build the reverse mapping if `impl Trait` is used.\n-        if fcx.anon_types.borrow().is_empty() {\n-            return wbcx;\n         }\n-\n-        let gcx = fcx.tcx.global_tcx();\n-        let free_substs = fcx.parameter_environment.free_substs;\n-        for (i, k) in free_substs.iter().enumerate() {\n-            let r = if let Some(r) = k.as_region() {\n-                r\n-            } else {\n-                continue;\n-            };\n-            match *r {\n-                ty::ReFree(ty::FreeRegion {\n-                    bound_region: ty::BoundRegion::BrNamed(def_id, name), ..\n-                }) => {\n-                    let bound_region = gcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        index: i as u32,\n-                        name: name,\n-                    }));\n-                    wbcx.free_to_bound_regions.insert(def_id, bound_region);\n-                }\n-                _ => {\n-                    bug!(\"{:?} is not a free region for an early-bound lifetime\", r);\n-                }\n-            }\n-        }\n-\n-        wbcx\n     }\n \n     fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n@@ -285,22 +247,16 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             let inside_ty = self.resolve(&concrete_ty, &node_id);\n \n             // Convert the type from the function into a type valid outside\n-            // the function, by replacing free regions with early-bound ones.\n+            // the function, by replacing invalid regions with 'static,\n+            // after producing an error for each of them.\n             let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n                 match *r {\n-                    // 'static is valid everywhere.\n-                    ty::ReStatic => gcx.types.re_static,\n-                    ty::ReEmpty => gcx.types.re_empty,\n-\n-                    // Free regions that come from early-bound regions are valid.\n-                    ty::ReFree(ty::FreeRegion {\n-                        bound_region: ty::BoundRegion::BrNamed(def_id, ..), ..\n-                    }) if self.free_to_bound_regions.contains_key(&def_id) => {\n-                        self.free_to_bound_regions[&def_id]\n-                    }\n+                    // 'static and early-bound regions are valid.\n+                    ty::ReStatic |\n+                    ty::ReEarlyBound(_) |\n+                    ty::ReEmpty => r,\n \n                     ty::ReFree(_) |\n-                    ty::ReEarlyBound(_) |\n                     ty::ReLateBound(..) |\n                     ty::ReScope(_) |\n                     ty::ReSkolemized(..) => {"}, {"sha": "d40a68e605690d880e34c4bd24a73dafd7004ff1", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -19,7 +19,6 @@ use rustc::traits::{self, ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::TypeFoldable;\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n-use rustc::ty::subst::Subst;\n use rustc::ty::util::CopyImplementationError;\n use rustc::infer;\n \n@@ -107,7 +106,6 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let span = tcx.hir.span(impl_node_id);\n     let param_env = tcx.parameter_environment(impl_did);\n-    let self_type = self_type.subst(tcx, &param_env.free_substs);\n     assert!(!self_type.has_escaping_regions());\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n@@ -202,8 +200,6 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let span = tcx.hir.span(impl_node_id);\n     let param_env = tcx.parameter_environment(impl_did);\n-    let source = source.subst(tcx, &param_env.free_substs);\n-    let target = target.subst(tcx, &param_env.free_substs);\n     assert!(!source.has_escaping_regions());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };"}, {"sha": "7c6c70024ce9e2453131fa7c4856e16e33e6fd09", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -205,10 +205,6 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         self.tcx.at(span).type_param_predicates((self.item_def_id, def_id))\n     }\n \n-    fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n-        None\n-    }\n-\n     fn re_infer(&self, _span: Span, _def: Option<&ty::RegionParameterDef>)\n                 -> Option<ty::Region<'tcx>> {\n         None\n@@ -1299,6 +1295,7 @@ fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            def_id: tcx.hir.local_def_id(param.lifetime.id),\n             index: index,\n             name: param.lifetime.name\n         }));"}, {"sha": "22e7de3838dc153a89f3bde569ef2ebcb45eb2c6", "filename": "src/test/compile-fail/issue-27942.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Ftest%2Fcompile-fail%2Fissue-27942.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Ftest%2Fcompile-fail%2Fissue-27942.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27942.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -11,17 +11,18 @@\n pub trait Resources<'a> {}\n \n pub trait Buffer<'a, R: Resources<'a>> {\n+    //~^ NOTE the lifetime 'a as defined on the trait at 13:0...\n+    //~| NOTE ...does not necessarily outlive the lifetime 'a as defined on the trait\n+\n     fn select(&self) -> BufferViewHandle<R>;\n     //~^ ERROR mismatched types\n     //~| lifetime mismatch\n     //~| NOTE expected type `Resources<'_>`\n-    //~| NOTE the lifetime 'a as defined on the method body at 14:4...\n     //~| NOTE ...does not necessarily outlive the anonymous lifetime #1 defined on the method body\n     //~| ERROR mismatched types\n     //~| lifetime mismatch\n     //~| NOTE expected type `Resources<'_>`\n-    //~| NOTE the anonymous lifetime #1 defined on the method body at 14:4...\n-    //~| NOTE ...does not necessarily outlive the lifetime 'a as defined on the method body\n+    //~| NOTE the anonymous lifetime #1 defined on the method body at 17:4...\n }\n \n pub struct BufferViewHandle<'a, R: 'a+Resources<'a>>(&'a R);"}, {"sha": "6313293bf2b6aae8e42fdcb9ba8cadb45c71e2a7", "filename": "src/test/compile-fail/issue-37884.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da080e779b4e6f4359c031824c3bdcedad452fd/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs?ref=2da080e779b4e6f4359c031824c3bdcedad452fd", "patch": "@@ -11,13 +11,14 @@\n struct RepeatMut<'a, T>(T, &'a ());\n \n impl<'a, T: 'a> Iterator for RepeatMut<'a, T> {\n+    //~^ NOTE ...does not necessarily outlive the lifetime 'a as defined on the impl\n+\n     type Item = &'a mut T;\n     fn next(&'a mut self) -> Option<Self::Item>\n     //~^ ERROR method not compatible with trait\n     //~| lifetime mismatch\n     //~| NOTE expected type `fn(&mut RepeatMut<'a, T>) -> std::option::Option<&mut T>`\n     //~| NOTE the anonymous lifetime #1 defined on the method body\n-    //~| NOTE ...does not necessarily outlive the lifetime 'a as defined on the method body\n     {\n         Some(&mut self.0)\n     }"}]}