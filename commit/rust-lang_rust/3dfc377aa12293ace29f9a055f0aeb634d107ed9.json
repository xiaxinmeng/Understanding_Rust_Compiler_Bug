{"sha": "3dfc377aa12293ace29f9a055f0aeb634d107ed9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZmMzNzdhYTEyMjkzYWNlMjlmOWEwNTVmMGFlYjYzNGQxMDdlZDk=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-10-15T01:07:57Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-13T21:38:27Z"}, "message": "move sendfile/splice/copy_file_range into kernel_copy module", "tree": {"sha": "166de453a36d983b1c0408e40470481b69eb8f66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/166de453a36d983b1c0408e40470481b69eb8f66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dfc377aa12293ace29f9a055f0aeb634d107ed9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dfc377aa12293ace29f9a055f0aeb634d107ed9", "html_url": "https://github.com/rust-lang/rust/commit/3dfc377aa12293ace29f9a055f0aeb634d107ed9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dfc377aa12293ace29f9a055f0aeb634d107ed9/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "888b1031bc267132c66dbba49b43a55a83452ca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/888b1031bc267132c66dbba49b43a55a83452ca4", "html_url": "https://github.com/rust-lang/rust/commit/888b1031bc267132c66dbba49b43a55a83452ca4"}], "stats": {"total": 303, "additions": 150, "deletions": 153}, "files": [{"sha": "8da2c7f13df14ff3f91c28d42bc9c36ea2993e4d", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 149, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/3dfc377aa12293ace29f9a055f0aeb634d107ed9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dfc377aa12293ace29f9a055f0aeb634d107ed9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=3dfc377aa12293ace29f9a055f0aeb634d107ed9", "patch": "@@ -1195,6 +1195,8 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     let max_len = u64::MAX;\n     let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n \n+    use super::kernel_copy::{copy_regular_files, CopyResult};\n+\n     match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n         CopyResult::Ended(result) => result,\n         CopyResult::Fallback(written) => {\n@@ -1206,155 +1208,6 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     }\n }\n \n-/// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n-/// as the name says, it only works on regular files\n-///\n-/// Callers must handle fallback to a generic copy loop.\n-/// `Fallback` may indicate non-zero number of bytes already written\n-/// if one of the files' cursor +`max_len` would exceed u64::MAX (`EOVERFLOW`).\n-/// If the initial file offset was 0 then `Fallback` will only contain `0`.\n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n-    use crate::cmp;\n-    use crate::sync::atomic::{AtomicBool, Ordering};\n-\n-    // Kernel prior to 4.5 don't have copy_file_range\n-    // We store the availability in a global to avoid unnecessary syscalls\n-    static HAS_COPY_FILE_RANGE: AtomicBool = AtomicBool::new(true);\n-\n-    unsafe fn copy_file_range(\n-        fd_in: libc::c_int,\n-        off_in: *mut libc::loff_t,\n-        fd_out: libc::c_int,\n-        off_out: *mut libc::loff_t,\n-        len: libc::size_t,\n-        flags: libc::c_uint,\n-    ) -> libc::c_long {\n-        libc::syscall(libc::SYS_copy_file_range, fd_in, off_in, fd_out, off_out, len, flags)\n-    }\n-\n-    let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n-    let mut written = 0u64;\n-    while written < max_len {\n-        let copy_result = if has_copy_file_range {\n-            let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n-            // cap to 2GB chunks in case u64::MAX is passed in as file size and the file has a non-zero offset\n-            // this allows us to copy large chunks without hitting the limit,\n-            // unless someone sets a file offset close to u64::MAX - 2GB, in which case the fallback would kick in\n-            let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x8000_0000usize);\n-            let copy_result = unsafe {\n-                // We actually don't have to adjust the offsets,\n-                // because copy_file_range adjusts the file offset automatically\n-                cvt(copy_file_range(\n-                    reader,\n-                    ptr::null_mut(),\n-                    writer,\n-                    ptr::null_mut(),\n-                    bytes_to_copy,\n-                    0,\n-                ))\n-            };\n-            if let Err(ref copy_err) = copy_result {\n-                match copy_err.raw_os_error() {\n-                    Some(libc::ENOSYS | libc::EPERM | libc::EOPNOTSUPP) => {\n-                        HAS_COPY_FILE_RANGE.store(false, Ordering::Relaxed);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            copy_result\n-        } else {\n-            Err(io::Error::from_raw_os_error(libc::ENOSYS))\n-        };\n-        match copy_result {\n-            Ok(0) if written == 0 => {\n-                // fallback to work around several kernel bugs where copy_file_range will fail to\n-                // copy any bytes and return 0 instead of an error if\n-                // - reading virtual files from the proc filesystem which appear to have 0 size\n-                //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n-                // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n-                return CopyResult::Fallback(0);\n-            }\n-            Ok(0) => return CopyResult::Ended(Ok(written)), // reached EOF\n-            Ok(ret) => written += ret as u64,\n-            Err(err) => {\n-                match err.raw_os_error() {\n-                    // when file offset + max_length > u64::MAX\n-                    Some(libc::EOVERFLOW) => return CopyResult::Fallback(written),\n-                    Some(\n-                        libc::ENOSYS | libc::EXDEV | libc::EINVAL | libc::EPERM | libc::EOPNOTSUPP,\n-                    ) => {\n-                        // Try fallback io::copy if either:\n-                        // - Kernel version is < 4.5 (ENOSYS)\n-                        // - Files are mounted on different fs (EXDEV)\n-                        // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n-                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n-                        // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n-                        assert_eq!(written, 0);\n-                        return CopyResult::Fallback(0);\n-                    }\n-                    _ => return CopyResult::Ended(Err(err)),\n-                }\n-            }\n-        }\n-    }\n-    CopyResult::Ended(Ok(written))\n-}\n-\n-#[derive(PartialEq)]\n-pub(super) enum SpliceMode {\n-    Sendfile,\n-    Splice,\n-}\n-\n-pub(super) enum CopyResult {\n-    Ended(io::Result<u64>),\n-    Fallback(u64),\n-}\n-\n-/// performs splice or sendfile between file descriptors\n-/// Does _not_ fall back to a generic copy loop.\n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub(super) fn sendfile_splice(\n-    mode: SpliceMode,\n-    reader: RawFd,\n-    writer: RawFd,\n-    len: u64,\n-) -> CopyResult {\n-    let mut written = 0u64;\n-    while written < len {\n-        let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n-\n-        let result = match mode {\n-            SpliceMode::Sendfile => {\n-                cvt(unsafe { libc::sendfile(writer, reader, ptr::null_mut(), chunk_size) })\n-            }\n-            SpliceMode::Splice => cvt(unsafe {\n-                libc::splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n-            }),\n-        };\n-\n-        match result {\n-            Ok(0) => break, // EOF\n-            Ok(ret) => written += ret as u64,\n-            Err(err) => {\n-                match err.raw_os_error() {\n-                    Some(os_err) if os_err == libc::EINVAL => {\n-                        // splice/sendfile do not support this particular file descritor (EINVAL)\n-                        assert_eq!(written, 0);\n-                        return CopyResult::Fallback(0);\n-                    }\n-                    Some(os_err) if mode == SpliceMode::Sendfile && os_err == libc::EOVERFLOW => {\n-                        return CopyResult::Fallback(written);\n-                    }\n-                    _ => return CopyResult::Ended(Err(err)),\n-                }\n-            }\n-        }\n-    }\n-    CopyResult::Ended(Ok(written))\n-}\n-\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::sync::atomic::{AtomicBool, Ordering};"}, {"sha": "6d4dcc30b45f588df01b86769a3a6fced752a861", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 146, "deletions": 2, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/3dfc377aa12293ace29f9a055f0aeb634d107ed9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dfc377aa12293ace29f9a055f0aeb634d107ed9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=3dfc377aa12293ace29f9a055f0aeb634d107ed9", "patch": "@@ -49,14 +49,16 @@ use crate::convert::TryInto;\n use crate::fs::{File, Metadata};\n use crate::io::copy::generic_copy;\n use crate::io::{\n-    BufRead, BufReader, BufWriter, Read, Result, StderrLock, StdinLock, StdoutLock, Take, Write,\n+    BufRead, BufReader, BufWriter, Error, Read, Result, StderrLock, StdinLock, StdoutLock, Take,\n+    Write,\n };\n use crate::mem::ManuallyDrop;\n use crate::net::TcpStream;\n use crate::os::unix::fs::FileTypeExt;\n use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n-use crate::sys::fs::{copy_regular_files, sendfile_splice, CopyResult, SpliceMode};\n+use crate::ptr;\n+use crate::sys::cvt;\n \n #[cfg(test)]\n mod tests;\n@@ -423,3 +425,145 @@ fn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n         Err(_) => FdMeta::NoneObtained,\n     }\n }\n+\n+pub(super) enum CopyResult {\n+    Ended(Result<u64>),\n+    Fallback(u64),\n+}\n+\n+/// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n+/// as the name says, it only works on regular files\n+///\n+/// Callers must handle fallback to a generic copy loop.\n+/// `Fallback` may indicate non-zero number of bytes already written\n+/// if one of the files' cursor +`max_len` would exceed u64::MAX (`EOVERFLOW`).\n+/// If the initial file offset was 0 then `Fallback` will only contain `0`.\n+pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n+    use crate::cmp;\n+    use crate::sync::atomic::{AtomicBool, Ordering};\n+\n+    // Kernel prior to 4.5 don't have copy_file_range\n+    // We store the availability in a global to avoid unnecessary syscalls\n+    static HAS_COPY_FILE_RANGE: AtomicBool = AtomicBool::new(true);\n+\n+    unsafe fn copy_file_range(\n+        fd_in: libc::c_int,\n+        off_in: *mut libc::loff_t,\n+        fd_out: libc::c_int,\n+        off_out: *mut libc::loff_t,\n+        len: libc::size_t,\n+        flags: libc::c_uint,\n+    ) -> libc::c_long {\n+        libc::syscall(libc::SYS_copy_file_range, fd_in, off_in, fd_out, off_out, len, flags)\n+    }\n+\n+    let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n+    let mut written = 0u64;\n+    while written < max_len {\n+        let copy_result = if has_copy_file_range {\n+            let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n+            // cap to 2GB chunks in case u64::MAX is passed in as file size and the file has a non-zero offset\n+            // this allows us to copy large chunks without hitting the limit,\n+            // unless someone sets a file offset close to u64::MAX - 2GB, in which case the fallback would kick in\n+            let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x8000_0000usize);\n+            let copy_result = unsafe {\n+                // We actually don't have to adjust the offsets,\n+                // because copy_file_range adjusts the file offset automatically\n+                cvt(copy_file_range(\n+                    reader,\n+                    ptr::null_mut(),\n+                    writer,\n+                    ptr::null_mut(),\n+                    bytes_to_copy,\n+                    0,\n+                ))\n+            };\n+            if let Err(ref copy_err) = copy_result {\n+                match copy_err.raw_os_error() {\n+                    Some(libc::ENOSYS | libc::EPERM | libc::EOPNOTSUPP) => {\n+                        HAS_COPY_FILE_RANGE.store(false, Ordering::Relaxed);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            copy_result\n+        } else {\n+            Err(Error::from_raw_os_error(libc::ENOSYS))\n+        };\n+        match copy_result {\n+            Ok(0) if written == 0 => {\n+                // fallback to work around several kernel bugs where copy_file_range will fail to\n+                // copy any bytes and return 0 instead of an error if\n+                // - reading virtual files from the proc filesystem which appear to have 0 size\n+                //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n+                // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n+                return CopyResult::Fallback(0);\n+            }\n+            Ok(0) => return CopyResult::Ended(Ok(written)), // reached EOF\n+            Ok(ret) => written += ret as u64,\n+            Err(err) => {\n+                return match err.raw_os_error() {\n+                    // when file offset + max_length > u64::MAX\n+                    Some(libc::EOVERFLOW) => CopyResult::Fallback(written),\n+                    Some(\n+                        libc::ENOSYS | libc::EXDEV | libc::EINVAL | libc::EPERM | libc::EOPNOTSUPP,\n+                    ) => {\n+                        // Try fallback io::copy if either:\n+                        // - Kernel version is < 4.5 (ENOSYS)\n+                        // - Files are mounted on different fs (EXDEV)\n+                        // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n+                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n+                        // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n+                        assert_eq!(written, 0);\n+                        CopyResult::Fallback(0)\n+                    }\n+                    _ => CopyResult::Ended(Err(err)),\n+                };\n+            }\n+        }\n+    }\n+    CopyResult::Ended(Ok(written))\n+}\n+\n+#[derive(PartialEq)]\n+enum SpliceMode {\n+    Sendfile,\n+    Splice,\n+}\n+\n+/// performs splice or sendfile between file descriptors\n+/// Does _not_ fall back to a generic copy loop.\n+fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) -> CopyResult {\n+    let mut written = 0u64;\n+    while written < len {\n+        let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n+\n+        let result = match mode {\n+            SpliceMode::Sendfile => {\n+                cvt(unsafe { libc::sendfile(writer, reader, ptr::null_mut(), chunk_size) })\n+            }\n+            SpliceMode::Splice => cvt(unsafe {\n+                libc::splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n+            }),\n+        };\n+\n+        match result {\n+            Ok(0) => break, // EOF\n+            Ok(ret) => written += ret as u64,\n+            Err(err) => {\n+                return match err.raw_os_error() {\n+                    Some(os_err) if os_err == libc::EINVAL => {\n+                        // splice/sendfile do not support this particular file descritor (EINVAL)\n+                        assert_eq!(written, 0);\n+                        CopyResult::Fallback(0)\n+                    }\n+                    Some(os_err) if mode == SpliceMode::Sendfile && os_err == libc::EOVERFLOW => {\n+                        CopyResult::Fallback(written)\n+                    }\n+                    _ => CopyResult::Ended(Err(err)),\n+                };\n+            }\n+        }\n+    }\n+    CopyResult::Ended(Ok(written))\n+}"}, {"sha": "889216924534c1e576e74fad1ec97b72b83c8859", "filename": "library/std/src/sys/unix/kernel_copy/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dfc377aa12293ace29f9a055f0aeb634d107ed9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dfc377aa12293ace29f9a055f0aeb634d107ed9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs?ref=3dfc377aa12293ace29f9a055f0aeb634d107ed9", "patch": "@@ -159,8 +159,8 @@ fn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n     let local_source = local_end.clone();\n     crate::thread::spawn(move || {\n         loop {\n-            crate::sys::fs::sendfile_splice(\n-                crate::sys::fs::SpliceMode::Splice,\n+            super::sendfile_splice(\n+                super::SpliceMode::Splice,\n                 local_source.as_raw_fd(),\n                 write_end.as_raw_fd(),\n                 u64::MAX,"}]}