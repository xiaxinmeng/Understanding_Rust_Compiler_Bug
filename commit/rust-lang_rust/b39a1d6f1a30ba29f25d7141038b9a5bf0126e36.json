{"sha": "b39a1d6f1a30ba29f25d7141038b9a5bf0126e36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzOWExZDZmMWEzMGJhMjlmMjVkNzE0MTAzOGI5YTViZjAxMjZlMzY=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-05-30T17:33:43Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-05-30T17:36:23Z"}, "message": "Run rustfmt", "tree": {"sha": "158a3ce450a02f9f9122fff3b01d4835e3eb8484", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/158a3ce450a02f9f9122fff3b01d4835e3eb8484"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAlsO4RcACgkQiMlBzaHU\nZDKbtQ/+IhgFPfCOWceF54FzfLd0WKNy02WBsLMUdv1Ds+ecuxbjutYHadQHCrp2\n1wFBOTcpVtydWrCu8CVmmY01aj/AgMmI0YIh6seTxE40XEuiUs2s+IDpwQGE7Ysh\nHQSayRIwME4FfA0MDu3fTfOINnujqtk0amXmblqkr63xN9inVQf0xnlCmNfh6/01\nnzAJ5pL0uXcu3QXPrHIkJxG7VYJ/L4U0PQ96IsBNWGbBItxo8W8Q2E0CW0QJDGHx\n1aQCytCyhqM4iCxMj5VZFeznx/7dIsw2/q1cBUXG3Apjehrt5uJucFbUSTPWYU28\n1EF+Ceet+5ZWkK2s1x2d4PC/5FdulLWuZBRgh6avyKMb1WLt0uzZU0hTtOVIDzDp\nXJlvFceBeM3lLv7BZv8XwV8RjC49ecLGN6eBaRb8uFQCxcqvxPSUp3Zkij0tGMSS\nAY070+UVHPE6qEj8ImsHZi05qCMwEhQHIWBZDRVpacD6RHvvPX0F2U8VfjxjxtcV\nUZGztTquwvkW7UI6EtXGffSVtP6eCPSHBaIMlFC9Z53YyE+b5z+3YNByh/fSHC8G\nArSL1H3jsFDCjV570WvCOJvs+8t0hBNGKg7i5e4647V94wS5oPUQp8uI+v6JmHuA\nZIcme+LqksKuMns9Bs3QBOZtFp/oeoaVyZfz66ujp+OID+6goH0=\n=5IHK\n-----END PGP SIGNATURE-----", "payload": "tree 158a3ce450a02f9f9122fff3b01d4835e3eb8484\nparent b970feedc272f324a27103b39d5d0b67646d10f0\nauthor Santiago Pastorino <spastorino@gmail.com> 1527701623 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1527701783 -0300\n\nRun rustfmt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36", "html_url": "https://github.com/rust-lang/rust/commit/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b970feedc272f324a27103b39d5d0b67646d10f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b970feedc272f324a27103b39d5d0b67646d10f0", "html_url": "https://github.com/rust-lang/rust/commit/b970feedc272f324a27103b39d5d0b67646d10f0"}], "stats": {"total": 1989, "additions": 1206, "deletions": 783}, "files": [{"sha": "4fdb36b3f6e959431c6553023c6910e85f0bcb5d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 756, "deletions": 490, "changes": 1246, "blob_url": "https://github.com/rust-lang/rust/blob/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b39a1d6f1a30ba29f25d7141038b9a5bf0126e36", "patch": "@@ -11,33 +11,33 @@\n use std::any::Any;\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n+use std::collections::HashMap;\n use std::env;\n use std::fmt::Debug;\n use std::fs;\n use std::hash::Hash;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::time::{Instant, Duration};\n-use std::collections::HashMap;\n+use std::time::{Duration, Instant};\n \n+use cache::{Cache, Interned, INTERNER};\n+use check;\n use compile;\n-use install;\n use dist;\n-use util::{exe, libdir, add_lib_path};\n-use {Build, Mode, DocTests};\n-use cache::{INTERNER, Interned, Cache};\n-use check;\n-use test;\n-use flags::Subcommand;\n use doc;\n-use tool;\n+use flags::Subcommand;\n+use install;\n use native;\n+use test;\n+use tool;\n+use util::{add_lib_path, exe, libdir};\n+use {Build, DocTests, Mode};\n \n pub use Compiler;\n \n-use petgraph::Graph;\n use petgraph::graph::NodeIndex;\n+use petgraph::Graph;\n \n pub struct Builder<'a> {\n     pub build: &'a Build,\n@@ -112,8 +112,8 @@ struct StepDescription {\n \n #[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n pub enum PathSet {\n-    Set (BTreeSet<PathBuf>),\n-    Suite (PathBuf)\n+    Set(BTreeSet<PathBuf>),\n+    Suite(PathBuf),\n }\n \n impl PathSet {\n@@ -130,14 +130,18 @@ impl PathSet {\n     fn has(&self, needle: &Path) -> bool {\n         match self {\n             PathSet::Set(set) => set.iter().any(|p| p.ends_with(needle)),\n-            PathSet::Suite(_) => false\n+            PathSet::Suite(_) => false,\n         }\n     }\n \n     fn path(&self, builder: &Builder) -> PathBuf {\n         match self {\n-            PathSet::Set(set) => set.iter().next().unwrap_or(&builder.build.src).to_path_buf(),\n-            PathSet::Suite(path) => PathBuf::from(path)\n+            PathSet::Set(set) => set\n+                .iter()\n+                .next()\n+                .unwrap_or(&builder.build.src)\n+                .to_path_buf(),\n+            PathSet::Suite(path) => PathBuf::from(path),\n         }\n     }\n }\n@@ -158,8 +162,10 @@ impl StepDescription {\n             eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n             return;\n         } else if !builder.config.exclude.is_empty() {\n-            eprintln!(\"{:?} not skipped for {:?} -- not in {:?}\", pathset,\n-                self.name, builder.config.exclude);\n+            eprintln!(\n+                \"{:?} not skipped for {:?} -- not in {:?}\",\n+                pathset, self.name, builder.config.exclude\n+            );\n         }\n         let hosts = &builder.hosts;\n \n@@ -188,14 +194,18 @@ impl StepDescription {\n     }\n \n     fn run(v: &[StepDescription], builder: &Builder, paths: &[PathBuf]) {\n-        let should_runs = v.iter().map(|desc| {\n-            (desc.should_run)(ShouldRun::new(builder))\n-        }).collect::<Vec<_>>();\n+        let should_runs = v\n+            .iter()\n+            .map(|desc| (desc.should_run)(ShouldRun::new(builder)))\n+            .collect::<Vec<_>>();\n \n         // sanity checks on rules\n         for (desc, should_run) in v.iter().zip(&should_runs) {\n-            assert!(!should_run.paths.is_empty(),\n-                \"{:?} should have at least one pathset\", desc.name);\n+            assert!(\n+                !should_run.paths.is_empty(),\n+                \"{:?} should have at least one pathset\",\n+                desc.name\n+            );\n         }\n \n         if paths.is_empty() {\n@@ -278,16 +288,15 @@ impl<'a> ShouldRun<'a> {\n \n     // multiple aliases for the same job\n     pub fn paths(mut self, paths: &[&str]) -> Self {\n-        self.paths.insert(PathSet::Set(paths.iter().map(PathBuf::from).collect()));\n+        self.paths\n+            .insert(PathSet::Set(paths.iter().map(PathBuf::from).collect()));\n         self\n     }\n \n     pub fn is_suite_path(&self, path: &Path) -> Option<&PathSet> {\n-        self.paths.iter().find(|pathset| {\n-            match pathset {\n-                PathSet::Suite(p) => path.starts_with(p),\n-                PathSet::Set(_) => false\n-            }\n+        self.paths.iter().find(|pathset| match pathset {\n+            PathSet::Suite(p) => path.starts_with(p),\n+            PathSet::Set(_) => false,\n         })\n     }\n \n@@ -326,40 +335,135 @@ impl<'a> Builder<'a> {\n             }};\n         }\n         match kind {\n-            Kind::Build => describe!(compile::Std, compile::Test, compile::Rustc,\n-                compile::StartupObjects, tool::BuildManifest, tool::Rustbook, tool::ErrorIndex,\n-                tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n-                tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n-                tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n-                native::Llvm, tool::Rustfmt, tool::Miri, native::Lld),\n-            Kind::Check => describe!(check::Std, check::Test, check::Rustc, check::CodegenBackend,\n-                check::Rustdoc),\n-            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::Ui, test::RunPass,\n-                test::CompileFail, test::ParseFail, test::RunFail, test::RunPassValgrind,\n-                test::MirOpt, test::Codegen, test::CodegenUnits, test::Incremental, test::Debuginfo,\n-                test::UiFullDeps, test::RunPassFullDeps, test::RunFailFullDeps,\n-                test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n-                test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n-                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty,\n-                test::Crate, test::CrateLibrustc, test::CrateRustdoc, test::Linkcheck,\n-                test::Cargotest, test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n+            Kind::Build => describe!(\n+                compile::Std,\n+                compile::Test,\n+                compile::Rustc,\n+                compile::StartupObjects,\n+                tool::BuildManifest,\n+                tool::Rustbook,\n+                tool::ErrorIndex,\n+                tool::UnstableBookGen,\n+                tool::Tidy,\n+                tool::Linkchecker,\n+                tool::CargoTest,\n+                tool::Compiletest,\n+                tool::RemoteTestServer,\n+                tool::RemoteTestClient,\n+                tool::RustInstaller,\n+                tool::Cargo,\n+                tool::Rls,\n+                tool::Rustdoc,\n+                tool::Clippy,\n+                native::Llvm,\n+                tool::Rustfmt,\n+                tool::Miri,\n+                native::Lld\n+            ),\n+            Kind::Check => describe!(\n+                check::Std,\n+                check::Test,\n+                check::Rustc,\n+                check::CodegenBackend,\n+                check::Rustdoc\n+            ),\n+            Kind::Test => describe!(\n+                test::Tidy,\n+                test::Bootstrap,\n+                test::Ui,\n+                test::RunPass,\n+                test::CompileFail,\n+                test::ParseFail,\n+                test::RunFail,\n+                test::RunPassValgrind,\n+                test::MirOpt,\n+                test::Codegen,\n+                test::CodegenUnits,\n+                test::Incremental,\n+                test::Debuginfo,\n+                test::UiFullDeps,\n+                test::RunPassFullDeps,\n+                test::RunFailFullDeps,\n+                test::CompileFailFullDeps,\n+                test::IncrementalFullDeps,\n+                test::Rustdoc,\n+                test::Pretty,\n+                test::RunPassPretty,\n+                test::RunFailPretty,\n+                test::RunPassValgrindPretty,\n+                test::RunPassFullDepsPretty,\n+                test::RunFailFullDepsPretty,\n+                test::Crate,\n+                test::CrateLibrustc,\n+                test::CrateRustdoc,\n+                test::Linkcheck,\n+                test::Cargotest,\n+                test::Cargo,\n+                test::Rls,\n+                test::ErrorIndex,\n+                test::Distcheck,\n                 test::RunMakeFullDeps,\n-                test::Nomicon, test::Reference, test::RustdocBook, test::RustByExample,\n-                test::TheBook, test::UnstableBook, test::RustcBook,\n-                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme,\n+                test::Nomicon,\n+                test::Reference,\n+                test::RustdocBook,\n+                test::RustByExample,\n+                test::TheBook,\n+                test::UnstableBook,\n+                test::RustcBook,\n+                test::Rustfmt,\n+                test::Miri,\n+                test::Clippy,\n+                test::RustdocJS,\n+                test::RustdocTheme,\n                 // Run run-make last, since these won't pass without make on Windows\n-                test::RunMake, test::RustdocUi),\n+                test::RunMake,\n+                test::RustdocUi\n+            ),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n-            Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n-                doc::Standalone, doc::Std, doc::Test, doc::WhitelistedRustc, doc::Rustc,\n-                doc::Rustdoc, doc::ErrorIndex, doc::Nomicon, doc::Reference, doc::RustdocBook,\n-                doc::RustByExample, doc::RustcBook, doc::CargoBook),\n-            Kind::Dist => describe!(dist::Docs, dist::RustcDocs, dist::Mingw, dist::Rustc,\n-                dist::DebuggerScripts, dist::Std, dist::Analysis, dist::Src,\n-                dist::PlainSourceTarball, dist::Cargo, dist::Rls, dist::Rustfmt, dist::Extended,\n-                dist::HashSign),\n-            Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n-                install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n+            Kind::Doc => describe!(\n+                doc::UnstableBook,\n+                doc::UnstableBookGen,\n+                doc::TheBook,\n+                doc::Standalone,\n+                doc::Std,\n+                doc::Test,\n+                doc::WhitelistedRustc,\n+                doc::Rustc,\n+                doc::Rustdoc,\n+                doc::ErrorIndex,\n+                doc::Nomicon,\n+                doc::Reference,\n+                doc::RustdocBook,\n+                doc::RustByExample,\n+                doc::RustcBook,\n+                doc::CargoBook\n+            ),\n+            Kind::Dist => describe!(\n+                dist::Docs,\n+                dist::RustcDocs,\n+                dist::Mingw,\n+                dist::Rustc,\n+                dist::DebuggerScripts,\n+                dist::Std,\n+                dist::Analysis,\n+                dist::Src,\n+                dist::PlainSourceTarball,\n+                dist::Cargo,\n+                dist::Rls,\n+                dist::Rustfmt,\n+                dist::Extended,\n+                dist::HashSign\n+            ),\n+            Kind::Install => describe!(\n+                install::Docs,\n+                install::Std,\n+                install::Cargo,\n+                install::Rls,\n+                install::Rustfmt,\n+                install::Analysis,\n+                install::Src,\n+                install::Rustc\n+            ),\n         }\n     }\n \n@@ -394,10 +498,12 @@ impl<'a> Builder<'a> {\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n         for pathset in should_run.paths {\n-            if let PathSet::Set(set) = pathset{\n-                set.iter().for_each(|path| help.push_str(\n-                    format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str()\n-                    ))\n+            if let PathSet::Set(set) = pathset {\n+                set.iter().for_each(|path| {\n+                    help.push_str(\n+                        format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str(),\n+                    )\n+                })\n             }\n         }\n         Some(help)\n@@ -428,11 +534,13 @@ impl<'a> Builder<'a> {\n             parent: Cell::new(None),\n         };\n \n-\n         if kind == Kind::Dist {\n-            assert!(!builder.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n+            assert!(\n+                !builder.config.test_miri,\n+                \"Do not distribute with miri enabled.\\n\\\n                 The distributed libraries would include all MIR (increasing binary size).\n-                The distributed MIR would include validation statements.\");\n+                The distributed MIR would include validation statements.\"\n+            );\n         }\n \n         builder\n@@ -457,7 +565,9 @@ impl<'a> Builder<'a> {\n     /// obtained through this function, since it ensures that they are valid\n     /// (i.e., built and assembled).\n     pub fn compiler(&self, stage: u32, host: Interned<String>) -> Compiler {\n-        self.ensure(compile::Assemble { target_compiler: Compiler { stage, host } })\n+        self.ensure(compile::Assemble {\n+            target_compiler: Compiler { stage, host },\n+        })\n     }\n \n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n@@ -467,7 +577,9 @@ impl<'a> Builder<'a> {\n     /// Returns the libdir where the standard library and other artifacts are\n     /// found for a compiler's sysroot.\n     pub fn sysroot_libdir(\n-        &self, compiler: Compiler, target: Interned<String>\n+        &self,\n+        compiler: Compiler,\n+        target: Interned<String>,\n     ) -> Interned<PathBuf> {\n         #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         struct Libdir {\n@@ -489,8 +601,12 @@ impl<'a> Builder<'a> {\n                 } else {\n                     Path::new(\"lib\")\n                 };\n-                let sysroot = builder.sysroot(self.compiler).join(lib)\n-                    .join(\"rustlib\").join(self.target).join(\"lib\");\n+                let sysroot = builder\n+                    .sysroot(self.compiler)\n+                    .join(lib)\n+                    .join(\"rustlib\")\n+                    .join(self.target)\n+                    .join(\"lib\");\n                 let _ = fs::remove_dir_all(&sysroot);\n                 t!(fs::create_dir_all(&sysroot));\n                 INTERNER.intern_path(sysroot)\n@@ -524,7 +640,7 @@ impl<'a> Builder<'a> {\n         // compiler live next to the compiler and the system will find them\n         // automatically.\n         if cfg!(windows) {\n-            return\n+            return;\n         }\n \n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n@@ -535,7 +651,9 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n         } else {\n-            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", &compiler.host))\n+            self.sysroot(compiler)\n+                .join(\"bin\")\n+                .join(exe(\"rustc\", &compiler.host))\n         }\n     }\n \n@@ -547,12 +665,15 @@ impl<'a> Builder<'a> {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n         let compiler = self.compiler(self.top_stage, host);\n         cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n-           .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-           .env(\"RUSTDOC_LIBDIR\", self.sysroot_libdir(compiler, self.config.build))\n-           .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n-           .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n-           .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+            .env(\n+                \"RUSTDOC_LIBDIR\",\n+                self.sysroot_libdir(compiler, self.config.build),\n+            )\n+            .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n+            .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n+            .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n         if let Some(linker) = self.linker(host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n@@ -566,17 +687,20 @@ impl<'a> Builder<'a> {\n     /// rustc compiler, its output will be scoped by `mode`'s output directory,\n     /// it will pass the `--target` flag for the specified `target`, and will be\n     /// executing the Cargo command `cmd`.\n-    pub fn cargo(&self,\n-             compiler: Compiler,\n-             mode: Mode,\n-             target: Interned<String>,\n-             cmd: &str) -> Command {\n+    pub fn cargo(\n+        &self,\n+        compiler: Compiler,\n+        mode: Mode,\n+        target: Interned<String>,\n+        cmd: &str,\n+    ) -> Command {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n-        cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n-             .arg(cmd)\n-             .arg(\"--target\")\n-             .arg(target);\n+        cargo\n+            .env(\"CARGO_TARGET_DIR\", out_dir)\n+            .arg(cmd)\n+            .arg(\"--target\")\n+            .arg(target);\n \n         // Set a flag for `check` so that certain build scripts can do less work\n         // (e.g. not building/requiring LLVM).\n@@ -619,8 +743,14 @@ impl<'a> Builder<'a> {\n         }\n \n         if !extra_args.is_empty() {\n-            cargo.env(\"RUSTFLAGS\",\n-                format!(\"{} {}\", env::var(\"RUSTFLAGS\").unwrap_or_default(), extra_args));\n+            cargo.env(\n+                \"RUSTFLAGS\",\n+                format!(\n+                    \"{} {}\",\n+                    env::var(\"RUSTFLAGS\").unwrap_or_default(),\n+                    extra_args\n+                ),\n+            );\n         }\n \n         let want_rustdoc = self.doc_tests != DocTests::No;\n@@ -631,23 +761,29 @@ impl<'a> Builder<'a> {\n         //\n         // These variables are primarily all read by\n         // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n-        cargo.env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n-             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n-             .env(\"RUSTC_REAL\", self.rustc(compiler))\n-             .env(\"RUSTC_STAGE\", stage.to_string())\n-             .env(\"RUSTC_DEBUG_ASSERTIONS\",\n-                  self.config.rust_debug_assertions.to_string())\n-             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-             .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n-             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n-             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n-             .env(\"RUSTDOC_REAL\", if cmd == \"doc\" || (cmd == \"test\" && want_rustdoc) {\n-                 self.rustdoc(compiler.host)\n-             } else {\n-                 PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n-             })\n-             .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n-             .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n+        cargo\n+            .env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n+            .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+            .env(\"RUSTC_REAL\", self.rustc(compiler))\n+            .env(\"RUSTC_STAGE\", stage.to_string())\n+            .env(\n+                \"RUSTC_DEBUG_ASSERTIONS\",\n+                self.config.rust_debug_assertions.to_string(),\n+            )\n+            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+            .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n+            .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n+            .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n+            .env(\n+                \"RUSTDOC_REAL\",\n+                if cmd == \"doc\" || (cmd == \"test\" && want_rustdoc) {\n+                    self.rustdoc(compiler.host)\n+                } else {\n+                    PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n+                },\n+            )\n+            .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n+            .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n \n         if let Some(host_linker) = self.linker(compiler.host) {\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n@@ -659,19 +795,28 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n         }\n         if cmd != \"build\" && cmd != \"check\" && want_rustdoc {\n-            cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.config.build)));\n+            cargo.env(\n+                \"RUSTDOC_LIBDIR\",\n+                self.rustc_libdir(self.compiler(2, self.config.build)),\n+            );\n         }\n \n         if mode == Mode::Tool {\n             // Tools like cargo and rls don't get debuginfo by default right now, but this can be\n             // enabled in the config.  Adding debuginfo makes them several times larger.\n             if self.config.rust_debuginfo_tools {\n                 cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-                cargo.env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string());\n+                cargo.env(\n+                    \"RUSTC_DEBUGINFO_LINES\",\n+                    self.config.rust_debuginfo_lines.to_string(),\n+                );\n             }\n         } else {\n             cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-            cargo.env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string());\n+            cargo.env(\n+                \"RUSTC_DEBUGINFO_LINES\",\n+                self.config.rust_debuginfo_lines.to_string(),\n+            );\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n@@ -718,11 +863,13 @@ impl<'a> Builder<'a> {\n         // If LLVM support is disabled we need to use the snapshot compiler to compile\n         // build scripts, as the new compiler doesn't support executables.\n         if mode == Mode::Libstd || !self.config.llvm_enabled {\n-            cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n+            cargo\n+                .env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n+                .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n-            cargo.env(\"RUSTC_SNAPSHOT\", self.rustc(compiler))\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n+            cargo\n+                .env(\"RUSTC_SNAPSHOT\", self.rustc(compiler))\n+                .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n         // Ignore incremental modes except for stage0, since we're\n@@ -780,32 +927,36 @@ impl<'a> Builder<'a> {\n                 }\n             };\n             let cc = ccacheify(&self.cc(target));\n-            cargo.env(format!(\"CC_{}\", target), &cc)\n-                 .env(\"CC\", &cc);\n+            cargo.env(format!(\"CC_{}\", target), &cc).env(\"CC\", &cc);\n \n             let cflags = self.cflags(target).join(\" \");\n-            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n-                 .env(\"CFLAGS\", cflags.clone());\n+            cargo\n+                .env(format!(\"CFLAGS_{}\", target), cflags.clone())\n+                .env(\"CFLAGS\", cflags.clone());\n \n             if let Some(ar) = self.ar(target) {\n                 let ranlib = format!(\"{} s\", ar.display());\n-                cargo.env(format!(\"AR_{}\", target), ar)\n-                     .env(\"AR\", ar)\n-                     .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n-                     .env(\"RANLIB\", ranlib);\n+                cargo\n+                    .env(format!(\"AR_{}\", target), ar)\n+                    .env(\"AR\", ar)\n+                    .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n+                    .env(\"RANLIB\", ranlib);\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n                 let cxx = ccacheify(&cxx);\n-                cargo.env(format!(\"CXX_{}\", target), &cxx)\n-                     .env(\"CXX\", &cxx)\n-                     .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n-                     .env(\"CXXFLAGS\", cflags);\n+                cargo\n+                    .env(format!(\"CXX_{}\", target), &cxx)\n+                    .env(\"CXX\", &cxx)\n+                    .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n+                    .env(\"CXXFLAGS\", cflags);\n             }\n         }\n \n-        if cmd == \"build\" && mode == Mode::Libstd\n-            && self.config.extended && compiler.is_final_stage(self)\n+        if cmd == \"build\"\n+            && mode == Mode::Libstd\n+            && self.config.extended\n+            && compiler.is_final_stage(self)\n         {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n@@ -893,7 +1044,10 @@ impl<'a> Builder<'a> {\n             let mut stack = self.stack.borrow_mut();\n             for stack_step in stack.iter() {\n                 // should skip\n-                if stack_step.downcast_ref::<S>().map_or(true, |stack_step| *stack_step != step) {\n+                if stack_step\n+                    .downcast_ref::<S>()\n+                    .map_or(true, |stack_step| *stack_step != step)\n+                {\n                     continue;\n                 }\n                 let mut out = String::new();\n@@ -909,7 +1063,9 @@ impl<'a> Builder<'a> {\n                 {\n                     let mut graph = self.graph.borrow_mut();\n                     let parent = self.parent.get();\n-                    let us = *self.graph_nodes.borrow_mut()\n+                    let us = *self\n+                        .graph_nodes\n+                        .borrow_mut()\n                         .entry(format!(\"{:?}\", step))\n                         .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n                     if let Some(parent) = parent {\n@@ -928,7 +1084,9 @@ impl<'a> Builder<'a> {\n         {\n             let mut graph = self.graph.borrow_mut();\n             let parent = self.parent.get();\n-            let us = *self.graph_nodes.borrow_mut()\n+            let us = *self\n+                .graph_nodes\n+                .borrow_mut()\n                 .entry(format!(\"{:?}\", step))\n                 .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n             self.parent.set(Some(us));\n@@ -950,28 +1108,34 @@ impl<'a> Builder<'a> {\n         self.parent.set(prev_parent);\n \n         if self.config.print_step_timings && dur > Duration::from_millis(100) {\n-            println!(\"[TIMING] {:?} -- {}.{:03}\",\n-                     step,\n-                     dur.as_secs(),\n-                     dur.subsec_nanos() / 1_000_000);\n+            println!(\n+                \"[TIMING] {:?} -- {}.{:03}\",\n+                step,\n+                dur.as_secs(),\n+                dur.subsec_nanos() / 1_000_000\n+            );\n         }\n \n         {\n             let mut stack = self.stack.borrow_mut();\n             let cur_step = stack.pop().expect(\"step stack empty\");\n             assert_eq!(cur_step.downcast_ref(), Some(&step));\n         }\n-        self.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n+        self.verbose(&format!(\n+            \"{}< {:?}\",\n+            \"  \".repeat(self.stack.borrow().len()),\n+            step\n+        ));\n         self.cache.put(step, out.clone());\n         out\n     }\n }\n \n #[cfg(test)]\n mod __test {\n+    use super::*;\n     use config::Config;\n     use std::thread;\n-    use super::*;\n \n     fn configure(host: &[&str], target: &[&str]) -> Config {\n         let mut config = Config::default_opts();\n@@ -980,15 +1144,26 @@ mod __test {\n         config.run_host_only = true;\n         config.dry_run = true;\n         // try to avoid spurious failures in dist where we create/delete each others file\n-        let dir = config.out.join(\"tmp-rustbuild-tests\")\n-            .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n+        let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n+            &thread::current()\n+                .name()\n+                .unwrap_or(\"unknown\")\n+                .replace(\":\", \"-\"),\n+        );\n         t!(fs::create_dir_all(&dir));\n         config.out = dir;\n         config.build = INTERNER.intern_str(\"A\");\n-        config.hosts = vec![config.build].clone().into_iter()\n-            .chain(host.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n-        config.targets = config.hosts.clone().into_iter()\n-            .chain(target.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n+        config.hosts = vec![config.build]\n+            .clone()\n+            .into_iter()\n+            .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+            .collect::<Vec<_>>();\n+        config.targets = config\n+            .hosts\n+            .clone()\n+            .into_iter()\n+            .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+            .collect::<Vec<_>>();\n         config\n     }\n \n@@ -1004,21 +1179,27 @@ mod __test {\n \n         let a = INTERNER.intern_str(\"A\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { stage: 2, host: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[dist::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: a,\n-            },\n-        ]);\n+            },]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n@@ -1031,27 +1212,36 @@ mod __test {\n         let a = INTERNER.intern_str(\"A\");\n         let b = INTERNER.intern_str(\"B\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n@@ -1064,28 +1254,41 @@ mod __test {\n         let a = INTERNER.intern_str(\"A\");\n         let b = INTERNER.intern_str(\"B\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n@@ -1099,34 +1302,50 @@ mod __test {\n         let b = INTERNER.intern_str(\"B\");\n         let c = INTERNER.intern_str(\"C\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-            dist::Docs { stage: 2, host: c },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-            dist::Mingw { host: c },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+                dist::Docs { stage: 2, host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[\n+                dist::Mingw { host: a },\n+                dist::Mingw { host: b },\n+                dist::Mingw { host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n@@ -1142,31 +1361,40 @@ mod __test {\n         let b = INTERNER.intern_str(\"B\");\n         let c = INTERNER.intern_str(\"C\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-            dist::Docs { stage: 2, host: c },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-            dist::Mingw { host: c },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+                dist::Docs { stage: 2, host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[\n+                dist::Mingw { host: a },\n+                dist::Mingw { host: b },\n+                dist::Mingw { host: c },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n     }\n \n@@ -1179,87 +1407,109 @@ mod __test {\n         let a = INTERNER.intern_str(\"A\");\n         let b = INTERNER.intern_str(\"B\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-        assert_eq!(first(builder.cache.all::<compile::Std>()), &[\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 0 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 1 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 2 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: b, stage: 2 },\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 0 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 2 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 2 },\n+                },\n+            ]\n+        );\n     }\n \n     #[test]\n@@ -1274,83 +1524,89 @@ mod __test {\n \n         assert!(!builder.cache.all::<compile::Std>().is_empty());\n         assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n-        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n-\n-        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n     }\n \n     #[test]\n@@ -1366,84 +1622,93 @@ mod __test {\n         let c = INTERNER.intern_str(\"C\");\n \n         assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 0 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 1 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: b, stage: 1 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 2 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: b, stage: 2 },\n-            },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-        ]);\n-\n-        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 0 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 2 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 2 },\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n     }\n \n     #[test]\n@@ -1472,14 +1737,15 @@ mod __test {\n \n         // Ensure we don't build any compiler artifacts.\n         assert!(builder.cache.all::<compile::Rustc>().is_empty());\n-        assert_eq!(first(builder.cache.all::<test::Crate>()), &[\n-            test::Crate {\n+        assert_eq!(\n+            first(builder.cache.all::<test::Crate>()),\n+            &[test::Crate {\n                 compiler: Compiler { host, stage: 0 },\n                 target: host,\n                 mode: Mode::Libstd,\n                 test_kind: test::TestKind::Test,\n                 krate: INTERNER.intern_str(\"std\"),\n-            },\n-        ]);\n+            },]\n+        );\n     }\n }"}, {"sha": "e5dceccdf8b9e557b659d99aed8532ec3686682f", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 130, "deletions": 98, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=b39a1d6f1a30ba29f25d7141038b9a5bf0126e36", "patch": "@@ -19,10 +19,10 @@ use std::process;\n \n use getopts::Options;\n \n-use {Build, DocTests};\n+use builder::Builder;\n use config::Config;\n use metadata;\n-use builder::Builder;\n+use {Build, DocTests};\n \n use cache::{Interned, INTERNER};\n \n@@ -93,7 +93,8 @@ impl Default for Subcommand {\n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut extra_help = String::new();\n-        let mut subcommand_help = format!(\"\\\n+        let mut subcommand_help = format!(\n+            \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n@@ -106,7 +107,8 @@ Subcommands:\n     dist        Build distribution artifacts\n     install     Install distribution artifacts\n \n-To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n+To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n+        );\n \n         let mut opts = Options::new();\n         // Options common to all subcommands\n@@ -124,33 +126,39 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n-        opts.optopt(\"\", \"warnings\", \"if value is deny, will deny warnings, otherwise use default\",\n-            \"VALUE\");\n+        opts.optopt(\n+            \"\",\n+            \"warnings\",\n+            \"if value is deny, will deny warnings, otherwise use default\",\n+            \"VALUE\",\n+        );\n         opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n \n         // fn usage()\n-        let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n-            println!(\"{}\", opts.usage(subcommand_help));\n-            if !extra_help.is_empty() {\n-                println!(\"{}\", extra_help);\n-            }\n-            process::exit(exit_code);\n-        };\n+        let usage =\n+            |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n+                println!(\"{}\", opts.usage(subcommand_help));\n+                if !extra_help.is_empty() {\n+                    println!(\"{}\", extra_help);\n+                }\n+                process::exit(exit_code);\n+            };\n \n         // We can't use getopt to parse the options until we have completed specifying which\n         // options are valid, but under the current implementation, some options are conditional on\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n         // complete the definition of the options.  Then we can use the getopt::Matches object from\n         // there on out.\n-        let subcommand = args.iter().find(|&s|\n+        let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n-            || (s == \"check\")\n-            || (s == \"test\")\n-            || (s == \"bench\")\n-            || (s == \"doc\")\n-            || (s == \"clean\")\n-            || (s == \"dist\")\n-            || (s == \"install\"));\n+                || (s == \"check\")\n+                || (s == \"test\")\n+                || (s == \"bench\")\n+                || (s == \"doc\")\n+                || (s == \"clean\")\n+                || (s == \"dist\")\n+                || (s == \"install\")\n+        });\n         let subcommand = match subcommand {\n             Some(s) => s,\n             None => {\n@@ -165,7 +173,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n \n         // Some subcommands get extra options\n         match subcommand.as_str() {\n-            \"test\"  => {\n+            \"test\" => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n                 opts.optmulti(\n@@ -176,12 +184,25 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                 );\n                 opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n                 opts.optflag(\"\", \"doc\", \"only run doc tests\");\n-                opts.optflag(\"\", \"bless\", \"update all stderr/stdout files of failing ui tests\");\n-                opts.optopt(\"\", \"compare-mode\", \"mode describing what file the actual ui output will be compared to\", \"COMPARE MODE\");\n-            },\n-            \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n-            \"clean\" => { opts.optflag(\"\", \"all\", \"clean all build artifacts\"); },\n-            _ => { },\n+                opts.optflag(\n+                    \"\",\n+                    \"bless\",\n+                    \"update all stderr/stdout files of failing ui tests\",\n+                );\n+                opts.optopt(\n+                    \"\",\n+                    \"compare-mode\",\n+                    \"mode describing what file the actual ui output will be compared to\",\n+                    \"COMPARE MODE\",\n+                );\n+            }\n+            \"bench\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+            }\n+            \"clean\" => {\n+                opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n+            }\n+            _ => {}\n         };\n \n         // Done specifying what options are possible, so do the getopts parsing\n@@ -201,21 +222,24 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                 if check_subcommand != subcommand {\n                     pass_sanity_check = false;\n                 }\n-            },\n+            }\n             None => {\n                 pass_sanity_check = false;\n             }\n         }\n         if !pass_sanity_check {\n             println!(\"{}\\n\", subcommand_help);\n-            println!(\"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n-                      You may need to move some options to after the subcommand.\\n\");\n+            println!(\n+                \"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n+                 You may need to move some options to after the subcommand.\\n\"\n+            );\n             process::exit(1);\n         }\n         // Extra help text for some commands\n         match subcommand.as_str() {\n             \"build\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to the crates\n     and/or artifacts to compile. For example:\n@@ -237,10 +261,12 @@ Arguments:\n     This will first build everything once (like --stage 0 without further\n     arguments would), and then use the compiler built in stage 0 to build\n     src/libtest and its dependencies.\n-    Once this is done, build/$ARCH/stage1 contains a usable compiler.\");\n+    Once this is done, build/$ARCH/stage1 contains a usable compiler.\",\n+                );\n             }\n             \"check\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to the crates\n     and/or artifacts to compile. For example:\n@@ -252,10 +278,12 @@ Arguments:\n     also that since we use `cargo check`, by default this will automatically enable incremental\n     compilation, so there's no need to pass it separately, though it won't hurt. We also completely\n     ignore the stage passed, as there's no way to compile in non-stage 0 without actually building\n-    the compiler.\");\n+    the compiler.\",\n+                );\n             }\n             \"test\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to tests that\n     should be compiled and run. For example:\n@@ -270,10 +298,12 @@ Arguments:\n     compiled and tested.\n \n         ./x.py test\n-        ./x.py test --stage 1\");\n+        ./x.py test --stage 1\",\n+                );\n             }\n             \"doc\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories of documentation\n     to build. For example:\n@@ -285,12 +315,16 @@ Arguments:\n     If no arguments are passed then everything is documented:\n \n         ./x.py doc\n-        ./x.py doc --stage 1\");\n+        ./x.py doc --stage 1\",\n+                );\n             }\n-            _ => { }\n+            _ => {}\n         };\n         // Get any optional paths which occur after the subcommand\n-        let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n+        let paths = matches.free[1..]\n+            .iter()\n+            .map(|p| p.into())\n+            .collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -309,9 +343,12 @@ Arguments:\n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n         } else if subcommand.as_str() != \"clean\" {\n-            extra_help.push_str(format!(\n-                \"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                subcommand).as_str());\n+            extra_help.push_str(\n+                format!(\n+                    \"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                    subcommand\n+                ).as_str(),\n+            );\n         }\n \n         // User passed in -h/--help?\n@@ -320,38 +357,28 @@ Arguments:\n         }\n \n         let cmd = match subcommand.as_str() {\n-            \"build\" => {\n-                Subcommand::Build { paths: paths }\n-            }\n-            \"check\" => {\n-                Subcommand::Check { paths: paths }\n-            }\n-            \"test\" => {\n-                Subcommand::Test {\n-                    paths,\n-                    bless: matches.opt_present(\"bless\"),\n-                    compare_mode: matches.opt_str(\"compare-mode\"),\n-                    test_args: matches.opt_strs(\"test-args\"),\n-                    rustc_args: matches.opt_strs(\"rustc-args\"),\n-                    fail_fast: !matches.opt_present(\"no-fail-fast\"),\n-                    doc_tests: if matches.opt_present(\"doc\") {\n-                        DocTests::Only\n-                    } else if matches.opt_present(\"no-doc\") {\n-                        DocTests::No\n-                    } else {\n-                        DocTests::Yes\n-                    }\n-                }\n-            }\n-            \"bench\" => {\n-                Subcommand::Bench {\n-                    paths,\n-                    test_args: matches.opt_strs(\"test-args\"),\n-                }\n-            }\n-            \"doc\" => {\n-                Subcommand::Doc { paths: paths }\n-            }\n+            \"build\" => Subcommand::Build { paths: paths },\n+            \"check\" => Subcommand::Check { paths: paths },\n+            \"test\" => Subcommand::Test {\n+                paths,\n+                bless: matches.opt_present(\"bless\"),\n+                compare_mode: matches.opt_str(\"compare-mode\"),\n+                test_args: matches.opt_strs(\"test-args\"),\n+                rustc_args: matches.opt_strs(\"rustc-args\"),\n+                fail_fast: !matches.opt_present(\"no-fail-fast\"),\n+                doc_tests: if matches.opt_present(\"doc\") {\n+                    DocTests::Only\n+                } else if matches.opt_present(\"no-doc\") {\n+                    DocTests::No\n+                } else {\n+                    DocTests::Yes\n+                },\n+            },\n+            \"bench\" => Subcommand::Bench {\n+                paths,\n+                test_args: matches.opt_strs(\"test-args\"),\n+            },\n+            \"doc\" => Subcommand::Doc { paths: paths },\n             \"clean\" => {\n                 if paths.len() > 0 {\n                     println!(\"\\nclean does not take a path argument\\n\");\n@@ -362,22 +389,13 @@ Arguments:\n                     all: matches.opt_present(\"all\"),\n                 }\n             }\n-            \"dist\" => {\n-                Subcommand::Dist {\n-                    paths,\n-                }\n-            }\n-            \"install\" => {\n-                Subcommand::Install {\n-                    paths,\n-                }\n-            }\n+            \"dist\" => Subcommand::Dist { paths },\n+            \"install\" => Subcommand::Install { paths },\n             _ => {\n                 usage(1, &opts, &subcommand_help, &extra_help);\n             }\n         };\n \n-\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: matches.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n@@ -386,15 +404,21 @@ Arguments:\n             rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n             host: split(matches.opt_strs(\"host\"))\n-                .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n+                .into_iter()\n+                .map(|x| INTERNER.intern_string(x))\n+                .collect::<Vec<_>>(),\n             target: split(matches.opt_strs(\"target\"))\n-                .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n+                .into_iter()\n+                .map(|x| INTERNER.intern_string(x))\n+                .collect::<Vec<_>>(),\n             config: cfg_file,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd,\n             incremental: matches.opt_present(\"incremental\"),\n             exclude: split(matches.opt_strs(\"exclude\"))\n-                .into_iter().map(|p| p.into()).collect::<Vec<_>>(),\n+                .into_iter()\n+                .map(|p| p.into())\n+                .collect::<Vec<_>>(),\n             warnings: matches.opt_str(\"warnings\").map(|v| v == \"deny\"),\n         }\n     }\n@@ -403,19 +427,22 @@ Arguments:\n impl Subcommand {\n     pub fn test_args(&self) -> Vec<&str> {\n         match *self {\n-            Subcommand::Test { ref test_args, .. } |\n-            Subcommand::Bench { ref test_args, .. } => {\n-                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            Subcommand::Test { ref test_args, .. } | Subcommand::Bench { ref test_args, .. } => {\n+                test_args\n+                    .iter()\n+                    .flat_map(|s| s.split_whitespace())\n+                    .collect()\n             }\n             _ => Vec::new(),\n         }\n     }\n \n     pub fn rustc_args(&self) -> Vec<&str> {\n         match *self {\n-            Subcommand::Test { ref rustc_args, .. } => {\n-                rustc_args.iter().flat_map(|s| s.split_whitespace()).collect()\n-            }\n+            Subcommand::Test { ref rustc_args, .. } => rustc_args\n+                .iter()\n+                .flat_map(|s| s.split_whitespace())\n+                .collect(),\n             _ => Vec::new(),\n         }\n     }\n@@ -443,12 +470,17 @@ impl Subcommand {\n \n     pub fn compare_mode(&self) -> Option<&str> {\n         match *self {\n-            Subcommand::Test { ref compare_mode, .. } => compare_mode.as_ref().map(|s| &s[..]),\n+            Subcommand::Test {\n+                ref compare_mode, ..\n+            } => compare_mode.as_ref().map(|s| &s[..]),\n             _ => None,\n         }\n     }\n }\n \n fn split(s: Vec<String>) -> Vec<String> {\n-    s.iter().flat_map(|s| s.split(',')).map(|s| s.to_string()).collect()\n+    s.iter()\n+        .flat_map(|s| s.split(','))\n+        .map(|s| s.to_string())\n+        .collect()\n }"}, {"sha": "92847786792156e1b44b01f9051fa2831ee4c9a6", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 241, "deletions": 150, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=b39a1d6f1a30ba29f25d7141038b9a5bf0126e36", "patch": "@@ -15,26 +15,26 @@\n \n use std::env;\n use std::ffi::OsString;\n-use std::iter;\n use std::fmt;\n use std::fs::{self, File};\n-use std::path::{PathBuf, Path};\n-use std::process::Command;\n use std::io::Read;\n+use std::iter;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n \n use build_helper::{self, output};\n \n-use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n-use Crate as CargoCrate;\n-use cache::{INTERNER, Interned};\n+use builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n+use cache::{Interned, INTERNER};\n use compile;\n use dist;\n+use flags::Subcommand;\n use native;\n use tool::{self, Tool};\n-use util::{self, dylib_path, dylib_path_var};\n-use {Mode, DocTests};\n use toolstate::ToolState;\n-use flags::Subcommand;\n+use util::{self, dylib_path, dylib_path_var};\n+use Crate as CargoCrate;\n+use {DocTests, Mode};\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n@@ -52,7 +52,7 @@ impl From<Kind> for TestKind {\n         match kind {\n             Kind::Test => TestKind::Test,\n             Kind::Bench => TestKind::Bench,\n-            _ => panic!(\"unexpected kind in crate: {:?}\", kind)\n+            _ => panic!(\"unexpected kind in crate: {:?}\", kind),\n         }\n     }\n }\n@@ -124,13 +124,18 @@ impl Step for Linkcheck {\n         builder.default_doc(None);\n \n         let _time = util::timeit(&builder);\n-        try_run(builder, builder.tool_cmd(Tool::Linkchecker)\n-                              .arg(builder.out.join(host).join(\"doc\")));\n+        try_run(\n+            builder,\n+            builder\n+                .tool_cmd(Tool::Linkchecker)\n+                .arg(builder.out.join(host).join(\"doc\")),\n+        );\n     }\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/linkchecker\").default_condition(builder.config.docs)\n+        run.path(\"src/tools/linkchecker\")\n+            .default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -165,7 +170,10 @@ impl Step for Cargotest {\n     /// test` to ensure that we don't regress the test suites there.\n     fn run(self, builder: &Builder) {\n         let compiler = builder.compiler(self.stage, self.host);\n-        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+        builder.ensure(compile::Rustc {\n+            compiler,\n+            target: compiler.host,\n+        });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n@@ -175,10 +183,13 @@ impl Step for Cargotest {\n \n         let _time = util::timeit(&builder);\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n-        try_run(builder, cmd.arg(&builder.initial_cargo)\n-                          .arg(&out_dir)\n-                          .env(\"RUSTC\", builder.rustc(compiler))\n-                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n+        try_run(\n+            builder,\n+            cmd.arg(&builder.initial_cargo)\n+                .arg(&out_dir)\n+                .env(\"RUSTC\", builder.rustc(compiler))\n+                .env(\"RUSTDOC\", builder.rustdoc(compiler.host)),\n+        );\n     }\n }\n \n@@ -207,9 +218,14 @@ impl Step for Cargo {\n     fn run(self, builder: &Builder) {\n         let compiler = builder.compiler(self.stage, self.host);\n \n-        builder.ensure(tool::Cargo { compiler, target: self.host });\n+        builder.ensure(tool::Cargo {\n+            compiler,\n+            target: self.host,\n+        });\n         let mut cargo = builder.cargo(compiler, Mode::Tool, self.host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/cargo/Cargo.toml\"));\n+        cargo\n+            .arg(\"--manifest-path\")\n+            .arg(builder.src.join(\"src/tools/cargo/Cargo.toml\"));\n         if !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n@@ -221,7 +237,10 @@ impl Step for Cargo {\n         // available.\n         cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n \n-        try_run(builder, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n+        try_run(\n+            builder,\n+            cargo.env(\"PATH\", &path_for_cargo(builder, compiler)),\n+        );\n     }\n }\n \n@@ -262,11 +281,7 @@ impl Step for Rls {\n             return;\n         }\n \n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rls\");\n+        let mut cargo = tool::prepare_tool_cargo(builder, compiler, host, \"test\", \"src/tools/rls\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -316,11 +331,8 @@ impl Step for Rustfmt {\n             return;\n         }\n \n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rustfmt\");\n+        let mut cargo =\n+            tool::prepare_tool_cargo(builder, compiler, host, \"test\", \"src/tools/rustfmt\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -372,7 +384,9 @@ impl Step for Miri {\n         });\n         if let Some(miri) = miri {\n             let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/miri/Cargo.toml\"));\n+            cargo\n+                .arg(\"--manifest-path\")\n+                .arg(builder.src.join(\"src/tools/miri/Cargo.toml\"));\n \n             // Don't build tests dynamically, just a pain to work with\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -428,15 +442,19 @@ impl Step for Clippy {\n         });\n         if let Some(clippy) = clippy {\n             let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/clippy/Cargo.toml\"));\n+            cargo\n+                .arg(\"--manifest-path\")\n+                .arg(builder.src.join(\"src/tools/clippy/Cargo.toml\"));\n \n             // Don't build tests dynamically, just a pain to work with\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n             // clippy tests need to know about the stage sysroot\n             cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n             cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder.stage_out(compiler, Mode::Tool).join(builder.cargo_dir());\n+            let host_libs = builder\n+                .stage_out(compiler, Mode::Tool)\n+                .join(builder.cargo_dir());\n             cargo.env(\"HOST_LIBS\", host_libs);\n             // clippy tests need to find the driver\n             cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n@@ -478,23 +496,30 @@ impl Step for RustdocTheme {\n     fn make_run(run: RunConfig) {\n         let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n-        run.builder.ensure(RustdocTheme {\n-            compiler: compiler,\n-        });\n+        run.builder.ensure(RustdocTheme { compiler: compiler });\n     }\n \n     fn run(self, builder: &Builder) {\n         let rustdoc = builder.out.join(\"bootstrap/debug/rustdoc\");\n         let mut cmd = builder.tool_cmd(Tool::RustdocTheme);\n         cmd.arg(rustdoc.to_str().unwrap())\n-           .arg(builder.src.join(\"src/librustdoc/html/static/themes\").to_str().unwrap())\n-           .env(\"RUSTC_STAGE\", self.compiler.stage.to_string())\n-           .env(\"RUSTC_SYSROOT\", builder.sysroot(self.compiler))\n-           .env(\"RUSTDOC_LIBDIR\", builder.sysroot_libdir(self.compiler, self.compiler.host))\n-           .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n-           .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler.host))\n-           .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+            .arg(\n+                builder\n+                    .src\n+                    .join(\"src/librustdoc/html/static/themes\")\n+                    .to_str()\n+                    .unwrap(),\n+            )\n+            .env(\"RUSTC_STAGE\", self.compiler.stage.to_string())\n+            .env(\"RUSTC_SYSROOT\", builder.sysroot(self.compiler))\n+            .env(\n+                \"RUSTDOC_LIBDIR\",\n+                builder.sysroot_libdir(self.compiler, self.compiler.host),\n+            )\n+            .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n+            .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler.host))\n+            .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n         if let Some(linker) = builder.linker(self.compiler.host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n@@ -534,7 +559,9 @@ impl Step for RustdocJS {\n             });\n             builder.run(&mut command);\n         } else {\n-            builder.info(&format!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"));\n+            builder.info(&format!(\n+                \"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"\n+            ));\n         }\n     }\n }\n@@ -918,15 +945,16 @@ impl Step for Compiletest {\n \n             builder.ensure(dist::DebuggerScripts {\n                 sysroot: builder.sysroot(compiler),\n-                host: target\n+                host: target,\n             });\n         }\n \n         if suite.ends_with(\"fulldeps\") ||\n             // FIXME: Does pretty need librustc compiled? Note that there are\n             // fulldeps test suites with mode = pretty as well.\n             mode == \"pretty\" ||\n-            mode == \"rustdoc\" {\n+            mode == \"rustdoc\"\n+        {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n@@ -939,26 +967,34 @@ impl Step for Compiletest {\n         // compiletest currently has... a lot of arguments, so let's just pass all\n         // of them!\n \n-        cmd.arg(\"--compile-lib-path\").arg(builder.rustc_libdir(compiler));\n-        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n+        cmd.arg(\"--compile-lib-path\")\n+            .arg(builder.rustc_libdir(compiler));\n+        cmd.arg(\"--run-lib-path\")\n+            .arg(builder.sysroot_libdir(compiler, target));\n         cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n \n         let is_rustdoc_ui = suite.ends_with(\"rustdoc-ui\");\n \n         // Avoid depending on rustdoc when we don't need it.\n-        if mode == \"rustdoc\" ||\n-           (mode == \"run-make\" && suite.ends_with(\"fulldeps\")) ||\n-           (mode == \"ui\" && is_rustdoc_ui) {\n-            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n+        if mode == \"rustdoc\"\n+            || (mode == \"run-make\" && suite.ends_with(\"fulldeps\"))\n+            || (mode == \"ui\" && is_rustdoc_ui)\n+        {\n+            cmd.arg(\"--rustdoc-path\")\n+                .arg(builder.rustdoc(compiler.host));\n         }\n \n-        cmd.arg(\"--src-base\").arg(builder.src.join(\"src/test\").join(suite));\n-        cmd.arg(\"--build-base\").arg(testdir(builder, compiler.host).join(suite));\n-        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n+        cmd.arg(\"--src-base\")\n+            .arg(builder.src.join(\"src/test\").join(suite));\n+        cmd.arg(\"--build-base\")\n+            .arg(testdir(builder, compiler.host).join(suite));\n+        cmd.arg(\"--stage-id\")\n+            .arg(format!(\"stage{}-{}\", compiler.stage, target));\n         cmd.arg(\"--mode\").arg(mode);\n         cmd.arg(\"--target\").arg(target);\n         cmd.arg(\"--host\").arg(&*compiler.host);\n-        cmd.arg(\"--llvm-filecheck\").arg(builder.llvm_filecheck(builder.config.build));\n+        cmd.arg(\"--llvm-filecheck\")\n+            .arg(builder.llvm_filecheck(builder.config.build));\n \n         if builder.config.cmd.bless() {\n             cmd.arg(\"--bless\");\n@@ -994,8 +1030,10 @@ impl Step for Compiletest {\n         cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n         let mut targetflags = flags.clone();\n-        targetflags.push(format!(\"-Lnative={}\",\n-                                 builder.test_helpers_out(target).display()));\n+        targetflags.push(format!(\n+            \"-Lnative={}\",\n+            builder.test_helpers_out(target).display()\n+        ));\n         cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n \n         cmd.arg(\"--docck-python\").arg(builder.python());\n@@ -1021,13 +1059,16 @@ impl Step for Compiletest {\n \n         // Get paths from cmd args\n         let paths = match &builder.config.cmd {\n-            Subcommand::Test { ref paths, ..} => &paths[..],\n-            _ => &[]\n+            Subcommand::Test { ref paths, .. } => &paths[..],\n+            _ => &[],\n         };\n \n         // Get test-args by striping suite path\n-        let mut test_args: Vec<&str> = paths.iter().filter(|p| p.starts_with(suite_path) &&\n-           p.is_file()).map(|p| p.strip_prefix(suite_path).unwrap().to_str().unwrap()).collect();\n+        let mut test_args: Vec<&str> = paths\n+            .iter()\n+            .filter(|p| p.starts_with(suite_path) && p.is_file())\n+            .map(|p| p.strip_prefix(suite_path).unwrap().to_str().unwrap())\n+            .collect();\n \n         test_args.append(&mut builder.config.cmd.test_args());\n \n@@ -1059,32 +1100,44 @@ impl Step for Compiletest {\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n                 let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n-                cmd.arg(\"--cc\").arg(builder.cc(target))\n-                .arg(\"--cxx\").arg(builder.cxx(target).unwrap())\n-                .arg(\"--cflags\").arg(builder.cflags(target).join(\" \"))\n-                .arg(\"--llvm-components\").arg(llvm_components.trim())\n-                .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+                cmd.arg(\"--cc\")\n+                    .arg(builder.cc(target))\n+                    .arg(\"--cxx\")\n+                    .arg(builder.cxx(target).unwrap())\n+                    .arg(\"--cflags\")\n+                    .arg(builder.cflags(target).join(\" \"))\n+                    .arg(\"--llvm-components\")\n+                    .arg(llvm_components.trim())\n+                    .arg(\"--llvm-cxxflags\")\n+                    .arg(llvm_cxxflags.trim());\n                 if let Some(ar) = builder.ar(target) {\n                     cmd.arg(\"--ar\").arg(ar);\n                 }\n             }\n         }\n         if suite == \"run-make-fulldeps\" && !builder.config.llvm_enabled {\n-            builder.info(\n-                &format!(\"Ignoring run-make test suite as they generally don't work without LLVM\"));\n+            builder.info(&format!(\n+                \"Ignoring run-make test suite as they generally don't work without LLVM\"\n+            ));\n             return;\n         }\n \n         if suite != \"run-make-fulldeps\" {\n-            cmd.arg(\"--cc\").arg(\"\")\n-               .arg(\"--cxx\").arg(\"\")\n-               .arg(\"--cflags\").arg(\"\")\n-               .arg(\"--llvm-components\").arg(\"\")\n-               .arg(\"--llvm-cxxflags\").arg(\"\");\n+            cmd.arg(\"--cc\")\n+                .arg(\"\")\n+                .arg(\"--cxx\")\n+                .arg(\"\")\n+                .arg(\"--cflags\")\n+                .arg(\"\")\n+                .arg(\"--llvm-components\")\n+                .arg(\"\")\n+                .arg(\"--llvm-cxxflags\")\n+                .arg(\"\");\n         }\n \n         if builder.remote_tested(target) {\n-            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n+            cmd.arg(\"--remote-test-client\")\n+                .arg(builder.tool_exe(Tool::RemoteTestClient));\n         }\n \n         // Running a C compiler on MSVC requires a few env vars to be set, to be\n@@ -1117,24 +1170,28 @@ impl Step for Compiletest {\n         if target.contains(\"android\") {\n             // Assume that cc for this target comes from the android sysroot\n             cmd.arg(\"--android-cross-path\")\n-               .arg(builder.cc(target).parent().unwrap().parent().unwrap());\n+                .arg(builder.cc(target).parent().unwrap().parent().unwrap());\n         } else {\n             cmd.arg(\"--android-cross-path\").arg(\"\");\n         }\n \n         builder.ci_env.force_coloring_in_ci(&mut cmd);\n \n         let _folder = builder.fold_output(|| format!(\"test_{}\", suite));\n-        builder.info(&format!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target));\n+        builder.info(&format!(\n+            \"Check compiletest suite={} mode={} ({} -> {})\",\n+            suite, mode, &compiler.host, target\n+        ));\n         let _time = util::timeit(&builder);\n         try_run(builder, &mut cmd);\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n             let _folder = builder.fold_output(|| format!(\"test_{}_{}\", suite, compare_mode));\n-            builder.info(&format!(\"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n-                                  suite, mode, compare_mode, &compiler.host, target));\n+            builder.info(&format!(\n+                \"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n+                suite, mode, compare_mode, &compiler.host, target\n+            ));\n             let _time = util::timeit(&builder);\n             try_run(builder, &mut cmd);\n         }\n@@ -1165,7 +1222,10 @@ impl Step for DocTest {\n     fn run(self, builder: &Builder) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n+        builder.ensure(compile::Test {\n+            compiler,\n+            target: compiler.host,\n+        });\n \n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n@@ -1177,7 +1237,7 @@ impl Step for DocTest {\n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n                 stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n-                continue\n+                continue;\n             }\n \n             if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n@@ -1284,7 +1344,10 @@ impl Step for ErrorIndex {\n     fn run(self, builder: &Builder) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n+        builder.ensure(compile::Std {\n+            compiler,\n+            target: compiler.host,\n+        });\n \n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n@@ -1296,7 +1359,6 @@ impl Step for ErrorIndex {\n             .env(\"CFG_BUILD\", &builder.config.build)\n             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n \n-\n         let _folder = builder.fold_output(|| \"test_error_index\");\n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n@@ -1314,7 +1376,7 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool\n                 return true;\n             }\n         }\n-        Err(_) => {},\n+        Err(_) => {}\n     }\n \n     builder.info(&format!(\"doc tests for: {}\", markdown.display()));\n@@ -1431,7 +1493,6 @@ impl Step for CrateNotDefault {\n     }\n }\n \n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Crate {\n     pub compiler: Compiler,\n@@ -1449,10 +1510,11 @@ impl Step for Crate {\n         let builder = run.builder;\n         run = run.krate(\"test\");\n         for krate in run.builder.in_tree_crates(\"std\") {\n-            if krate.is_local(&run.builder) &&\n-                !krate.name.contains(\"jemalloc\") &&\n-                !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) &&\n-                krate.name != \"dlmalloc\" {\n+            if krate.is_local(&run.builder)\n+                && !krate.name.contains(\"jemalloc\")\n+                && !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\"))\n+                && krate.name != \"dlmalloc\"\n+            {\n                 run = run.path(krate.local_path(&builder).to_str().unwrap());\n             }\n         }\n@@ -1567,38 +1629,59 @@ impl Step for Crate {\n         }\n \n         if target.contains(\"emscripten\") {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      builder.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n+            cargo.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                builder\n+                    .config\n+                    .nodejs\n+                    .as_ref()\n+                    .expect(\"nodejs not configured\"),\n+            );\n         } else if target.starts_with(\"wasm32\") {\n             // Warn about running tests without the `wasm_syscall` feature enabled.\n             // The javascript shim implements the syscall interface so that test\n             // output can be correctly reported.\n             if !builder.config.wasm_syscall {\n-                builder.info(&format!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n-                          test output may not be visible.\"));\n+                builder.info(&format!(\n+                    \"Libstd was built without `wasm_syscall` feature enabled: \\\n+                     test output may not be visible.\"\n+                ));\n             }\n \n             // On the wasm32-unknown-unknown target we're using LTO which is\n             // incompatible with `-C prefer-dynamic`, so disable that here\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n \n-            let node = builder.config.nodejs.as_ref()\n+            let node = builder\n+                .config\n+                .nodejs\n+                .as_ref()\n                 .expect(\"nodejs not configured\");\n-            let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n-                                 node.display(),\n-                                 builder.src.display());\n+            let runner = format!(\n+                \"{} {}/src/etc/wasm32-shim.js\",\n+                node.display(),\n+                builder.src.display()\n+            );\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n         } else if builder.remote_tested(target) {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      format!(\"{} run\",\n-                              builder.tool_exe(Tool::RemoteTestClient).display()));\n+            cargo.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                format!(\"{} run\", builder.tool_exe(Tool::RemoteTestClient).display()),\n+            );\n         }\n \n         let _folder = builder.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n+            format!(\n+                \"{}_stage{}-{}\",\n+                test_kind.subcommand(),\n+                compiler.stage,\n+                krate\n+            )\n         });\n-        builder.info(&format!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n-                &compiler.host, target));\n+        builder.info(&format!(\n+            \"{} {} stage{} ({} -> {})\",\n+            test_kind, krate, compiler.stage, &compiler.host, target\n+        ));\n         let _time = util::timeit(&builder);\n         try_run(builder, &mut cargo);\n     }\n@@ -1636,11 +1719,13 @@ impl Step for CrateRustdoc {\n         let compiler = builder.compiler(builder.top_stage, self.host);\n         let target = compiler.host;\n \n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 target,\n-                                                 test_kind.subcommand(),\n-                                                 \"src/tools/rustdoc\");\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            target,\n+            test_kind.subcommand(),\n+            \"src/tools/rustdoc\",\n+        );\n         if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n@@ -1654,24 +1739,26 @@ impl Step for CrateRustdoc {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _folder = builder.fold_output(|| {\n-            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n-        });\n-        builder.info(&format!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target));\n+        let _folder = builder\n+            .fold_output(|| format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage));\n+        builder.info(&format!(\n+            \"{} rustdoc stage{} ({} -> {})\",\n+            test_kind, compiler.stage, &compiler.host, target\n+        ));\n         let _time = util::timeit(&builder);\n \n         try_run(builder, &mut cargo);\n     }\n }\n \n fn envify(s: &str) -> String {\n-    s.chars().map(|c| {\n-        match c {\n+    s.chars()\n+        .map(|c| match c {\n             '-' => '_',\n             c => c,\n-        }\n-    }).flat_map(|c| c.to_uppercase()).collect()\n+        })\n+        .flat_map(|c| c.to_uppercase())\n+        .collect()\n }\n \n /// Some test suites are run inside emulators or on remote devices, and most\n@@ -1700,7 +1787,7 @@ impl Step for RemoteCopyLibs {\n         let compiler = self.compiler;\n         let target = self.target;\n         if !builder.remote_tested(target) {\n-            return\n+            return;\n         }\n \n         builder.ensure(compile::Test { compiler, target });\n@@ -1714,9 +1801,9 @@ impl Step for RemoteCopyLibs {\n         let tool = builder.tool_exe(Tool::RemoteTestClient);\n         let mut cmd = Command::new(&tool);\n         cmd.arg(\"spawn-emulator\")\n-           .arg(target)\n-           .arg(&server)\n-           .arg(builder.out.join(\"tmp\"));\n+            .arg(target)\n+            .arg(&server)\n+            .arg(builder.out.join(\"tmp\"));\n         if let Some(rootfs) = builder.qemu_rootfs(target) {\n             cmd.arg(rootfs);\n         }\n@@ -1727,9 +1814,7 @@ impl Step for RemoteCopyLibs {\n             let f = t!(f);\n             let name = f.file_name().into_string().unwrap();\n             if util::is_dylib(&name) {\n-                builder.run(Command::new(&tool)\n-                                  .arg(\"push\")\n-                                  .arg(f.path()));\n+                builder.run(Command::new(&tool).arg(\"push\").arg(f.path()));\n             }\n         }\n     }\n@@ -1762,17 +1847,21 @@ impl Step for Distcheck {\n \n         let mut cmd = Command::new(\"tar\");\n         cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::PlainSourceTarball))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n+            .arg(builder.ensure(dist::PlainSourceTarball))\n+            .arg(\"--strip-components=1\")\n+            .current_dir(&dir);\n         builder.run(&mut cmd);\n-        builder.run(Command::new(\"./configure\")\n-                         .args(&builder.config.configure_args)\n-                         .arg(\"--enable-vendor\")\n-                         .current_dir(&dir));\n-        builder.run(Command::new(build_helper::make(&builder.config.build))\n-                         .arg(\"check\")\n-                         .current_dir(&dir));\n+        builder.run(\n+            Command::new(\"./configure\")\n+                .args(&builder.config.configure_args)\n+                .arg(\"--enable-vendor\")\n+                .current_dir(&dir),\n+        );\n+        builder.run(\n+            Command::new(build_helper::make(&builder.config.build))\n+                .arg(\"check\")\n+                .current_dir(&dir),\n+        );\n \n         // Now make sure that rust-src has all of libstd's dependencies\n         builder.info(&format!(\"Distcheck rust-src\"));\n@@ -1782,17 +1871,19 @@ impl Step for Distcheck {\n \n         let mut cmd = Command::new(\"tar\");\n         cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::Src))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n+            .arg(builder.ensure(dist::Src))\n+            .arg(\"--strip-components=1\")\n+            .current_dir(&dir);\n         builder.run(&mut cmd);\n \n         let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-        builder.run(Command::new(&builder.initial_cargo)\n-                         .arg(\"generate-lockfile\")\n-                         .arg(\"--manifest-path\")\n-                         .arg(&toml)\n-                         .current_dir(&dir));\n+        builder.run(\n+            Command::new(&builder.initial_cargo)\n+                .arg(\"generate-lockfile\")\n+                .arg(\"--manifest-path\")\n+                .arg(&toml)\n+                .current_dir(&dir),\n+        );\n     }\n }\n \n@@ -1808,11 +1899,11 @@ impl Step for Bootstrap {\n     fn run(self, builder: &Builder) {\n         let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")\n-           .current_dir(builder.src.join(\"src/bootstrap\"))\n-           .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n-           .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-           .env(\"RUSTC\", &builder.initial_rustc);\n+            .current_dir(builder.src.join(\"src/bootstrap\"))\n+            .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n+            .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+            .env(\"RUSTC\", &builder.initial_rustc);\n         if let Some(flags) = option_env!(\"RUSTFLAGS\") {\n             // Use the same rustc flags for testing as for \"normal\" compilation,\n             // so that Cargo doesn\u2019t recompile the entire dependency graph every time:"}, {"sha": "5daf192e2db2ed2224d2520a74ba9c2de1645e2a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 79, "deletions": 45, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b39a1d6f1a30ba29f25d7141038b9a5bf0126e36/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=b39a1d6f1a30ba29f25d7141038b9a5bf0126e36", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use common::CompareMode;\n-use common::{expected_output_path, UI_STDERR, UI_STDOUT, UI_FIXED};\n+use common::{expected_output_path, UI_FIXED, UI_STDERR, UI_STDOUT};\n use common::{output_base_dir, output_base_name, output_testname_unique};\n use common::{Codegen, CodegenUnits, DebugInfoGdb, DebugInfoLldb, Rustdoc};\n use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n@@ -24,8 +24,8 @@ use regex::Regex;\n use rustfix::{apply_suggestions, get_suggestions_from_json};\n use util::{logv, PathBufExt};\n \n-use std::collections::{HashMap, HashSet, VecDeque};\n use std::collections::hash_map::DefaultHasher;\n+use std::collections::{HashMap, HashSet, VecDeque};\n use std::env;\n use std::ffi::OsString;\n use std::fmt;\n@@ -48,9 +48,7 @@ fn disable_error_reporting<F: FnOnce() -> R, R>(f: F) -> R {\n     }\n \n     lazy_static! {\n-        static ref LOCK: Mutex<()> = {\n-            Mutex::new(())\n-        };\n+        static ref LOCK: Mutex<()> = { Mutex::new(()) };\n     }\n     // Error mode is a global variable, so lock it so only one thread will change it\n     let _lock = LOCK.lock().unwrap();\n@@ -743,7 +741,8 @@ impl<'test> TestCx<'test> {\n             }\n \n             _ => {\n-                let rust_src_root = self.config\n+                let rust_src_root = self\n+                    .config\n                     .find_rust_src_root()\n                     .expect(\"Could not find Rust source root\");\n                 let rust_pp_module_rel_path = Path::new(\"./src/etc\");\n@@ -905,7 +904,8 @@ impl<'test> TestCx<'test> {\n         script_str.push_str(\"version\\n\");\n \n         // Switch LLDB into \"Rust mode\"\n-        let rust_src_root = self.config\n+        let rust_src_root = self\n+            .config\n             .find_rust_src_root()\n             .expect(\"Could not find Rust source root\");\n         let rust_pp_module_rel_path = Path::new(\"./src/etc/lldb_rust_formatters.py\");\n@@ -1052,7 +1052,8 @@ impl<'test> TestCx<'test> {\n \n         // Remove options that are either unwanted (-O) or may lead to duplicates due to RUSTFLAGS.\n         let options_to_remove = [\"-O\".to_owned(), \"-g\".to_owned(), \"--debuginfo\".to_owned()];\n-        let new_options = self.split_maybe_args(options)\n+        let new_options = self\n+            .split_maybe_args(options)\n             .into_iter()\n             .filter(|x| !options_to_remove.contains(x))\n             .collect::<Vec<String>>();\n@@ -1351,7 +1352,8 @@ impl<'test> TestCx<'test> {\n \n         let aux_dir = self.aux_output_dir_name();\n \n-        let rustdoc_path = self.config\n+        let rustdoc_path = self\n+            .config\n             .rustdoc_path\n             .as_ref()\n             .expect(\"--rustdoc-path passed\");\n@@ -1449,7 +1451,8 @@ impl<'test> TestCx<'test> {\n     /// For each `aux-build: foo/bar` annotation, we check to find the\n     /// file in a `auxiliary` directory relative to the test itself.\n     fn compute_aux_test_paths(&self, rel_ab: &str) -> TestPaths {\n-        let test_ab = self.testpaths\n+        let test_ab = self\n+            .testpaths\n             .file\n             .parent()\n             .expect(\"test file path has no parent\")\n@@ -1464,7 +1467,8 @@ impl<'test> TestCx<'test> {\n \n         TestPaths {\n             file: test_ab,\n-            relative_dir: self.testpaths\n+            relative_dir: self\n+                .testpaths\n                 .relative_dir\n                 .join(self.output_testname_unique())\n                 .join(\"auxiliary\")\n@@ -1617,16 +1621,20 @@ impl<'test> TestCx<'test> {\n         let mut rustc = if !is_rustdoc {\n             Command::new(&self.config.rustc_path)\n         } else {\n-            Command::new(&self.config\n-                .rustdoc_path\n-                .clone()\n-                .expect(\"no rustdoc built yet\"))\n+            Command::new(\n+                &self\n+                    .config\n+                    .rustdoc_path\n+                    .clone()\n+                    .expect(\"no rustdoc built yet\"),\n+            )\n         };\n         // FIXME Why is -L here?\n-        rustc.arg(input_file);//.arg(\"-L\").arg(&self.config.build_base);\n+        rustc.arg(input_file); //.arg(\"-L\").arg(&self.config.build_base);\n \n         // Optionally prevent default --target if specified in test compile-flags.\n-        let custom_target = self.props\n+        let custom_target = self\n+            .props\n             .compile_flags\n             .iter()\n             .any(|x| x.starts_with(\"--target\"));\n@@ -1670,7 +1678,8 @@ impl<'test> TestCx<'test> {\n                 }\n             }\n             Ui => {\n-                if !self.props\n+                if !self\n+                    .props\n                     .compile_flags\n                     .iter()\n                     .any(|s| s.starts_with(\"--error-format\"))\n@@ -1704,7 +1713,13 @@ impl<'test> TestCx<'test> {\n         }\n \n         if self.props.skip_codegen {\n-            assert!(!self.props.compile_flags.iter().any(|s| s.starts_with(\"--emit\")));\n+            assert!(\n+                !self\n+                    .props\n+                    .compile_flags\n+                    .iter()\n+                    .any(|s| s.starts_with(\"--emit\"))\n+            );\n             rustc.args(&[\"--emit\", \"metadata\"]);\n         }\n \n@@ -1812,7 +1827,8 @@ impl<'test> TestCx<'test> {\n \n     fn split_maybe_args(&self, argstr: &Option<String>) -> Vec<String> {\n         match *argstr {\n-            Some(ref s) => s.split(' ')\n+            Some(ref s) => s\n+                .split(' ')\n                 .filter_map(|s| {\n                     if s.chars().all(|c| c.is_whitespace()) {\n                         None\n@@ -2125,7 +2141,8 @@ impl<'test> TestCx<'test> {\n         }\n \n         let mut tested = 0;\n-        for _ in res.stdout\n+        for _ in res\n+            .stdout\n             .split('\\n')\n             .filter(|s| s.starts_with(\"test \"))\n             .inspect(|s| {\n@@ -2136,7 +2153,8 @@ impl<'test> TestCx<'test> {\n                         tested += 1;\n                         let mut iter = tmp[1].split(\"(line \");\n                         iter.next();\n-                        let line = iter.next()\n+                        let line = iter\n+                            .next()\n                             .unwrap_or(\")\")\n                             .split(')')\n                             .next()\n@@ -2290,7 +2308,8 @@ impl<'test> TestCx<'test> {\n \n             let full_string = format!(\"{}{}\", PREFIX, s.trim().to_owned());\n \n-            let parts: Vec<&str> = s.split(CGU_MARKER)\n+            let parts: Vec<&str> = s\n+                .split(CGU_MARKER)\n                 .map(str::trim)\n                 .filter(|s| !s.is_empty())\n                 .collect();\n@@ -2375,7 +2394,8 @@ impl<'test> TestCx<'test> {\n         // FIXME -- use non-incremental mode as an oracle? That doesn't apply\n         // to #[rustc_dirty] and clean tests I guess\n \n-        let revision = self.revision\n+        let revision = self\n+            .revision\n             .expect(\"incremental tests require a list of revisions\");\n \n         // Incremental workproduct directory should have already been created.\n@@ -2421,7 +2441,8 @@ impl<'test> TestCx<'test> {\n \n     fn run_rmake_test(&self) {\n         let cwd = env::current_dir().unwrap();\n-        let src_root = self.config\n+        let src_root = self\n+            .config\n             .src_base\n             .parent()\n             .unwrap()\n@@ -2438,8 +2459,10 @@ impl<'test> TestCx<'test> {\n         create_dir_all(&tmpdir).unwrap();\n \n         let host = &self.config.host;\n-        let make = if host.contains(\"bitrig\") || host.contains(\"dragonfly\")\n-            || host.contains(\"freebsd\") || host.contains(\"netbsd\")\n+        let make = if host.contains(\"bitrig\")\n+            || host.contains(\"dragonfly\")\n+            || host.contains(\"freebsd\")\n+            || host.contains(\"netbsd\")\n             || host.contains(\"openbsd\")\n         {\n             \"gmake\"\n@@ -2494,7 +2517,8 @@ impl<'test> TestCx<'test> {\n             // MSYS doesn't like passing flags of the form `/foo` as it thinks it's\n             // a path and instead passes `C:\\msys64\\foo`, so convert all\n             // `/`-arguments to MSVC here to `-` arguments.\n-            let cflags = self.config\n+            let cflags = self\n+                .config\n                 .cflags\n                 .split(' ')\n                 .map(|s| s.replace(\"/\", \"-\"))\n@@ -2516,7 +2540,8 @@ impl<'test> TestCx<'test> {\n             }\n         }\n \n-        let output = cmd.spawn()\n+        let output = cmd\n+            .spawn()\n             .and_then(read2_abbreviated)\n             .expect(\"failed to spawn `make`\");\n         if !output.status.success() {\n@@ -2557,7 +2582,8 @@ impl<'test> TestCx<'test> {\n         // if the user specified a format in the ui test\n         // print the output to the stderr file, otherwise extract\n         // the rendered error messages from json and print them\n-        let explicit = self.props\n+        let explicit = self\n+            .props\n             .compile_flags\n             .iter()\n             .any(|s| s.contains(\"--error-format\"));\n@@ -2587,22 +2613,27 @@ impl<'test> TestCx<'test> {\n             // don't test rustfix with nll right now\n         } else if self.props.run_rustfix {\n             // Apply suggestions from rustc to the code itself\n-            let unfixed_code = self.load_expected_output_from_path(&self.testpaths.file)\n+            let unfixed_code = self\n+                .load_expected_output_from_path(&self.testpaths.file)\n                 .unwrap();\n             let suggestions = get_suggestions_from_json(&proc_res.stderr, &HashSet::new()).unwrap();\n-            let fixed_code = apply_suggestions(&unfixed_code, &suggestions).expect(\n-                &format!(\"failed to apply suggestions for {:?} with rustfix\", self.testpaths.file)\n-            );\n+            let fixed_code = apply_suggestions(&unfixed_code, &suggestions).expect(&format!(\n+                \"failed to apply suggestions for {:?} with rustfix\",\n+                self.testpaths.file\n+            ));\n \n             errors += self.compare_output(\"fixed\", &fixed_code, &expected_fixed);\n         } else if !expected_fixed.is_empty() {\n-            panic!(\"the `// run-rustfix` directive wasn't found but a `*.fixed` \\\n-                    file was found\");\n+            panic!(\n+                \"the `// run-rustfix` directive wasn't found but a `*.fixed` \\\n+                 file was found\"\n+            );\n         }\n \n         if errors > 0 {\n             println!(\"To update references, rerun the tests and pass the `--bless` flag\");\n-            let relative_path_to_file = self.testpaths\n+            let relative_path_to_file = self\n+                .testpaths\n                 .relative_dir\n                 .join(self.testpaths.file.file_name().unwrap());\n             println!(\n@@ -2784,11 +2815,7 @@ impl<'test> TestCx<'test> {\n                  Test Name: {}\\n\\\n                  Expected:\\n{}\\n\\\n                  Actual:\\n{}\",\n-                extra_msg,\n-                expected_line,\n-                test_name,\n-                expected_content,\n-                normalize_all\n+                extra_msg, expected_line, test_name, expected_content, normalize_all\n             );\n         };\n \n@@ -2904,7 +2931,12 @@ impl<'test> TestCx<'test> {\n \n         if !path.exists() {\n             if let Some(CompareMode::Polonius) = self.config.compare_mode {\n-                path = expected_output_path(&self.testpaths, self.revision, &Some(CompareMode::Nll), kind);\n+                path = expected_output_path(\n+                    &self.testpaths,\n+                    self.revision,\n+                    &Some(CompareMode::Nll),\n+                    kind,\n+                );\n             }\n         }\n \n@@ -2973,7 +3005,8 @@ impl<'test> TestCx<'test> {\n         }\n \n         let mode = self.config.compare_mode.as_ref().map_or(\"\", |m| m.to_str());\n-        let output_file = self.output_base_name()\n+        let output_file = self\n+            .output_base_name()\n             .with_extra_extension(self.revision.unwrap_or(\"\"))\n             .with_extra_extension(mode)\n             .with_extra_extension(kind);\n@@ -3023,7 +3056,8 @@ impl<'test> TestCx<'test> {\n \n     fn create_stamp(&self) {\n         let mut f = File::create(::stamp(&self.config, self.testpaths, self.revision)).unwrap();\n-        f.write_all(compute_stamp_hash(&self.config).as_bytes()).unwrap();\n+        f.write_all(compute_stamp_hash(&self.config).as_bytes())\n+            .unwrap();\n     }\n }\n "}]}