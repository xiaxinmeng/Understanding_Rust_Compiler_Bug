{"sha": "ee3f75366cc1468a4ce8106976eeb9f42eb9965b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlM2Y3NTM2NmNjMTQ2OGE0Y2U4MTA2OTc2ZWViOWY0MmViOTk2NWI=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-07-27T18:03:57Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-02T22:49:00Z"}, "message": "Sha2: Re-write the Sha2 compression functions to improve performance.\n\nThe Sha2 compression functions were re-written to execute the message\nscheduling calculations in the same loop as the rest of the compression\nfunction. The compiler is able to generate much better code. Additionally,\ninnermost part of the compression functions were turned into macros to\nreduce code duplicate and to make the functions more concise.", "tree": {"sha": "cb9c0af5b9ec1492a5fce09a323fde3446614901", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9c0af5b9ec1492a5fce09a323fde3446614901"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee3f75366cc1468a4ce8106976eeb9f42eb9965b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee3f75366cc1468a4ce8106976eeb9f42eb9965b", "html_url": "https://github.com/rust-lang/rust/commit/ee3f75366cc1468a4ce8106976eeb9f42eb9965b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee3f75366cc1468a4ce8106976eeb9f42eb9965b/comments", "author": null, "committer": null, "parents": [{"sha": "654c536fec01d984f758ec32904354378aa3b792", "url": "https://api.github.com/repos/rust-lang/rust/commits/654c536fec01d984f758ec32904354378aa3b792", "html_url": "https://github.com/rust-lang/rust/commit/654c536fec01d984f758ec32904354378aa3b792"}], "stats": {"total": 193, "additions": 91, "deletions": 102}, "files": [{"sha": "fc420d7179fdb05060ce1be67e507d2a257b3748", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 91, "deletions": 102, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/ee3f75366cc1468a4ce8106976eeb9f42eb9965b/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee3f75366cc1468a4ce8106976eeb9f42eb9965b/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=ee3f75366cc1468a4ce8106976eeb9f42eb9965b", "patch": "@@ -8,11 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::uint;\n+\n use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, FixedBuffer,\n     FixedBuffer128, FixedBuffer64, StandardPadding};\n use digest::Digest;\n \n \n+// Sha-512 and Sha-256 use basically the same calculations which are implemented by these macros.\n+// Inlining the calculations seems to result in better generated code.\n+macro_rules! schedule_round( ($t:expr) => (\n+        W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n+    )\n+)\n+\n+macro_rules! sha2_round(\n+    ($A:ident, $B:ident, $C:ident, $D:ident,\n+     $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n+        {\n+            $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n+            $D += $H;\n+            $H += sum0($A) + maj($A, $B, $C);\n+        }\n+    )\n+)\n+\n+\n // BitCounter is a specialized structure intended simply for counting the\n // number of bits that have been processed by the SHA-2 512 family of functions.\n // It does very little overflow checking since such checking is not necessary\n@@ -117,15 +138,6 @@ impl Engine512State {\n             ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n         }\n \n-        let mut W = [0u64, ..80];\n-\n-        read_u64v_be(W.mut_slice(0, 16), data);\n-\n-        foreach t in range(16u, 80) {\n-            W[t] = sigma1(W[t - 2]) + W[t - 7] + sigma0(W[t - 15]) +\n-                W[t - 16];\n-        }\n-\n         let mut a = self.H0;\n         let mut b = self.H1;\n         let mut c = self.H2;\n@@ -135,48 +147,41 @@ impl Engine512State {\n         let mut g = self.H6;\n         let mut h = self.H7;\n \n-        let mut t = 0;\n-        \n-        foreach _ in range(0u, 10) {\n-            h += sum1(e) + ch(e, f, g) + K64[t] + W[t];\n-            d += h;\n-            h += sum0(a) + maj(a, b, c);\n-            t += 1;\n-\n-            g += sum1(d) + ch(d, e, f) + K64[t] + W[t];\n-            c += g;\n-            g += sum0(h) + maj(h, a, b);\n-            t += 1;\n-\n-            f += sum1(c) + ch(c, d, e) + K64[t] + W[t];\n-            b += f;\n-            f += sum0(g) + maj(g, h, a);\n-            t += 1;\n-\n-            e += sum1(b) + ch(b, c, d) + K64[t] + W[t];\n-            a += e;\n-            e += sum0(f) + maj(f, g, h);\n-            t += 1;\n-\n-            d += sum1(a) + ch(a, b, c) + K64[t] + W[t];\n-            h += d;\n-            d += sum0(e) + maj(e, f, g);\n-            t += 1;\n-\n-            c += sum1(h) + ch(h, a, b) + K64[t] + W[t];\n-            g += c;\n-            c += sum0(d) + maj(d, e, f);\n-            t += 1;\n-\n-            b += sum1(g) + ch(g, h, a) + K64[t] + W[t];\n-            f += b;\n-            b += sum0(c) + maj(c, d, e);\n-            t += 1;\n-\n-            a += sum1(f) + ch(f, g, h) + K64[t] + W[t];\n-            e += a;\n-            a += sum0(b) + maj(b, c, d);\n-            t += 1;\n+        let mut W = [0u64, ..80];\n+\n+        read_u64v_be(W.mut_slice(0, 16), data);\n+\n+        // Putting the message schedule inside the same loop as the round calculations allows for\n+        // the compiler to generate better code.\n+        for uint::range_step(0, 64, 8) |t| {\n+            schedule_round!(t + 16);\n+            schedule_round!(t + 17);\n+            schedule_round!(t + 18);\n+            schedule_round!(t + 19);\n+            schedule_round!(t + 20);\n+            schedule_round!(t + 21);\n+            schedule_round!(t + 22);\n+            schedule_round!(t + 23);\n+\n+            sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K64, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K64, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n+        }\n+\n+        for uint::range_step(64, 80, 8) |t| {\n+            sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K64, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K64, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n         }\n \n         self.H0 += a;\n@@ -523,15 +528,6 @@ impl Engine256State {\n             ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n         }\n \n-        let mut W = [0u32, ..80];\n-\n-        read_u32v_be(W.mut_slice(0, 16), data);\n-\n-        foreach t in range(16u, 64) {\n-            W[t] = sigma1(W[t - 2]) + W[t - 7] + sigma0(W[t - 15]) +\n-                W[t - 16];\n-        }\n-\n         let mut a = self.H0;\n         let mut b = self.H1;\n         let mut c = self.H2;\n@@ -541,48 +537,41 @@ impl Engine256State {\n         let mut g = self.H6;\n         let mut h = self.H7;\n \n-        let mut t = 0;\n-\n-        foreach _ in range(0u, 8) {\n-            h += sum1(e) + ch(e, f, g) + K32[t] + W[t];\n-            d += h;\n-            h += sum0(a) + maj(a, b, c);\n-            t += 1;\n-\n-            g += sum1(d) + ch(d, e, f) + K32[t] + W[t];\n-            c += g;\n-            g += sum0(h) + maj(h, a, b);\n-            t += 1;\n-\n-            f += sum1(c) + ch(c, d, e) + K32[t] + W[t];\n-            b += f;\n-            f += sum0(g) + maj(g, h, a);\n-            t += 1;\n-\n-            e += sum1(b) + ch(b, c, d) + K32[t] + W[t];\n-            a += e;\n-            e += sum0(f) + maj(f, g, h);\n-            t += 1;\n-\n-            d += sum1(a) + ch(a, b, c) + K32[t] + W[t];\n-            h += d;\n-            d += sum0(e) + maj(e, f, g);\n-            t += 1;\n-\n-            c += sum1(h) + ch(h, a, b) + K32[t] + W[t];\n-            g += c;\n-            c += sum0(d) + maj(d, e, f);\n-            t += 1;\n-\n-            b += sum1(g) + ch(g, h, a) + K32[t] + W[t];\n-            f += b;\n-            b += sum0(c) + maj(c, d, e);\n-            t += 1;\n-\n-            a += sum1(f) + ch(f, g, h) + K32[t] + W[t];\n-            e += a;\n-            a += sum0(b) + maj(b, c, d);\n-            t += 1;\n+        let mut W = [0u32, ..64];\n+\n+        read_u32v_be(W.mut_slice(0, 16), data);\n+\n+        // Putting the message schedule inside the same loop as the round calculations allows for\n+        // the compiler to generate better code.\n+        for uint::range_step(0, 48, 8) |t| {\n+            schedule_round!(t + 16);\n+            schedule_round!(t + 17);\n+            schedule_round!(t + 18);\n+            schedule_round!(t + 19);\n+            schedule_round!(t + 20);\n+            schedule_round!(t + 21);\n+            schedule_round!(t + 22);\n+            schedule_round!(t + 23);\n+\n+            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n+        }\n+\n+        for uint::range_step(48, 64, 8) |t| {\n+            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n         }\n \n         self.H0 += a;"}]}