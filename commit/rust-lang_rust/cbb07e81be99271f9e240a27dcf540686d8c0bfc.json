{"sha": "cbb07e81be99271f9e240a27dcf540686d8c0bfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYjA3ZTgxYmU5OTI3MWY5ZTI0MGEyN2RjZjU0MDY4NmQ4YzBiZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-22T05:30:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-22T05:30:30Z"}, "message": "auto merge of #17029 : alexcrichton/rust/vec-stable, r=aturon\n\nThe following methods, types, and names have become stable:\r\n\r\n* Vec\r\n* Vec::as_mut_slice\r\n* Vec::as_slice\r\n* Vec::capacity\r\n* Vec::clear\r\n* Vec::default\r\n* Vec::grow\r\n* Vec::insert\r\n* Vec::len\r\n* Vec::new\r\n* Vec::pop\r\n* Vec::push\r\n* Vec::remove\r\n* Vec::set_len\r\n* Vec::shrink_to_fit\r\n* Vec::truncate\r\n* Vec::with_capacity\r\n* vec::raw\r\n* vec::raw::from_buf\r\n* vec::raw::from_raw_parts\r\n\r\nThe following have become unstable:\r\n\r\n* Vec::dedup        // naming\r\n* Vec::from_fn      // naming and unboxed closures\r\n* Vec::get_mut      // will be removed for IndexMut\r\n* Vec::grow_fn      // unboxed closures and naming\r\n* Vec::retain       // unboxed closures\r\n* Vec::swap_remove  // uncertain naming\r\n* Vec::from_elem    // uncertain semantics\r\n* vec::unzip        // should be generic for all collections\r\n\r\nThe following have been deprecated\r\n\r\n* Vec::append - call .extend()\r\n* Vec::append_one - call .push()\r\n* Vec::from_slice - call .to_vec()\r\n* Vec::grow_set - call .grow() and then .push()\r\n* Vec::into_vec - move the vector instead\r\n* Vec::move_iter - renamed to iter_move()\r\n* Vec::push_all - call .extend()\r\n* Vec::to_vec - call .clone()\r\n* Vec:from_raw_parts - moved to raw::from_raw_parts\r\n\r\nThis is a breaking change in terms of the signature of the `Vec::grow` function.\r\nThe argument used to be taken by reference, but it is now taken by value. Code\r\nmust update by removing a leading `&` sigil or by calling `.clone()` to create a\r\nvalue.\r\n\r\n[breaking-change]", "tree": {"sha": "a0a2ce0e5d9e65137f445201cbcd01324ca0d275", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0a2ce0e5d9e65137f445201cbcd01324ca0d275"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbb07e81be99271f9e240a27dcf540686d8c0bfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbb07e81be99271f9e240a27dcf540686d8c0bfc", "html_url": "https://github.com/rust-lang/rust/commit/cbb07e81be99271f9e240a27dcf540686d8c0bfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbb07e81be99271f9e240a27dcf540686d8c0bfc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e5b62618cb5341139177c1ef62e2467affd041f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e5b62618cb5341139177c1ef62e2467affd041f", "html_url": "https://github.com/rust-lang/rust/commit/4e5b62618cb5341139177c1ef62e2467affd041f"}, {"sha": "0169218047dc989acf9ea25e3122b9c659acb6b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0169218047dc989acf9ea25e3122b9c659acb6b3", "html_url": "https://github.com/rust-lang/rust/commit/0169218047dc989acf9ea25e3122b9c659acb6b3"}], "stats": {"total": 458, "additions": 250, "deletions": 208}, "files": [{"sha": "f3e9177fc6e11bc3b1cb5da8904beeab338a799e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -273,8 +273,8 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                             format!(\"--target={}\", config.target),\n                             \"-L\".to_string(),\n                             aux_dir.as_str().unwrap().to_string());\n-        args.push_all_move(split_maybe_args(&config.target_rustcflags));\n-        args.push_all_move(split_maybe_args(&props.compile_flags));\n+        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n+        args.extend(split_maybe_args(&props.compile_flags).into_iter());\n         return ProcArgs {\n             prog: config.rustc_path.as_str().unwrap().to_string(),\n             args: args,\n@@ -321,8 +321,8 @@ actual:\\n\\\n                             config.build_base.as_str().unwrap().to_string(),\n                             \"-L\".to_string(),\n                             aux_dir.as_str().unwrap().to_string());\n-        args.push_all_move(split_maybe_args(&config.target_rustcflags));\n-        args.push_all_move(split_maybe_args(&props.compile_flags));\n+        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n+        args.extend(split_maybe_args(&props.compile_flags).into_iter());\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {\n             prog: config.rustc_path.as_str().unwrap().to_string(),\n@@ -1095,11 +1095,12 @@ fn compile_test_(config: &Config, props: &TestProps,\n                  testfile: &Path, extra_args: &[String]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_string(),\n-                         aux_dir.as_str().unwrap().to_string());\n+    let mut link_args = vec!(\"-L\".to_string(),\n+                             aux_dir.as_str().unwrap().to_string());\n+    link_args.extend(extra_args.iter().map(|s| s.clone()));\n     let args = make_compile_args(config,\n                                  props,\n-                                 link_args.append(extra_args),\n+                                 link_args,\n                                  |a, b| ThisFile(make_exe_name(a, b)), testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n@@ -1146,16 +1147,16 @@ fn compose_and_run_compiler(\n     for rel_ab in props.aux_builds.iter() {\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = header::load_props(&abs_ab);\n-        let crate_type = if aux_props.no_prefer_dynamic {\n+        let mut crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n             vec!(\"--crate-type=dylib\".to_string())\n         };\n+        crate_type.extend(extra_link_args.clone().into_iter());\n         let aux_args =\n             make_compile_args(config,\n                               &aux_props,\n-                              crate_type.append(\n-                                  extra_link_args.as_slice()),\n+                              crate_type,\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n                                   ThisDirectory(f.dir_path())\n@@ -1246,11 +1247,11 @@ fn make_compile_args(config: &Config,\n     };\n     args.push(path.as_str().unwrap().to_string());\n     if props.force_host {\n-        args.push_all_move(split_maybe_args(&config.host_rustcflags));\n+        args.extend(split_maybe_args(&config.host_rustcflags).into_iter());\n     } else {\n-        args.push_all_move(split_maybe_args(&config.target_rustcflags));\n+        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n     }\n-    args.push_all_move(split_maybe_args(&props.compile_flags));\n+    args.extend(split_maybe_args(&props.compile_flags).into_iter());\n     return ProcArgs {\n         prog: config.rustc_path.as_str().unwrap().to_string(),\n         args: args,\n@@ -1267,10 +1268,9 @@ fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> Path {\n fn make_exe_name(config: &Config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n     if !os::consts::EXE_SUFFIX.is_empty() {\n-        match f.filename().map(|s| Vec::from_slice(s).append(os::consts::EXE_SUFFIX.as_bytes())) {\n-            Some(v) => f.set_filename(v),\n-            None => ()\n-        }\n+        let mut fname = f.filename().unwrap().to_vec();\n+        fname.extend(os::consts::EXE_SUFFIX.bytes());\n+        f.set_filename(fname);\n     }\n     f\n }\n@@ -1286,7 +1286,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     args.push(exe_file.as_str().unwrap().to_string());\n \n     // Add the arguments in the run_flags directive\n-    args.push_all_move(split_maybe_args(&props.run_flags));\n+    args.extend(split_maybe_args(&props.run_flags).into_iter());\n \n     let prog = args.remove(0).unwrap();\n     return ProcArgs {\n@@ -1381,12 +1381,10 @@ fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> Path {\n }\n \n fn aux_output_dir_name(config: &Config, testfile: &Path) -> Path {\n-    let mut f = output_base_name(config, testfile);\n-    match f.filename().map(|s| Vec::from_slice(s).append(b\".libaux\")) {\n-        Some(v) => f.set_filename(v),\n-        None => ()\n-    }\n-    f\n+    let f = output_base_name(config, testfile);\n+    let mut fname = f.filename().unwrap().to_vec();\n+    fname.extend(\"libaux\".bytes());\n+    f.with_filename(fname)\n }\n \n fn output_testname(testfile: &Path) -> Path {\n@@ -1598,22 +1596,25 @@ fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n     if suffix.len() == 0 {\n         (*p).clone()\n     } else {\n-        let stem = p.filestem().unwrap();\n-        p.with_filename(Vec::from_slice(stem).append(b\"-\").append(suffix.as_bytes()))\n+        let mut stem = p.filestem().unwrap().to_vec();\n+        stem.extend(\"-\".bytes());\n+        stem.extend(suffix.bytes());\n+        p.with_filename(stem)\n     }\n }\n \n fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_string(),\n-                         aux_dir.as_str().unwrap().to_string());\n+    let mut link_args = vec!(\"-L\".to_string(),\n+                             aux_dir.as_str().unwrap().to_string());\n     let llvm_args = vec!(\"--emit=bc,obj\".to_string(),\n                          \"--crate-type=lib\".to_string());\n+    link_args.extend(llvm_args.into_iter());\n     let args = make_compile_args(config,\n                                  props,\n-                                 link_args.append(llvm_args.as_slice()),\n+                                 link_args,\n                                  |a, b| ThisDirectory(output_base_name(a, b).dir_path()),\n                                  testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)"}, {"sha": "2ffe22cba7553b00660beec8f188860c82fc4e02", "filename": "src/doc/rust.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -3833,8 +3833,9 @@ fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n        return vec![];\n     }\n     let first: B = f(xs[0].clone());\n-    let rest: Vec<B> = map(f, xs.slice(1, xs.len()));\n-    return vec![first].append(rest.as_slice());\n+    let mut rest: Vec<B> = map(f, xs.slice(1, xs.len()));\n+    rest.insert(0, first);\n+    return rest;\n }\n ~~~~\n "}, {"sha": "60c9dfcff187c1c03882d8e224130658286af35e", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -631,7 +631,7 @@ impl Bitv {\n         let old_size = self.storage.len();\n         let size = (size + uint::BITS - 1) / uint::BITS;\n         if old_size < size {\n-            self.storage.grow(size - old_size, &0);\n+            self.storage.grow(size - old_size, 0);\n         }\n     }\n \n@@ -687,7 +687,7 @@ impl Bitv {\n         // Allocate new words, if needed\n         if new_nwords > self.storage.len() {\n           let to_add = new_nwords - self.storage.len();\n-          self.storage.grow(to_add, &full_value);\n+          self.storage.grow(to_add, full_value);\n         }\n         // Adjust internal bit count\n         self.nbits = new_nbits;"}, {"sha": "44fe962fad4a06ed44b9b3524a833ffe9b6b648b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -283,7 +283,11 @@ pub trait CloneableVector<T> {\n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> { Vec::from_slice(*self) }\n+    fn to_vec(&self) -> Vec<T> {\n+        let mut vector = Vec::with_capacity(self.len());\n+        vector.push_all(*self);\n+        vector\n+    }\n \n     #[inline(always)]\n     fn into_vec(self) -> Vec<T> { self.to_vec() }\n@@ -1039,7 +1043,7 @@ mod tests {\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = vec![];\n-        v.grow(2u, &1i);\n+        v.grow(2u, 1i);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 2u);\n@@ -1048,7 +1052,7 @@ mod tests {\n         }\n \n         // Test on-heap grow().\n-        v.grow(3u, &2i);\n+        v.grow(3u, 2i);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 5u);"}, {"sha": "f677b170bb3674dfb7c4f72d5fbb223c19f522ad", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -67,6 +67,7 @@ use core::prelude::{range};\n use {Deque, MutableSeq};\n use hash;\n use ringbuf::RingBuf;\n+use slice::CloneableVector;\n use string::String;\n use unicode;\n use vec::Vec;\n@@ -754,7 +755,7 @@ pub trait StrAllocating: Str {\n     #[inline]\n     fn to_owned(&self) -> String {\n         unsafe {\n-            mem::transmute(Vec::from_slice(self.as_slice().as_bytes()))\n+            mem::transmute(self.as_slice().as_bytes().to_vec())\n         }\n     }\n "}, {"sha": "bb66d271ee4d43e37ff17f391c668bfd221d248f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -23,6 +23,7 @@ use core::raw::Slice as RawSlice;\n \n use {Mutable, MutableSeq};\n use hash;\n+use slice::CloneableVector;\n use str;\n use str::{CharRange, StrAllocating, MaybeOwned, Owned};\n use str::Slice as MaybeOwnedSlice; // So many `Slice`s...\n@@ -75,9 +76,7 @@ impl String {\n     /// ```\n     #[inline]\n     pub fn from_str(string: &str) -> String {\n-        String {\n-            vec: Vec::from_slice(string.as_bytes())\n-        }\n+        String { vec: string.as_bytes().to_vec() }\n     }\n \n     /// Deprecated. Replaced by `string::raw::from_parts`"}, {"sha": "d5ca48e605a644b30d021e6211e7b0dc4bccba51", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 63, "deletions": 41, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -99,6 +99,7 @@ use slice::{Items, MutItems};\n /// to use `Vec::with_capacity` whenever possible to specify how big the vector\n /// is expected to get.\n #[unsafe_no_drop_flag]\n+#[stable]\n pub struct Vec<T> {\n     len: uint,\n     cap: uint,\n@@ -116,6 +117,7 @@ impl<T> Vec<T> {\n     /// let mut vec: Vec<int> = Vec::new();\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn new() -> Vec<T> {\n         // We want ptr to never be NULL so instead we set it to some arbitrary\n         // non-null value which is fine since we never call deallocate on the ptr\n@@ -152,6 +154,7 @@ impl<T> Vec<T> {\n     /// vec.push(11);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n             Vec { len: 0, cap: uint::MAX, ptr: EMPTY as *mut T }\n@@ -177,6 +180,8 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![0, 2, 4]);\n     /// ```\n     #[inline]\n+    #[unstable = \"the naming is uncertain as well as this migrating to unboxed \\\n+                  closures in the future\"]\n     pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -229,6 +234,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n+    #[experimental]\n     pub unsafe fn from_raw_parts(length: uint, capacity: uint,\n                                  ptr: *mut T) -> Vec<T> {\n         Vec { len: length, cap: capacity, ptr: ptr }\n@@ -249,6 +255,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n     #[inline]\n+    #[experimental]\n     pub fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n@@ -266,36 +273,18 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n-    /// Iterates over the `second` vector, copying each element and appending it to\n-    /// the `first`. Afterwards, the `first` is then returned for use again.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2i];\n-    /// let vec = vec.append([3i, 4i]);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n-    /// ```\n+    /// Deprecated, call `extend` instead.\n     #[inline]\n+    #[deprecated = \"this function has been deprecated in favor of extend()\"]\n     pub fn append(mut self, second: &[T]) -> Vec<T> {\n         self.push_all(second);\n         self\n     }\n \n-    /// Constructs a `Vec` by cloning elements of a slice.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let slice = [1i, 2, 3];\n-    /// let vec = Vec::from_slice(slice);\n-    /// ```\n+    /// Deprecated, call `to_vec()` instead\n     #[inline]\n-    pub fn from_slice(values: &[T]) -> Vec<T> {\n-        let mut vector = Vec::new();\n-        vector.push_all(values);\n-        vector\n-    }\n+    #[deprecated = \"this function has been deprecated in favor of to_vec()\"]\n+    pub fn from_slice(values: &[T]) -> Vec<T> { values.to_vec() }\n \n     /// Constructs a `Vec` with copies of a value.\n     ///\n@@ -307,6 +296,7 @@ impl<T: Clone> Vec<T> {\n     /// println!(\"{}\", vec); // prints [hi, hi, hi]\n     /// ```\n     #[inline]\n+    #[unstable = \"this functionality may become more generic over all collections\"]\n     pub fn from_elem(length: uint, value: T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -333,6 +323,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n+    #[experimental]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve_additional(other.len());\n \n@@ -359,15 +350,16 @@ impl<T: Clone> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![\"hello\"];\n-    /// vec.grow(2, &(\"world\"));\n+    /// vec.grow(2, \"world\");\n     /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n     /// ```\n-    pub fn grow(&mut self, n: uint, value: &T) {\n+    #[stable]\n+    pub fn grow(&mut self, n: uint, value: T) {\n         self.reserve_additional(n);\n         let mut i: uint = 0u;\n \n         while i < n {\n-            self.push((*value).clone());\n+            self.push(value.clone());\n             i += 1u;\n         }\n     }\n@@ -382,15 +374,17 @@ impl<T: Clone> Vec<T> {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut vec = vec![\"a\", \"b\", \"c\"];\n     /// vec.grow_set(1, &(\"fill\"), \"d\");\n     /// vec.grow_set(4, &(\"fill\"), \"e\");\n     /// assert_eq!(vec, vec![\"a\", \"d\", \"c\", \"fill\", \"e\"]);\n     /// ```\n+    #[deprecated = \"call .grow() and .push() manually instead\"]\n     pub fn grow_set(&mut self, index: uint, initval: &T, value: T) {\n         let l = self.len();\n         if index >= l {\n-            self.grow(index - l + 1u, initval);\n+            self.grow(index - l + 1u, initval.clone());\n         }\n         *self.get_mut(index) = value;\n     }\n@@ -409,6 +403,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(even, vec![2i, 4]);\n     /// assert_eq!(odd, vec![1i, 3]);\n     /// ```\n+    #[experimental]\n     pub fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts = Vec::new();\n         let mut rights = Vec::new();\n@@ -427,9 +422,7 @@ impl<T: Clone> Vec<T> {\n \n #[unstable]\n impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> {\n-        Vec::from_slice(self.as_slice())\n-    }\n+    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten\n@@ -449,6 +442,7 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n+#[experimental = \"waiting on Index stability\"]\n impl<T> Index<uint,T> for Vec<T> {\n     #[inline]\n     #[allow(deprecated)] // allow use of get\n@@ -506,6 +500,8 @@ impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n         self.as_mut_slice().slice_mut_(start, end)\n     }\n }\n+\n+#[experimental = \"waiting on FromIterator stability\"]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n@@ -518,6 +514,7 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n+#[experimental = \"waiting on Extendable stability\"]\n impl<T> Extendable<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n@@ -529,43 +526,52 @@ impl<T> Extendable<T> for Vec<T> {\n     }\n }\n \n+#[unstable = \"waiting on PartialEq stability\"]\n impl<T: PartialEq> PartialEq for Vec<T> {\n     #[inline]\n     fn eq(&self, other: &Vec<T>) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n+#[unstable = \"waiting on PartialOrd stability\"]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(&other.as_slice())\n     }\n }\n \n+#[unstable = \"waiting on Eq stability\"]\n impl<T: Eq> Eq for Vec<T> {}\n \n+#[experimental]\n impl<T: PartialEq, V: Slice<T>> Equiv<V> for Vec<T> {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+#[unstable = \"waiting on Ord stability\"]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n }\n \n+#[experimental = \"waiting on Collection stability\"]\n impl<T> Collection for Vec<T> {\n     #[inline]\n+    #[stable]\n     fn len(&self) -> uint {\n         self.len\n     }\n }\n \n impl<T: Clone> CloneableVector<T> for Vec<T> {\n+    #[deprecated = \"call .clone() instead\"]\n     fn to_vec(&self) -> Vec<T> { self.clone() }\n+    #[deprecated = \"move the vector instead\"]\n     fn into_vec(self) -> Vec<T> { self }\n }\n \n@@ -600,6 +606,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.cap\n     }\n@@ -683,6 +690,7 @@ impl<T> Vec<T> {\n     /// let mut vec = vec![1i, 2, 3];\n     /// vec.shrink_to_fit();\n     /// ```\n+    #[stable]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -706,17 +714,9 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Appends one element to the vector provided. The vector itself is then\n-    /// returned for use again.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2];\n-    /// let vec = vec.append_one(3);\n-    /// assert_eq!(vec, vec![1, 2, 3]);\n-    /// ```\n+    /// Deprecated, call `push` instead\n     #[inline]\n+    #[deprecated = \"call .push() instead\"]\n     pub fn append_one(mut self, x: T) -> Vec<T> {\n         self.push(x);\n         self\n@@ -734,6 +734,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n+    #[unstable = \"waiting on failure semantics\"]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -757,6 +758,7 @@ impl<T> Vec<T> {\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -796,7 +798,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-\n     /// Sets the length of a vector.\n     ///\n     /// This will explicitly set the size of the vector, without actually\n@@ -812,6 +813,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[stable]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n     }\n@@ -850,6 +852,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1i, 4, 3]);\n     /// ```\n     #[inline]\n+    #[unstable = \"this is likely to be moved to actual indexing\"]\n     pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n         &mut self.as_mut_slice()[index]\n     }\n@@ -1020,6 +1023,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v.swap_remove(2), None);\n     /// ```\n     #[inline]\n+    #[unstable = \"the naming of this function may be altered\"]\n     pub fn swap_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n@@ -1088,6 +1092,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n+    #[unstable = \"failure semantics need settling\"]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -1124,6 +1129,7 @@ impl<T> Vec<T> {\n     /// // v is unchanged:\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n+    #[unstable = \"failure semantics need settling\"]\n     pub fn remove(&mut self, index: uint) -> Option<T> {\n         let len = self.len();\n         if index < len {\n@@ -1155,11 +1161,13 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut vec = vec![box 1i];\n     /// vec.push_all_move(vec![box 2, box 3, box 4]);\n     /// assert_eq!(vec, vec![box 1, box 2, box 3, box 4]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use .extend(other.into_iter())\"]\n     pub fn push_all_move(&mut self, other: Vec<T>) {\n         self.extend(other.into_iter());\n     }\n@@ -1410,6 +1418,7 @@ impl<T> Vec<T> {\n     /// vec.retain(|x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n+    #[unstable = \"the closure argument may become an unboxed closure\"]\n     pub fn retain(&mut self, f: |&T| -> bool) {\n         let len = self.len();\n         let mut del = 0u;\n@@ -1441,6 +1450,7 @@ impl<T> Vec<T> {\n     /// vec.grow_fn(3, |i| i);\n     /// assert_eq!(vec, vec![0, 1, 0, 1, 2]);\n     /// ```\n+    #[unstable = \"this function may be renamed or change to unboxed closures\"]\n     pub fn grow_fn(&mut self, n: uint, f: |uint| -> T) {\n         self.reserve_additional(n);\n         for i in range(0u, n) {\n@@ -1467,8 +1477,10 @@ impl<T:Ord> Vec<T> {\n     }\n }\n \n+#[experimental = \"waiting on Mutable stability\"]\n impl<T> Mutable for Vec<T> {\n     #[inline]\n+    #[stable]\n     fn clear(&mut self) {\n         self.truncate(0)\n     }\n@@ -1499,6 +1511,7 @@ impl<T: PartialEq> Vec<T> {\n     /// vec.dedup();\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n+    #[unstable = \"this function may be renamed\"]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1596,6 +1609,7 @@ impl<T> Slice<T> for Vec<T> {\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]\n+    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe { mem::transmute(RawSlice { data: self.as_ptr(), len: self.len }) }\n     }\n@@ -1627,18 +1641,21 @@ impl<T> Drop for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for Vec<T> {\n     fn default() -> Vec<T> {\n         Vec::new()\n     }\n }\n \n+#[experimental = \"waiting on Show stability\"]\n impl<T:fmt::Show> fmt::Show for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_slice().fmt(f)\n     }\n }\n \n+#[experimental = \"waiting on MutableSeq stability\"]\n impl<T> MutableSeq<T> for Vec<T> {\n     /// Appends an element to the back of a collection.\n     ///\n@@ -1654,6 +1671,7 @@ impl<T> MutableSeq<T> for Vec<T> {\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n     #[inline]\n+    #[stable]\n     fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the address space running out\n@@ -1680,6 +1698,7 @@ impl<T> MutableSeq<T> for Vec<T> {\n     }\n \n     #[inline]\n+    #[stable]\n     fn pop(&mut self) -> Option<T> {\n         if self.len == 0 {\n             None\n@@ -1765,6 +1784,7 @@ impl<T> Drop for MoveItems<T> {\n /// vector contains the first element of the i-th tuple of the input iterator,\n /// and the i-th element of the second vector contains the second element\n /// of the i-th tuple of the input iterator.\n+#[unstable = \"this functionality may become more generic over time\"]\n pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n     let (lo, _) = iter.size_hint();\n     let mut ts = Vec::with_capacity(lo);\n@@ -1777,6 +1797,7 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n }\n \n /// Unsafe vector operations.\n+#[unstable]\n pub mod raw {\n     use super::Vec;\n     use core::ptr;\n@@ -1786,6 +1807,7 @@ pub mod raw {\n     /// The elements of the buffer are copied into the vector without cloning,\n     /// as if `ptr::read()` were called on them.\n     #[inline]\n+    #[unstable]\n     pub unsafe fn from_buf<T>(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);"}, {"sha": "94e89dc6043cecd3fd43f2e71dab4be2a583d1ef", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -170,7 +170,7 @@ impl<'a,T:Clone> MaybeOwnedVector<'a,T> {\n     pub fn into_vec(self) -> Vec<T> {\n         match self {\n             Growable(v) => v,\n-            Borrowed(v) => Vec::from_slice(v),\n+            Borrowed(v) => v.to_vec(),\n         }\n     }\n }"}, {"sha": "648aa8668144b22610d082ff0d81545c5a769ce8", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -87,7 +87,7 @@ impl Writer for SeekableMemWriter {\n             // currently are\n             let difference = self.pos as i64 - self.buf.len() as i64;\n             if difference > 0 {\n-                self.buf.grow(difference as uint, &0);\n+                self.buf.grow(difference as uint, 0);\n             }\n \n             // Figure out what bytes will be used to overwrite what's currently"}, {"sha": "91c3da001628e62f300689da9090bd580e522e28", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -156,7 +156,7 @@ impl<'r> Compiler<'r> {\n             Capture(cap, name, x) => {\n                 let len = self.names.len();\n                 if cap >= len {\n-                    self.names.grow(10 + cap - len, &None)\n+                    self.names.grow(10 + cap - len, None)\n                 }\n                 *self.names.get_mut(cap) = name;\n "}, {"sha": "7f4289b128afeac769bd047362fef6bd2d72a0d2", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -986,9 +986,9 @@ fn combine_ranges(unordered: Vec<(char, char)>) -> Vec<(char, char)> {\n // (or any of their negated forms). Note that this does not handle negation.\n fn perl_unicode_class(which: char) -> Vec<(char, char)> {\n     match which.to_lowercase() {\n-        'd' => Vec::from_slice(PERLD),\n-        's' => Vec::from_slice(PERLS),\n-        'w' => Vec::from_slice(PERLW),\n+        'd' => PERLD.to_vec(),\n+        's' => PERLS.to_vec(),\n+        'w' => PERLW.to_vec(),\n         _ => unreachable!(),\n     }\n }\n@@ -997,7 +997,7 @@ fn perl_unicode_class(which: char) -> Vec<(char, char)> {\n // `Cat` expression will never be a direct child of another `Cat` expression.\n fn concat_flatten(x: Ast, y: Ast) -> Ast {\n     match (x, y) {\n-        (Cat(mut xs), Cat(ys)) => { xs.push_all_move(ys); Cat(xs) }\n+        (Cat(mut xs), Cat(ys)) => { xs.extend(ys.into_iter()); Cat(xs) }\n         (Cat(mut xs), ast) => { xs.push(ast); Cat(xs) }\n         (ast, Cat(mut xs)) => { xs.insert(0, ast); Cat(xs) }\n         (ast1, ast2) => Cat(vec!(ast1, ast2)),\n@@ -1019,7 +1019,7 @@ fn is_valid_cap(c: char) -> bool {\n \n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n     match classes.binary_search(|&(s, _)| s.cmp(&name)) {\n-        slice::Found(i) => Some(Vec::from_slice(classes[i].val1())),\n+        slice::Found(i) => Some(classes[i].val1().to_vec()),\n         slice::NotFound(_) => None,\n     }\n }"}, {"sha": "cc6a8e27cda4aa727bd02e922682958c69549c8a", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -133,7 +133,7 @@ impl<'a> NfaGen<'a> {\n         let init_groups = self.vec_expr(range(0, num_cap_locs),\n                                         |cx, _| cx.expr_none(self.sp));\n \n-        let prefix_lit = Rc::new(Vec::from_slice(self.prog.prefix.as_slice().as_bytes()));\n+        let prefix_lit = Rc::new(self.prog.prefix.as_slice().as_bytes().to_vec());\n         let prefix_bytes = self.cx.expr_lit(self.sp, ast::LitBinary(prefix_lit));\n \n         let check_prefix = self.check_prefix();"}, {"sha": "660b6c7ade2b2e4a552c9c052e6562877d26c09f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -505,7 +505,7 @@ fn external_path(cx: &DocContext, name: &str, substs: &subst::Substs) -> Path {\n                     .iter()\n                     .filter_map(|v| v.clean(cx))\n                     .collect();\n-    let types = Vec::from_slice(substs.types.get_slice(subst::TypeSpace));\n+    let types = substs.types.get_slice(subst::TypeSpace).to_vec();\n     let types = types.clean(cx);\n     Path {\n         global: false,\n@@ -661,8 +661,8 @@ impl<'a> Clean<Generics> for (&'a ty::Generics, subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         let (me, space) = *self;\n         Generics {\n-            type_params: Vec::from_slice(me.types.get_slice(space)).clean(cx),\n-            lifetimes: Vec::from_slice(me.regions.get_slice(space)).clean(cx),\n+            type_params: me.types.get_slice(space).to_vec().clean(cx),\n+            lifetimes: me.regions.get_slice(space).to_vec().clean(cx),\n         }\n     }\n }\n@@ -991,7 +991,7 @@ impl Clean<Item> for ty::Method {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n-                    inputs: Vec::from_slice(self.fty.sig.inputs.slice_from(1)),\n+                    inputs: self.fty.sig.inputs.slice_from(1).to_vec(),\n                     ..self.fty.sig.clone()\n                 };\n                 let s = match s {"}, {"sha": "8b72bd9e10283a6cbe7832feebc62e21524ee312", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -183,8 +183,8 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let p_16: Vec<u16> = p.as_str().unwrap().utf16_units().collect();\n-            let p_16 = p_16.append_one(0);\n+            let mut p_16: Vec<u16> = p.as_str().unwrap().utf16_units().collect();\n+            p_16.push(0);\n             let handle = unsafe {\n                 libc::CreateFileW(p_16.as_ptr(),\n                                   libc::FILE_GENERIC_READ |"}, {"sha": "c831015e5393683d05829849010bd3db3e9726ab", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -740,8 +740,9 @@ impl<'a> SourceCollector<'a> {\n             root_path.push_str(\"../\");\n         });\n \n-        cur.push(Vec::from_slice(p.filename().expect(\"source has no filename\"))\n-                 .append(b\".html\"));\n+        let mut fname = p.filename().expect(\"source has no filename\").to_vec();\n+        fname.extend(\".html\".bytes());\n+        cur.push(fname);\n         let mut w = BufferedWriter::new(try!(File::create(&cur)));\n \n         let title = format!(\"{} -- source\", cur.filename_display());"}, {"sha": "c0a17a720147377c2608a8655a44d178bf441e04", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -47,6 +47,7 @@ mod imp {\n     use core::prelude::*;\n \n     use alloc::boxed::Box;\n+    use collections::slice::CloneableVector;\n     use collections::vec::Vec;\n     use core::mem;\n     use core::slice;\n@@ -106,7 +107,7 @@ mod imp {\n             let mut len = 0;\n             while *base.offset(len) != 0 { len += 1; }\n             slice::raw::buf_as_slice(base, len as uint, |slice| {\n-                Vec::from_slice(slice)\n+                slice.to_vec()\n             })\n         })\n     }"}, {"sha": "d572d8ce58a53ef1b153b1c0de792587ac605140", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -655,7 +655,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n \n         // see comments in StreamWatcher::write for why we may allocate a buffer\n         // here.\n-        let data = if guard.can_timeout {Some(Vec::from_slice(buf))} else {None};\n+        let data = if guard.can_timeout {Some(buf.to_vec())} else {None};\n         let uv_buf = if guard.can_timeout {\n             slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n         } else {"}, {"sha": "de49fd6cf0986539483a728bc68ad926a4c36f04", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -159,7 +159,7 @@ impl StreamWatcher {\n         //\n         // To do this, the write context has an optionally owned vector of\n         // bytes.\n-        let data = if may_timeout {Some(Vec::from_slice(buf))} else {None};\n+        let data = if may_timeout {Some(buf.to_vec())} else {None};\n         let uv_buf = if may_timeout {\n             slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n         } else {"}, {"sha": "fe2b8a15c7375387c96f0193ac794f4cd25a4cf8", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -21,8 +21,7 @@ use mem;\n use option::{Option, Some, None};\n use slice::{ImmutableSlice, MutableSlice, Slice};\n use str::{Str, StrSlice};\n-use str;\n-use string::String;\n+use string::{mod, String};\n use to_string::IntoStr;\n use vec::Vec;\n \n@@ -113,7 +112,7 @@ impl Ascii {\n     /// Check if the character is a letter or number\n     #[inline]\n     pub fn is_alphanumeric(&self) -> bool {\n-        self.is_alpha() || self.is_digit()\n+        self.is_alphabetic() || self.is_digit()\n     }\n \n     /// Check if the character is a space or horizontal tab\n@@ -169,7 +168,7 @@ impl Ascii {\n     /// Checks if the character is punctuation\n     #[inline]\n     pub fn is_punctuation(&self) -> bool {\n-        self.is_graph() && !self.is_alnum()\n+        self.is_graph() && !self.is_alphanumeric()\n     }\n \n     /// Checks if the character is a valid hex digit\n@@ -338,12 +337,12 @@ impl<'a> AsciiStr for &'a [Ascii] {\n \n     #[inline]\n     fn to_lower(&self) -> Vec<Ascii> {\n-        self.iter().map(|a| a.to_lower()).collect()\n+        self.iter().map(|a| a.to_lowercase()).collect()\n     }\n \n     #[inline]\n     fn to_upper(&self) -> Vec<Ascii> {\n-        self.iter().map(|a| a.to_upper()).collect()\n+        self.iter().map(|a| a.to_uppercase()).collect()\n     }\n \n     #[inline]\n@@ -410,13 +409,13 @@ impl<'a> AsciiExt<String> for &'a str {\n     #[inline]\n     fn to_ascii_upper(&self) -> String {\n         // Vec<u8>::to_ascii_upper() preserves the UTF-8 invariant.\n-        unsafe { str::raw::from_utf8_owned(self.as_bytes().to_ascii_upper()) }\n+        unsafe { string::raw::from_utf8(self.as_bytes().to_ascii_upper()) }\n     }\n \n     #[inline]\n     fn to_ascii_lower(&self) -> String {\n         // Vec<u8>::to_ascii_lower() preserves the UTF-8 invariant.\n-        unsafe { str::raw::from_utf8_owned(self.as_bytes().to_ascii_lower()) }\n+        unsafe { string::raw::from_utf8(self.as_bytes().to_ascii_lower()) }\n     }\n \n     #[inline]\n@@ -429,13 +428,13 @@ impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_upper(self) -> String {\n         // Vec<u8>::into_ascii_upper() preserves the UTF-8 invariant.\n-        unsafe { str::raw::from_utf8_owned(self.into_bytes().into_ascii_upper()) }\n+        unsafe { string::raw::from_utf8(self.into_bytes().into_ascii_upper()) }\n     }\n \n     #[inline]\n     fn into_ascii_lower(self) -> String {\n         // Vec<u8>::into_ascii_lower() preserves the UTF-8 invariant.\n-        unsafe { str::raw::from_utf8_owned(self.into_bytes().into_ascii_lower()) }\n+        unsafe { string::raw::from_utf8(self.into_bytes().into_ascii_lower()) }\n     }\n }\n "}, {"sha": "b0604e1316304fb855771ea0ab22d222e719d7f4", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -1288,7 +1288,7 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let s: String = map.get_copy(&1);\n     /// ```\n     pub fn get_copy(&self, k: &K) -> V {\n-        (*self.get(k)).clone()\n+        self[*k].clone()\n     }\n }\n \n@@ -1325,6 +1325,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n     #[inline]\n+    #[allow(deprecated)]\n     fn index<'a>(&'a self, index: &K) -> &'a V {\n         self.get(index)\n     }"}, {"sha": "45ca633b41f9a62862b52692f9ae9c93cd409dfb", "filename": "src/libstd/collections/hashmap/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -846,8 +846,8 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n                                 (full.hash(), k.clone(), v.clone())\n                             };\n                             *new_buckets.raw.hash = h.inspect();\n-                            mem::overwrite(new_buckets.raw.key, k);\n-                            mem::overwrite(new_buckets.raw.val, v);\n+                            ptr::write(new_buckets.raw.key, k);\n+                            ptr::write(new_buckets.raw.val, v);\n                         }\n                         Empty(..) => {\n                             *new_buckets.raw.hash = EMPTY_BUCKET;"}, {"sha": "e8d570f30e614a808c845c456eed44376ec2fe99", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -281,6 +281,7 @@ pub mod dl {\n #[cfg(target_os = \"windows\")]\n pub mod dl {\n     use c_str::ToCStr;\n+    use collections::MutableSeq;\n     use iter::Iterator;\n     use libc;\n     use os;\n@@ -295,8 +296,8 @@ pub mod dl {\n         // Windows expects Unicode data\n         let filename_cstr = filename.to_c_str();\n         let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n-        let filename_str: Vec<u16> = filename_str.utf16_units().collect();\n-        let filename_str = filename_str.append_one(0);\n+        let mut filename_str: Vec<u16> = filename_str.utf16_units().collect();\n+        filename_str.push(0);\n         LoadLibraryW(filename_str.as_ptr() as *const libc::c_void) as *mut u8\n     }\n "}, {"sha": "a7de84184ff5db719651ce22e92fb55a5d61c1f5", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -38,9 +38,9 @@ impl Writer for Stdio {\n }\n \n pub fn on_fail(obj: &Any + Send, file: &'static str, line: uint) {\n-    let msg = match obj.as_ref::<&'static str>() {\n+    let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n-        None => match obj.as_ref::<String>() {\n+        None => match obj.downcast_ref::<String>() {\n             Some(s) => s.as_slice(),\n             None => \"Box<Any>\",\n         }"}, {"sha": "d9543a06b350c83e385fa91401cff37c8ea571ac", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -162,7 +162,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.get_mut_ref().write(self.buf.slice_to(self.pos));\n+            let ret = self.inner.as_mut().unwrap().write(self.buf.slice_to(self.pos));\n             self.pos = 0;\n             ret\n         } else {\n@@ -174,7 +174,7 @@ impl<W: Writer> BufferedWriter<W> {\n     ///\n     /// This type does not expose the ability to get a mutable reference to the\n     /// underlying reader because that could possibly corrupt the buffer.\n-    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n+    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.as_ref().unwrap() }\n \n     /// Unwraps this `BufferedWriter`, returning the underlying writer.\n     ///\n@@ -193,7 +193,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         }\n \n         if buf.len() > self.buf.len() {\n-            self.inner.get_mut_ref().write(buf)\n+            self.inner.as_mut().unwrap().write(buf)\n         } else {\n             let dst = self.buf.slice_from_mut(self.pos);\n             slice::bytes::copy_memory(dst, buf);\n@@ -203,7 +203,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n     }\n \n     fn flush(&mut self) -> IoResult<()> {\n-        self.flush_buf().and_then(|()| self.inner.get_mut_ref().flush())\n+        self.flush_buf().and_then(|()| self.inner.as_mut().unwrap().flush())\n     }\n }\n \n@@ -273,7 +273,7 @@ impl<W> InternalBufferedWriter<W> {\n \n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.get_mut().inner.get_mut_ref().read(buf)\n+        self.get_mut().inner.as_mut().unwrap().read(buf)\n     }\n }\n "}, {"sha": "0a969fc37c924aa6dc01c82ce0f4f39f47ad8d27", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -15,7 +15,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n-use slice::{bytes, MutableSlice, ImmutableSlice};\n+use slice::{bytes, MutableSlice, ImmutableSlice, CloneableVector};\n use str::StrSlice;\n use super::{Reader, Writer, IoResult};\n use vec::Vec;\n@@ -118,7 +118,7 @@ impl Clone for ChanWriter {\n \n impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.tx.send_opt(Vec::from_slice(buf)).map_err(|_| {\n+        self.tx.send_opt(buf.to_vec()).map_err(|_| {\n             io::IoError {\n                 kind: io::BrokenPipe,\n                 desc: \"Pipe closed\","}, {"sha": "a93f9826fa56b89def4a3aca4c7ddce33033f642", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -16,13 +16,14 @@\n // FIXME: Iteration should probably be considered separately\n \n use collections::{Collection, MutableSeq};\n+use io::{IoError, IoResult, Reader};\n+use io;\n use iter::Iterator;\n+use num::Int;\n use option::{Option, Some, None};\n+use ptr::RawPtr;\n use result::{Ok, Err};\n-use io;\n-use io::{IoError, IoResult, Reader};\n use slice::{ImmutableSlice, Slice};\n-use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `EndOfFile`.\n@@ -76,16 +77,15 @@ impl<'r, R: Reader> Iterator<IoResult<u8>> for Bytes<'r, R> {\n ///\n /// This function returns the value returned by the callback, for convenience.\n pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n-    use mem::{to_le16, to_le32, to_le64};\n     use mem::transmute;\n \n     // LLVM fails to properly optimize this when using shifts instead of the to_le* intrinsics\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<_, [u8, ..2]>(to_le16(n as u16)) }),\n-      4u => f(unsafe { transmute::<_, [u8, ..4]>(to_le32(n as u32)) }),\n-      8u => f(unsafe { transmute::<_, [u8, ..8]>(to_le64(n)) }),\n+      2u => f(unsafe { transmute::<_, [u8, ..2]>((n as u16).to_le()) }),\n+      4u => f(unsafe { transmute::<_, [u8, ..4]>((n as u32).to_le()) }),\n+      8u => f(unsafe { transmute::<_, [u8, ..8]>(n.to_le()) }),\n       _ => {\n \n         let mut bytes = vec!();\n@@ -116,16 +116,15 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n ///\n /// This function returns the value returned by the callback, for convenience.\n pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n-    use mem::{to_be16, to_be32, to_be64};\n     use mem::transmute;\n \n     // LLVM fails to properly optimize this when using shifts instead of the to_be* intrinsics\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<_, [u8, ..2]>(to_be16(n as u16)) }),\n-      4u => f(unsafe { transmute::<_, [u8, ..4]>(to_be32(n as u32)) }),\n-      8u => f(unsafe { transmute::<_, [u8, ..8]>(to_be64(n)) }),\n+      2u => f(unsafe { transmute::<_, [u8, ..2]>((n as u16).to_be()) }),\n+      4u => f(unsafe { transmute::<_, [u8, ..4]>((n as u32).to_be()) }),\n+      8u => f(unsafe { transmute::<_, [u8, ..8]>(n.to_be()) }),\n       _ => {\n         let mut bytes = vec!();\n         let mut i = size;\n@@ -152,7 +151,6 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n ///           32-bit value is parsed.\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     use ptr::{copy_nonoverlapping_memory};\n-    use mem::from_be64;\n     use slice::MutableSlice;\n \n     assert!(size <= 8u);\n@@ -166,7 +164,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n         let ptr = data.as_ptr().offset(start as int);\n         let out = buf.as_mut_ptr();\n         copy_nonoverlapping_memory(out.offset((8 - size) as int), ptr, size);\n-        from_be64(*(out as *const u64))\n+        (*(out as *const u64)).to_be()\n     }\n }\n "}, {"sha": "b8e18fc44cbc6400205fd74f1fe2f7fdc0985f61", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -61,7 +61,7 @@ use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n use io::UpdateIoError;\n use io;\n-use iter::Iterator;\n+use iter::{Iterator, Extendable};\n use kinds::Send;\n use libc;\n use option::{Some, None, Option};\n@@ -688,7 +688,7 @@ impl Iterator<Path> for Directories {\n                                                 e, path.display()));\n \n                     match result {\n-                        Ok(dirs) => { self.stack.push_all_move(dirs); }\n+                        Ok(dirs) => { self.stack.extend(dirs.into_iter()); }\n                         Err(..) => {}\n                     }\n                 }"}, {"sha": "6eb7d1c02fbc7b47942a4fdcd90ce8b4fd11900f", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -103,7 +103,12 @@ impl<'a> Parser<'a> {\n     // Commit only if parser read till EOF\n     fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n                      -> Option<T> {\n-        self.read_atomically(|p| cb(p).filtered(|_| p.is_eof()))\n+        self.read_atomically(|p| {\n+            match cb(p) {\n+                Some(x) => if p.is_eof() {Some(x)} else {None},\n+                None => None,\n+            }\n+        })\n     }\n \n     // Return result of first successful parser\n@@ -152,7 +157,10 @@ impl<'a> Parser<'a> {\n     // Return char and advance iff next char is equal to requested\n     fn read_given_char(&mut self, c: char) -> Option<char> {\n         self.read_atomically(|p| {\n-            p.read_char().filtered(|&next| next == c)\n+            match p.read_char() {\n+                Some(next) if next == c => Some(next),\n+                _ => None,\n+            }\n         })\n     }\n \n@@ -232,8 +240,8 @@ impl<'a> Parser<'a> {\n         fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16, ..8];\n-            gs.copy_from(head);\n-            gs.slice_mut(8 - tail.len(), 8).copy_from(tail);\n+            gs.clone_from_slice(head);\n+            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n "}, {"sha": "9d6713b25b7248452ca2fc8c5bccd157390db88b", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -79,7 +79,7 @@ impl TempDir {\n \n     /// Access the wrapped `std::path::Path` to the temporary directory.\n     pub fn path<'a>(&'a self) -> &'a Path {\n-        self.path.get_ref()\n+        self.path.as_ref().unwrap()\n     }\n \n     /// Close and remove the temporary directory"}, {"sha": "299e41f72191d148504886ec52537afceeb4be2f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -112,7 +112,6 @@\n // Don't link to std. We are std.\n #![no_std]\n \n-#![allow(deprecated)]\n #![deny(missing_doc)]\n \n #![reexport_test_harness_main = \"test_main\"]"}, {"sha": "81dd114ec7d063063fb2d345774344cd1b320151", "filename": "src/libstd/os.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -46,15 +46,14 @@ use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n use slice::{Slice, ImmutableSlice, MutableSlice, ImmutablePartialEqSlice};\n+use slice::CloneableVector;\n use str::{Str, StrSlice, StrAllocating};\n use string::String;\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use vec::Vec;\n \n-#[cfg(unix)]\n-use c_str::ToCStr;\n-#[cfg(unix)]\n-use libc::c_char;\n+#[cfg(unix)] use c_str::ToCStr;\n+#[cfg(unix)] use libc::c_char;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n@@ -260,8 +259,11 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             let mut i = 0;\n             while *ch.offset(i) != 0 {\n                 let p = &*ch.offset(i);\n-                let len = ptr::position(p, |c| *c == 0);\n-                raw::buf_as_slice(p, len, |s| {\n+                let mut len = 0;\n+                while *(p as *const _).offset(len) != 0 {\n+                    len += 1;\n+                }\n+                raw::buf_as_slice(p, len as uint, |s| {\n                     result.push(String::from_utf16_lossy(s).into_bytes());\n                 });\n                 i += len as int + 1;\n@@ -276,27 +278,28 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             extern {\n                 fn rust_env_pairs() -> *const *const c_char;\n             }\n-            let environ = rust_env_pairs();\n+            let mut environ = rust_env_pairs();\n             if environ as uint == 0 {\n                 fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n             let mut result = Vec::new();\n-            ptr::array_each(environ, |e| {\n+            while *environ != 0 as *const _ {\n                 let env_pair =\n-                    Vec::from_slice(CString::new(e, false).as_bytes_no_nul());\n+                    CString::new(*environ, false).as_bytes_no_nul().to_vec();\n                 result.push(env_pair);\n-            });\n+                environ = environ.offset(1);\n+            }\n             result\n         }\n \n         fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n                 let mut it = p.as_slice().splitn(1, |b| *b == b'=');\n-                let key = Vec::from_slice(it.next().unwrap());\n+                let key = it.next().unwrap().to_vec();\n                 let default: &[u8] = &[];\n-                let val = Vec::from_slice(it.next().unwrap_or(default));\n+                let val = it.next().unwrap_or(default).to_vec();\n                 pairs.push((key, val));\n             }\n             pairs\n@@ -350,8 +353,7 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n             if s.is_null() {\n                 None\n             } else {\n-                Some(Vec::from_slice(CString::new(s as *const i8,\n-                                                  false).as_bytes_no_nul()))\n+                Some(CString::new(s as *const i8, false).as_bytes_no_nul().to_vec())\n             }\n         })\n     }\n@@ -364,8 +366,8 @@ pub fn getenv(n: &str) -> Option<String> {\n     unsafe {\n         with_env_lock(|| {\n             use os::windows::{fill_utf16_buf_and_decode};\n-            let n: Vec<u16> = n.utf16_units().collect();\n-            let n = n.append_one(0);\n+            let mut n: Vec<u16> = n.utf16_units().collect();\n+            n.push(0);\n             fill_utf16_buf_and_decode(|buf, sz| {\n                 libc::GetEnvironmentVariableW(n.as_ptr(), buf, sz)\n             })\n@@ -411,10 +413,10 @@ pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n \n     #[cfg(windows)]\n     fn _setenv(n: &str, v: &[u8]) {\n-        let n: Vec<u16> = n.utf16_units().collect();\n-        let n = n.append_one(0);\n-        let v: Vec<u16> = ::str::from_utf8(v).unwrap().utf16_units().collect();\n-        let v = v.append_one(0);\n+        let mut n: Vec<u16> = n.utf16_units().collect();\n+        n.push(0);\n+        let mut v: Vec<u16> = ::str::from_utf8(v).unwrap().utf16_units().collect();\n+        v.push(0);\n \n         unsafe {\n             with_env_lock(|| {\n@@ -441,8 +443,8 @@ pub fn unsetenv(n: &str) {\n \n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n-        let n: Vec<u16> = n.utf16_units().collect();\n-        let n = n.append_one(0);\n+        let mut n: Vec<u16> = n.utf16_units().collect();\n+        n.push(0);\n         unsafe {\n             with_env_lock(|| {\n                 libc::SetEnvironmentVariableW(n.as_ptr(), ptr::null());\n@@ -882,7 +884,11 @@ pub fn change_dir(p: &Path) -> bool {\n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n         let p = match p.as_str() {\n-            Some(s) => s.utf16_units().collect::<Vec<u16>>().append_one(0),\n+            Some(s) => {\n+                let mut p = s.utf16_units().collect::<Vec<u16>>();\n+                p.push(0);\n+                p\n+            }\n             None => return false,\n         };\n         unsafe {\n@@ -1099,8 +1105,7 @@ unsafe fn load_argc_and_argv(argc: int,\n     use c_str::CString;\n \n     Vec::from_fn(argc as uint, |i| {\n-        Vec::from_slice(CString::new(*argv.offset(i as int),\n-                                     false).as_bytes_no_nul())\n+        CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_vec()\n     })\n }\n \n@@ -1169,7 +1174,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n                 mem::transmute(objc_msgSend(tmp, utf8Sel));\n             let s = CString::new(utf_c_str, false);\n             if s.is_not_null() {\n-                res.push(Vec::from_slice(s.as_bytes_no_nul()))\n+                res.push(s.as_bytes_no_nul().to_vec())\n             }\n         }\n     }"}, {"sha": "16552daae36b7526b0e109f30c88bc8ae52f187c", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -76,7 +76,7 @@ use option::{Option, None, Some};\n use str;\n use str::{MaybeOwned, Str, StrSlice};\n use string::String;\n-use slice::Slice;\n+use slice::{Slice, CloneableVector};\n use slice::{ImmutablePartialEqSlice, ImmutableSlice};\n use vec::Vec;\n \n@@ -480,7 +480,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(Vec::from_slice(name.slice_to(idx))),\n+                (Some(idx), 0) => Some(name.slice_to(idx).to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -798,7 +798,7 @@ pub trait BytesContainer {\n     /// Consumes the receiver and converts it into Vec<u8>\n     #[inline]\n     fn container_into_owned_bytes(self) -> Vec<u8> {\n-        Vec::from_slice(self.container_as_bytes())\n+        self.container_as_bytes().to_vec()\n     }\n     /// Returns the receiver interpreted as a utf-8 string, if possible\n     #[inline]"}, {"sha": "9c4139853c540b275b44d91f59c7f7a39ad3c51e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -264,7 +264,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn is_absolute(&self) -> bool {\n-        *self.repr.get(0) == SEP_BYTE\n+        self.repr[0] == SEP_BYTE\n     }\n \n     fn is_ancestor_of(&self, other: &Path) -> bool {\n@@ -399,7 +399,7 @@ impl Path {\n             }\n         };\n         match val {\n-            None => Vec::from_slice(v.as_slice()),\n+            None => v.as_slice().to_vec(),\n             Some(val) => val\n         }\n     }\n@@ -409,7 +409,7 @@ impl Path {\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n-        let v = if *self.repr.get(0) == SEP_BYTE {\n+        let v = if self.repr[0] == SEP_BYTE {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);"}, {"sha": "3f598e5280624e7dce759f5071f71962f8e4fee4", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -264,10 +264,10 @@ impl GenericPathUnsafe for Path {\n             let repr = me.repr.as_slice();\n             match me.prefix {\n                 Some(DiskPrefix) => {\n-                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_upper().to_byte()\n+                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_uppercase().to_byte()\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii().to_upper().to_byte()\n+                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii().to_uppercase().to_byte()\n                 }\n                 _ => false\n             }\n@@ -371,7 +371,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn into_vec(self) -> Vec<u8> {\n-        Vec::from_slice(self.repr.as_bytes())\n+        self.repr.into_bytes()\n     }\n \n     #[inline]\n@@ -776,9 +776,9 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(0) = v.get(0)\n+                                    *v.get_mut(0) = (*v)[0]\n                                                      .to_ascii()\n-                                                     .to_upper()\n+                                                     .to_uppercase()\n                                                      .to_byte();\n                                 }\n                                 if is_abs {\n@@ -794,7 +794,7 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(4) = v.get(4).to_ascii().to_upper().to_byte();\n+                                    *v.get_mut(4) = (*v)[4].to_ascii().to_uppercase().to_byte();\n                                 }\n                                 Some(s)\n                             }\n@@ -815,12 +815,14 @@ impl Path {\n                         let mut s = String::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {\n-                                s.push_char(prefix_.as_bytes()[0].to_ascii().to_upper().to_char());\n+                                s.push_char(prefix_.as_bytes()[0].to_ascii()\n+                                                   .to_uppercase().to_char());\n                                 s.push_char(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n                                 s.push_str(prefix_.slice_to(4));\n-                                s.push_char(prefix_.as_bytes()[4].to_ascii().to_upper().to_char());\n+                                s.push_char(prefix_.as_bytes()[4].to_ascii()\n+                                                   .to_uppercase().to_char());\n                                 s.push_str(prefix_.slice_from(5));\n                             }\n                             Some(UNCPrefix(a,b)) => {\n@@ -1619,7 +1621,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"\\\\e\", b\"f\"], b\"\\\\e\\\\f\");\n-        t!(v: b\"a\\\\b\\\\c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")],\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\".to_vec(), b\"e\".to_vec()],\n            b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n \n@@ -1759,7 +1761,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b\"a\\\\b\\\\c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")],\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\".to_vec(), b\"e\".to_vec()],\n            b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n "}, {"sha": "a00eeb1f938389afb640722cf94cf25abbec8ba4", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -79,7 +79,7 @@ impl<T> TaskPool<T> {\n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n     pub fn execute(&mut self, f: proc(&T):Send) {\n-        self.channels.get(self.next_index).send(Execute(f));\n+        self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n     }"}, {"sha": "3f626d716f88bcb2c4bf13ad656dc2e00308f151", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -505,8 +505,8 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             if flags.precision > s.len() {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n-                s_.grow(n, &b'0');\n-                s_.push_all_move(s);\n+                s_.grow(n, b'0');\n+                s_.extend(s.into_iter());\n                 s = s_;\n             }\n             assert!(!s.is_empty(), \"string conversion produced empty result\");\n@@ -524,7 +524,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                 FormatHex => {\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'x'));\n-                        s.push_all_move(s_);\n+                        s.extend(s_.into_iter());\n                     }\n                 }\n                 FormatHEX => {\n@@ -536,7 +536,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                          .collect();\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'X'));\n-                        s.push_all_move(s_);\n+                        s.extend(s_.into_iter());\n                     }\n                 }\n                 FormatString => unreachable!()\n@@ -546,7 +546,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n         Words(s) => {\n             match op {\n                 FormatString => {\n-                    let mut s = Vec::from_slice(s.as_bytes());\n+                    let mut s = s.as_bytes().to_vec();\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);\n                     }\n@@ -562,11 +562,11 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     if flags.width > s.len() {\n         let n = flags.width - s.len();\n         if flags.left {\n-            s.grow(n, &b' ');\n+            s.grow(n, b' ');\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n-            s_.grow(n, &b' ');\n-            s_.push_all_move(s);\n+            s_.grow(n, b' ');\n+            s_.extend(s.into_iter());\n             s = s_;\n         }\n     }"}, {"sha": "f59a4465e1da4b4ad092e07c23cde8ed826ded95", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -290,9 +290,8 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      Vec::from_slice(\n-                                          string_table.slice(offset as uint,\n-                                          offset as uint + len)))\n+                                      string_table.slice(offset as uint,\n+                                          offset as uint + len).to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\\n@@ -314,10 +313,10 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_string(), Vec::from_slice(b\"\\x1B[0m\"));\n-    strings.insert(\"bold\".to_string(), Vec::from_slice(b\"\\x1B[1m\"));\n-    strings.insert(\"setaf\".to_string(), Vec::from_slice(b\"\\x1B[3%p1%dm\"));\n-    strings.insert(\"setab\".to_string(), Vec::from_slice(b\"\\x1B[4%p1%dm\"));\n+    strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n+    strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());\n+    strings.insert(\"setaf\".to_string(), b\"\\x1B[3%p1%dm\".to_vec());\n+    strings.insert(\"setab\".to_string(), b\"\\x1B[4%p1%dm\".to_vec());\n     box TermInfo {\n         names: vec!(\"cygwin\".to_string()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),"}, {"sha": "ae70bb4b7925a6eb367681f5eeec0e2ffa9ed758", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -261,13 +261,13 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n     }\n \n     fn percentile(self, pct: T) -> T {\n-        let mut tmp = Vec::from_slice(self);\n+        let mut tmp = self.to_vec();\n         local_sort(tmp.as_mut_slice());\n         percentile_of_sorted(tmp.as_slice(), pct)\n     }\n \n     fn quartiles(self) -> (T,T,T) {\n-        let mut tmp = Vec::from_slice(self);\n+        let mut tmp = self.to_vec();\n         local_sort(tmp.as_mut_slice());\n         let first = FromPrimitive::from_uint(25).unwrap();\n         let a = percentile_of_sorted(tmp.as_slice(), first);\n@@ -318,7 +318,7 @@ fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n ///\n /// See: http://en.wikipedia.org/wiki/Winsorising\n pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n-    let mut tmp = Vec::from_slice(samples);\n+    let mut tmp = samples.to_vec();\n     local_sort(tmp.as_mut_slice());\n     let lo = percentile_of_sorted(tmp.as_slice(), pct);\n     let hundred: T = FromPrimitive::from_uint(100).unwrap();"}, {"sha": "cdfb384d47ca27580bec9743e38245ceee9e91fb", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb07e81be99271f9e240a27dcf540686d8c0bfc/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=cbb07e81be99271f9e240a27dcf540686d8c0bfc", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let mut vector = vec![1u, 2];\n     for &x in vector.iter() {\n         let cap = vector.capacity();\n-        vector.grow(cap, &0u);      //~ ERROR cannot borrow\n+        vector.grow(cap, 0u);      //~ ERROR cannot borrow\n         *vector.get_mut(1u) = 5u;   //~ ERROR cannot borrow\n     }\n }"}]}