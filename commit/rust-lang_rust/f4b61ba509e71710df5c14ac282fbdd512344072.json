{"sha": "f4b61ba509e71710df5c14ac282fbdd512344072", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YjYxYmE1MDllNzE3MTBkZjVjMTRhYzI4MmZiZGQ1MTIzNDQwNzI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-14T20:10:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-15T15:14:11Z"}, "message": "adjustions and cleanup to make Miri build again", "tree": {"sha": "6508c060e035d2d3354447eb50a0a84371a6a5a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6508c060e035d2d3354447eb50a0a84371a6a5a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4b61ba509e71710df5c14ac282fbdd512344072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b61ba509e71710df5c14ac282fbdd512344072", "html_url": "https://github.com/rust-lang/rust/commit/f4b61ba509e71710df5c14ac282fbdd512344072", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4b61ba509e71710df5c14ac282fbdd512344072/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8932aebfdfc8e4be18ed5213ba24f72954c7ba47", "url": "https://api.github.com/repos/rust-lang/rust/commits/8932aebfdfc8e4be18ed5213ba24f72954c7ba47", "html_url": "https://github.com/rust-lang/rust/commit/8932aebfdfc8e4be18ed5213ba24f72954c7ba47"}], "stats": {"total": 335, "additions": 134, "deletions": 201}, "files": [{"sha": "307d7d2846208e791513618ba9ed29fda1dfe54a", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -171,7 +171,7 @@ impl<Tag> From<Pointer<Tag>> for Pointer<Option<Tag>> {\n }\n \n impl<Tag> Pointer<Option<Tag>> {\n-    pub fn into_pointer_or_offset(self) -> Result<Pointer<Tag>, Size> {\n+    pub fn into_pointer_or_addr(self) -> Result<Pointer<Tag>, Size> {\n         match self.provenance {\n             Some(tag) => Ok(Pointer::new(tag, self.offset)),\n             None => Err(self.offset),\n@@ -187,6 +187,13 @@ impl<Tag> Pointer<Option<Tag>> {\n     }\n }\n \n+impl<Tag> Pointer<Option<Tag>> {\n+    #[inline(always)]\n+    pub fn null() -> Self {\n+        Pointer { provenance: None, offset: Size::ZERO }\n+    }\n+}\n+\n impl<'tcx, Tag> Pointer<Tag> {\n     #[inline(always)]\n     pub fn new(provenance: Tag, offset: Size) -> Self {\n@@ -206,9 +213,14 @@ impl<'tcx, Tag> Pointer<Tag> {\n     where\n         Tag: Provenance,\n     {\n+        // FIXME: This is wrong! `self.offset` might be an absolute address.\n         Pointer { offset: self.offset, provenance: self.provenance.erase_for_fmt() }\n     }\n \n+    pub fn map_provenance(self, f: impl FnOnce(Tag) -> Tag) -> Self {\n+        Pointer { provenance: f(self.provenance), ..self }\n+    }\n+\n     #[inline]\n     pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n         Ok(Pointer {"}, {"sha": "1be04f8c18b1bdbbc2269bf080926a1a86753d3f", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 52, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -6,7 +6,7 @@ use rustc_apfloat::{\n     Float,\n };\n use rustc_macros::HashStable;\n-use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::abi::{HasDataLayout, Size};\n \n use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n \n@@ -179,7 +179,7 @@ impl<Tag> From<ScalarInt> for Scalar<Tag> {\n     }\n }\n \n-impl<'tcx, Tag> Scalar<Tag> {\n+impl<Tag> Scalar<Tag> {\n     pub const ZST: Self = Scalar::Int(ScalarInt::ZST);\n \n     #[inline(always)]\n@@ -202,56 +202,6 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Int(ScalarInt::null(cx.pointer_size()))\n     }\n \n-    #[inline(always)]\n-    fn ptr_op(\n-        self,\n-        dl: &TargetDataLayout,\n-        f_int: impl FnOnce(u64) -> InterpResult<'tcx, u64>,\n-        f_ptr: impl FnOnce(Pointer<Tag>) -> InterpResult<'tcx, Pointer<Tag>>,\n-    ) -> InterpResult<'tcx, Self> {\n-        match self {\n-            Scalar::Int(int) => Ok(Scalar::Int(int.ptr_sized_op(dl, f_int)?)),\n-            Scalar::Ptr(ptr, sz) => {\n-                debug_assert_eq!(u64::from(sz), dl.pointer_size().bytes());\n-                Ok(Scalar::Ptr(f_ptr(ptr)?, sz))\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n-        let dl = cx.data_layout();\n-        self.ptr_op(dl, |int| dl.offset(int, i.bytes()), |ptr| ptr.offset(i, dl))\n-    }\n-\n-    #[inline]\n-    pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n-        let dl = cx.data_layout();\n-        self.ptr_op(\n-            dl,\n-            |int| Ok(dl.overflowing_offset(int, i.bytes()).0),\n-            |ptr| Ok(ptr.wrapping_offset(i, dl)),\n-        )\n-        .unwrap()\n-    }\n-\n-    #[inline]\n-    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n-        let dl = cx.data_layout();\n-        self.ptr_op(dl, |int| dl.signed_offset(int, i), |ptr| ptr.signed_offset(i, dl))\n-    }\n-\n-    #[inline]\n-    pub fn ptr_wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n-        let dl = cx.data_layout();\n-        self.ptr_op(\n-            dl,\n-            |int| Ok(dl.overflowing_signed_offset(int, i).0),\n-            |ptr| Ok(ptr.wrapping_signed_offset(i, dl)),\n-        )\n-        .unwrap()\n-    }\n-\n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n         Scalar::Int(b.into())"}, {"sha": "8262bc261996a510b45fc83bf0d0974301057b7a", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -1,7 +1,7 @@\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use rustc_target::abi::{Size, TargetDataLayout};\n+use rustc_target::abi::Size;\n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n \n@@ -193,15 +193,6 @@ impl ScalarInt {\n         self.data == 0\n     }\n \n-    pub(crate) fn ptr_sized_op<E>(\n-        self,\n-        dl: &TargetDataLayout,\n-        f_int: impl FnOnce(u64) -> Result<u64, E>,\n-    ) -> Result<Self, E> {\n-        assert_eq!(u64::from(self.size), dl.pointer_size.bytes());\n-        Ok(Self::try_from_uint(f_int(u64::try_from(self.data).unwrap())?, self.size()).unwrap())\n-    }\n-\n     #[inline]\n     pub fn try_from_uint(i: impl Into<u128>, size: Size) -> Option<Self> {\n         let data = i.into();"}, {"sha": "c809f4f273aa5e059377ddb5ab9a98c29b768cc8", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -312,7 +312,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     align,\n                     interpret::MemoryKind::Machine(MemoryKind::Heap),\n                 )?;\n-                ecx.write_scalar(Scalar::from_pointer(ptr, &*ecx.tcx), dest)?;\n+                ecx.write_pointer(ptr, dest)?;\n             }\n             _ => {\n                 return Err(ConstEvalErrKind::NeedsRfc(format!("}, {"sha": "a334165df4cb1ff28a3747663808b2416edec18f", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -35,7 +35,7 @@ pub(crate) fn const_caller_location(\n     if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &loc_place).is_err() {\n         bug!(\"intern_const_alloc_recursive should not error in this case\")\n     }\n-    ConstValue::Scalar(Scalar::from_pointer(loc_place.ptr.into_pointer_or_offset().unwrap(), &tcx))\n+    ConstValue::Scalar(Scalar::from_pointer(loc_place.ptr.into_pointer_or_addr().unwrap(), &tcx))\n }\n \n /// Convert an evaluated constant to a type level constant"}, {"sha": "514c1aa9646a063c28e50ac54ca11a1a8d755d01", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -57,7 +57,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n \n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        self.write_scalar(Scalar::from_pointer(fn_ptr, &*self.tcx), dest)?;\n+                        self.write_pointer(fn_ptr, dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"reify fn pointer on {:?}\", src.layout.ty),\n                 }\n@@ -88,7 +88,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             ty::ClosureKind::FnOnce,\n                         );\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        self.write_scalar(Scalar::from_pointer(fn_ptr, &*self.tcx), dest)?;\n+                        self.write_pointer(fn_ptr, dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"closure fn pointer on {:?}\", src.layout.ty),\n                 }"}, {"sha": "f2457d11d9ee3cd4a19a603901813b7f02d88d7b", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::ty::{self, layout::TyAndLayout, Ty};\n \n use rustc_ast::Mutability;\n \n-use super::{AllocId, Allocation, InterpCx, MPlaceTy, Machine, MemoryKind, ValueVisitor};\n+use super::{AllocId, Allocation, InterpCx, MPlaceTy, Machine, MemoryKind, PlaceTy, ValueVisitor};\n use crate::const_eval;\n \n pub trait CompileTimeMachine<'mir, 'tcx, T> = Machine<\n@@ -425,11 +425,11 @@ impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx, !>>\n         layout: TyAndLayout<'tcx>,\n         f: impl FnOnce(\n             &mut InterpCx<'mir, 'tcx, M>,\n-            &MPlaceTy<'tcx, M::PointerTag>,\n+            &PlaceTy<'tcx, M::PointerTag>,\n         ) -> InterpResult<'tcx, ()>,\n     ) -> InterpResult<'tcx, &'tcx Allocation> {\n         let dest = self.allocate(layout, MemoryKind::Stack)?;\n-        f(self, &dest)?;\n+        f(self, &dest.into())?;\n         let mut alloc = self.memory.alloc_map.remove(&dest.ptr.provenance.unwrap()).unwrap().1;\n         alloc.mutability = Mutability::Not;\n         Ok(self.tcx.intern_const_alloc(alloc))"}, {"sha": "9335b783c77513688940dcccf2ed585176263296", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -337,17 +337,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n-                self.write_scalar(Scalar::from_maybe_pointer(offset_ptr, self), dest)?;\n+                self.write_pointer(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n-                let ptr = self.read_scalar(&args[0])?.check_init()?;\n+                let ptr = self.read_pointer(&args[0])?;\n                 let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n                 let offset_bytes = offset_count.wrapping_mul(pointee_size);\n-                let offset_ptr = ptr.ptr_wrapping_signed_offset(offset_bytes, self);\n-                self.write_scalar(offset_ptr, dest)?;\n+                let offset_ptr = ptr.wrapping_signed_offset(offset_bytes, self);\n+                self.write_pointer(offset_ptr, dest)?;\n             }\n             sym::ptr_offset_from => {\n                 let a = self.read_immediate(&args[0])?.to_scalar()?;\n@@ -379,8 +379,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // General case: we need two pointers.\n                     let a = self.scalar_to_ptr(a);\n                     let b = self.scalar_to_ptr(b);\n-                    let (a_alloc_id, a_offset, _) = self.memory.ptr_force_alloc(a)?;\n-                    let (b_alloc_id, b_offset, _) = self.memory.ptr_force_alloc(b)?;\n+                    let (a_alloc_id, a_offset, _) = self.memory.ptr_get_alloc(a)?;\n+                    let (b_alloc_id, b_offset, _) = self.memory.ptr_get_alloc(b)?;\n                     if a_alloc_id != b_alloc_id {\n                         throw_ub_format!(\n                             \"ptr_offset_from cannot compute offset of pointers into different \\"}, {"sha": "7b8f2aecd0d47e901cfccdb1c1cffca17c3a7503", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -7,14 +7,14 @@ use std::fmt::Debug;\n use std::hash::Hash;\n \n use rustc_middle::mir;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    AllocId, Allocation, Frame, ImmTy, InterpCx, InterpResult, LocalValue, MemPlace, Memory,\n-    MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n+    AllocId, AllocRange, Allocation, Frame, ImmTy, InterpCx, InterpResult, LocalValue, MemPlace,\n+    Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -262,34 +262,40 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n \n     /// Return the `AllocId` for the given thread-local static in the current thread.\n-    fn thread_local_static_alloc_id(\n+    fn thread_local_static_base_pointer(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n+    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         throw_unsup!(ThreadLocalStatic(def_id))\n     }\n \n-    /// Return the `AllocId` backing the given `extern static`.\n-    fn extern_static_alloc_id(\n+    /// Return the root pointer for the given `extern static`.\n+    fn extern_static_base_pointer(\n         mem: &Memory<'mir, 'tcx, Self>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n-        // Use the `AllocId` associated with the `DefId`. Any actual *access* will fail.\n-        Ok(mem.tcx.create_static_alloc(def_id))\n-    }\n+    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>>;\n \n-    /// Return the \"base\" tag for the given *global* allocation: the one that is used for direct\n-    /// accesses to this static/const/fn allocation. If `id` is not a global allocation,\n-    /// this will return an unusable tag (i.e., accesses will be UB)!\n-    ///\n-    /// Called on the id returned by `thread_local_static_alloc_id` and `extern_static_alloc_id`, if needed.\n+    /// Return a \"base\" pointer for the given allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation, or the one returned from the heap allocator.\n     ///\n-    /// `offset` is relative inside the allocation.\n-    fn tag_global_base_pointer(\n-        memory_extra: &Self::MemoryExtra,\n+    /// Not called on `extern` or thread-local statics (those use the methods above).\n+    fn tag_alloc_base_pointer(\n+        mem: &Memory<'mir, 'tcx, Self>,\n         ptr: Pointer,\n     ) -> Pointer<Self::PointerTag>;\n \n+    /// \"Int-to-pointer cast\"\n+    fn ptr_from_addr(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        addr: u64,\n+    ) -> Pointer<Option<Self::PointerTag>>;\n+\n+    /// Convert a pointer with provenance into an allocation-offset pair.\n+    fn ptr_get_alloc(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+    ) -> (AllocId, Size);\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra.\n@@ -303,16 +309,13 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n-    ///\n-    /// Also return the \"base\" tag to use for this allocation: the one that is used for direct\n-    /// accesses to this allocation. If `kind == STATIC_KIND`, this tag must be consistent\n-    /// with `tag_global_base_pointer`.\n     fn init_allocation_extra<'b>(\n         memory_extra: &Self::MemoryExtra,\n+        tcx: TyCtxt<'tcx>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n+    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n \n     /// Hook for performing extra checks on a memory read access.\n     ///\n@@ -323,8 +326,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn memory_read(\n         _memory_extra: &Self::MemoryExtra,\n         _alloc_extra: &Self::AllocExtra,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n+        _tag: Self::PointerTag,\n+        _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -334,8 +337,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn memory_written(\n         _memory_extra: &mut Self::MemoryExtra,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n+        _tag: Self::PointerTag,\n+        _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -345,17 +348,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn memory_deallocated(\n         _memory_extra: &mut Self::MemoryExtra,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n-    ) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    /// Called after initializing static memory using the interpreter.\n-    fn after_static_mem_initialized(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n+        _tag: Self::PointerTag,\n+        _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -400,19 +394,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         // By default, we do not support unwinding from panics\n         Ok(StackPopJump::Normal)\n     }\n-\n-    /// \"Int-to-pointer cast\"\n-    fn ptr_from_addr(\n-        mem: &Memory<'mir, 'tcx, Self>,\n-        addr: u64,\n-    ) -> Pointer<Option<Self::PointerTag>>;\n-\n-    /// Convert a pointer with provenance into an allocation-offset pair,\n-    /// or a `None` with an absolute address if that conversion is not possible.\n-    fn ptr_get_alloc(\n-        mem: &Memory<'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n-    ) -> (Option<AllocId>, Size);\n }\n \n // A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n@@ -461,17 +442,26 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n         _memory_extra: &Self::MemoryExtra,\n-        id: AllocId,\n+        _tcx: TyCtxt<$tcx>,\n+        _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+    ) -> Cow<'b, Allocation<Self::PointerTag>> {\n         // We do not use a tag so we can just cheaply forward the allocation\n-        (alloc, id)\n+        alloc\n+    }\n+\n+    fn extern_static_base_pointer(\n+        mem: &Memory<$mir, $tcx, Self>,\n+        def_id: DefId,\n+    ) -> InterpResult<$tcx, Pointer> {\n+        // Use the `AllocId` associated with the `DefId`. Any actual *access* will fail.\n+        Ok(Pointer::new(mem.tcx.create_static_alloc(def_id), Size::ZERO))\n     }\n \n     #[inline(always)]\n-    fn tag_global_base_pointer(\n-        _memory_extra: &Self::MemoryExtra,\n+    fn tag_alloc_base_pointer(\n+        _mem: &Memory<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n     ) -> Pointer<AllocId> {\n         ptr\n@@ -486,9 +476,9 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     fn ptr_get_alloc(\n         _mem: &Memory<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n-    ) -> (Option<AllocId>, Size) {\n+    ) -> (AllocId, Size) {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n-        (Some(alloc_id), offset)\n+        (alloc_id, offset)\n     }\n }"}, {"sha": "aae3721e4e4fb7130036fc6b3b5d6f7b9ab52427", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -168,20 +168,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n         // We need to handle `extern static`.\n-        let alloc_id = match self.tcx.get_global_alloc(alloc_id) {\n+        match self.tcx.get_global_alloc(alloc_id) {\n             Some(GlobalAlloc::Static(def_id)) if self.tcx.is_thread_local_static(def_id) => {\n                 bug!(\"global memory cannot point to thread-local static\")\n             }\n             Some(GlobalAlloc::Static(def_id)) if self.tcx.is_foreign_item(def_id) => {\n-                M::extern_static_alloc_id(self, def_id)?\n+                return M::extern_static_base_pointer(self, def_id);\n             }\n-            _ => {\n-                // No need to change the `AllocId`.\n-                alloc_id\n-            }\n-        };\n+            _ => {}\n+        }\n         // And we need to get the tag.\n-        Ok(M::tag_global_base_pointer(&self.extra, Pointer::new(alloc_id, offset)))\n+        Ok(M::tag_alloc_base_pointer(self, Pointer::new(alloc_id, offset)))\n     }\n \n     pub fn create_fn_alloc(\n@@ -236,9 +233,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             \"dynamically allocating global memory\"\n         );\n         // This is a new allocation, not a new global one, so no `global_base_ptr`.\n-        let (alloc, tag) = M::init_allocation_extra(&self.extra, id, Cow::Owned(alloc), Some(kind));\n+        let alloc = M::init_allocation_extra(&self.extra, self.tcx, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n-        Pointer::new(tag, Size::ZERO)\n+        M::tag_alloc_base_pointer(self, Pointer::new(id, Size::ZERO))\n     }\n \n     pub fn reallocate(\n@@ -249,7 +246,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        let (alloc_id, offset, ptr) = self.ptr_force_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n@@ -284,7 +281,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        let (alloc_id, offset, ptr) = self.ptr_force_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n         trace!(\"deallocating: {}\", alloc_id);\n \n         if offset.bytes() != 0 {\n@@ -337,7 +334,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // Let the machine take some extra action\n         let size = alloc.size();\n-        M::memory_deallocated(&mut self.extra, &mut alloc.extra, ptr, size)?;\n+        M::memory_deallocated(&mut self.extra, &mut alloc.extra, ptr.provenance, alloc_range(Size::ZERO, size))?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(alloc_id, (size, alloc.align));\n@@ -424,7 +421,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             self.ptr_try_get_alloc(ptr)\n         } else {\n             // A \"real\" access, we insist on getting an `AllocId`.\n-            Ok(self.ptr_force_alloc(ptr)?)\n+            Ok(self.ptr_get_alloc(ptr)?)\n         };\n         Ok(match ptr_or_addr {\n             Err(addr) => {\n@@ -530,14 +527,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         M::before_access_global(memory_extra, id, alloc, def_id, is_write)?;\n         let alloc = Cow::Borrowed(alloc);\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n-        let (alloc, tag) = M::init_allocation_extra(\n+        let alloc = M::init_allocation_extra(\n             memory_extra,\n+            tcx,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n         );\n-        // Sanity check that this is the same tag we would have gotten via `global_base_pointer`.\n-        debug_assert!(tag == M::tag_global_base_pointer(memory_extra, id.into()).provenance);\n         Ok(alloc)\n     }\n \n@@ -596,8 +592,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             },\n         )?;\n         if let Some((alloc_id, offset, ptr, alloc)) = ptr_and_alloc {\n-            M::memory_read(&self.extra, &alloc.extra, ptr, size)?;\n             let range = alloc_range(offset, size);\n+            M::memory_read(&self.extra, &alloc.extra, ptr.provenance, range)?;\n             Ok(Some(AllocRef { alloc, range, tcx: self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n@@ -662,8 +658,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n             let (alloc, extra) = self.get_raw_mut(alloc_id)?;\n-            M::memory_written(extra, &mut alloc.extra, ptr, size)?;\n             let range = alloc_range(offset, size);\n+            M::memory_written(extra, &mut alloc.extra, ptr.provenance, range)?;\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n@@ -756,7 +752,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n-        let (alloc_id, offset, ptr) = self.ptr_force_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(ptr.erase_for_fmt()))\n         }\n@@ -1036,7 +1032,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(src_ptr) => src_ptr,\n         };\n         let src_alloc = self.get_raw(src_alloc_id)?;\n-        M::memory_read(&self.extra, &src_alloc.extra, src, size)?;\n+        let src_range = alloc_range(src_offset, size);\n+        M::memory_read(&self.extra, &src_alloc.extra, src.provenance, src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n         let (dest_alloc_id, dest_offset, dest) = match dest_parts {\n@@ -1051,23 +1048,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // relocations overlapping the edges; those would not be handled correctly).\n         let relocations = src_alloc.prepare_relocation_copy(\n             self,\n-            alloc_range(src_offset, size),\n+            src_range,\n             dest_offset,\n             num_copies,\n         );\n         // Prepare a copy of the initialization mask.\n-        let compressed = src_alloc.compress_uninit_range(alloc_range(src_offset, size));\n+        let compressed = src_alloc.compress_uninit_range(src_range);\n         // This checks relocation edges on the src.\n         let src_bytes = src_alloc\n-            .get_bytes_with_uninit_and_ptr(&tcx, alloc_range(src_offset, size))\n+            .get_bytes_with_uninit_and_ptr(&tcx, src_range)\n             .map_err(|e| e.to_interp_error(src_alloc_id))?\n             .as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n \n         // Destination alloc preparations and access hooks.\n         let (dest_alloc, extra) = self.get_raw_mut(dest_alloc_id)?;\n-        M::memory_written(extra, &mut dest_alloc.extra, dest, size * num_copies)?;\n+        let dest_range = alloc_range(dest_offset, size * num_copies);\n+        M::memory_written(extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n         let dest_bytes = dest_alloc\n-            .get_bytes_mut_ptr(&tcx, alloc_range(dest_offset, size * num_copies))\n+            .get_bytes_mut_ptr(&tcx, dest_range)\n             .as_mut_ptr();\n \n         if compressed.no_bytes_init() {\n@@ -1077,7 +1075,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // This also avoids writing to the target bytes so that the backing allocation is never\n             // touched if the bytes stay uninitialized for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n-            dest_alloc.mark_init(alloc_range(dest_offset, size * num_copies), false); // `Size` multiplication\n+            dest_alloc.mark_init(dest_range, false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -1119,7 +1117,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // now fill in all the \"init\" data\n         dest_alloc.mark_compressed_init_range(\n             &compressed,\n-            alloc_range(dest_offset, size),\n+            alloc_range(dest_offset, size), // just a single copy (i.e., not full `dest_range`)\n             num_copies,\n         );\n         // copy the relocations to the destination\n@@ -1141,29 +1139,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Internal helper for turning a \"maybe pointer\" into a proper pointer (and some information\n+    /// Turning a \"maybe pointer\" into a proper pointer (and some information\n     /// about where it points), or an absolute address.\n-    pub(super) fn ptr_try_get_alloc(\n+    pub fn ptr_try_get_alloc(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> Result<(AllocId, Size, Pointer<M::PointerTag>), u64> {\n-        match ptr.into_pointer_or_offset() {\n+        match ptr.into_pointer_or_addr() {\n             Ok(ptr) => {\n                 let (alloc_id, offset) = M::ptr_get_alloc(self, ptr);\n-                if let Some(alloc_id) = alloc_id {\n-                    Ok((alloc_id, offset, ptr))\n-                } else {\n-                    Err(offset.bytes())\n-                }\n+                Ok((alloc_id, offset, ptr))\n             }\n-            Err(offset) => Err(offset.bytes()),\n+            Err(addr) => Err(addr.bytes()),\n         }\n     }\n \n-    /// Internal helper for turning a \"maybe pointer\" into a proper pointer (and some information\n-    /// about where it points).\n+    /// Turning a \"maybe pointer\" into a proper pointer (and some information about where it points).\n     #[inline(always)]\n-    pub(super) fn ptr_force_alloc(\n+    pub fn ptr_get_alloc(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, (AllocId, Size, Pointer<M::PointerTag>)> {"}, {"sha": "5b0a940637d1edfd40bea83ff86464281a3068c7", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -199,6 +199,11 @@ impl<Tag> MemPlace<Tag> {\n         MemPlace { ptr, align, meta: MemPlaceMeta::None }\n     }\n \n+    /// Adjust the provenance of the main pointer (metadata is unaffected).\n+    pub fn map_provenance(self, f: impl FnOnce(Option<Tag>) -> Option<Tag>) -> Self {\n+        MemPlace { ptr: self.ptr.map_provenance(f), ..self }\n+    }\n+\n     /// Turn a mplace into a (thin or wide) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n     #[inline(always)]\n@@ -252,7 +257,7 @@ impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    fn from_aligned_ptr(ptr: Pointer<Option<Tag>>, layout: TyAndLayout<'tcx>) -> Self {\n+    pub fn from_aligned_ptr(ptr: Pointer<Option<Tag>>, layout: TyAndLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align.abi), layout }\n     }\n \n@@ -695,16 +700,6 @@ where\n         Ok(place_ty)\n     }\n \n-    /// Write a scalar to a place\n-    #[inline(always)]\n-    pub fn write_scalar(\n-        &mut self,\n-        val: impl Into<ScalarMaybeUninit<M::PointerTag>>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        self.write_immediate(Immediate::Scalar(val.into()), dest)\n-    }\n-\n     /// Write an immediate to a place\n     #[inline(always)]\n     pub fn write_immediate(\n@@ -722,21 +717,24 @@ where\n         Ok(())\n     }\n \n-    /// Write an `Immediate` to memory.\n+    /// Write a scalar to a place\n     #[inline(always)]\n-    pub fn write_immediate_to_mplace(\n+    pub fn write_scalar(\n         &mut self,\n-        src: Immediate<M::PointerTag>,\n-        dest: &MPlaceTy<'tcx, M::PointerTag>,\n+        val: impl Into<ScalarMaybeUninit<M::PointerTag>>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        self.write_immediate_to_mplace_no_validate(src, dest)?;\n-\n-        if M::enforce_validity(self) {\n-            // Data got changed, better make sure it matches the type!\n-            self.validate_operand(&dest.into())?;\n-        }\n+        self.write_immediate(Immediate::Scalar(val.into()), dest)\n+    }\n \n-        Ok(())\n+    /// Write a pointer to a place\n+    #[inline(always)]\n+    pub fn write_pointer(\n+        &mut self,\n+        ptr: impl Into<Pointer<Option<M::PointerTag>>>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx> {\n+        self.write_scalar(Scalar::from_maybe_pointer(ptr.into(), self), dest)\n     }\n \n     /// Write an immediate to a place."}, {"sha": "f2a8a067dfac2a11287515d4a2e927aec3c62946", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -162,9 +162,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::Rvalue::*;\n         match *rvalue {\n             ThreadLocalRef(did) => {\n-                let id = M::thread_local_static_alloc_id(self, did)?;\n-                let val = self.global_base_pointer(id.into())?;\n-                self.write_scalar(Scalar::from_pointer(val, &*self.tcx), &dest)?;\n+                let ptr = M::thread_local_static_base_pointer(self, did)?;\n+                self.write_pointer(ptr, &dest)?;\n             }\n \n             Use(ref operand) => {"}, {"sha": "5e2c47be3a2ea884d59b614396793d6d72ac889d", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b61ba509e71710df5c14ac282fbdd512344072/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=f4b61ba509e71710df5c14ac282fbdd512344072", "patch": "@@ -869,7 +869,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                                     let alloc = this\n                                         .ecx\n                                         .intern_with_temp_alloc(value.layout, |ecx, dest| {\n-                                            ecx.write_immediate_to_mplace(*imm, dest)\n+                                            ecx.write_immediate(*imm, dest)\n                                         })\n                                         .unwrap();\n                                     Ok(Some(alloc))"}]}