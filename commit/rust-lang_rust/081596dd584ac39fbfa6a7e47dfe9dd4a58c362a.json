{"sha": "081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MTU5NmRkNTg0YWMzOWZiZmE2YTdlNDdkZmU5ZGQ0YTU4YzM2MmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-16T16:50:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-16T16:50:37Z"}, "message": "Merge #5413\n\n5413: Semantical call info r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b6d564a63068530ef3aabb8855699bf20c45a608", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6d564a63068530ef3aabb8855699bf20c45a608"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEIVdCRBK7hj4Ov3rIwAAdHIIAC6n8ZHfhcFFoxoJV8sidi8D\nEw3IVqjxLOplqzrrglFu1iEmvRwrIiIVVnJUsf19JuU4Xexh+t3IpbUdoM8fypn3\na7uowdkkPOJO8awN9jgfLZGjhWVYETIm6D3bOOb1XNsD2UefWpytIpwiWeixR1WM\n+0g0V4uMaYq8dywerRZaQCyYM8sU4iEC6p+gAZNxnfO7pr+dosFdyKvHcVcpzYHX\n703c+DJorCtFeaBVMulO+673APoPBljTEkWlzDPh2kgiFXQNXYaMA6NBvAZ9FaxT\nVQamK0jl8RUEnuVaCZS9g3i6sKGsu3ymmCt4TD5shkFiN4U3AFEdO3qpvfWTFts=\n=MTX/\n-----END PGP SIGNATURE-----\n", "payload": "tree b6d564a63068530ef3aabb8855699bf20c45a608\nparent 9210fcc076808e53e9bde84be26307fc0dc7d688\nparent e1e79cf0648624e7a3787d0013c0c7e86210772f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594918237 +0000\ncommitter GitHub <noreply@github.com> 1594918237 +0000\n\nMerge #5413\n\n5413: Semantical call info r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "html_url": "https://github.com/rust-lang/rust/commit/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9210fcc076808e53e9bde84be26307fc0dc7d688", "url": "https://api.github.com/repos/rust-lang/rust/commits/9210fcc076808e53e9bde84be26307fc0dc7d688", "html_url": "https://github.com/rust-lang/rust/commit/9210fcc076808e53e9bde84be26307fc0dc7d688"}, {"sha": "e1e79cf0648624e7a3787d0013c0c7e86210772f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1e79cf0648624e7a3787d0013c0c7e86210772f", "html_url": "https://github.com/rust-lang/rust/commit/e1e79cf0648624e7a3787d0013c0c7e86210772f"}], "stats": {"total": 765, "additions": 452, "deletions": 313}, "files": [{"sha": "eb6a14eda4e54b1b55267cb23a5427a7da842a7a", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 79, "deletions": 7, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -1,5 +1,5 @@\n //! FIXME: write short doc here\n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use either::Either;\n@@ -12,6 +12,7 @@ use hir_def::{\n     import_map,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n+    src::HasSource as _,\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocContainerId, ConstId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule,\n     ImplId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StaticId, StructId,\n@@ -25,8 +26,8 @@ use hir_expand::{\n use hir_ty::{\n     autoderef,\n     display::{HirDisplayError, HirFormatter},\n-    method_resolution, ApplicationTy, Canonical, GenericPredicate, InEnvironment, Substs,\n-    TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    method_resolution, ApplicationTy, CallableDefId, Canonical, FnSig, GenericPredicate,\n+    InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n@@ -40,7 +41,7 @@ use stdx::impl_from;\n use crate::{\n     db::{DefDatabase, HirDatabase},\n     has_source::HasSource,\n-    CallableDefId, HirDisplay, InFile, Name,\n+    HirDisplay, InFile, Name,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -1168,6 +1169,12 @@ impl Type {\n         Type::new(db, krate, def, ty)\n     }\n \n+    pub fn is_unit(&self) -> bool {\n+        matches!(\n+            self.ty.value,\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { cardinality: 0 }, .. })\n+        )\n+    }\n     pub fn is_bool(&self) -> bool {\n         matches!(self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. }))\n     }\n@@ -1225,9 +1232,10 @@ impl Type {\n         db.trait_solve(self.krate, goal).is_some()\n     }\n \n-    // FIXME: this method is broken, as it doesn't take closures into account.\n-    pub fn as_callable(&self) -> Option<CallableDefId> {\n-        Some(self.ty.value.as_callable()?.0)\n+    pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n+        let (id, substs) = self.ty.value.as_callable()?;\n+        let sig = db.callable_item_signature(id).subst(substs);\n+        Some(Callable { ty: self.clone(), sig, id, is_bound_method: false })\n     }\n \n     pub fn is_closure(&self) -> bool {\n@@ -1512,6 +1520,70 @@ impl HirDisplay for Type {\n     }\n }\n \n+// FIXME: closures\n+#[derive(Debug)]\n+pub struct Callable {\n+    ty: Type,\n+    sig: FnSig,\n+    id: CallableDefId,\n+    pub(crate) is_bound_method: bool,\n+}\n+\n+pub enum CallableKind {\n+    Function(Function),\n+    TupleStruct(Struct),\n+    TupleEnumVariant(EnumVariant),\n+}\n+\n+impl Callable {\n+    pub fn kind(&self) -> CallableKind {\n+        match self.id {\n+            CallableDefId::FunctionId(it) => CallableKind::Function(it.into()),\n+            CallableDefId::StructId(it) => CallableKind::TupleStruct(it.into()),\n+            CallableDefId::EnumVariantId(it) => CallableKind::TupleEnumVariant(it.into()),\n+        }\n+    }\n+    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<ast::SelfParam> {\n+        let func = match self.id {\n+            CallableDefId::FunctionId(it) if self.is_bound_method => it,\n+            _ => return None,\n+        };\n+        let src = func.lookup(db.upcast()).source(db.upcast());\n+        let param_list = src.value.param_list()?;\n+        param_list.self_param()\n+    }\n+    pub fn params(\n+        &self,\n+        db: &dyn HirDatabase,\n+    ) -> Vec<(Option<Either<ast::SelfParam, ast::Pat>>, Type)> {\n+        let types = self\n+            .sig\n+            .params()\n+            .iter()\n+            .skip(if self.is_bound_method { 1 } else { 0 })\n+            .map(|ty| self.ty.derived(ty.clone()));\n+        let patterns = match self.id {\n+            CallableDefId::FunctionId(func) => {\n+                let src = func.lookup(db.upcast()).source(db.upcast());\n+                src.value.param_list().map(|param_list| {\n+                    param_list\n+                        .self_param()\n+                        .map(|it| Some(Either::Left(it)))\n+                        .filter(|_| !self.is_bound_method)\n+                        .into_iter()\n+                        .chain(param_list.params().map(|it| it.pat().map(Either::Right)))\n+                })\n+            }\n+            CallableDefId::StructId(_) => None,\n+            CallableDefId::EnumVariantId(_) => None,\n+        };\n+        patterns.into_iter().flatten().chain(iter::repeat(None)).zip(types).collect()\n+    }\n+    pub fn return_type(&self) -> Type {\n+        self.ty.derived(self.sig.ret().clone())\n+    }\n+}\n+\n /// For IDE only\n #[derive(Debug)]\n pub enum ScopeDef {"}, {"sha": "31f3241c9ed12a5b09226da3f18abb8707eb78fb", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -32,10 +32,10 @@ mod has_source;\n \n pub use crate::{\n     code_model::{\n-        Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Const, Crate, CrateDependency,\n-        DefWithBody, Docs, Enum, EnumVariant, Field, FieldSource, Function, GenericDef, HasAttrs,\n-        HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef, Static, Struct,\n-        Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n+        Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Callable, CallableKind, Const,\n+        Crate, CrateDependency, DefWithBody, Docs, Enum, EnumVariant, Field, FieldSource, Function,\n+        GenericDef, HasAttrs, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef,\n+        Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n     has_source::HasSource,\n     semantics::{original_range, PathResolution, Semantics, SemanticsScope},\n@@ -52,7 +52,8 @@ pub use hir_def::{\n     type_ref::Mutability,\n };\n pub use hir_expand::{\n-    hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId,\n+    hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,\n+    MacroDefId, /* FIXME */\n     MacroFile, Origin,\n };\n-pub use hir_ty::{display::HirDisplay, CallableDefId};\n+pub use hir_ty::display::HirDisplay;"}, {"sha": "f5283ab220e264237d58fa5b73259726d19f4498", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -6,7 +6,7 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n-    AsMacroCall, TraitId, VariantId,\n+    AsMacroCall, FunctionId, TraitId, VariantId,\n };\n use hir_expand::{diagnostics::AstDiagnostic, hygiene::Hygiene, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n@@ -24,8 +24,8 @@ use crate::{\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n-    AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n-    Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    AssocItem, Callable, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module,\n+    ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n use resolver::TypeNs;\n \n@@ -197,7 +197,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        self.imp.resolve_method_call(call)\n+        self.imp.resolve_method_call(call).map(Function::from)\n+    }\n+\n+    pub fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n+        self.imp.resolve_method_call_as_callable(call)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n@@ -385,10 +389,21 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(param.syntax()).type_of_self(self.db, &param)\n     }\n \n-    fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n+    fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<FunctionId> {\n         self.analyze(call.syntax()).resolve_method_call(self.db, call)\n     }\n \n+    fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n+        // FIXME: this erases Substs\n+        let func = self.resolve_method_call(call)?;\n+        let ty = self.db.value_ty(func.into());\n+        let resolver = self.analyze(call.syntax()).resolver;\n+        let ty = Type::new_with_resolver(self.db, &resolver, ty.value)?;\n+        let mut res = ty.as_callable(self.db)?;\n+        res.is_bound_method = true;\n+        Some(res)\n+    }\n+\n     fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n         self.analyze(field.syntax()).resolve_field(self.db, field)\n     }"}, {"sha": "86a47a9e54f2db77a710b57d363a40703fc8fbe1", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -14,7 +14,7 @@ use hir_def::{\n     },\n     expr::{ExprId, Pat, PatId},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n-    AsMacroCall, DefWithBodyId, FieldId, LocalFieldId, VariantId,\n+    AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n use hir_ty::{\n@@ -142,9 +142,9 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         call: &ast::MethodCallExpr,\n-    ) -> Option<Function> {\n+    ) -> Option<FunctionId> {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n-        self.infer.as_ref()?.method_resolution(expr_id).map(Function::from)\n+        self.infer.as_ref()?.method_resolution(expr_id)\n     }\n \n     pub(crate) fn resolve_field("}, {"sha": "dbfa7fccb4777b58e0d9c259c162839f09a39974", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -226,7 +226,15 @@ impl CrateDefMap {\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            PerNs::both(variant.into(), variant.into(), Visibility::Public)\n+                            match &*enum_data.variants[local_id].variant_data {\n+                                crate::adt::VariantData::Record(_) => {\n+                                    PerNs::types(variant.into(), Visibility::Public)\n+                                }\n+                                crate::adt::VariantData::Tuple(_)\n+                                | crate::adt::VariantData::Unit => {\n+                                    PerNs::both(variant.into(), variant.into(), Visibility::Public)\n+                                }\n+                            }\n                         }\n                         None => {\n                             return ResolvePathResult::with("}, {"sha": "6af251d231c5e9b39f9c316f1e58c0a9da4b4932", "filename": "crates/ra_ide/src/call_hierarchy.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -95,9 +95,9 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n             if let Some(func_target) = match &call_node {\n                 FnCallNode::CallExpr(expr) => {\n                     //FIXME: Type::as_callable is broken\n-                    let callable_def = sema.type_of_expr(&expr.expr()?)?.as_callable()?;\n-                    match callable_def {\n-                        hir::CallableDefId::FunctionId(it) => {\n+                    let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(db)?;\n+                    match callable.kind() {\n+                        hir::CallableKind::Function(it) => {\n                             let fn_def: hir::Function = it.into();\n                             let nav = fn_def.to_nav(db);\n                             Some(nav)\n@@ -109,10 +109,6 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n                     let function = sema.resolve_method_call(&expr)?;\n                     Some(function.to_nav(db))\n                 }\n-                FnCallNode::MacroCallExpr(macro_call) => {\n-                    let macro_def = sema.resolve_macro_call(&macro_call)?;\n-                    Some(macro_def.to_nav(db))\n-                }\n             } {\n                 Some((func_target, name_ref.syntax().text_range()))\n             } else {"}, {"sha": "35a8a0dc53f59d525851935e70a186b87816656a", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 193, "deletions": 168, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -1,20 +1,42 @@\n //! FIXME: write short doc here\n-use hir::Semantics;\n+use either::Either;\n+use hir::{Docs, HirDisplay, Semantics, Type};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, ArgListOwner},\n-    match_ast, AstNode, SyntaxNode, SyntaxToken,\n+    match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n+use stdx::format_to;\n use test_utils::mark;\n \n-use crate::{FilePosition, FunctionSignature};\n+use crate::FilePosition;\n \n /// Contains information about a call site. Specifically the\n /// `FunctionSignature`and current parameter.\n #[derive(Debug)]\n pub struct CallInfo {\n-    pub signature: FunctionSignature,\n+    pub doc: Option<String>,\n+    pub signature: String,\n     pub active_parameter: Option<usize>,\n+    parameters: Vec<TextRange>,\n+}\n+\n+impl CallInfo {\n+    pub fn parameter_labels(&self) -> impl Iterator<Item = &str> + '_ {\n+        self.parameters.iter().map(move |&it| &self.signature[it])\n+    }\n+    pub fn parameter_ranges(&self) -> &[TextRange] {\n+        &self.parameters\n+    }\n+    fn push_param(&mut self, param: &str) {\n+        if !self.signature.ends_with('(') {\n+            self.signature.push_str(\", \");\n+        }\n+        let start = TextSize::of(&self.signature);\n+        self.signature.push_str(param);\n+        let end = TextSize::of(&self.signature);\n+        self.parameters.push(TextRange::new(start, end))\n+    }\n }\n \n /// Computes parameter information for the given call expression.\n@@ -24,105 +46,130 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let file = file.syntax();\n     let token = file.token_at_offset(position.offset).next()?;\n     let token = sema.descend_into_macros(token);\n-    call_info_for_token(&sema, token)\n-}\n \n-#[derive(Debug)]\n-pub(crate) struct ActiveParameter {\n-    /// FIXME: should be `Type` and `Name\n-    pub(crate) ty: String,\n-    pub(crate) name: String,\n-}\n+    let (callable, active_parameter) = call_info_impl(&sema, token)?;\n \n-impl ActiveParameter {\n-    pub(crate) fn at(db: &RootDatabase, position: FilePosition) -> Option<Self> {\n-        call_info(db, position)?.into_active_parameter()\n+    let mut res =\n+        CallInfo { doc: None, signature: String::new(), parameters: vec![], active_parameter };\n+\n+    match callable.kind() {\n+        hir::CallableKind::Function(func) => {\n+            res.doc = func.docs(db).map(|it| it.as_str().to_string());\n+            format_to!(res.signature, \"fn {}\", func.name(db));\n+        }\n+        hir::CallableKind::TupleStruct(strukt) => {\n+            res.doc = strukt.docs(db).map(|it| it.as_str().to_string());\n+            format_to!(res.signature, \"struct {}\", strukt.name(db));\n+        }\n+        hir::CallableKind::TupleEnumVariant(variant) => {\n+            res.doc = variant.docs(db).map(|it| it.as_str().to_string());\n+            format_to!(\n+                res.signature,\n+                \"enum {}::{}\",\n+                variant.parent_enum(db).name(db),\n+                variant.name(db)\n+            );\n+        }\n     }\n \n-    pub(crate) fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n-        call_info_for_token(sema, token)?.into_active_parameter()\n+    res.signature.push('(');\n+    {\n+        if let Some(self_param) = callable.receiver_param(db) {\n+            format_to!(res.signature, \"{}\", self_param)\n+        }\n+        let mut buf = String::new();\n+        for (pat, ty) in callable.params(db) {\n+            buf.clear();\n+            if let Some(pat) = pat {\n+                match pat {\n+                    Either::Left(_self) => format_to!(buf, \"self: \"),\n+                    Either::Right(pat) => format_to!(buf, \"{}: \", pat),\n+                }\n+            }\n+            format_to!(buf, \"{}\", ty.display(db));\n+            res.push_param(&buf);\n+        }\n     }\n+    res.signature.push(')');\n+\n+    match callable.kind() {\n+        hir::CallableKind::Function(_) => {\n+            let ret_type = callable.return_type();\n+            if !ret_type.is_unit() {\n+                format_to!(res.signature, \" -> {}\", ret_type.display(db));\n+            }\n+        }\n+        hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => {}\n+    }\n+    Some(res)\n }\n \n-fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<CallInfo> {\n+fn call_info_impl(\n+    sema: &Semantics<RootDatabase>,\n+    token: SyntaxToken,\n+) -> Option<(hir::Callable, Option<usize>)> {\n     // Find the calling expression and it's NameRef\n     let calling_node = FnCallNode::with_node(&token.parent())?;\n \n-    let signature = match &calling_node {\n-        FnCallNode::CallExpr(call) => {\n-            //FIXME: Type::as_callable is broken\n-            let callable_def = sema.type_of_expr(&call.expr()?)?.as_callable()?;\n-            match callable_def {\n-                hir::CallableDefId::FunctionId(it) => {\n-                    let fn_def = it.into();\n-                    FunctionSignature::from_hir(sema.db, fn_def)\n-                }\n-                hir::CallableDefId::StructId(it) => {\n-                    FunctionSignature::from_struct(sema.db, it.into())?\n-                }\n-                hir::CallableDefId::EnumVariantId(it) => {\n-                    FunctionSignature::from_enum_variant(sema.db, it.into())?\n-                }\n-            }\n-        }\n-        FnCallNode::MethodCallExpr(method_call) => {\n-            let function = sema.resolve_method_call(&method_call)?;\n-            FunctionSignature::from_hir(sema.db, function)\n-        }\n-        FnCallNode::MacroCallExpr(macro_call) => {\n-            let macro_def = sema.resolve_macro_call(&macro_call)?;\n-            FunctionSignature::from_macro(sema.db, macro_def)?\n+    let callable = match &calling_node {\n+        FnCallNode::CallExpr(call) => sema.type_of_expr(&call.expr()?)?.as_callable(sema.db)?,\n+        FnCallNode::MethodCallExpr(call) => sema.resolve_method_call_as_callable(call)?,\n+    };\n+    let active_param = if let Some(arg_list) = calling_node.arg_list() {\n+        // Number of arguments specified at the call site\n+        let num_args_at_callsite = arg_list.args().count();\n+\n+        let arg_list_range = arg_list.syntax().text_range();\n+        if !arg_list_range.contains_inclusive(token.text_range().start()) {\n+            mark::hit!(call_info_bad_offset);\n+            return None;\n         }\n+        let param = std::cmp::min(\n+            num_args_at_callsite,\n+            arg_list\n+                .args()\n+                .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+                .count(),\n+        );\n+\n+        Some(param)\n+    } else {\n+        None\n     };\n+    Some((callable, active_param))\n+}\n \n-    // If we have a calling expression let's find which argument we are on\n-    let num_params = signature.parameters.len();\n-\n-    let active_parameter = match num_params {\n-        0 => None,\n-        1 if signature.has_self_param => None,\n-        1 => Some(0),\n-        _ => {\n-            if let Some(arg_list) = calling_node.arg_list() {\n-                // Number of arguments specified at the call site\n-                let num_args_at_callsite = arg_list.args().count();\n-\n-                let arg_list_range = arg_list.syntax().text_range();\n-                if !arg_list_range.contains_inclusive(token.text_range().start()) {\n-                    mark::hit!(call_info_bad_offset);\n-                    return None;\n-                }\n+#[derive(Debug)]\n+pub(crate) struct ActiveParameter {\n+    pub(crate) ty: Type,\n+    pub(crate) name: String,\n+}\n \n-                let mut param = std::cmp::min(\n-                    num_args_at_callsite,\n-                    arg_list\n-                        .args()\n-                        .take_while(|arg| {\n-                            arg.syntax().text_range().end() <= token.text_range().start()\n-                        })\n-                        .count(),\n-                );\n-\n-                // If we are in a method account for `self`\n-                if signature.has_self_param {\n-                    param += 1;\n-                }\n+impl ActiveParameter {\n+    pub(crate) fn at(db: &RootDatabase, position: FilePosition) -> Option<Self> {\n+        let sema = Semantics::new(db);\n+        let file = sema.parse(position.file_id);\n+        let file = file.syntax();\n+        let token = file.token_at_offset(position.offset).next()?;\n+        let token = sema.descend_into_macros(token);\n+        Self::at_token(&sema, token)\n+    }\n \n-                Some(param)\n-            } else {\n-                None\n-            }\n-        }\n-    };\n+    pub(crate) fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n+        let (signature, active_parameter) = call_info_impl(&sema, token)?;\n \n-    Some(CallInfo { signature, active_parameter })\n+        let idx = active_parameter?;\n+        let mut params = signature.params(sema.db);\n+        let (pat, ty) = params.swap_remove(idx);\n+        let name = pat?.to_string();\n+        Some(ActiveParameter { ty, name })\n+    }\n }\n \n #[derive(Debug)]\n pub(crate) enum FnCallNode {\n     CallExpr(ast::CallExpr),\n     MethodCallExpr(ast::MethodCallExpr),\n-    MacroCallExpr(ast::MacroCall),\n }\n \n impl FnCallNode {\n@@ -138,7 +185,6 @@ impl FnCallNode {\n                         }\n                         Some(FnCallNode::MethodCallExpr(it))\n                     },\n-                    ast::MacroCall(it) => Some(FnCallNode::MacroCallExpr(it)),\n                     _ => None,\n                 }\n             }\n@@ -150,7 +196,6 @@ impl FnCallNode {\n             match node {\n                 ast::CallExpr(it) => Some(FnCallNode::CallExpr(it)),\n                 ast::MethodCallExpr(it) => Some(FnCallNode::MethodCallExpr(it)),\n-                ast::MacroCall(it) => Some(FnCallNode::MacroCallExpr(it)),\n                 _ => None,\n             }\n         }\n@@ -166,30 +211,17 @@ impl FnCallNode {\n             FnCallNode::MethodCallExpr(call_expr) => {\n                 call_expr.syntax().children().filter_map(ast::NameRef::cast).next()\n             }\n-\n-            FnCallNode::MacroCallExpr(call_expr) => call_expr.path()?.segment()?.name_ref(),\n         }\n     }\n \n     fn arg_list(&self) -> Option<ast::ArgList> {\n         match self {\n             FnCallNode::CallExpr(expr) => expr.arg_list(),\n             FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n-            FnCallNode::MacroCallExpr(_) => None,\n         }\n     }\n }\n \n-impl CallInfo {\n-    fn into_active_parameter(self) -> Option<ActiveParameter> {\n-        let idx = self.active_parameter?;\n-        let ty = self.signature.parameter_types.get(idx)?.clone();\n-        let name = self.signature.parameter_names.get(idx)?.clone();\n-        let res = ActiveParameter { ty, name };\n-        Some(res)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect::{expect, Expect};\n@@ -202,20 +234,18 @@ mod tests {\n         let call_info = analysis.call_info(position).unwrap();\n         let actual = match call_info {\n             Some(call_info) => {\n-                let docs = match &call_info.signature.doc {\n+                let docs = match &call_info.doc {\n                     None => \"\".to_string(),\n                     Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n                 };\n                 let params = call_info\n-                    .signature\n-                    .parameters\n-                    .iter()\n+                    .parameter_labels()\n                     .enumerate()\n                     .map(|(i, param)| {\n                         if Some(i) == call_info.active_parameter {\n                             format!(\"<{}>\", param)\n                         } else {\n-                            param.clone()\n+                            param.to_string()\n                         }\n                     })\n                     .collect::<Vec<_>>()\n@@ -296,10 +326,8 @@ fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n fn bar() { foo(<|>3, ); }\n \"#,\n             expect![[r#\"\n-                fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n-                where T: Copy + Display,\n-                      U: Debug\n-                (<x: T>, y: U)\n+                fn foo(x: i32, y: {unknown}) -> u32\n+                (<x: i32>, y: {unknown})\n             \"#]],\n         );\n     }\n@@ -312,8 +340,7 @@ fn foo<T>() -> T where T: Copy + Display {}\n fn bar() { foo(<|>); }\n \"#,\n             expect![[r#\"\n-                fn foo<T>() -> T\n-                where T: Copy + Display\n+                fn foo() -> {unknown}\n                 ()\n             \"#]],\n         );\n@@ -323,11 +350,14 @@ fn bar() { foo(<|>); }\n     fn test_fn_signature_for_impl() {\n         check(\n             r#\"\n-struct F; impl F { pub fn new() { F{}} }\n-fn bar() {let _ : F = F::new(<|>);}\n+struct F;\n+impl F { pub fn new() { } }\n+fn bar() {\n+    let _ : F = F::new(<|>);\n+}\n \"#,\n             expect![[r#\"\n-                pub fn new()\n+                fn new()\n                 ()\n             \"#]],\n         );\n@@ -346,8 +376,8 @@ fn bar() {\n }\n \"#,\n             expect![[r#\"\n-                pub fn do_it(&self)\n-                (&self)\n+                fn do_it(&self)\n+                ()\n             \"#]],\n         );\n     }\n@@ -357,16 +387,33 @@ fn bar() {\n         check(\n             r#\"\n struct S;\n-impl S { pub fn do_it(&self, x: i32) {} }\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n \n-fn bar() {\n-    let s: S = S;\n-    s.do_it(<|>);\n+fn main() { S.foo(<|>); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(&self, x: i32)\n+                (<x: i32>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_method_with_arg_as_assoc_fn() {\n+        check(\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self, x: i32) {}\n }\n+\n+fn main() { S::foo(<|>); }\n \"#,\n             expect![[r#\"\n-                pub fn do_it(&self, x: i32)\n-                (&self, <x: i32>)\n+                fn foo(self: &S, x: i32)\n+                (<self: &S>, x: i32)\n             \"#]],\n         );\n     }\n@@ -425,7 +472,7 @@ pub fn do() {\n                 assert_eq!(6, my_crate::add_one(5));\n                 ```\n                 ------\n-                pub fn add_one(x: i32) -> i32\n+                fn add_one(x: i32) -> i32\n                 (<x: i32>)\n             \"##]],\n         );\n@@ -467,7 +514,7 @@ pub fn do_it() {\n                 assert_eq!(6, my_crate::add_one(5));\n                 ```\n                 ------\n-                pub fn add_one(x: i32) -> i32\n+                fn add_one(x: i32) -> i32\n                 (<x: i32>)\n             \"##]],\n         );\n@@ -505,8 +552,8 @@ pub fn foo(mut r: WriteHandler<()>) {\n \n                 By default this method stops actor's `Context`.\n                 ------\n-                fn finished(&mut self, ctx: &mut Self::Context)\n-                (&mut self, <ctx: &mut Self::Context>)\n+                fn finished(&mut self, ctx: &mut {unknown})\n+                (<ctx: &mut {unknown}>)\n             \"#]],\n         );\n     }\n@@ -539,7 +586,7 @@ fn main() {\n \"#,\n             expect![[r#\"\n                 fn bar(&self, _: u32)\n-                (&self, <_: u32>)\n+                (<_: u32>)\n             \"#]],\n         );\n     }\n@@ -549,15 +596,15 @@ fn main() {\n         check(\n             r#\"\n /// A cool tuple struct\n-struct TS(u32, i32);\n+struct S(u32, i32);\n fn main() {\n-    let s = TS(0, <|>);\n+    let s = S(0, <|>);\n }\n \"#,\n             expect![[r#\"\n                 A cool tuple struct\n                 ------\n-                struct TS(u32, i32) -> TS\n+                struct S(u32, i32)\n                 (u32, <i32>)\n             \"#]],\n         );\n@@ -567,31 +614,18 @@ fn main() {\n     fn generic_struct() {\n         check(\n             r#\"\n-struct TS<T>(T);\n+struct S<T>(T);\n fn main() {\n-    let s = TS(<|>);\n+    let s = S(<|>);\n }\n \"#,\n             expect![[r#\"\n-                struct TS<T>(T) -> TS\n-                (<T>)\n+                struct S({unknown})\n+                (<{unknown}>)\n             \"#]],\n         );\n     }\n \n-    #[test]\n-    fn cant_call_named_structs() {\n-        check(\n-            r#\"\n-struct TS { x: u32, y: i32 }\n-fn main() {\n-    let s = TS(<|>);\n-}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n     #[test]\n     fn works_for_enum_variants() {\n         check(\n@@ -612,52 +646,43 @@ fn main() {\n             expect![[r#\"\n                 A Variant\n                 ------\n-                E::A(0: i32)\n-                (<0: i32>)\n+                enum E::A(i32)\n+                (<i32>)\n             \"#]],\n         );\n     }\n \n     #[test]\n-    fn cant_call_enum_records() {\n+    fn cant_call_struct_record() {\n         check(\n             r#\"\n-enum E {\n-    /// A Variant\n-    A(i32),\n-    /// Another\n-    B,\n-    /// And C\n-    C { a: i32, b: i32 }\n-}\n-\n+struct S { x: u32, y: i32 }\n fn main() {\n-    let a = E::C(<|>);\n+    let s = S(<|>);\n }\n \"#,\n             expect![[\"\"]],\n         );\n     }\n \n     #[test]\n-    fn fn_signature_for_macro() {\n+    fn cant_call_enum_record() {\n         check(\n             r#\"\n-/// empty macro\n-macro_rules! foo {\n-    () => {}\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n }\n \n-fn f() {\n-    foo!(<|>);\n+fn main() {\n+    let a = E::C(<|>);\n }\n \"#,\n-            expect![[r#\"\n-                empty macro\n-                ------\n-                foo!()\n-                ()\n-            \"#]],\n+            expect![[\"\"]],\n         );\n     }\n "}, {"sha": "90f5b1c254b7fd3a0b5c958be264e9f55c31e783", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -43,7 +43,7 @@ use crate::{\n     completion::{\n         CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n     },\n-    display::FunctionSignature,\n+    display::function_signature::FunctionSignature,\n };\n \n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {"}, {"sha": "e29b82017810a9fd6684bd1c00a96a45749c2849", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -11,7 +11,7 @@ use crate::{\n         completion_item::Builder, CompletionContext, CompletionItem, CompletionItemKind,\n         CompletionKind, Completions,\n     },\n-    display::{const_label, macro_label, type_label, FunctionSignature},\n+    display::{const_label, function_signature::FunctionSignature, macro_label, type_label},\n     CompletionScore, RootDatabase,\n };\n \n@@ -329,15 +329,10 @@ pub(crate) fn compute_score(\n     ty: &Type,\n     name: &str,\n ) -> Option<CompletionScore> {\n-    // FIXME: this should not fall back to string equality.\n-    let ty = &ty.display(ctx.db).to_string();\n     let (active_name, active_type) = if let Some(record_field) = &ctx.record_field_syntax {\n         mark::hit!(record_field_type_match);\n         let (struct_field, _local) = ctx.sema.resolve_record_field(record_field)?;\n-        (\n-            struct_field.name(ctx.db).to_string(),\n-            struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n-        )\n+        (struct_field.name(ctx.db).to_string(), struct_field.signature_ty(ctx.db))\n     } else if let Some(active_parameter) = &ctx.active_parameter {\n         mark::hit!(active_param_type_match);\n         (active_parameter.name.clone(), active_parameter.ty.clone())"}, {"sha": "1ec9463690f000930c596f614a9afae31c2ecd26", "filename": "crates/ra_ide/src/display.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -1,25 +1,22 @@\n //! This module contains utilities for turning SyntaxNodes and HIR types\n //! into types that may be used to render in a UI.\n \n-mod function_signature;\n+pub(crate) mod function_signature;\n mod navigation_target;\n-mod structure;\n mod short_label;\n \n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner, NameOwner, TypeParamsOwner},\n     SyntaxKind::{ATTR, COMMENT},\n };\n \n-pub use function_signature::FunctionSignature;\n-pub use navigation_target::NavigationTarget;\n-pub use structure::{file_structure, StructureNode};\n-\n pub(crate) use navigation_target::{ToNav, TryToNav};\n pub(crate) use short_label::ShortLabel;\n \n+pub use navigation_target::NavigationTarget;\n+\n pub(crate) fn function_label(node: &ast::FnDef) -> String {\n-    FunctionSignature::from(node).to_string()\n+    function_signature::FunctionSignature::from(node).to_string()\n }\n \n pub(crate) fn const_label(node: &ast::ConstDef) -> String {"}, {"sha": "9b7220d1fe30a5935c9b4600c9ccfa4c2422ac4a", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 19, "deletions": 42, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -15,49 +15,48 @@ use stdx::{split_delim, SepBy};\n use crate::display::{generic_parameters, where_predicates};\n \n #[derive(Debug)]\n-pub enum CallableKind {\n+pub(crate) enum CallableKind {\n     Function,\n     StructConstructor,\n     VariantConstructor,\n-    Macro,\n }\n \n /// Contains information about a function signature\n #[derive(Debug)]\n-pub struct FunctionSignature {\n-    pub kind: CallableKind,\n+pub(crate) struct FunctionSignature {\n+    pub(crate) kind: CallableKind,\n     /// Optional visibility\n-    pub visibility: Option<String>,\n+    pub(crate) visibility: Option<String>,\n     /// Qualifiers like `async`, `unsafe`, ...\n-    pub qualifier: FunctionQualifier,\n+    pub(crate) qualifier: FunctionQualifier,\n     /// Name of the function\n-    pub name: Option<String>,\n+    pub(crate) name: Option<String>,\n     /// Documentation for the function\n-    pub doc: Option<Documentation>,\n+    pub(crate) doc: Option<Documentation>,\n     /// Generic parameters\n-    pub generic_parameters: Vec<String>,\n+    pub(crate) generic_parameters: Vec<String>,\n     /// Parameters of the function\n-    pub parameters: Vec<String>,\n+    pub(crate) parameters: Vec<String>,\n     /// Parameter names of the function\n-    pub parameter_names: Vec<String>,\n+    pub(crate) parameter_names: Vec<String>,\n     /// Parameter types of the function\n-    pub parameter_types: Vec<String>,\n+    pub(crate) parameter_types: Vec<String>,\n     /// Optional return type\n-    pub ret_type: Option<String>,\n+    pub(crate) ret_type: Option<String>,\n     /// Where predicates\n-    pub where_predicates: Vec<String>,\n+    pub(crate) where_predicates: Vec<String>,\n     /// Self param presence\n-    pub has_self_param: bool,\n+    pub(crate) has_self_param: bool,\n }\n \n #[derive(Debug, Default)]\n-pub struct FunctionQualifier {\n+pub(crate) struct FunctionQualifier {\n     // `async` and `const` are mutually exclusive. Do we need to enforcing it here?\n-    pub is_async: bool,\n-    pub is_const: bool,\n-    pub is_unsafe: bool,\n+    pub(crate) is_async: bool,\n+    pub(crate) is_const: bool,\n+    pub(crate) is_unsafe: bool,\n     /// The string `extern \"..\"`\n-    pub extern_abi: Option<String>,\n+    pub(crate) extern_abi: Option<String>,\n }\n \n impl FunctionSignature {\n@@ -149,27 +148,6 @@ impl FunctionSignature {\n             has_self_param: false,\n         })\n     }\n-\n-    pub(crate) fn from_macro(db: &RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n-        let node: ast::MacroCall = macro_def.source(db).value;\n-\n-        let params = vec![];\n-\n-        Some(FunctionSignature {\n-            kind: CallableKind::Macro,\n-            visibility: None,\n-            qualifier: Default::default(),\n-            name: node.name().map(|n| n.text().to_string()),\n-            ret_type: None,\n-            parameters: params,\n-            parameter_names: vec![],\n-            parameter_types: vec![],\n-            generic_parameters: vec![],\n-            where_predicates: vec![],\n-            doc: macro_def.docs(db),\n-            has_self_param: false,\n-        })\n-    }\n }\n \n impl From<&'_ ast::FnDef> for FunctionSignature {\n@@ -298,7 +276,6 @@ impl Display for FunctionSignature {\n                 CallableKind::Function => write!(f, \"fn {}\", name)?,\n                 CallableKind::StructConstructor => write!(f, \"struct {}\", name)?,\n                 CallableKind::VariantConstructor => write!(f, \"{}\", name)?,\n-                CallableKind::Macro => write!(f, \"{}!\", name)?,\n             }\n         }\n "}, {"sha": "1f6a3febf37108565ccd0db728c988efb9dd685f", "filename": "crates/ra_ide/src/file_structure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "previous_filename": "crates/ra_ide/src/display/structure.rs"}, {"sha": "ae5695f613ff1121a09fdaea27f99cdb7e279564", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -5,10 +5,10 @@ use ra_syntax::{\n     ast::{self, ArgListOwner, AstNode, TypeAscriptionOwner},\n     match_ast, Direction, NodeOrToken, SmolStr, SyntaxKind, TextRange, T,\n };\n-\n-use crate::{FileId, FunctionSignature};\n use stdx::to_lower_snake_case;\n \n+use crate::{display::function_signature::FunctionSignature, FileId};\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct InlayHintsConfig {\n     pub type_hints: bool,\n@@ -322,15 +322,15 @@ fn get_fn_signature(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<\n     match expr {\n         ast::Expr::CallExpr(expr) => {\n             // FIXME: Type::as_callable is broken for closures\n-            let callable_def = sema.type_of_expr(&expr.expr()?)?.as_callable()?;\n-            match callable_def {\n-                hir::CallableDefId::FunctionId(it) => {\n+            let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db)?;\n+            match callable.kind() {\n+                hir::CallableKind::Function(it) => {\n                     Some(FunctionSignature::from_hir(sema.db, it.into()))\n                 }\n-                hir::CallableDefId::StructId(it) => {\n+                hir::CallableKind::TupleStruct(it) => {\n                     FunctionSignature::from_struct(sema.db, it.into())\n                 }\n-                hir::CallableDefId::EnumVariantId(it) => {\n+                hir::CallableKind::TupleEnumVariant(it) => {\n                     FunctionSignature::from_enum_variant(sema.db, it.into())\n                 }\n             }"}, {"sha": "d3b20f371b99857d3a47ec0d5e4308172a475961", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -19,29 +19,31 @@ pub mod mock_analysis;\n \n mod markup;\n mod prime_caches;\n-mod status;\n+mod display;\n+\n+mod call_hierarchy;\n+mod call_info;\n mod completion;\n-mod runnables;\n+mod diagnostics;\n+mod expand_macro;\n+mod extend_selection;\n+mod file_structure;\n+mod folding_ranges;\n mod goto_definition;\n-mod goto_type_definition;\n mod goto_implementation;\n-mod extend_selection;\n+mod goto_type_definition;\n mod hover;\n-mod call_hierarchy;\n-mod call_info;\n-mod syntax_highlighting;\n+mod inlay_hints;\n+mod join_lines;\n+mod matching_brace;\n mod parent_module;\n mod references;\n-mod diagnostics;\n+mod runnables;\n+mod ssr;\n+mod status;\n+mod syntax_highlighting;\n mod syntax_tree;\n-mod folding_ranges;\n-mod join_lines;\n mod typing;\n-mod matching_brace;\n-mod display;\n-mod inlay_hints;\n-mod expand_macro;\n-mod ssr;\n \n use std::sync::Arc;\n \n@@ -65,8 +67,9 @@ pub use crate::{\n         CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat,\n     },\n     diagnostics::Severity,\n-    display::{file_structure, FunctionSignature, NavigationTarget, StructureNode},\n+    display::NavigationTarget,\n     expand_macro::ExpandedMacro,\n+    file_structure::StructureNode,\n     folding_ranges::{Fold, FoldKind},\n     hover::{HoverAction, HoverConfig, HoverGotoTypeData, HoverResult},\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n@@ -323,7 +326,7 @@ impl Analysis {\n     /// Returns a tree representation of symbols in the file. Useful to draw a\n     /// file outline.\n     pub fn file_structure(&self, file_id: FileId) -> Cancelable<Vec<StructureNode>> {\n-        self.with_db(|db| file_structure(&db.parse(file_id).tree()))\n+        self.with_db(|db| file_structure::file_structure(&db.parse(file_id).tree()))\n     }\n \n     /// Returns a list of the places in the file where type hints can be displayed."}, {"sha": "753001949e2a523d4241c613683d020e0dbcb451", "filename": "crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -10,7 +10,7 @@ mod ssr;\n use std::io::Read;\n \n use anyhow::Result;\n-use ra_ide::{file_structure, Analysis};\n+use ra_ide::Analysis;\n use ra_prof::profile;\n use ra_syntax::{AstNode, SourceFile};\n \n@@ -48,8 +48,10 @@ pub fn parse(no_dump: bool) -> Result<()> {\n }\n \n pub fn symbols() -> Result<()> {\n-    let file = file()?;\n-    for s in file_structure(&file) {\n+    let text = read_stdin()?;\n+    let (analysis, file_id) = Analysis::from_single_file(text);\n+    let structure = analysis.file_structure(file_id).unwrap();\n+    for s in structure {\n         println!(\"{:?}\", s);\n     }\n     Ok(())"}, {"sha": "68b2a2abdd0c4679f3a2d675fe3ad10b852d49ea", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -127,6 +127,7 @@ pub struct ClientCapsConfig {\n     pub resolve_code_action: bool,\n     pub hover_actions: bool,\n     pub status_notification: bool,\n+    pub signature_help_label_offsets: bool,\n }\n \n impl Config {\n@@ -302,6 +303,15 @@ impl Config {\n             {\n                 self.client_caps.code_action_literals = value;\n             }\n+            if let Some(value) = doc_caps\n+                .signature_help\n+                .as_ref()\n+                .and_then(|it| it.signature_information.as_ref())\n+                .and_then(|it| it.parameter_information.as_ref())\n+                .and_then(|it| it.label_offset_support)\n+            {\n+                self.client_caps.signature_help_label_offsets = value;\n+            }\n \n             self.completion.allow_snippets(false);\n             if let Some(completion) = &doc_caps.completion {"}, {"sha": "18d660f427579699e27fe52d9de054f4a95456d6", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -553,21 +553,16 @@ pub(crate) fn handle_signature_help(\n     let _p = profile(\"handle_signature_help\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n     let call_info = match snap.analysis.call_info(position)? {\n-        None => return Ok(None),\n         Some(it) => it,\n+        None => return Ok(None),\n     };\n     let concise = !snap.config.call_info_full;\n-    let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n-    if concise && call_info.signature.has_self_param {\n-        active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n-    }\n-    let sig_info = to_proto::signature_information(call_info.signature, concise);\n-\n-    Ok(Some(lsp_types::SignatureHelp {\n-        signatures: vec![sig_info],\n-        active_signature: Some(0),\n-        active_parameter,\n-    }))\n+    let res = to_proto::signature_help(\n+        call_info,\n+        concise,\n+        snap.config.client_caps.signature_help_label_offsets,\n+    );\n+    Ok(Some(res))\n }\n \n pub(crate) fn handle_hover("}, {"sha": "7fcb43a4f77309b7bc815c5e66351aa1c381b8ae", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081596dd584ac39fbfa6a7e47dfe9dd4a58c362a/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=081596dd584ac39fbfa6a7e47dfe9dd4a58c362a", "patch": "@@ -4,8 +4,8 @@ use std::path::{self, Path};\n use itertools::Itertools;\n use ra_db::{FileId, FileRange};\n use ra_ide::{\n-    Assist, AssistKind, CompletionItem, CompletionItemKind, Documentation, FileSystemEdit, Fold,\n-    FoldKind, FunctionSignature, Highlight, HighlightModifier, HighlightTag, HighlightedRange,\n+    Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind, Documentation,\n+    FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag, HighlightedRange,\n     Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup, NavigationTarget,\n     ReferenceAccess, ResolvedAssist, Runnable, Severity, SourceChange, SourceFileEdit, TextEdit,\n };\n@@ -219,29 +219,72 @@ pub(crate) fn completion_item(\n     res\n }\n \n-pub(crate) fn signature_information(\n-    signature: FunctionSignature,\n+pub(crate) fn signature_help(\n+    call_info: CallInfo,\n     concise: bool,\n-) -> lsp_types::SignatureInformation {\n-    let (label, documentation, params) = if concise {\n-        let mut params = signature.parameters;\n-        if signature.has_self_param {\n-            params.remove(0);\n+    label_offsets: bool,\n+) -> lsp_types::SignatureHelp {\n+    let (label, parameters) = match (concise, label_offsets) {\n+        (_, false) => {\n+            let params = call_info\n+                .parameter_labels()\n+                .map(|label| lsp_types::ParameterInformation {\n+                    label: lsp_types::ParameterLabel::Simple(label.to_string()),\n+                    documentation: None,\n+                })\n+                .collect::<Vec<_>>();\n+            let label =\n+                if concise { call_info.parameter_labels().join(\", \") } else { call_info.signature };\n+            (label, params)\n+        }\n+        (false, true) => {\n+            let params = call_info\n+                .parameter_ranges()\n+                .iter()\n+                .map(|it| [u32::from(it.start()).into(), u32::from(it.end()).into()])\n+                .map(|label_offsets| lsp_types::ParameterInformation {\n+                    label: lsp_types::ParameterLabel::LabelOffsets(label_offsets),\n+                    documentation: None,\n+                })\n+                .collect::<Vec<_>>();\n+            (call_info.signature, params)\n+        }\n+        (true, true) => {\n+            let mut params = Vec::new();\n+            let mut label = String::new();\n+            let mut first = true;\n+            for param in call_info.parameter_labels() {\n+                if !first {\n+                    label.push_str(\", \");\n+                }\n+                first = false;\n+                let start = label.len() as u64;\n+                label.push_str(param);\n+                let end = label.len() as u64;\n+                params.push(lsp_types::ParameterInformation {\n+                    label: lsp_types::ParameterLabel::LabelOffsets([start, end]),\n+                    documentation: None,\n+                });\n+            }\n+\n+            (label, params)\n         }\n-        (params.join(\", \"), None, params)\n-    } else {\n-        (signature.to_string(), signature.doc.map(documentation), signature.parameters)\n     };\n \n-    let parameters: Vec<lsp_types::ParameterInformation> = params\n-        .into_iter()\n-        .map(|param| lsp_types::ParameterInformation {\n-            label: lsp_types::ParameterLabel::Simple(param),\n-            documentation: None,\n+    let documentation = call_info.doc.map(|doc| {\n+        lsp_types::Documentation::MarkupContent(lsp_types::MarkupContent {\n+            kind: lsp_types::MarkupKind::Markdown,\n+            value: doc,\n         })\n-        .collect();\n-\n-    lsp_types::SignatureInformation { label, documentation, parameters: Some(parameters) }\n+    });\n+\n+    let signature =\n+        lsp_types::SignatureInformation { label, documentation, parameters: Some(parameters) };\n+    lsp_types::SignatureHelp {\n+        signatures: vec![signature],\n+        active_signature: None,\n+        active_parameter: call_info.active_parameter.map(|it| it as i64),\n+    }\n }\n \n pub(crate) fn inlay_int(line_index: &LineIndex, inlay_hint: InlayHint) -> lsp_ext::InlayHint {"}]}