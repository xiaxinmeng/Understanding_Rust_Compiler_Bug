{"sha": "755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NWI0ZmIwMmIyYTFmY2M3ZDFlMjE2M2QxYjRiMzcwNjk5Nzg4Yzk=", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-04-16T19:29:35Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-04-17T16:55:28Z"}, "message": "rustdoc: move the cx argument to the end of the list\n\nThis should help make things consistent.", "tree": {"sha": "1c1d3ec2731ef33642ebcf0d98fb1020d424277a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c1d3ec2731ef33642ebcf0d98fb1020d424277a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "html_url": "https://github.com/rust-lang/rust/commit/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb0204861b8c870eaf972986e85fb682b3c337a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb0204861b8c870eaf972986e85fb682b3c337a6", "html_url": "https://github.com/rust-lang/rust/commit/bb0204861b8c870eaf972986e85fb682b3c337a6"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "ca364b9f103658609dc10090b9318bb60fec1d06", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "patch": "@@ -125,8 +125,8 @@ fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Displ\n }\n \n crate fn print_generic_bounds<'a, 'tcx: 'a>(\n-    cx: &'a Context<'tcx>,\n     bounds: &'a [clean::GenericBound],\n+    cx: &'a Context<'tcx>,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n     display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n@@ -155,9 +155,9 @@ impl clean::GenericParamDef {\n \n                 if !bounds.is_empty() {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", print_generic_bounds(cx, bounds))?;\n+                        write!(f, \": {:#}\", print_generic_bounds(bounds, cx))?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", print_generic_bounds(cx, bounds))?;\n+                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cx))?;\n                     }\n                 }\n \n@@ -239,13 +239,13 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n                         clause.push_str(&format!(\n                             \"{:#}: {:#}\",\n                             ty.print(cx),\n-                            print_generic_bounds(cx, bounds)\n+                            print_generic_bounds(bounds, cx)\n                         ));\n                     } else {\n                         clause.push_str(&format!(\n                             \"{}: {}\",\n                             ty.print(cx),\n-                            print_generic_bounds(cx, bounds)\n+                            print_generic_bounds(bounds, cx)\n                         ));\n                     }\n                 }\n@@ -819,9 +819,9 @@ fn fmt_type<'cx>(\n         }\n         clean::ImplTrait(ref bounds) => {\n             if f.alternate() {\n-                write!(f, \"impl {:#}\", print_generic_bounds(cx, bounds))\n+                write!(f, \"impl {:#}\", print_generic_bounds(bounds, cx))\n             } else {\n-                write!(f, \"impl {}\", print_generic_bounds(cx, bounds))\n+                write!(f, \"impl {}\", print_generic_bounds(bounds, cx))\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n@@ -1013,21 +1013,21 @@ impl clean::FnDecl {\n     /// * `asyncness`: Whether the function is async or not.\n     crate fn full_print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'tcx>,\n         header_len: usize,\n         indent: usize,\n         asyncness: hir::IsAsync,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        display_fn(move |f| self.inner_full_print(cx, header_len, indent, asyncness, f))\n+        display_fn(move |f| self.inner_full_print(header_len, indent, asyncness, f, cx))\n     }\n \n     fn inner_full_print(\n         &self,\n-        cx: &Context<'_>,\n         header_len: usize,\n         indent: usize,\n         asyncness: hir::IsAsync,\n         f: &mut fmt::Formatter<'_>,\n+        cx: &Context<'_>,\n     ) -> fmt::Result {\n         let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n         let mut args = String::new();\n@@ -1134,8 +1134,8 @@ impl clean::FnDecl {\n impl clean::Visibility {\n     crate fn print_with_space<'a, 'tcx: 'a>(\n         self,\n-        cx: &'a Context<'tcx>,\n         item_did: DefId,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         let to_print = match self {\n             clean::Public => \"pub \".to_owned(),\n@@ -1320,9 +1320,9 @@ impl clean::TypeBinding {\n                 clean::TypeBindingKind::Constraint { ref bounds } => {\n                     if !bounds.is_empty() {\n                         if f.alternate() {\n-                            write!(f, \": {:#}\", print_generic_bounds(cx, bounds))?;\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds, cx))?;\n                         } else {\n-                            write!(f, \":&nbsp;{}\", print_generic_bounds(cx, bounds))?;\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cx))?;\n                         }\n                     }\n                 }"}, {"sha": "d10b612a7379992234fcd7bffa2569499002ad25", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "patch": "@@ -815,7 +815,7 @@ fn assoc_const(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(cx, it.def_id),\n+        it.visibility.print_with_space(it.def_id, cx),\n         naive_assoc_href(it, link, cx),\n         it.name.as_ref().unwrap(),\n         ty.print(cx)\n@@ -839,7 +839,7 @@ fn assoc_type(\n         it.name.as_ref().unwrap()\n     );\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", print_generic_bounds(cx, bounds))\n+        write!(w, \": {}\", print_generic_bounds(bounds, cx))\n     }\n     if let Some(default) = default {\n         write!(w, \" = {}\", default.print(cx))\n@@ -910,7 +910,7 @@ fn render_assoc_item(\n                     .unwrap_or_else(|| format!(\"#{}.{}\", ty, name))\n             }\n         };\n-        let vis = meth.visibility.print_with_space(cx, meth.def_id).to_string();\n+        let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n         let constness = header.constness.print_with_space();\n         let asyncness = header.asyncness.print_with_space();\n         let unsafety = header.unsafety.print_with_space();\n@@ -952,7 +952,7 @@ fn render_assoc_item(\n             href = href,\n             name = name,\n             generics = g.print(cx),\n-            decl = d.full_print(cx, header_len, indent, header.asyncness),\n+            decl = d.full_print(header_len, indent, header.asyncness, cx),\n             notable_traits = notable_traits_decl(&d, cx),\n             where_clause = print_where_clause(g, cx, indent, end_newline),\n         )"}, {"sha": "42b795030171bef143f38bbf187ad2a97452947d", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755b4fb02b2a1fcc7d1e2163d1b4b370699788c9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=755b4fb02b2a1fcc7d1e2163d1b4b370699788c9", "patch": "@@ -267,14 +267,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(cx, myitem.def_id),\n+                        myitem.visibility.print_with_space(myitem.def_id, cx),\n                         anchor(myitem.def_id, &*src.as_str(), cx),\n                         myitem.name.as_ref().unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(cx, myitem.def_id),\n+                        myitem.visibility.print_with_space(myitem.def_id, cx),\n                         anchor(myitem.def_id, &*myitem.name.as_ref().unwrap().as_str(), cx),\n                     ),\n                 }\n@@ -285,7 +285,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 write!(\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(cx, myitem.def_id),\n+                    myitem.visibility.print_with_space(myitem.def_id, cx),\n                     import.print(cx),\n                 );\n             }\n@@ -386,7 +386,7 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(cx, it.def_id),\n+        it.visibility.print_with_space(it.def_id, cx),\n         f.header.constness.print_with_space(),\n         f.header.asyncness.print_with_space(),\n         f.header.unsafety.print_with_space(),\n@@ -401,15 +401,15 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         w,\n         \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n          {name}{generics}{decl}{notable_traits}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(cx, it.def_id),\n+        vis = it.visibility.print_with_space(it.def_id, cx),\n         constness = f.header.constness.print_with_space(),\n         asyncness = f.header.asyncness.print_with_space(),\n         unsafety = f.header.unsafety.print_with_space(),\n         abi = print_abi_with_space(f.header.abi),\n         name = it.name.as_ref().unwrap(),\n         generics = f.generics.print(cx),\n         where_clause = print_where_clause(&f.generics, cx, 0, true),\n-        decl = f.decl.full_print(cx, header_len, 0, f.header.asyncness),\n+        decl = f.decl.full_print(header_len, 0, f.header.asyncness, cx),\n         notable_traits = notable_traits_decl(&f.decl, cx),\n     );\n     document(w, cx, it, None)\n@@ -429,7 +429,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(cx, it.def_id),\n+            it.visibility.print_with_space(it.def_id, cx),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n@@ -848,7 +848,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(cx, it.def_id),\n+            it.visibility.print_with_space(it.def_id, cx),\n             it.name.as_ref().unwrap(),\n             e.generics.print(cx),\n             print_where_clause(&e.generics, cx, 0, true),\n@@ -1029,7 +1029,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(cx, it.def_id),\n+        vis = it.visibility.print_with_space(it.def_id, cx),\n         name = it.name.as_ref().unwrap(),\n         typ = c.type_.print(cx),\n     );\n@@ -1116,7 +1116,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(cx, it.def_id),\n+        vis = it.visibility.print_with_space(it.def_id, cx),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n         typ = s.type_.print(cx)\n@@ -1130,7 +1130,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(cx, it.def_id),\n+        it.visibility.print_with_space(it.def_id, cx),\n         it.name.as_ref().unwrap(),\n     );\n \n@@ -1289,7 +1289,7 @@ fn render_union(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx, it.def_id),\n+        it.visibility.print_with_space(it.def_id, cx),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -1311,7 +1311,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(cx, field.def_id),\n+                field.visibility.print_with_space(field.def_id, cx),\n                 field.name.as_ref().unwrap(),\n                 ty.print(cx),\n                 tab\n@@ -1341,7 +1341,7 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx, it.def_id),\n+        it.visibility.print_with_space(it.def_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -1367,7 +1367,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(cx, field.def_id),\n+                        field.visibility.print_with_space(field.def_id, cx),\n                         field.name.as_ref().unwrap(),\n                         ty.print(cx),\n                     );\n@@ -1401,7 +1401,7 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(cx, field.def_id),\n+                            field.visibility.print_with_space(field.def_id, cx),\n                             ty.print(cx),\n                         )\n                     }"}]}