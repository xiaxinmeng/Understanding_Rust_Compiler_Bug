{"sha": "01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYzExZjlmYjUwMWNiYWVhMDFiYzk0ZmNkYWU3ZTFlMzJmNzM1ODE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-20T16:51:25Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-11T20:14:32Z"}, "message": "avoid the loop in unwinding stack popping", "tree": {"sha": "9f94ea0db5dfe01d4be211bc06af98156738d1e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f94ea0db5dfe01d4be211bc06af98156738d1e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl3JwSgACgkQtAh+UQ6Y\nsWQerA/9GVGnyH3TeaeJtdMLq24dStGHElNmAqzoJXc0llbmbDYfZyDyCNVMLuEy\nLM3tpZ+Z6Qh5JDMnkGpML7PpTDclnFV+uKpqlhmHzjss9VmL7su+CWN+Igg0VnJ6\nS5hil0R2qnocZJrQ6qTfdkfeYDbdivySIpx+QW1lozeK3o731tzg6OynvClS6qzg\nUXjG6d08XguJhBoxxTrai3XRGSYkMJzyg13ywoHAnYuu0ADOuXoHL4Asdt0mcfDK\nz7c0x0EtTfjooiSD9/IuIxsisjHDGJ7uMSebBNbA3WBlk2Px7NJ9TALQunkWqlVa\nUaok6BkDECh8NNoeTYa3Qr4/uBQse74yawc4CoziwT6xM3HkIG/kmAnB3Av7Zj/4\nZil/ajCJIQ4pgcHn47pnzSz6rKzLizDY3s4IijonzOnUKowf3a6X8CiyUcNM5mTr\nuFKlKIWkAd143sji0nu6yRKqNzOVhMiZHvevH8njV3lL8yq6Zx3k2/Pdm3d+KkX0\n94fE5Sm9aV7Kq2fC37UG5o1WnY6qc8W08PeUdMJEKY8EN7GJXkTfo59JSA10INxq\nouWafZ3cLtVl+BtsryB0TPR009X3BteK4uAwBuN19BjU6kjQ1dIJe42Y8gCVbuI/\nBM2RjZGEdoeM6BDPIhwDOL7o4kfsZM5brWQXcbpg/JTpCeWCtyc=\n=jLEw\n-----END PGP SIGNATURE-----", "payload": "tree 9f94ea0db5dfe01d4be211bc06af98156738d1e5\nparent 499eb5d8315b0a8715e1f21e291fd70cb00e46ce\nauthor Ralf Jung <post@ralfj.de> 1571590285 +0200\ncommitter Aaron Hill <aa1ronham@gmail.com> 1573503272 -0500\n\navoid the loop in unwinding stack popping\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "html_url": "https://github.com/rust-lang/rust/commit/01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "499eb5d8315b0a8715e1f21e291fd70cb00e46ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/499eb5d8315b0a8715e1f21e291fd70cb00e46ce", "html_url": "https://github.com/rust-lang/rust/commit/499eb5d8315b0a8715e1f21e291fd70cb00e46ce"}], "stats": {"total": 192, "additions": 85, "deletions": 107}, "files": [{"sha": "b02a42ff0d8d54782b1e4f67feff1cb69228dceb", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 71, "deletions": 102, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "patch": "@@ -60,6 +60,9 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     /// The span of the call site.\n     pub span: source_map::Span,\n \n+    /// Extra data for the machine.\n+    pub extra: Extra,\n+\n     ////////////////////////////////////////////////////////////////////////////////\n     // Return place and locals\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -82,13 +85,12 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     /// The block that is currently executed (or will be executed after the above call stacks\n     /// return).\n-    pub block: mir::BasicBlock,\n+    /// If this is `None`, we are unwinding and this function doesn't need any clean-up.\n+    /// Just continue the same as with\n+    pub block: Option<mir::BasicBlock>,\n \n     /// The index of the currently evaluated statement.\n     pub stmt: usize,\n-\n-    /// Extra data for the machine.\n-    pub extra: Extra,\n }\n \n #[derive(Clone, Eq, PartialEq, Debug)] // Miri debug-prints these\n@@ -491,7 +493,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let extra = M::stack_push(self)?;\n         self.stack.push(Frame {\n             body,\n-            block: mir::START_BLOCK,\n+            block: Some(mir::START_BLOCK),\n             return_to_block,\n             return_place,\n             // empty local array, we fill it in below, after we are inside the stack frame and\n@@ -549,51 +551,75 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn pop_stack_frame_internal(\n+    pub(super) fn pop_stack_frame(\n         &mut self,\n         unwinding: bool\n-    ) -> InterpResult<'tcx, (StackPopCleanup, StackPopInfo)> {\n+    ) -> InterpResult<'tcx> {\n         info!(\"LEAVING({}) {} (unwinding = {})\",\n             self.cur_frame(), self.frame().instance, unwinding);\n \n+        // Sanity check `unwinding`.\n+        assert_eq!(\n+            unwinding,\n+            match self.frame().block {\n+                None => true,\n+                Some(block) => self.body().basic_blocks()[block].is_cleanup\n+            }\n+        );\n+\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n         let stack_pop_info = M::stack_pop(self, frame.extra)?;\n+        match (unwinding, stack_pop_info) {\n+            (true, StackPopInfo::StartUnwinding) =>\n+                bug!(\"Attempted to start unwinding while already unwinding!\"),\n+            (false, StackPopInfo::StopUnwinding) =>\n+                bug!(\"Attempted to stop unwinding while there is no unwinding!\"),\n+            _ => {}\n+        }\n \n-        // Abort early if we do not want to clean up: We also avoid validation in that case,\n+        // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n+        // In that case, we return early. We also avoid validation in that case,\n         // because this is CTFE and the final value will be thoroughly validated anyway.\n-        match frame.return_to_block {\n-            StackPopCleanup::Goto{ .. } => {},\n+        let cleanup = unwinding || match frame.return_to_block {\n+            StackPopCleanup::Goto{ .. } => true,\n             StackPopCleanup::None { cleanup, .. } => {\n-                assert!(!unwinding, \"Encountered StackPopCleanup::None while unwinding\");\n-\n-                if !cleanup {\n-                    assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n-                    // Leak the locals, skip validation.\n-                    return Ok((frame.return_to_block, stack_pop_info));\n-                }\n+                cleanup\n             }\n+        };\n+        if !cleanup {\n+            assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n+            // Leak the locals, skip validation.\n+            return Ok(());\n         }\n-        // Deallocate all locals that are backed by an allocation.\n+\n+        // Cleanup: deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n             self.deallocate_local(local.value)?;\n         }\n \n-        // If we're popping frames due to unwinding, and we didn't just exit\n-        // unwinding, we skip a bunch of validation and cleanup logic (including\n-        // jumping to the regular return block specified in the StackPopCleanup)\n-        let cur_unwinding = unwinding && stack_pop_info != StackPopInfo::StopUnwinding;\n+        // Now where do we jump next?\n \n-        info!(\"StackPopCleanup: {:?} StackPopInfo: {:?} cur_unwinding = {:?}\",\n+        // Determine if we leave this function normally or via unwinding.\n+        let cur_unwinding = unwinding && stack_pop_info != StackPopInfo::StopUnwinding;\n+        trace!(\"StackPopCleanup: {:?} StackPopInfo: {:?} cur_unwinding = {:?}\",\n                frame.return_to_block, stack_pop_info, cur_unwinding);\n-\n-\n-        // When we're popping a stack frame for unwinding purposes,\n-        // we don't care at all about returning-related stuff (i.e. return_place\n-        // and return_to_block), because we're not performing a return from this frame.\n-        if !cur_unwinding  {\n+        if cur_unwinding {\n+            // Follow the unwind edge.\n+            match frame.return_to_block {\n+                StackPopCleanup::Goto { unwind, .. } => {\n+                    let next_frame = self.frame_mut();\n+                    // If `unwind` is `None`, we'll leave that function immediately again.\n+                    next_frame.block = unwind;\n+                    next_frame.stmt = 0;\n+                },\n+                StackPopCleanup::None { .. } =>\n+                    bug!(\"Encountered StackPopCleanup::None while unwinding\"),\n+            }\n+        } else {\n+            // Follow the normal return edge.\n             // Validate the return value. Do this after deallocating so that we catch dangling\n             // references.\n             if let Some(return_place) = frame.return_place {\n@@ -625,70 +651,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-\n-        Ok((frame.return_to_block, stack_pop_info))\n-    }\n-\n-    pub(super) fn pop_stack_frame(&mut self, unwinding: bool) -> InterpResult<'tcx> {\n-        let (mut cleanup, mut stack_pop_info) = self.pop_stack_frame_internal(unwinding)?;\n-\n-        // There are two cases where we want to unwind the stack:\n-        // * The caller explicitly told us (i.e. we hit a Resume terminator)\n-        // * The machine indicated that we've just started unwinding (i.e.\n-        // a panic has just occured)\n-        if unwinding || stack_pop_info == StackPopInfo::StartUnwinding {\n-            trace!(\"unwinding: starting stack unwind...\");\n-            // Overwrite our current stack_pop_info, so that the check\n-            // below doesn't fail.\n-            stack_pop_info = StackPopInfo::Normal;\n-            // There are three posible ways that we can exit the loop:\n-            // 1) We find an unwind block - we jump to it to allow cleanup\n-            // to occur for that frame\n-            // 2) pop_stack_frame_internal reports that we're no longer unwinding\n-            //    - this means that the panic has been caught, and that execution\n-            //    should continue as normal\n-            // 3) We pop all of our frames off the stack - this should never happen.\n-            while !self.stack.is_empty() {\n-                match stack_pop_info {\n-                    // We tried to start unwinding while we were already\n-                    // unwinding. Note that this **is not** the same thing\n-                    // as a double panic, which will be intercepted by\n-                    // libcore/libstd before we actually attempt to unwind.\n-                    StackPopInfo::StartUnwinding => {\n-                        throw_ub_format!(\"Attempted to start unwinding while already unwinding!\");\n-                    },\n-                    StackPopInfo::StopUnwinding => {\n-                        trace!(\"unwinding: no longer unwinding!\");\n-                        break;\n-                    }\n-                    StackPopInfo::Normal => {}\n-                }\n-\n-                match cleanup {\n-                    StackPopCleanup::Goto { unwind, .. } if unwind.is_some() => {\n-\n-                        info!(\"unwind: found cleanup block {:?}\", unwind);\n-                        self.goto_block(unwind)?;\n-                        break;\n-                    },\n-                    _ => {}\n-                }\n-\n-                info!(\"unwinding: popping frame!\");\n-                let res = self.pop_stack_frame_internal(true)?;\n-                cleanup = res.0;\n-                stack_pop_info = res.1;\n-            }\n-            if self.stack.is_empty() {\n-                // We should never get here:\n-                // The 'start_fn' lang item should always install a panic handler\n-                throw_ub!(Unreachable);\n-            }\n-\n-        }\n-\n         if self.stack.len() > 0 {\n-            info!(\"CONTINUING({}) {}\", self.cur_frame(), self.frame().instance);\n+            info!(\"CONTINUING({}) {} (unwinding = {})\",\n+                self.cur_frame(), self.frame().instance, cur_unwinding);\n         }\n \n         Ok(())\n@@ -833,16 +798,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             } else {\n                 last_span = Some(span);\n             }\n-            let block = &body.basic_blocks()[block];\n-            let source_info = if stmt < block.statements.len() {\n-                block.statements[stmt].source_info\n-            } else {\n-                block.terminator().source_info\n-            };\n-            let lint_root = match body.source_scope_local_data {\n-                mir::ClearCrossCrate::Set(ref ivs) => Some(ivs[source_info.scope].lint_root),\n-                mir::ClearCrossCrate::Clear => None,\n-            };\n+\n+            let lint_root = block.and_then(|block| {\n+                let block = &body.basic_blocks()[block];\n+                let source_info = if stmt < block.statements.len() {\n+                    block.statements[stmt].source_info\n+                } else {\n+                    block.terminator().source_info\n+                };\n+                match body.source_scope_local_data {\n+                    mir::ClearCrossCrate::Set(ref ivs) => Some(ivs[source_info.scope].lint_root),\n+                    mir::ClearCrossCrate::Clear => None,\n+                }\n+            });\n+\n             frames.push(FrameInfo { call_site: span, instance, lint_root });\n         }\n         trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);"}, {"sha": "995f1199047c35c52414bc07fade179ca1c0480f", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "patch": "@@ -18,7 +18,7 @@ use super::{\n \n /// Data returned by Machine::stack_pop,\n /// to provide further control over the popping of the stack frame\n-#[derive(Eq, PartialEq, Debug)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum StackPopInfo {\n     /// Indicates that we have just started unwinding\n     /// as the result of panic"}, {"sha": "7f3ea0283cda38d2614458a04ee83498fd922573", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "patch": "@@ -326,7 +326,7 @@ struct FrameSnapshot<'a, 'tcx> {\n     return_to_block: &'a StackPopCleanup,\n     return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n     locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n-    block: &'a mir::BasicBlock,\n+    block: Option<mir::BasicBlock>,\n     stmt: usize,\n }\n \n@@ -364,7 +364,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             instance: *instance,\n             span: *span,\n             return_to_block,\n-            block,\n+            block: *block,\n             stmt: *stmt,\n             return_place: return_place.map(|r| r.snapshot(ctx)),\n             locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),"}, {"sha": "d7493338a5352f083a9db4a3733366d44baf7715", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "patch": "@@ -49,7 +49,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n \n-        let block = self.frame().block;\n+        let block = match self.frame().block {\n+            Some(block) => block,\n+            None => {\n+                // We are unwinding and this fn has no cleanup code.\n+                // Just go on unwinding.\n+                trace!(\"unwinding: skipping frame\");\n+                self.pop_stack_frame(/* unwinding */ true)?;\n+                return Ok(true)\n+            }\n+        };\n         let stmt_id = self.frame().stmt;\n         let body = self.body();\n         let basic_block = &body.basic_blocks()[block];"}, {"sha": "bed6c5bea543658589f5f54c45bb60c99cbaf128", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01c11f9fb501cbaea01bc94fcdae7e1e32f73581/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=01c11f9fb501cbaea01bc94fcdae7e1e32f73581", "patch": "@@ -15,7 +15,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {\n-            self.frame_mut().block = target;\n+            self.frame_mut().block = Some(target);\n             self.frame_mut().stmt = 0;\n             Ok(())\n         } else {"}]}