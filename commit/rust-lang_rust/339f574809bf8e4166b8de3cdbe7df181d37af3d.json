{"sha": "339f574809bf8e4166b8de3cdbe7df181d37af3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzOWY1NzQ4MDliZjhlNDE2NmI4ZGUzY2RiZTdkZjE4MWQzN2FmM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-06T11:24:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-06T11:24:13Z"}, "message": "Auto merge of #71949 - Dylan-DPC:rollup-0gg02wd, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #71510 (Btreemap iter intertwined)\n - #71727 (SipHasher with keys initialized to 0 should just use new())\n - #71889 (Explain our RwLock implementation)\n - #71905 (Add command aliases from Cargo to x.py commands)\n - #71914 (Backport 1.43.1 release notes to master)\n - #71921 (explain the types used in the open64 call)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "37c3fb4745e7d4415233d21c70eba1595fca85cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37c3fb4745e7d4415233d21c70eba1595fca85cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/339f574809bf8e4166b8de3cdbe7df181d37af3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/339f574809bf8e4166b8de3cdbe7df181d37af3d", "html_url": "https://github.com/rust-lang/rust/commit/339f574809bf8e4166b8de3cdbe7df181d37af3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/339f574809bf8e4166b8de3cdbe7df181d37af3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8da5869fb738e51438dd1e0697c1b2c84eb11c59", "url": "https://api.github.com/repos/rust-lang/rust/commits/8da5869fb738e51438dd1e0697c1b2c84eb11c59", "html_url": "https://github.com/rust-lang/rust/commit/8da5869fb738e51438dd1e0697c1b2c84eb11c59"}, {"sha": "b86620a558dd662fe4261b8c0a2798b7c3d1f068", "url": "https://api.github.com/repos/rust-lang/rust/commits/b86620a558dd662fe4261b8c0a2798b7c3d1f068", "html_url": "https://github.com/rust-lang/rust/commit/b86620a558dd662fe4261b8c0a2798b7c3d1f068"}], "stats": {"total": 312, "additions": 195, "deletions": 117}, "files": [{"sha": "8ea481f7e18cdc78714aaba8d13dbe4ef4aa6b30", "filename": "RELEASES.md", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -1,3 +1,15 @@\n+Version 1.43.1 (2020-05-07)\n+===========================\n+\n+* [Updated openssl-src to 1.1.1g for CVE-2020-1967.][71430]\n+* [Fixed the stabilization of AVX-512 features.][71473]\n+* [Fixed `cargo package --list` not working with unpublished dependencies.][cargo/8151]\n+\n+[71430]: https://github.com/rust-lang/rust/pull/71430\n+[71473]: https://github.com/rust-lang/rust/issues/71473\n+[cargo/8151]: https://github.com/rust-lang/cargo/issues/8151\n+\n+\n Version 1.43.0 (2020-04-23)\n ==========================\n \n@@ -14,7 +26,7 @@ Language\n - [Merge `fn` syntax + cleanup item parsing.][68728]\n - [`item` macro fragments can be interpolated into `trait`s, `impl`s, and `extern` blocks.][69366]\n   For example, you may now write:\n-  ```rust \n+  ```rust\n   macro_rules! mac_trait {\n       ($i:item) => {\n           trait T { $i }\n@@ -82,7 +94,7 @@ Misc\n - [Certain checks in the `const_err` lint were deemed unrelated to const\n   evaluation][69185], and have been moved to the `unconditional_panic` and\n   `arithmetic_overflow` lints.\n-  \n+\n Compatibility Notes\n -------------------\n \n@@ -173,7 +185,7 @@ Language\n      (e.g. `type Foo: Ord;`).\n    - `...` (the C-variadic type) may occur syntactically directly as the type of\n       any function parameter.\n-  \n+\n   These are still rejected *semantically*, so you will likely receive an error\n   but these changes can be seen and parsed by procedural macros and\n   conditional compilation.\n@@ -465,7 +477,7 @@ Compatibility Notes\n - [Using `#[inline]` on function prototypes and consts now emits a warning under\n   `unused_attribute` lint.][65294] Using `#[inline]` anywhere else inside traits\n   or `extern` blocks now correctly emits a hard error.\n-  \n+\n [65294]: https://github.com/rust-lang/rust/pull/65294/\n [66103]: https://github.com/rust-lang/rust/pull/66103/\n [65843]: https://github.com/rust-lang/rust/pull/65843/"}, {"sha": "fb380af0a47e71bc9e202750575ccc36a610b4ce", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -106,18 +106,18 @@ impl Flags {\n Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n-    build       Compile either the compiler or libraries\n-    check       Compile either the compiler or libraries, using cargo check\n+    build, b    Compile either the compiler or libraries\n+    check, c    Compile either the compiler or libraries, using cargo check\n     clippy      Run clippy (uses rustup/cargo-installed clippy binary)\n     fix         Run cargo fix\n     fmt         Run rustfmt\n-    test        Build and run some test suites\n+    test, t     Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n     clean       Clean out build directories\n     dist        Build distribution artifacts\n     install     Install distribution artifacts\n-    run         Run tools contained in this repository\n+    run, r      Run tools contained in this repository\n \n To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         );\n@@ -184,17 +184,21 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         // there on out.\n         let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n+                || (s == \"b\")\n                 || (s == \"check\")\n+                || (s == \"c\")\n                 || (s == \"clippy\")\n                 || (s == \"fix\")\n                 || (s == \"fmt\")\n                 || (s == \"test\")\n+                || (s == \"t\")\n                 || (s == \"bench\")\n                 || (s == \"doc\")\n                 || (s == \"clean\")\n                 || (s == \"dist\")\n                 || (s == \"install\")\n                 || (s == \"run\")\n+                || (s == \"r\")\n         });\n         let subcommand = match subcommand {\n             Some(s) => s,\n@@ -210,7 +214,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n \n         // Some subcommands get extra options\n         match subcommand.as_str() {\n-            \"test\" => {\n+            \"test\" | \"t\" => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n                 opts.optmulti(\n@@ -285,7 +289,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         }\n         // Extra help text for some commands\n         match subcommand.as_str() {\n-            \"build\" => {\n+            \"build\" | \"b\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -312,7 +316,7 @@ Arguments:\n     Once this is done, build/$ARCH/stage1 contains a usable compiler.\",\n                 );\n             }\n-            \"check\" => {\n+            \"check\" | \"c\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -362,7 +366,7 @@ Arguments:\n         ./x.py fmt --check\",\n                 );\n             }\n-            \"test\" => {\n+            \"test\" | \"t\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -407,7 +411,7 @@ Arguments:\n         ./x.py doc --stage 1\",\n                 );\n             }\n-            \"run\" => {\n+            \"run\" | \"r\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -453,11 +457,11 @@ Arguments:\n         }\n \n         let cmd = match subcommand.as_str() {\n-            \"build\" => Subcommand::Build { paths },\n-            \"check\" => Subcommand::Check { paths },\n+            \"build\" | \"b\" => Subcommand::Build { paths },\n+            \"check\" | \"c\" => Subcommand::Check { paths },\n             \"clippy\" => Subcommand::Clippy { paths },\n             \"fix\" => Subcommand::Fix { paths },\n-            \"test\" => Subcommand::Test {\n+            \"test\" | \"t\" => Subcommand::Test {\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n                 compare_mode: matches.opt_str(\"compare-mode\"),\n@@ -487,7 +491,7 @@ Arguments:\n             \"fmt\" => Subcommand::Format { check: matches.opt_present(\"check\") },\n             \"dist\" => Subcommand::Dist { paths },\n             \"install\" => Subcommand::Install { paths },\n-            \"run\" => {\n+            \"run\" | \"r\" => {\n                 if paths.is_empty() {\n                     println!(\"\\nrun requires at least a path!\\n\");\n                     usage(1, &opts, &subcommand_help, &extra_help);"}, {"sha": "38d19c59ad186edfbad8b6d8f972320d9df57f22", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -1,6 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n-use std::ops::Bound::{Excluded, Unbounded};\n+use std::ops::RangeBounds;\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -117,7 +117,7 @@ map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n-fn bench_iter(b: &mut Bencher, size: i32) {\n+fn bench_iteration(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -133,21 +133,21 @@ fn bench_iter(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_20(b: &mut Bencher) {\n-    bench_iter(b, 20);\n+pub fn iteration_20(b: &mut Bencher) {\n+    bench_iteration(b, 20);\n }\n \n #[bench]\n-pub fn iter_1000(b: &mut Bencher) {\n-    bench_iter(b, 1000);\n+pub fn iteration_1000(b: &mut Bencher) {\n+    bench_iteration(b, 1000);\n }\n \n #[bench]\n-pub fn iter_100000(b: &mut Bencher) {\n-    bench_iter(b, 100000);\n+pub fn iteration_100000(b: &mut Bencher) {\n+    bench_iteration(b, 100000);\n }\n \n-fn bench_iter_mut(b: &mut Bencher, size: i32) {\n+fn bench_iteration_mut(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -163,18 +163,18 @@ fn bench_iter_mut(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_mut_20(b: &mut Bencher) {\n-    bench_iter_mut(b, 20);\n+pub fn iteration_mut_20(b: &mut Bencher) {\n+    bench_iteration_mut(b, 20);\n }\n \n #[bench]\n-pub fn iter_mut_1000(b: &mut Bencher) {\n-    bench_iter_mut(b, 1000);\n+pub fn iteration_mut_1000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 1000);\n }\n \n #[bench]\n-pub fn iter_mut_100000(b: &mut Bencher) {\n-    bench_iter_mut(b, 100000);\n+pub fn iteration_mut_100000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 100000);\n }\n \n fn bench_first_and_last(b: &mut Bencher, size: i32) {\n@@ -202,57 +202,83 @@ pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n \n-#[bench]\n-pub fn range_excluded_excluded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+const BENCH_RANGE_SIZE: i32 = 145;\n+const BENCH_RANGE_COUNT: i32 = BENCH_RANGE_SIZE * (BENCH_RANGE_SIZE - 1) / 2;\n+\n+fn bench_range<F, R>(b: &mut Bencher, f: F)\n+where\n+    F: Fn(i32, i32) -> R,\n+    R: RangeBounds<i32>,\n+{\n+    let map: BTreeMap<_, _> = (0..BENCH_RANGE_SIZE).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            for last in first + 1..size {\n-                black_box(map.range((Excluded(first), Excluded(last))));\n+        let mut c = 0;\n+        for i in 0..BENCH_RANGE_SIZE {\n+            for j in i + 1..BENCH_RANGE_SIZE {\n+                black_box(map.range(f(i, j)));\n+                c += 1;\n             }\n         }\n+        debug_assert_eq!(c, BENCH_RANGE_COUNT);\n     });\n }\n \n #[bench]\n-pub fn range_excluded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range((Excluded(first), Unbounded)));\n-        }\n-    });\n+pub fn range_included_excluded(b: &mut Bencher) {\n+    bench_range(b, |i, j| i..j);\n }\n \n #[bench]\n pub fn range_included_included(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            for last in first..size {\n-                black_box(map.range(first..=last));\n-            }\n-        }\n-    });\n+    bench_range(b, |i, j| i..=j);\n }\n \n #[bench]\n pub fn range_included_unbounded(b: &mut Bencher) {\n-    let size = 144;\n+    bench_range(b, |i, _| i..);\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    bench_range(b, |_, _| ..);\n+}\n+\n+fn bench_iter(b: &mut Bencher, repeats: i32, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range(first..));\n+        for _ in 0..repeats {\n+            black_box(map.iter());\n         }\n     });\n }\n \n+/// Contrast range_unbounded_unbounded with `iter()`.\n #[bench]\n-pub fn range_unbounded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| map.range(..));\n+pub fn range_unbounded_vs_iter(b: &mut Bencher) {\n+    bench_iter(b, BENCH_RANGE_COUNT, BENCH_RANGE_SIZE);\n+}\n+\n+#[bench]\n+pub fn iter_0(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 0);\n+}\n+\n+#[bench]\n+pub fn iter_1(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1);\n+}\n+\n+#[bench]\n+pub fn iter_100(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 100);\n+}\n+\n+#[bench]\n+pub fn iter_10k(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 10_000);\n+}\n+\n+#[bench]\n+pub fn iter_1m(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1_000_000);\n }"}, {"sha": "98a94d695f78444acbdd0e123272c641ba0a0249", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -1540,16 +1540,10 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n \n     fn into_iter(self) -> IntoIter<K, V> {\n         let mut me = ManuallyDrop::new(self);\n-        if let Some(root) = me.root.as_mut() {\n-            let root1 = unsafe { ptr::read(root).into_ref() };\n-            let root2 = unsafe { ptr::read(root).into_ref() };\n-            let len = me.length;\n-\n-            IntoIter {\n-                front: Some(root1.first_leaf_edge()),\n-                back: Some(root2.last_leaf_edge()),\n-                length: len,\n-            }\n+        if let Some(root) = me.root.take() {\n+            let (f, b) = full_range_search(root.into_ref());\n+\n+            IntoIter { front: Some(f), back: Some(b), length: me.length }\n         } else {\n             IntoIter { front: None, back: None, length: 0 }\n         }\n@@ -2037,6 +2031,7 @@ where\n     }\n }\n \n+/// Finds the leaf edges delimiting a specified range in or underneath a node.\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R,\n@@ -2122,6 +2117,33 @@ where\n     }\n }\n \n+/// Equivalent to `range_search(k, v, ..)` without the `Ord` bound.\n+fn full_range_search<BorrowType, K, V>(\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+) {\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n+    loop {\n+        let front = min_node.first_edge();\n+        let back = max_node.last_edge();\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            }\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            }\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -2146,12 +2168,12 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            range: Range {\n-                front: self.root.as_ref().map(|r| r.as_ref().first_leaf_edge()),\n-                back: self.root.as_ref().map(|r| r.as_ref().last_leaf_edge()),\n-            },\n-            length: self.length,\n+        if let Some(root) = &self.root {\n+            let (f, b) = full_range_search(root.as_ref());\n+\n+            Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n+        } else {\n+            Iter { range: Range { front: None, back: None }, length: 0 }\n         }\n     }\n \n@@ -2178,19 +2200,15 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        IterMut {\n-            range: if let Some(root) = &mut self.root {\n-                let root1 = root.as_mut();\n-                let root2 = unsafe { ptr::read(&root1) };\n-                RangeMut {\n-                    front: Some(root1.first_leaf_edge()),\n-                    back: Some(root2.last_leaf_edge()),\n-                    _marker: PhantomData,\n-                }\n-            } else {\n-                RangeMut { front: None, back: None, _marker: PhantomData }\n-            },\n-            length: self.length,\n+        if let Some(root) = &mut self.root {\n+            let (f, b) = full_range_search(root.as_mut());\n+\n+            IterMut {\n+                range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n+                length: self.length,\n+            }\n+        } else {\n+            IterMut { range: RangeMut { front: None, back: None, _marker: PhantomData }, length: 0 }\n         }\n     }\n "}, {"sha": "80cf6a5dbc27b181747f4adc7c80637a9d399fbb", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -703,6 +703,10 @@ impl File {\n             | opts.get_access_mode()?\n             | opts.get_creation_mode()?\n             | (opts.custom_flags as c_int & !libc::O_ACCMODE);\n+        // The third argument of `open64` is documented to have type `mode_t`. On\n+        // some platforms (like macOS, where `open64` is actually `open`), `mode_t` is `u16`.\n+        // However, since this is a variadic function, C integer promotion rules mean that on\n+        // the ABI level, this still gets passed as `c_int` (aka `u32` on Unix platforms).\n         let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;\n         let fd = FileDesc::new(fd);\n "}, {"sha": "45c600f75f5cf577a03b4bfda78c5be6f275f275", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -28,14 +28,20 @@ impl Mutex {\n         //\n         // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n         // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n-        // try to re-lock it from the same thread when you already hold a lock.\n+        // try to re-lock it from the same thread when you already hold a lock\n+        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html).\n+        // This is the case even if PTHREAD_MUTEX_DEFAULT == PTHREAD_MUTEX_NORMAL\n+        // (https://github.com/rust-lang/rust/issues/33770#issuecomment-220847521) -- in that\n+        // case, `pthread_mutexattr_settype(PTHREAD_MUTEX_DEFAULT)` will of course be the same\n+        // as setting it to `PTHREAD_MUTEX_NORMAL`, but not setting any mode will result in\n+        // a Mutex where re-locking is UB.\n         //\n         // In practice, glibc takes advantage of this undefined behavior to\n         // implement hardware lock elision, which uses hardware transactional\n         // memory to avoid acquiring the lock. While a transaction is in\n         // progress, the lock appears to be unlocked. This isn't a problem for\n         // other threads since the transactional memory will abort if a conflict\n-        // is detected, however no abort is generated if re-locking from the\n+        // is detected, however no abort is generated when re-locking from the\n         // same thread.\n         //\n         // Since locking the same mutex twice will result in two aliasing &mut"}, {"sha": "2b5067a34f648fa41baa290706ad3a53a347cce3", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -22,32 +22,33 @@ impl RWLock {\n     pub unsafe fn read(&self) {\n         let r = libc::pthread_rwlock_rdlock(self.inner.get());\n \n-        // According to the pthread_rwlock_rdlock spec, this function **may**\n-        // fail with EDEADLK if a deadlock is detected. On the other hand\n-        // pthread mutexes will *never* return EDEADLK if they are initialized\n-        // as the \"fast\" kind (which ours always are). As a result, a deadlock\n-        // situation may actually return from the call to pthread_rwlock_rdlock\n-        // instead of blocking forever (as mutexes and Windows rwlocks do). Note\n-        // that not all unix implementations, however, will return EDEADLK for\n-        // their rwlocks.\n+        // According to POSIX, when a thread tries to acquire this read lock\n+        // while it already holds the write lock\n+        // (or vice versa, or tries to acquire the write lock twice),\n+        // \"the call shall either deadlock or return [EDEADLK]\"\n+        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html,\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_rdlock.html).\n+        // So, in principle, all we have to do here is check `r == 0` to be sure we properly\n+        // got the lock.\n         //\n-        // We roughly maintain the deadlocking behavior by panicking to ensure\n-        // that this lock acquisition does not succeed.\n-        //\n-        // We also check whether this lock is already write locked. This\n-        // is only possible if it was write locked by the current thread and\n-        // the implementation allows recursive locking. The POSIX standard\n-        // doesn't require recursively locking a rwlock to deadlock, but we can't\n-        // allow that because it could lead to aliasing issues.\n+        // However, (at least) glibc before version 2.25 does not conform to this spec,\n+        // and can return `r == 0` even when this thread already holds the write lock.\n+        // We thus check for this situation ourselves and panic when detecting that a thread\n+        // got the write lock more than once, or got a read and a write lock.\n         if r == libc::EAGAIN {\n             panic!(\"rwlock maximum reader count exceeded\");\n         } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n+            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n+            // data races.\n             if r == 0 {\n+                // `pthread_rwlock_rdlock` succeeded when it should not have.\n                 self.raw_unlock();\n             }\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n-            assert_eq!(r, 0);\n+            // According to POSIX, for a properly initialized rwlock this can only\n+            // return EAGAIN or EDEADLK or 0. We rely on that.\n+            debug_assert_eq!(r, 0);\n             self.num_readers.fetch_add(1, Ordering::Relaxed);\n         }\n     }\n@@ -56,6 +57,7 @@ impl RWLock {\n         let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n         if r == 0 {\n             if *self.write_locked.get() {\n+                // `pthread_rwlock_tryrdlock` succeeded when it should not have.\n                 self.raw_unlock();\n                 false\n             } else {\n@@ -69,17 +71,22 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn write(&self) {\n         let r = libc::pthread_rwlock_wrlock(self.inner.get());\n-        // See comments above for why we check for EDEADLK and write_locked. We\n-        // also need to check that num_readers is 0.\n+        // See comments above for why we check for EDEADLK and write_locked. For the same reason,\n+        // we also need to check that there are no readers (tracked in `num_readers`).\n         if r == libc::EDEADLK\n-            || *self.write_locked.get()\n+            || (r == 0 && *self.write_locked.get())\n             || self.num_readers.load(Ordering::Relaxed) != 0\n         {\n+            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n+            // data races.\n             if r == 0 {\n+                // `pthread_rwlock_wrlock` succeeded when it should not have.\n                 self.raw_unlock();\n             }\n             panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n+            // According to POSIX, for a properly initialized rwlock this can only\n+            // return EDEADLK or 0. We rely on that.\n             debug_assert_eq!(r, 0);\n         }\n         *self.write_locked.get() = true;\n@@ -89,6 +96,7 @@ impl RWLock {\n         let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n         if r == 0 {\n             if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n+                // `pthread_rwlock_trywrlock` succeeded when it should not have.\n                 self.raw_unlock();\n                 false\n             } else {"}, {"sha": "8b51370bca502e94ec9b2024e394b45cb96a3843", "filename": "src/test/ui/deriving/deriving-hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Ftest%2Fui%2Fderiving%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Ftest%2Fui%2Fderiving%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-hash.rs?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -24,7 +24,7 @@ struct Person {\n enum E { A=1, B }\n \n fn hash<T: Hash>(t: &T) -> u64 {\n-    let mut s = SipHasher::new_with_keys(0, 0);\n+    let mut s = SipHasher::new();\n     t.hash(&mut s);\n     s.finish()\n }"}, {"sha": "25817a2a63d6023d33aaee880e3cd099e3fde3cc", "filename": "src/test/ui/issues/issue-16530.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Ftest%2Fui%2Fissues%2Fissue-16530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339f574809bf8e4166b8de3cdbe7df181d37af3d/src%2Ftest%2Fui%2Fissues%2Fissue-16530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16530.rs?ref=339f574809bf8e4166b8de3cdbe7df181d37af3d", "patch": "@@ -7,9 +7,9 @@ use std::hash::{SipHasher, Hasher, Hash};\n struct Empty;\n \n pub fn main() {\n-    let mut s1 = SipHasher::new_with_keys(0, 0);\n+    let mut s1 = SipHasher::new();\n     Empty.hash(&mut s1);\n-    let mut s2 = SipHasher::new_with_keys(0, 0);\n+    let mut s2 = SipHasher::new();\n     Empty.hash(&mut s2);\n     assert_eq!(s1.finish(), s2.finish());\n }"}]}