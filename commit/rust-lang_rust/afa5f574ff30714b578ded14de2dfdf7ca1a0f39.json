{"sha": "afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYTVmNTc0ZmYzMDcxNGI1NzhkZWQxNGRlMmRmZGY3Y2ExYTBmMzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-10T20:50:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-21T01:48:32Z"}, "message": "Re-work loading crates with nicer errors\n\nThis commit rewrites crate loading internally in attempt to look at less\nmetadata and provide nicer errors. The loading is now split up into a few\nstages:\n\n1. Collect a mapping of (hash => ~[Path]) for a set of candidate libraries for a\n   given search. The hash is the hash in the filename and the Path is the\n   location of the library in question. All candidates are filtered based on\n   their prefix/suffix (dylib/rlib appropriate) and then the hash/version are\n   split up and are compared (if necessary).\n\n   This means that if you're looking for an exact hash of library you don't have\n   to open up the metadata of all libraries named the same, but also in your\n   path.\n\n2. Once this mapping is constructed, each (hash, ~[Path]) pair is filtered down\n   to just a Path. This is necessary because the same rlib could show up twice\n   in the path in multiple locations. Right now the filenames are based on just\n   the crate id, so this could be indicative of multiple version of a crate\n   during one crate_id lifetime in the path. If multiple duplicate crates are\n   found, an error is generated.\n\n3. Now that we have a mapping of (hash => Path), we error on multiple versions\n   saying that multiple versions were found. Only if there's one (hash => Path)\n   pair do we actually return that Path and its metadata.\n\nWith this restructuring, it restructures code so errors which were assertions\npreviously are now first-class errors. Additionally, this should read much less\nmetadata with lots of crates of the same name or same version in a path.\n\nCloses #11908", "tree": {"sha": "74a900396cc3b3773e47b5b4f1e3b9578be0f5fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74a900396cc3b3773e47b5b4f1e3b9578be0f5fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "html_url": "https://github.com/rust-lang/rust/commit/afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6532d2fa0d173e4f815ac2144ff9860f5343cd7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6532d2fa0d173e4f815ac2144ff9860f5343cd7d", "html_url": "https://github.com/rust-lang/rust/commit/6532d2fa0d173e4f815ac2144ff9860f5343cd7d"}], "stats": {"total": 334, "additions": 240, "deletions": 94}, "files": [{"sha": "903a93816dd22e753485606fbfe162b4e213ab62", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 167, "deletions": 94, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "patch": "@@ -26,6 +26,7 @@ use syntax::attr::AttrMetaMethods;\n \n use std::c_str::ToCStr;\n use std::cast;\n+use std::hashmap::{HashMap, HashSet};\n use std::cmp;\n use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n@@ -69,6 +70,7 @@ impl Context {\n         match self.find_library_crate() {\n             Some(t) => t,\n             None => {\n+                self.sess.abort_if_errors();\n                 let message = match root_ident {\n                     None => format!(\"can't find crate for `{}`\", self.ident),\n                     Some(c) => format!(\"can't find crate for `{}` which `{}` depends on\",\n@@ -82,78 +84,107 @@ impl Context {\n \n     fn find_library_crate(&self) -> Option<Library> {\n         let filesearch = self.sess.filesearch;\n-        let crate_name = self.name.clone();\n         let (dyprefix, dysuffix) = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}-\", dyprefix, crate_name);\n-        let rlib_prefix = format!(\"lib{}-\", crate_name);\n+        let dylib_prefix = format!(\"{}{}-\", dyprefix, self.name);\n+        let rlib_prefix = format!(\"lib{}-\", self.name);\n \n-        let mut matches = ~[];\n-        filesearch.search(|path| {\n-            match path.filename_str() {\n-                None => FileDoesntMatch,\n-                Some(file) => {\n-                    let (candidate, existing) = if file.starts_with(rlib_prefix) &&\n-                                                   file.ends_with(\".rlib\") {\n-                        debug!(\"{} is an rlib candidate\", path.display());\n-                        (true, self.add_existing_rlib(matches, path, file))\n-                    } else if file.starts_with(dylib_prefix) &&\n-                              file.ends_with(dysuffix) {\n-                        debug!(\"{} is a dylib candidate\", path.display());\n-                        (true, self.add_existing_dylib(matches, path, file))\n-                    } else {\n-                        (false, false)\n-                    };\n+        let mut candidates = HashMap::new();\n \n-                    if candidate && existing {\n+        // First, find all possible candidate rlibs and dylibs purely based on\n+        // the name of the files themselves. We're trying to match against an\n+        // exact crate_id and a possibly an exact hash.\n+        //\n+        // During this step, we can filter all found libraries based on the\n+        // name and id found in the crate id (we ignore the path portion for\n+        // filename matching), as well as the exact hash (if specified). If we\n+        // end up having many candidates, we must look at the metadata to\n+        // perform exact matches against hashes/crate ids. Note that opening up\n+        // the metadata is where we do an exact match against the full contents\n+        // of the crate id (path/name/id).\n+        //\n+        // The goal of this step is to look at as little metadata as possible.\n+        filesearch.search(|path| {\n+            let file = match path.filename_str() {\n+                None => return FileDoesntMatch,\n+                Some(file) => file,\n+            };\n+            if file.starts_with(rlib_prefix) && file.ends_with(\".rlib\") {\n+                info!(\"rlib candidate: {}\", path.display());\n+                match self.try_match(file, rlib_prefix, \".rlib\") {\n+                    Some(hash) => {\n+                        info!(\"rlib accepted, hash: {}\", hash);\n+                        let slot = candidates.find_or_insert_with(hash, |_| {\n+                            (HashSet::new(), HashSet::new())\n+                        });\n+                        let (ref mut rlibs, _) = *slot;\n+                        rlibs.insert(path.clone());\n                         FileMatches\n-                    } else if candidate {\n-                        match get_metadata_section(self.os, path) {\n-                            Some(cvec) =>\n-                                if crate_matches(cvec.as_slice(),\n-                                                 self.name.clone(),\n-                                                 self.version.clone(),\n-                                                 self.hash.clone()) {\n-                                    debug!(\"found {} with matching crate_id\",\n-                                           path.display());\n-                                    let (rlib, dylib) = if file.ends_with(\".rlib\") {\n-                                        (Some(path.clone()), None)\n-                                    } else {\n-                                        (None, Some(path.clone()))\n-                                    };\n-                                    matches.push(Library {\n-                                        rlib: rlib,\n-                                        dylib: dylib,\n-                                        metadata: cvec,\n-                                    });\n-                                    FileMatches\n-                                } else {\n-                                    debug!(\"skipping {}, crate_id doesn't match\",\n-                                           path.display());\n-                                    FileDoesntMatch\n-                                },\n-                                _ => {\n-                                    debug!(\"could not load metadata for {}\",\n-                                           path.display());\n-                                    FileDoesntMatch\n-                                }\n-                        }\n-                    } else {\n+                    }\n+                    None => {\n+                        info!(\"rlib rejected\");\n                         FileDoesntMatch\n                     }\n                 }\n+            } else if file.starts_with(dylib_prefix) && file.ends_with(dysuffix){\n+                info!(\"dylib candidate: {}\", path.display());\n+                match self.try_match(file, dylib_prefix, dysuffix) {\n+                    Some(hash) => {\n+                        info!(\"dylib accepted, hash: {}\", hash);\n+                        let slot = candidates.find_or_insert_with(hash, |_| {\n+                            (HashSet::new(), HashSet::new())\n+                        });\n+                        let (_, ref mut dylibs) = *slot;\n+                        dylibs.insert(path.clone());\n+                        FileMatches\n+                    }\n+                    None => {\n+                        info!(\"dylib rejected\");\n+                        FileDoesntMatch\n+                    }\n+                }\n+            } else {\n+                FileDoesntMatch\n             }\n         });\n \n-        match matches.len() {\n+        // We have now collected all known libraries into a set of candidates\n+        // keyed of the filename hash listed. For each filename, we also have a\n+        // list of rlibs/dylibs that apply. Here, we map each of these lists\n+        // (per hash), to a Library candidate for returning.\n+        //\n+        // A Library candidate is created if the metadata for the set of\n+        // libraries corresponds to the crate id and hash criteria that this\n+        // serach is being performed for.\n+        let mut libraries = ~[];\n+        for (_hash, (rlibs, dylibs)) in candidates.move_iter() {\n+            let mut metadata = None;\n+            let rlib = self.extract_one(rlibs, \"rlib\", &mut metadata);\n+            let dylib = self.extract_one(dylibs, \"dylib\", &mut metadata);\n+            match metadata {\n+                Some(metadata) => {\n+                    libraries.push(Library {\n+                        dylib: dylib,\n+                        rlib: rlib,\n+                        metadata: metadata,\n+                    })\n+                }\n+                None => {}\n+            }\n+        }\n+\n+        // Having now translated all relevant found hashes into libraries, see\n+        // what we've got and figure out if we found multiple candidates for\n+        // libraries or not.\n+        match libraries.len() {\n             0 => None,\n-            1 => Some(matches[0]),\n+            1 => Some(libraries[0]),\n             _ => {\n                 self.sess.span_err(self.span,\n-                    format!(\"multiple matching crates for `{}`\", crate_name));\n+                    format!(\"multiple matching crates for `{}`\", self.name));\n                 self.sess.note(\"candidates:\");\n-                for lib in matches.iter() {\n+                for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\", p.display()));\n@@ -175,50 +206,90 @@ impl Context {\n                         }\n                     }\n                 }\n-                self.sess.abort_if_errors();\n                 None\n             }\n         }\n     }\n \n-    fn add_existing_rlib(&self, libs: &mut [Library],\n-                         path: &Path, file: &str) -> bool {\n-        let (prefix, suffix) = self.dylibname();\n-        let file = file.slice_from(3); // chop off 'lib'\n-        let file = file.slice_to(file.len() - 5); // chop off '.rlib'\n-        let file = format!(\"{}{}{}\", prefix, file, suffix);\n-\n-        for lib in libs.mut_iter() {\n-            match lib.dylib {\n-                Some(ref p) if p.filename_str() == Some(file.as_slice()) => {\n-                    assert!(lib.rlib.is_none()); // FIXME: legit compiler error\n-                    lib.rlib = Some(path.clone());\n-                    return true;\n-                }\n-                Some(..) | None => {}\n-            }\n+    // Attempts to match the requested version of a library against the file\n+    // specified. The prefix/suffix are specified (disambiguates between\n+    // rlib/dylib).\n+    //\n+    // The return value is `None` if `file` doesn't look like a rust-generated\n+    // library, or if a specific version was requested and it doens't match the\n+    // apparent file's version.\n+    //\n+    // If everything checks out, then `Some(hash)` is returned where `hash` is\n+    // the listed hash in the filename itself.\n+    fn try_match(&self, file: &str, prefix: &str, suffix: &str) -> Option<~str>{\n+        let middle = file.slice(prefix.len(), file.len() - suffix.len());\n+        debug!(\"matching -- {}, middle: {}\", file, middle);\n+        let mut parts = middle.splitn('-', 1);\n+        let hash = match parts.next() { Some(h) => h, None => return None };\n+        debug!(\"matching -- {}, hash: {}\", file, hash);\n+        let vers = match parts.next() { Some(v) => v, None => return None };\n+        debug!(\"matching -- {}, vers: {}\", file, vers);\n+        if !self.version.is_empty() && self.version.as_slice() != vers {\n+            return None\n+        }\n+        debug!(\"matching -- {}, vers ok (requested {})\", file,\n+               self.version);\n+        // hashes in filenames are prefixes of the \"true hash\"\n+        if self.hash.is_empty() || self.hash.starts_with(hash) {\n+            debug!(\"matching -- {}, hash ok (requested {})\", file, self.hash);\n+            Some(hash.to_owned())\n+        } else {\n+            None\n         }\n-        return false;\n     }\n \n-    fn add_existing_dylib(&self, libs: &mut [Library],\n-                          path: &Path, file: &str) -> bool {\n-        let (prefix, suffix) = self.dylibname();\n-        let file = file.slice_from(prefix.len());\n-        let file = file.slice_to(file.len() - suffix.len());\n-        let file = format!(\"lib{}.rlib\", file);\n+    // Attempts to extract *one* library from the set `m`. If the set has no\n+    // elements, `None` is returned. If the set has more than one element, then\n+    // the errors and notes are emitted about the set of libraries.\n+    //\n+    // With only one library in the set, this function will extract it, and then\n+    // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n+    // be read, it is assumed that the file isn't a valid rust library (no\n+    // errors are emitted).\n+    //\n+    // FIXME(#10786): for an optimization, we only read one of the library's\n+    //                metadata sections. In theory we should read both, but\n+    //                reading dylib metadata is quite slow.\n+    fn extract_one(&self, m: HashSet<Path>, flavor: &str,\n+                   slot: &mut Option<MetadataBlob>) -> Option<Path> {\n+        if m.len() == 0 { return None }\n+        if m.len() > 1 {\n+            self.sess.span_err(self.span,\n+                               format!(\"multiple {} candidates for `{}` \\\n+                                        found\", flavor, self.name));\n+            for (i, path) in m.iter().enumerate() {\n+                self.sess.span_note(self.span,\n+                                    format!(r\"candidate \\#{}: {}\", i + 1,\n+                                            path.display()));\n+            }\n+            return None\n+        }\n \n-        for lib in libs.mut_iter() {\n-            match lib.rlib {\n-                Some(ref p) if p.filename_str() == Some(file.as_slice()) => {\n-                    assert!(lib.dylib.is_none()); // FIXME: legit compiler error\n-                    lib.dylib = Some(path.clone());\n-                    return true;\n+        let lib = m.move_iter().next().unwrap();\n+        if slot.is_none() {\n+            info!(\"{} reading meatadata from: {}\", flavor, lib.display());\n+            match get_metadata_section(self.os, &lib) {\n+                Some(blob) => {\n+                    if crate_matches(blob.as_slice(), self.name,\n+                                     self.version, self.hash) {\n+                        *slot = Some(blob);\n+                    } else {\n+                        info!(\"metadata mismatch\");\n+                        return None;\n+                    }\n+                }\n+                None => {\n+                    info!(\"no metadata found\");\n+                    return None\n                 }\n-                Some(..) | None => {}\n             }\n         }\n-        return false;\n+        return Some(lib);\n     }\n \n     // Returns the corresponding (prefix, suffix) that files need to have for\n@@ -239,16 +310,16 @@ pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n }\n \n fn crate_matches(crate_data: &[u8],\n-                 name: ~str,\n-                 version: ~str,\n-                 hash: ~str) -> bool {\n+                 name: &str,\n+                 version: &str,\n+                 hash: &str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     match attr::find_crateid(attrs) {\n         None => false,\n         Some(crateid) => {\n             if !hash.is_empty() {\n                 let chash = decoder::get_crate_hash(crate_data);\n-                if chash != hash { return false; }\n+                if chash.as_slice() != hash { return false; }\n             }\n             name == crateid.name &&\n                 (version.is_empty() ||\n@@ -383,7 +454,9 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(os: Os, path: &Path,\n                           out: &mut io::Writer) -> io::IoResult<()> {\n     match get_metadata_section(os, path) {\n-      Some(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n-      None => write!(out, \"could not find metadata in {}.\\n\", path.display())\n+        Some(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n+        None => {\n+            write!(out, \"could not find metadata in {}.\\n\", path.display())\n+        }\n     }\n }"}, {"sha": "f06929a5deeecb6996cf422f246af5e132138ffb", "filename": "src/test/auxiliary/issue-11908-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Ftest%2Fauxiliary%2Fissue-11908-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Ftest%2Fauxiliary%2Fissue-11908-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11908-1.rs?ref=afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#[crate_id = \"collections#0.10-pre\"];\n+#[crate_type = \"dylib\"];"}, {"sha": "345be34f377467874aa3d4d27501d525bfce1ffd", "filename": "src/test/auxiliary/issue-11908-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Ftest%2Fauxiliary%2Fissue-11908-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Ftest%2Fauxiliary%2Fissue-11908-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11908-2.rs?ref=afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#[crate_id = \"collections#0.10-pre\"];\n+#[crate_type = \"rlib\"];"}, {"sha": "207e953414b46784a533555236a9616e3da3d0f7", "filename": "src/test/compile-fail/issue-11908-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Ftest%2Fcompile-fail%2Fissue-11908-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Ftest%2Fcompile-fail%2Fissue-11908-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11908-1.rs?ref=afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-11908-1.rs\n+// ignore-android this test is incompatible with the android test runner\n+// error-pattern: multiple dylib candidates for `collections` found\n+\n+// This test ensures that if you have the same rlib or dylib at two locations\n+// in the same path that you don't hit an assertion in the compiler.\n+//\n+// Note that this relies on `libcollections` to be in the path somewhere else,\n+// and then our aux-built libraries will collide with libcollections (they have\n+// the same version listed)\n+\n+extern crate collections;\n+\n+fn main() {}"}, {"sha": "b4782c35762838ef68cd3e6d20c7144bd4ad5e6f", "filename": "src/test/compile-fail/issue-11908-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Ftest%2Fcompile-fail%2Fissue-11908-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa5f574ff30714b578ded14de2dfdf7ca1a0f39/src%2Ftest%2Fcompile-fail%2Fissue-11908-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11908-2.rs?ref=afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-11908-2.rs\n+// no-prefer-dynamic\n+// ignore-android this test is incompatible with the android test runner\n+// error-pattern: multiple rlib candidates for `collections` found\n+\n+// see comments in issue-11908-1 for what's going on here\n+\n+extern crate collections;\n+\n+fn main() {}\n+"}]}