{"sha": "72898355429c278ea994758805a92e611aecb430", "node_id": "C_kwDOAAsO6NoAKDcyODk4MzU1NDI5YzI3OGVhOTk0NzU4ODA1YTkyZTYxMWFlY2I0MzA", "commit": {"author": {"name": "kraktus", "email": "kraktus@users.noreply.github.com", "date": "2022-09-27T20:24:14Z"}, "committer": {"name": "kraktus", "email": "kraktus@users.noreply.github.com", "date": "2022-09-28T06:42:01Z"}, "message": "[`should_implement_trait`] Also lint `default` method", "tree": {"sha": "a8fd6b16a49032acdf0e341018c020b96cf17337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8fd6b16a49032acdf0e341018c020b96cf17337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72898355429c278ea994758805a92e611aecb430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72898355429c278ea994758805a92e611aecb430", "html_url": "https://github.com/rust-lang/rust/commit/72898355429c278ea994758805a92e611aecb430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72898355429c278ea994758805a92e611aecb430/comments", "author": {"login": "kraktus", "id": 56031107, "node_id": "MDQ6VXNlcjU2MDMxMTA3", "avatar_url": "https://avatars.githubusercontent.com/u/56031107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kraktus", "html_url": "https://github.com/kraktus", "followers_url": "https://api.github.com/users/kraktus/followers", "following_url": "https://api.github.com/users/kraktus/following{/other_user}", "gists_url": "https://api.github.com/users/kraktus/gists{/gist_id}", "starred_url": "https://api.github.com/users/kraktus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kraktus/subscriptions", "organizations_url": "https://api.github.com/users/kraktus/orgs", "repos_url": "https://api.github.com/users/kraktus/repos", "events_url": "https://api.github.com/users/kraktus/events{/privacy}", "received_events_url": "https://api.github.com/users/kraktus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kraktus", "id": 56031107, "node_id": "MDQ6VXNlcjU2MDMxMTA3", "avatar_url": "https://avatars.githubusercontent.com/u/56031107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kraktus", "html_url": "https://github.com/kraktus", "followers_url": "https://api.github.com/users/kraktus/followers", "following_url": "https://api.github.com/users/kraktus/following{/other_user}", "gists_url": "https://api.github.com/users/kraktus/gists{/gist_id}", "starred_url": "https://api.github.com/users/kraktus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kraktus/subscriptions", "organizations_url": "https://api.github.com/users/kraktus/orgs", "repos_url": "https://api.github.com/users/kraktus/repos", "events_url": "https://api.github.com/users/kraktus/events{/privacy}", "received_events_url": "https://api.github.com/users/kraktus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aa85dc35b1692aaf907c5ca921913e2be7253f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa85dc35b1692aaf907c5ca921913e2be7253f7", "html_url": "https://github.com/rust-lang/rust/commit/9aa85dc35b1692aaf907c5ca921913e2be7253f7"}], "stats": {"total": 95, "additions": 49, "deletions": 46}, "files": [{"sha": "c43f822e3a386fdc1185bb3ccb2dab5b6b06e8fc", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 38, "deletions": 45, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/72898355429c278ea994758805a92e611aecb430/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72898355429c278ea994758805a92e611aecb430/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=72898355429c278ea994758805a92e611aecb430", "patch": "@@ -3255,65 +3255,59 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let self_ty = cx.tcx.type_of(item.def_id);\n \n         let implements_trait = matches!(item.kind, hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }));\n-        if_chain! {\n-            if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n-            if let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next();\n-\n+        if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind {\n             let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n-\n-            let first_arg_ty = method_sig.inputs().iter().next();\n-\n-            // check conventions w.r.t. conversion method names and predicates\n-            if let Some(first_arg_ty) = first_arg_ty;\n-\n-            then {\n-                // if this impl block implements a trait, lint in trait definition instead\n-                if !implements_trait && cx.access_levels.is_exported(impl_item.def_id) {\n-                    // check missing trait implementations\n-                    for method_config in &TRAIT_METHODS {\n-                        if name == method_config.method_name &&\n-                            sig.decl.inputs.len() == method_config.param_count &&\n-                            method_config.output_type.matches(&sig.decl.output) &&\n-                            method_config.self_kind.matches(cx, self_ty, *first_arg_ty) &&\n-                            fn_header_equals(method_config.fn_header, sig.header) &&\n-                            method_config.lifetime_param_cond(impl_item)\n-                        {\n-                            span_lint_and_help(\n-                                cx,\n-                                SHOULD_IMPLEMENT_TRAIT,\n-                                impl_item.span,\n-                                &format!(\n-                                    \"method `{}` can be confused for the standard trait method `{}::{}`\",\n-                                    method_config.method_name,\n-                                    method_config.trait_name,\n-                                    method_config.method_name\n-                                ),\n-                                None,\n-                                &format!(\n-                                    \"consider implementing the trait `{}` or choosing a less ambiguous method name\",\n-                                    method_config.trait_name\n-                                )\n-                            );\n-                        }\n+            let first_arg_ty_opt = method_sig.inputs().iter().next().copied();\n+            // if this impl block implements a trait, lint in trait definition instead\n+            if !implements_trait && cx.access_levels.is_exported(impl_item.def_id) {\n+                // check missing trait implementations\n+                for method_config in &TRAIT_METHODS {\n+                    if name == method_config.method_name\n+                        && sig.decl.inputs.len() == method_config.param_count\n+                        && method_config.output_type.matches(&sig.decl.output)\n+                        // in case there is no first arg, since we already have checked the number of arguments\n+                        // it's should be always true\n+                        && first_arg_ty_opt.map_or(true, |first_arg_ty| method_config\n+                            .self_kind.matches(cx, self_ty, first_arg_ty)\n+                            )\n+                        && fn_header_equals(method_config.fn_header, sig.header)\n+                        && method_config.lifetime_param_cond(impl_item)\n+                    {\n+                        span_lint_and_help(\n+                            cx,\n+                            SHOULD_IMPLEMENT_TRAIT,\n+                            impl_item.span,\n+                            &format!(\n+                                \"method `{}` can be confused for the standard trait method `{}::{}`\",\n+                                method_config.method_name, method_config.trait_name, method_config.method_name\n+                            ),\n+                            None,\n+                            &format!(\n+                                \"consider implementing the trait `{}` or choosing a less ambiguous method name\",\n+                                method_config.trait_name\n+                            ),\n+                        );\n                     }\n                 }\n+            }\n \n-                if sig.decl.implicit_self.has_implicit_self()\n+            if sig.decl.implicit_self.has_implicit_self()\n                     && !(self.avoid_breaking_exported_api\n-                        && cx.access_levels.is_exported(impl_item.def_id))\n+                    && cx.access_levels.is_exported(impl_item.def_id))\n+                    && let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next()\n+                    && let Some(first_arg_ty) = first_arg_ty_opt\n                 {\n                     wrong_self_convention::check(\n                         cx,\n                         name,\n                         self_ty,\n-                        *first_arg_ty,\n+                        first_arg_ty,\n                         first_arg.pat.span,\n                         implements_trait,\n                         false\n                     );\n                 }\n-            }\n         }\n \n         // if this impl block implements a trait, lint in trait definition instead\n@@ -3799,7 +3793,6 @@ const TRAIT_METHODS: [ShouldImplTraitCase; 30] = [\n     ShouldImplTraitCase::new(\"std::borrow::BorrowMut\", \"borrow_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n     ShouldImplTraitCase::new(\"std::clone::Clone\", \"clone\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n     ShouldImplTraitCase::new(\"std::cmp::Ord\", \"cmp\",  2,  FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n-    // FIXME: default doesn't work\n     ShouldImplTraitCase::new(\"std::default::Default\", \"default\",  0,  FN_HEADER,  SelfKind::No,  OutType::Any, true),\n     ShouldImplTraitCase::new(\"std::ops::Deref\", \"deref\",  1,  FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n     ShouldImplTraitCase::new(\"std::ops::DerefMut\", \"deref_mut\",  1,  FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n@@ -3827,7 +3820,7 @@ enum SelfKind {\n     Value,\n     Ref,\n     RefMut,\n-    No,\n+    No, // When we want the first argument type to be different than `Self`\n }\n \n impl SelfKind {"}, {"sha": "e6daedc56546753708e0e67cfb3784b21a1050c3", "filename": "tests/ui/should_impl_trait/method_list_1.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72898355429c278ea994758805a92e611aecb430/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72898355429c278ea994758805a92e611aecb430/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr?ref=72898355429c278ea994758805a92e611aecb430", "patch": "@@ -99,6 +99,16 @@ LL | |     }\n    |\n    = help: consider implementing the trait `std::cmp::Ord` or choosing a less ambiguous method name\n \n+error: method `default` can be confused for the standard trait method `std::default::Default::default`\n+  --> $DIR/method_list_1.rs:65:5\n+   |\n+LL | /     pub fn default() -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::default::Default` or choosing a less ambiguous method name\n+\n error: method `deref` can be confused for the standard trait method `std::ops::Deref::deref`\n   --> $DIR/method_list_1.rs:69:5\n    |\n@@ -139,5 +149,5 @@ LL | |     }\n    |\n    = help: consider implementing the trait `std::ops::Drop` or choosing a less ambiguous method name\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 15 previous errors\n "}]}