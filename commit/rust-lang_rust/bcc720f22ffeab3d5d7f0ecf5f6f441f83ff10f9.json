{"sha": "bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "node_id": "C_kwDOAAsO6NoAKGJjYzcyMGYyMmZmZWFiM2Q1ZDdmMGVjZjVmNmY0NDFmODNmZjEwZjk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-10T18:19:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-10T18:19:02Z"}, "message": "Merge #10979\n\n10979: fix: Don't show trait flyimports for impl trait and placeholders r=Veykril a=Veykril\n\ncc #8539\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "dc44dcdc6616e91588a5e232a13470e793588e92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc44dcdc6616e91588a5e232a13470e793588e92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhs5oWCRBK7hj4Ov3rIwAAlTUIAJDJYLAZFFpIMAMtsXywj1i1\nzrt6B18KS1INBpwBstVO8dJJmtqmk3A6mO+zfKzHx5jHSc+1b6ck9/XMyb6x57VO\nOp/xxuvCNfwm8vAYWu2Nb/IJfThWyI/yVu0NeZ68VtIu4eLByxVWcxqa5I7okyrG\nwLAWLeByXvjKij83e2WNS6BeIvN+qOWCZxOkrLPnWDH0h8CG1gVNN/nQPhxzLgIk\ngehXo6Yhx+kHugzqZJRqlwu9gseza9APtyxZZ10tOTtmyBHgTTQUbWhczVp50ln6\n3H0PJ/d+tZc7mrIH6u0xZlRMDk/6uw2ByQAxdkr+B37m54sBkozKKCERbx+zKEw=\n=297i\n-----END PGP SIGNATURE-----\n", "payload": "tree dc44dcdc6616e91588a5e232a13470e793588e92\nparent bc8efca0c8226cb250825eb40ccc68787649a83c\nparent c81aa68afe7a39544bccf4a71957b8b5b3ce0254\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639160342 +0000\ncommitter GitHub <noreply@github.com> 1639160342 +0000\n\nMerge #10979\n\n10979: fix: Don't show trait flyimports for impl trait and placeholders r=Veykril a=Veykril\n\ncc #8539\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "html_url": "https://github.com/rust-lang/rust/commit/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc8efca0c8226cb250825eb40ccc68787649a83c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc8efca0c8226cb250825eb40ccc68787649a83c", "html_url": "https://github.com/rust-lang/rust/commit/bc8efca0c8226cb250825eb40ccc68787649a83c"}, {"sha": "c81aa68afe7a39544bccf4a71957b8b5b3ce0254", "url": "https://api.github.com/repos/rust-lang/rust/commits/c81aa68afe7a39544bccf4a71957b8b5b3ce0254", "html_url": "https://github.com/rust-lang/rust/commit/c81aa68afe7a39544bccf4a71957b8b5b3ce0254"}], "stats": {"total": 147, "additions": 102, "deletions": 45}, "files": [{"sha": "3739e522a182342e597e05dda7ffae119de447c0", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -2623,13 +2623,15 @@ impl Type {\n     }\n \n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n+        self.autoderef_(db).map(move |ty| self.derived(ty))\n+    }\n+\n+    pub fn autoderef_<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Ty> + 'a {\n         // There should be no inference vars in types passed here\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n         let environment = self.env.env.clone();\n         let ty = InEnvironment { goal: canonical, environment };\n-        autoderef(db, Some(self.krate), ty)\n-            .map(|canonical| canonical.value)\n-            .map(move |ty| self.derived(ty))\n+        autoderef(db, Some(self.krate), ty).map(|canonical| canonical.value)\n     }\n \n     // This would be nicer if it just returned an iterator, but that runs into\n@@ -2808,22 +2810,32 @@ impl Type {\n         db: &'a dyn HirDatabase,\n     ) -> impl Iterator<Item = Trait> + 'a {\n         let _p = profile::span(\"applicable_inherent_traits\");\n-        self.autoderef(db)\n-            .filter_map(|derefed_type| derefed_type.ty.dyn_trait())\n+        self.autoderef_(db)\n+            .filter_map(|ty| ty.dyn_trait())\n             .flat_map(move |dyn_trait_id| hir_ty::all_super_traits(db.upcast(), dyn_trait_id))\n             .map(Trait::from)\n     }\n \n-    pub fn as_impl_traits(&self, db: &dyn HirDatabase) -> Option<Vec<Trait>> {\n+    pub fn env_traits<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Trait> + 'a {\n+        let _p = profile::span(\"env_traits\");\n+        self.autoderef_(db)\n+            .filter(|ty| matches!(ty.kind(&Interner), TyKind::Placeholder(_)))\n+            .flat_map(|ty| {\n+                self.env\n+                    .traits_in_scope_from_clauses(ty)\n+                    .flat_map(|t| hir_ty::all_super_traits(db.upcast(), t))\n+            })\n+            .map(Trait::from)\n+    }\n+\n+    pub fn as_impl_traits(&self, db: &dyn HirDatabase) -> Option<impl Iterator<Item = Trait>> {\n         self.ty.impl_trait_bounds(db).map(|it| {\n-            it.into_iter()\n-                .filter_map(|pred| match pred.skip_binders() {\n-                    hir_ty::WhereClause::Implemented(trait_ref) => {\n-                        Some(Trait::from(trait_ref.hir_trait_id()))\n-                    }\n-                    _ => None,\n-                })\n-                .collect()\n+            it.into_iter().filter_map(|pred| match pred.skip_binders() {\n+                hir_ty::WhereClause::Implemented(trait_ref) => {\n+                    Some(Trait::from(trait_ref.hir_trait_id()))\n+                }\n+                _ => None,\n+            })\n         })\n     }\n "}, {"sha": "6af39828be59ff3b63688bf29e478cf4138f5770", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -719,7 +719,7 @@ fn iterate_trait_method_candidates(\n     let env_traits = match self_ty.value.kind(&Interner) {\n         TyKind::Placeholder(_) => {\n             // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n-            env.traits_in_scope_from_clauses(&self_ty.value)\n+            env.traits_in_scope_from_clauses(self_ty.value.clone())\n                 .flat_map(|t| all_super_traits(db.upcast(), t))\n                 .collect()\n         }"}, {"sha": "3876a9da26943fa2e6b8748605237916f345201f", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -54,17 +54,13 @@ impl TraitEnvironment {\n         }\n     }\n \n-    pub(crate) fn traits_in_scope_from_clauses<'a>(\n+    pub fn traits_in_scope_from_clauses<'a>(\n         &'a self,\n-        ty: &'a Ty,\n+        ty: Ty,\n     ) -> impl Iterator<Item = TraitId> + 'a {\n-        self.traits_from_clauses.iter().filter_map(move |(self_ty, trait_id)| {\n-            if self_ty == ty {\n-                Some(*trait_id)\n-            } else {\n-                None\n-            }\n-        })\n+        self.traits_from_clauses\n+            .iter()\n+            .filter_map(move |(self_ty, trait_id)| (*self_ty == ty).then(|| *trait_id))\n     }\n }\n "}, {"sha": "55cdb3200eac96b6d9a7930a04ba24af290308db", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn goto_type_definition(\n                 } else if let Some(trait_) = t.as_dyn_trait() {\n                     push(trait_.into());\n                 } else if let Some(traits) = t.as_impl_traits(db) {\n-                    traits.into_iter().for_each(|it| push(it.into()));\n+                    traits.for_each(|it| push(it.into()));\n                 } else if let Some(trait_) = t.as_associated_type_parent_trait(db) {\n                     push(trait_.into());\n                 }"}, {"sha": "7d5cfaa93728a24e90d6a834e6e7204ea0a4fdcc", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -337,7 +337,7 @@ fn walk_and_push_ty(\n         } else if let Some(trait_) = t.as_dyn_trait() {\n             push_new_def(trait_.into());\n         } else if let Some(traits) = t.as_impl_traits(db) {\n-            traits.into_iter().for_each(|it| push_new_def(it.into()));\n+            traits.for_each(|it| push_new_def(it.into()));\n         } else if let Some(trait_) = t.as_associated_type_parent_trait(db) {\n             push_new_def(trait_.into());\n         }"}, {"sha": "2021db3abab2cb6f9aa114bc0b27312d0109a6c8", "filename": "crates/ide_assists/src/utils/suggest_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -243,7 +243,7 @@ fn name_of_type(ty: &hir::Type, db: &RootDatabase) -> Option<String> {\n     } else if let Some(trait_) = ty.as_dyn_trait() {\n         trait_name(&trait_, db)?\n     } else if let Some(traits) = ty.as_impl_traits(db) {\n-        let mut iter = traits.into_iter().filter_map(|t| trait_name(&t, db));\n+        let mut iter = traits.filter_map(|t| trait_name(&t, db));\n         let name = iter.next()?;\n         if iter.next().is_some() {\n             return None;"}, {"sha": "b3b27f251f6f3d520de016e30b24771345a75ee1", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -1,5 +1,7 @@\n //! Completes constants and paths in unqualified patterns.\n \n+use hir::db::DefDatabase;\n+\n use crate::{\n     context::{PatternContext, PatternRefutability},\n     CompletionContext, Completions,\n@@ -13,11 +15,12 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n         _ => return,\n     };\n+    let single_variant_enum = |enum_: hir::Enum| ctx.db.enum_data(enum_.into()).variants.len() == 1;\n \n-    if refutable {\n-        if let Some(hir::Adt::Enum(e)) =\n-            ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n-        {\n+    if let Some(hir::Adt::Enum(e)) =\n+        ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n+    {\n+        if refutable || single_variant_enum(e) {\n             super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n                 acc.add_qualified_variant_pat(ctx, variant, path.clone());\n                 acc.add_qualified_enum_variant(ctx, variant, path);\n@@ -28,20 +31,20 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n     ctx.process_all_names(&mut |name, res| {\n-        let add_resolution = match &res {\n+        let add_resolution = match res {\n             hir::ScopeDef::ModuleDef(def) => match def {\n                 hir::ModuleDef::Adt(hir::Adt::Struct(strukt)) => {\n-                    acc.add_struct_pat(ctx, *strukt, Some(name.clone()));\n+                    acc.add_struct_pat(ctx, strukt, Some(name.clone()));\n                     true\n                 }\n-                hir::ModuleDef::Variant(variant) if refutable => {\n-                    acc.add_variant_pat(ctx, *variant, Some(name.clone()));\n+                hir::ModuleDef::Variant(variant)\n+                    if refutable || single_variant_enum(variant.parent_enum(ctx.db)) =>\n+                {\n+                    acc.add_variant_pat(ctx, variant, Some(name.clone()));\n                     true\n                 }\n-                hir::ModuleDef::Adt(hir::Adt::Enum(..))\n-                | hir::ModuleDef::Variant(..)\n-                | hir::ModuleDef::Const(..)\n-                | hir::ModuleDef::Module(..) => refutable,\n+                hir::ModuleDef::Adt(hir::Adt::Enum(e)) => refutable || single_variant_enum(e),\n+                hir::ModuleDef::Const(..) | hir::ModuleDef::Module(..) => refutable,\n                 _ => false,\n             },\n             hir::ScopeDef::MacroDef(mac) => mac.is_fn_like(),"}, {"sha": "1f96e122f956c66867f5152389b6165e5eba4875", "filename": "crates/ide_completion/src/tests/flyimport.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -924,6 +924,44 @@ mod bar {\n             \"#,\n         expect![[r#\"\"#]],\n     );\n+    check(\n+        r#\"\n+mod baz {\n+    pub trait DefDatabase {\n+        fn method1(&self);\n+    }\n+    pub trait HirDatabase: DefDatabase {\n+        fn method2(&self);\n+    }\n+}\n+\n+mod bar {\n+    fn test(db: &impl crate::baz::HirDatabase) {\n+        db.metho$0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+    check(\n+        r#\"\n+mod baz {\n+    pub trait DefDatabase {\n+        fn method1(&self);\n+    }\n+    pub trait HirDatabase: DefDatabase {\n+        fn method2(&self);\n+    }\n+}\n+\n+mod bar {\n+    fn test<T: crate::baz::HirDatabase>(db: T) {\n+        db.metho$0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n }\n \n #[test]"}, {"sha": "99e20b6ed092c35dc59e6209e75fc1d24cbd003f", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -130,18 +130,24 @@ fn foo() {\n fn irrefutable() {\n     check(\n         r#\"\n+enum SingleVariantEnum {\n+    Variant\n+}\n+use SingleVariantEnum::Variant;\n fn foo() {\n    let a$0\n }\n \"#,\n         expect![[r##\"\n             kw mut\n-            bn Record    Record { field$1 }$0\n+            bn Record            Record { field$1 }$0\n             st Record\n-            bn Tuple     Tuple($1)$0\n+            bn Tuple             Tuple($1)$0\n             st Tuple\n+            ev Variant\n+            en SingleVariantEnum\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)         #[macro_export] macro_rules! makro\n         \"##]],\n     );\n }"}, {"sha": "ac0ccfa63f82ebdb6dc83aba6e89a44dc9baa641", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "patch": "@@ -454,8 +454,10 @@ fn trait_applicable_items(\n \n     let db = sema.db;\n \n-    let related_dyn_traits =\n-        trait_candidate.receiver_ty.applicable_inherent_traits(db).collect::<FxHashSet<_>>();\n+    let inherent_traits = trait_candidate.receiver_ty.applicable_inherent_traits(db);\n+    let env_traits = trait_candidate.receiver_ty.env_traits(db);\n+    let related_traits = inherent_traits.chain(env_traits).collect::<FxHashSet<_>>();\n+\n     let mut required_assoc_items = FxHashSet::default();\n     let trait_candidates = items_locator::items_with_name(\n         sema,\n@@ -467,7 +469,7 @@ fn trait_applicable_items(\n     .filter_map(|input| item_as_assoc(db, input))\n     .filter_map(|assoc| {\n         let assoc_item_trait = assoc.containing_trait(db)?;\n-        if related_dyn_traits.contains(&assoc_item_trait) {\n+        if related_traits.contains(&assoc_item_trait) {\n             None\n         } else {\n             required_assoc_items.insert(assoc);"}]}