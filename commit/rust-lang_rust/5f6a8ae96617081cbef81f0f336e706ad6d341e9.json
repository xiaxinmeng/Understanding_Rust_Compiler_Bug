{"sha": "5f6a8ae96617081cbef81f0f336e706ad6d341e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNmE4YWU5NjYxNzA4MWNiZWY4MWYwZjMzNmU3MDZhZDZkMzQxZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-22T14:15:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-22T14:15:54Z"}, "message": "auto merge of #9362 : huonw/rust/rand, r=alexcrichton\n\nFirst steps on toward a shiny new `std::rand`, this does a variety of relatively clean-up tasks, like:\r\n- moving `std/rand.rs` to `std/rand/mod.rs` in preparation for (e.g.) splitting the large chunk that is the `Isaac` implementation into a separate file later.\r\n- removing the now unused RNG code in the old rt (500 lines gone just like that!)\r\n- merging Rng and RngUtil via default methods\r\n- examples in the documentation for almost all methods.\r\n\r\nAnd other things mentioned in the commit messages.", "tree": {"sha": "0a0e65ee4ccfabd9b28a759471f35a19f4c19f33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0e65ee4ccfabd9b28a759471f35a19f4c19f33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f6a8ae96617081cbef81f0f336e706ad6d341e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6a8ae96617081cbef81f0f336e706ad6d341e9", "html_url": "https://github.com/rust-lang/rust/commit/5f6a8ae96617081cbef81f0f336e706ad6d341e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f6a8ae96617081cbef81f0f336e706ad6d341e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07167826d6b7b30c96cc9d6227fbe01b65e980f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/07167826d6b7b30c96cc9d6227fbe01b65e980f8", "html_url": "https://github.com/rust-lang/rust/commit/07167826d6b7b30c96cc9d6227fbe01b65e980f8"}, {"sha": "0951313c1eb6ef0d7b6c30d51211637fcc1b3624", "url": "https://api.github.com/repos/rust-lang/rust/commits/0951313c1eb6ef0d7b6c30d51211637fcc1b3624", "html_url": "https://github.com/rust-lang/rust/commit/0951313c1eb6ef0d7b6c30d51211637fcc1b3624"}], "stats": {"total": 1090, "additions": 311, "deletions": 779}, "files": [{"sha": "1b818bfee415103d642f0c8a1c9f5bd5cd1644c9", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -74,7 +74,6 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/rust_rng.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n-              rt/isaac/randport.cpp \\\n               rt/miniz.cpp \\\n               rt/memory_region.cpp \\\n               rt/boxed_region.cpp \\"}, {"sha": "191ecbe8d16b42969b9ce7e6ff5c50f95b7be28f", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -311,11 +311,11 @@ mod test {\n \n     #[test]\n     fn test_base64_random() {\n-        use std::rand::{task_rng, random, RngUtil};\n+        use std::rand::{task_rng, random, Rng};\n         use std::vec;\n \n         do 1000.times {\n-            let times = task_rng().gen_uint_range(1, 100);\n+            let times = task_rng().gen_integer_range(1u, 100);\n             let v = vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }"}, {"sha": "c5311d210ab9bb513a3480f19ecd2c0e70129cfc", "filename": "src/libextra/container.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -43,7 +43,7 @@ pub trait Deque<T> : Mutable {\n mod bench {\n     use std::container::MutableMap;\n     use std::{vec, rand};\n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n     use test::BenchHarness;\n \n     pub fn insert_rand_n<M:MutableMap<uint,uint>>(n: uint,"}, {"sha": "4eba3e13eea5985e3978bc190cd89c733bb1d5bf", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -347,8 +347,7 @@ impl <T: FixedBuffer> StandardPadding for T {\n \n #[cfg(test)]\n mod test {\n-    use std::rand::IsaacRng;\n-    use std::rand::RngUtil;\n+    use std::rand::{IsaacRng, Rng};\n     use std::vec;\n \n     use cryptoutil::{add_bytes_to_bits, add_bytes_to_bits_tuple};\n@@ -365,7 +364,7 @@ mod test {\n         digest.reset();\n \n         while count < total_size {\n-            let next: uint = rng.gen_uint_range(0, 2 * blocksize + 1);\n+            let next: uint = rng.gen_integer_range(0, 2 * blocksize + 1);\n             let remaining = total_size - count;\n             let size = if next > remaining { remaining } else { next };\n             digest.input(buffer.slice_to(size));"}, {"sha": "e12ac276482436666901023a02ec63a6991c4ffc", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -106,15 +106,15 @@ pub fn inflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n mod tests {\n     use super::*;\n     use std::rand;\n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n \n     #[test]\n     fn test_flate_round_trip() {\n         let mut r = rand::rng();\n         let mut words = ~[];\n         do 20.times {\n-            let range = r.gen_uint_range(1, 10);\n-            words.push(r.gen_bytes(range));\n+            let range = r.gen_integer_range(1u, 10);\n+            words.push(r.gen_vec::<u8>(range));\n         }\n         do 20.times {\n             let mut input = ~[];"}, {"sha": "f7462ae29438b02e850a8314ff3741baeb594eac", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -23,7 +23,7 @@ use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use std::int;\n use std::num;\n use std::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n-use std::rand::{Rng, RngUtil};\n+use std::rand::Rng;\n use std::str;\n use std::uint;\n use std::vec;"}, {"sha": "bab889ff9245a42a725b8875faa50649c41117d4", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -909,7 +909,7 @@ mod tests {\n mod test_tim_sort {\n \n     use sort::tim_sort;\n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n     use std::rand;\n     use std::vec;\n \n@@ -1008,7 +1008,7 @@ mod big_tests {\n \n     use sort::*;\n \n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n     use std::rand;\n     use std::vec;\n \n@@ -1069,8 +1069,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_uint_range(0, n);\n-                let i2 = rng.gen_uint_range(0, n);\n+                let i1 = rng.gen_integer_range(0u, n);\n+                let i2 = rng.gen_integer_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1088,7 +1088,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_uint_range(0, n);\n+                let idx = rng.gen_integer_range(0u, n);\n                 arr[idx] = rng.gen();\n             }\n             tim_sort(arr);\n@@ -1141,8 +1141,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_uint_range(0, n);\n-                let i2 = rng.gen_uint_range(0, n);\n+                let i1 = rng.gen_integer_range(0u, n);\n+                let i2 = rng.gen_integer_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1160,7 +1160,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_uint_range(0, n);\n+                let idx = rng.gen_integer_range(0u, n);\n                 arr[idx] = @rng.gen();\n             }\n             tim_sort(arr);"}, {"sha": "13e0c47433f684a01f32e89c395a36ff276e0ea9", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -12,15 +12,15 @@\n \n \n use std::os;\n-use std::rand::RngUtil;\n+use std::rand::Rng;\n use std::rand;\n \n /// Attempts to make a temporary directory inside of `tmpdir` whose name will\n /// have the suffix `suffix`. If no directory can be created, None is returned.\n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     let mut r = rand::rng();\n     for _ in range(0u, 1000) {\n-        let p = tmpdir.push(r.gen_str(16) + suffix);\n+        let p = tmpdir.push(r.gen_ascii_str(16) + suffix);\n         if os::make_dir(&p, 0x1c0) { // 700\n             return Some(p);\n         }"}, {"sha": "8ddc0413aa3c71efe33de61e7c26f8667ce32aa1", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -874,7 +874,7 @@ mod test_treemap {\n \n     use super::*;\n \n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n     use std::rand;\n \n     #[test]\n@@ -1028,7 +1028,7 @@ mod test_treemap {\n             }\n \n             do 30.times {\n-                let r = rng.gen_uint_range(0, ctrl.len());\n+                let r = rng.gen_integer_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);"}, {"sha": "8eff9a022995a7f193b3ddfad52afe1aa70f31a8", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -62,7 +62,7 @@ use std::char::Char;\n use std::container::Container;\n use std::to_str::ToStr;\n use std::rand;\n-use std::rand::RngUtil;\n+use std::rand::Rng;\n use std::cmp::Eq;\n use std::cast::{transmute,transmute_copy};\n \n@@ -170,7 +170,7 @@ impl Uuid {\n     /// of random numbers. Use the rand::Rand trait to supply\n     /// a custom generator if required.\n     pub fn new_v4() -> Uuid {\n-        let ub = rand::task_rng().gen_bytes(16);\n+        let ub = rand::task_rng().gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n         vec::bytes::copy_memory(uuid.bytes, ub, 16);\n         uuid.set_variant(VariantRFC4122);\n@@ -488,7 +488,7 @@ impl TotalEq for Uuid {\n impl rand::Rand for Uuid {\n     #[inline]\n     fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n-        let ub = rng.gen_bytes(16);\n+        let ub = rng.gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n         vec::bytes::copy_memory(uuid.bytes, ub, 16);\n         uuid.set_variant(VariantRFC4122);"}, {"sha": "f496e89acf75dfae2c5e879c221b38f52cb805ce", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -24,7 +24,7 @@ use iter::{Iterator, FromIterator, Extendable};\n use iter::{FilterMap, Chain, Repeat, Zip};\n use num;\n use option::{None, Option, Some};\n-use rand::RngUtil;\n+use rand::Rng;\n use rand;\n use uint;\n use util::replace;"}, {"sha": "ca524a255ae8630975fc04a78cf173ea5c6bf43a", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -734,7 +734,7 @@ mod test {\n #[cfg(test)]\n mod bench {\n     use extra::test::BenchHarness;\n-    use rand::{XorShiftRng,RngUtil};\n+    use rand::{XorShiftRng, Rng};\n     use float;\n     use to_str::ToStr;\n "}, {"sha": "08a1f879e7804634c50e1e9e631c170e35c3f8f0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1718,7 +1718,7 @@ mod tests {\n     use os::{remove_file, setenv, unsetenv};\n     use os;\n     use path::Path;\n-    use rand::RngUtil;\n+    use rand::Rng;\n     use rand;\n     use run;\n     use str::StrSlice;\n@@ -1738,7 +1738,7 @@ mod tests {\n \n     fn make_rand_name() -> ~str {\n         let mut rng = rand::rng();\n-        let n = ~\"TEST\" + rng.gen_str(10u);\n+        let n = ~\"TEST\" + rng.gen_ascii_str(10u);\n         assert!(getenv(n).is_none());\n         n\n     }"}, {"sha": "7b753f821d71fd5d7b89394ee6afd35b40cd3a81", "filename": "src/libstd/rand/mod.rs", "status": "renamed", "additions": 274, "deletions": 393, "changes": 667, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -11,7 +11,7 @@\n /*!\n Random number generation.\n \n-The key functions are `random()` and `RngUtil::gen()`. These are polymorphic\n+The key functions are `random()` and `Rng::gen()`. These are polymorphic\n and so can be used to generate any type that implements `Rand`. Type inference\n means that often a simple call to `rand::random()` or `rng.gen()` will\n suffice, but sometimes an annotation is required, e.g. `rand::random::<float>()`.\n@@ -23,7 +23,7 @@ distributions like normal and exponential.\n \n ~~~ {.rust}\n use std::rand;\n-use std::rand::RngUtil;\n+use std::rand::Rng;\n \n fn main() {\n     let mut rng = rand::rng();\n@@ -44,22 +44,20 @@ fn main () {\n */\n \n use cast;\n-use clone::Clone;\n use cmp;\n use container::Container;\n use int;\n use iter::{Iterator, range, range_step};\n use local_data;\n-use num;\n use prelude::*;\n use str;\n use sys;\n use u32;\n+use u64;\n use uint;\n use vec;\n use libc::size_t;\n \n-#[path=\"rand/distributions.rs\"]\n pub mod distributions;\n \n /// A type that can be randomly generated using an Rng\n@@ -244,17 +242,10 @@ pub mod rustrt {\n     use libc::size_t;\n \n     extern {\n-        pub fn rand_seed_size() -> size_t;\n         pub fn rand_gen_seed(buf: *mut u8, sz: size_t);\n     }\n }\n \n-/// A random number generator\n-pub trait Rng {\n-    /// Return the next random integer\n-    fn next(&mut self) -> u32;\n-}\n-\n /// A value with a particular weight compared to other values\n pub struct Weighted<T> {\n     /// The numerical weight of this item\n@@ -263,311 +254,187 @@ pub struct Weighted<T> {\n     item: T,\n }\n \n-/// Helper functions attached to the Rng type\n-pub trait RngUtil {\n-    /// Return a random value of a Rand type\n-    fn gen<T:Rand>(&mut self) -> T;\n-    /**\n-     * Return a int randomly chosen from the range [start, end),\n-     * failing if start >= end\n-     */\n-    fn gen_int_range(&mut self, start: int, end: int) -> int;\n-    /**\n-     * Return a uint randomly chosen from the range [start, end),\n-     * failing if start >= end\n-     */\n-    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint;\n-    /**\n-     * Return a char randomly chosen from chars, failing if chars is empty\n-     */\n-    fn gen_char_from(&mut self, chars: &str) -> char;\n-    /**\n-     * Return a bool with a 1 in n chance of true\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     printfln!(\"%b\", rng.gen_weighted_bool(3));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_weighted_bool(&mut self, n: uint) -> bool;\n-    /**\n-     * Return a random string of the specified length composed of A-Z,a-z,0-9\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     println(rng.gen_str(8));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_str(&mut self, len: uint) -> ~str;\n-    /**\n-     * Return a random byte string of the specified length\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     printfln!(rng.gen_bytes(8));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_bytes(&mut self, len: uint) -> ~[u8];\n-    /**\n-     * Choose an item randomly, failing if values is empty\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     printfln!(\"%d\", rng.choose([1,2,4,8,16,32]));\n-     * }\n-     * ~~~\n-     */\n-    fn choose<T:Clone>(&mut self, values: &[T]) -> T;\n-    /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Clone>(&mut self, values: &[T]) -> Option<T>;\n-    /**\n-     * Choose an item respecting the relative weights, failing if the sum of\n-     * the weights is 0\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n-     *              rand::Weighted {weight: 2, item: 'b'},\n-     *              rand::Weighted {weight: 2, item: 'c'}];\n-     *     printfln!(\"%c\", rng.choose_weighted(x));\n-     * }\n-     * ~~~\n-     */\n-    fn choose_weighted<T:Clone>(&mut self, v : &[Weighted<T>]) -> T;\n-    /**\n-     * Choose Some(item) respecting the relative weights, returning none if\n-     * the sum of the weights is 0\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n-     *              rand::Weighted {weight: 2, item: 'b'},\n-     *              rand::Weighted {weight: 2, item: 'c'}];\n-     *     printfln!(rng.choose_weighted_option(x));\n-     * }\n-     * ~~~\n-     */\n-    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n-                                     -> Option<T>;\n-    /**\n-     * Return a vec containing copies of the items, in order, where\n-     * the weight of the item determines how many copies there are\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n-     *              rand::Weighted {weight: 2, item: 'b'},\n-     *              rand::Weighted {weight: 2, item: 'c'}];\n-     *     printfln!(rng.weighted_vec(x));\n-     * }\n-     * ~~~\n-     */\n-    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T];\n-    /**\n-     * Shuffle a vec\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     printfln!(rng.shuffle([1,2,3]));\n-     * }\n-     * ~~~\n-     */\n-    fn shuffle<T:Clone>(&mut self, values: &[T]) -> ~[T];\n-    /**\n-     * Shuffle a mutable vec in place\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let mut y = [1,2,3];\n-     *     rng.shuffle_mut(y);\n-     *     printfln!(y);\n-     *     rng.shuffle_mut(y);\n-     *     printfln!(y);\n-     * }\n-     * ~~~\n-     */\n-    fn shuffle_mut<T>(&mut self, values: &mut [T]);\n+/// A random number generator\n+pub trait Rng {\n+    /// Return the next random integer\n+    fn next(&mut self) -> u32;\n \n-    /**\n-     * Sample up to `n` values from an iterator.\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let vals = range(1, 100).to_owned_vec();\n-     *     let sample = rng.sample(vals.iter(), 5);\n-     *     printfln!(sample);\n-     * }\n-     * ~~~\n-     */\n-    fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> ~[A];\n-}\n \n-/// Extension methods for random number generators\n-impl<R: Rng> RngUtil for R {\n-    /// Return a random value for a Rand type\n-    #[inline]\n+    /// Return a random value of a Rand type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let x: uint = rng.gen();\n+    ///    printfln!(x);\n+    ///    printfln!(rng.gen::<(float, bool)>());\n+    /// }\n+    /// ~~~\n+    #[inline(always)]\n     fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n     }\n \n-    /**\n-     * Return an int randomly chosen from the range [start, end),\n-     * failing if start >= end\n-     */\n-    fn gen_int_range(&mut self, start: int, end: int) -> int {\n-        assert!(start < end);\n-        start + num::abs(self.gen::<int>() % (end - start))\n-    }\n-\n-    /**\n-     * Return a uint randomly chosen from the range [start, end),\n-     * failing if start >= end\n-     */\n-    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint {\n-        assert!(start < end);\n-        start + (self.gen::<uint>() % (end - start))\n-    }\n-\n-    /**\n-     * Return a char randomly chosen from chars, failing if chars is empty\n-     */\n-    fn gen_char_from(&mut self, chars: &str) -> char {\n-        assert!(!chars.is_empty());\n-        let mut cs = ~[];\n-        for c in chars.iter() { cs.push(c) }\n-        self.choose(cs)\n-    }\n-\n-    /// Return a bool with a 1-in-n chance of true\n-    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n-        if n == 0u {\n-            true\n-        } else {\n-            self.gen_uint_range(1u, n + 1u) == 1u\n+    /// Return a random vector of the specified length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let x: ~[uint] = rng.gen_vec(10);\n+    ///    printfln!(x);\n+    ///    printfln!(rng.gen_vec::<(float, bool)>(5));\n+    /// }\n+    /// ~~~\n+    fn gen_vec<T: Rand>(&mut self, len: uint) -> ~[T] {\n+        vec::from_fn(len, |_| self.gen())\n+    }\n+\n+    /// Generate a random primitive integer in the range [`low`,\n+    /// `high`). Fails if `low >= high`.\n+    ///\n+    /// This gives a uniform distribution (assuming this RNG is itself\n+    /// uniform), even for edge cases like `gen_integer_range(0u8,\n+    /// 170)`, which a naive modulo operation would return numbers\n+    /// less than 85 with double the probability to those greater than\n+    /// 85.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let n: uint = rng.gen_integer_range(0u, 10);\n+    ///    printfln!(n);\n+    ///    let m: i16 = rng.gen_integer_range(-40, 400);\n+    ///    printfln!(m);\n+    /// }\n+    /// ~~~\n+    fn gen_integer_range<T: Rand + Int>(&mut self, low: T, high: T) -> T {\n+        assert!(low < high, \"RNG.gen_integer_range called with low >= high\");\n+        let range = (high - low).to_u64();\n+        let accept_zone = u64::max_value - u64::max_value % range;\n+        loop {\n+            let rand = self.gen::<u64>();\n+            if rand < accept_zone {\n+                return low + NumCast::from(rand % range);\n+            }\n         }\n     }\n \n-    /**\n-     * Return a random string of the specified length composed of A-Z,a-z,0-9\n-     */\n-    fn gen_str(&mut self, len: uint) -> ~str {\n-        let charset = ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-                       abcdefghijklmnopqrstuvwxyz\\\n-                       0123456789\";\n-        let mut s = ~\"\";\n-        let mut i = 0u;\n-        while (i < len) {\n-            s = s + str::from_char(self.gen_char_from(charset));\n-            i += 1u;\n+    /// Return a bool with a 1 in n chance of true\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng = rand::rng();\n+    ///     printfln!(\"%b\", rng.gen_weighted_bool(3));\n+    /// }\n+    /// ~~~\n+    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n+        n == 0 || self.gen_integer_range(0, n) == 0\n+    }\n+\n+    /// Return a random string of the specified length composed of\n+    /// A-Z,a-z,0-9.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    println(rand::task_rng().gen_ascii_str(10));\n+    /// }\n+    /// ~~~\n+    fn gen_ascii_str(&mut self, len: uint) -> ~str {\n+        static GEN_ASCII_STR_CHARSET: &'static [u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                                                             abcdefghijklmnopqrstuvwxyz\\\n+                                                             0123456789\");\n+        let mut s = str::with_capacity(len);\n+        for _ in range(0, len) {\n+            s.push_char(self.choose(GEN_ASCII_STR_CHARSET) as char)\n         }\n         s\n     }\n \n-    /// Return a random byte string of the specified length\n-    fn gen_bytes(&mut self, len: uint) -> ~[u8] {\n-        do vec::from_fn(len) |_i| {\n-            self.gen()\n-        }\n-    }\n-\n-    /// Choose an item randomly, failing if values is empty\n-    fn choose<T:Clone>(&mut self, values: &[T]) -> T {\n-        self.choose_option(values).unwrap()\n-    }\n-\n-    /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Clone>(&mut self, values: &[T]) -> Option<T> {\n+    /// Choose an item randomly, failing if `values` is empty.\n+    fn choose<T: Clone>(&mut self, values: &[T]) -> T {\n+        self.choose_option(values).expect(\"Rng.choose: `values` is empty\").clone()\n+    }\n+\n+    /// Choose `Some(&item)` randomly, returning `None` if values is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///     printfln!(rand::task_rng().choose_option([1,2,4,8,16,32]));\n+    ///     printfln!(rand::task_rng().choose_option([]));\n+    /// }\n+    /// ~~~\n+    fn choose_option<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(values[self.gen_uint_range(0u, values.len())].clone())\n+            Some(&values[self.gen_integer_range(0u, values.len())])\n         }\n     }\n-    /**\n-     * Choose an item respecting the relative weights, failing if the sum of\n-     * the weights is 0\n-     */\n-    fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n-        self.choose_weighted_option(v).unwrap()\n-    }\n \n-    /**\n-     * Choose Some(item) respecting the relative weights, returning none if\n-     * the sum of the weights is 0\n-     */\n+    /// Choose an item respecting the relative weights, failing if the sum of\n+    /// the weights is 0\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng = rand::rng();\n+    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n+    ///              rand::Weighted {weight: 2, item: 'b'},\n+    ///              rand::Weighted {weight: 2, item: 'c'}];\n+    ///     printfln!(\"%c\", rng.choose_weighted(x));\n+    /// }\n+    /// ~~~\n+    fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n+        self.choose_weighted_option(v).expect(\"Rng.choose_weighted: total weight is 0\")\n+    }\n+\n+    /// Choose Some(item) respecting the relative weights, returning none if\n+    /// the sum of the weights is 0\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng = rand::rng();\n+    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n+    ///              rand::Weighted {weight: 2, item: 'b'},\n+    ///              rand::Weighted {weight: 2, item: 'c'}];\n+    ///     printfln!(rng.choose_weighted_option(x));\n+    /// }\n+    /// ~~~\n     fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n                                        -> Option<T> {\n         let mut total = 0u;\n@@ -577,7 +444,7 @@ impl<R: Rng> RngUtil for R {\n         if total == 0u {\n             return None;\n         }\n-        let chosen = self.gen_uint_range(0u, total);\n+        let chosen = self.gen_integer_range(0u, total);\n         let mut so_far = 0u;\n         for item in v.iter() {\n             so_far += item.weight;\n@@ -588,10 +455,23 @@ impl<R: Rng> RngUtil for R {\n         unreachable!();\n     }\n \n-    /**\n-     * Return a vec containing copies of the items, in order, where\n-     * the weight of the item determines how many copies there are\n-     */\n+    /// Return a vec containing copies of the items, in order, where\n+    /// the weight of the item determines how many copies there are\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng = rand::rng();\n+    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n+    ///              rand::Weighted {weight: 2, item: 'b'},\n+    ///              rand::Weighted {weight: 2, item: 'c'}];\n+    ///     printfln!(rng.weighted_vec(x));\n+    /// }\n+    /// ~~~\n     fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for item in v.iter() {\n@@ -603,24 +483,61 @@ impl<R: Rng> RngUtil for R {\n     }\n \n     /// Shuffle a vec\n-    fn shuffle<T:Clone>(&mut self, values: &[T]) -> ~[T] {\n-        let mut m = values.to_owned();\n-        self.shuffle_mut(m);\n-        m\n-    }\n-\n-    /// Shuffle a mutable vec in place\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///     printfln!(rand::task_rng().shuffle(~[1,2,3]));\n+    /// }\n+    /// ~~~\n+    fn shuffle<T>(&mut self, values: ~[T]) -> ~[T] {\n+        let mut v = values;\n+        self.shuffle_mut(v);\n+        v\n+    }\n+\n+    /// Shuffle a mutable vector in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let mut y = [1,2,3];\n+    ///    rng.shuffle_mut(y);\n+    ///    printfln!(y);\n+    ///    rng.shuffle_mut(y);\n+    ///    printfln!(y);\n+    /// }\n+    /// ~~~\n     fn shuffle_mut<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place.\n             i -= 1u;\n             // lock element i in place.\n-            values.swap(i, self.gen_uint_range(0u, i + 1u));\n+            values.swap(i, self.gen_integer_range(0u, i + 1u));\n         }\n     }\n \n-    /// Randomly sample up to `n` elements from an iterator\n+    /// Randomly sample up to `n` elements from an iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let sample = rng.sample(range(1, 100), 5);\n+    ///    printfln!(sample);\n+    /// }\n+    /// ~~~\n     fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> ~[A] {\n         let mut reservoir : ~[A] = vec::with_capacity(n);\n         for (i, elem) in iter.enumerate() {\n@@ -629,7 +546,7 @@ impl<R: Rng> RngUtil for R {\n                 loop\n             }\n \n-            let k = self.gen_uint_range(0, i + 1);\n+            let k = self.gen_integer_range(0, i + 1);\n             if k < reservoir.len() {\n                 reservoir[k] = elem\n             }\n@@ -904,8 +821,8 @@ pub fn seed() -> ~[u8] {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     unsafe {\n-        let n = rustrt::rand_seed_size() as uint;\n-        let mut s = vec::from_elem(n, 0_u8);\n+        let n = RAND_SIZE * 4;\n+        let mut s = vec::from_elem(n as uint, 0_u8);\n         do s.as_mut_buf |p, sz| {\n             rustrt::rand_gen_seed(p, sz as size_t)\n         }\n@@ -962,7 +879,7 @@ mod test {\n         let seed = seed();\n         let mut ra = IsaacRng::new_seeded(seed);\n         let mut rb = IsaacRng::new_seeded(seed);\n-        assert_eq!(ra.gen_str(100u), rb.gen_str(100u));\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n \n     #[test]\n@@ -971,7 +888,7 @@ mod test {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let mut ra = IsaacRng::new_seeded(seed);\n         let mut rb = IsaacRng::new_seeded(seed);\n-        assert_eq!(ra.gen_str(100u), rb.gen_str(100u));\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n \n     #[test]\n@@ -986,35 +903,36 @@ mod test {\n     }\n \n     #[test]\n-    fn test_gen_int_range() {\n+    fn test_gen_integer_range() {\n         let mut r = rng();\n-        let a = r.gen_int_range(-3, 42);\n-        assert!(a >= -3 && a < 42);\n-        assert_eq!(r.gen_int_range(0, 1), 0);\n-        assert_eq!(r.gen_int_range(-12, -11), -12);\n-    }\n+        for _ in range(0, 1000) {\n+            let a = r.gen_integer_range(-3i, 42);\n+            assert!(a >= -3 && a < 42);\n+            assert_eq!(r.gen_integer_range(0, 1), 0);\n+            assert_eq!(r.gen_integer_range(-12, -11), -12);\n+        }\n+\n+        for _ in range(0, 1000) {\n+            let a = r.gen_integer_range(10, 42);\n+            assert!(a >= 10 && a < 42);\n+            assert_eq!(r.gen_integer_range(0, 1), 0);\n+            assert_eq!(r.gen_integer_range(3_000_000u, 3_000_001), 3_000_000);\n+        }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_gen_int_from_fail() {\n-        let mut r = rng();\n-        r.gen_int_range(5, -2);\n     }\n \n     #[test]\n-    fn test_gen_uint_range() {\n+    #[should_fail]\n+    fn test_gen_integer_range_fail_int() {\n         let mut r = rng();\n-        let a = r.gen_uint_range(3u, 42u);\n-        assert!(a >= 3u && a < 42u);\n-        assert_eq!(r.gen_uint_range(0u, 1u), 0u);\n-        assert_eq!(r.gen_uint_range(12u, 13u), 12u);\n+        r.gen_integer_range(5i, -2);\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_uint_range_fail() {\n+    fn test_gen_integer_range_fail_uint() {\n         let mut r = rng();\n-        r.gen_uint_range(5u, 2u);\n+        r.gen_integer_range(5u, 2u);\n     }\n \n     #[test]\n@@ -1033,22 +951,22 @@ mod test {\n     }\n \n     #[test]\n-    fn test_gen_str() {\n+    fn test_gen_ascii_str() {\n         let mut r = rng();\n-        debug!(r.gen_str(10u));\n-        debug!(r.gen_str(10u));\n-        debug!(r.gen_str(10u));\n-        assert_eq!(r.gen_str(0u).len(), 0u);\n-        assert_eq!(r.gen_str(10u).len(), 10u);\n-        assert_eq!(r.gen_str(16u).len(), 16u);\n+        debug!(r.gen_ascii_str(10u));\n+        debug!(r.gen_ascii_str(10u));\n+        debug!(r.gen_ascii_str(10u));\n+        assert_eq!(r.gen_ascii_str(0u).len(), 0u);\n+        assert_eq!(r.gen_ascii_str(10u).len(), 10u);\n+        assert_eq!(r.gen_ascii_str(16u).len(), 16u);\n     }\n \n     #[test]\n-    fn test_gen_bytes() {\n+    fn test_gen_vec() {\n         let mut r = rng();\n-        assert_eq!(r.gen_bytes(0u).len(), 0u);\n-        assert_eq!(r.gen_bytes(10u).len(), 10u);\n-        assert_eq!(r.gen_bytes(16u).len(), 16u);\n+        assert_eq!(r.gen_vec::<u8>(0u).len(), 0u);\n+        assert_eq!(r.gen_vec::<u8>(10u).len(), 10u);\n+        assert_eq!(r.gen_vec::<f64>(16u).len(), 16u);\n     }\n \n     #[test]\n@@ -1060,9 +978,12 @@ mod test {\n     #[test]\n     fn test_choose_option() {\n         let mut r = rng();\n-        let x: Option<int> = r.choose_option([]);\n-        assert!(x.is_none());\n-        assert_eq!(r.choose_option([1, 1, 1]), Some(1));\n+        let v: &[int] = &[];\n+        assert!(r.choose_option(v).is_none());\n+\n+        let i = 1;\n+        let v = [1,1,1];\n+        assert_eq!(r.choose_option(v), Some(&i));\n     }\n \n     #[test]\n@@ -1107,16 +1028,16 @@ mod test {\n     fn test_shuffle() {\n         let mut r = rng();\n         let empty: ~[int] = ~[];\n-        assert_eq!(r.shuffle([]), empty);\n-        assert_eq!(r.shuffle([1, 1, 1]), ~[1, 1, 1]);\n+        assert_eq!(r.shuffle(~[]), empty);\n+        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n     }\n \n     #[test]\n     fn test_task_rng() {\n         let mut r = task_rng();\n         r.gen::<int>();\n-        assert_eq!(r.shuffle([1, 1, 1]), ~[1, 1, 1]);\n-        assert_eq!(r.gen_uint_range(0u, 1u), 0u);\n+        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n+        assert_eq!(r.gen_integer_range(0u, 1u), 0u);\n     }\n \n     #[test]\n@@ -1131,46 +1052,6 @@ mod test {\n                      (f32, (f64, (float,)))) = random();\n     }\n \n-    #[test]\n-    fn compare_isaac_implementation() {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        // This is to verify that the implementation of the ISAAC rng is\n-        // correct (i.e. matches the output of the upstream implementation,\n-        // which is in the runtime)\n-        use libc::size_t;\n-\n-        #[abi = \"cdecl\"]\n-        mod rustrt {\n-            use libc::size_t;\n-\n-            #[allow(non_camel_case_types)] // runtime type\n-            pub enum rust_rng {}\n-\n-            extern {\n-                pub fn rand_new_seeded(buf: *u8, sz: size_t) -> *rust_rng;\n-                pub fn rand_next(rng: *rust_rng) -> u32;\n-                pub fn rand_free(rng: *rust_rng);\n-            }\n-        }\n-\n-        // run against several seeds\n-        do 10.times {\n-            unsafe {\n-                let seed = super::seed();\n-                let rt_rng = do seed.as_imm_buf |p, sz| {\n-                    rustrt::rand_new_seeded(p, sz as size_t)\n-                };\n-                let mut rng = IsaacRng::new_seeded(seed);\n-\n-                do 10000.times {\n-                    assert_eq!(rng.next(), rustrt::rand_next(rt_rng));\n-                }\n-                rustrt::rand_free(rt_rng);\n-            }\n-        }\n-    }\n-\n     #[test]\n     fn test_sample() {\n         let MIN_VAL = 1;", "previous_filename": "src/libstd/rand.rs"}, {"sha": "6336b1cbe2e783dab3c9c4993ae9f5c8f8fc0ce8", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1095,7 +1095,7 @@ mod test {\n     #[test]\n     fn megapipe_stress() {\n         use rand;\n-        use rand::RngUtil;\n+        use rand::Rng;\n \n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n \n@@ -1106,7 +1106,7 @@ mod test {\n             let total = stress_factor() + 10;\n             let mut rng = rand::rng();\n             do total.times {\n-                let msgs = rng.gen_uint_range(0, 10);\n+                let msgs = rng.gen_integer_range(0u, 10);\n                 let pipe_clone = pipe.clone();\n                 let end_chan_clone = end_chan.clone();\n                 do spawntask_random {"}, {"sha": "9c6c53c206497db88d04bd91ae0c289cba79172a", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -26,7 +26,7 @@ use rt::local::Local;\n use rt::rtio::{RemoteCallback, PausibleIdleCallback};\n use borrow::{to_uint};\n use cell::Cell;\n-use rand::{XorShiftRng, RngUtil};\n+use rand::{XorShiftRng, Rng};\n use iter::range;\n use vec::{OwnedVector};\n \n@@ -391,7 +391,7 @@ impl Scheduler {\n     fn try_steals(&mut self) -> Option<~Task> {\n         let work_queues = &mut self.work_queues;\n         let len = work_queues.len();\n-        let start_index = self.rng.gen_uint_range(0, len);\n+        let start_index = self.rng.gen_integer_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n             match work_queues[index].steal() {\n                 Some(task) => {"}, {"sha": "c28b35e688d5a11be71eb7099e98121236a84609", "filename": "src/rt/isaac/rand.h", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/07167826d6b7b30c96cc9d6227fbe01b65e980f8/src%2Frt%2Fisaac%2Frand.h", "raw_url": "https://github.com/rust-lang/rust/raw/07167826d6b7b30c96cc9d6227fbe01b65e980f8/src%2Frt%2Fisaac%2Frand.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fisaac%2Frand.h?ref=07167826d6b7b30c96cc9d6227fbe01b65e980f8", "patch": "@@ -1,54 +0,0 @@\n-/*\n-------------------------------------------------------------------------------\n-rand.h: definitions for a random number generator\n-By Bob Jenkins, 1996, Public Domain\n-MODIFIED:\n-  960327: Creation (addition of randinit, really)\n-  970719: use context, not global variables, for internal state\n-  980324: renamed seed to flag\n-  980605: recommend RANDSIZL=4 for noncryptography.\n-  010626: note this is public domain\n-------------------------------------------------------------------------------\n-*/\n-#ifndef STANDARD\n-#include \"standard.h\"\n-#endif\n-\n-#ifndef RAND\n-#define RAND\n-#define RANDSIZL   (8)  /* I recommend 8 for crypto, 4 for simulations */\n-#define RANDSIZ    (1<<RANDSIZL)\n-\n-/* context of random number generator */\n-struct randctx\n-{\n-  ub4 randcnt;\n-  ub4 randrsl[RANDSIZ];\n-  ub4 randmem[RANDSIZ];\n-  ub4 randa;\n-  ub4 randb;\n-  ub4 randc;\n-};\n-typedef  struct randctx  randctx;\n-\n-/*\n-------------------------------------------------------------------------------\n- If (flag==TRUE), then use the contents of randrsl[0..RANDSIZ-1] as the seed.\n-------------------------------------------------------------------------------\n-*/\n-void randinit(randctx *r, word flag);\n-\n-void isaac(randctx *r);\n-\n-\n-/*\n-------------------------------------------------------------------------------\n- Call isaac_rand(/o_ randctx *r _o/) to retrieve a single 32-bit random value\n-------------------------------------------------------------------------------\n-*/\n-#define isaac_rand(r) \\\n-   (!(r)->randcnt-- ? \\\n-     (isaac(r), (r)->randcnt=RANDSIZ-1, (r)->randrsl[(r)->randcnt]) : \\\n-     (r)->randrsl[(r)->randcnt])\n-\n-#endif  /* RAND */"}, {"sha": "a2928a9b5d08e66998136f9d6a51f4808fa6b884", "filename": "src/rt/isaac/randport.cpp", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/07167826d6b7b30c96cc9d6227fbe01b65e980f8/src%2Frt%2Fisaac%2Frandport.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/07167826d6b7b30c96cc9d6227fbe01b65e980f8/src%2Frt%2Fisaac%2Frandport.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fisaac%2Frandport.cpp?ref=07167826d6b7b30c96cc9d6227fbe01b65e980f8", "patch": "@@ -1,139 +0,0 @@\n-/*\n-------------------------------------------------------------------------------\n-rand.c: By Bob Jenkins.  My random number generator, ISAAC.  Public Domain\n-MODIFIED:\n-  960327: Creation (addition of randinit, really)\n-  970719: use context, not global variables, for internal state\n-  980324: make a portable version\n-  010626: Note this is public domain\n-  100725: Mask on use of >32 bits, not on assignment: from Paul Eggert\n-------------------------------------------------------------------------------\n-*/\n-#ifndef STANDARD\n-#include \"standard.h\"\n-#endif\n-#ifndef RAND\n-#include \"rand.h\"\n-#endif\n-\n-\n-#define ind(mm,x)  ((mm)[(x>>2)&(RANDSIZ-1)])\n-#define rngstep(mix,a,b,mm,m,m2,r,x) \\\n-{ \\\n-  x = *m;  \\\n-  a = ((a^(mix)) + *(m2++)) & 0xffffffff; \\\n-  *(m++) = y = (ind(mm,x) + a + b) & 0xffffffff; \\\n-  *(r++) = b = (ind(mm,y>>RANDSIZL) + x) & 0xffffffff; \\\n-}\n-\n-void     isaac(randctx *ctx)\n-{\n-   ub4 a,b,x,y,*m,*mm,*m2,*r,*mend;\n-   mm=ctx->randmem; r=ctx->randrsl;\n-   a = ctx->randa; b = ctx->randb + (++ctx->randc);\n-   for (m = mm, mend = m2 = m+(RANDSIZ/2); m<mend; )\n-   {\n-      rngstep( a<<13, a, b, mm, m, m2, r, x);\n-      rngstep( (a & 0xffffffff) >>6 , a, b, mm, m, m2, r, x);\n-      rngstep( a<<2 , a, b, mm, m, m2, r, x);\n-      rngstep( (a & 0xffffffff) >>16, a, b, mm, m, m2, r, x);\n-   }\n-   for (m2 = mm; m2<mend; )\n-   {\n-      rngstep( a<<13, a, b, mm, m, m2, r, x);\n-      rngstep( (a & 0xffffffff) >>6 , a, b, mm, m, m2, r, x);\n-      rngstep( a<<2 , a, b, mm, m, m2, r, x);\n-      rngstep( (a & 0xffffffff) >>16, a, b, mm, m, m2, r, x);\n-   }\n-   ctx->randb = b; ctx->randa = a;\n-}\n-\n-\n-#define mix(a,b,c,d,e,f,g,h) \\\n-{ \\\n-   a^=b<<11;              d+=a; b+=c; \\\n-   b^=(c&0xffffffff)>>2;  e+=b; c+=d; \\\n-   c^=d<<8;               f+=c; d+=e; \\\n-   d^=(e&0xffffffff)>>16; g+=d; e+=f; \\\n-   e^=f<<10;              h+=e; f+=g; \\\n-   f^=(g&0xffffffff)>>4;  a+=f; g+=h; \\\n-   g^=h<<8;               b+=g; h+=a; \\\n-   h^=(a&0xffffffff)>>9;  c+=h; a+=b; \\\n-}\n-\n-/* if (flag==TRUE), then use the contents of randrsl[] to initialize mm[]. */\n-void randinit(randctx *ctx, word flag)\n-{\n-   word i;\n-   ub4 a,b,c,d,e,f,g,h;\n-   ub4 *m,*r;\n-   ctx->randa = ctx->randb = ctx->randc = 0;\n-   m=ctx->randmem;\n-   r=ctx->randrsl;\n-   a=b=c=d=e=f=g=h=0x9e3779b9;  /* the golden ratio */\n-\n-   for (i=0; i<4; ++i)          /* scramble it */\n-   {\n-     mix(a,b,c,d,e,f,g,h);\n-   }\n-\n-   if (flag)\n-   {\n-     /* initialize using the contents of r[] as the seed */\n-     for (i=0; i<RANDSIZ; i+=8)\n-     {\n-       a+=r[i  ]; b+=r[i+1];\n-       c+=r[i+2]; d+=r[i+3];\n-       e+=r[i+4]; f+=r[i+5];\n-       g+=r[i+6]; h+=r[i+7];\n-       mix(a,b,c,d,e,f,g,h);\n-       m[i  ]=a; m[i+1]=b; m[i+2]=c; m[i+3]=d;\n-       m[i+4]=e; m[i+5]=f; m[i+6]=g; m[i+7]=h;\n-     }\n-     /* do a second pass to make all of the seed affect all of m */\n-     for (i=0; i<RANDSIZ; i+=8)\n-     {\n-       a+=m[i  ]; b+=m[i+1];\n-       c+=m[i+2]; d+=m[i+3];\n-       e+=m[i+4]; f+=m[i+5];\n-       g+=m[i+6]; h+=m[i+7];\n-       mix(a,b,c,d,e,f,g,h);\n-       m[i  ]=a; m[i+1]=b; m[i+2]=c; m[i+3]=d;\n-       m[i+4]=e; m[i+5]=f; m[i+6]=g; m[i+7]=h;\n-     }\n-   }\n-   else\n-   {\n-     for (i=0; i<RANDSIZ; i+=8)\n-     {\n-       /* fill in mm[] with messy stuff */\n-       mix(a,b,c,d,e,f,g,h);\n-       m[i  ]=a; m[i+1]=b; m[i+2]=c; m[i+3]=d;\n-       m[i+4]=e; m[i+5]=f; m[i+6]=g; m[i+7]=h;\n-     }\n-   }\n-\n-   isaac(ctx);            /* fill in the first set of results */\n-   ctx->randcnt=RANDSIZ;  /* prepare to use the first set of results */\n-}\n-\n-\n-#ifdef NEVER\n-int main()\n-{\n-  ub4 i,j;\n-  randctx ctx;\n-  ctx.randa=ctx.randb=ctx.randc=(ub4)0;\n-  for (i=0; i<256; ++i) ctx.randrsl[i]=(ub4)0;\n-  randinit(&ctx, TRUE);\n-  for (i=0; i<2; ++i)\n-  {\n-    isaac(&ctx);\n-    for (j=0; j<256; ++j)\n-    {\n-      printf(\"%.8lx\",ctx.randrsl[j]);\n-      if ((j&7)==7) printf(\"\\n\");\n-    }\n-  }\n-}\n-#endif"}, {"sha": "c196a37474b9d3e4adefaebbe4d637b556d7e09d", "filename": "src/rt/isaac/standard.h", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/07167826d6b7b30c96cc9d6227fbe01b65e980f8/src%2Frt%2Fisaac%2Fstandard.h", "raw_url": "https://github.com/rust-lang/rust/raw/07167826d6b7b30c96cc9d6227fbe01b65e980f8/src%2Frt%2Fisaac%2Fstandard.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fisaac%2Fstandard.h?ref=07167826d6b7b30c96cc9d6227fbe01b65e980f8", "patch": "@@ -1,50 +0,0 @@\n-/*\n-------------------------------------------------------------------------------\n-Standard definitions and types, Bob Jenkins\n-------------------------------------------------------------------------------\n-*/\n-#ifndef STANDARD\n-# define STANDARD\n-# ifndef STDIO\n-#  include <stdio.h>\n-#  define STDIO\n-# endif\n-# ifndef STDDEF\n-#  include <stddef.h>\n-#  define STDDEF\n-# endif\n-# ifndef STDINT\n-#  include <stdint.h>\n-#  define STDINT\n-# endif\n-\n-typedef  uint64_t  ub8;\n-#define UB8MAXVAL 0xffffffffffffffffLL\n-#define UB8BITS 64\n-typedef   int64_t  sb8;\n-#define SB8MAXVAL 0x7fffffffffffffffLL\n-typedef  uint32_t  ub4;   /* unsigned 4-byte quantities */\n-#define UB4MAXVAL 0xffffffff\n-typedef   int32_t  sb4;\n-#define UB4BITS 32\n-#define SB4MAXVAL 0x7fffffff\n-typedef  uint16_t  ub2;\n-#define UB2MAXVAL 0xffff\n-#define UB2BITS 16\n-typedef   int16_t  sb2;\n-#define SB2MAXVAL 0x7fff\n-typedef   uint8_t  ub1;\n-#define UB1MAXVAL 0xff\n-#define UB1BITS 8\n-typedef    int8_t  sb1;   /* signed 1-byte quantities */\n-#define SB1MAXVAL 0x7f\n-typedef      int  word;  /* fastest type available */\n-\n-#define bis(target,mask)  ((target) |=  (mask))\n-#define bic(target,mask)  ((target) &= ~(mask))\n-#define bit(target,mask)  ((target) &   (mask))\n-#define TRUE  1\n-#define FALSE 0\n-#define SUCCESS 0  /* 1 on VAX */\n-\n-#endif /* STANDARD */"}, {"sha": "eeb0c95337a8bce53b5398b4e778ae828fa6f4a3", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -69,35 +69,11 @@ rust_env_pairs() {\n }\n #endif\n \n-extern \"C\" CDECL size_t\n-rand_seed_size() {\n-    return rng_seed_size();\n-}\n-\n extern \"C\" CDECL void\n rand_gen_seed(uint8_t* dest, size_t size) {\n     rng_gen_seed(dest, size);\n }\n \n-extern \"C\" CDECL void *\n-rand_new_seeded(uint8_t* seed, size_t seed_size) {\n-    assert(seed != NULL);\n-    rust_rng *rng = (rust_rng *) malloc(sizeof(rust_rng));\n-    assert(rng != NULL && \"rng alloc failed\");\n-    rng_init(rng, NULL, seed, seed_size);\n-    return rng;\n-}\n-\n-extern \"C\" CDECL uint32_t\n-rand_next(rust_rng *rng) {\n-    return rng_gen_u32(rng);\n-}\n-\n-extern \"C\" CDECL void\n-rand_free(rust_rng *rng) {\n-    free(rng);\n-}\n-\n extern \"C\" CDECL char*\n #if defined(__WIN32__)\n rust_list_dir_val(WIN32_FIND_DATA* entry_ptr) {"}, {"sha": "89754f94b7096842e1076a92229b044762e34c19", "filename": "src/rt/rust_rng.cpp", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frt%2Frust_rng.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frt%2Frust_rng.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_rng.cpp?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -32,14 +32,6 @@ win32_require(LPCTSTR fn, BOOL ok) {\n }\n #endif\n \n-size_t\n-rng_seed_size() {\n-    randctx rctx;\n-    return sizeof(rctx.randrsl);\n-}\n-\n-// Initialization helpers for ISAAC RNG\n-\n void\n rng_gen_seed(uint8_t* dest, size_t size) {\n #ifdef __WIN32__\n@@ -80,59 +72,6 @@ rng_gen_seed(uint8_t* dest, size_t size) {\n #endif\n }\n \n-static void\n-isaac_init(randctx *rctx, char *env_seed,\n-           uint8_t* user_seed, size_t seed_len) {\n-    memset(rctx, 0, sizeof(randctx));\n-\n-    if (user_seed != NULL) {\n-        // ignore bytes after the required length\n-        if (seed_len > sizeof(rctx->randrsl)) {\n-            seed_len = sizeof(rctx->randrsl);\n-        }\n-        memcpy(&rctx->randrsl, user_seed, seed_len);\n-    } else if (env_seed != NULL) {\n-        ub4 seed = (ub4) atoi(env_seed);\n-        for (size_t i = 0; i < RANDSIZ; i ++) {\n-            memcpy(&rctx->randrsl[i], &seed, sizeof(ub4));\n-            seed = (seed + 0x7ed55d16) + (seed << 12);\n-        }\n-    } else {\n-        rng_gen_seed((uint8_t*)&rctx->randrsl,\n-                     sizeof(rctx->randrsl));\n-    }\n-\n-    randinit(rctx, 1);\n-}\n-\n-void\n-rng_init(rust_rng* rng, char* env_seed,\n-         uint8_t *user_seed, size_t seed_len) {\n-    isaac_init(&rng->rctx, env_seed, user_seed, seed_len);\n-    rng->reseedable = !user_seed && !env_seed;\n-}\n-\n-static void\n-rng_maybe_reseed(rust_rng* rng) {\n-    // If this RNG has generated more than 32KB of random data and was not\n-    // seeded by the user or RUST_SEED, then we should reseed now.\n-    const size_t RESEED_THRESHOLD = 32 * 1024;\n-    size_t bytes_generated = rng->rctx.randc * sizeof(ub4);\n-    if (bytes_generated < RESEED_THRESHOLD || !rng->reseedable) {\n-        return;\n-    }\n-    rng_gen_seed((uint8_t*)rng->rctx.randrsl,\n-                 sizeof(rng->rctx.randrsl));\n-    randinit(&rng->rctx, 1);\n-}\n-\n-uint32_t\n-rng_gen_u32(rust_rng* rng) {\n-    uint32_t x = isaac_rand(&rng->rctx);\n-    rng_maybe_reseed(rng);\n-    return x;\n-}\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "08335a6f73f79ab777bd6bd1ba71c66e710cfb36", "filename": "src/rt/rust_rng.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frt%2Frust_rng.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frt%2Frust_rng.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_rng.h?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -11,22 +11,7 @@\n #ifndef RUST_RNG_H\n #define RUST_RNG_H\n \n-#include \"rand.h\"\n-\n-class rust_kernel;\n-\n-// Initialization helpers for ISAAC RNG\n-\n-struct rust_rng {\n-    randctx rctx;\n-    bool reseedable;\n-};\n-\n-size_t rng_seed_size();\n void rng_gen_seed(uint8_t* dest, size_t size);\n-void rng_init(rust_rng *rng, char *env_seed,\n-              uint8_t *user_seed, size_t seed_len);\n-uint32_t rng_gen_u32(rust_rng *rng);\n \n //\n // Local Variables:"}, {"sha": "186fb387eea500c25b5a184c38cb063c0d97baaa", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -9,11 +9,7 @@ rust_localtime\n rust_timegm\n rust_mktime\n precise_time_ns\n-rand_free\n-rand_new_seeded\n-rand_seed_size\n rand_gen_seed\n-rand_next\n rust_path_is_dir\n rust_path_exists\n rust_get_stdin"}, {"sha": "807f62ece7ae558051ab8672efa7aa9fdaa9abb5", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -15,7 +15,7 @@ extern mod extra;\n use extra::time::precise_time_s;\n use std::io;\n use std::os;\n-use std::rand::RngUtil;\n+use std::rand::Rng;\n use std::rand;\n use std::str;\n use std::util;\n@@ -85,7 +85,7 @@ fn vec_plus() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n+        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all_move(rv);\n         } else {\n@@ -101,7 +101,7 @@ fn vec_append() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n+        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n         if r.gen() {\n             v = vec::append(v, rv);\n         }\n@@ -117,7 +117,7 @@ fn vec_push_all() {\n \n     let mut v = ~[];\n     for i in range(0u, 1500) {\n-        let mut rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n+        let mut rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all(rv);\n         }"}, {"sha": "1a3a188b86f8d5500ed7528feb00b4a24fd58cca", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,7 +1,7 @@\n // Perlin noise benchmark from https://gist.github.com/1170424\n \n use std::float;\n-use std::rand::{Rng, RngUtil};\n+use std::rand::Rng;\n use std::rand;\n \n struct Vec2 {"}]}