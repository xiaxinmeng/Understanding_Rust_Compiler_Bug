{"sha": "2a84449169b3c882e101a68eb156800fe8ff24c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhODQ0NDkxNjliM2M4ODJlMTAxYTY4ZWIxNTY4MDBmZThmZjI0YzM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-24T15:00:55Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-09-06T15:18:09Z"}, "message": "allow testing DepNode::Krate edges directly", "tree": {"sha": "4d679676e244ed641c6394429e81368a4e83c877", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d679676e244ed641c6394429e81368a4e83c877"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a84449169b3c882e101a68eb156800fe8ff24c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a84449169b3c882e101a68eb156800fe8ff24c3", "html_url": "https://github.com/rust-lang/rust/commit/2a84449169b3c882e101a68eb156800fe8ff24c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a84449169b3c882e101a68eb156800fe8ff24c3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "753590f0c52c0ca54e7b80c1cc90f72bb8bbc8fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/753590f0c52c0ca54e7b80c1cc90f72bb8bbc8fb", "html_url": "https://github.com/rust-lang/rust/commit/753590f0c52c0ca54e7b80c1cc90f72bb8bbc8fb"}], "stats": {"total": 170, "additions": 78, "deletions": 92}, "files": [{"sha": "b28454cddb247feedf5868d4ddc69b3cd0662abf", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 71, "deletions": 87, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/2a84449169b3c882e101a68eb156800fe8ff24c3/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a84449169b3c882e101a68eb156800fe8ff24c3/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=2a84449169b3c882e101a68eb156800fe8ff24c3", "patch": "@@ -26,19 +26,20 @@\n //! used to check when paths exist or do not.\n //!\n //! The full form of the `rustc_if_this_changed` annotation is\n-//! `#[rustc_if_this_changed(id)]`. The `\"id\"` is optional and\n-//! defaults to `\"id\"` if omitted.\n+//! `#[rustc_if_this_changed(\"foo\")]`, which will report a\n+//! source node of `foo(def_id)`. The `\"foo\"` is optional and\n+//! defaults to `\"Hir\"` if omitted.\n //!\n //! Example:\n //!\n //! ```\n-//! #[rustc_if_this_changed]\n+//! #[rustc_if_this_changed(Hir)]\n //! fn foo() { }\n //!\n-//! #[rustc_then_this_would_need(\"trans\")] //~ ERROR no path from `foo`\n+//! #[rustc_then_this_would_need(trans)] //~ ERROR no path from `foo`\n //! fn bar() { }\n //!\n-//! #[rustc_then_this_would_need(\"trans\")] //~ ERROR OK\n+//! #[rustc_then_this_would_need(trans)] //~ ERROR OK\n //! fn baz() { foo(); }\n //! ```\n \n@@ -47,7 +48,7 @@ use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::fnv::FnvHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n use rustc::hir::intravisit::Visitor;\n@@ -61,7 +62,6 @@ use syntax_pos::Span;\n \n const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n-const ID: &'static str = \"id\";\n \n pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -80,8 +80,9 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // Find annotations supplied by user (if any).\n     let (if_this_changed, then_this_would_need) = {\n         let mut visitor = IfThisChanged { tcx: tcx,\n-                                          if_this_changed: FnvHashMap(),\n-                                          then_this_would_need: FnvHashMap() };\n+                                          if_this_changed: vec![],\n+                                          then_this_would_need: vec![] };\n+        visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.map.krate().attrs);\n         tcx.map.krate().visit_all_items(&mut visitor);\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n@@ -97,58 +98,51 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     check_paths(tcx, &if_this_changed, &then_this_would_need);\n }\n \n-type SourceHashMap =\n-    FnvHashMap<InternedString,\n-               FnvHashSet<(Span, DefId, DepNode<DefId>)>>;\n-type TargetHashMap =\n-    FnvHashMap<InternedString,\n-               FnvHashSet<(Span, InternedString, ast::NodeId, DepNode<DefId>)>>;\n+type Sources = Vec<(Span, DefId, DepNode<DefId>)>;\n+type Targets = Vec<(Span, InternedString, ast::NodeId, DepNode<DefId>)>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    if_this_changed: SourceHashMap,\n-    then_this_would_need: TargetHashMap,\n+    if_this_changed: Sources,\n+    then_this_would_need: Targets,\n }\n \n impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n-    fn process_attrs(&mut self, node_id: ast::NodeId, def_id: DefId) {\n-        for attr in self.tcx.get_attrs(def_id).iter() {\n+    fn argument(&self, attr: &ast::Attribute) -> Option<InternedString> {\n+        let mut value = None;\n+        for list_item in attr.meta_item_list().unwrap_or_default() {\n+            match list_item.word() {\n+                Some(word) if value.is_none() =>\n+                    value = Some(word.name().clone()),\n+                _ =>\n+                    // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                    span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),\n+            }\n+        }\n+        value\n+    }\n+\n+    fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n+        let def_id = self.tcx.map.local_def_id(node_id);\n+        for attr in attrs {\n             if attr.check_name(IF_THIS_CHANGED) {\n-                let mut id = None;\n-                for list_item in attr.meta_item_list().unwrap_or_default() {\n-                    match list_item.word() {\n-                        Some(word) if id.is_none() => {\n-                            id = Some(word.name().clone())\n-                        },\n-                        _ => {\n-                            // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                            span_bug!(list_item.span(), \"unexpected list-item {:?}\", list_item.node)\n+                let dep_node_interned = self.argument(attr);\n+                let dep_node = match dep_node_interned {\n+                    None => DepNode::Hir(def_id),\n+                    Some(ref n) => {\n+                        match DepNode::from_label_string(&n[..], def_id) {\n+                            Ok(n) => n,\n+                            Err(()) => {\n+                                self.tcx.sess.span_fatal(\n+                                    attr.span,\n+                                    &format!(\"unrecognized DepNode variant {:?}\", n));\n+                            }\n                         }\n                     }\n-                }\n-\n-                let id = id.unwrap_or(InternedString::new(ID));\n-                self.if_this_changed.entry(id)\n-                                    .or_insert(FnvHashSet())\n-                                    .insert((attr.span, def_id, DepNode::Hir(def_id)));\n+                };\n+                self.if_this_changed.push((attr.span, def_id, dep_node));\n             } else if attr.check_name(THEN_THIS_WOULD_NEED) {\n-                let mut dep_node_interned = None;\n-                let mut id = None;\n-                for list_item in attr.meta_item_list().unwrap_or_default() {\n-                    match list_item.word() {\n-                        Some(word) if dep_node_interned.is_none() => {\n-                            dep_node_interned = Some(word.name().clone());\n-                        },\n-                        Some(word) if id.is_none() => {\n-                            id = Some(word.name().clone())\n-                        },\n-                        _ => {\n-                            // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                            span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node)\n-                        }\n-                    }\n-                }\n-\n+                let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     Some(ref n) => {\n                         match DepNode::from_label_string(&n[..], def_id) {\n@@ -166,59 +160,49 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                             &format!(\"missing DepNode variant\"));\n                     }\n                 };\n-                let id = id.unwrap_or(InternedString::new(ID));\n-                self.then_this_would_need\n-                    .entry(id)\n-                    .or_insert(FnvHashSet())\n-                    .insert((attr.span, dep_node_interned.clone().unwrap(), node_id, dep_node));\n+                self.then_this_would_need.push((attr.span,\n+                                                dep_node_interned.clone().unwrap(),\n+                                                node_id,\n+                                                dep_node));\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = self.tcx.map.local_def_id(item.id);\n-        self.process_attrs(item.id, def_id);\n+        self.process_attrs(item.id, &item.attrs);\n     }\n }\n \n fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         if_this_changed: &SourceHashMap,\n-                         then_this_would_need: &TargetHashMap)\n+                         if_this_changed: &Sources,\n+                         then_this_would_need: &Targets)\n {\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n+        for &(target_span, _, _, _) in then_this_would_need {\n+            tcx.sess.span_err(\n+                target_span,\n+                &format!(\"no #[rustc_if_this_changed] annotation detected\"));\n+\n+        }\n         return;\n     }\n     let query = tcx.dep_graph.query();\n-    for (id, sources) in if_this_changed {\n-        let targets = match then_this_would_need.get(id) {\n-            Some(targets) => targets,\n-            None => {\n-                for &(source_span, ..) in sources.iter().take(1) {\n-                    tcx.sess.span_err(\n-                        source_span,\n-                        &format!(\"no targets for id `{}`\", id));\n-                }\n-                continue;\n-            }\n-        };\n-\n-        for &(_, source_def_id, ref source_dep_node) in sources {\n-            let dependents = query.transitive_successors(source_dep_node);\n-            for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n-                if !dependents.contains(&target_dep_node) {\n-                    tcx.sess.span_err(\n-                        target_span,\n-                        &format!(\"no path from `{}` to `{}`\",\n-                                 tcx.item_path_str(source_def_id),\n-                                 target_pass));\n-                } else {\n-                    tcx.sess.span_err(\n-                        target_span,\n-                        &format!(\"OK\"));\n-                }\n+    for &(_, source_def_id, ref source_dep_node) in if_this_changed {\n+        let dependents = query.transitive_successors(source_dep_node);\n+        for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n+            if !dependents.contains(&target_dep_node) {\n+                tcx.sess.span_err(\n+                    target_span,\n+                    &format!(\"no path from `{}` to `{}`\",\n+                             tcx.item_path_str(source_def_id),\n+                             target_pass));\n+            } else {\n+                tcx.sess.span_err(\n+                    target_span,\n+                    &format!(\"OK\"));\n             }\n         }\n     }"}, {"sha": "ba32b41983fc2bd031dab2d889ac5a2de8928232", "filename": "src/test/incremental/krate-inlined.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a84449169b3c882e101a68eb156800fe8ff24c3/src%2Ftest%2Fincremental%2Fkrate-inlined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a84449169b3c882e101a68eb156800fe8ff24c3/src%2Ftest%2Fincremental%2Fkrate-inlined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate-inlined.rs?ref=2a84449169b3c882e101a68eb156800fe8ff24c3", "patch": "@@ -8,22 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: rpass1 rpass2\n+// Regr. test that using HIR inlined from another krate does *not* add\n+// a dependency from the local Krate node.\n+\n+// revisions: cfail1\n // compile-flags: -Z query-dep-graph\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n-#![rustc_partition_reused(module=\"krate_inlined-x\", cfg=\"rpass2\")]\n+\n+#![rustc_if_this_changed(Krate)]\n \n fn main() { }\n \n mod x {\n+    #[rustc_then_this_would_need(TransCrateItem)] //[cfail1]~ ERROR no path\n     fn method() {\n         // use some methods that require inlining HIR from another crate:\n         let mut v = vec![];\n         v.push(1);\n     }\n }\n-\n-#[cfg(rpass1)]\n-fn bar() { } // remove this unrelated fn in rpass2, which should not affect `x::method`"}]}