{"sha": "f065d4b887e6722d617eacc93d5dcb75e6b32105", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNjVkNGI4ODdlNjcyMmQ2MTdlYWNjOTNkNWRjYjc1ZTZiMzIxMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-09T20:49:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-09T20:49:27Z"}, "message": "Auto merge of #5279 - DevinR528:macro-use-sugg, r=flip1995\n\nMacro use sugg\n\nchangelog: Add auto applicable suggstion to macro_use_imports\n\nfixes #5275\n\n<s>Where exactly is the `wildcard_imports_helper` I haven't been able to import anything ex.\n`use lazy_static;` or something like for that I get version/compiler conflicts?</s>\nFound it.\n\nShould we also check for `#[macro_use] extern crate`, although this is still depended on for stuff like `rustc_private`?", "tree": {"sha": "70742040b2efee818c1a3c4218a025a6d5f48d96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70742040b2efee818c1a3c4218a025a6d5f48d96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f065d4b887e6722d617eacc93d5dcb75e6b32105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f065d4b887e6722d617eacc93d5dcb75e6b32105", "html_url": "https://github.com/rust-lang/rust/commit/f065d4b887e6722d617eacc93d5dcb75e6b32105", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f065d4b887e6722d617eacc93d5dcb75e6b32105/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff0993c5e9162ddaea78e83d0f0161e68bd4ea73", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0993c5e9162ddaea78e83d0f0161e68bd4ea73", "html_url": "https://github.com/rust-lang/rust/commit/ff0993c5e9162ddaea78e83d0f0161e68bd4ea73"}, {"sha": "e521a4ed3818c02a1831db570e69d056c351ee05", "url": "https://api.github.com/repos/rust-lang/rust/commits/e521a4ed3818c02a1831db570e69d056c351ee05", "html_url": "https://github.com/rust-lang/rust/commit/e521a4ed3818c02a1831db570e69d056c351ee05"}], "stats": {"total": 388, "additions": 360, "deletions": 28}, "files": [{"sha": "021fbe932d895916e7198b2a3792416bd217c60a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f065d4b887e6722d617eacc93d5dcb75e6b32105/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f065d4b887e6722d617eacc93d5dcb75e6b32105/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f065d4b887e6722d617eacc93d5dcb75e6b32105", "patch": "@@ -1062,7 +1062,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box option_env_unwrap::OptionEnvUnwrap);\n     let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n     store.register_late_pass(move || box wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports));\n-    store.register_early_pass(|| box macro_use::MacroUseImports);\n     store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n@@ -1080,6 +1079,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         single_char_binding_names_threshold,\n     });\n     store.register_early_pass(|| box unnested_or_patterns::UnnestedOrPatterns);\n+    store.register_late_pass(|| box macro_use::MacroUseImports::default());\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),"}, {"sha": "b845b20d2c012c6dc6b4193d36a1b79da03ee2b2", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 196, "deletions": 17, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/f065d4b887e6722d617eacc93d5dcb75e6b32105/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f065d4b887e6722d617eacc93d5dcb75e6b32105/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=f065d4b887e6722d617eacc93d5dcb75e6b32105", "patch": "@@ -1,18 +1,21 @@\n-use crate::utils::{snippet, span_lint_and_sugg};\n+use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n+use hir::def::{DefKind, Res};\n use if_chain::if_chain;\n use rustc_ast::ast;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::edition::Edition;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{edition::Edition, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `#[macro_use] use...`.\n     ///\n     /// **Why is this bad?** Since the Rust 2018 edition you can import\n     /// macro's directly, this is considered idiomatic.\n     ///\n-    /// **Known problems:** This lint does not generate an auto-applicable suggestion.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -24,29 +27,205 @@ declare_clippy_lint! {\n     \"#[macro_use] is no longer needed\"\n }\n \n-declare_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n+const BRACKETS: &[char] = &['<', '>'];\n \n-impl EarlyLintPass for MacroUseImports {\n-    fn check_item(&mut self, ecx: &EarlyContext<'_>, item: &ast::Item) {\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+struct PathAndSpan {\n+    path: String,\n+    span: Span,\n+}\n+\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n+#[derive(Debug, Clone)]\n+pub struct MacroRefData {\n+    name: String,\n+    path: String,\n+}\n+\n+impl MacroRefData {\n+    pub fn new(name: String, callee: Span, cx: &LateContext<'_, '_>) -> Self {\n+        let mut path = cx.sess().source_map().span_to_filename(callee).to_string();\n+\n+        // std lib paths are <::std::module::file type>\n+        // so remove brackets, space and type.\n+        if path.contains('<') {\n+            path = path.replace(BRACKETS, \"\");\n+        }\n+        if path.contains(' ') {\n+            path = path.split(' ').next().unwrap().to_string();\n+        }\n+        Self { name, path }\n+    }\n+}\n+\n+#[derive(Default)]\n+#[allow(clippy::module_name_repetitions)]\n+pub struct MacroUseImports {\n+    /// the actual import path used and the span of the attribute above it.\n+    imports: Vec<(String, Span)>,\n+    /// the span of the macro reference, kept to ensure only one reference is used per macro call.\n+    collected: FxHashSet<Span>,\n+    mac_refs: Vec<MacroRefData>,\n+}\n+\n+impl_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n+\n+impl MacroUseImports {\n+    fn push_unique_macro(&mut self, cx: &LateContext<'_, '_>, span: Span) {\n+        let call_site = span.source_callsite();\n+        let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+        if let Some(callee) = span.source_callee() {\n+            if !self.collected.contains(&call_site) {\n+                let name = if name.contains(\"::\") {\n+                    name.split(\"::\").last().unwrap().to_string()\n+                } else {\n+                    name.to_string()\n+                };\n+\n+                self.mac_refs.push(MacroRefData::new(name, callee.def_site, cx));\n+                self.collected.insert(call_site);\n+            }\n+        }\n+    }\n+\n+    fn push_unique_macro_pat_ty(&mut self, cx: &LateContext<'_, '_>, span: Span) {\n+        let call_site = span.source_callsite();\n+        let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+        if let Some(callee) = span.source_callee() {\n+            if !self.collected.contains(&call_site) {\n+                self.mac_refs\n+                    .push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n+                self.collected.insert(call_site);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         if_chain! {\n-            if ecx.sess.opts.edition == Edition::Edition2018;\n-            if let ast::ItemKind::Use(use_tree) = &item.kind;\n+            if cx.sess().opts.edition == Edition::Edition2018;\n+            if let hir::ItemKind::Use(path, _kind) = &item.kind;\n             if let Some(mac_attr) = item\n                 .attrs\n                 .iter()\n                 .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n+            if let Res::Def(DefKind::Mod, id) = path.res;\n             then {\n-                let msg = \"`macro_use` attributes are no longer needed in the Rust 2018 edition\";\n-                let help = format!(\"use {}::<macro name>\", snippet(ecx, use_tree.span, \"_\"));\n+                for kid in cx.tcx.item_children(id).iter() {\n+                    if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n+                        let span = mac_attr.span;\n+                        let def_path = cx.tcx.def_path_str(mac_id);\n+                        self.imports.push((def_path, span));\n+                    }\n+                }\n+            } else {\n+                if in_macro(item.span) {\n+                    self.push_unique_macro_pat_ty(cx, item.span);\n+                }\n+            }\n+        }\n+    }\n+    fn check_attribute(&mut self, cx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n+        if in_macro(attr.span) {\n+            self.push_unique_macro(cx, attr.span);\n+        }\n+    }\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n+        if in_macro(expr.span) {\n+            self.push_unique_macro(cx, expr.span);\n+        }\n+    }\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n+        if in_macro(stmt.span) {\n+            self.push_unique_macro(cx, stmt.span);\n+        }\n+    }\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n+        if in_macro(pat.span) {\n+            self.push_unique_macro_pat_ty(cx, pat.span);\n+        }\n+    }\n+    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &hir::Ty<'_>) {\n+        if in_macro(ty.span) {\n+            self.push_unique_macro_pat_ty(cx, ty.span);\n+        }\n+    }\n+    #[allow(clippy::too_many_lines)]\n+    fn check_crate_post(&mut self, cx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n+        let mut used = FxHashMap::default();\n+        let mut check_dup = vec![];\n+        for (import, span) in &self.imports {\n+            let found_idx = self.mac_refs.iter().position(|mac| import.ends_with(&mac.name));\n+\n+            if let Some(idx) = found_idx {\n+                let _ = self.mac_refs.remove(idx);\n+                let seg = import.split(\"::\").collect::<Vec<_>>();\n+\n+                match seg.as_slice() {\n+                    // an empty path is impossible\n+                    // a path should always consist of 2 or more segments\n+                    [] | [_] => return,\n+                    [root, item] => {\n+                        if !check_dup.contains(&(*item).to_string()) {\n+                            used.entry(((*root).to_string(), span))\n+                                .or_insert_with(Vec::new)\n+                                .push((*item).to_string());\n+                            check_dup.push((*item).to_string());\n+                        }\n+                    },\n+                    [root, rest @ ..] => {\n+                        if rest.iter().all(|item| !check_dup.contains(&(*item).to_string())) {\n+                            let filtered = rest\n+                                .iter()\n+                                .filter_map(|item| {\n+                                    if check_dup.contains(&(*item).to_string()) {\n+                                        None\n+                                    } else {\n+                                        Some((*item).to_string())\n+                                    }\n+                                })\n+                                .collect::<Vec<_>>();\n+                            used.entry(((*root).to_string(), span))\n+                                .or_insert_with(Vec::new)\n+                                .push(filtered.join(\"::\"));\n+                            check_dup.extend(filtered);\n+                        } else {\n+                            let rest = rest.to_vec();\n+                            used.entry(((*root).to_string(), span))\n+                                .or_insert_with(Vec::new)\n+                                .push(rest.join(\"::\"));\n+                            check_dup.extend(rest.iter().map(ToString::to_string));\n+                        }\n+                    },\n+                }\n+            }\n+        }\n+\n+        let mut suggestions = vec![];\n+        for ((root, span), path) in used {\n+            if path.len() == 1 {\n+                suggestions.push((span, format!(\"{}::{}\", root, path[0])))\n+            } else {\n+                suggestions.push((span, format!(\"{}::{{{}}}\", root, path.join(\", \"))))\n+            }\n+        }\n+\n+        // If mac_refs is not empty we have encountered an import we could not handle\n+        // such as `std::prelude::v1::foo` or some other macro that expands to an import.\n+        if self.mac_refs.is_empty() {\n+            for (span, import) in suggestions {\n+                let help = format!(\"use {};\", import);\n                 span_lint_and_sugg(\n-                    ecx,\n+                    cx,\n                     MACRO_USE_IMPORTS,\n-                    mac_attr.span,\n-                    msg,\n+                    *span,\n+                    \"`macro_use` attributes are no longer needed in the Rust 2018 edition\",\n                     \"remove the attribute and import the macro directly, try\",\n                     help,\n-                    Applicability::HasPlaceholders,\n-                );\n+                    Applicability::MaybeIncorrect,\n+                )\n             }\n         }\n     }"}, {"sha": "ecb55d8cb48d5bbcb6f32ba3223d6ef8671793ed", "filename": "tests/ui/auxiliary/macro_use_helper.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f065d4b887e6722d617eacc93d5dcb75e6b32105/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f065d4b887e6722d617eacc93d5dcb75e6b32105/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs?ref=f065d4b887e6722d617eacc93d5dcb75e6b32105", "patch": "@@ -0,0 +1,60 @@\n+extern crate macro_rules;\n+\n+// STMT\n+#[macro_export]\n+macro_rules! pub_macro {\n+    () => {\n+        let _ = \"hello Mr. Vonnegut\";\n+    };\n+}\n+\n+pub mod inner {\n+    pub use super::*;\n+\n+    // RE-EXPORT\n+    // this will stick in `inner` module\n+    pub use macro_rules::foofoo;\n+    pub use macro_rules::try_err;\n+\n+    pub mod nested {\n+        pub use macro_rules::string_add;\n+    }\n+\n+    // ITEM\n+    #[macro_export]\n+    macro_rules! inner_mod_macro {\n+        () => {\n+            #[allow(dead_code)]\n+            pub struct Tardis;\n+        };\n+    }\n+}\n+\n+// EXPR\n+#[macro_export]\n+macro_rules! function_macro {\n+    () => {\n+        if true {\n+        } else {\n+        }\n+    };\n+}\n+\n+// TYPE\n+#[macro_export]\n+macro_rules! ty_macro {\n+    () => {\n+        Vec<u8>\n+    };\n+}\n+\n+mod extern_exports {\n+    pub(super) mod private_inner {\n+        #[macro_export]\n+        macro_rules! pub_in_private_macro {\n+            ($name:ident) => {\n+                let $name = String::from(\"secrets and lies\");\n+            };\n+        }\n+    }\n+}"}, {"sha": "91e34c62160a129672ce3c9f08da34e3943ffd04", "filename": "tests/ui/macro_use_imports.fixed", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f065d4b887e6722d617eacc93d5dcb75e6b32105/tests%2Fui%2Fmacro_use_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f065d4b887e6722d617eacc93d5dcb75e6b32105/tests%2Fui%2Fmacro_use_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.fixed?ref=f065d4b887e6722d617eacc93d5dcb75e6b32105", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: --edition 2018\n+// aux-build:macro_rules.rs\n+// aux-build:macro_use_helper.rs\n+// run-rustfix\n+// ignore-32bit\n+\n+#![allow(unused_imports, unreachable_code, unused_variables, dead_code)]\n+#![allow(clippy::single_component_path_imports)]\n+#![warn(clippy::macro_use_imports)]\n+\n+#[macro_use]\n+extern crate macro_use_helper as mac;\n+\n+#[macro_use]\n+extern crate clippy_mini_macro_test as mini_mac;\n+\n+mod a {\n+    use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro};\n+    use mac;\n+    use mini_mac::ClippyMiniMacroTest;\n+    use mini_mac;\n+    use mac::{inner::foofoo, inner::try_err};\n+    use mac::inner;\n+    use mac::inner::nested::string_add;\n+    use mac::inner::nested;\n+\n+    #[derive(ClippyMiniMacroTest)]\n+    struct Test;\n+\n+    fn test() {\n+        pub_macro!();\n+        inner_mod_macro!();\n+        pub_in_private_macro!(_var);\n+        function_macro!();\n+        let v: ty_macro!() = Vec::default();\n+\n+        inner::try_err!();\n+        inner::foofoo!();\n+        nested::string_add!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9c3c50c5d49f29b0a03eea1ca77c583a71686597", "filename": "tests/ui/macro_use_imports.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f065d4b887e6722d617eacc93d5dcb75e6b32105/tests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f065d4b887e6722d617eacc93d5dcb75e6b32105/tests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.rs?ref=f065d4b887e6722d617eacc93d5dcb75e6b32105", "patch": "@@ -1,11 +1,43 @@\n-// edition:2018\n+// compile-flags: --edition 2018\n+// aux-build:macro_rules.rs\n+// aux-build:macro_use_helper.rs\n+// run-rustfix\n+// ignore-32bit\n+\n+#![allow(unused_imports, unreachable_code, unused_variables, dead_code)]\n+#![allow(clippy::single_component_path_imports)]\n #![warn(clippy::macro_use_imports)]\n \n-use std::collections::HashMap;\n #[macro_use]\n-use std::prelude;\n+extern crate macro_use_helper as mac;\n+\n+#[macro_use]\n+extern crate clippy_mini_macro_test as mini_mac;\n+\n+mod a {\n+    #[macro_use]\n+    use mac;\n+    #[macro_use]\n+    use mini_mac;\n+    #[macro_use]\n+    use mac::inner;\n+    #[macro_use]\n+    use mac::inner::nested;\n \n-fn main() {\n-    let _ = HashMap::<u8, u8>::new();\n-    println!();\n+    #[derive(ClippyMiniMacroTest)]\n+    struct Test;\n+\n+    fn test() {\n+        pub_macro!();\n+        inner_mod_macro!();\n+        pub_in_private_macro!(_var);\n+        function_macro!();\n+        let v: ty_macro!() = Vec::default();\n+\n+        inner::try_err!();\n+        inner::foofoo!();\n+        nested::string_add!();\n+    }\n }\n+\n+fn main() {}"}, {"sha": "f8c86c8d9179f8af918b684eb9294c18ea4a7008", "filename": "tests/ui/macro_use_imports.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f065d4b887e6722d617eacc93d5dcb75e6b32105/tests%2Fui%2Fmacro_use_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f065d4b887e6722d617eacc93d5dcb75e6b32105/tests%2Fui%2Fmacro_use_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.stderr?ref=f065d4b887e6722d617eacc93d5dcb75e6b32105", "patch": "@@ -1,10 +1,28 @@\n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:5:1\n+  --> $DIR/macro_use_imports.rs:18:5\n    |\n-LL | #[macro_use]\n-   | ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use std::prelude::<macro name>`\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro};`\n    |\n    = note: `-D clippy::macro-use-imports` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:20:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mini_mac::ClippyMiniMacroTest;`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:22:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{inner::foofoo, inner::try_err};`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:24:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::nested::string_add;`\n+\n+error: aborting due to 4 previous errors\n "}]}