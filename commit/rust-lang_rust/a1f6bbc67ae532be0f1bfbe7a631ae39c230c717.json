{"sha": "a1f6bbc67ae532be0f1bfbe7a631ae39c230c717", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZjZiYmM2N2FlNTMyYmUwZjFiZmJlN2E2MzFhZTM5YzIzMGM3MTc=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-26T23:52:20Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-26T23:52:20Z"}, "message": "niko fixes", "tree": {"sha": "9b5ddaea4a0fbae5264d96e33d310a8714d0f170", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b5ddaea4a0fbae5264d96e33d310a8714d0f170"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717", "html_url": "https://github.com/rust-lang/rust/commit/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2e802b827d5020c89e1d3290fe13602386a4b33", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e802b827d5020c89e1d3290fe13602386a4b33", "html_url": "https://github.com/rust-lang/rust/commit/d2e802b827d5020c89e1d3290fe13602386a4b33"}], "stats": {"total": 222, "additions": 126, "deletions": 96}, "files": [{"sha": "04cfe58b3b0a6509acd8d1ef63db3f1e5bb65563", "filename": "README.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a1f6bbc67ae532be0f1bfbe7a631ae39c230c717", "patch": "@@ -92,7 +92,6 @@ quite permisive with respect to other dubious operations. Rust considers it\n * Deadlock\n * Leak memory\n * Fail to call destructors\n-* Access private fields\n * Overflow integers\n * Delete the production database\n "}, {"sha": "48bfcb029913e50f189324a0661e1df76ca1fce4", "filename": "lifetimes.md", "status": "modified", "additions": 126, "deletions": 95, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717/lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717/lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lifetimes.md?ref=a1f6bbc67ae532be0f1bfbe7a631ae39c230c717", "patch": "@@ -102,59 +102,11 @@ more than a local lint against incorrect usage of a value.\n \n \n \n-# Weird Lifetimes\n-\n-Given the following code:\n-\n-```rust\n-struct Foo;\n-\n-impl Foo {\n-    fn mutate_and_share(&mut self) -> &Self { &*self }\n-    fn share(&self) {}\n-}\n-\n-fn main() {\n-    let mut foo = Foo;\n-    let loan = foo.mutate_and_share();\n-    foo.share();\n-}\n-```\n-\n-One might expect it to compile. We call `mutate_and_share`, which mutably borrows\n-`foo` *temporarily*, but then returns *only* a shared reference. Therefore we\n-would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.\n-\n-However when we try to compile it:\n-\n-```text\n-<anon>:11:5: 11:8 error: cannot borrow `foo` as immutable because it is also borrowed as mutable\n-<anon>:11     foo.share();\n-              ^~~\n-<anon>:10:16: 10:19 note: previous borrow of `foo` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `foo` until the borrow ends\n-<anon>:10     let loan = foo.mutate_and_share();\n-                         ^~~\n-<anon>:12:2: 12:2 note: previous borrow ends here\n-<anon>:8 fn main() {\n-<anon>:9     let mut foo = Foo;\n-<anon>:10     let loan = foo.mutate_and_share();\n-<anon>:11     foo.share();\n-<anon>:12 }\n-          ^\n-```\n-\n-What happened? Well, the lifetime of `loan` is derived from a *mutable* borrow.\n-This makes the type system believe that `foo` is mutably borrowed as long as\n-`loan` exists, even though it's a shared reference. To my knowledge, this is not\n-a bug.\n-\n-\n-\n \n # Lifetime Elision\n \n In order to make common patterns more ergonomic, Rust allows lifetimes to be\n-*elided* in function, impl, and type signatures.\n+*elided* in function signatures.\n \n A *lifetime position* is anywhere you can write a lifetime in a type:\n \n@@ -336,16 +288,18 @@ In Rust, subtyping derives entirely from *lifetimes*. Since lifetimes are derive\n from scopes, we can partially order them based on an *outlives* relationship. We\n can even express this as a generic bound: `T: 'a` specifies that `T` *outlives* `'a`.\n \n-We can then define subtyping on lifetimes in terms of lifetimes: `'a : 'b` implies\n-`'a <: b` -- if `'a` outlives `'b`, then `'a` is a subtype of `'b`. This is a very\n+We can then define subtyping on lifetimes in terms of lifetimes: if `'a : 'b`\n+(\"a outlives b\"), then `'a` is a subtype of  `b`. This is a\n large source of confusion, because a bigger scope is a *sub type* of a smaller scope.\n This does in fact make sense. The intuitive reason for this is that if you expect an\n-`&'a u8`, then it's totally fine for me to hand you an `&'static u8`, in the same way\n+`&'a u8`, then it's totally fine for me to hand you an `&'static u8` in the same way\n that if you expect an Animal in Java, it's totally fine for me to hand you a Cat.\n \n (Note, the subtyping relationship and typed-ness of lifetimes is a fairly arbitrary\n construct that some disagree with. I just find that it simplifies this analysis.)\n \n+TODO: higher rank lifetime subtyping\n+\n Variance is where things get really harsh.\n \n Variance is a property that *type constructors* have. A type constructor in Rust\n@@ -356,21 +310,27 @@ take a lifetime and a type.\n A type constructor's *variance* is how the subtypes of its inputs affects the\n subtypes of its outputs. There are three kinds of variance:\n \n-* F is *covariant* if `T <: U` implies `F<T> <: F<U>`\n-* F is *contravariant* if `T <: U` implies `F<U> <: F<T>`\n+* F is *variant* if `T` being a subtype of `U` implies `F<T>` is a subtype of `F<U>`\n * F is *invariant* otherwise (no subtyping relation can be derived)\n \n+(For those of you who are familiar with variance from other languages, what we refer\n+to as \"just\" variant is in fact *covariant*. Rust does not have contravariance.\n+Historically Rust did have some contravariance but it was scrapped due to poor\n+interactions with other features.)\n+\n Some important variances:\n \n-* `&` is covariant (as is *const by metaphor)\n+* `&` is variant (as is *const by metaphor)\n * `&mut` is invariant (as is *mut by metaphor)\n-* `Fn(T)` is contravariant with respect to `T`\n-* `Box`, `Vec`, and all other collections are covariant\n+* `Fn(T) -> U` is invariant with respect to `T`, but variant with respect to `U`\n+* `Box`, `Vec`, and all other collections are variant\n * `UnsafeCell`, `Cell`, `RefCell`, `Mutex` and all \"interior mutability\"\n   types are invariant\n \n To understand why these variances are correct and desirable, we will consider several\n-examples. We have already covered why `&` should be covariant.\n+examples. We have already covered why `&` should be variant when introducing subtyping:\n+it's desirable to be able to pass longer-lived things where shorter-lived things are\n+needed.\n \n To see why `&mut` should be invariant, consider the following code:\n \n@@ -391,28 +351,29 @@ fn overwrite<T: Copy>(input: &mut T, new: &mut T) {\n \n The signature of `overwrite` is clearly valid: it takes mutable references to two values\n of the same type, and replaces one with the other. We have seen already that `&` is\n-covariant, and `'static` is a subtype of *any* `'a`, so `&'static str` is a\n+variant, and `'static` is a subtype of *any* `'a`, so `&'static str` is a\n subtype of `&'a str`. Therefore, if `&mut` was\n-*also* covariant, then the lifetime of the `&'static str` would successfully be\n+*also* variant, then the lifetime of the `&'static str` would successfully be\n \"shrunk\" down to the shorter lifetime of the string, and `replace` would be\n called successfully. The string would subsequently be dropped, and `forever_str`\n would point to freed memory when we print it!\n \n-Therefore `&mut` should be invariant. This is the general theme of covariance vs\n-invariance: if covariance would allow you to *store* a short-lived value in a\n+Therefore `&mut` should be invariant. This is the general theme of variance vs\n+invariance: if variance would allow you to *store* a short-lived value in a\n longer-lived slot, then you must be invariant.\n \n-`Box` and `Vec` are interesting cases because they're covariant, but you can\n+`Box` and `Vec` are interesting cases because they're variant, but you can\n definitely store values in them! This is fine because *you can only store values\n in them through a mutable reference*! The mutable reference makes the whole type\n invariant, and therefore prevents you from getting in trouble.\n \n-Being covariant allows them to be covariant when shared immutably (so you can pass\n+Being variant allows them to be variant when shared immutably (so you can pass\n a `&Box<&'static str>` where a `&Box<&'a str>` is expected). It also allows you to\n forever weaken the type by moving it into a weaker slot. That is, you can do:\n \n ```rust\n fn get_box<'a>(&'a u8) -> Box<&'a str> {\n+    // string literals are `&'static str`s\n     Box::new(\"hello\")\n }\n ```\n@@ -424,51 +385,67 @@ The variance of the cell types similarly follows. `&` is like an `&mut` for a\n cell, because you can still store values in them through an `&`. Therefore cells\n must be invariant to avoid lifetime smuggling.\n \n-`Fn` is the most confusing case, largely because contravariance is easily the\n-most confusing kind of variance, and basically never comes up. To understand it,\n-consider a function `len` that takes a function `F`.\n+`Fn` is the most subtle case, because it has mixed variance. To see why\n+`Fn(T) -> U` should be invariant over T, consider the following function\n+signature:\n \n ```rust\n-fn len<F>(func: F) -> usize\n-    where F: Fn(&'static str) -> usize\n-{\n-    func(\"hello\")\n-}\n+// 'a is derived from some parent scope\n+fn foo(&'a str) -> usize;\n ```\n \n-We require that F is a Fn that can take an `&'static str` and returns a usize. Now\n-say we have a function that can take an `&'a str` (for *some* `'a`). Such a function actually\n-accepts *more* inputs, since `&'static str` is a subtype of `&'a str`. Therefore\n-`len` should happily accept such a function!\n+This signature claims that it can handle any &str that lives *at least* as long\n+as `'a`. Now if this signature was variant with respect to &str, that would mean\n+\n+```rust\n+fn foo(&'static str) -> usize;\n+```\n \n-So a `Fn(&'a str)` is a subtype of a `Fn(&'static str)` because\n-`&'static str` is a subtype of `&'a str`. Exactly contravariance.\n+could be provided in its place, as it would be a subtype. However this function\n+has a *stronger* requirement: it says that it can *only* handle `&'static str`s,\n+and nothing else. Therefore functions are not variant over their arguments.\n \n-The variance of `*const` and `*mut` is basically arbitrary as they're not at all\n-type or memory safe, so their variance is determined in analogy to & and &mut\n-respectively.\n+To see why `Fn(T) -> U` should be *variant* over U, consider the following\n+function signature:\n+\n+```rust\n+// 'a is derived from some parent scope\n+fn foo(usize) -> &'a str;\n+```\n+\n+This signature claims that it will return something that outlives `'a`. It is\n+therefore completely reasonable to provide\n+\n+```rust\n+fn foo(usize) -> &'static str;\n+```\n+\n+in its place. Therefore functions *are* variant over their return type.\n+\n+`*const` has the exact same semantics as &, so variance follows. `*mut` on the\n+other hand can dereference to an &mut whether shared or not, so it is marked\n+as invariant in analogy to cells.\n \n This is all well and good for the types the standard library provides, but\n-how is variance determined for type that *you* define? A struct informally\n-speaking inherits the variance of its fields. If a struct `Foo`\n+how is variance determined for type that *you* define? A struct, informally\n+speaking, inherits the variance of its fields. If a struct `Foo`\n has a generic argument `A` that is used in a field `a`, then Foo's variance\n over `A` is exactly `a`'s variance. However this is complicated if `A` is used\n in multiple fields.\n \n-* If all uses of A are covariant, then Foo is covariant over A\n-* If all uses of A are contravariant, then Foo is contravariant over A\n+* If all uses of A are variant, then Foo is variant over A\n * Otherwise, Foo is invariant over A\n \n ```rust\n struct Foo<'a, 'b, A, B, C, D, E, F, G, H> {\n-    a: &'a A,     // covariant over 'a and A\n+    a: &'a A,     // variant over 'a and A\n     b: &'b mut B, // invariant over 'b and B\n-    c: *const C,  // covariant over C\n+    c: *const C,  // variant over C\n     d: *mut D,    // invariant over D\n-    e: Vec<E>,    // covariant over E\n+    e: Vec<E>,    // variant over E\n     f: Cell<F>,   // invariant over F\n-    g: G          // covariant over G\n-    h1: H         // would also be covariant over H except...\n+    g: G          // variant over G\n+    h1: H         // would also be variant over H except...\n     h2: Cell<H>   // invariant over H, because invariance wins\n }\n ```\n@@ -497,8 +474,9 @@ correct variance and drop checking.\n \n We do this using *PhantomData*, which is a special marker type. PhantomData\n consumes no space, but simulates a field of the given type for the purpose of\n-variance. This was deemed to be less error-prone than explicitly telling the\n-type-system the kind of variance that you want.\n+static analysis. This was deemed to be less error-prone than explicitly telling\n+the type-system the kind of variance that you want, while also providing other\n+useful information.\n \n Iter logically contains `&'a T`, so this is exactly what we tell\n the PhantomData to simulate:\n@@ -526,16 +504,16 @@ However the one exception is with PhantomData. Given a struct like Vec:\n \n ```\n struct Vec<T> {\n-    data: *const T, // *const for covariance!\n+    data: *const T, // *const for variance!\n     len: usize,\n     cap: usize,\n }\n ```\n \n-dropck will generously determine that Vec<T> does not contain any values of\n+dropck will generously determine that Vec<T> does not own any values of\n type T. This will unfortunately allow people to construct unsound Drop\n implementations that access data that has already been dropped. In order to\n-tell dropck that we *do* own values of type T and may call destructors of that\n+tell dropck that we *do* own values of type T, and may call destructors of that\n type, we must add extra PhantomData:\n \n ```\n@@ -700,3 +678,56 @@ Bar is *also* live. Since IterMut is always live when `next` can be called, if\n to it exist!\n \n \n+\n+\n+\n+# Weird Lifetimes\n+\n+Given the following code:\n+\n+```rust\n+struct Foo;\n+\n+impl Foo {\n+    fn mutate_and_share(&mut self) -> &Self { &*self }\n+    fn share(&self) {}\n+}\n+\n+fn main() {\n+    let mut foo = Foo;\n+    let loan = foo.mutate_and_share();\n+    foo.share();\n+}\n+```\n+\n+One might expect it to compile. We call `mutate_and_share`, which mutably borrows\n+`foo` *temporarily*, but then returns *only* a shared reference. Therefore we\n+would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.\n+\n+However when we try to compile it:\n+\n+```text\n+<anon>:11:5: 11:8 error: cannot borrow `foo` as immutable because it is also borrowed as mutable\n+<anon>:11     foo.share();\n+              ^~~\n+<anon>:10:16: 10:19 note: previous borrow of `foo` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `foo` until the borrow ends\n+<anon>:10     let loan = foo.mutate_and_share();\n+                         ^~~\n+<anon>:12:2: 12:2 note: previous borrow ends here\n+<anon>:8 fn main() {\n+<anon>:9     let mut foo = Foo;\n+<anon>:10     let loan = foo.mutate_and_share();\n+<anon>:11     foo.share();\n+<anon>:12 }\n+          ^\n+```\n+\n+What happened? Well, the lifetime of `loan` is derived from a *mutable* borrow.\n+This makes the type system believe that `foo` is mutably borrowed as long as\n+`loan` exists, even though it's a shared reference. This isn't a bug, although\n+one could argue it is a limitation of the design. In particular, to know if\n+the mutable part of the borrow is *really* expired we'd have to peek into\n+implementation details of the function. Currently, type-checking a function\n+does not need to inspect the bodies of any other functions or types.\n+\n+"}]}