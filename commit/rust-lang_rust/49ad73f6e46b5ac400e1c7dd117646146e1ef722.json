{"sha": "49ad73f6e46b5ac400e1c7dd117646146e1ef722", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YWQ3M2Y2ZTQ2YjVhYzQwMGUxYzdkZDExNzY0NjE0NmUxZWY3MjI=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-17T17:55:59Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-18T09:07:13Z"}, "message": "consts: minor improvements", "tree": {"sha": "f24a5ec71d22ac2fd4b69e06fcf986e9f83af108", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f24a5ec71d22ac2fd4b69e06fcf986e9f83af108"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49ad73f6e46b5ac400e1c7dd117646146e1ef722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49ad73f6e46b5ac400e1c7dd117646146e1ef722", "html_url": "https://github.com/rust-lang/rust/commit/49ad73f6e46b5ac400e1c7dd117646146e1ef722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49ad73f6e46b5ac400e1c7dd117646146e1ef722/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a9e03dd9f8a5efbb4bd134a135aab6dd11c8dce", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a9e03dd9f8a5efbb4bd134a135aab6dd11c8dce", "html_url": "https://github.com/rust-lang/rust/commit/8a9e03dd9f8a5efbb4bd134a135aab6dd11c8dce"}], "stats": {"total": 76, "additions": 31, "deletions": 45}, "files": [{"sha": "07bde1d0b0801e0274c9f873cc1c129d6c480f2e", "filename": "src/consts.rs", "status": "modified", "additions": 31, "deletions": 45, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/49ad73f6e46b5ac400e1c7dd117646146e1ef722/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ad73f6e46b5ac400e1c7dd117646146e1ef722/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=49ad73f6e46b5ac400e1c7dd117646146e1ef722", "patch": "@@ -59,7 +59,7 @@ impl Constant {\n     ///\n     /// if the constant could not be converted to u64 losslessly\n     fn as_u64(&self) -> u64 {\n-        if let &ConstantInt(val, _) = self {\n+        if let ConstantInt(val, _) = *self {\n             val // TODO we may want to check the sign if any\n         } else {\n             panic!(\"Could not convert a {:?} to u64\");\n@@ -149,15 +149,15 @@ impl PartialOrd for Constant {\n \n \n fn lit_to_constant(lit: &Lit_) -> Constant {\n-    match lit {\n-        &LitStr(ref is, style) => ConstantStr(is.to_string(), style),\n-        &LitBinary(ref blob) => ConstantBinary(blob.clone()),\n-        &LitByte(b) => ConstantByte(b),\n-        &LitChar(c) => ConstantChar(c),\n-        &LitInt(value, ty) => ConstantInt(value, ty),\n-        &LitFloat(ref is, ty) => ConstantFloat(is.to_string(), ty.into()),\n-        &LitFloatUnsuffixed(ref is) => ConstantFloat(is.to_string(), FwAny),\n-        &LitBool(b) => ConstantBool(b),\n+    match *lit {\n+        LitStr(ref is, style) => ConstantStr(is.to_string(), style),\n+        LitBinary(ref blob) => ConstantBinary(blob.clone()),\n+        LitByte(b) => ConstantByte(b),\n+        LitChar(c) => ConstantChar(c),\n+        LitInt(value, ty) => ConstantInt(value, ty),\n+        LitFloat(ref is, ty) => ConstantFloat(is.to_string(), ty.into()),\n+        LitFloatUnsuffixed(ref is) => ConstantFloat(is.to_string(), FwAny),\n+        LitBool(b) => ConstantBool(b),\n     }\n }\n \n@@ -293,25 +293,25 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n \n     /// simple constant folding: Insert an expression, get a constant or none.\n     fn expr(&mut self, e: &Expr) -> Option<Constant> {\n-        match &e.node {\n-            &ExprParen(ref inner) => self.expr(inner),\n-            &ExprPath(_, _) => self.fetch_path(e),\n-            &ExprBlock(ref block) => self.block(block),\n-            &ExprIf(ref cond, ref then, ref otherwise) =>\n+        match e.node {\n+            ExprParen(ref inner) => self.expr(inner),\n+            ExprPath(_, _) => self.fetch_path(e),\n+            ExprBlock(ref block) => self.block(block),\n+            ExprIf(ref cond, ref then, ref otherwise) =>\n                 self.ifthenelse(&*cond, &*then, &*otherwise),\n-            &ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n-            &ExprVec(ref vec) => self.vec(&vec[..]),\n-            &ExprTup(ref tup) => self.tup(&tup[..]),\n-            &ExprRepeat(ref value, ref number) =>\n-                self.binop_apply(value, number,|v, n|\n+            ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n+            ExprVec(ref vec) => self.vec(&vec),\n+            ExprTup(ref tup) => self.tup(&tup),\n+            ExprRepeat(ref value, ref number) =>\n+                self.binop_apply(value, number, |v, n|\n                     Some(ConstantRepeat(Box::new(v), n.as_u64() as usize))),\n-            &ExprUnary(op, ref operand) => self.expr(operand).and_then(\n+            ExprUnary(op, ref operand) => self.expr(operand).and_then(\n                 |o| match op {\n                     UnNot => constant_not(o),\n                     UnNeg => constant_negate(o),\n                     UnUniq | UnDeref => Some(o),\n                 }),\n-            &ExprBinary(op, ref left, ref right) =>\n+            ExprBinary(op, ref left, ref right) =>\n                 self.binop(op, left, right),\n             //TODO: add other expressions\n             _ => None,\n@@ -321,29 +321,15 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n     /// create `Some(ConstantVec(..))` of all constants, unless there is any\n     /// non-constant part\n     fn vec<E: Deref<Target=Expr> + Sized>(&mut self, vec: &[E]) -> Option<Constant> {\n-        let mut parts = Vec::new();\n-        for opt_part in vec {\n-            match self.expr(opt_part) {\n-                Some(p) => {\n-                    parts.push(p)\n-                },\n-                None => { return None; },\n-            }\n-        }\n-        Some(ConstantVec(parts))\n+        vec.iter().map(|elem| self.expr(elem))\n+                  .collect::<Option<_>>()\n+                  .map(ConstantVec)\n     }\n \n     fn tup<E: Deref<Target=Expr> + Sized>(&mut self, tup: &[E]) -> Option<Constant> {\n-        let mut parts = Vec::new();\n-        for opt_part in tup {\n-            match self.expr(opt_part) {\n-                Some(p) => {\n-                    parts.push(p)\n-                },\n-                None => { return None; },\n-            }\n-        }\n-        Some(ConstantTuple(parts),)\n+        tup.iter().map(|elem| self.expr(elem))\n+                  .collect::<Option<_>>()\n+                  .map(ConstantTuple)\n     }\n \n     /// lookup a possibly constant expression from a ExprPath\n@@ -366,7 +352,7 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n     /// A block can only yield a constant if it only has one constant expression\n     fn block(&mut self, block: &Block) -> Option<Constant> {\n         if block.stmts.is_empty() {\n-            block.expr.as_ref().and_then(|b| self.expr(&*b))\n+            block.expr.as_ref().and_then(|ref b| self.expr(b))\n         } else { None }\n     }\n \n@@ -376,7 +362,7 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n             if b {\n                 self.block(then)\n             } else {\n-                otherwise.as_ref().and_then(|expr| self.expr(&*expr))\n+                otherwise.as_ref().and_then(|ref expr| self.expr(expr))\n             }\n         } else { None }\n     }\n@@ -472,7 +458,7 @@ impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n \n     fn short_circuit(&mut self, left: &Expr, right: &Expr, b: bool) -> Option<Constant> {\n         self.expr(left).and_then(|left|\n-            if let &ConstantBool(lbool) = &left {\n+            if let ConstantBool(lbool) = left {\n                 if lbool == b {\n                     Some(left)\n                 } else {"}]}