{"sha": "7f5e0441e2246451e3b03ac907c4308d071e99fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNWUwNDQxZTIyNDY0NTFlM2IwM2FjOTA3YzQzMDhkMDcxZTk5ZmQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-17T19:24:48Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-17T19:58:11Z"}, "message": "`ConstantValue` is the only other ctor allowed when subtracting from slice ctors", "tree": {"sha": "69e5eb0ef6f2924cdb0ae06bd39cd3806c374d54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69e5eb0ef6f2924cdb0ae06bd39cd3806c374d54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f5e0441e2246451e3b03ac907c4308d071e99fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5e0441e2246451e3b03ac907c4308d071e99fd", "html_url": "https://github.com/rust-lang/rust/commit/7f5e0441e2246451e3b03ac907c4308d071e99fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f5e0441e2246451e3b03ac907c4308d071e99fd/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd0e3ccd0bf81b57f115b344dcf424a3ed626cab", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0e3ccd0bf81b57f115b344dcf424a3ed626cab", "html_url": "https://github.com/rust-lang/rust/commit/bd0e3ccd0bf81b57f115b344dcf424a3ed626cab"}], "stats": {"total": 72, "additions": 39, "deletions": 33}, "files": [{"sha": "a6afea228818c680c2c716953af6f79179669d2a", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7f5e0441e2246451e3b03ac907c4308d071e99fd/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5e0441e2246451e3b03ac907c4308d071e99fd/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=7f5e0441e2246451e3b03ac907c4308d071e99fd", "patch": "@@ -742,44 +742,50 @@ impl<'tcx> Constructor<'tcx> {\n             Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n-            &Slice(slice) => match slice.value_kind() {\n-                FixedLen(self_len) => {\n-                    let overlaps = |c: &Constructor<'_>| match *c {\n-                        Slice(other_slice) => other_slice.value_kind().covers_length(self_len),\n-                        _ => false,\n-                    };\n-                    if other_ctors.iter().any(overlaps) { vec![] } else { vec![Slice(slice)] }\n-                }\n-                VarLen(..) => {\n-                    let mut remaining_slices = vec![slice.value_kind()];\n-\n-                    // For each used slice, subtract from the current set of slices.\n-                    for other_ctor in other_ctors {\n-                        let other_slice = match other_ctor {\n-                            Slice(slice) => slice.value_kind(),\n-                            // FIXME(#65413): If `other_ctor` is not a slice, we assume it doesn't\n-                            // cover any value here.\n-                            _ => continue,\n-                        };\n-                        remaining_slices = remaining_slices\n-                            .into_iter()\n-                            .flat_map(|remaining_slice| remaining_slice.subtract(other_slice))\n-                            .collect();\n+            &Slice(slice) => {\n+                let mut other_slices = other_ctors\n+                    .iter()\n+                    .filter_map(|c: &Constructor<'_>| match c {\n+                        Slice(slice) => Some(*slice),\n+                        // FIXME(#65413): We ignore `ConstantValue`s here.\n+                        ConstantValue(..) => None,\n+                        _ => bug!(\"bad slice pattern constructor {:?}\", c),\n+                    })\n+                    .map(Slice::value_kind);\n \n-                        // If the constructors that have been considered so far already cover\n-                        // the entire range of `self`, no need to look at more constructors.\n-                        if remaining_slices.is_empty() {\n-                            break;\n+                match slice.value_kind() {\n+                    FixedLen(self_len) => {\n+                        if other_slices.any(|other_slice| other_slice.covers_length(self_len)) {\n+                            vec![]\n+                        } else {\n+                            vec![Slice(slice)]\n                         }\n                     }\n+                    kind @ VarLen(..) => {\n+                        let mut remaining_slices = vec![kind];\n+\n+                        // For each used slice, subtract from the current set of slices.\n+                        for other_slice in other_slices {\n+                            remaining_slices = remaining_slices\n+                                .into_iter()\n+                                .flat_map(|remaining_slice| remaining_slice.subtract(other_slice))\n+                                .collect();\n+\n+                            // If the constructors that have been considered so far already cover\n+                            // the entire range of `self`, no need to look at more constructors.\n+                            if remaining_slices.is_empty() {\n+                                break;\n+                            }\n+                        }\n \n-                    remaining_slices\n-                        .into_iter()\n-                        .map(|kind| Slice { array_len: slice.array_len, kind })\n-                        .map(Slice)\n-                        .collect()\n+                        remaining_slices\n+                            .into_iter()\n+                            .map(|kind| Slice { array_len: slice.array_len, kind })\n+                            .map(Slice)\n+                            .collect()\n+                    }\n                 }\n-            },\n+            }\n             IntRange(self_range) => {\n                 let mut remaining_ranges = vec![self_range.clone()];\n                 for other_ctor in other_ctors {"}]}