{"sha": "85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YmE4MTc4ZTJlOTk1YzBkYTZlYjkyNjg2MTJiYWNhOGE2YmEyZTM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-15T07:46:12Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-15T16:51:15Z"}, "message": "rustc: implement fully qualified UFCS expressions.", "tree": {"sha": "84335c40ee3bd03d89f14d22a8d60c479a0d2c51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84335c40ee3bd03d89f14d22a8d60c479a0d2c51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "html_url": "https://github.com/rust-lang/rust/commit/85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b51026e09cd749393eddec31179a8f940b4e595c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b51026e09cd749393eddec31179a8f940b4e595c", "html_url": "https://github.com/rust-lang/rust/commit/b51026e09cd749393eddec31179a8f940b4e595c"}], "stats": {"total": 168, "additions": 130, "deletions": 38}, "files": [{"sha": "7743a437858d2e97d3b4a350b8d81dfc7a750d4a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "patch": "@@ -61,7 +61,7 @@ use rustc::util::lev_distance::lev_distance;\n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n-use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n+use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n@@ -3169,7 +3169,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     TraitImplementation        => \"implement\",\n                     TraitDerivation            => \"derive\",\n                     TraitObject                => \"reference\",\n-                    TraitQPath                 => \"extract an associated type from\",\n+                    TraitQPath                 => \"extract an associated item from\",\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n@@ -3565,31 +3565,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                match result_def {\n-                    None => {\n-                        match self.resolve_path(ty.id, path, TypeNS, true) {\n-                            Some(def) => {\n-                                debug!(\"(resolving type) resolved `{:?}` to \\\n-                                        type {:?}\",\n-                                       token::get_ident(path.segments.last().unwrap() .identifier),\n-                                       def);\n-                                result_def = Some(def);\n-                            }\n-                            None => {\n-                                result_def = None;\n-                            }\n-                        }\n-                    }\n-                    Some(_) => {}   // Continue.\n+                if let None = result_def {\n+                    result_def = self.resolve_path(ty.id, path, TypeNS, true);\n                 }\n \n                 match result_def {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n-                                (id {})\",\n+                                (id {}) = {:?}\",\n                                self.path_names_to_string(path),\n-                               path_id);\n+                               path_id, def);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n@@ -3609,6 +3595,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             TyQPath(ref qpath) => {\n                 self.resolve_type(&*qpath.self_type);\n                 self.resolve_trait_reference(ty.id, &*qpath.trait_ref, TraitQPath);\n+                for ty in qpath.item_path.parameters.types().into_iter() {\n+                    self.resolve_type(&**ty);\n+                }\n+                for binding in qpath.item_path.parameters.bindings().into_iter() {\n+                    self.resolve_type(&*binding.ty);\n+                }\n             }\n \n             TyPolyTraitRef(ref bounds) => {\n@@ -4400,15 +4392,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // The interpretation of paths depends on whether the path has\n             // multiple elements in it or not.\n \n-            ExprPath(ref path) => {\n+            ExprPath(_) | ExprQPath(_) => {\n+                let mut path_from_qpath;\n+                let path = match expr.node {\n+                    ExprPath(ref path) => path,\n+                    ExprQPath(ref qpath) => {\n+                        self.resolve_type(&*qpath.self_type);\n+                        self.resolve_trait_reference(expr.id, &*qpath.trait_ref, TraitQPath);\n+                        path_from_qpath = qpath.trait_ref.path.clone();\n+                        path_from_qpath.segments.push(qpath.item_path.clone());\n+                        &path_from_qpath\n+                    }\n+                    _ => unreachable!()\n+                };\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n-\n-                let path_name = self.path_names_to_string(path);\n-\n                 match self.resolve_path(expr.id, path, ValueNS, true) {\n                     // Check if struct variant\n                     Some((DefVariant(_, _, true), _)) => {\n+                        let path_name = self.path_names_to_string(path);\n                         self.resolve_error(expr.span,\n                                 format!(\"`{}` is a struct variant name, but \\\n                                          this expression \\\n@@ -4423,7 +4425,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n-                               path_name);\n+                               self.path_names_to_string(path));\n \n                         self.record_def(expr.id, def);\n                     }\n@@ -4432,6 +4434,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // (The pattern matching def_tys where the id is in self.structs\n                         // matches on regular structs while excluding tuple- and enum-like\n                         // structs, which wouldn't result in this error.)\n+                        let path_name = self.path_names_to_string(path);\n                         match self.with_no_errors(|this|\n                             this.resolve_path(expr.id, path, TypeNS, false)) {\n                             Some((DefTy(struct_id, _), _))"}, {"sha": "f2a67029170b756df54a1f049aa44ff60783fe71", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "patch": "@@ -767,7 +767,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     span: Span,\n                     path: &ast::Path,\n                     ref_kind: Option<recorder::Row>) {\n-        if generated_code(path.span) {\n+        if generated_code(span) {\n             return\n         }\n \n@@ -1307,9 +1307,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 visit::walk_expr(self, ex);\n             },\n             ast::ExprPath(ref path) => {\n-                self.process_path(ex.id, ex.span, path, None);\n+                self.process_path(ex.id, path.span, path, None);\n                 visit::walk_path(self, path);\n             }\n+            ast::ExprQPath(ref qpath) => {\n+                let mut path = qpath.trait_ref.path.clone();\n+                path.segments.push(qpath.item_path.clone());\n+                self.process_path(ex.id, ex.span, &path, None);\n+                visit::walk_qpath(self, ex.span, &**qpath);\n+            }\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n@@ -1439,7 +1445,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           \"\")\n                 }\n                 def::DefVariant(..) => {\n-                    paths_to_process.push((id, p.span, p.clone(), Some(ref_kind)))\n+                    paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 // FIXME(nrc) what are these doing here?\n                 def::DefStatic(_, _) => {}\n@@ -1448,8 +1454,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                             *def)\n             }\n         }\n-        for &(id, span, ref path, ref_kind) in paths_to_process.iter() {\n-            self.process_path(id, span, path, ref_kind);\n+        for &(id, ref path, ref_kind) in paths_to_process.iter() {\n+            self.process_path(id, path.span, path, ref_kind);\n         }\n         self.collecting = false;\n         self.collected_paths.clear();"}, {"sha": "47346592c86bb859220ba8186d4470cf6002952b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "patch": "@@ -467,7 +467,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n     };\n \n     instantiate_path(pcx.fcx, path, ty::lookup_item_type(tcx, enum_def_id),\n-                     def, pat.span, pat.id);\n+                     None, def, pat.span, pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n@@ -505,7 +505,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, path, path_scheme, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx, path, path_scheme, None, def, pat.span, pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "e4c333a0e1ea593a96f2591ff651c4d6401b63e0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "patch": "@@ -3553,10 +3553,25 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::ExprPath(ref pth) => {\n-          let defn = lookup_def(fcx, pth.span, id);\n+      ast::ExprPath(ref path) => {\n+          let defn = lookup_def(fcx, path.span, id);\n           let pty = type_scheme_for_def(fcx, expr.span, defn);\n-          instantiate_path(fcx, pth, pty, defn, expr.span, expr.id);\n+          instantiate_path(fcx, path, pty, None, defn, expr.span, expr.id);\n+\n+          // We always require that the type provided as the value for\n+          // a type parameter outlives the moment of instantiation.\n+          constrain_path_type_parameters(fcx, expr);\n+      }\n+      ast::ExprQPath(ref qpath) => {\n+          // Require explicit type params for the trait.\n+          let self_ty = fcx.to_ty(&*qpath.self_type);\n+          astconv::instantiate_trait_ref(fcx, fcx, &*qpath.trait_ref, Some(self_ty), None);\n+\n+          let defn = lookup_def(fcx, expr.span, id);\n+          let pty = type_scheme_for_def(fcx, expr.span, defn);\n+          let mut path = qpath.trait_ref.path.clone();\n+          path.segments.push(qpath.item_path.clone());\n+          instantiate_path(fcx, &path, pty, Some(self_ty), defn, expr.span, expr.id);\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n@@ -4619,6 +4634,7 @@ pub fn type_scheme_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   path: &ast::Path,\n                                   type_scheme: TypeScheme<'tcx>,\n+                                  opt_self_ty: Option<Ty<'tcx>>,\n                                   def: def::Def,\n                                   span: Span,\n                                   node_id: ast::NodeId) {\n@@ -4776,6 +4792,11 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n     }\n+    if let Some(self_ty) = opt_self_ty {\n+        // `<T as Trait>::foo` shouldn't have resolved to a `Self`-less item.\n+        assert_eq!(type_defs.len(subst::SelfSpace), 1);\n+        substs.types.push(subst::SelfSpace, self_ty);\n+    }\n \n     // Now we have to compare the types that the user *actually*\n     // provided against the types that were *expected*. If the user"}, {"sha": "5fa66eb98e1af47f33625facccae8107559e1f47", "filename": "src/test/compile-fail/ufcs-qpath-missing-params.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs?ref=85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::borrow::IntoCow;\n+\n+fn main() {\n+    <String as IntoCow>::into_cow(\"foo\".to_string());\n+    //~^ ERROR wrong number of type arguments: expected 2, found 0\n+}\n+"}, {"sha": "868c1eae4a9e1fd80c868847aba8e576885c8f29", "filename": "src/test/compile-fail/ufcs-qpath-self-mismatch.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-self-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-self-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-self-mismatch.rs?ref=85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Add;\n+\n+fn main() {\n+    <i32 as Add<u32>>::add(1, 2);\n+    //~^ ERROR the trait `core::ops::Add<u32>` is not implemented for the type `i32`\n+    <i32 as Add<i32>>::add(1u32, 2);\n+    //~^ ERROR mismatched types\n+    <i32 as Add<i32>>::add(1, 2u32);\n+    //~^ ERROR mismatched types\n+}\n+"}, {"sha": "f8f92a56adb1a687c65033f37c1747f13b9a74d0", "filename": "src/test/run-pass/const-polymorphic-paths.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ba8178e2e995c0da6eb9268612baca8a6ba2e3/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs?ref=85ba8178e2e995c0da6eb9268612baca8a6ba2e3", "patch": "@@ -10,9 +10,11 @@\n \n #![feature(macro_rules)]\n \n+use std::borrow::{Cow, IntoCow};\n use std::collections::Bitv;\n use std::default::Default;\n use std::iter::FromIterator;\n+use std::ops::Add;\n use std::option::IntoIter as OptionIter;\n use std::rand::Rand;\n use std::rand::XorShiftRng as DummyRng;\n@@ -28,6 +30,11 @@ fn u8_as_i8(x: u8) -> i8 { x as i8 }\n fn odd(x: uint) -> bool { x % 2 == 1 }\n fn dummy_rng() -> DummyRng { DummyRng::new_unseeded() }\n \n+trait Size: Sized {\n+    fn size() -> uint { std::mem::size_of::<Self>() }\n+}\n+impl<T> Size for T {}\n+\n macro_rules! tests {\n     ($($expr:expr, $ty:ty, ($($test:expr),*);)+) => (pub fn main() {$({\n         const C: $ty = $expr;\n@@ -70,14 +77,31 @@ tests! {\n     //    , (vec![b'f', b'o', b'o'], u8_as_i8);\n \n     // Trait static methods.\n-    // FIXME qualified path expressions aka UFCS i.e. <T as Trait>::method.\n+    <bool as Size>::size, fn() -> uint, ();\n     Default::default, fn() -> int, ();\n+    <int as Default>::default, fn() -> int, ();\n     Rand::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n+    <int as Rand>::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n     Rand::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n+    <int as Rand>::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n \n     // Trait non-static methods.\n     Clone::clone, fn(&int) -> int, (&5);\n+    <int as Clone>::clone, fn(&int) -> int, (&5);\n     FromIterator::from_iter, fn(OptionIter<int>) -> Vec<int>, (Some(5).into_iter());\n-    FromIterator::from_iter::<OptionIter<int>>, fn(OptionIter<int>) -> Vec<int>\n-       , (Some(5).into_iter());\n+    <Vec<_> as FromIterator<_>>::from_iter, fn(OptionIter<int>) -> Vec<int>,\n+        (Some(5).into_iter());\n+    <Vec<int> as FromIterator<_>>::from_iter, fn(OptionIter<int>) -> Vec<int>,\n+        (Some(5).into_iter());\n+    FromIterator::from_iter::<OptionIter<int>>, fn(OptionIter<int>) -> Vec<int>,\n+        (Some(5).into_iter());\n+    <Vec<int> as FromIterator<_>>::from_iter::<OptionIter<int>>, fn(OptionIter<int>) -> Vec<int>,\n+        (Some(5).into_iter());\n+    Add::add, fn(i32, i32) -> i32, (5, 6);\n+    <i32 as Add<_>>::add, fn(i32, i32) -> i32, (5, 6);\n+    <i32 as Add<i32>>::add, fn(i32, i32) -> i32, (5, 6);\n+    <String as IntoCow<_, _>>::into_cow, fn(String) -> Cow<'static, String, str>,\n+        (\"foo\".to_string());\n+    <String as IntoCow<'static, _, _>>::into_cow, fn(String) -> Cow<'static, String, str>,\n+        (\"foo\".to_string());\n }"}]}