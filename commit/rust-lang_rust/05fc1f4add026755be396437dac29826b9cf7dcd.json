{"sha": "05fc1f4add026755be396437dac29826b9cf7dcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZmMxZjRhZGQwMjY3NTViZTM5NjQzN2RhYzI5ODI2YjljZjdkY2Q=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-07-03T15:34:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-03T15:34:31Z"}, "message": "Merge pull request #1058 from bjorn3/misc_rustc_test_suite_fixes\n\nMisc rustc test suite fixes", "tree": {"sha": "95db9fbd805b7a0644727266af66383a7125b44e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95db9fbd805b7a0644727266af66383a7125b44e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05fc1f4add026755be396437dac29826b9cf7dcd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/1AHCRBK7hj4Ov3rIwAAdHIIALATsvH+OnpO7vx+SJSy+OxC\nBjohi3k93l0EYINxJchg3HJOQHzBlZRHpxQ2n+jt5HI/P/rAelnRsj+pGNkhuuQv\nmsdvtWuwFCuFHWEPXuAywlOmfE6M6Aazx15vjn/EWqcGoUzj6zg+QfDWY1Q6TzUf\nQYGutNOv1Nb7Lop6qsb+NlIkdSTx96TGhocmFaVXy/8IkHX5SiWtoQHmBZmj1sLh\nomGoAxNmVggRKl4Lfree1B2YX0XSVyCcgyHjdp/BTDptcbbmrLtNcz8//GL/qCa1\nEaqecTi8O1x1wwer+5+M6j0mxBSiXbk2C2NOoaQzWlaLNFpnxxDxOY+lXdVeA28=\n=YMFO\n-----END PGP SIGNATURE-----\n", "payload": "tree 95db9fbd805b7a0644727266af66383a7125b44e\nparent d032c24476fed9db7ccd2b733e2e9c1a90c17b3e\nparent 6345e4a1bcee38c42ee5817426beda78f43431ca\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1593790471 +0200\ncommitter GitHub <noreply@github.com> 1593790471 +0200\n\nMerge pull request #1058 from bjorn3/misc_rustc_test_suite_fixes\n\nMisc rustc test suite fixes"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05fc1f4add026755be396437dac29826b9cf7dcd", "html_url": "https://github.com/rust-lang/rust/commit/05fc1f4add026755be396437dac29826b9cf7dcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05fc1f4add026755be396437dac29826b9cf7dcd/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "html_url": "https://github.com/rust-lang/rust/commit/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e"}, {"sha": "6345e4a1bcee38c42ee5817426beda78f43431ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/6345e4a1bcee38c42ee5817426beda78f43431ca", "html_url": "https://github.com/rust-lang/rust/commit/6345e4a1bcee38c42ee5817426beda78f43431ca"}], "stats": {"total": 121, "additions": 107, "deletions": 14}, "files": [{"sha": "61595e97730f40c40c5733fcbe12619da8517d94", "filename": "Readme.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05fc1f4add026755be396437dac29826b9cf7dcd/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/05fc1f4add026755be396437dac29826b9cf7dcd/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=05fc1f4add026755be396437dac29826b9cf7dcd", "patch": "@@ -69,7 +69,7 @@ function jit_calc() {\n     to make it possible to use incremental mode for all analyses performed by rustc without caching\n     object files when their content should have been changed by a change to cg_clif.</dd>\n     <dt>CG_CLIF_DISPLAY_CG_TIME</dt>\n-    <dd>Display the time it took to perform codegen for a crate</dd>\n+    <dd>If \"1\", display the time it took to perform codegen for a crate</dd>\n </dl>\n \n ## Not yet supported"}, {"sha": "0c8fa8c0ba970f590b17728ec1b4814123134e68", "filename": "example/std_example.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05fc1f4add026755be396437dac29826b9cf7dcd/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05fc1f4add026755be396437dac29826b9cf7dcd/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=05fc1f4add026755be396437dac29826b9cf7dcd", "patch": "@@ -103,6 +103,14 @@ fn main() {\n     Box::pin(move |mut _task_context| {\n         yield ();\n     }).as_mut().resume(0);\n+\n+    #[derive(Copy, Clone)]\n+    enum Nums {\n+        NegOne = -1,\n+    }\n+\n+    let kind = Nums::NegOne;\n+    assert_eq!(-1i128, kind as i128);\n }\n \n #[target_feature(enable = \"sse2\")]"}, {"sha": "053f6e81d5ee717a6abf17f315ebaebc5ae07e70", "filename": "src/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=05fc1f4add026755be396437dac29826b9cf7dcd", "patch": "@@ -689,6 +689,9 @@ fn trans_stmt<'tcx>(\n                 asm_str_style: _,\n             } = asm;\n             match &*asm_code.as_str() {\n+                \"\" => {\n+                    // Black box\n+                }\n                 cpuid if cpuid.contains(\"cpuid\") => {\n                     crate::trap::trap_unimplemented(\n                         fx,"}, {"sha": "9a60b1e6a33c0a8c70e12a27ce7a8d48ecef0b39", "filename": "src/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=05fc1f4add026755be396437dac29826b9cf7dcd", "patch": "@@ -109,7 +109,7 @@ fn trans_mono_item<'tcx, B: Backend + 'static>(\n }\n \n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").is_ok() {\n+    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").as_ref().map(|val| &**val) == Ok(\"1\") {\n         println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n         let before = std::time::Instant::now();\n         let res = tcx.sess.time(name, f);"}, {"sha": "d93da0fb0873a556b11b9c9c91c293ec86bfce5d", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 65, "deletions": 12, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=05fc1f4add026755be396437dac29826b9cf7dcd", "patch": "@@ -138,6 +138,27 @@ macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $\n     crate::atomic_shim::unlock_global_lock($fx);\n }\n \n+macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n+    match $ty.kind {\n+        ty::Uint(_) | ty::Int(_) => {}\n+        _ => {\n+            $fx.tcx.sess.span_err($span, &format!(\"`{}` intrinsic: expected basic integer type, found `{:?}`\", $intrinsic, $ty));\n+            // Prevent verifier error\n+            crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n+            return;\n+        }\n+    }\n+}\n+\n+macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n+    if !$ty.is_simd() {\n+        $fx.tcx.sess.span_err($span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", $intrinsic, $ty));\n+        // Prevent verifier error\n+        crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n+        return;\n+    }\n+}\n+\n fn lane_type_and_count<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     layout: TyAndLayout<'tcx>,\n@@ -817,7 +838,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             dest.write_cvalue(fx, val);\n         };\n \n-        size_of | pref_align_of | min_align_of | needs_drop | type_id | type_name, () {\n+        size_of | pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n             let const_val =\n                 fx.tcx.const_eval_instance(ParamEnv::reveal_all(), instance, None).unwrap();\n             let val = crate::constant::trans_const_value(\n@@ -866,12 +887,15 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             let inner_layout =\n                 fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n+            validate_atomic_type!(fx, intrinsic, span, inner_layout.ty);\n             let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n             ret.write_cvalue(fx, val);\n \n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n+            validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n+\n             crate::atomic_shim::lock_global_lock(fx);\n \n             let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n@@ -880,6 +904,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n         _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n             crate::atomic_shim::lock_global_lock(fx);\n \n             // Read old\n@@ -893,7 +919,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, v test_old, v new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n+            let test_old = test_old.load_scalar(fx);\n+            let new = new.load_scalar(fx);\n+\n             crate::atomic_shim::lock_global_lock(fx);\n \n             // Read old\n@@ -913,16 +944,26 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, v amount) {\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, c amount) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let amount = amount.load_scalar(fx);\n             atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, v amount) {\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, c amount) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let amount = amount.load_scalar(fx);\n             atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+\n+            let src = src.load_scalar(fx);\n+\n             crate::atomic_shim::lock_global_lock(fx);\n \n             let clif_ty = fx.clif_type(T).unwrap();\n@@ -934,23 +975,35 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             crate::atomic_shim::unlock_global_lock(fx);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, v src) {\n+        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, c src) {\n+            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+            let src = src.load_scalar(fx);\n             atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n         };\n "}, {"sha": "32f561bdd3631e4988f185435d0fe2ee875a89c6", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=05fc1f4add026755be396437dac29826b9cf7dcd", "patch": "@@ -21,6 +21,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_cast, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n             simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n                 let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n \n@@ -33,26 +34,34 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_eq, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, Equal(x, y) -> ret);\n         };\n         simd_ne, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, NotEqual(x, y) -> ret);\n         };\n         simd_lt, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, UnsignedLessThan|SignedLessThan(x, y) -> ret);\n         };\n         simd_le, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, UnsignedLessThanOrEqual|SignedLessThanOrEqual(x, y) -> ret);\n         };\n         simd_gt, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, UnsignedGreaterThan|SignedGreaterThan(x, y) -> ret);\n         };\n         simd_ge, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_cmp!(fx, UnsignedGreaterThanOrEqual|SignedGreaterThanOrEqual(x, y) -> ret);\n         };\n \n         // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n         _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+\n             let n: u16 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n \n             assert_eq!(x.layout(), y.layout());\n@@ -105,6 +114,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_insert, (c base, o idx, v _val) {\n+            // FIXME validate\n             let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n                 idx_const\n             } else {\n@@ -132,6 +142,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_extract, (c v, o idx) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n             let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n                 idx_const\n             } else {\n@@ -155,34 +166,44 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_add, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, iadd|fadd(x, y) -> ret);\n         };\n         simd_sub, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, isub|fsub(x, y) -> ret);\n         };\n         simd_mul, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, imul|fmul(x, y) -> ret);\n         };\n         simd_div, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, udiv|sdiv|fdiv(x, y) -> ret);\n         };\n         simd_shl, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, ishl(x, y) -> ret);\n         };\n         simd_shr, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, ushr|sshr(x, y) -> ret);\n         };\n         simd_and, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, band(x, y) -> ret);\n         };\n         simd_or, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, bor(x, y) -> ret);\n         };\n         simd_xor, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, bxor(x, y) -> ret);\n         };\n \n         simd_fma, (c a, c b, c c) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n             assert_eq!(a.layout(), b.layout());\n             assert_eq!(a.layout(), c.layout());\n             let layout = a.layout();\n@@ -205,9 +226,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_fmin, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_flt_binop!(fx, fmin(x, y) -> ret);\n         };\n         simd_fmax, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_flt_binop!(fx, fmax(x, y) -> ret);\n         };\n     }"}, {"sha": "b1e624d87f047b52153c02ef8bc94f87ef208143", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=05fc1f4add026755be396437dac29826b9cf7dcd", "patch": "@@ -234,6 +234,8 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorReported> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n+        sess.abort_if_errors();\n+\n         let codegen_results = *res\n             .downcast::<CodegenResults>()\n             .expect(\"Expected CraneliftCodegenBackend's CodegenResult, found Box<Any>\");"}, {"sha": "c9516a98bfe446c84b6bbf7363d1f6179247c1d5", "filename": "src/value_and_place.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05fc1f4add026755be396437dac29826b9cf7dcd/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=05fc1f4add026755be396437dac29826b9cf7dcd", "patch": "@@ -406,6 +406,10 @@ impl<'tcx> CPlace<'tcx> {\n             to_ty: Ty<'tcx>,\n         ) {\n             match (&from_ty.kind, &to_ty.kind) {\n+                (ty::Ref(_, a, _), ty::Ref(_, b, _))\n+                | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _}), ty::RawPtr(TypeAndMut { ty: b, mutbl: _})) => {\n+                    assert_assignable(fx, a, b);\n+                }\n                 (ty::FnPtr(_), ty::FnPtr(_)) => {\n                     let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n                         ParamEnv::reveal_all(),"}]}