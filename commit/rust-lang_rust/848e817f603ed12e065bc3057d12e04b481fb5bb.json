{"sha": "848e817f603ed12e065bc3057d12e04b481fb5bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0OGU4MTdmNjAzZWQxMmUwNjViYzMwNTdkMTJlMDRiNDgxZmI1YmI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-30T00:39:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-30T00:39:29Z"}, "message": "Merge #7083\n\n7083: Refactor mbe parsing code r=edwin0cheng a=edwin0cheng\n\nInspire by #5426 , this PR refactor out the parsing code such that it only parsed on `mbe::Rule`, but not on invocations. \r\n\r\nHowever, it just improve the overall performance unnoticeablely :( \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "c4dd3ba17b56e25995e2ee14eabac1a4659b41e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4dd3ba17b56e25995e2ee14eabac1a4659b41e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/848e817f603ed12e065bc3057d12e04b481fb5bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf68xBCRBK7hj4Ov3rIwAAdHIIAAHckwlfRnKKgCgVbxMvg82d\ngjo8tR7FVzrN8ctinOr1NjsHDuKNpSm0PTaU7zwlTrjF+NNezJwvNcBDiR8uTszy\nLSa9q1Vw9GxRfURrzpeThCZ6TRdrrJt4iCRjp/aZcpdE6tkOd0tnylFmT3B0QZMJ\nVNftMmAqJNGc4skdPJ3KAW+QSwngjXyjjFTZ8sGhTZAcpcddAwc8qZAyZrkewkd7\nBHyu9Mx1Vi9slpEyUiWZX+TgUOS2aT0viprd281H9alaljdCXaS1Z/QdYS4hoKH+\n+5LEdms2sdw/GCTPSkoZJs0ahCOE5YB7Wt1jQ3LfiWOt2CVZ1+o42/npUSsExko=\n=OOjN\n-----END PGP SIGNATURE-----\n", "payload": "tree c4dd3ba17b56e25995e2ee14eabac1a4659b41e7\nparent 386c447038166687b9403bec71d5924b8e2d3fbc\nparent 266b14d4b5b44d1491e50c7aa2ed4b85020796e1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1609288769 +0000\ncommitter GitHub <noreply@github.com> 1609288769 +0000\n\nMerge #7083\n\n7083: Refactor mbe parsing code r=edwin0cheng a=edwin0cheng\n\nInspire by #5426 , this PR refactor out the parsing code such that it only parsed on `mbe::Rule`, but not on invocations. \r\n\r\nHowever, it just improve the overall performance unnoticeablely :( \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/848e817f603ed12e065bc3057d12e04b481fb5bb", "html_url": "https://github.com/rust-lang/rust/commit/848e817f603ed12e065bc3057d12e04b481fb5bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/848e817f603ed12e065bc3057d12e04b481fb5bb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "386c447038166687b9403bec71d5924b8e2d3fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/386c447038166687b9403bec71d5924b8e2d3fbc", "html_url": "https://github.com/rust-lang/rust/commit/386c447038166687b9403bec71d5924b8e2d3fbc"}, {"sha": "266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "html_url": "https://github.com/rust-lang/rust/commit/266b14d4b5b44d1491e50c7aa2ed4b85020796e1"}], "stats": {"total": 175, "additions": 99, "deletions": 76}, "files": [{"sha": "7878faaa4c665d47187ad031902e674c542dee94", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/848e817f603ed12e065bc3057d12e04b481fb5bb/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e817f603ed12e065bc3057d12e04b481fb5bb/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=848e817f603ed12e065bc3057d12e04b481fb5bb", "patch": "@@ -14,10 +14,10 @@ mod tests;\n \n use std::fmt;\n \n-pub use tt::{Delimiter, Punct};\n+pub use tt::{Delimiter, DelimiterKind, Punct};\n \n use crate::{\n-    parser::{parse_pattern, Op},\n+    parser::{parse_pattern, parse_template, Op},\n     tt_iter::TtIter,\n };\n \n@@ -78,8 +78,24 @@ pub struct MacroRules {\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n struct Rule {\n-    lhs: tt::Subtree,\n-    rhs: tt::Subtree,\n+    lhs: MetaTemplate,\n+    rhs: MetaTemplate,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+struct MetaTemplate {\n+    delimiter: Option<Delimiter>,\n+    tokens: Vec<Result<Op, ExpandError>>,\n+}\n+\n+impl<'a> MetaTemplate {\n+    fn iter(&self) -> impl Iterator<Item = &Result<Op, ExpandError>> {\n+        self.tokens.iter()\n+    }\n+\n+    fn delimiter_kind(&self) -> Option<DelimiterKind> {\n+        self.delimiter.map(|it| it.kind)\n+    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n@@ -167,7 +183,7 @@ impl MacroRules {\n             rules.push(rule);\n             if let Err(()) = src.expect_char(';') {\n                 if src.len() > 0 {\n-                    return Err(ParseError::Expected(\"expected `:`\".to_string()));\n+                    return Err(ParseError::Expected(\"expected `;`\".to_string()));\n                 }\n                 break;\n             }\n@@ -213,34 +229,38 @@ impl Rule {\n             .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?\n             .clone();\n         rhs.delimiter = None;\n+\n+        let lhs = MetaTemplate { tokens: parse_pattern(&lhs), delimiter: None };\n+        let rhs = MetaTemplate { tokens: parse_template(&rhs), delimiter: None };\n+\n         Ok(crate::Rule { lhs, rhs })\n     }\n }\n \n-fn to_parse_error(e: ExpandError) -> ParseError {\n+fn to_parse_error(e: &ExpandError) -> ParseError {\n     let msg = match e {\n         ExpandError::InvalidRepeat => \"invalid repeat\".to_string(),\n         _ => \"invalid macro definition\".to_string(),\n     };\n     ParseError::Expected(msg)\n }\n \n-fn validate(pattern: &tt::Subtree) -> Result<(), ParseError> {\n-    for op in parse_pattern(pattern) {\n-        let op = op.map_err(to_parse_error)?;\n+fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n+    for op in pattern.iter() {\n+        let op = op.as_ref().map_err(|e| to_parse_error(&e))?;\n \n         match op {\n-            Op::TokenTree(tt::TokenTree::Subtree(subtree)) => validate(subtree)?,\n+            Op::Subtree(subtree) => validate(&subtree)?,\n             Op::Repeat { subtree, separator, .. } => {\n                 // Checks that no repetition which could match an empty token\n                 // https://github.com/rust-lang/rust/blob/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f/src/librustc_expand/mbe/macro_rules.rs#L558\n \n                 if separator.is_none() {\n-                    if parse_pattern(subtree).all(|child_op| {\n-                        match child_op.map_err(to_parse_error) {\n+                    if subtree.iter().all(|child_op| {\n+                        match child_op.as_ref().map_err(to_parse_error) {\n                             Ok(Op::Var { kind, .. }) => {\n                                 // vis is optional\n-                                if kind.map_or(false, |it| it == \"vis\") {\n+                                if kind.as_ref().map_or(false, |it| it == \"vis\") {\n                                     return true;\n                                 }\n                             }"}, {"sha": "ab5f87c487ce6b910fdff0eb7ac6012340a7803f", "filename": "crates/mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/848e817f603ed12e065bc3057d12e04b481fb5bb/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e817f603ed12e065bc3057d12e04b481fb5bb/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=848e817f603ed12e065bc3057d12e04b481fb5bb", "patch": "@@ -2,10 +2,10 @@\n \n use crate::{\n     mbe_expander::{Binding, Bindings, Fragment},\n-    parser::{parse_pattern, Op, RepeatKind, Separator},\n+    parser::{Op, RepeatKind, Separator},\n     subtree_source::SubtreeTokenSource,\n     tt_iter::TtIter,\n-    ExpandError,\n+    ExpandError, MetaTemplate,\n };\n \n use super::ExpandResult;\n@@ -83,7 +83,7 @@ impl Match {\n // sense to try using it. Matching errors are added to the `Match`. It might\n // make sense to make pattern parsing a separate step?\n \n-pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Match, ExpandError> {\n+pub(super) fn match_(pattern: &MetaTemplate, src: &tt::Subtree) -> Result<Match, ExpandError> {\n     assert!(pattern.delimiter == None);\n \n     let mut res = Match::default();\n@@ -101,12 +101,12 @@ pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Match,\n \n fn match_subtree(\n     res: &mut Match,\n-    pattern: &tt::Subtree,\n+    pattern: &MetaTemplate,\n     src: &mut TtIter,\n ) -> Result<(), ExpandError> {\n-    for op in parse_pattern(pattern) {\n-        match op? {\n-            Op::TokenTree(tt::TokenTree::Leaf(lhs)) => {\n+    for op in pattern.iter() {\n+        match op.as_ref().map_err(|err| err.clone())? {\n+            Op::Leaf(lhs) => {\n                 let rhs = match src.expect_leaf() {\n                     Ok(l) => l,\n                     Err(()) => {\n@@ -132,7 +132,7 @@ fn match_subtree(\n                     }\n                 }\n             }\n-            Op::TokenTree(tt::TokenTree::Subtree(lhs)) => {\n+            Op::Subtree(lhs) => {\n                 let rhs = match src.expect_subtree() {\n                     Ok(s) => s,\n                     Err(()) => {\n@@ -172,7 +172,7 @@ fn match_subtree(\n                 }\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                match_repeat(res, subtree, kind, separator, src)?;\n+                match_repeat(res, subtree, *kind, separator, src)?;\n             }\n         }\n     }\n@@ -372,9 +372,9 @@ impl<'a> TtIter<'a> {\n \n pub(super) fn match_repeat(\n     res: &mut Match,\n-    pattern: &tt::Subtree,\n+    pattern: &MetaTemplate,\n     kind: RepeatKind,\n-    separator: Option<Separator>,\n+    separator: &Option<Separator>,\n     src: &mut TtIter,\n ) -> Result<(), ExpandError> {\n     // Dirty hack to make macro-expansion terminate.\n@@ -489,12 +489,12 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragmen\n     result.map(|tt| if kind == \"expr\" { tt.map(Fragment::Ast) } else { tt.map(Fragment::Tokens) })\n }\n \n-fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &tt::Subtree) -> Result<(), ExpandError> {\n-    for op in parse_pattern(pattern) {\n-        match op? {\n+fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) -> Result<(), ExpandError> {\n+    for op in pattern.iter() {\n+        match op.as_ref().map_err(|e| e.clone())? {\n             Op::Var { name, .. } => buf.push(name.clone()),\n-            Op::TokenTree(tt::TokenTree::Leaf(_)) => (),\n-            Op::TokenTree(tt::TokenTree::Subtree(subtree)) => collect_vars(buf, subtree)?,\n+            Op::Leaf(_) => (),\n+            Op::Subtree(subtree) => collect_vars(buf, subtree)?,\n             Op::Repeat { subtree, .. } => collect_vars(buf, subtree)?,\n         }\n     }"}, {"sha": "7205312371d16686392dac48c7921e0d75b52258", "filename": "crates/mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/848e817f603ed12e065bc3057d12e04b481fb5bb/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e817f603ed12e065bc3057d12e04b481fb5bb/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=848e817f603ed12e065bc3057d12e04b481fb5bb", "patch": "@@ -6,8 +6,8 @@ use syntax::SmolStr;\n use super::ExpandResult;\n use crate::{\n     mbe_expander::{Binding, Bindings, Fragment},\n-    parser::{parse_template, Op, RepeatKind, Separator},\n-    ExpandError,\n+    parser::{Op, RepeatKind, Separator},\n+    ExpandError, MetaTemplate,\n };\n \n impl Bindings {\n@@ -50,7 +50,10 @@ impl Bindings {\n     }\n }\n \n-pub(super) fn transcribe(template: &tt::Subtree, bindings: &Bindings) -> ExpandResult<tt::Subtree> {\n+pub(super) fn transcribe(\n+    template: &MetaTemplate,\n+    bindings: &Bindings,\n+) -> ExpandResult<tt::Subtree> {\n     assert!(template.delimiter == None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new() };\n     let mut arena: Vec<tt::TokenTree> = Vec::new();\n@@ -76,35 +79,35 @@ struct ExpandCtx<'a> {\n \n fn expand_subtree(\n     ctx: &mut ExpandCtx,\n-    template: &tt::Subtree,\n+    template: &MetaTemplate,\n     arena: &mut Vec<tt::TokenTree>,\n ) -> ExpandResult<tt::Subtree> {\n     // remember how many elements are in the arena now - when returning, we want to drain exactly how many elements we added. This way, the recursive uses of the arena get their own \"view\" of the arena, but will reuse the allocation\n     let start_elements = arena.len();\n     let mut err = None;\n-    for op in parse_template(template) {\n+    for op in template.iter() {\n         let op = match op {\n             Ok(op) => op,\n             Err(e) => {\n-                err = Some(e);\n+                err = Some(e.clone());\n                 break;\n             }\n         };\n         match op {\n-            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => arena.push(tt.clone()),\n-            Op::TokenTree(tt::TokenTree::Subtree(tt)) => {\n-                let ExpandResult { value: tt, err: e } = expand_subtree(ctx, tt, arena);\n+            Op::Leaf(tt) => arena.push(tt.clone().into()),\n+            Op::Subtree(tt) => {\n+                let ExpandResult { value: tt, err: e } = expand_subtree(ctx, &tt, arena);\n                 err = err.or(e);\n                 arena.push(tt.into());\n             }\n             Op::Var { name, .. } => {\n-                let ExpandResult { value: fragment, err: e } = expand_var(ctx, name);\n+                let ExpandResult { value: fragment, err: e } = expand_var(ctx, &name);\n                 err = err.or(e);\n                 push_fragment(arena, fragment);\n             }\n             Op::Repeat { subtree, kind, separator } => {\n                 let ExpandResult { value: fragment, err: e } =\n-                    expand_repeat(ctx, subtree, kind, separator, arena);\n+                    expand_repeat(ctx, subtree, *kind, separator, arena);\n                 err = err.or(e);\n                 push_fragment(arena, fragment)\n             }\n@@ -161,9 +164,9 @@ fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n \n fn expand_repeat(\n     ctx: &mut ExpandCtx,\n-    template: &tt::Subtree,\n+    template: &MetaTemplate,\n     kind: RepeatKind,\n-    separator: Option<Separator>,\n+    separator: &Option<Separator>,\n     arena: &mut Vec<tt::TokenTree>,\n ) -> ExpandResult<Fragment> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();"}, {"sha": "2f3ebc831397675f95741762ac11eaa3280acb50", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/848e817f603ed12e065bc3057d12e04b481fb5bb/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e817f603ed12e065bc3057d12e04b481fb5bb/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=848e817f603ed12e065bc3057d12e04b481fb5bb", "patch": "@@ -4,16 +4,17 @@\n use smallvec::SmallVec;\n use syntax::SmolStr;\n \n-use crate::{tt_iter::TtIter, ExpandError};\n+use crate::{tt_iter::TtIter, ExpandError, MetaTemplate};\n \n-#[derive(Debug)]\n-pub(crate) enum Op<'a> {\n-    Var { name: &'a SmolStr, kind: Option<&'a SmolStr> },\n-    Repeat { subtree: &'a tt::Subtree, kind: RepeatKind, separator: Option<Separator> },\n-    TokenTree(&'a tt::TokenTree),\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum Op {\n+    Var { name: SmolStr, kind: Option<SmolStr> },\n+    Repeat { subtree: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n+    Leaf(tt::Leaf),\n+    Subtree(MetaTemplate),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(crate) enum RepeatKind {\n     ZeroOrMore,\n     OneOrMore,\n@@ -45,16 +46,12 @@ impl PartialEq for Separator {\n     }\n }\n \n-pub(crate) fn parse_template(\n-    template: &tt::Subtree,\n-) -> impl Iterator<Item = Result<Op<'_>, ExpandError>> {\n-    parse_inner(template, Mode::Template)\n+pub(crate) fn parse_template(template: &tt::Subtree) -> Vec<Result<Op, ExpandError>> {\n+    parse_inner(&template, Mode::Template)\n }\n \n-pub(crate) fn parse_pattern(\n-    pattern: &tt::Subtree,\n-) -> impl Iterator<Item = Result<Op<'_>, ExpandError>> {\n-    parse_inner(pattern, Mode::Pattern)\n+pub(crate) fn parse_pattern(pattern: &tt::Subtree) -> Vec<Result<Op, ExpandError>> {\n+    parse_inner(&pattern, Mode::Pattern)\n }\n \n #[derive(Clone, Copy)]\n@@ -63,12 +60,13 @@ enum Mode {\n     Template,\n }\n \n-fn parse_inner(src: &tt::Subtree, mode: Mode) -> impl Iterator<Item = Result<Op<'_>, ExpandError>> {\n-    let mut src = TtIter::new(src);\n+fn parse_inner(tt: &tt::Subtree, mode: Mode) -> Vec<Result<Op, ExpandError>> {\n+    let mut src = TtIter::new(&tt);\n     std::iter::from_fn(move || {\n         let first = src.next()?;\n         Some(next_op(first, &mut src, mode))\n     })\n+    .collect()\n }\n \n macro_rules! err {\n@@ -83,21 +81,20 @@ macro_rules! bail {\n     };\n }\n \n-fn next_op<'a>(\n-    first: &'a tt::TokenTree,\n-    src: &mut TtIter<'a>,\n-    mode: Mode,\n-) -> Result<Op<'a>, ExpandError> {\n+fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ExpandError> {\n     let res = match first {\n-        tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n+        tt::TokenTree::Leaf(leaf @ tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n             // Note that the '$' itself is a valid token inside macro_rules.\n             let second = match src.next() {\n-                None => return Ok(Op::TokenTree(first)),\n+                None => return Ok(Op::Leaf(leaf.clone())),\n                 Some(it) => it,\n             };\n             match second {\n                 tt::TokenTree::Subtree(subtree) => {\n                     let (separator, kind) = parse_repeat(src)?;\n+                    let delimiter = subtree.delimiter;\n+                    let tokens = parse_inner(&subtree, mode);\n+                    let subtree = MetaTemplate { tokens, delimiter };\n                     Op::Repeat { subtree, separator, kind }\n                 }\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n@@ -107,18 +104,18 @@ fn next_op<'a>(\n                         if punct.char != '_' {\n                             return Err(ExpandError::UnexpectedToken);\n                         }\n-                        let name = &UNDERSCORE;\n+                        let name = UNDERSCORE.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n                         Op::Var { name, kind }\n                     }\n                     tt::Leaf::Ident(ident) => {\n-                        let name = &ident.text;\n+                        let name = ident.text.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n                         Op::Var { name, kind }\n                     }\n                     tt::Leaf::Literal(lit) => {\n-                        if is_boolean_literal(lit) {\n-                            let name = &lit.text;\n+                        if is_boolean_literal(&lit) {\n+                            let name = lit.text.clone();\n                             let kind = eat_fragment_kind(src, mode)?;\n                             Op::Var { name, kind }\n                         } else {\n@@ -128,19 +125,22 @@ fn next_op<'a>(\n                 },\n             }\n         }\n-        tt => Op::TokenTree(tt),\n+        tt::TokenTree::Leaf(tt) => Op::Leaf(tt.clone()),\n+        tt::TokenTree::Subtree(subtree) => {\n+            let delimiter = subtree.delimiter;\n+            let tokens = parse_inner(&subtree, mode);\n+            let subtree = MetaTemplate { tokens, delimiter };\n+            Op::Subtree(subtree)\n+        }\n     };\n     Ok(res)\n }\n \n-fn eat_fragment_kind<'a>(\n-    src: &mut TtIter<'a>,\n-    mode: Mode,\n-) -> Result<Option<&'a SmolStr>, ExpandError> {\n+fn eat_fragment_kind<'a>(src: &mut TtIter<'a>, mode: Mode) -> Result<Option<SmolStr>, ExpandError> {\n     if let Mode::Pattern = mode {\n         src.expect_char(':').map_err(|()| err!(\"bad fragment specifier 1\"))?;\n         let ident = src.expect_ident().map_err(|()| err!(\"bad fragment specifier 1\"))?;\n-        return Ok(Some(&ident.text));\n+        return Ok(Some(ident.text.clone()));\n     };\n     Ok(None)\n }"}]}