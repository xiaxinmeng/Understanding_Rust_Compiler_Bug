{"sha": "9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "node_id": "C_kwDOAAsO6NoAKDllMWM2MDBmNzRmOTY2ZWM1ODNmMGFjMzlkMGMyYTEwM2EyNTYwYTc", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2023-01-19T06:43:05Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2023-02-03T16:33:40Z"}, "message": "Disallow impl autotrait for trait object", "tree": {"sha": "4f6b150433154920c424a3da5a6b1764a20ad30d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f6b150433154920c424a3da5a6b1764a20ad30d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmPdN2QACgkQ+boUO5X/\nbYJeUQ//dUujLk+yQBGwNmcInFIV8FOMt8BvQ/dgaaCOiTPnM/w+IwFo7ntkPYhc\n2QNXUpt9HeuRUf4OkvcmfUa2fOey7vny19w1ZeSKwQtWCIA3TKogiLKGBy1Z0QyO\nSoV/iowIpY3D7oKJH46B9b+AaYa5OfCQMSInnVUHZbD/2cFYRs0+vFUAobJzlb6N\nGN5Jwp2W9G/M1+nwtWSSWNE8hj8VQLdhxRjwL8pZI6ykvllVUbgJkJgpKcEEcEZJ\n7lSwGcJ+/uzrA0Tgc272C7IRAM6QX9CF/hfTv0vy3RUe9Wap5+LEptO384nnMRgN\nGX5qtPKO6cXpSnlt9qvb140XETGFsC95Ahd1Wtyh8zrnkizYIyilWqQJTBzak6PW\nC+IBtNGg8P28oSOzapqCnAMGd984VTJ92E2u0dRltGW2rYc3YlVUBS3mp3Su5eqw\n47aTGidz1Smp+DBJeFHM7XICKwnozVtj3ZSf0b63v5cuLHWCXk0ExLCaKOm4gXt+\nl72aBXtaCO2wdRF33cg9etYGQVuzqqovbXP6H3GOTN17RVxZZEw4DcQOZWkWSP6m\nNrU+0XY9iCDsYM/EFR4rxflGBrNYWtC0TczCKdLJp4Xn2sZV4OXPpLPUZlTcfP3K\nT921s3pjeM/vS4obMwmuJBdlR0zOVtN1TTmx8k0T+QgOhXQhVaw=\n=2Uxu\n-----END PGP SIGNATURE-----", "payload": "tree 4f6b150433154920c424a3da5a6b1764a20ad30d\nparent a94b9fd0ace1336a3dd93f51f1c0db6ca0fd7f92\nauthor David Tolnay <dtolnay@gmail.com> 1674110585 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1675442020 -0800\n\nDisallow impl autotrait for trait object\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "html_url": "https://github.com/rust-lang/rust/commit/9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a94b9fd0ace1336a3dd93f51f1c0db6ca0fd7f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/a94b9fd0ace1336a3dd93f51f1c0db6ca0fd7f92", "html_url": "https://github.com/rust-lang/rust/commit/a94b9fd0ace1336a3dd93f51f1c0db6ca0fd7f92"}], "stats": {"total": 335, "additions": 267, "deletions": 68}, "files": [{"sha": "ad71dcdf9d95384421a94cf71d35277e8dde8b03", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "patch": "@@ -31,8 +31,8 @@ cfg_if! {\n         pub auto trait Send {}\n         pub auto trait Sync {}\n \n-        impl<T: ?Sized> Send for T {}\n-        impl<T: ?Sized> Sync for T {}\n+        impl<T> Send for T {}\n+        impl<T> Sync for T {}\n \n         #[macro_export]\n         macro_rules! rustc_erase_owner {"}, {"sha": "5c478b96fe6bb95073217498bfdb22cce0be7671", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 161, "deletions": 40, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{\n-    self, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n+    self, AliasKind, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n@@ -86,7 +86,7 @@ fn do_orphan_check_impl<'tcx>(\n     // struct B { }\n     // impl Foo for A { }\n     // impl Foo for B { }\n-    // impl !Send for (A, B) { }\n+    // impl !Foo for (A, B) { }\n     // ```\n     //\n     // This final impl is legal according to the orphan\n@@ -99,50 +99,171 @@ fn do_orphan_check_impl<'tcx>(\n         tcx.trait_is_auto(trait_def_id)\n     );\n \n-    if tcx.trait_is_auto(trait_def_id) && !trait_def_id.is_local() {\n+    if tcx.trait_is_auto(trait_def_id) {\n         let self_ty = trait_ref.self_ty();\n-        let opt_self_def_id = match *self_ty.kind() {\n-            ty::Adt(self_def, _) => Some(self_def.did()),\n-            ty::Foreign(did) => Some(did),\n-            _ => None,\n-        };\n \n-        let msg = match opt_self_def_id {\n-            // We only want to permit nominal types, but not *all* nominal types.\n-            // They must be local to the current crate, so that people\n-            // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n-            // `impl !Send for Box<SomethingLocalAndSend>`.\n-            Some(self_def_id) => {\n-                if self_def_id.is_local() {\n-                    None\n+        // If the impl is in the same crate as the auto-trait, almost anything\n+        // goes.\n+        //\n+        //     impl MyAuto for Rc<Something> {}  // okay\n+        //     impl<T> !MyAuto for *const T {}   // okay\n+        //     impl<T> MyAuto for T {}           // okay\n+        //\n+        // But there is one important exception: implementing for a trait object\n+        // is not allowed.\n+        //\n+        //     impl MyAuto for dyn Trait {}      // NOT OKAY\n+        //     impl<T: ?Sized> MyAuto for T {}   // NOT OKAY\n+        //\n+        enum LocalImpl {\n+            Allow,\n+            Disallow { problematic_kind: &'static str },\n+        }\n+\n+        // If the auto-trait is from a dependency, it must only be getting\n+        // implemented for a nominal type, and specifically one local to the\n+        // current crate.\n+        //\n+        //     impl<T> Sync for MyStruct<T> {}   // okay\n+        //\n+        //     impl Sync for Rc<MyStruct> {}     // NOT OKAY\n+        enum NonlocalImpl {\n+            Allow,\n+            DisallowBecauseNonlocal,\n+            DisallowOther,\n+        }\n+\n+        // Exhaustive match considering that this logic is essential for\n+        // soundness.\n+        let (local_impl, nonlocal_impl) = match self_ty.kind() {\n+            // struct Struct<T>;\n+            // impl AutoTrait for Struct<Foo> {}\n+            ty::Adt(self_def, _) => (\n+                LocalImpl::Allow,\n+                if self_def.did().is_local() {\n+                    NonlocalImpl::Allow\n+                } else {\n+                    NonlocalImpl::DisallowBecauseNonlocal\n+                },\n+            ),\n+\n+            // extern { type OpaqueType; }\n+            // impl AutoTrait for OpaqueType {}\n+            ty::Foreign(did) => (\n+                LocalImpl::Allow,\n+                if did.is_local() {\n+                    NonlocalImpl::Allow\n                 } else {\n-                    Some((\n-                        format!(\n-                            \"cross-crate traits with a default impl, like `{}`, \\\n-                                    can only be implemented for a struct/enum type \\\n-                                    defined in the current crate\",\n-                            tcx.def_path_str(trait_def_id)\n-                        ),\n-                        \"can't implement cross-crate trait for type in another crate\",\n-                    ))\n+                    NonlocalImpl::DisallowBecauseNonlocal\n+                },\n+            ),\n+\n+            // impl AutoTrait for dyn Trait {}\n+            ty::Dynamic(..) => (\n+                LocalImpl::Disallow { problematic_kind: \"trait object\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // impl<T> AutoTrait for T {}\n+            // impl<T: ?Sized> AutoTrait for T {}\n+            ty::Param(..) => (\n+                if self_ty.is_sized(tcx, tcx.param_env(def_id)) {\n+                    LocalImpl::Allow\n+                } else {\n+                    LocalImpl::Disallow { problematic_kind: \"generic type\" }\n+                },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // trait Id { type This: ?Sized; }\n+            // impl<T: ?Sized> Id for T {\n+            //     type This = T;\n+            // }\n+            // impl<T: ?Sized> AutoTrait for <T as Id>::This {}\n+            ty::Alias(AliasKind::Projection, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"associated type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // type Opaque = impl Trait;\n+            // impl AutoTrait for Opaque {}\n+            ty::Alias(AliasKind::Opaque, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"opaque type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(..)\n+            | ty::Never\n+            | ty::Tuple(..) => (LocalImpl::Allow, NonlocalImpl::DisallowOther),\n+\n+            ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Bound(..)\n+            | ty::Placeholder(..)\n+            | ty::Infer(..) => span_bug!(sp, \"weird self type for autotrait impl\"),\n+\n+            ty::Error(..) => (LocalImpl::Allow, NonlocalImpl::Allow),\n+        };\n+\n+        if trait_def_id.is_local() {\n+            match local_impl {\n+                LocalImpl::Allow => {}\n+                LocalImpl::Disallow { problematic_kind } => {\n+                    let msg = format!(\n+                        \"traits with a default impl, like `{trait}`, \\\n+                                cannot be implemented for {problematic_kind} `{self_ty}`\",\n+                        trait = tcx.def_path_str(trait_def_id),\n+                    );\n+                    let label = format!(\n+                        \"a trait object implements `{trait}` if and only if `{trait}` \\\n+                                is one of the trait object's trait bounds\",\n+                        trait = tcx.def_path_str(trait_def_id),\n+                    );\n+                    let reported =\n+                        struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).note(label).emit();\n+                    return Err(reported);\n                 }\n             }\n-            _ => Some((\n-                format!(\n-                    \"cross-crate traits with a default impl, like `{}`, can \\\n+        } else {\n+            if let Some((msg, label)) = match nonlocal_impl {\n+                NonlocalImpl::Allow => None,\n+                NonlocalImpl::DisallowBecauseNonlocal => Some((\n+                    format!(\n+                        \"cross-crate traits with a default impl, like `{}`, \\\n+                                can only be implemented for a struct/enum type \\\n+                                defined in the current crate\",\n+                        tcx.def_path_str(trait_def_id)\n+                    ),\n+                    \"can't implement cross-crate trait for type in another crate\",\n+                )),\n+                NonlocalImpl::DisallowOther => Some((\n+                    format!(\n+                        \"cross-crate traits with a default impl, like `{}`, can \\\n                                 only be implemented for a struct/enum type, not `{}`\",\n-                    tcx.def_path_str(trait_def_id),\n-                    self_ty\n-                ),\n-                \"can't implement cross-crate trait with a default impl for \\\n-                        non-struct/enum type\",\n-            )),\n-        };\n-\n-        if let Some((msg, label)) = msg {\n-            let reported =\n-                struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n-            return Err(reported);\n+                        tcx.def_path_str(trait_def_id),\n+                        self_ty\n+                    ),\n+                    \"can't implement cross-crate trait with a default impl for \\\n+                            non-struct/enum type\",\n+                )),\n+            } {\n+                let reported =\n+                    struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n+                return Err(reported);\n+            }\n         }\n     }\n "}, {"sha": "98f1558b7ffe18d5493f4628ac97cd3738feb44a", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-negative.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs?ref=9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "patch": "@@ -12,19 +12,26 @@ auto trait Marker2 {}\n trait Object: Marker1 {}\n \n // A supertrait marker is illegal...\n-impl !Marker1 for dyn Object + Marker2 { }   //~ ERROR E0371\n+impl !Marker1 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                          //~^ ERROR 0321\n // ...and also a direct component.\n-impl !Marker2 for dyn Object + Marker2 { }   //~ ERROR E0371\n-\n-// But implementing a marker if it is not present is OK.\n-impl !Marker2 for dyn Object {} // OK\n+impl !Marker2 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                          //~^ ERROR 0321\n \n // A non-principal trait-object type is orphan even in its crate.\n impl !Send for dyn Marker2 {} //~ ERROR E0117\n \n-// And impl'ing a remote marker for a local trait object is forbidden\n-// by one of these special orphan-like rules.\n+// Implementing a marker for a local trait object is forbidden by a special\n+// orphan-like rule.\n+impl !Marker2 for dyn Object {} //~ ERROR E0321\n impl !Send for dyn Object {} //~ ERROR E0321\n impl !Send for dyn Object + Marker2 {} //~ ERROR E0321\n \n-fn main() { }\n+// Blanket impl that applies to dyn Object is equally problematic.\n+auto trait Marker3 {}\n+impl<T: ?Sized> !Marker3 for T {} //~ ERROR E0321\n+\n+auto trait Marker4 {}\n+impl<T> !Marker4 for T {} // okay\n+\n+fn main() {}"}, {"sha": "ea38afc40ce80bf82ad8bf5702984152899b02e5", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-negative.stderr", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr?ref=9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "patch": "@@ -1,17 +1,41 @@\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n   --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:15:1\n    |\n-LL | impl !Marker1 for dyn Object + Marker2 { }\n+LL | impl !Marker1 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n \n+error[E0321]: traits with a default impl, like `Marker1`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:15:1\n+   |\n+LL | impl !Marker1 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker1` if and only if `Marker1` is one of the trait object's trait bounds\n+\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:17:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:18:1\n    |\n-LL | impl !Marker2 for dyn Object + Marker2 { }\n+LL | impl !Marker2 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n \n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:18:1\n+   |\n+LL | impl !Marker2 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:26:1\n+   |\n+LL | impl !Marker2 for dyn Object {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:23:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:22:1\n    |\n LL | impl !Send for dyn Marker2 {}\n    | ^^^^^^^^^^^^^^^-----------\n@@ -33,7 +57,15 @@ error[E0321]: cross-crate traits with a default impl, like `Send`, can only be i\n LL | impl !Send for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait with a default impl for non-struct/enum type\n \n-error: aborting due to 5 previous errors\n+error[E0321]: traits with a default impl, like `Marker3`, cannot be implemented for generic type `T`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:32:1\n+   |\n+LL | impl<T: ?Sized> !Marker3 for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker3` if and only if `Marker3` is one of the trait object's trait bounds\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0117, E0321, E0371.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "db2e2b4509a2af6f5c85d77d5722d8cae7355792", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-positive.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs?ref=9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "patch": "@@ -12,19 +12,26 @@ auto trait Marker2 {}\n trait Object: Marker1 {}\n \n // A supertrait marker is illegal...\n-impl Marker1 for dyn Object + Marker2 { }   //~ ERROR E0371\n+impl Marker1 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                         //~^ ERROR E0321\n // ...and also a direct component.\n-impl Marker2 for dyn Object + Marker2 { }   //~ ERROR E0371\n-\n-// But implementing a marker if it is not present is OK.\n-impl Marker2 for dyn Object {} // OK\n+impl Marker2 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                         //~^ ERROR E0321\n \n // A non-principal trait-object type is orphan even in its crate.\n unsafe impl Send for dyn Marker2 {} //~ ERROR E0117\n \n-// And impl'ing a remote marker for a local trait object is forbidden\n-// by one of these special orphan-like rules.\n+// Implementing a marker for a local trait object is forbidden by a special\n+// orphan-like rule.\n+impl Marker2 for dyn Object {} //~ ERROR E0321\n unsafe impl Send for dyn Object {} //~ ERROR E0321\n unsafe impl Send for dyn Object + Marker2 {} //~ ERROR E0321\n \n-fn main() { }\n+// Blanket impl that applies to dyn Object is equally problematic.\n+auto trait Marker3 {}\n+impl<T: ?Sized> Marker3 for T {} //~ ERROR E0321\n+\n+auto trait Marker4 {}\n+impl<T> Marker4 for T {} // okay\n+\n+fn main() {}"}, {"sha": "2a8713bc327942496550e57aa390781c10a741c2", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-positive.stderr", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c600f74f966ec583f0ac39d0c2a103a2560a7/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr?ref=9e1c600f74f966ec583f0ac39d0c2a103a2560a7", "patch": "@@ -1,17 +1,41 @@\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n   --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:15:1\n    |\n-LL | impl Marker1 for dyn Object + Marker2 { }\n+LL | impl Marker1 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n \n+error[E0321]: traits with a default impl, like `Marker1`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:15:1\n+   |\n+LL | impl Marker1 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker1` if and only if `Marker1` is one of the trait object's trait bounds\n+\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:17:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:18:1\n    |\n-LL | impl Marker2 for dyn Object + Marker2 { }\n+LL | impl Marker2 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n \n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:18:1\n+   |\n+LL | impl Marker2 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:26:1\n+   |\n+LL | impl Marker2 for dyn Object {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:23:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:22:1\n    |\n LL | unsafe impl Send for dyn Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^-----------\n@@ -33,7 +57,15 @@ error[E0321]: cross-crate traits with a default impl, like `Send`, can only be i\n LL | unsafe impl Send for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait with a default impl for non-struct/enum type\n \n-error: aborting due to 5 previous errors\n+error[E0321]: traits with a default impl, like `Marker3`, cannot be implemented for generic type `T`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:32:1\n+   |\n+LL | impl<T: ?Sized> Marker3 for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker3` if and only if `Marker3` is one of the trait object's trait bounds\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0117, E0321, E0371.\n For more information about an error, try `rustc --explain E0117`."}]}