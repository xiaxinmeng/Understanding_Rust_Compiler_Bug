{"sha": "3d9997889bfe536a96e70535ab208a6e7ff3bc12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOTk5Nzg4OWJmZTUzNmE5NmU3MDUzNWFiMjA4YTZlN2ZmM2JjMTI=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-06-23T09:07:42Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-01T08:44:11Z"}, "message": "SSR: Add initial support for placeholder constraints", "tree": {"sha": "6f280e6af08979d7a5c17d45a15b94a54798dba3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f280e6af08979d7a5c17d45a15b94a54798dba3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d9997889bfe536a96e70535ab208a6e7ff3bc12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9997889bfe536a96e70535ab208a6e7ff3bc12", "html_url": "https://github.com/rust-lang/rust/commit/3d9997889bfe536a96e70535ab208a6e7ff3bc12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d9997889bfe536a96e70535ab208a6e7ff3bc12/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d34fd372bbcce4600fe7dd1ca61b9b213a7f5ced", "url": "https://api.github.com/repos/rust-lang/rust/commits/d34fd372bbcce4600fe7dd1ca61b9b213a7f5ced", "html_url": "https://github.com/rust-lang/rust/commit/d34fd372bbcce4600fe7dd1ca61b9b213a7f5ced"}], "stats": {"total": 162, "additions": 156, "deletions": 6}, "files": [{"sha": "61ae8157a7fafe827e96d227cc0812d9a929f30d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d9997889bfe536a96e70535ab208a6e7ff3bc12/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d9997889bfe536a96e70535ab208a6e7ff3bc12/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3d9997889bfe536a96e70535ab208a6e7ff3bc12", "patch": "@@ -1248,6 +1248,7 @@ dependencies = [\n  \"ra_syntax\",\n  \"ra_text_edit\",\n  \"rustc-hash\",\n+ \"test_utils\",\n ]\n \n [[package]]"}, {"sha": "b3e9e5dfe111385693a0ab759318824d20d9d8b2", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=3d9997889bfe536a96e70535ab208a6e7ff3bc12", "patch": "@@ -10,6 +10,18 @@ use ra_ssr::{MatchFinder, SsrError, SsrRule};\n // The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n // A `$<name>` placeholder in the search pattern will match any AST node and `$<name>` will reference it in the replacement.\n // Within a macro call, a placeholder will match up until whatever token follows the placeholder.\n+//\n+// Placeholders may be given constraints by writing them as `${<name>:<constraint1>:<constraint2>...}`.\n+//\n+// Supported constraints:\n+//\n+// |===\n+// | Constraint    | Restricts placeholder\n+//\n+// | kind(literal) | Is a literal (e.g. `42` or `\"forty two\"`)\n+// | not(a)        | Negates the constraint `a`\n+// |===\n+//\n // Available via the command `rust-analyzer.ssr`.\n //\n // ```rust"}, {"sha": "fe098aaee30099e3390444bc52fe56865b75441e", "filename": "crates/ra_ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2FCargo.toml?ref=3d9997889bfe536a96e70535ab208a6e7ff3bc12", "patch": "@@ -17,3 +17,4 @@ ra_db = { path = \"../ra_db\" }\n ra_ide_db = { path = \"../ra_ide_db\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n rustc-hash = \"1.1.0\"\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "ce53d46d2963fd59d288cb56deec1f8a7730c768", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=3d9997889bfe536a96e70535ab208a6e7ff3bc12", "patch": "@@ -2,7 +2,7 @@\n //! process of matching, placeholder values are recorded.\n \n use crate::{\n-    parsing::{Placeholder, SsrTemplate},\n+    parsing::{Constraint, NodeKind, Placeholder, SsrTemplate},\n     SsrMatches, SsrPattern, SsrRule,\n };\n use hir::Semantics;\n@@ -11,6 +11,7 @@ use ra_syntax::ast::{AstNode, AstToken};\n use ra_syntax::{ast, SyntaxElement, SyntaxElementChildren, SyntaxKind, SyntaxNode, SyntaxToken};\n use rustc_hash::FxHashMap;\n use std::{cell::Cell, iter::Peekable};\n+use test_utils::mark;\n \n // Creates a match error. If we're currently attempting to match some code that we thought we were\n // going to match, as indicated by the --debug-snippet flag, then populate the reason field.\n@@ -169,6 +170,9 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         if let Some(placeholder) =\n             match_inputs.get_placeholder(&SyntaxElement::Node(pattern.clone()))\n         {\n+            for constraint in &placeholder.constraints {\n+                self.check_constraint(constraint, code)?;\n+            }\n             if self.match_out.is_none() {\n                 return Ok(());\n             }\n@@ -292,6 +296,24 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         Ok(())\n     }\n \n+    fn check_constraint(\n+        &self,\n+        constraint: &Constraint,\n+        code: &SyntaxNode,\n+    ) -> Result<(), MatchFailed> {\n+        match constraint {\n+            Constraint::Kind(kind) => {\n+                kind.matches(code)?;\n+            }\n+            Constraint::Not(sub) => {\n+                if self.check_constraint(&*sub, code).is_ok() {\n+                    fail_match!(\"Constraint {:?} failed for '{}'\", constraint, code.text());\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// We want to allow the records to match in any order, so we have special matching logic for\n     /// them.\n     fn attempt_match_record_field_list(\n@@ -515,6 +537,21 @@ impl SsrPattern {\n     }\n }\n \n+impl NodeKind {\n+    fn matches(&self, node: &SyntaxNode) -> Result<(), MatchFailed> {\n+        let ok = match self {\n+            Self::Literal => {\n+                mark::hit!(literal_constraint);\n+                ast::Literal::can_cast(node.kind())\n+            }\n+        };\n+        if !ok {\n+            fail_match!(\"Code '{}' isn't of kind {:?}\", node.text(), self);\n+        }\n+        Ok(())\n+    }\n+}\n+\n // If `node` contains nothing but an ident then return it, otherwise return None.\n fn only_ident(element: SyntaxElement) -> Option<SyntaxToken> {\n     match element {"}, {"sha": "0f4f88b7c93b86c6ca3138153a7af81208b28f84", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 87, "deletions": 5, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=3d9997889bfe536a96e70535ab208a6e7ff3bc12", "patch": "@@ -39,6 +39,18 @@ pub(crate) struct Placeholder {\n     pub(crate) ident: SmolStr,\n     /// A unique name used in place of this placeholder when we parse the pattern as Rust code.\n     stand_in_name: String,\n+    pub(crate) constraints: Vec<Constraint>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum Constraint {\n+    Kind(NodeKind),\n+    Not(Box<Constraint>),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum NodeKind {\n+    Literal,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -177,6 +189,9 @@ fn validate_rule(rule: &SsrRule) -> Result<(), SsrError> {\n             if !defined_placeholders.contains(&placeholder.ident) {\n                 undefined.push(format!(\"${}\", placeholder.ident));\n             }\n+            if !placeholder.constraints.is_empty() {\n+                bail!(\"Replacement placeholders cannot have constraints\");\n+            }\n         }\n     }\n     if !undefined.is_empty() {\n@@ -205,23 +220,90 @@ fn tokenize(source: &str) -> Result<Vec<Token>, SsrError> {\n \n fn parse_placeholder(tokens: &mut std::vec::IntoIter<Token>) -> Result<Placeholder, SsrError> {\n     let mut name = None;\n+    let mut constraints = Vec::new();\n     if let Some(token) = tokens.next() {\n         match token.kind {\n             SyntaxKind::IDENT => {\n                 name = Some(token.text);\n             }\n+            SyntaxKind::L_CURLY => {\n+                let token =\n+                    tokens.next().ok_or_else(|| SsrError::new(\"Unexpected end of placeholder\"))?;\n+                if token.kind == SyntaxKind::IDENT {\n+                    name = Some(token.text);\n+                }\n+                loop {\n+                    let token = tokens\n+                        .next()\n+                        .ok_or_else(|| SsrError::new(\"Placeholder is missing closing brace '}'\"))?;\n+                    match token.kind {\n+                        SyntaxKind::COLON => {\n+                            constraints.push(parse_constraint(tokens)?);\n+                        }\n+                        SyntaxKind::R_CURLY => break,\n+                        _ => bail!(\"Unexpected token while parsing placeholder: '{}'\", token.text),\n+                    }\n+                }\n+            }\n             _ => {\n-                bail!(\"Placeholders should be $name\");\n+                bail!(\"Placeholders should either be $name or ${name:constraints}\");\n             }\n         }\n     }\n     let name = name.ok_or_else(|| SsrError::new(\"Placeholder ($) with no name\"))?;\n-    Ok(Placeholder::new(name))\n+    Ok(Placeholder::new(name, constraints))\n+}\n+\n+fn parse_constraint(tokens: &mut std::vec::IntoIter<Token>) -> Result<Constraint, SsrError> {\n+    let constraint_type = tokens\n+        .next()\n+        .ok_or_else(|| SsrError::new(\"Found end of placeholder while looking for a constraint\"))?\n+        .text\n+        .to_string();\n+    match constraint_type.as_str() {\n+        \"kind\" => {\n+            expect_token(tokens, \"(\")?;\n+            let t = tokens.next().ok_or_else(|| {\n+                SsrError::new(\"Unexpected end of constraint while looking for kind\")\n+            })?;\n+            if t.kind != SyntaxKind::IDENT {\n+                bail!(\"Expected ident, found {:?} while parsing kind constraint\", t.kind);\n+            }\n+            expect_token(tokens, \")\")?;\n+            Ok(Constraint::Kind(NodeKind::from(&t.text)?))\n+        }\n+        \"not\" => {\n+            expect_token(tokens, \"(\")?;\n+            let sub = parse_constraint(tokens)?;\n+            expect_token(tokens, \")\")?;\n+            Ok(Constraint::Not(Box::new(sub)))\n+        }\n+        x => bail!(\"Unsupported constraint type '{}'\", x),\n+    }\n+}\n+\n+fn expect_token(tokens: &mut std::vec::IntoIter<Token>, expected: &str) -> Result<(), SsrError> {\n+    if let Some(t) = tokens.next() {\n+        if t.text == expected {\n+            return Ok(());\n+        }\n+        bail!(\"Expected {} found {}\", expected, t.text);\n+    }\n+    bail!(\"Expected {} found end of stream\");\n+}\n+\n+impl NodeKind {\n+    fn from(name: &SmolStr) -> Result<NodeKind, SsrError> {\n+        Ok(match name.as_str() {\n+            \"literal\" => NodeKind::Literal,\n+            _ => bail!(\"Unknown node kind '{}'\", name),\n+        })\n+    }\n }\n \n impl Placeholder {\n-    fn new(name: SmolStr) -> Self {\n-        Self { stand_in_name: format!(\"__placeholder_{}\", name), ident: name }\n+    fn new(name: SmolStr, constraints: Vec<Constraint>) -> Self {\n+        Self { stand_in_name: format!(\"__placeholder_{}\", name), constraints, ident: name }\n     }\n }\n \n@@ -241,7 +323,7 @@ mod tests {\n             PatternElement::Token(Token { kind, text: SmolStr::new(text) })\n         }\n         fn placeholder(name: &str) -> PatternElement {\n-            PatternElement::Placeholder(Placeholder::new(SmolStr::new(name)))\n+            PatternElement::Placeholder(Placeholder::new(SmolStr::new(name), Vec::new()))\n         }\n         let result: SsrRule = \"foo($a, $b) ==>> bar($b, $a)\".parse().unwrap();\n         assert_eq!("}, {"sha": "9568d44322d6df2afbaa80aee9e5adabd3ba1ce3", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9997889bfe536a96e70535ab208a6e7ff3bc12/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=3d9997889bfe536a96e70535ab208a6e7ff3bc12", "patch": "@@ -1,5 +1,6 @@\n use crate::{MatchFinder, SsrRule};\n use ra_db::{FileId, SourceDatabaseExt};\n+use test_utils::mark;\n \n fn parse_error_text(query: &str) -> String {\n     format!(\"{}\", query.parse::<SsrRule>().unwrap_err())\n@@ -301,6 +302,22 @@ fn match_pattern() {\n     assert_matches(\"Some($a)\", \"fn f() {if let Some(x) = foo() {}}\", &[\"Some(x)\"]);\n }\n \n+#[test]\n+fn literal_constraint() {\n+    mark::check!(literal_constraint);\n+    let code = r#\"\n+        fn f1() {\n+            let x1 = Some(42);\n+            let x2 = Some(\"foo\");\n+            let x3 = Some(x1);\n+            let x4 = Some(40 + 2);\n+            let x5 = Some(true);\n+        }\n+        \"#;\n+    assert_matches(\"Some(${a:kind(literal)})\", code, &[\"Some(42)\", \"Some(\\\"foo\\\")\", \"Some(true)\"]);\n+    assert_matches(\"Some(${a:not(kind(literal))})\", code, &[\"Some(x1)\", \"Some(40 + 2)\"]);\n+}\n+\n #[test]\n fn match_reordered_struct_instantiation() {\n     assert_matches("}]}