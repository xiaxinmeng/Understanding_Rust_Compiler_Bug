{"sha": "d6f6084b24923f14bff0cf31ef78da9383cfb397", "node_id": "C_kwDOAAsO6NoAKGQ2ZjYwODRiMjQ5MjNmMTRiZmYwY2YzMWVmNzhkYTkzODNjZmIzOTc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-02T01:34:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-02T01:34:24Z"}, "message": "Rollup merge of #95556 - declanvk:nonnull-provenance, r=dtolnay\n\nImplement provenance preserving methods on NonNull\n\n### Description\n Add the `addr`, `with_addr`, `map_addr` methods to the `NonNull` type, and map the address type to `NonZeroUsize`.\n\n ### Motivation\n The `NonNull` type is useful for implementing pointer types which have  the 0-niche. It is currently possible to implement these provenance  preserving functions by calling `NonNull::as_ptr` and `new_unchecked`. The adding these methods makes it more ergonomic.\n\n ### Testing\n Added a unit test of a non-null tagged pointer type. This is based on some real code I have elsewhere, that currently routes the pointer through a `NonZeroUsize` and back out to produce a usable pointer. I wanted to produce an ideal version of the same tagged pointer struct that preserved pointer provenance.\n\n### Related\n\nExtension of APIs proposed in #95228 . I can also split this out into a separate tracking issue if that is better (though I may need some pointers on how to do that).", "tree": {"sha": "c14660294ec1c2b522bf5aae2bd67a8ed9ca69ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c14660294ec1c2b522bf5aae2bd67a8ed9ca69ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6f6084b24923f14bff0cf31ef78da9383cfb397", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiR6ggCRBK7hj4Ov3rIwAAvBIIAJolqGimyFM4EajRh+GWSHhA\ngf9NHvDBJnunAQSzTEbo6dtmJ9dw+F0I8HJofSBG8KJrX5U7bu8zJ75KJHumPyrn\nPXG0Ao29tj4A0E4o8V9UAiBoAwEthBlEmS5hf6RMHui3di+vbQ6QWcgsEiKCLxzQ\ndARX4OTFlClqKdn/G+RR0I3zvCPubFwLSFmRkThXyXZDZJctnXUYqvdoMD8wNIMS\n2hdAfqAGjKQRB989C8PINtyrF+twt5B9hWPa0J4mox9/keEKDnYamKNYgUACHamb\na31E6hX+UTOcM+ESFvTBsE72xDzQV2OBIXyTo61sGkFfm5qQIMGKwVNpxkV3ZiE=\n=GY8K\n-----END PGP SIGNATURE-----\n", "payload": "tree c14660294ec1c2b522bf5aae2bd67a8ed9ca69ed\nparent 556c7411cc01c88d4656b65a28646fd945ac2a22\nparent 2a827635ba65e3d40af8643373e4584858eecc7d\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1648863264 +0200\ncommitter GitHub <noreply@github.com> 1648863264 +0200\n\nRollup merge of #95556 - declanvk:nonnull-provenance, r=dtolnay\n\nImplement provenance preserving methods on NonNull\n\n### Description\n Add the `addr`, `with_addr`, `map_addr` methods to the `NonNull` type, and map the address type to `NonZeroUsize`.\n\n ### Motivation\n The `NonNull` type is useful for implementing pointer types which have  the 0-niche. It is currently possible to implement these provenance  preserving functions by calling `NonNull::as_ptr` and `new_unchecked`. The adding these methods makes it more ergonomic.\n\n ### Testing\n Added a unit test of a non-null tagged pointer type. This is based on some real code I have elsewhere, that currently routes the pointer through a `NonZeroUsize` and back out to produce a usable pointer. I wanted to produce an ideal version of the same tagged pointer struct that preserved pointer provenance.\n\n### Related\n\nExtension of APIs proposed in #95228 . I can also split this out into a separate tracking issue if that is better (though I may need some pointers on how to do that).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6f6084b24923f14bff0cf31ef78da9383cfb397", "html_url": "https://github.com/rust-lang/rust/commit/d6f6084b24923f14bff0cf31ef78da9383cfb397", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6f6084b24923f14bff0cf31ef78da9383cfb397/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "556c7411cc01c88d4656b65a28646fd945ac2a22", "url": "https://api.github.com/repos/rust-lang/rust/commits/556c7411cc01c88d4656b65a28646fd945ac2a22", "html_url": "https://github.com/rust-lang/rust/commit/556c7411cc01c88d4656b65a28646fd945ac2a22"}, {"sha": "2a827635ba65e3d40af8643373e4584858eecc7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a827635ba65e3d40af8643373e4584858eecc7d", "html_url": "https://github.com/rust-lang/rust/commit/2a827635ba65e3d40af8643373e4584858eecc7d"}], "stats": {"total": 127, "additions": 127, "deletions": 0}, "files": [{"sha": "7516d4bba4cdfcd98a6d94c08eb65785879a571c", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d6f6084b24923f14bff0cf31ef78da9383cfb397/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f6084b24923f14bff0cf31ef78da9383cfb397/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=d6f6084b24923f14bff0cf31ef78da9383cfb397", "patch": "@@ -4,6 +4,7 @@ use crate::fmt;\n use crate::hash;\n use crate::marker::Unsize;\n use crate::mem::{self, MaybeUninit};\n+use crate::num::NonZeroUsize;\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n use crate::slice::{self, SliceIndex};\n@@ -253,6 +254,53 @@ impl<T: ?Sized> NonNull<T> {\n         (self.cast(), super::metadata(self.as_ptr()))\n     }\n \n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn addr(self) -> NonZeroUsize\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: The pointer is guaranteed by the type to be non-null,\n+        // meaning that the address will be non-zero.\n+        unsafe { NonZeroUsize::new_unchecked(self.pointer.addr()) }\n+    }\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn with_addr(self, addr: NonZeroUsize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: The result of `ptr::from::with_addr` is non-null because `addr` is guaranteed to be non-zero.\n+        unsafe { NonNull::new_unchecked(self.pointer.with_addr(addr.get()) as *mut _) }\n+    }\n+\n+    /// Creates a new pointer by mapping `self`'s address to a new one.\n+    ///\n+    /// This is a convenience for [`with_addr`][Self::with_addr], see that method for details.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn map_addr(self, f: impl FnOnce(NonZeroUsize) -> NonZeroUsize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        self.with_addr(f(self.addr()))\n+    }\n+\n     /// Acquires the underlying `*mut` pointer.\n     ///\n     /// # Examples"}, {"sha": "3af277a556b4f45c9e67253058175afe7c15011c", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6f6084b24923f14bff0cf31ef78da9383cfb397/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f6084b24923f14bff0cf31ef78da9383cfb397/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=d6f6084b24923f14bff0cf31ef78da9383cfb397", "patch": "@@ -86,6 +86,7 @@\n #![feature(int_roundings)]\n #![feature(slice_group_by)]\n #![feature(split_array)]\n+#![feature(strict_provenance)]\n #![feature(trusted_random_access)]\n #![feature(unsize)]\n #![feature(unzip_option)]"}, {"sha": "03fe56022b069107e27de11684ce1728c0263242", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d6f6084b24923f14bff0cf31ef78da9383cfb397/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f6084b24923f14bff0cf31ef78da9383cfb397/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=d6f6084b24923f14bff0cf31ef78da9383cfb397", "patch": "@@ -1,4 +1,5 @@\n use core::cell::RefCell;\n+use core::num::NonZeroUsize;\n use core::ptr;\n use core::ptr::*;\n use std::fmt::{Debug, Display};\n@@ -691,3 +692,80 @@ fn thin_box() {\n         }\n     }\n }\n+\n+#[test]\n+fn nonnull_tagged_pointer_with_provenance() {\n+    let raw_pointer = Box::into_raw(Box::new(10));\n+\n+    let mut p = TaggedPointer::new(raw_pointer).unwrap();\n+    assert_eq!(p.tag(), 0);\n+\n+    p.set_tag(1);\n+    assert_eq!(p.tag(), 1);\n+    assert_eq!(unsafe { *p.pointer().as_ptr() }, 10);\n+\n+    p.set_tag(3);\n+    assert_eq!(p.tag(), 3);\n+    assert_eq!(unsafe { *p.pointer().as_ptr() }, 10);\n+\n+    unsafe { Box::from_raw(p.pointer().as_ptr()) };\n+\n+    /// A non-null pointer type which carries several bits of metadata and maintains provenance.\n+    #[repr(transparent)]\n+    pub struct TaggedPointer<T>(NonNull<T>);\n+\n+    impl<T> Clone for TaggedPointer<T> {\n+        fn clone(&self) -> Self {\n+            Self(self.0)\n+        }\n+    }\n+\n+    impl<T> Copy for TaggedPointer<T> {}\n+\n+    impl<T> TaggedPointer<T> {\n+        /// The ABI-required minimum alignment of the `P` type.\n+        pub const ALIGNMENT: usize = core::mem::align_of::<T>();\n+        /// A mask for data-carrying bits of the address.\n+        pub const DATA_MASK: usize = !Self::ADDRESS_MASK;\n+        /// Number of available bits of storage in the address.\n+        pub const NUM_BITS: u32 = Self::ALIGNMENT.trailing_zeros();\n+        /// A mask for the non-data-carrying bits of the address.\n+        pub const ADDRESS_MASK: usize = usize::MAX << Self::NUM_BITS;\n+\n+        /// Create a new tagged pointer from a possibly null pointer.\n+        pub fn new(pointer: *mut T) -> Option<TaggedPointer<T>> {\n+            Some(TaggedPointer(NonNull::new(pointer)?))\n+        }\n+\n+        /// Consume this tagged pointer and produce a raw mutable pointer to the\n+        /// memory location.\n+        pub fn pointer(self) -> NonNull<T> {\n+            // SAFETY: The `addr` guaranteed to have bits set in the Self::ADDRESS_MASK, so the result will be non-null.\n+            self.0.map_addr(|addr| unsafe {\n+                NonZeroUsize::new_unchecked(addr.get() & Self::ADDRESS_MASK)\n+            })\n+        }\n+\n+        /// Consume this tagged pointer and produce the data it carries.\n+        pub fn tag(&self) -> usize {\n+            self.0.addr().get() & Self::DATA_MASK\n+        }\n+\n+        /// Update the data this tagged pointer carries to a new value.\n+        pub fn set_tag(&mut self, data: usize) {\n+            assert_eq!(\n+                data & Self::ADDRESS_MASK,\n+                0,\n+                \"cannot set more data beyond the lowest NUM_BITS\"\n+            );\n+            let data = data & Self::DATA_MASK;\n+\n+            // SAFETY: This value will always be non-zero because the upper bits (from\n+            // ADDRESS_MASK) will always be non-zero. This a property of the type and its\n+            // construction.\n+            self.0 = self.0.map_addr(|addr| unsafe {\n+                NonZeroUsize::new_unchecked((addr.get() & Self::ADDRESS_MASK) | data)\n+            })\n+        }\n+    }\n+}"}]}