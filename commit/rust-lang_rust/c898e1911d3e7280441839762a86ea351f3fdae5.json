{"sha": "c898e1911d3e7280441839762a86ea351f3fdae5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4OThlMTkxMWQzZTcyODA0NDE4Mzk3NjJhODZlYTM1MWYzZmRhZTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-25T12:36:24Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "fix handling of unsized types in validation; validate str to be UTF-8", "tree": {"sha": "20886a6d75c10dd69e97d17d97dd92def97aff75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20886a6d75c10dd69e97d17d97dd92def97aff75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c898e1911d3e7280441839762a86ea351f3fdae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c898e1911d3e7280441839762a86ea351f3fdae5", "html_url": "https://github.com/rust-lang/rust/commit/c898e1911d3e7280441839762a86ea351f3fdae5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c898e1911d3e7280441839762a86ea351f3fdae5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "url": "https://api.github.com/repos/rust-lang/rust/commits/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79", "html_url": "https://github.com/rust-lang/rust/commit/89cfd08b47f38f2721a00bd0a2ba2fce6f530c79"}], "stats": {"total": 714, "additions": 399, "deletions": 315}, "files": [{"sha": "77fd893b516b3bfe3d9067391c0d6c9c63ca60f7", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -29,7 +29,7 @@ use rustc::mir::interpret::{\n     Scalar, AllocId, Allocation, ConstValue, AllocType,\n };\n use interpret::{self,\n-    Place, PlaceExtra, PlaceTy, MemPlace, OpTy, Operand, Value,\n+    Place, PlaceTy, MemPlace, OpTy, Operand, Value,\n     EvalContext, StackPopCleanup, MemoryKind, Memory,\n };\n \n@@ -103,7 +103,7 @@ pub fn op_to_const<'tcx>(\n     let val = match normalized_op {\n         Err(MemPlace { ptr, align, extra }) => {\n             // extract alloc-offset pair\n-            assert_eq!(extra, PlaceExtra::None);\n+            assert!(extra.is_none());\n             let ptr = ptr.to_ptr()?;\n             let alloc = ecx.memory.get(ptr.alloc_id)?;\n             assert!(alloc.align.abi() >= align.abi());"}, {"sha": "455c3fc281a6be45b1be6da6d55ffcea13155375", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 83, "deletions": 79, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -34,7 +34,7 @@ use rustc::mir::interpret::{\n use syntax::source_map::{self, Span};\n \n use super::{\n-    Value, Operand, MemPlace, MPlaceTy, Place, PlaceExtra,\n+    Value, Operand, MemPlace, MPlaceTy, Place,\n     Memory, Machine\n };\n \n@@ -462,90 +462,94 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     /// Return the actual dynamic size and alignment of the place at the given type.\n-    /// Note that the value does not matter if the type is sized. For unsized types,\n-    /// the value has to be a fat pointer, and we only care about the \"extra\" data in it.\n-    pub fn size_and_align_of_mplace(\n+    /// Only the \"extra\" (metadata) part of the place matters.\n+    pub(super) fn size_and_align_of(\n         &self,\n-        mplace: MPlaceTy<'tcx>,\n+        metadata: Option<Scalar>,\n+        layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        if let PlaceExtra::None = mplace.extra {\n-            assert!(!mplace.layout.is_unsized());\n-            Ok(mplace.layout.size_and_align())\n-        } else {\n-            let layout = mplace.layout;\n-            assert!(layout.is_unsized());\n-            match layout.ty.sty {\n-                ty::Adt(..) | ty::Tuple(..) => {\n-                    // First get the size of all statically known fields.\n-                    // Don't use type_of::sizing_type_of because that expects t to be sized,\n-                    // and it also rounds up to alignment, which we want to avoid,\n-                    // as the unsized field's alignment could be smaller.\n-                    assert!(!layout.ty.is_simd());\n-                    debug!(\"DST layout: {:?}\", layout);\n-\n-                    let sized_size = layout.fields.offset(layout.fields.count() - 1);\n-                    let sized_align = layout.align;\n-                    debug!(\n-                        \"DST {} statically sized prefix size: {:?} align: {:?}\",\n-                        layout.ty,\n-                        sized_size,\n-                        sized_align\n-                    );\n-\n-                    // Recurse to get the size of the dynamically sized field (must be\n-                    // the last field).\n-                    let field = self.mplace_field(mplace, layout.fields.count() as u64 - 1)?;\n-                    let (unsized_size, unsized_align) = self.size_and_align_of_mplace(field)?;\n-\n-                    // FIXME (#26403, #27023): We should be adding padding\n-                    // to `sized_size` (to accommodate the `unsized_align`\n-                    // required of the unsized field that follows) before\n-                    // summing it with `sized_size`. (Note that since #26403\n-                    // is unfixed, we do not yet add the necessary padding\n-                    // here. But this is where the add would go.)\n-\n-                    // Return the sum of sizes and max of aligns.\n-                    let size = sized_size + unsized_size;\n-\n-                    // Choose max of two known alignments (combined value must\n-                    // be aligned according to more restrictive of the two).\n-                    let align = sized_align.max(unsized_align);\n-\n-                    // Issue #27023: must add any necessary padding to `size`\n-                    // (to make it a multiple of `align`) before returning it.\n-                    //\n-                    // Namely, the returned size should be, in C notation:\n-                    //\n-                    //   `size + ((size & (align-1)) ? align : 0)`\n-                    //\n-                    // emulated via the semi-standard fast bit trick:\n-                    //\n-                    //   `(size + (align-1)) & -align`\n-\n-                    Ok((size.abi_align(align), align))\n-                }\n-                ty::Dynamic(..) => {\n-                    let vtable = match mplace.extra {\n-                        PlaceExtra::Vtable(vtable) => vtable,\n-                        _ => bug!(\"Expected vtable\"),\n-                    };\n-                    // the second entry in the vtable is the dynamic size of the object.\n-                    self.read_size_and_align_from_vtable(vtable)\n-                }\n-\n-                ty::Slice(_) | ty::Str => {\n-                    let len = match mplace.extra {\n-                        PlaceExtra::Length(len) => len,\n-                        _ => bug!(\"Expected length\"),\n-                    };\n-                    let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                    Ok((elem_size * len, align))\n-                }\n+        let metadata = match metadata {\n+            None => {\n+                assert!(!layout.is_unsized());\n+                return Ok(layout.size_and_align())\n+            }\n+            Some(metadata) => {\n+                assert!(layout.is_unsized());\n+                metadata\n+            }\n+        };\n+        match layout.ty.sty {\n+            ty::Adt(..) | ty::Tuple(..) => {\n+                // First get the size of all statically known fields.\n+                // Don't use type_of::sizing_type_of because that expects t to be sized,\n+                // and it also rounds up to alignment, which we want to avoid,\n+                // as the unsized field's alignment could be smaller.\n+                assert!(!layout.ty.is_simd());\n+                debug!(\"DST layout: {:?}\", layout);\n+\n+                let sized_size = layout.fields.offset(layout.fields.count() - 1);\n+                let sized_align = layout.align;\n+                debug!(\n+                    \"DST {} statically sized prefix size: {:?} align: {:?}\",\n+                    layout.ty,\n+                    sized_size,\n+                    sized_align\n+                );\n+\n+                // Recurse to get the size of the dynamically sized field (must be\n+                // the last field).\n+                let field = layout.field(self, layout.fields.count() - 1)?;\n+                let (unsized_size, unsized_align) = self.size_and_align_of(Some(metadata), field)?;\n+\n+                // FIXME (#26403, #27023): We should be adding padding\n+                // to `sized_size` (to accommodate the `unsized_align`\n+                // required of the unsized field that follows) before\n+                // summing it with `sized_size`. (Note that since #26403\n+                // is unfixed, we do not yet add the necessary padding\n+                // here. But this is where the add would go.)\n+\n+                // Return the sum of sizes and max of aligns.\n+                let size = sized_size + unsized_size;\n+\n+                // Choose max of two known alignments (combined value must\n+                // be aligned according to more restrictive of the two).\n+                let align = sized_align.max(unsized_align);\n+\n+                // Issue #27023: must add any necessary padding to `size`\n+                // (to make it a multiple of `align`) before returning it.\n+                //\n+                // Namely, the returned size should be, in C notation:\n+                //\n+                //   `size + ((size & (align-1)) ? align : 0)`\n+                //\n+                // emulated via the semi-standard fast bit trick:\n+                //\n+                //   `(size + (align-1)) & -align`\n+\n+                Ok((size.abi_align(align), align))\n+            }\n+            ty::Dynamic(..) => {\n+                let vtable = metadata.to_ptr()?;\n+                // the second entry in the vtable is the dynamic size of the object.\n+                self.read_size_and_align_from_vtable(vtable)\n+            }\n \n-                _ => bug!(\"size_of_val::<{:?}> not supported\", layout.ty),\n+            ty::Slice(_) | ty::Str => {\n+                let len = metadata.to_usize(self)?;\n+                let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n+                Ok((elem_size * len, align))\n             }\n+\n+            _ => bug!(\"size_and_align_of::<{:?}> not supported\", layout.ty),\n         }\n     }\n+    #[inline]\n+    pub fn size_and_align_of_mplace(\n+        &self,\n+        mplace: MPlaceTy<'tcx>\n+    ) -> EvalResult<'tcx, (Size, Align)> {\n+        self.size_and_align_of(mplace.extra, mplace.layout)\n+    }\n \n     pub fn push_stack_frame(\n         &mut self,"}, {"sha": "35e3253ca7f8e8414c1092a5afb40ecfc9e13878", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -142,8 +142,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 self.mplace_field(place, 3)?,\n             );\n \n-            let msg = Symbol::intern(self.read_str(msg.into())?);\n-            let file = Symbol::intern(self.read_str(file.into())?);\n+            let msg_place = self.ref_to_mplace(self.read_value(msg.into())?)?;\n+            let msg = Symbol::intern(self.read_str(msg_place)?);\n+            let file_place = self.ref_to_mplace(self.read_value(file.into())?)?;\n+            let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n             return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n@@ -159,8 +161,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 self.mplace_field(place, 2)?,\n             );\n \n-            let msg = Symbol::intern(self.read_str(msg)?);\n-            let file = Symbol::intern(self.read_str(file.into())?);\n+            let msg_place = self.ref_to_mplace(self.read_value(msg.into())?)?;\n+            let msg = Symbol::intern(self.read_str(msg_place)?);\n+            let file_place = self.ref_to_mplace(self.read_value(file.into())?)?;\n+            let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n             return Err(EvalErrorKind::Panic { msg, file, line, col }.into());"}, {"sha": "5f58fdf589c15e7d448626ffc686b583403a9159", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -27,7 +27,7 @@ pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup, LocalValue,\n };\n \n-pub use self::place::{Place, PlaceExtra, PlaceTy, MemPlace, MPlaceTy};\n+pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind};\n "}, {"sha": "66b9861f02e70374321d7bf8eee6bf2e3143f504", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc::mir::interpret::{\n     GlobalId, ConstValue, Scalar, EvalResult, Pointer, ScalarMaybeUndef, EvalErrorKind\n };\n-use super::{EvalContext, Machine, MemPlace, MPlaceTy, PlaceExtra, MemoryKind};\n+use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n \n /// A `Value` represents a single immediate self-contained Rust value.\n ///\n@@ -65,6 +65,14 @@ impl<'tcx> Value {\n         self.to_scalar_or_undef().not_undef()\n     }\n \n+    #[inline]\n+    pub fn to_scalar_pair(self) -> EvalResult<'tcx, (Scalar, Scalar)> {\n+        match self {\n+            Value::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n+            Value::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n+        }\n+    }\n+\n     /// Convert the value into a pointer (or a pointer-sized integer).\n     /// Throws away the second half of a ScalarPair!\n     #[inline]\n@@ -74,24 +82,6 @@ impl<'tcx> Value {\n             Value::ScalarPair(ptr, _) => ptr.not_undef(),\n         }\n     }\n-\n-    pub fn to_scalar_dyn_trait(self) -> EvalResult<'tcx, (Scalar, Pointer)> {\n-        match self {\n-            Value::ScalarPair(ptr, vtable) =>\n-                Ok((ptr.not_undef()?, vtable.to_ptr()?)),\n-            _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n-        }\n-    }\n-\n-    pub fn to_scalar_slice(self, cx: impl HasDataLayout) -> EvalResult<'tcx, (Scalar, u64)> {\n-        match self {\n-            Value::ScalarPair(ptr, val) => {\n-                let len = val.to_bits(cx.data_layout().pointer_size)?;\n-                Ok((ptr.not_undef()?, len as u64))\n-            }\n-            _ => bug!(\"expected ptr and length, got {:?}\", self),\n-        }\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have a value and a type together\n@@ -242,7 +232,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         mplace: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx, Option<Value>> {\n-        if mplace.extra != PlaceExtra::None {\n+        debug_assert_eq!(mplace.extra.is_some(), mplace.layout.is_unsized());\n+        if mplace.extra.is_some() {\n+            // Dont touch unsized\n             return Ok(None);\n         }\n         let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n@@ -315,20 +307,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    // operand must be a &str or compatible layout\n+    // Turn the MPlace into a string (must already be dereferenced!)\n     pub fn read_str(\n         &self,\n-        op: OpTy<'tcx>,\n+        mplace: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx, &str> {\n-        let val = self.read_value(op)?;\n-        if let Value::ScalarPair(ptr, len) = *val {\n-            let len = len.not_undef()?.to_bits(self.memory.pointer_size())?;\n-            let bytes = self.memory.read_bytes(ptr.not_undef()?, Size::from_bytes(len as u64))?;\n-            let str = ::std::str::from_utf8(bytes).map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n-            Ok(str)\n-        } else {\n-            bug!(\"read_str: not a str\")\n-        }\n+        let len = mplace.len(self)?;\n+        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n+        let str = ::std::str::from_utf8(bytes)\n+            .map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n+        Ok(str)\n     }\n \n     pub fn uninit_operand(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Operand> {"}, {"sha": "d4300f251767be954363afd42bf2b9f857791e26", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 80, "deletions": 119, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -31,7 +31,8 @@ pub struct MemPlace {\n     /// However, it may never be undef.\n     pub ptr: Scalar,\n     pub align: Align,\n-    pub extra: PlaceExtra,\n+    /// Metadata for unsized places.  Interpretation is up to the type.\n+    pub extra: Option<Scalar>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -47,14 +48,6 @@ pub enum Place {\n     },\n }\n \n-// Extra information for fat pointers / places\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum PlaceExtra {\n-    None,\n-    Length(u64),\n-    Vtable(Pointer),\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx> {\n     place: Place,\n@@ -100,7 +93,7 @@ impl MemPlace {\n         MemPlace {\n             ptr,\n             align,\n-            extra: PlaceExtra::None,\n+            extra: None,\n         }\n     }\n \n@@ -111,7 +104,7 @@ impl MemPlace {\n \n     #[inline(always)]\n     pub fn to_scalar_ptr_align(self) -> (Scalar, Align) {\n-        assert_eq!(self.extra, PlaceExtra::None);\n+        assert_eq!(self.extra, None);\n         (self.ptr, self.align)\n     }\n \n@@ -126,13 +119,12 @@ impl MemPlace {\n \n     /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n-    pub fn to_ref(self, cx: impl HasDataLayout) -> Value {\n+    pub fn to_ref(self) -> Value {\n         // We ignore the alignment of the place here -- special handling for packed structs ends\n         // at the `&` operator.\n         match self.extra {\n-            PlaceExtra::None => Value::Scalar(self.ptr.into()),\n-            PlaceExtra::Length(len) => Value::new_slice(self.ptr.into(), len, cx),\n-            PlaceExtra::Vtable(vtable) => Value::new_dyn_trait(self.ptr.into(), vtable),\n+            None => Value::Scalar(self.ptr.into()),\n+            Some(extra) => Value::ScalarPair(self.ptr.into(), extra.into()),\n         }\n     }\n }\n@@ -144,16 +136,28 @@ impl<'tcx> MPlaceTy<'tcx> {\n     }\n \n     #[inline]\n-    pub(super) fn len(self) -> u64 {\n-        // Sanity check\n-        let ty_len = match self.layout.fields {\n-            layout::FieldPlacement::Array { count, .. } => count,\n-            _ => bug!(\"Length for non-array layout {:?} requested\", self.layout),\n-        };\n-        if let PlaceExtra::Length(len) = self.extra {\n-            len\n-        } else {\n-            ty_len\n+    pub(super) fn len(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n+        match self.layout.ty.sty {\n+            ty::Array(..) => {\n+                // Sized, get length from layout.\n+                debug_assert!(self.extra.is_none());\n+                match self.layout.fields {\n+                    layout::FieldPlacement::Array { count, .. } => Ok(count),\n+                    _ => bug!(\"Length for non-array layout {:?} requested\", self.layout),\n+                }\n+            }\n+            ty::Slice(..) | ty::Str => {\n+                self.extra.unwrap().to_usize(cx)\n+            }\n+            _ => bug!(\"len not supported on type {:?}\", self.layout.ty),\n+        }\n+    }\n+\n+    #[inline]\n+    pub(super) fn vtable(self) -> EvalResult<'tcx, Pointer> {\n+        match self.layout.ty.sty {\n+            ty::Dynamic(..) => self.extra.unwrap().to_ptr(),\n+            _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n     }\n }\n@@ -231,33 +235,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n-        let mplace = match self.tcx.struct_tail(pointee_type).sty {\n-            // Matching on the type is okay here, because we used `struct_tail` to get to\n-            // the \"core\" of what makes this unsized.\n-            ty::Dynamic(..) => {\n-                let (ptr, vtable) = val.to_scalar_dyn_trait()?;\n-                MemPlace {\n-                    ptr,\n-                    align: layout.align,\n-                    extra: PlaceExtra::Vtable(vtable),\n-                }\n-            }\n-            ty::Str | ty::Slice(_) => {\n-                let (ptr, len) = val.to_scalar_slice(self)?;\n-                MemPlace {\n-                    ptr,\n-                    align: layout.align,\n-                    extra: PlaceExtra::Length(len),\n-                }\n-            }\n-            _ => {\n-                assert!(!layout.is_unsized(), \"Unhandled unsized type {:?}\", pointee_type);\n-                MemPlace {\n-                    ptr: val.to_scalar()?,\n-                    align: layout.align,\n-                    extra: PlaceExtra::None,\n-                }\n-            }\n+        let mplace = if layout.is_unsized() {\n+            let (ptr, extra) = val.to_scalar_pair()?;\n+            MemPlace { ptr, align: layout.align, extra: Some(extra) }\n+        } else {\n+            MemPlace { ptr: val.to_scalar()?, align: layout.align, extra: None }\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }\n@@ -276,9 +258,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } =>\n                 offsets[usize::try_from(field).unwrap()],\n             layout::FieldPlacement::Array { stride, .. } => {\n-                let len = base.len();\n-                assert!(field < len,\n-                        \"Tried to access element {} of array/slice with length {}\", field, len);\n+                let len = base.len(self)?;\n+                assert!(field < len, \"Tried to access element {} of array/slice with length {}\",\n+                    field, len);\n                 stride * field\n             }\n             layout::FieldPlacement::Union(count) => {\n@@ -292,29 +274,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // above). In that case, all fields are equal.\n         let field_layout = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n \n-        // Adjust offset\n-        let offset = match base.extra {\n-            PlaceExtra::Vtable(vtable) => {\n-                let (_, align) = self.read_size_and_align_from_vtable(vtable)?;\n-                // FIXME: Is this right? Should we always do this, or only when actually\n-                // accessing the field to which the vtable applies?\n-                offset.abi_align(align)\n-            }\n-            _ => {\n-                // No adjustment needed\n-                offset\n-            }\n-        };\n+        // Offset may need adjustment for unsized fields\n+        let (extra, offset) = if field_layout.is_unsized() {\n+            // re-use parent metadata to determine dynamic field layout\n+            let (_, align) = self.size_and_align_of(base.extra, field_layout)?;\n+            (base.extra, offset.abi_align(align))\n \n-        let ptr = base.ptr.ptr_offset(offset, self)?;\n-        let align = base.align.min(field_layout.align);\n-        let extra = if !field_layout.is_unsized() {\n-            PlaceExtra::None\n         } else {\n-            assert!(base.extra != PlaceExtra::None, \"Expected fat ptr\");\n-            base.extra\n+            // base.extra could be present; we might be accessing a sized field of an unsized\n+            // struct.\n+            (None, offset)\n         };\n \n+        let ptr = base.ptr.ptr_offset(offset, self)?;\n+        let align = base.align.min(field_layout.align); // only use static information\n+\n         Ok(MPlaceTy { mplace: MemPlace { ptr, align, extra }, layout: field_layout })\n     }\n \n@@ -324,7 +298,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         base: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx, impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx>>> + 'a> {\n-        let len = base.len();\n+        let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n             layout::FieldPlacement::Array { stride, .. } => stride,\n             _ => bug!(\"mplace_array_fields: expected an array layout\"),\n@@ -334,7 +308,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok((0..len).map(move |i| {\n             let ptr = base.ptr.ptr_offset(i * stride, dl)?;\n             Ok(MPlaceTy {\n-                mplace: MemPlace { ptr, align: base.align, extra: PlaceExtra::None },\n+                mplace: MemPlace { ptr, align: base.align, extra: None },\n                 layout\n             })\n         }))\n@@ -346,7 +320,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         from: u64,\n         to: u64,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n-        let len = base.len();\n+        let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         assert!(from <= len - to);\n \n         // Not using layout method because that works with usize, and does not work with slices\n@@ -364,9 +338,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n             ty::Array(inner, _) =>\n-                (PlaceExtra::None, self.tcx.mk_array(inner, inner_len)),\n-            ty::Slice(..) =>\n-                (PlaceExtra::Length(inner_len), base.layout.ty),\n+                (None, self.tcx.mk_array(inner, inner_len)),\n+            ty::Slice(..) => {\n+                let len = Scalar::Bits {\n+                    bits: inner_len.into(),\n+                    size: self.memory.pointer_size().bytes() as u8\n+                };\n+                (Some(len), base.layout.ty)\n+            }\n             _ =>\n                 bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n         };\n@@ -384,7 +363,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         variant: usize,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         // Downcasts only change the layout\n-        assert_eq!(base.extra, PlaceExtra::None);\n+        assert_eq!(base.extra, None);\n         Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n     }\n \n@@ -413,7 +392,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 min_length,\n                 from_end,\n             } => {\n-                let n = base.len();\n+                let n = base.len(self)?;\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -773,43 +752,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(OpTy { op, layout: place.layout })\n     }\n \n-    /// Turn a place that is a dyn trait (i.e., PlaceExtra::Vtable and the appropriate layout)\n-    /// or a slice into the specific fixed-size place and layout that is given by the vtable/len.\n-    /// This \"unpacks\" the existential quantifier, so to speak.\n-    pub fn unpack_unsized_mplace(\n-        &self,\n-        mplace: MPlaceTy<'tcx>\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n-        trace!(\"Unpacking {:?} ({:?})\", *mplace, mplace.layout.ty);\n-        let layout = match mplace.extra {\n-            PlaceExtra::Vtable(vtable) => {\n-                // the drop function signature\n-                let drop_instance = self.read_drop_type_from_vtable(vtable)?;\n-                trace!(\"Found drop fn: {:?}\", drop_instance);\n-                let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n-                let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n-                // the drop function takes *mut T where T is the type being dropped, so get that\n-                let ty = fn_sig.inputs()[0].builtin_deref(true).unwrap().ty;\n-                let layout = self.layout_of(ty)?;\n-                // Sanity checks\n-                let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n-                assert_eq!(size, layout.size);\n-                assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n-                // FIXME: More checks for the vtable? We could make sure it is exactly\n-                // the one one would expect for this type.\n-                // Done!\n-                layout\n-            },\n-            PlaceExtra::Length(len) => {\n-                let ty = self.tcx.mk_array(mplace.layout.field(self, 0)?.ty, len);\n-                self.layout_of(ty)?\n-            }\n-            PlaceExtra::None => bug!(\"Expected a fat pointer\"),\n-        };\n-        trace!(\"Unpacked type: {:?}\", layout.ty);\n-        Ok(MPlaceTy {\n-            mplace: MemPlace { extra: PlaceExtra::None, ..*mplace },\n+    /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n+    /// Also return some more information so drop doesn't have to run the same code twice.\n+    pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx>)\n+    -> EvalResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx>)> {\n+        let vtable = mplace.vtable()?; // also sanity checks the type\n+        let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n+        let layout = self.layout_of(ty)?;\n+\n+        // More sanity checks\n+        let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n+        assert_eq!(size, layout.size);\n+        assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n+        // FIXME: More checks for the vtable? We could make sure it is exactly\n+        // the one one would expect for this type.\n+\n+        let mplace = MPlaceTy {\n+            mplace: MemPlace { extra: None, ..*mplace },\n             layout\n-        })\n+        };\n+        Ok((instance, mplace))\n     }\n }"}, {"sha": "933f06d3d10a0b9da935d2f70ec44c769913fdc2", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Repeat(ref operand, _) => {\n                 let op = self.eval_operand(operand, None)?;\n                 let dest = self.force_allocation(dest)?;\n-                let length = dest.len();\n+                let length = dest.len(&self)?;\n \n                 if length > 0 {\n                     // write the first\n@@ -268,7 +268,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n                 let mplace = self.force_allocation(src)?;\n-                let len = mplace.len();\n+                let len = mplace.len(&self)?;\n                 let size = self.memory.pointer_size().bytes() as u8;\n                 self.write_scalar(\n                     Scalar::Bits {\n@@ -281,7 +281,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n-                let val = self.force_allocation(src)?.to_ref(&self);\n+                let val = self.force_allocation(src)?.to_ref();\n                 self.write_value(val, dest)?;\n             }\n "}, {"sha": "e637633b90b09b2f898947fabf2753210766b510", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -16,7 +16,7 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, Scalar};\n use super::{\n-    EvalContext, Machine, Value, OpTy, Place, PlaceTy, PlaceExtra, ValTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -419,7 +419,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n-                let (ptr, vtable) = self.read_value(args[0])?.to_scalar_dyn_trait()?;\n+                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let vtable = ptr.vtable()?;\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n@@ -433,7 +434,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n                 let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n                 args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(&self, 0)?;\n-                args[0].op = Operand::Immediate(Value::Scalar(ptr.into())); // strip vtable\n+                args[0].op = Operand::Immediate(Value::Scalar(ptr.ptr.into())); // strip vtable\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(instance, &args, dest, ret, span, sig)\n@@ -457,19 +458,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let (instance, place) = match place.layout.ty.sty {\n             ty::Dynamic(..) => {\n                 // Dropping a trait object.\n-                let vtable = match place.extra {\n-                    PlaceExtra::Vtable(vtable) => vtable,\n-                    _ => bug!(\"Expected vtable when dropping {:#?}\", place),\n-                };\n-                let place = self.unpack_unsized_mplace(place)?;\n-                let instance = self.read_drop_type_from_vtable(vtable)?;\n-                (instance, place)\n+                self.unpack_dyn_trait(place)?\n             }\n             _ => (instance, place),\n         };\n \n         let arg = OpTy {\n-            op: Operand::Immediate(place.to_ref(&self)),\n+            op: Operand::Immediate(place.to_ref()),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n "}, {"sha": "74567b429749175bbfd6f3a17df1d03a41903290", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -76,14 +76,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(vtable)\n     }\n \n+    /// Return the drop fn instance as well as the actual dynamic type\n     pub fn read_drop_type_from_vtable(\n         &self,\n         vtable: Pointer,\n-    ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    ) -> EvalResult<'tcx, (ty::Instance<'tcx>, ty::Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n         let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.to_ptr()?;\n-        self.memory.get_fn(drop_fn)\n+        let drop_instance = self.memory.get_fn(drop_fn)?;\n+        trace!(\"Found drop fn: {:?}\", drop_instance);\n+        let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n+        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n+        // the drop function takes *mut T where T is the type being dropped, so get that\n+        let ty = fn_sig.inputs()[0].builtin_deref(true).unwrap().ty;\n+        Ok((drop_instance, ty))\n     }\n \n     pub fn read_size_and_align_from_vtable("}, {"sha": "e72be125878b6bf0773ff501b398ca0708a3d95a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 108, "deletions": 38, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    /// This function checks the data at `op`.  The operand must be sized.\n+    /// This function checks the data at `op`.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     /// The `path` may be pushed to, but the part that is present when the function\n     /// starts must not be changed!\n@@ -208,14 +208,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout::Variants::Tagged { .. } => {\n                 let variant = match self.read_discriminant(dest) {\n                     Ok(res) => res.1,\n-                    Err(err) => match err.kind {\n-                        EvalErrorKind::InvalidDiscriminant |\n-                        EvalErrorKind::ReadPointerAsBytes =>\n-                            return validation_failure!(\n-                                \"invalid enum discriminant\", path\n-                            ),\n-                        _ => return Err(err),\n-                    }\n+                    Err(_) =>\n+                        return validation_failure!(\n+                            \"invalid enum discriminant\", path\n+                        ),\n                 };\n                 let inner_dest = self.operand_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field\n@@ -227,6 +223,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 (variant, inner_dest)\n             },\n             layout::Variants::Single { index } => {\n+                // Pre-processing for trait objects: Treat them at their real type.\n+                // (We do not do this for slices and strings: For slices it is not needed,\n+                // `mplace_array_fields` does the right thing, and for strings there is no\n+                // real type that would show the actual length.)\n+                let dest = match dest.layout.ty.sty {\n+                    ty::Dynamic(..) => {\n+                        let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n+                        match self.unpack_dyn_trait(dest) {\n+                            Ok(res) => res.1.into(),\n+                            Err(_) =>\n+                                return validation_failure!(\n+                                    \"invalid vtable in fat pointer\", path\n+                                ),\n+                        }\n+                    }\n+                    _ => dest\n+                };\n                 (index, dest)\n             }\n         };\n@@ -249,7 +262,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     // expectation.\n                     layout::Abi::Scalar(ref scalar_layout) => {\n                         let size = scalar_layout.value.size(self);\n-                        let value = self.read_value(dest)?;\n+                        let value = match self.read_value(dest) {\n+                            Ok(val) => val,\n+                            Err(err) => match err.kind {\n+                                EvalErrorKind::PointerOutOfBounds { .. } |\n+                                EvalErrorKind::ReadUndefBytes =>\n+                                    return validation_failure!(\n+                                        \"uninitialized or out-of-bounds memory\", path\n+                                    ),\n+                                _ =>\n+                                    return validation_failure!(\n+                                        \"unrepresentable data\", path\n+                                    ),\n+                            }\n+                        };\n                         let scalar = value.to_scalar_or_undef();\n                         self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n                         if scalar_layout.value == Primitive::Pointer {\n@@ -283,44 +309,88 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // The fields don't need to correspond to any bit pattern of the union's fields.\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n             },\n-            layout::FieldPlacement::Array { .. } => {\n-                // FIXME: For a TyStr, check that this is valid UTF-8.\n-                // Skips for ZSTs; we could have an empty array as an immediate\n-                if !dest.layout.is_zst() {\n-                    let dest = dest.to_mem_place(); // arrays cannot be immediate\n-                    for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n-                        let field = field?;\n-                        path.push(PathElem::ArrayElem(i));\n-                        self.validate_operand(field.into(), path, seen, todo)?;\n-                        path.truncate(path_len);\n+            layout::FieldPlacement::Array { .. } if !dest.layout.is_zst() => {\n+                let dest = dest.to_mem_place(); // non-ZST array/slice/str cannot be immediate\n+                // Special handling for strings to verify UTF-8\n+                match dest.layout.ty.sty {\n+                    ty::Str => {\n+                        match self.read_str(dest) {\n+                            Ok(_) => {},\n+                            Err(err) => match err.kind {\n+                                EvalErrorKind::PointerOutOfBounds { .. } |\n+                                EvalErrorKind::ReadUndefBytes =>\n+                                    // The error here looks slightly different than it does\n+                                    // for slices, because we do not report the index into the\n+                                    // str at which we are OOB.\n+                                    return validation_failure!(\n+                                        \"uninitialized or out-of-bounds memory\", path\n+                                    ),\n+                                _ =>\n+                                    return validation_failure!(\n+                                        \"non-UTF-8 data in str\", path\n+                                    ),\n+                            }\n+                        }\n+                    }\n+                    ty::Array(..) | ty::Slice(..) => {\n+                        // This handles the unsized case correctly as well\n+                        for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n+                            let field = field?;\n+                            path.push(PathElem::ArrayElem(i));\n+                            self.validate_operand(field.into(), path, seen, todo)?;\n+                            path.truncate(path_len);\n+                        }\n                     }\n+                    _ => bug!(\"Array layout for non-array type {:?}\", dest.layout.ty),\n                 }\n             },\n+            layout::FieldPlacement::Array { .. } => {\n+                // An empty array.  Nothing to do.\n+            }\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // Fat pointers need special treatment.\n+                // Fat pointers are treated like pointers, not aggregates.\n                 if dest.layout.ty.builtin_deref(true).is_some() {\n                     // This is a fat pointer.\n-                    let ptr = match self.ref_to_mplace(self.read_value(dest.into())?) {\n+                    let ptr = match self.read_value(dest.into())\n+                        .and_then(|val| self.ref_to_mplace(val))\n+                    {\n                         Ok(ptr) => ptr,\n-                        Err(err) => match err.kind {\n-                            EvalErrorKind::ReadPointerAsBytes =>\n-                                return validation_failure!(\n-                                    \"fat pointer length is not a valid integer\", path\n-                                ),\n-                            EvalErrorKind::ReadBytesAsPointer =>\n-                                return validation_failure!(\n-                                    \"fat pointer vtable is not a valid pointer\", path\n-                                ),\n-                            _ => return Err(err),\n-                        }\n+                        Err(_) =>\n+                            return validation_failure!(\n+                                \"undefined metadata in fat pointer\", path\n+                            ),\n                     };\n-                    let unpacked_ptr = self.unpack_unsized_mplace(ptr)?.into();\n+                    // check metadata\n+                    match self.tcx.struct_tail(ptr.layout.ty).sty {\n+                        ty::Dynamic(..) => {\n+                            match ptr.extra.unwrap().to_ptr() {\n+                                Ok(_) => {},\n+                                Err(_) =>\n+                                    return validation_failure!(\n+                                        \"non-pointer vtable in fat pointer\", path\n+                                    ),\n+                            }\n+                        }\n+                        ty::Slice(..) | ty::Str => {\n+                            match ptr.extra.unwrap().to_usize(self) {\n+                                Ok(_) => {},\n+                                Err(_) =>\n+                                    return validation_failure!(\n+                                        \"non-integer slice length in fat pointer\", path\n+                                    ),\n+                            }\n+                        }\n+                        _ =>\n+                            bug!(\"Unexpected unsized type tail: {:?}\",\n+                                self.tcx.struct_tail(ptr.layout.ty)\n+                            ),\n+                    }\n                     // for safe ptrs, recursively check it\n                     if !dest.layout.ty.is_unsafe_ptr() {\n-                        if seen.insert(unpacked_ptr) {\n-                            trace!(\"Recursing below fat ptr {:?} (unpacked: {:?})\",\n-                                ptr, unpacked_ptr);\n-                            todo.push((unpacked_ptr, path_clone_and_deref(path)));\n+                        let ptr = ptr.into();\n+                        if seen.insert(ptr) {\n+                            trace!(\"Recursing below fat ptr {:?}\", ptr);\n+                            todo.push((ptr, path_clone_and_deref(path)));\n                         }\n                     }\n                 } else {"}, {"sha": "0c42d28eb00f49d148cd8fcb5929a932b2e06539", "filename": "src/test/ui/union-ub-fat-ptr.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused)]\n+\n // normalize-stderr-test \"alignment \\d+\" -> \"alignment N\"\n // normalize-stderr-test \"offset \\d+\" -> \"offset N\"\n // normalize-stderr-test \"allocation \\d+\" -> \"allocation N\"\n@@ -37,7 +39,8 @@ union SliceTransmute {\n     bad: BadSliceRepr,\n     slice: &'static [u8],\n     str: &'static str,\n-    my_str: &'static Str,\n+    my_str: &'static MyStr,\n+    my_slice: &'static MySliceBool,\n }\n \n #[repr(C)]\n@@ -71,7 +74,12 @@ union DynTransmute {\n trait Trait {}\n impl Trait for bool {}\n \n-struct Str(str);\n+// custom unsized type\n+struct MyStr(str);\n+\n+// custom unsized type with sized fields\n+struct MySlice<T: ?Sized>(bool, T);\n+type MySliceBool = MySlice<[bool]>;\n \n // OK\n const A: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n@@ -81,8 +89,8 @@ const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 }\n // bad str\n const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n //~^ ERROR this constant likely exhibits undefined behavior\n-// bad str in Str\n-const C2: &Str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+// bad str in user-defined unsized type\n+const C2: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n //~^ ERROR this constant likely exhibits undefined behavior\n \n // OK\n@@ -107,10 +115,25 @@ const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3\n // bad data *inside* the trait object\n const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n //~^ ERROR this constant likely exhibits undefined behavior\n-\n // bad data *inside* the slice\n const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n //~^ ERROR this constant likely exhibits undefined behavior\n \n+// good MySliceBool\n+const I1: &MySliceBool = &MySlice(true, [false]);\n+// bad: sized field is not okay\n+const I2: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n+//~^ ERROR this constant likely exhibits undefined behavior\n+// bad: unsized part is not okay\n+const I3: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// invalid UTF-8\n+const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+// invalid UTF-8 in user-defined str-like\n+const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n fn main() {\n }"}, {"sha": "5d817dce205b15091e6829790629ec3ab9cd1c0c", "filename": "src/test/ui/union-ub-fat-ptr.stderr", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c898e1911d3e7280441839762a86ea351f3fdae5/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr?ref=c898e1911d3e7280441839762a86ea351f3fdae5", "patch": "@@ -1,83 +1,115 @@\n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:79:1\n+  --> $DIR/union-ub-fat-ptr.rs:87:1\n    |\n LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or out-of-bounds memory at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:82:1\n+  --> $DIR/union-ub-fat-ptr.rs:90:1\n    |\n LL | const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:85:1\n+  --> $DIR/union-ub-fat-ptr.rs:93:1\n    |\n-LL | const C2: &Str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n+LL | const C2: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:91:1\n+  --> $DIR/union-ub-fat-ptr.rs:99:1\n    |\n LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or out-of-bounds memory at .<deref>[1]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:94:1\n+  --> $DIR/union-ub-fat-ptr.rs:102:1\n    |\n LL | const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:98:1\n+  --> $DIR/union-ub-fat-ptr.rs:106:1\n    |\n LL | const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ tried to access memory with alignment N, but alignment N is required\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid vtable in fat pointer at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:101:1\n+  --> $DIR/union-ub-fat-ptr.rs:109:1\n    |\n LL | const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a memory access tried to interpret some bytes as a pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid vtable in fat pointer at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:104:1\n+  --> $DIR/union-ub-fat-ptr.rs:112:1\n    |\n LL | const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer vtable is not a valid pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-pointer vtable in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:108:1\n+  --> $DIR/union-ub-fat-ptr.rs:116:1\n    |\n LL | const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:112:1\n+  --> $DIR/union-ub-fat-ptr.rs:119:1\n    |\n LL | const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 10 previous errors\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:125:1\n+   |\n+LL | const I2: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected something in the range 0..=1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:128:1\n+   |\n+LL | const I3: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected something in the range 0..=1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:132:1\n+   |\n+LL | const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-UTF-8 data in str at .<deref>\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:135:1\n+   |\n+LL | const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-UTF-8 data in str at .<deref>.0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 14 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}