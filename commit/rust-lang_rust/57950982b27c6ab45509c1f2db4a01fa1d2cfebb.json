{"sha": "57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3OTUwOTgyYjI3YzZhYjQ1NTA5YzFmMmRiNGEwMWZhMWQyY2ZlYmI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-11-09T21:09:28Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-11-12T18:08:03Z"}, "message": "rustc_trans: translate closures using the collector\n\nTranslate closures like normal functions, using the trans::collector\ninterface.", "tree": {"sha": "31999422c25805650003d783c1b6d789829bb228", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31999422c25805650003d783c1b6d789829bb228"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "html_url": "https://github.com/rust-lang/rust/commit/57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6828fd1acf11272b05c32010f9071d3e8862e76", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6828fd1acf11272b05c32010f9071d3e8862e76", "html_url": "https://github.com/rust-lang/rust/commit/b6828fd1acf11272b05c32010f9071d3e8862e76"}], "stats": {"total": 645, "additions": 241, "deletions": 404}, "files": [{"sha": "c7cad6455bc30e17a472a32abea52587e2546074", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -1003,34 +1003,41 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     }\n }\n \n-/// Builds an LLVM function out of a source function.\n-///\n-/// If the function closes over its environment a closure will be returned.\n-pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               llfndecl: ValueRef,\n-                               instance: Instance<'tcx>,\n-                               sig: &ty::FnSig<'tcx>,\n-                               abi: Abi) {\n+pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n+    let _s = StatRecorder::new(ccx, ccx.tcx().item_path_str(instance.def));\n+    // this is an info! to allow collecting monomorphization statistics\n+    // and to allow finding the last function before LLVM aborts from\n+    // release builds.\n+    info!(\"trans_instance({})\", instance);\n+\n+    let _icx = push_ctxt(\"trans_instance\");\n+\n+    let fn_ty = ccx.tcx().item_type(instance.def);\n+    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n+    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n+\n+    let ty::BareFnTy { abi, ref sig, .. } = *common::ty_fn_ty(ccx, fn_ty);\n+    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n+\n+    let lldecl = match ccx.instances().borrow().get(&instance) {\n+        Some(&val) => val,\n+        None => bug!(\"Instance `{:?}` not already declared\", instance)\n+    };\n+\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n-    let _icx = push_ctxt(\"trans_closure\");\n     if !ccx.sess().no_landing_pads() {\n-        attributes::emit_uwtable(llfndecl, true);\n+        attributes::emit_uwtable(lldecl, true);\n     }\n \n-    // this is an info! to allow collecting monomorphization statistics\n-    // and to allow finding the last function before LLVM aborts from\n-    // release builds.\n-    info!(\"trans_closure(..., {})\", instance);\n-\n-    let fn_ty = FnType::new(ccx, abi, sig, &[]);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx,\n-                               llfndecl,\n+                               lldecl,\n                                fn_ty,\n-                               Some((instance, sig, abi)),\n+                               Some((instance, &sig, abi)),\n                                &arena);\n \n     if fcx.mir.is_none() {\n@@ -1040,26 +1047,6 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     mir::trans_mir(&fcx);\n }\n \n-pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx().item_path_str(instance.def));\n-    debug!(\"trans_instance(instance={:?})\", instance);\n-    let _icx = push_ctxt(\"trans_instance\");\n-\n-    let fn_ty = ccx.tcx().item_type(instance.def);\n-    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n-    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n-\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(fn_ty.fn_sig());\n-    let abi = fn_ty.fn_abi();\n-\n-    let lldecl = match ccx.instances().borrow().get(&instance) {\n-        Some(&val) => val,\n-        None => bug!(\"Instance `{:?}` not already declared\", instance)\n-    };\n-\n-    trans_closure(ccx, lldecl, instance, &sig, abi);\n-}\n-\n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,"}, {"sha": "faf65f3f98b0928d12d9b928faa7daeecda238d7", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 171, "deletions": 6, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -26,11 +26,11 @@ use attributes;\n use base;\n use base::*;\n use build::*;\n-use closure;\n use common::{self, Block, Result, CrateContext, FunctionContext, SharedCrateContext};\n use consts;\n use debuginfo::DebugLoc;\n use declare;\n+use value::Value;\n use meth;\n use monomorphize::{self, Instance};\n use trans_item::TransItem;\n@@ -147,11 +147,12 @@ impl<'tcx> Callee<'tcx> {\n                 // after passing through fulfill_obligation\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 let instance = Instance::new(def_id, substs);\n-                let llfn = closure::trans_closure_method(ccx,\n-                                                         vtable_closure.closure_def_id,\n-                                                         vtable_closure.substs,\n-                                                         instance,\n-                                                         trait_closure_kind);\n+                let llfn = trans_closure_method(\n+                    ccx,\n+                    vtable_closure.closure_def_id,\n+                    vtable_closure.substs,\n+                    instance,\n+                    trait_closure_kind);\n \n                 let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n@@ -250,6 +251,170 @@ fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n     monomorphize::apply_param_substs(shared, substs, &ty)\n }\n \n+\n+fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                                  def_id: DefId,\n+                                  substs: ty::ClosureSubsts<'tcx>,\n+                                  method_instance: Instance<'tcx>,\n+                                  trait_closure_kind: ty::ClosureKind)\n+                                  -> ValueRef\n+{\n+    // If this is a closure, redirect to it.\n+    let (llfn, _) = get_fn(ccx, def_id, substs.substs);\n+\n+    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n+    // then adapt the self type\n+    let llfn_closure_kind = ccx.tcx().closure_kind(def_id);\n+\n+    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n+\n+    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n+           trait_closure_kind={:?}, llfn={:?})\",\n+           llfn_closure_kind, trait_closure_kind, Value(llfn));\n+\n+    match (llfn_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+            // No adapter needed.\n+            llfn\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            llfn\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            trans_fn_once_adapter_shim(ccx, def_id, substs, method_instance, llfn)\n+        }\n+        _ => {\n+            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                 llfn_closure_kind,\n+                 trait_closure_kind);\n+        }\n+    }\n+}\n+\n+fn trans_fn_once_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    method_instance: Instance<'tcx>,\n+    llreffn: ValueRef)\n+    -> ValueRef\n+{\n+    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n+        return llfn;\n+    }\n+\n+    debug!(\"trans_fn_once_adapter_shim(def_id={:?}, substs={:?}, llreffn={:?})\",\n+           def_id, substs, Value(llreffn));\n+\n+    let tcx = ccx.tcx();\n+\n+    // Find a version of the closure type. Substitute static for the\n+    // region since it doesn't really matter.\n+    let closure_ty = tcx.mk_closure_from_closure_substs(def_id, substs);\n+    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n+\n+    // Make a version with the type of by-ref closure.\n+    let ty::ClosureTy { unsafety, abi, mut sig } = tcx.closure_type(def_id, substs);\n+    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n+    let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: unsafety,\n+        abi: abi,\n+        sig: sig.clone()\n+    }));\n+    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n+           llref_fn_ty);\n+\n+\n+    // Make a version of the closure type with the same arguments, but\n+    // with argument #0 being by value.\n+    assert_eq!(abi, Abi::RustCall);\n+    sig.0.inputs[0] = closure_ty;\n+\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n+\n+    let llonce_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: unsafety,\n+        abi: abi,\n+        sig: ty::Binder(sig)\n+    }));\n+\n+    // Create the by-value helper.\n+    let function_name = method_instance.symbol_name(ccx.shared());\n+    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n+    attributes::set_frame_pointer_elimination(ccx, lloncefn);\n+\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n+    let mut bcx = fcx.init(false);\n+\n+\n+    // the first argument (`self`) will be the (by value) closure env.\n+\n+    let mut llargs = get_params(fcx.llfn);\n+    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let env_arg = &fcx.fn_ty.args[0];\n+    let llenv = if env_arg.is_indirect() {\n+        llargs[self_idx]\n+    } else {\n+        let scratch = alloc_ty(bcx, closure_ty, \"self\");\n+        let mut llarg_idx = self_idx;\n+        env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, scratch);\n+        scratch\n+    };\n+\n+    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n+    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n+    // For zero-sized closures that means sneaking in a new argument.\n+    if env_arg.is_ignore() {\n+        if self_idx > 0 {\n+            self_idx -= 1;\n+            llargs[self_idx] = llenv;\n+        } else {\n+            llargs.insert(0, llenv);\n+        }\n+    } else {\n+        llargs[self_idx] = llenv;\n+    }\n+\n+    let dest = fcx.llretslotptr.get();\n+\n+    let callee = Callee {\n+        data: Fn(llreffn),\n+        ty: llref_fn_ty\n+    };\n+\n+    // Call the by-ref closure body with `self` in a cleanup scope,\n+    // to drop `self` when the body returns, or in case it unwinds.\n+    let self_scope = fcx.push_custom_cleanup_scope();\n+    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n+\n+    bcx = callee.call(bcx, DebugLoc::None, &llargs[self_idx..], dest).bcx;\n+\n+    fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n+\n+    fcx.finish(bcx, DebugLoc::None);\n+\n+    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n+\n+    lloncefn\n+}\n+\n /// Translates an adapter that implements the `Fn` trait for a fn\n /// pointer. This is basically the equivalent of something like:\n ///"}, {"sha": "0cefc49cb425eb42020b7a6f23b2438ca69444e4", "filename": "src/librustc_trans/closure.rs", "status": "removed", "additions": 0, "deletions": 318, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/b6828fd1acf11272b05c32010f9071d3e8862e76/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6828fd1acf11272b05c32010f9071d3e8862e76/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=b6828fd1acf11272b05c32010f9071d3e8862e76", "patch": "@@ -1,318 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use arena::TypedArena;\n-use llvm::{self, ValueRef, get_params};\n-use rustc::hir::def_id::DefId;\n-use abi::{Abi, FnType};\n-use attributes;\n-use base::*;\n-use callee::{self, Callee};\n-use common::*;\n-use debuginfo::{DebugLoc};\n-use declare;\n-use monomorphize::{Instance};\n-use value::Value;\n-use rustc::ty::{self, Ty, TyCtxt};\n-\n-use rustc::hir;\n-\n-fn get_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           closure_id: DefId,\n-                           fn_ty: Ty<'tcx>)\n-                           -> Ty<'tcx> {\n-    match tcx.closure_kind(closure_id) {\n-        ty::ClosureKind::Fn => {\n-            tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), fn_ty)\n-        }\n-        ty::ClosureKind::FnMut => {\n-            tcx.mk_mut_ref(tcx.mk_region(ty::ReErased), fn_ty)\n-        }\n-        ty::ClosureKind::FnOnce => fn_ty,\n-    }\n-}\n-\n-/// Returns the LLVM function declaration for a closure, creating it if\n-/// necessary. If the ID does not correspond to a closure ID, returns None.\n-fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               closure_id: DefId,\n-                                               substs: ty::ClosureSubsts<'tcx>)\n-                                               -> ValueRef {\n-    // Normalize type so differences in regions and typedefs don't cause\n-    // duplicate declarations\n-    let tcx = ccx.tcx();\n-    let substs = tcx.erase_regions(&substs);\n-    let instance = Instance::new(closure_id, substs.substs);\n-\n-    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-        debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\",\n-               instance, Value(llfn));\n-        return llfn;\n-    }\n-\n-    let symbol = instance.symbol_name(ccx.shared());\n-\n-    // Compute the rust-call form of the closure call method.\n-    let sig = &tcx.closure_type(closure_id, substs).sig;\n-    let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-    let closure_type = tcx.mk_closure_from_closure_substs(closure_id, substs);\n-    let function_type = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: hir::Unsafety::Normal,\n-        abi: Abi::RustCall,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: Some(get_self_type(tcx, closure_id, closure_type))\n-                        .into_iter().chain(sig.inputs).collect(),\n-            output: sig.output,\n-            variadic: false\n-        })\n-    }));\n-    let llfn = declare::declare_fn(ccx, &symbol, function_type);\n-\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-\n-    debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n-            closure {:?}: {:?}\",\n-           instance, Value(llfn));\n-\n-    // NOTE: We do *not* store llfn in the ccx.instances() map here,\n-    //       that is only done, when the closures body is translated.\n-\n-    llfn\n-}\n-\n-pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                            closure_def_id: DefId,\n-                                            closure_substs: ty::ClosureSubsts<'tcx>) {\n-    // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n-    // defid of the closure in its original crate, whereas `id` will be the id of the local\n-    // inlined copy.\n-    debug!(\"trans_closure_body_via_mir(closure_def_id={:?}, closure_substs={:?})\",\n-           closure_def_id, closure_substs);\n-\n-    let tcx = ccx.tcx();\n-    let _icx = push_ctxt(\"closure::trans_closure_expr\");\n-\n-    let instance = Instance::new(closure_def_id, closure_substs.substs);\n-\n-    // If we have not done so yet, translate this closure's body\n-    if  !ccx.instances().borrow().contains_key(&instance) {\n-        let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n-\n-        unsafe {\n-            if ccx.sess().target.target.options.allows_weak_linkage {\n-                llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::WeakODRLinkage);\n-                llvm::SetUniqueComdat(ccx.llmod(), llfn);\n-            } else {\n-                llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage);\n-            }\n-        }\n-\n-        // set an inline hint for all closures\n-        attributes::inline(llfn, attributes::InlineAttr::Hint);\n-\n-        // Get the type of this closure. Use the current `param_substs` as\n-        // the closure substitutions. This makes sense because the closure\n-        // takes the same set of type arguments as the enclosing fn, and\n-        // this function (`trans_closure`) is invoked at the point\n-        // of the closure expression.\n-\n-        let sig = &tcx.closure_type(closure_def_id, closure_substs).sig;\n-        let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-\n-        let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n-                                                              closure_substs);\n-        let sig = ty::FnSig {\n-            inputs: Some(get_self_type(tcx, closure_def_id, closure_type))\n-                        .into_iter().chain(sig.inputs).collect(),\n-            output: sig.output,\n-            variadic: false\n-        };\n-\n-        trans_closure(ccx,\n-                      llfn,\n-                      instance,\n-                      &sig,\n-                      Abi::RustCall);\n-\n-        ccx.instances().borrow_mut().insert(instance, llfn);\n-    }\n-}\n-\n-pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                      closure_def_id: DefId,\n-                                      substs: ty::ClosureSubsts<'tcx>,\n-                                      method_instance: Instance<'tcx>,\n-                                      trait_closure_kind: ty::ClosureKind)\n-                                      -> ValueRef\n-{\n-    // If this is a closure, redirect to it.\n-    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, substs);\n-\n-    // If weak linkage is not allowed, we have to make sure that a local,\n-    // private copy of the closure is available in this codegen unit\n-    if !ccx.sess().target.target.options.allows_weak_linkage &&\n-       !ccx.sess().opts.single_codegen_unit() {\n-\n-        trans_closure_body_via_mir(ccx, closure_def_id, substs);\n-    }\n-\n-    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n-    // then adapt the self type\n-    let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);\n-\n-    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n-\n-    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n-           trait_closure_kind={:?}, llfn={:?})\",\n-           llfn_closure_kind, trait_closure_kind, Value(llfn));\n-\n-    match (llfn_closure_kind, trait_closure_kind) {\n-        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n-            // No adapter needed.\n-            llfn\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n-            // `fn(&mut self, ...)`. In fact, at trans time, these are\n-            // basically the same thing, so we can just return llfn.\n-            llfn\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n-            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n-            // this by doing something like:\n-            //\n-            //     fn call_once(self, ...) { call_mut(&self, ...) }\n-            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-            //\n-            // These are both the same at trans time.\n-            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, method_instance, llfn)\n-        }\n-        _ => {\n-            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                 llfn_closure_kind,\n-                 trait_closure_kind);\n-        }\n-    }\n-}\n-\n-fn trans_fn_once_adapter_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    closure_def_id: DefId,\n-    substs: ty::ClosureSubsts<'tcx>,\n-    method_instance: Instance<'tcx>,\n-    llreffn: ValueRef)\n-    -> ValueRef\n-{\n-    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n-        return llfn;\n-    }\n-\n-    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={:?})\",\n-           closure_def_id, substs, Value(llreffn));\n-\n-    let tcx = ccx.tcx();\n-\n-    // Find a version of the closure type. Substitute static for the\n-    // region since it doesn't really matter.\n-    let closure_ty = tcx.mk_closure_from_closure_substs(closure_def_id, substs);\n-    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n-\n-    // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } =\n-        tcx.closure_type(closure_def_id, substs);\n-    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n-    let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: sig.clone()\n-    }));\n-    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n-           llref_fn_ty);\n-\n-\n-    // Make a version of the closure type with the same arguments, but\n-    // with argument #0 being by value.\n-    assert_eq!(abi, Abi::RustCall);\n-    sig.0.inputs[0] = closure_ty;\n-\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n-    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n-\n-    let llonce_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: ty::Binder(sig)\n-    }));\n-\n-    // Create the by-value helper.\n-    let function_name = method_instance.symbol_name(ccx.shared());\n-    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n-    attributes::set_frame_pointer_elimination(ccx, lloncefn);\n-\n-    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n-    let mut bcx = fcx.init(false);\n-\n-\n-    // the first argument (`self`) will be the (by value) closure env.\n-\n-    let mut llargs = get_params(fcx.llfn);\n-    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n-    let env_arg = &fcx.fn_ty.args[0];\n-    let llenv = if env_arg.is_indirect() {\n-        llargs[self_idx]\n-    } else {\n-        let scratch = alloc_ty(bcx, closure_ty, \"self\");\n-        let mut llarg_idx = self_idx;\n-        env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, scratch);\n-        scratch\n-    };\n-\n-    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n-    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n-    // For zero-sized closures that means sneaking in a new argument.\n-    if env_arg.is_ignore() {\n-        if self_idx > 0 {\n-            self_idx -= 1;\n-            llargs[self_idx] = llenv;\n-        } else {\n-            llargs.insert(0, llenv);\n-        }\n-    } else {\n-        llargs[self_idx] = llenv;\n-    }\n-\n-    let dest = fcx.llretslotptr.get();\n-\n-    let callee = Callee {\n-        data: callee::Fn(llreffn),\n-        ty: llref_fn_ty\n-    };\n-\n-    // Call the by-ref closure body with `self` in a cleanup scope,\n-    // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.push_custom_cleanup_scope();\n-    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n-\n-    bcx = callee.call(bcx, DebugLoc::None, &llargs[self_idx..], dest).bcx;\n-\n-    fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n-\n-    fcx.finish(bcx, DebugLoc::None);\n-\n-    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n-\n-    lloncefn\n-}"}, {"sha": "2728a666556e43c90da4b4a7e665defe56647e02", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -446,24 +446,6 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n-                                                               ref substs), _) => {\n-                let mir = self.scx.tcx().item_mir(def_id);\n-\n-                let concrete_substs = monomorphize::apply_param_substs(self.scx,\n-                                                                       self.param_substs,\n-                                                                       &substs.substs);\n-                let concrete_substs = self.scx.tcx().erase_regions(&concrete_substs);\n-\n-                let visitor = MirNeighborCollector {\n-                    scx: self.scx,\n-                    mir: &mir,\n-                    output: self.output,\n-                    param_substs: concrete_substs\n-                };\n-\n-                visit_mir_and_promoted(visitor, &mir);\n-            }\n             // When doing an cast from a regular pointer to a fat pointer, we\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n@@ -888,10 +870,12 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         traits::VtableImpl(impl_data) => {\n             Some(traits::find_method(tcx, trait_method.name, rcvr_substs, &impl_data))\n         }\n-        // If we have a closure or a function pointer, we will also encounter\n-        // the concrete closure/function somewhere else (during closure or fn\n-        // pointer construction). That's where we track those things.\n-        traits::VtableClosure(..) |\n+        traits::VtableClosure(closure_data) => {\n+            Some((closure_data.closure_def_id, closure_data.substs.substs))\n+        }\n+        // Trait object and function pointer shims are always\n+        // instantiated in-place, and as they are just an ABI-adjusting\n+        // indirect call they do not have any dependencies.\n         traits::VtableFnPointer(..) |\n         traits::VtableObject(..) => {\n             None"}, {"sha": "a0fac9cc6599eeaa9e98761e0e1360c3066c519d", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -44,6 +44,8 @@ use rustc::hir;\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n+use std::borrow::Cow;\n+use std::iter;\n use std::ops::Deref;\n use std::ffi::CString;\n use std::cell::{Cell, RefCell, Ref};\n@@ -1069,3 +1071,32 @@ pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n+\n+pub fn ty_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                          ty: Ty<'tcx>)\n+                          -> Cow<'tcx, ty::BareFnTy<'tcx>>\n+{\n+    match ty.sty {\n+        ty::TyFnDef(_, _, fty) => Cow::Borrowed(fty),\n+        // Shims currently have type TyFnPtr. Not sure this should remain.\n+        ty::TyFnPtr(fty) => Cow::Borrowed(fty),\n+        ty::TyClosure(def_id, substs) => {\n+            let tcx = ccx.tcx();\n+            let ty::ClosureTy { unsafety, abi, sig } = tcx.closure_type(def_id, substs);\n+\n+            let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n+            let env_ty = match tcx.closure_kind(def_id) {\n+                ty::ClosureKind::Fn => tcx.mk_imm_ref(tcx.mk_region(env_region), ty),\n+                ty::ClosureKind::FnMut => tcx.mk_mut_ref(tcx.mk_region(env_region), ty),\n+                ty::ClosureKind::FnOnce => ty,\n+            };\n+\n+            let sig = sig.map_bound(|sig| ty::FnSig {\n+                inputs: iter::once(env_ty).chain(sig.inputs).collect(),\n+                ..sig\n+            });\n+            Cow::Owned(ty::BareFnTy { unsafety: unsafety, abi: abi, sig: sig })\n+        }\n+        _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n+    }\n+}"}, {"sha": "662e3bec66db874cad34a8920558e7bb0962f928", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -25,6 +25,7 @@ use rustc::ty;\n use abi::{Abi, FnType};\n use attributes;\n use context::CrateContext;\n+use common;\n use type_::Type;\n use value::Value;\n \n@@ -103,8 +104,8 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                             fn_type: ty::Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n-    let abi = fn_type.fn_abi();\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(fn_type.fn_sig());\n+    let ty::BareFnTy { abi, ref sig, .. } = *common::ty_fn_ty(ccx, fn_type);\n+    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n     let fty = FnType::new(ccx, abi, &sig, &[]);"}, {"sha": "0757343a8af574f6c390e17696be7170976fcaba", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -109,7 +109,6 @@ mod cabi_x86_64;\n mod cabi_x86_win64;\n mod callee;\n mod cleanup;\n-mod closure;\n mod collector;\n mod common;\n mod consts;"}, {"sha": "bca81fa36458f4726c2041d696148e1ed811e6fe", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -553,14 +553,6 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n                 failure?;\n \n-                // FIXME Shouldn't need to manually trigger closure instantiations.\n-                if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n-                    use closure;\n-                    closure::trans_closure_body_via_mir(self.ccx,\n-                                                        def_id,\n-                                                        self.monomorphize(&substs));\n-                }\n-\n                 match *kind {\n                     mir::AggregateKind::Array => {\n                         self.const_array(dest_ty, &fields)"}, {"sha": "bf01db0ffd3255eb7fa926b7bde38bb57333efcf", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -133,15 +133,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     },\n                     _ => {\n-                        // FIXME Shouldn't need to manually trigger closure instantiations.\n-                        if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n-                            use closure;\n-\n-                            closure::trans_closure_body_via_mir(bcx.ccx(),\n-                                                                def_id,\n-                                                                bcx.monomorphize(&substs));\n-                        }\n-\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields."}, {"sha": "c5a7dbbcf54800642c8ee202fd3bee7106a58621", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57950982b27c6ab45509c1f2db4a01fa1d2cfebb/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "patch": "@@ -166,6 +166,11 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n         }\n \n+        if let ty::TyClosure(..) = mono_ty.sty {\n+            // set an inline hint for all closures\n+            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+        }\n+\n         attributes::from_fn_attrs(ccx, &attrs, lldecl);\n \n         ccx.instances().borrow_mut().insert(instance, lldecl);"}]}