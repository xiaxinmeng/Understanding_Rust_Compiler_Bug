{"sha": "fb72be0a8990f530d20437bf9d11a31fcffc5a9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNzJiZTBhODk5MGY1MzBkMjA0MzdiZjlkMTFhMzFmY2ZmYzVhOWQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-01T10:36:49Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-01T15:50:52Z"}, "message": "Do not store a tag num for single-variant tags\n\nThis is a preparation for tags-as-nominal-types. A tag that has only a\nsingle variant is now represented, at run-time, as simply a tuple of\nthe variant's parameters, with the variant id left off.", "tree": {"sha": "f276a3fc8aa75ebab81eed92fb9bcadcbddc0639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f276a3fc8aa75ebab81eed92fb9bcadcbddc0639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb72be0a8990f530d20437bf9d11a31fcffc5a9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb72be0a8990f530d20437bf9d11a31fcffc5a9d", "html_url": "https://github.com/rust-lang/rust/commit/fb72be0a8990f530d20437bf9d11a31fcffc5a9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb72be0a8990f530d20437bf9d11a31fcffc5a9d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf20fe557588563d8070869f5ebe187c7ba0ba9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf20fe557588563d8070869f5ebe187c7ba0ba9e", "html_url": "https://github.com/rust-lang/rust/commit/bf20fe557588563d8070869f5ebe187c7ba0ba9e"}], "stats": {"total": 261, "additions": 142, "deletions": 119}, "files": [{"sha": "b1e87e0134b4cc3869964b714d011ffb510f1805", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 142, "deletions": 119, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/fb72be0a8990f530d20437bf9d11a31fcffc5a9d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb72be0a8990f530d20437bf9d11a31fcffc5a9d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fb72be0a8990f530d20437bf9d11a31fcffc5a9d", "patch": "@@ -809,14 +809,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n         case (ty::ty_char) { llty = T_char(); }\n         case (ty::ty_str) { llty = T_ptr(T_str()); }\n         case (ty::ty_istr) { llty = T_ivec(T_i8()); }\n-        case (ty::ty_tag(_, _)) {\n-            if (ty::type_has_dynamic_size(cx.tcx, t)) {\n-                llty = T_opaque_tag(cx.tn);\n-            } else {\n-                auto size = static_size_of_tag(cx, sp, t);\n-                llty = T_tag(cx.tn, size);\n-            }\n-        }\n+        case (ty::ty_tag(?did, _)) { llty = type_of_tag(cx, sp, did, t); }\n         case (ty::ty_box(?mt)) {\n             llty = T_ptr(T_box(type_of_inner(cx, sp, mt.ty)));\n         }\n@@ -894,6 +887,22 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n     ret llty;\n }\n \n+fn type_of_tag(&@crate_ctxt cx, &span sp, &ast::def_id did, &ty::t t)\n+    -> TypeRef {\n+    auto degen = vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n+    if (ty::type_has_dynamic_size(cx.tcx, t)) {\n+        if (degen) { ret T_i8(); }\n+        else { ret T_opaque_tag(cx.tn); }\n+    } else {\n+        auto size = static_size_of_tag(cx, sp, t);\n+        if (!degen) { ret T_tag(cx.tn, size); }\n+        // LLVM does not like 0-size arrays, apparently\n+        if (size == 0u) { size = 1u; }\n+        ret T_array(T_i8(), size);\n+    }\n+}\n+\n+\n fn type_of_arg(@local_ctxt cx, &span sp, &ty::arg arg) -> TypeRef {\n     alt (ty::struct(cx.ccx.tcx, arg.ty)) {\n         case (ty::ty_param(_)) {\n@@ -1339,7 +1348,9 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n                 bcx.build.Store(umax(bcx, this_size, old_max_size), max_size);\n             }\n             auto max_size_val = bcx.build.Load(max_size);\n-            auto total_size = bcx.build.Add(max_size_val, llsize_of(T_int()));\n+            auto total_size = if (vec::len(variants) != 1u) {\n+                bcx.build.Add(max_size_val, llsize_of(T_int()))\n+            } else { max_size_val };\n             ret rslt(bcx, total_size);\n         }\n         case (ty::ty_ivec(?mt)) {\n@@ -2535,6 +2546,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         r.bcx.build.Br(next_cx.llbb);\n         ret rslt(next_cx, C_nil());\n     }\n+\n     fn iter_ivec(@block_ctxt bcx, ValueRef av, ValueRef bv, ty::t unit_ty,\n                  &val_pair_and_ty_fn f) -> result {\n         // FIXME: \"unimplemented rebinding existing function\" workaround\n@@ -2603,6 +2615,42 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n \n         ret rslt(next_cx, C_nil());\n     }\n+\n+    fn iter_variant(@block_ctxt cx, ValueRef a_tup, ValueRef b_tup,\n+                    &ty::variant_info variant, &vec[ty::t] tps,\n+                    &ast::def_id tid, &val_pair_and_ty_fn f) -> result {\n+        if (vec::len[ty::t](variant.args) == 0u) {\n+            ret rslt(cx, C_nil());\n+        }\n+        auto fn_ty = variant.ctor_ty;\n+        auto ccx = cx.fcx.lcx.ccx;\n+        alt (ty::struct(ccx.tcx, fn_ty)) {\n+            case (ty::ty_fn(_, ?args, _, _, _)) {\n+                auto j = 0;\n+                for (ty::arg a in args) {\n+                    auto rslt = GEP_tag(cx, a_tup, tid,\n+                                        variant.id, tps, j);\n+                    auto llfldp_a = rslt.val;\n+                    cx = rslt.bcx;\n+                    rslt = GEP_tag(cx, b_tup, tid,\n+                                   variant.id, tps, j);\n+                    auto llfldp_b = rslt.val;\n+                    cx = rslt.bcx;\n+                    auto ty_subst =\n+                        ty::substitute_type_params(ccx.tcx, tps, a.ty);\n+                    auto llfld_a =\n+                        load_if_immediate(cx, llfldp_a, ty_subst);\n+                    auto llfld_b =\n+                        load_if_immediate(cx, llfldp_b, ty_subst);\n+                    rslt = f(cx, llfld_a, llfld_b, ty_subst);\n+                    cx = rslt.bcx;\n+                    j += 1;\n+                }\n+            }\n+        }\n+        ret rslt(cx, C_nil());\n+    }\n+    \n     let result r = rslt(cx, C_nil());\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_tup(?args)) {\n@@ -2612,8 +2660,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                 auto elt_a = r.val;\n                 r = GEP_tup_like(r.bcx, t, bv, [0, i]);\n                 auto elt_b = r.val;\n-                r =\n-                    f(r.bcx, load_if_immediate(r.bcx, elt_a, arg.ty),\n+                r = f(r.bcx, load_if_immediate(r.bcx, elt_a, arg.ty),\n                       load_if_immediate(r.bcx, elt_b, arg.ty), arg.ty);\n                 i += 1;\n             }\n@@ -2625,8 +2672,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                 auto llfld_a = r.val;\n                 r = GEP_tup_like(r.bcx, t, bv, [0, i]);\n                 auto llfld_b = r.val;\n-                r =\n-                    f(r.bcx, load_if_immediate(r.bcx, llfld_a, fld.mt.ty),\n+                r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, fld.mt.ty),\n                       load_if_immediate(r.bcx, llfld_b, fld.mt.ty),\n                       fld.mt.ty);\n                 i += 1;\n@@ -2644,8 +2690,12 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         }\n         case (ty::ty_tag(?tid, ?tps)) {\n             auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, tid);\n-            auto n_variants = vec::len[ty::variant_info](variants);\n+            auto n_variants = vec::len(variants);\n+\n             // Cast the tags to types we can GEP into.\n+            if (n_variants == 1u) {\n+                ret iter_variant(cx, av, bv, variants.(0), tps, tid, f);\n+            }\n \n             auto lltagty = T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn);\n             auto av_tag = cx.build.PointerCast(av, lltagty);\n@@ -2656,9 +2706,9 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             auto lldiscrim_b_ptr = cx.build.GEP(bv_tag, [C_int(0), C_int(0)]);\n             auto llunion_b_ptr = cx.build.GEP(bv_tag, [C_int(0), C_int(1)]);\n             auto lldiscrim_b = cx.build.Load(lldiscrim_b_ptr);\n+\n             // NB: we must hit the discriminant first so that structural\n             // comparison know not to proceed when the discriminants differ.\n-\n             auto bcx = cx;\n             bcx =\n                 f(bcx, lldiscrim_a, lldiscrim_b,\n@@ -2675,47 +2725,10 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                                        \"tag-iter-variant-\" +\n                                            uint::to_str(i, 10u));\n                 llvm::LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n-                if (vec::len[ty::t](variant.args) > 0u) {\n-                    // N-ary variant.\n-\n-                    auto fn_ty = variant.ctor_ty;\n-                    alt (ty::struct(bcx.fcx.lcx.ccx.tcx, fn_ty)) {\n-                        case (ty::ty_fn(_, ?args, _, _, _)) {\n-                            auto j = 0;\n-                            for (ty::arg a in args) {\n-                                auto rslt =\n-                                    GEP_tag(variant_cx, llunion_a_ptr, tid,\n-                                            variant.id, tps, j);\n-                                auto llfldp_a = rslt.val;\n-                                variant_cx = rslt.bcx;\n-                                rslt =\n-                                    GEP_tag(variant_cx, llunion_b_ptr, tid,\n-                                            variant.id, tps, j);\n-                                auto llfldp_b = rslt.val;\n-                                variant_cx = rslt.bcx;\n-                                auto tcx = cx.fcx.lcx.ccx.tcx;\n-                                auto ty_subst =\n-                                    ty::substitute_type_params(tcx, tps,\n-                                                               a.ty);\n-                                auto llfld_a =\n-                                    load_if_immediate(variant_cx, llfldp_a,\n-                                                      ty_subst);\n-                                auto llfld_b =\n-                                    load_if_immediate(variant_cx, llfldp_b,\n-                                                      ty_subst);\n-                                rslt =\n-                                    f(variant_cx, llfld_a, llfld_b, ty_subst);\n-                                variant_cx = rslt.bcx;\n-                                j += 1;\n-                            }\n-                        }\n-                    }\n-                    variant_cx.build.Br(next_cx.llbb);\n-                } else {\n-                    // Nullary variant; nothing to do.\n-\n-                    variant_cx.build.Br(next_cx.llbb);\n-                }\n+                variant_cx = iter_variant\n+                    (variant_cx, llunion_a_ptr, llunion_b_ptr, variant,\n+                     tps, tid, f).bcx;\n+                variant_cx.build.Br(next_cx.llbb);\n                 i += 1u;\n             }\n             ret rslt(next_cx, C_nil());\n@@ -4614,34 +4627,43 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             ret rslt(matched_cx, llval);\n         }\n         case (ast::pat_tag(?ident, ?subpats, ?id)) {\n-            auto lltagptr =\n-                cx.build.PointerCast(llval,\n-                                     T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n-            auto lldiscrimptr = cx.build.GEP(lltagptr, [C_int(0), C_int(0)]);\n-            auto lldiscrim = cx.build.Load(lldiscrimptr);\n             auto vdef =\n                 ast::variant_def_ids(cx.fcx.lcx.ccx.tcx.def_map.get(id));\n-            auto variant_tag = 0;\n             auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0);\n-            auto i = 0;\n-            for (ty::variant_info v in variants) {\n-                auto this_variant_id = v.id;\n-                if (vdef._1._0 == this_variant_id._0 &&\n+            auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n+            auto llblobptr = llval;\n+\n+            if (vec::len(variants) == 1u) {\n+                cx.build.Br(matched_cx.llbb);\n+            } else {\n+                auto lltagptr =\n+                    cx.build.PointerCast(llval,\n+                                         T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n+                auto lldiscrimptr = cx.build.GEP(lltagptr,\n+                                                 [C_int(0), C_int(0)]);\n+                auto lldiscrim = cx.build.Load(lldiscrimptr);\n+                auto variant_tag = 0;\n+                auto i = 0;\n+                for (ty::variant_info v in variants) {\n+                    auto this_variant_id = v.id;\n+                    if (vdef._1._0 == this_variant_id._0 &&\n                         vdef._1._1 == this_variant_id._1) {\n-                    variant_tag = i;\n+                        variant_tag = i;\n+                    }\n+                    i += 1;\n+                }\n+                auto lleq =\n+                    cx.build.ICmp(lib::llvm::LLVMIntEQ, lldiscrim,\n+                                  C_int(variant_tag));\n+                cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n+                if (vec::len(subpats) > 0u) {\n+                    llblobptr =\n+                        matched_cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n                 }\n-                i += 1;\n             }\n-            auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n-            auto lleq =\n-                cx.build.ICmp(lib::llvm::LLVMIntEQ, lldiscrim,\n-                              C_int(variant_tag));\n-            cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n             auto ty_params = ty::node_id_to_type_params\n                 (cx.fcx.lcx.ccx.tcx, id);\n-            if (vec::len[@ast::pat](subpats) > 0u) {\n-                auto llblobptr =\n-                    matched_cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n+            if (vec::len(subpats) > 0u) {\n                 auto i = 0;\n                 for (@ast::pat subpat in subpats) {\n                     auto rslt =\n@@ -4690,10 +4712,12 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n \n             auto vdef =\n                 ast::variant_def_ids(cx.fcx.lcx.ccx.tcx.def_map.get(id));\n-            auto lltagptr =\n-                cx.build.PointerCast(llval,\n-                                     T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n-            auto llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n+            auto llblobptr = llval;\n+            if (vec::len(ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0))!=1u) {\n+                auto lltagptr = cx.build.PointerCast\n+                    (llval, T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n+                llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n+            }\n             auto ty_param_substs =\n                 ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, id);\n             auto this_cx = cx;\n@@ -4828,6 +4852,7 @@ fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n }\n \n fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n+    auto ccx = cx.fcx.lcx.ccx;\n     alt (cx.fcx.lcx.ccx.tcx.def_map.get(id)) {\n         case (ast::def_arg(?did)) {\n             alt (cx.fcx.llargs.find(did._1)) {\n@@ -4856,56 +4881,49 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n             ret lval_mem(cx, cx.fcx.llobjfields.get(did._1));\n         }\n         case (ast::def_fn(?did, _)) {\n-            auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n+            auto tyt = ty::lookup_item_type(ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, id);\n         }\n         case (ast::def_variant(?tid, ?vid)) {\n-            auto v_tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, vid);\n-            alt (ty::struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n+            auto v_tyt = ty::lookup_item_type(ccx.tcx, vid);\n+            alt (ty::struct(ccx.tcx, v_tyt._1)) {\n                 case (ty::ty_fn(_, _, _, _, _)) {\n                     // N-ary variant.\n \n                     ret lval_generic_fn(cx, v_tyt, vid, id);\n                 }\n                 case (_) {\n                     // Nullary variant.\n-\n-                    auto tag_ty = node_id_type(cx.fcx.lcx.ccx, id);\n-                    auto lldiscrim_gv =\n-                        lookup_discriminant(cx.fcx.lcx, tid, vid);\n-                    auto lldiscrim = cx.build.Load(lldiscrim_gv);\n+                    auto tag_ty = node_id_type(ccx, id);\n                     auto alloc_result = alloc_ty(cx, tag_ty);\n                     auto lltagblob = alloc_result.val;\n-                    auto lltagty;\n-                    if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, tag_ty))\n-                       {\n-                        lltagty = T_opaque_tag(cx.fcx.lcx.ccx.tn);\n-                    } else {\n-                        lltagty = type_of(cx.fcx.lcx.ccx, p.span, tag_ty);\n+                    auto lltagty = type_of_tag(ccx, p.span, tid, tag_ty);\n+                    auto bcx = alloc_result.bcx;\n+                    auto lltagptr = bcx.build.PointerCast\n+                        (lltagblob, T_ptr(lltagty));\n+                    if (vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u) {\n+                        auto lldiscrim_gv =\n+                            lookup_discriminant(bcx.fcx.lcx, tid, vid);\n+                        auto lldiscrim = bcx.build.Load(lldiscrim_gv);\n+                        auto lldiscrimptr = bcx.build.GEP\n+                            (lltagptr, [C_int(0), C_int(0)]);\n+                        bcx.build.Store(lldiscrim, lldiscrimptr);\n                     }\n-                    auto lltagptr =\n-                        alloc_result.bcx.build.PointerCast(lltagblob,\n-                                                           T_ptr(lltagty));\n-                    auto lldiscrimptr =\n-                        alloc_result.bcx.build.GEP(lltagptr,\n-                                                   [C_int(0), C_int(0)]);\n-                    alloc_result.bcx.build.Store(lldiscrim, lldiscrimptr);\n-                    ret lval_val(alloc_result.bcx, lltagptr);\n+                    ret lval_val(bcx, lltagptr);\n                 }\n             }\n         }\n         case (ast::def_const(?did)) {\n             // TODO: externals\n-\n-            assert (cx.fcx.lcx.ccx.consts.contains_key(did._1));\n-            ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did._1));\n+            assert (ccx.consts.contains_key(did._1));\n+            ret lval_mem(cx, ccx.consts.get(did._1));\n         }\n         case (ast::def_native_fn(?did)) {\n-            auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n+            auto tyt = ty::lookup_item_type(ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, id);\n         }\n         case (_) {\n-            cx.fcx.lcx.ccx.sess.span_unimpl(cx.sp, \"def variant in trans\");\n+            ccx.sess.span_unimpl(cx.sp, \"def variant in trans\");\n         }\n     }\n }\n@@ -5538,7 +5556,6 @@ fn trans_arg_expr(&@block_ctxt cx, &ty::arg arg, TypeRef lldestty0,\n         // \"undef\" value, as such a value should never\n         // be inspected. It's important for the value\n         // to have type lldestty0 (the callee's expected type).\n-\n         val = llvm::LLVMGetUndef(lldestty0);\n     } else if (ty::type_contains_params(cx.fcx.lcx.ccx.tcx, arg.ty)) {\n         auto lldestty = lldestty0;\n@@ -7920,7 +7937,7 @@ fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n \n \n fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n-                     &ast::variant variant, int index,\n+                     &ast::variant variant, int index, bool is_degen,\n                      &vec[ast::ty_param] ty_params) {\n     if (vec::len[ast::variant_arg](variant.node.args) == 0u) {\n         ret; // nullary constructors are just constants\n@@ -7953,13 +7970,17 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n-    // Cast the tag to a type we can GEP into.\n \n-    auto lltagptr =\n-        bcx.build.PointerCast(fcx.llretptr, T_opaque_tag_ptr(fcx.lcx.ccx.tn));\n-    auto lldiscrimptr = bcx.build.GEP(lltagptr, [C_int(0), C_int(0)]);\n-    bcx.build.Store(C_int(index), lldiscrimptr);\n-    auto llblobptr = bcx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n+    auto llblobptr = if (is_degen) {\n+        fcx.llretptr\n+    } else {\n+        // Cast the tag to a type we can GEP into.\n+        auto lltagptr = bcx.build.PointerCast\n+            (fcx.llretptr, T_opaque_tag_ptr(fcx.lcx.ccx.tn));\n+        auto lldiscrimptr = bcx.build.GEP(lltagptr, [C_int(0), C_int(0)]);\n+        bcx.build.Store(C_int(index), lldiscrimptr);\n+        bcx.build.GEP(lltagptr, [C_int(0), C_int(1)])\n+    };\n     i = 0u;\n     for (ast::variant_arg va in variant.node.args) {\n         auto rslt =\n@@ -8040,9 +8061,10 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n         }\n         case (ast::item_tag(?variants, ?tps)) {\n             auto sub_cx = extend_path(cx, item.ident);\n+            auto degen = vec::len(variants) == 1u;\n             auto i = 0;\n             for (ast::variant variant in variants) {\n-                trans_tag_variant(sub_cx, item.id, variant, i, tps);\n+                trans_tag_variant(sub_cx, item.id, variant, i, degen, tps);\n                 i += 1;\n             }\n         }\n@@ -8427,13 +8449,14 @@ fn trans_constant(@crate_ctxt ccx, &@ast::item it, &vec[str] pt,\n             auto n_variants = vec::len[ast::variant](variants);\n             while (i < n_variants) {\n                 auto variant = variants.(i);\n-                auto discrim_val = C_int(i as int);\n                 auto p = new_pt + [it.ident, variant.node.name, \"discrim\"];\n                 auto s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n                 auto discrim_gvar =\n                     llvm::LLVMAddGlobal(ccx.llmod, T_int(), str::buf(s));\n-                llvm::LLVMSetInitializer(discrim_gvar, discrim_val);\n-                llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n+                if (n_variants != 1u) {\n+                    llvm::LLVMSetInitializer(discrim_gvar, C_int(i as int));\n+                    llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n+                }\n                 ccx.discrims.insert(variant.node.id, discrim_gvar);\n                 ccx.discrim_symbols.insert(variant.node.id, s);\n                 i += 1u;"}]}