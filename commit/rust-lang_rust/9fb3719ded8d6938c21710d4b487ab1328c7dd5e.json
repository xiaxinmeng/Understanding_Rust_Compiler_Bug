{"sha": "9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYjM3MTlkZWQ4ZDY5MzhjMjE3MTBkNGI0ODdhYjEzMjhjN2RkNWU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-23T09:56:10Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-23T10:02:27Z"}, "message": "Rollback return-by-reference\n\nIt's proving too inflexible, so I'm ripping out the extra complexity\nin the hope that regions will, at some point, provide something\nsimilar.\n\nCloses #918", "tree": {"sha": "6612e313512e59a050093108962e371616d0eab9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6612e313512e59a050093108962e371616d0eab9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "html_url": "https://github.com/rust-lang/rust/commit/9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "html_url": "https://github.com/rust-lang/rust/commit/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5"}], "stats": {"total": 420, "additions": 50, "deletions": 370}, "files": [{"sha": "70e87824ad0d538b5569ccd723efb3d4347109ef", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -55,11 +55,6 @@ fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, len: uint,\n fn parse_ret_ty(st: @pstate, sd: str_def) -> (ast::ret_style, ty::t) {\n     alt peek(st) as char {\n       '!' { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n-      '&' | '^' {\n-        let mut = next(st) == '^' as u8;\n-        let arg = next(st) as uint;\n-        (ast::return_ref(mut, arg), parse_ty(st, sd))\n-      }\n       _ { (ast::return_val, parse_ty(st, sd)) }\n     }\n }"}, {"sha": "4f3d51e0714e12f9aa2ad1d8c2c319506cb55055", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -214,11 +214,6 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, args: [ty::arg], out: ty::t,\n     }\n     alt cf {\n       noreturn. { w.write_char('!'); }\n-      return_ref(mut, arg) {\n-        w.write_char(mut ? '^' : '&');\n-        w.write_bytes([arg as u8]);\n-        enc_ty(w, cx, out);\n-      }\n       _ { enc_ty(w, cx, out); }\n     }\n }"}, {"sha": "e3353e3d483078b1103370a3b7eab316fca92fdb", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 110, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -28,10 +28,8 @@ type binding = @{node_id: node_id,\n                  unsafe_tys: [unsafe_ty],\n                  mutable copied: copied};\n \n-tag ret_info { by_ref(bool, node_id); other; }\n // FIXME it may be worthwhile to use a linked list of bindings instead\n type scope = {bs: [binding],\n-              ret_info: ret_info,\n               invalid: @mutable list<@invalid>};\n \n fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n@@ -67,7 +65,7 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_block: bind visit_block(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n-    let sc = {bs: [], ret_info: other, invalid: @mutable list::nil};\n+    let sc = {bs: [], invalid: @mutable list::nil};\n     visit::visit_crate(*crate, sc, visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n     ret (cx.copy_map, cx.ref_map);\n@@ -84,24 +82,12 @@ fn visit_fn(cx: @ctx, f: ast::_fn, _tp: [ast::ty_param], sp: span,\n         }\n     }\n \n-    if ast_util::ret_by_ref(f.decl.cf) && !is_none(f.body.node.expr) {\n-        // FIXME this will be easier to lift once have DPS\n-        err(*cx, option::get(f.body.node.expr).span,\n-            \"reference-returning functions may not return implicitly\");\n-    }\n-    let ret_info = alt f.decl.cf {\n-      ast::return_ref(mut, n_arg) {\n-        by_ref(mut, f.decl.inputs[n_arg - 1u].id)\n-      }\n-      _ { other }\n-    };\n     // Blocks need to obey any restrictions from the enclosing scope, and may\n     // be called multiple times.\n     if f.proto == ast::proto_block {\n-        let sc = {ret_info: ret_info with sc};\n         check_loop(*cx, sc) {|| v.visit_block(f.body, sc, v);}\n     } else {\n-        let sc = {bs: [], ret_info: ret_info, invalid: @mutable list::nil};\n+        let sc = {bs: [], invalid: @mutable list::nil};\n         v.visit_block(f.body, sc, v);\n     }\n }\n@@ -134,17 +120,6 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n       ast::expr_assign(dest, src) | ast::expr_assign_op(_, dest, src) {\n         check_assign(cx, dest, src, sc, v);\n       }\n-      ast::expr_ret(oexpr) {\n-        if !is_none(oexpr) {\n-            alt sc.ret_info {\n-              by_ref(mut, arg_node_id) {\n-                check_ret_ref(*cx, sc, mut, arg_node_id, option::get(oexpr));\n-              }\n-              _ {}\n-            }\n-        }\n-        handled = false;\n-      }\n       ast::expr_if(c, then, els) { check_if(c, then, els, sc, v); }\n       ast::expr_while(_, _) | ast::expr_do_while(_, _) {\n         check_loop(*cx, sc) {|| visit::visit_expr(ex, sc, v); }\n@@ -237,9 +212,6 @@ fn cant_copy(cx: ctx, b: binding) -> bool {\n fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n     -> [binding] {\n     let fty = ty::expr_ty(cx.tcx, f);\n-    let by_ref = alt ty::ty_fn_ret_style(cx.tcx, fty) {\n-      ast::return_ref(_, arg_n) { arg_n } _ { 0u }\n-    };\n     let arg_ts = ty::ty_fn_args(cx.tcx, fty);\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n     let bindings = [];\n@@ -265,7 +237,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n                        mutable copied: alt arg_t.mode {\n                          ast::by_move. | ast::by_copy. { copied }\n                          ast::by_mut_ref. { not_allowed }\n-                         _ { i + 1u == by_ref ? not_allowed : not_copied }\n+                         _ { not_copied }\n                        }}];\n         i += 1u;\n     }\n@@ -338,69 +310,6 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n     ret bindings;\n }\n \n-fn check_ret_ref(cx: ctx, sc: scope, mut: bool, arg_node_id: node_id,\n-                 expr: @ast::expr) {\n-    let root = expr_root(cx, expr, false);\n-    let bad = none;\n-    let mut_field = !is_none(root.mut);\n-    alt path_def(cx, root.ex) {\n-      none. {\n-        bad = some(\"a temporary\");\n-      }\n-      some(ast::def_local(did, _)) | some(ast::def_binding(did)) |\n-      some(ast::def_arg(did, _)) {\n-        let cur_node = did.node;\n-        while true {\n-            alt cx.tcx.items.find(cur_node) {\n-              some(ast_map::node_arg(arg, _)) {\n-                if arg.mode == ast::by_move {\n-                    bad = some(\"a move-mode parameter\");\n-                }\n-                if arg.mode == ast::by_copy {\n-                    bad = some(\"a copy-mode parameter\");\n-                }\n-                if cur_node != arg_node_id {\n-                    bad = some(\"the wrong parameter\");\n-                }\n-                break;\n-              }\n-              _ {}\n-            }\n-            alt vec::find({|b| b.node_id == cur_node}, sc.bs) {\n-              some(b) {\n-                if vec::len(b.unsafe_tys) > 0u {\n-                    mut_field = true;\n-                    break;\n-                }\n-                if is_none(b.root_var) {\n-                    bad = some(\"a function-local value\");\n-                    break;\n-                }\n-                if b.copied == copied {\n-                    bad = some(\"an implicitly copied reference\");\n-                    break;\n-                }\n-                b.copied = not_allowed;\n-                cur_node = option::get(b.root_var);\n-              }\n-              none. {\n-                bad = some(\"a function-local value\");\n-                break;\n-              }\n-            }\n-        }\n-      }\n-      _ { bad = some(\"a non-local value\"); }\n-    }\n-    if mut_field && !mut { bad = some(\"a mutable field\"); }\n-    alt bad {\n-      some(name) {\n-        err(cx, expr.span, \"can not return a reference to \" + name);\n-      }\n-      _ {}\n-    }\n-}\n-\n fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n              v: vt<scope>) {\n     v.visit_expr(input, sc, v);\n@@ -733,22 +642,6 @@ fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n           _ {}\n         }\n       }\n-      ast::expr_call(f, args, _) {\n-        let fty = ty::expr_ty(cx.tcx, f);\n-        alt ty::ty_fn_ret_style(cx.tcx, fty) {\n-          ast::return_ref(mut, arg_n) {\n-            let arg = args[arg_n - 1u];\n-            let arg_root = expr_root(cx, arg, false);\n-            if mut {\n-                let ret_ty = ty::expr_ty(cx.tcx, base_root.ex);\n-                unsafe_ty = some(mut_contains(ret_ty));\n-            }\n-            if !is_none(arg_root.mut) { unsafe_ty = arg_root.mut; }\n-            ret {ex: arg_root.ex, mut: unsafe_ty};\n-          }\n-          _ {}\n-        }\n-      }\n       _ {}\n     }\n     ret {ex: base_root.ex, mut: unsafe_ty};"}, {"sha": "32f249132863bead1f6503654f349501d2d4d222", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -30,19 +30,16 @@ type rval_map = std::map::hashmap<node_id, ()>;\n \n type ctx = {tcx: ty::ctxt,\n             rval_map: rval_map,\n-            last_uses: last_use::last_uses,\n-            mutable ret_by_ref: bool};\n+            last_uses: last_use::last_uses};\n \n fn check_crate(tcx: ty::ctxt, last_uses: last_use::last_uses,\n                crate: @crate) -> rval_map {\n     let ctx = {tcx: tcx,\n                rval_map: std::map::new_int_hash(),\n-               last_uses: last_uses,\n-               mutable ret_by_ref: false};\n+               last_uses: last_uses};\n     let visit = visit::mk_vt(@{\n         visit_expr: check_expr,\n-        visit_stmt: check_stmt,\n-        visit_fn: visit_fn\n+        visit_stmt: check_stmt\n         with *visit::default_visitor()\n     });\n     visit::visit_crate(*crate, ctx, visit);\n@@ -55,7 +52,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_assign(_, ex) | expr_assign_op(_, _, ex) |\n       expr_block({node: {expr: some(ex), _}, _}) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) { maybe_copy(cx, ex); }\n-      expr_ret(some(ex)) { if !cx.ret_by_ref { maybe_copy(cx, ex); } }\n+      expr_ret(some(ex)) { maybe_copy(cx, ex); }\n       expr_copy(expr) { check_copy_ex(cx, expr, false); }\n       // Vector add copies.\n       expr_binary(add., ls, rs) { maybe_copy(cx, ls); maybe_copy(cx, rs); }\n@@ -138,14 +135,6 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_stmt(stmt, cx, v);\n }\n \n-fn visit_fn(f: _fn, tps: [ty_param], sp: span, ident: fn_ident,\n-            id: node_id, cx: ctx, v: visit::vt<ctx>) {\n-    let old_ret = cx.ret_by_ref;\n-    cx.ret_by_ref = ast_util::ret_by_ref(f.decl.cf);\n-    visit::visit_fn(f, tps, sp, ident, id, cx, v);\n-    cx.ret_by_ref = old_ret;\n-}\n-\n fn maybe_copy(cx: ctx, ex: @expr) {\n     check_copy_ex(cx, ex, true);\n }"}, {"sha": "624a168ef634de5c15174af525d2a49ccdc6ca98", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 25, "deletions": 52, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -80,14 +80,14 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n //  - new_fn_ctxt\n //  - trans_args\n fn type_of_fn(cx: @crate_ctxt, sp: span,\n-              is_method: bool, ret_ref: bool, inputs: [ty::arg],\n+              is_method: bool, inputs: [ty::arg],\n               output: ty::t, ty_param_count: uint)\n    : non_ty_var(cx, output) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n     let out_ty = T_ptr(type_of_inner(cx, sp, output));\n-    atys += [ret_ref ? T_ptr(out_ty) : out_ty];\n+    atys += [out_ty];\n \n     // Arg 1: Env (closure-bindings / self-obj)\n     if is_method {\n@@ -108,13 +108,12 @@ fn type_of_fn(cx: @crate_ctxt, sp: span,\n fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n                       ty_param_count: uint)\n     : returns_non_ty_var(cx, fty) -> TypeRef {\n-    let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(cx.tcx, fty));\n     // FIXME: Check should be unnecessary, b/c it's implied\n     // by returns_non_ty_var(t). Make that a postcondition\n     // (see Issue #586)\n     let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n     check non_ty_var(cx, ret_ty);\n-    ret type_of_fn(cx, sp, false, by_ref, ty::ty_fn_args(cx.tcx, fty),\n+    ret type_of_fn(cx, sp, false, ty::ty_fn_args(cx.tcx, fty),\n                    ret_ty, ty_param_count);\n }\n \n@@ -3046,11 +3045,10 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n     let v = GEPi(bcx, vtbl, [0, ix as int]);\n     let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, mths[ix]);\n     let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n-    let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n     // FIXME: constrain ty_obj?\n     check non_ty_var(ccx, ret_ty);\n \n-    let ll_fn_ty = type_of_fn(ccx, bcx.sp, true, ret_ref,\n+    let ll_fn_ty = type_of_fn(ccx, bcx.sp, true,\n                               ty::ty_fn_args(tcx, fn_ty), ret_ty, 0u);\n     v = Load(bcx, PointerCast(bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n     ret {bcx: bcx, mthptr: v, objptr: o};\n@@ -3656,16 +3654,14 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n+fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n               gen: option::t<generic_info>, es: [@ast::expr], fn_ty: ty::t,\n               dest: dest)\n    -> {bcx: @block_ctxt,\n-       outer_cx: @block_ctxt,\n        args: [ValueRef],\n        retslot: ValueRef,\n        to_zero: [{v: ValueRef, t: ty::t}],\n-       to_revoke: [{v: ValueRef, t: ty::t}],\n-       ret_ref: bool} {\n+       to_revoke: [{v: ValueRef, t: ty::t}]} {\n \n     let args: [ty::arg] = ty::ty_fn_args(bcx_tcx(cx), fn_ty);\n     let llargs: [ValueRef] = [];\n@@ -3676,8 +3672,6 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n     let ccx = bcx_ccx(cx);\n     let tcx = ccx.tcx;\n     let bcx = cx;\n-    let ret_style = ty::ty_fn_ret_style(tcx, fn_ty);\n-    let ret_ref = ast_util::ret_by_ref(ret_style);\n \n     let retty = ty::ty_fn_ret(tcx, fn_ty), full_retty = retty;\n     alt gen {\n@@ -3691,18 +3685,14 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n     }\n     // Arg 0: Output pointer.\n     let llretty = type_of_or_i8(bcx, full_retty);\n-    let llretslot = if ret_ref {\n-        alloca(cx, T_ptr(llretty))\n-    } else {\n-        alt dest {\n-          ignore. {\n-            if ty::type_is_nil(tcx, retty) {\n-                llvm::LLVMGetUndef(T_ptr(llretty))\n-            } else { alloca(cx, llretty) }\n-          }\n-          save_in(dst) { dst }\n-          by_val(_) { alloca(cx, llretty) }\n-        }\n+    let llretslot = alt dest {\n+      ignore. {\n+        if ty::type_is_nil(tcx, retty) {\n+            llvm::LLVMGetUndef(T_ptr(llretty))\n+        } else { alloca(cx, llretty) }\n+      }\n+      save_in(dst) { dst }\n+      by_val(_) { alloca(cx, llretty) }\n     };\n \n     if ty::type_contains_params(tcx, retty) {\n@@ -3713,7 +3703,6 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n         // view, for the sake of making a type-compatible call.\n         check non_ty_var(ccx, retty);\n         let llretty = T_ptr(type_of_inner(ccx, bcx.sp, retty));\n-        if ret_ref { llretty = T_ptr(llretty); }\n         llargs += [PointerCast(cx, llretslot, llretty)];\n     } else { llargs += [llretslot]; }\n \n@@ -3729,25 +3718,19 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n     let arg_tys = type_of_explicit_args(ccx, cx.sp, args);\n-    let i = 0u, outer_cx = outer_cx;\n+    let i = 0u;\n     for e: @ast::expr in es {\n-        let is_referenced = alt ret_style {\n-          ast::return_ref(_, arg_n) { i + 1u == arg_n }\n-          _ { false }\n-        };\n-        let r = trans_arg_expr(is_referenced ? outer_cx : bcx,\n-                               args[i], arg_tys[i], to_zero, to_revoke, e);\n-        if is_referenced { outer_cx = r.bcx; } else { bcx = r.bcx; }\n+        let r = trans_arg_expr(bcx, args[i], arg_tys[i], to_zero, to_revoke,\n+                               e);\n+        bcx = r.bcx;\n         llargs += [r.val];\n         i += 1u;\n     }\n     ret {bcx: bcx,\n-         outer_cx: outer_cx,\n          args: llargs,\n          retslot: llretslot,\n          to_zero: to_zero,\n-         to_revoke: to_revoke,\n-         ret_ref: ret_ref};\n+         to_revoke: to_revoke};\n }\n \n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n@@ -3764,6 +3747,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n //NDM    }\n \n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n+    Br(in_cx, cx.llbb);\n     let f_res = trans_callee(cx, f);\n     let bcx = f_res.bcx;\n \n@@ -3789,8 +3773,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n \n     let ret_ty = ty::node_id_to_type(tcx, id);\n     let args_res =\n-        trans_args(bcx, in_cx, llenv, f_res.generic, args, fn_expr_ty, dest);\n-    Br(args_res.outer_cx, cx.llbb);\n+        trans_args(bcx, llenv, f_res.generic, args, fn_expr_ty, dest);\n     bcx = args_res.bcx;\n     let llargs = args_res.args;\n     let llretslot = args_res.retslot;\n@@ -3803,8 +3786,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n                       args_res.to_revoke);\n     alt dest {\n       ignore. {\n-        if llvm::LLVMIsUndef(llretslot) != lib::llvm::True &&\n-           !args_res.ret_ref {\n+        if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n             bcx = drop_ty(bcx, llretslot, ret_ty);\n         }\n       }\n@@ -4445,16 +4427,7 @@ fn trans_cont(sp: span, cx: @block_ctxt) -> @block_ctxt {\n fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n     let cleanup_cx = bcx, bcx = bcx;\n     alt e {\n-      some(x) {\n-        if ast_util::ret_by_ref(bcx.fcx.ret_style) {\n-            let {bcx: cx, val, kind} = trans_lval(bcx, x);\n-            assert kind == owned;\n-            Store(cx, val, bcx.fcx.llretptr);\n-            bcx = cx;\n-        } else {\n-            bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr);\n-        }\n-      }\n+      some(x) { bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr); }\n       _ {}\n     }\n     // run all cleanups and back out.\n@@ -5604,7 +5577,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let nt = ty::mk_nil(ccx.tcx);\n         check non_ty_var(ccx, nt);\n \n-        let llfty = type_of_fn(ccx, sp, false, false, [vecarg_ty], nt, 0u);\n+        let llfty = type_of_fn(ccx, sp, false, [vecarg_ty], nt, 0u);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::LLVMCCallConv, llfty);\n \n@@ -5700,7 +5673,7 @@ fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_native_fn(args, out) {\n         check non_ty_var(cx, out);\n-        ret type_of_fn(cx, sp, false, false, args, out, ty_param_count);\n+        ret type_of_fn(cx, sp, false, args, out, ty_param_count);\n       }\n     }\n }"}, {"sha": "e77ce6c8d5fb831366f2b7cd959231b5449f2f32", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -321,7 +321,7 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n     let nil_res = ty::mk_nil(ccx.tcx);\n     // FIXME: Silly check -- mk_nil should have a postcondition\n     check non_ty_var(ccx, nil_res);\n-    let f_t = type_of_fn(ccx, sp, false, false,\n+    let f_t = type_of_fn(ccx, sp, false,\n                          [{mode: ast::by_ref, ty: inner_t}],\n                          nil_res, params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n@@ -430,14 +430,14 @@ fn find_scope_cx(cx: @block_ctxt) -> @block_ctxt {\n // Accessors\n // TODO: When we have overloading, simplify these names!\n \n-pure fn bcx_tcx(bcx: @block_ctxt) -> &ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n-pure fn bcx_ccx(bcx: @block_ctxt) -> &@crate_ctxt { ret bcx.fcx.lcx.ccx; }\n-pure fn bcx_lcx(bcx: @block_ctxt) -> &@local_ctxt { ret bcx.fcx.lcx; }\n-pure fn bcx_fcx(bcx: @block_ctxt) -> &@fn_ctxt { ret bcx.fcx; }\n-pure fn fcx_ccx(fcx: @fn_ctxt) -> &@crate_ctxt { ret fcx.lcx.ccx; }\n-pure fn fcx_tcx(fcx: @fn_ctxt) -> &ty::ctxt { ret fcx.lcx.ccx.tcx; }\n-pure fn lcx_ccx(lcx: @local_ctxt) -> &@crate_ctxt { ret lcx.ccx; }\n-pure fn ccx_tcx(ccx: @crate_ctxt) -> &ty::ctxt { ret ccx.tcx; }\n+pure fn bcx_tcx(bcx: @block_ctxt) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n+pure fn bcx_ccx(bcx: @block_ctxt) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n+pure fn bcx_lcx(bcx: @block_ctxt) -> @local_ctxt { ret bcx.fcx.lcx; }\n+pure fn bcx_fcx(bcx: @block_ctxt) -> @fn_ctxt { ret bcx.fcx; }\n+pure fn fcx_ccx(fcx: @fn_ctxt) -> @crate_ctxt { ret fcx.lcx.ccx; }\n+pure fn fcx_tcx(fcx: @fn_ctxt) -> ty::ctxt { ret fcx.lcx.ccx.tcx; }\n+pure fn lcx_ccx(lcx: @local_ctxt) -> @crate_ctxt { ret lcx.ccx; }\n+pure fn ccx_tcx(ccx: @crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n \n // LLVM type constructors.\n fn T_void() -> TypeRef {"}, {"sha": "ba3e32c411a71a619b4039dad0ad9466d59e275f", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -879,8 +879,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n       ty::ty_fn(_, inputs, output, rs, _) {\n         check non_ty_var(ccx, output);\n-        llfnty = type_of_fn(ccx, m.span, true,\n-                            ast_util::ret_by_ref(rs), inputs, output,\n+        llfnty = type_of_fn(ccx, m.span, true, inputs, output,\n                             vec::len(ty_params));\n       }\n     }\n@@ -933,8 +932,7 @@ fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n                 tps: [ast::ty_param]) -> TypeRef {\n     let out_ty = m.output;\n     check non_ty_var(ccx, out_ty);\n-    type_of_fn(ccx, sp, true, ast_util::ret_by_ref(m.cf),\n-               m.inputs, out_ty, vec::len(tps))\n+    type_of_fn(ccx, sp, true, m.inputs, out_ty, vec::len(tps))\n }\n \n //"}, {"sha": "e3615d697ba704345f4c44f5dfff874ef497a857", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -1670,10 +1670,6 @@ fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n           ty_rec(_) { true }\n         }\n       }\n-      ast::expr_call(f, _, _) {\n-          let fty = expr_ty(tcx, f);\n-          ast_util::ret_by_ref(ty_fn_ret_style(tcx, fty))\n-      }\n       _ { false }\n     }\n }\n@@ -2623,10 +2619,6 @@ fn type_err_to_str(err: ty::type_err) -> str {\n             alt s {\n               ast::noreturn. { \"non-returning\" }\n               ast::return_val. { \"return-by-value\" }\n-              ast::return_ref(mut, arg) {\n-                #fmt(\"return-by-%sreference on arg %u\",\n-                     mut ? \"mutable-\" : \"\", arg)\n-              }\n             }\n         }\n         ret to_str(actual) + \" function found where \" + to_str(expect) +"}, {"sha": "b1e1a16c6af428bfd3a660d3f3a6000a75827ec8", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -397,7 +397,6 @@ tag ret_style {\n     noreturn; // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val; // everything else\n-    return_ref(bool, uint);\n }\n \n type _fn = {decl: fn_decl, proto: proto, body: blk};"}, {"sha": "862d182b9fd39938a4a24685a2860b90613b97d4", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -223,13 +223,6 @@ fn ternary_to_if(e: @expr) -> @expr {\n     }\n }\n \n-fn ret_by_ref(style: ret_style) -> bool {\n-    alt style {\n-      return_ref(_, _) { true }\n-      _ { false }\n-    }\n-}\n-\n fn ty_param_kind(tp: ty_param) -> kind { tp.kind }\n \n fn compare_lit(a: @lit, b: @lit) -> int {"}, {"sha": "391d5eb88195ea5b2be4c35acfb22d4fe0b8bd67", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -295,7 +295,7 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n     // FIXME: there's no syntax for this right now anyway\n     //  auto constrs = parse_constrs(~[], p);\n     let constrs: [@ast::constr] = [];\n-    let (ret_style, ret_ty) = parse_ret_ty(p, vec::len(inputs.node));\n+    let (ret_style, ret_ty) = parse_ret_ty(p);\n     ret ast::ty_fn(proto, inputs.node, ret_ty, ret_style, constrs);\n }\n \n@@ -439,34 +439,12 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool)\n     }\n }\n \n-fn parse_ret_ty(p: parser, n_args: uint) -> (ast::ret_style, @ast::ty) {\n+fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n     ret if eat(p, token::RARROW) {\n         let lo = p.get_lo_pos();\n         if eat(p, token::NOT) {\n             (ast::noreturn, @spanned(lo, p.get_last_hi_pos(), ast::ty_bot))\n-        } else {\n-            let style = ast::return_val;\n-            if eat(p, token::BINOP(token::AND)) {\n-                if n_args == 0u {\n-                    p.fatal(\"can not return reference from argument-less fn\");\n-                }\n-                let mut_root = eat(p, token::NOT), arg = 1u;\n-                alt p.peek() {\n-                  token::LIT_INT(val) { p.bump(); arg = val as uint; }\n-                  _ { if n_args > 1u {\n-                      p.fatal(\"must specify referenced parameter\");\n-                  } }\n-                }\n-                if arg > n_args {\n-                    p.fatal(\"referenced argument does not exist\");\n-                }\n-                if arg == 0u {\n-                    p.fatal(\"referenced argument can't be 0\");\n-                }\n-                style = ast::return_ref(mut_root, arg);\n-            };\n-            (style, parse_ty(p, false))\n-        }\n+        } else { (ast::return_val, parse_ty(p, false)) }\n     } else {\n         let pos = p.get_lo_pos();\n         (ast::return_val, @spanned(pos, pos, ast::ty_nil))\n@@ -1791,7 +1769,7 @@ fn parse_fn_decl(p: parser, purity: ast::purity, il: ast::inlineness) ->\n         p.bump();\n         constrs = parse_constrs({|x| parse_ty_constr(inputs.node, x) }, p);\n     }\n-    let (ret_style, ret_ty) = parse_ret_ty(p, vec::len(inputs.node));\n+    let (ret_style, ret_ty) = parse_ret_ty(p);\n     ret {inputs: inputs.node,\n          output: ret_ty,\n          purity: purity,"}, {"sha": "0fb5df69edbe7c2654079d63d5bd94091857702a", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -1130,15 +1130,6 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl, constrs: [@ast::constr]) {\n     if decl.output.node != ast::ty_nil {\n         space_if_not_bol(s);\n         word_space(s, \"->\");\n-        alt decl.cf {\n-          ast::return_ref(mut, arg) {\n-            word(s.s, mut ? \"&!\" : \"&\");\n-            if vec::len(decl.inputs) > 1u {\n-                word_space(s, std::uint::str(arg));\n-            }\n-          }\n-          _ {}\n-        }\n         print_type(s, decl.output);\n     }\n }\n@@ -1336,18 +1327,8 @@ fn print_ty_fn(s: ps, proto: ast::proto, id: option::t<ast::ident>,\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n         word_space(s, \"->\");\n-        if cf == ast::noreturn {\n-            word_nbsp(s, \"!\");\n-        } else {\n-            alt cf {\n-              ast::return_ref(mut, arg) {\n-                word(s.s, mut ? \"&!\" : \"&\");\n-                if vec::len(inputs) > 1u { word(s.s, std::uint::str(arg)); }\n-              }\n-              _ {}\n-            }\n-            print_type(s, output);\n-        }\n+        if cf == ast::noreturn { word_nbsp(s, \"!\"); }\n+        else { print_type(s, output); }\n         end(s);\n     }\n     word(s.s, ast_ty_fn_constrs_str(constrs));"}, {"sha": "d35d871ce656b3116d3e52589c01cea8a290a010", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -62,11 +62,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n             s += \" -> \";\n             alt cf {\n               ast::noreturn. { s += \"!\"; }\n-              ast::return_ref(mut, arg) {\n-                s += mut ? \"&!\" : \"&\";\n-                if vec::len(inputs) > 1u { s += std::uint::str(arg); }\n-                s += ty_to_str(cx, output);\n-              }\n               ast::return_val. { s += ty_to_str(cx, output); }\n             }\n         }"}, {"sha": "403cb47f47e645d608a2fe04f1ea27f89fbd888f", "filename": "src/lib/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb3719ded8d6938c21710d4b487ab1328c7dd5e/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=9fb3719ded8d6938c21710d4b487ab1328c7dd5e", "patch": "@@ -30,7 +30,7 @@ Failure:\n \n Fails if the value equals `none`.\n */\n-fn get<T>(opt: t<T>) -> &T {\n+fn get<copy T>(opt: t<T>) -> T {\n     alt opt { some(x) { ret x; } none. { fail \"option none\"; } }\n }\n "}, {"sha": "2a6d05f23d4a25be49028778749f4f300e23bbea", "filename": "src/test/compile-fail/ret-by-reference-from-temporary.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-from-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-from-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-by-reference-from-temporary.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:a reference binding can't be rooted in a temporary\n-\n-fn f(a: {x: int}) -> &int {\n-    ret a.x;\n-}\n-\n-fn main() {\n-    let &_a = f({x: 4});\n-}"}, {"sha": "5e0df4fc3cdf2937536be6f2ea0aa5315e32f47b", "filename": "src/test/compile-fail/ret-by-reference-local-value.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-local-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-local-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-by-reference-local-value.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,8 +0,0 @@\n-// error-pattern:can not return a reference to a function-local value\n-\n-fn f(a: {mutable x: int}) -> &int {\n-    let x = {y: 4};\n-    ret x.y;\n-}\n-\n-fn main() {}"}, {"sha": "a40b9aeba2dec6d4241f323320acb17d6b9196eb", "filename": "src/test/compile-fail/ret-by-reference-mutable-field.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-mutable-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-mutable-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-by-reference-mutable-field.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:can not return a reference to a mutable field\n-\n-fn f(a: {mutable x: int}) -> &int {\n-    ret a.x;\n-}\n-\n-fn main() {}"}, {"sha": "f6cd81308e943a1235ea8c1b0efdfafc13c7ebc9", "filename": "src/test/compile-fail/ret-by-reference-safety-1.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-safety-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-safety-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-by-reference-safety-1.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,12 +0,0 @@\n-// error-pattern:taking the value of x will invalidate reference a\n-\n-fn f(a: {mutable x: int}) -> &!int {\n-    ret a.x;\n-}\n-\n-fn main() {\n-    let x = {mutable x: 4};\n-    let &a = f(x);\n-    x;\n-    a;\n-}"}, {"sha": "546511419c130fde18eb177d8851b64ee62801cc", "filename": "src/test/compile-fail/ret-by-reference-safety-2.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-safety-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-safety-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-by-reference-safety-2.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,12 +0,0 @@\n-// error-pattern:overwriting x will invalidate reference a\n-\n-fn f(a: {x: {mutable x: int}}) -> &{mutable x: int} {\n-    ret a.x;\n-}\n-\n-fn main() {\n-    let x = {x: {mutable x: 4}};\n-    let &a = f(x);\n-    x = {x: {mutable x: 5}};\n-    a;\n-}"}, {"sha": "a99dfc1c8dd94f7fb4b14a5168b61097ec12e8eb", "filename": "src/test/compile-fail/ret-by-reference-specify-param.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-specify-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-specify-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-by-reference-specify-param.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:must specify referenced parameter\n-\n-fn f(a: int, b: int) -> &int {\n-    ret a;\n-}\n-\n-fn main() {}"}, {"sha": "5a571cf3ecc8b660bcc53dcac52192f09e7ffb5d", "filename": "src/test/compile-fail/ret-by-reference-temporary.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-by-reference-temporary.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:can not return a reference to a temporary\n-\n-fn f(a: int) -> &int {\n-    ret 10;\n-}\n-\n-fn main() {}"}, {"sha": "7c4791248057789705b1fbfb32b5f593d02822c8", "filename": "src/test/compile-fail/ret-by-reference-wrong-param.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-wrong-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Fcompile-fail%2Fret-by-reference-wrong-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-by-reference-wrong-param.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:can not return a reference to the wrong parameter\n-\n-fn f(a: int, b: int) -> &2 int {\n-    ret a;\n-}\n-\n-fn main() {}"}, {"sha": "9c2324a21691c943664e0b95857d701c0ff2a11c", "filename": "src/test/run-pass/ret-by-reference.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Frun-pass%2Fret-by-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbc4aa9f8f46545c8c11422c62b392e3ef64cf5/src%2Ftest%2Frun-pass%2Fret-by-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-by-reference.rs?ref=acbc4aa9f8f46545c8c11422c62b392e3ef64cf5", "patch": "@@ -1,32 +0,0 @@\n-tag option<T> { some(T); none; }\n-\n-fn get<T>(opt: option<T>) -> &T {\n-    alt opt {\n-      some(x) { ret x; }\n-    }\n-}\n-\n-fn get_mut(a: {mutable x: @int}, _b: int) -> &!1 @int {\n-    ret a.x;\n-}\n-\n-fn get_deep(a: {mutable y: {mutable x: @int}}) -> &!@int {\n-    ret get_mut(a.y, 1);\n-}\n-\n-fn main() {\n-    let x = some(@50);\n-    let &y = get(x);\n-    assert *y == 50;\n-    assert get(some(10)) == 10;\n-\n-    let y = {mutable x: @50};\n-    let &box = get_mut(y, 4);\n-    assert *box == 50;\n-    assert *get_mut({mutable x: @70}, 5) == 70;\n-\n-    let u = {mutable y: {mutable x: @10}};\n-    let &deep = get_deep(u);\n-    assert *deep == 10;\n-    assert *get_deep({mutable y: {mutable x: @11}}) + 2 == 13;\n-}"}]}