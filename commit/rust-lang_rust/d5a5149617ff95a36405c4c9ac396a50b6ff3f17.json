{"sha": "d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YTUxNDk2MTdmZjk1YTM2NDA1YzRjOWFjMzk2YTUwYjZmZjNmMTc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-26T14:58:35Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-01T08:09:12Z"}, "message": "Move caching of HIR-inlining into CStore in order to avoid duplicating inlined HIR.", "tree": {"sha": "c7d6037ccbd0d5259af9eb4d9a439ffed8bab410", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7d6037ccbd0d5259af9eb4d9a439ffed8bab410"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "html_url": "https://github.com/rust-lang/rust/commit/d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "535cea0eecea4e25e988d9771f2da877113f98ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/535cea0eecea4e25e988d9771f2da877113f98ee", "html_url": "https://github.com/rust-lang/rust/commit/535cea0eecea4e25e988d9771f2da877113f98ee"}], "stats": {"total": 510, "additions": 335, "deletions": 175}, "files": [{"sha": "aded220c0cdfe6893c854a8c734a560606cd6bff", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -867,7 +867,7 @@ pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq)]\n pub struct IdRange {\n     pub min: NodeId,\n     pub max: NodeId,\n@@ -893,6 +893,7 @@ impl IdRange {\n         self.min = cmp::min(self.min, id);\n         self.max = cmp::max(self.max, id + 1);\n     }\n+\n }\n \n "}, {"sha": "aed3613f44ed489328e3df2f1a6ae1013fafd684", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -32,6 +32,7 @@ use hir::print as pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n+use std::cmp;\n use std::io;\n use std::mem;\n \n@@ -127,7 +128,10 @@ impl<'ast> MapEntry<'ast> {\n             EntryStructCtor(id, _) => id,\n             EntryLifetime(id, _) => id,\n             EntryTyParam(id, _) => id,\n-            _ => return None\n+\n+            NotPresent |\n+            RootCrate |\n+            RootInlinedParent(_) => return None,\n         })\n     }\n \n@@ -196,6 +200,10 @@ pub struct Map<'ast> {\n     map: RefCell<Vec<MapEntry<'ast>>>,\n \n     definitions: RefCell<Definitions>,\n+\n+    /// All NodeIds that are numerically greater or equal to this value come\n+    /// from inlined items.\n+    local_node_id_watermark: NodeId,\n }\n \n impl<'ast> Map<'ast> {\n@@ -550,6 +558,13 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn expect_inlined_item(&self, id: NodeId) -> &'ast InlinedItem {\n+        match self.find_entry(id) {\n+            Some(RootInlinedParent(inlined_item)) => inlined_item,\n+            _ => bug!(\"expected inlined item, found {}\", self.node_to_string(id)),\n+        }\n+    }\n+\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -649,6 +664,10 @@ impl<'ast> Map<'ast> {\n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, false)\n     }\n+\n+    pub fn is_inlined(&self, id: NodeId) -> bool {\n+        id >= self.local_node_id_watermark\n+    }\n }\n \n pub struct NodesMatchingSuffix<'a, 'ast:'a> {\n@@ -765,13 +784,37 @@ pub trait FoldOps {\n }\n \n /// A Folder that updates IDs and Span's according to fold_ops.\n-struct IdAndSpanUpdater<F> {\n-    fold_ops: F\n+pub struct IdAndSpanUpdater<F> {\n+    fold_ops: F,\n+    min_id_assigned: NodeId,\n+    max_id_assigned: NodeId,\n+}\n+\n+impl<F: FoldOps> IdAndSpanUpdater<F> {\n+    pub fn new(fold_ops: F) -> IdAndSpanUpdater<F> {\n+        IdAndSpanUpdater {\n+            fold_ops: fold_ops,\n+            min_id_assigned: ::std::u32::MAX,\n+            max_id_assigned: ::std::u32::MIN,\n+        }\n+    }\n+\n+    pub fn id_range(&self) -> intravisit::IdRange {\n+        intravisit::IdRange {\n+            min: self.min_id_assigned,\n+            max: self.max_id_assigned + 1,\n+        }\n+    }\n }\n \n impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     fn new_id(&mut self, id: NodeId) -> NodeId {\n-        self.fold_ops.new_id(id)\n+        let id = self.fold_ops.new_id(id);\n+\n+        self.min_id_assigned = cmp::min(self.min_id_assigned, id);\n+        self.max_id_assigned = cmp::max(self.max_id_assigned, id);\n+\n+        id\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n@@ -802,11 +845,14 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n+    let local_node_id_watermark = map.len() as NodeId;\n+\n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n         definitions: RefCell::new(definitions),\n+        local_node_id_watermark: local_node_id_watermark\n     }\n }\n \n@@ -818,7 +864,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           ii: InlinedItem,\n                                           fold_ops: F)\n                                           -> &'ast InlinedItem {\n-    let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n+    let mut fld = IdAndSpanUpdater::new(fold_ops);\n     let ii = match ii {\n         II::Item(i) => II::Item(i.map(|i| fld.fold_item(i))),\n         II::TraitItem(d, ti) => {\n@@ -835,6 +881,12 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let ii = map.forest.inlined_items.alloc(ii);\n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n \n+    // Assert that the ii_parent_id is the last NodeId in our reserved range\n+    assert!(ii_parent_id == fld.max_id_assigned);\n+    // Assert that we did not violate the invariant that all inlined HIR items\n+    // have NodeIds greater than or equal to `local_node_id_watermark`\n+    assert!(fld.min_id_assigned >= map.local_node_id_watermark);\n+\n     let defs = &mut *map.definitions.borrow_mut();\n     let mut def_collector = DefCollector::extend(ii_parent_id,\n                                                  parent_def_path.clone(),"}, {"sha": "32344a7b9c8deb1485d2d5ac8e27c8102144c0c3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -120,12 +120,6 @@ pub struct ChildItem {\n     pub vis: ty::Visibility,\n }\n \n-pub enum FoundAst<'ast> {\n-    Found(&'ast InlinedItem),\n-    FoundParent(DefId, &'ast hir::Item),\n-    NotFound,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct ExternCrate {\n     /// def_id of an `extern crate` in the current crate that caused\n@@ -250,7 +244,10 @@ pub trait CrateStore<'tcx> {\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> FoundAst<'tcx>;\n+                              -> Option<(&'tcx InlinedItem, ast::NodeId)>;\n+    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId>;\n+    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId>;\n+\n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n@@ -447,7 +444,16 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> FoundAst<'tcx> { bug!(\"maybe_get_item_ast\") }\n+                              -> Option<(&'tcx InlinedItem, ast::NodeId)> {\n+        bug!(\"maybe_get_item_ast\")\n+    }\n+    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId> {\n+        bug!(\"local_node_for_inlined_defid\")\n+    }\n+    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId> {\n+        bug!(\"defid_for_inlined_node\")\n+    }\n+\n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {"}, {"sha": "d424b57c938411168550c1e229c9ff022fca94bf", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -17,7 +17,7 @@ use self::EvalHint::*;\n \n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::middle::cstore::{self, InlinedItem};\n+use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n@@ -142,13 +142,13 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n+            Some((&InlinedItem::Item(ref item), _)) => match item.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n                     Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n                 _ => None\n             },\n-            cstore::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n+            Some((&InlinedItem::TraitItem(trait_id, ref ti), _)) => match ti.node {\n                 hir::ConstTraitItem(_, _) => {\n                     used_substs = true;\n                     if let Some(substs) = substs {\n@@ -163,7 +163,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n                 _ => None\n             },\n-            cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n+            Some((&InlinedItem::ImplItem(_, ref ii), _)) => match ii.node {\n                 hir::ImplItemKind::Const(ref ty, ref expr) => {\n                     Some((&**expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n@@ -198,8 +198,8 @@ fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-        cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n-        cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n+        Some((&InlinedItem::Item(ref item), _)) => Some(item.id),\n+        Some((&InlinedItem::ImplItem(_, ref item), _)) => Some(item.id),\n         _ => None\n     };\n     tcx.extern_const_fns.borrow_mut().insert(def_id,"}, {"sha": "c39ad414492ed637fd0faa29134e7e504ccea3d7", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -88,8 +88,9 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            rbml_w.writer.seek(SeekFrom::Current(0)));\n \n     // Folding could be avoided with a smarter encoder.\n-    let ii = simplify_ast(ii);\n+    let (ii, expected_id_range) = simplify_ast(ii);\n     let id_range = inlined_item_id_range(&ii);\n+    assert_eq!(expected_id_range, id_range);\n \n     rbml_w.start_tag(c::tag_ast as usize);\n     id_range.encode(rbml_w);\n@@ -186,6 +187,10 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         // from_id_range should be non-empty\n         assert!(!self.from_id_range.empty());\n+        // Make sure that translating the NodeId will actually yield a\n+        // meaningful result\n+        assert!(self.from_id_range.contains(id));\n+\n         // Use wrapping arithmetic because otherwise it introduces control flow.\n         // Maybe we should just have the control flow? -- aatch\n         (id.wrapping_sub(self.from_id_range.min).wrapping_add(self.to_id_range.min))\n@@ -279,9 +284,23 @@ fn encode_ast(rbml_w: &mut Encoder, item: &InlinedItem) {\n     rbml_w.end_tag();\n }\n \n-struct NestedItemsDropper;\n+struct NestedItemsDropper {\n+    id_range: IdRange\n+}\n \n impl Folder for NestedItemsDropper {\n+\n+    // The unit tests below run on HIR with NodeIds not properly assigned. That\n+    // causes an integer overflow. So we just don't track the id_range when\n+    // building the unit tests.\n+    #[cfg(not(test))]\n+    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n+        // Record the range of NodeIds we are visiting, so we can do a sanity\n+        // check later\n+        self.id_range.add(id);\n+        id\n+    }\n+\n     fn fold_block(&mut self, blk: P<hir::Block>) -> P<hir::Block> {\n         blk.and_then(|hir::Block {id, stmts, expr, rules, span, ..}| {\n             let stmts_sans_items = stmts.into_iter().filter_map(|stmt| {\n@@ -322,10 +341,12 @@ impl Folder for NestedItemsDropper {\n // As it happens, trans relies on the fact that we do not export\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n-fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n-    let mut fld = NestedItemsDropper;\n+fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n+    let mut fld = NestedItemsDropper {\n+        id_range: IdRange::max()\n+    };\n \n-    match ii {\n+    let ii = match ii {\n         // HACK we're not dropping items.\n         InlinedItemRef::Item(i) => {\n             InlinedItem::Item(P(fold::noop_fold_item(i.clone(), &mut fld)))\n@@ -339,7 +360,9 @@ fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n         InlinedItemRef::Foreign(i) => {\n             InlinedItem::Foreign(P(fold::noop_fold_foreign_item(i.clone(), &mut fld)))\n         }\n-    }\n+    };\n+\n+    (ii, fld.id_range)\n }\n \n fn decode_ast(item_doc: rbml::Doc) -> InlinedItem {\n@@ -361,8 +384,18 @@ impl tr for Def {\n         match *self {\n           Def::Fn(did) => Def::Fn(did.tr(dcx)),\n           Def::Method(did) => Def::Method(did.tr(dcx)),\n-          Def::SelfTy(opt_did, impl_id) => { Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n-                                                         impl_id.map(|id| dcx.tr_id(id))) }\n+          Def::SelfTy(opt_did, impl_id) => {\n+              // Since the impl_id will never lie within the reserved range of\n+              // imported NodeIds, it does not make sense to translate it.\n+              // The result would not make any sense within the importing crate.\n+              // We also don't allow for impl items to be inlined (just their\n+              // members), so even if we had a DefId here, we wouldn't be able\n+              // to do much with it.\n+              // So, we set the id to DUMMY_NODE_ID. That way we make it\n+              // explicit that this is no usable NodeId.\n+              Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n+                          impl_id.map(|_| ast::DUMMY_NODE_ID))\n+          }\n           Def::Mod(did) => { Def::Mod(did.tr(dcx)) }\n           Def::ForeignMod(did) => { Def::ForeignMod(did.tr(dcx)) }\n           Def::Static(did, m) => { Def::Static(did.tr(dcx), m) }\n@@ -1361,7 +1394,7 @@ fn test_simplification() {\n     with_testing_context(|lcx| {\n         let hir_item = lcx.lower_item(&item);\n         let item_in = InlinedItemRef::Item(&hir_item);\n-        let item_out = simplify_ast(item_in);\n+        let (item_out, _) = simplify_ast(item_in);\n         let item_exp = InlinedItem::Item(P(lcx.lower_item(&quote_item!(&cx,\n             fn new_int_alist<B>() -> alist<isize, B> {\n                 return alist {eq_fn: eq_int, data: Vec::new()};"}, {"sha": "862245b9b78694bcb22cba1271a98ced9ba0c0e2", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 141, "deletions": 6, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -14,7 +14,7 @@ use decoder;\n use encoder;\n use loader;\n \n-use middle::cstore::{CrateStore, CrateSource, ChildItem, ExternCrate, FoundAst, DefLike};\n+use middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate, DefLike};\n use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use rustc::hir::def;\n use middle::lang_items;\n@@ -482,12 +482,146 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> FoundAst<'tcx>\n+    fn maybe_get_item_ast<'a>(&'tcx self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId)\n+                              -> Option<(&'tcx InlinedItem, ast::NodeId)>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_ast(&cdata, tcx, def.index)\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n+\n+        match self.inlined_item_cache.borrow().get(&def_id) {\n+            Some(&None) => {\n+                return None; // Not inlinable\n+            }\n+            Some(&Some(ref cached_inlined_item)) => {\n+                // Already inline\n+                debug!(\"maybe_get_item_ast({}): already inline as node id {}\",\n+                          tcx.item_path_str(def_id), cached_inlined_item.item_id);\n+                return Some((tcx.map.expect_inlined_item(cached_inlined_item.inlined_root),\n+                             cached_inlined_item.item_id));\n+            }\n+            None => {\n+                // Not seen yet\n+            }\n+        }\n+\n+        debug!(\"maybe_get_item_ast({}): inlining item\", tcx.item_path_str(def_id));\n+\n+        let cdata = self.get_crate_data(def_id.krate);\n+        let inlined = decoder::maybe_get_item_ast(&cdata, tcx, def_id.index);\n+\n+        let cache_inlined_item = |original_def_id, inlined_item_id, inlined_root_node_id| {\n+            let cache_entry = cstore::CachedInlinedItem {\n+                inlined_root: inlined_root_node_id,\n+                item_id: inlined_item_id,\n+            };\n+            self.inlined_item_cache\n+                .borrow_mut()\n+                .insert(original_def_id, Some(cache_entry));\n+            self.defid_for_inlined_node\n+                .borrow_mut()\n+                .insert(inlined_item_id, original_def_id);\n+        };\n+\n+        let find_inlined_item_root = |inlined_item_id| {\n+            let mut node = inlined_item_id;\n+            let mut path = Vec::with_capacity(10);\n+\n+            // If we can't find the inline root after a thousand hops, we can\n+            // be pretty sure there's something wrong with the HIR map.\n+            for _ in 0 .. 1000 {\n+                path.push(node);\n+                let parent_node = tcx.map.get_parent_node(node);\n+                if parent_node == node {\n+                    return node;\n+                }\n+                node = parent_node;\n+            }\n+            bug!(\"cycle in HIR map parent chain\")\n+        };\n+\n+        match inlined {\n+            decoder::FoundAst::NotFound => {\n+                self.inlined_item_cache\n+                    .borrow_mut()\n+                    .insert(def_id, None);\n+            }\n+            decoder::FoundAst::Found(&InlinedItem::Item(ref item)) => {\n+                let inlined_root_node_id = find_inlined_item_root(item.id);\n+                cache_inlined_item(def_id, item.id, inlined_root_node_id);\n+            }\n+            decoder::FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n+                let inlined_root_node_id = find_inlined_item_root(item.id);\n+                cache_inlined_item(def_id, item.id, inlined_root_node_id);\n+            }\n+            decoder::FoundAst::FoundParent(parent_did, item) => {\n+                let inlined_root_node_id = find_inlined_item_root(item.id);\n+                cache_inlined_item(parent_did, item.id, inlined_root_node_id);\n+\n+                match item.node {\n+                    hir::ItemEnum(ref ast_def, _) => {\n+                        let ast_vs = &ast_def.variants;\n+                        let ty_vs = &tcx.lookup_adt_def(parent_did).variants;\n+                        assert_eq!(ast_vs.len(), ty_vs.len());\n+                        for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n+                            cache_inlined_item(ty_v.did,\n+                                               ast_v.node.data.id(),\n+                                               inlined_root_node_id);\n+                        }\n+                    }\n+                    hir::ItemStruct(ref struct_def, _) => {\n+                        if struct_def.is_struct() {\n+                            bug!(\"instantiate_inline: called on a non-tuple struct\")\n+                        } else {\n+                            cache_inlined_item(def_id,\n+                                               struct_def.id(),\n+                                               inlined_root_node_id);\n+                        }\n+                    }\n+                    _ => bug!(\"instantiate_inline: item has a \\\n+                               non-enum, non-struct parent\")\n+                }\n+            }\n+            decoder::FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n+                let inlined_root_node_id = find_inlined_item_root(trait_item.id);\n+                cache_inlined_item(def_id, trait_item.id, inlined_root_node_id);\n+\n+                // Associated consts already have to be evaluated in `typeck`, so\n+                // the logic to do that already exists in `middle`. In order to\n+                // reuse that code, it needs to be able to look up the traits for\n+                // inlined items.\n+                let ty_trait_item = tcx.impl_or_trait_item(def_id).clone();\n+                let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n+                tcx.impl_or_trait_items.borrow_mut()\n+                   .insert(trait_item_def_id, ty_trait_item);\n+            }\n+            decoder::FoundAst::Found(&InlinedItem::ImplItem(_, ref impl_item)) => {\n+                let inlined_root_node_id = find_inlined_item_root(impl_item.id);\n+                cache_inlined_item(def_id, impl_item.id, inlined_root_node_id);\n+            }\n+        }\n+\n+        // We can be sure to hit the cache now\n+        return self.maybe_get_item_ast(tcx, def_id);\n+    }\n+\n+    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId> {\n+        assert!(!def_id.is_local());\n+        match self.inlined_item_cache.borrow().get(&def_id) {\n+            Some(&Some(ref cached_inlined_item)) => {\n+                Some(cached_inlined_item.item_id)\n+            }\n+            Some(&None) => {\n+                None\n+            }\n+            _ => {\n+                bug!(\"Trying to lookup inlined NodeId for unexpected item\");\n+            }\n+        }\n+    }\n+\n+    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId> {\n+        self.defid_for_inlined_node.borrow().get(&node_id).map(|x| *x)\n     }\n \n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -634,3 +768,4 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         visible_parent_map\n     }\n }\n+"}, {"sha": "d786cc5ba0eb7865bbc58e4f2e3c267a1417e58b", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -25,7 +25,7 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::{ExternCrate};\n+use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n@@ -96,6 +96,13 @@ pub struct CrateMetadata {\n     pub explicitly_linked: Cell<bool>,\n }\n \n+pub struct CachedInlinedItem {\n+    /// The NodeId of the RootInlinedParent HIR map entry\n+    pub inlined_root: ast::NodeId,\n+    /// The local NodeId of the inlined entity\n+    pub item_id: ast::NodeId,\n+}\n+\n pub struct CStore {\n     pub dep_graph: DepGraph,\n     metas: RefCell<FnvHashMap<ast::CrateNum, Rc<CrateMetadata>>>,\n@@ -105,6 +112,8 @@ pub struct CStore {\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<NodeSet>,\n+    pub inlined_item_cache: RefCell<DefIdMap<Option<CachedInlinedItem>>>,\n+    pub defid_for_inlined_node: RefCell<NodeMap<DefId>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n@@ -119,6 +128,8 @@ impl CStore {\n             used_link_args: RefCell::new(Vec::new()),\n             statically_included_foreign_items: RefCell::new(NodeSet()),\n             visible_parent_map: RefCell::new(FnvHashMap()),\n+            inlined_item_cache: RefCell::new(FnvHashMap()),\n+            defid_for_inlined_node: RefCell::new(FnvHashMap()),\n         }\n     }\n "}, {"sha": "d8fd25d62774af11721a3db8b604a6ff6c0f4400", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -30,7 +30,7 @@ use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n use rustc::session::config::PanicStrategy;\n \n-use middle::cstore::{FoundAst, InlinedItem, LinkagePreference};\n+use middle::cstore::{InlinedItem, LinkagePreference};\n use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n@@ -755,6 +755,12 @@ pub fn maybe_get_item_name(cdata: Cmd, id: DefIndex) -> Option<ast::Name> {\n     maybe_item_name(cdata.lookup_item(id))\n }\n \n+pub enum FoundAst<'ast> {\n+    Found(&'ast InlinedItem),\n+    FoundParent(DefId, &'ast hir::Item),\n+    NotFound,\n+}\n+\n pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n                                     -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);"}, {"sha": "61d8a0837c1d6219127a108eed022ae19b070f08", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -1235,7 +1235,6 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      inlined_vid: ast::NodeId)\n                                      -> ty::VariantDef<'tcx>\n {\n-\n     let ctor_ty = ccx.tcx().node_id_to_type(inlined_vid);\n     debug!(\"inlined_variant_def: ctor_ty={:?} inlined_vid={:?}\", ctor_ty,\n            inlined_vid);\n@@ -1245,13 +1244,18 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }), ..}) => ty,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n-    let inlined_vid_def_id = ccx.tcx().map.local_def_id(inlined_vid);\n-    adt_def.variants.iter().find(|v| {\n-        inlined_vid_def_id == v.did ||\n-            ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n-    }).unwrap_or_else(|| {\n-        bug!(\"no variant for {:?}::{}\", adt_def, inlined_vid)\n-    })\n+    let variant_def_id = if ccx.tcx().map.is_inlined(inlined_vid) {\n+        ccx.defid_for_inlined_node(inlined_vid).unwrap()\n+    } else {\n+        ccx.tcx().map.local_def_id(inlined_vid)\n+    };\n+\n+    adt_def.variants\n+           .iter()\n+           .find(|v| variant_def_id == v.did)\n+           .unwrap_or_else(|| {\n+                bug!(\"no variant for {:?}::{}\", adt_def, inlined_vid)\n+            })\n }\n \n // To avoid UB from LLVM, these two functions mask RHS with an"}, {"sha": "27048994254caa968bb518f23feb8bc749847e42", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -1026,7 +1026,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                              .get(TransItem::Static(id))\n                              .expect(\"Local statics should always be in the SymbolMap\");\n                 // Make sure that this is never executed for something inlined.\n-                assert!(!ccx.external_srcs().borrow().contains_key(&id));\n+                assert!(!ccx.tcx().map.is_inlined(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()"}, {"sha": "5923f407df7570f555d6207b36a25d52d7c14ad5", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -36,7 +36,7 @@ use session::config::NoDebugInfo;\n use session::Session;\n use symbol_map::SymbolMap;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -101,11 +101,6 @@ pub struct LocalCrateContext<'tcx> {\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n-    /// Track mapping of external ids to local items imported for inlining\n-    external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n-    /// Backwards version of the `external` map (inlined items to where they\n-    /// came from)\n-    external_srcs: RefCell<NodeMap<DefId>>,\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<usize>>,\n@@ -572,8 +567,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n                 drop_glues: RefCell::new(FnvHashMap()),\n-                external: RefCell::new(DefIdMap()),\n-                external_srcs: RefCell::new(NodeMap()),\n                 instances: RefCell::new(FnvHashMap()),\n                 monomorphizing: RefCell::new(DefIdMap()),\n                 vtables: RefCell::new(FnvHashMap()),\n@@ -767,12 +760,12 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().drop_glues\n     }\n \n-    pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n-        &self.local().external\n+    pub fn local_node_for_inlined_defid<'a>(&'a self, def_id: DefId) -> Option<ast::NodeId> {\n+        self.sess().cstore.local_node_for_inlined_defid(def_id)\n     }\n \n-    pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<DefId>> {\n-        &self.local().external_srcs\n+    pub fn defid_for_inlined_node<'a>(&'a self, node_id: ast::NodeId) -> Option<DefId> {\n+        self.sess().cstore.defid_for_inlined_node(node_id)\n     }\n \n     pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {"}, {"sha": "858dcc1bb18cc2cabbb82b3e9a47494c6f1400cd", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -326,13 +326,12 @@ impl<'tcx> TypeMap<'tcx> {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let def_id = if let Some(node_id) = cx.tcx().map.as_local_node_id(def_id) {\n-                match cx.external_srcs().borrow().get(&node_id).cloned() {\n-                    Some(source_def_id) => {\n-                        // The given def_id identifies the inlined copy of a\n-                        // type definition, let's take the source of the copy.\n-                        source_def_id\n-                    }\n-                    None => def_id\n+                if cx.tcx().map.is_inlined(node_id) {\n+                    // The given def_id identifies the inlined copy of a\n+                    // type definition, let's take the source of the copy.\n+                    cx.defid_for_inlined_node(node_id).unwrap()\n+                } else {\n+                    def_id\n                 }\n             } else {\n                 def_id\n@@ -1842,7 +1841,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     // crate should already contain debuginfo for it. More importantly, the\n     // global might not even exist in un-inlined form anywhere which would lead\n     // to a linker errors.\n-    if cx.external_srcs().borrow().contains_key(&node_id) {\n+    if cx.tcx().map.is_inlined(node_id) {\n         return;\n     }\n "}, {"sha": "e8a28d55a73c114e9c1ec580e6c7f5b488fafb6c", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -439,10 +439,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         });\n \n         // Try to get some span information, if we have an inlined item.\n-        let definition_span = match cx.external().borrow().get(&instance.def) {\n-            Some(&Some(node_id)) => cx.tcx().map.span(node_id),\n-            _ => cx.tcx().map.def_id_span(instance.def, syntax_pos::DUMMY_SP)\n-        };\n+        let definition_span = cx.tcx()\n+                                .map\n+                                .def_id_span(instance.def, syntax_pos::DUMMY_SP);\n \n         (containing_scope, definition_span)\n     }"}, {"sha": "facdfe73ddc8e577c046cdccbfddc8d25b6f45cb", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -86,10 +86,7 @@ pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n     });\n \n     // Try to get some span information, if we have an inlined item.\n-    let definition_span = match cx.external().borrow().get(&def_id) {\n-        Some(&Some(node_id)) => cx.tcx().map.span(node_id),\n-        _ => cx.tcx().map.def_id_span(def_id, syntax_pos::DUMMY_SP)\n-    };\n+    let definition_span = cx.tcx().map.def_id_span(def_id, syntax_pos::DUMMY_SP);\n \n     (containing_scope, definition_span)\n }"}, {"sha": "8581fccf10ab53b0d2c783567a4e403ea894e60f", "filename": "src/librustc_trans/inline.rs", "status": "modified", "additions": 6, "deletions": 100, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_trans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Finline.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -8,119 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::{FoundAst, InlinedItem};\n use rustc::hir::def_id::DefId;\n use base::push_ctxt;\n use common::*;\n use monomorphize::Instance;\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir;\n \n fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n     debug!(\"instantiate_inline({:?})\", fn_id);\n     let _icx = push_ctxt(\"instantiate_inline\");\n     let tcx = ccx.tcx();\n     let _task = tcx.dep_graph.in_task(DepNode::TransInlinedItem(fn_id));\n \n-    match ccx.external().borrow().get(&fn_id) {\n-        Some(&Some(node_id)) => {\n-            // Already inline\n-            debug!(\"instantiate_inline({}): already inline as node id {}\",\n-                   tcx.item_path_str(fn_id), node_id);\n-            let node_def_id = tcx.map.local_def_id(node_id);\n-            return Some(node_def_id);\n-        }\n-        Some(&None) => {\n-            return None; // Not inlinable\n-        }\n-        None => {\n-            // Not seen yet\n-        }\n-    }\n-\n-    let inlined = tcx.sess.cstore.maybe_get_item_ast(tcx, fn_id);\n-    let inline_id = match inlined {\n-        FoundAst::NotFound => {\n-            ccx.external().borrow_mut().insert(fn_id, None);\n-            return None;\n-        }\n-        FoundAst::Found(&InlinedItem::Item(ref item)) => {\n-            ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n-            ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n-\n-            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-\n-            item.id\n-        }\n-        FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n-            ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n-            ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n-            item.id\n-        }\n-        FoundAst::FoundParent(parent_id, item) => {\n-            ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n-            ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n-\n-            let mut my_id = 0;\n-            match item.node {\n-                hir::ItemEnum(ref ast_def, _) => {\n-                    let ast_vs = &ast_def.variants;\n-                    let ty_vs = &tcx.lookup_adt_def(parent_id).variants;\n-                    assert_eq!(ast_vs.len(), ty_vs.len());\n-                    for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n-                        if ty_v.did == fn_id { my_id = ast_v.node.data.id(); }\n-                        ccx.external().borrow_mut().insert(ty_v.did, Some(ast_v.node.data.id()));\n-                        ccx.external_srcs().borrow_mut().insert(ast_v.node.data.id(), ty_v.did);\n-                    }\n-                }\n-                hir::ItemStruct(ref struct_def, _) => {\n-                    if struct_def.is_struct() {\n-                        bug!(\"instantiate_inline: called on a \\\n-                              non-tuple struct\")\n-                    } else {\n-                        ccx.external().borrow_mut().insert(fn_id, Some(struct_def.id()));\n-                        ccx.external_srcs().borrow_mut().insert(struct_def.id(), fn_id);\n-                        my_id = struct_def.id();\n-                    }\n-                }\n-                _ => bug!(\"instantiate_inline: item has a \\\n-                           non-enum, non-struct parent\")\n-            }\n-            my_id\n-        }\n-        FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n-            ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n-            ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);\n-\n-            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-\n-            // Associated consts already have to be evaluated in `typeck`, so\n-            // the logic to do that already exists in `middle`. In order to\n-            // reuse that code, it needs to be able to look up the traits for\n-            // inlined items.\n-            let ty_trait_item = tcx.impl_or_trait_item(fn_id).clone();\n-            let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n-            tcx.impl_or_trait_items.borrow_mut()\n-               .insert(trait_item_def_id, ty_trait_item);\n-\n-            // If this is a default method, we can't look up the\n-            // impl type. But we aren't going to translate anyways, so\n-            // don't.\n-            trait_item.id\n-        }\n-        FoundAst::Found(&InlinedItem::ImplItem(_, ref impl_item)) => {\n-            ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n-            ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n-\n-            ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-\n-            impl_item.id\n-        }\n-    };\n-\n-    let inline_def_id = tcx.map.local_def_id(inline_id);\n-    Some(inline_def_id)\n+    tcx.sess\n+       .cstore\n+       .maybe_get_item_ast(tcx, fn_id)\n+       .map(|(_, inline_id)| {\n+            tcx.map.local_def_id(inline_id)\n+       })\n }\n \n pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)"}, {"sha": "3b2bca4ab391225f9e477195a248be95a9b5eefd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -1313,6 +1313,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(trait_did), Some(impl_id))) => {\n+                // For Def::SelfTy() values inlined from another crate, the\n+                // impl_id will be DUMMY_NODE_ID, which would cause problems\n+                // here. But we should never run into an impl from another crate\n+                // in this pass.\n+                assert!(impl_id != ast::DUMMY_NODE_ID);\n+\n                 // `Self` in an impl of a trait - we have a concrete self type and a\n                 // trait reference.\n                 let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(impl_id)).unwrap();\n@@ -1518,6 +1524,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::SelfTy(_, Some(impl_id)) => {\n                 // Self in impl (we know the concrete type).\n+\n+                // For Def::SelfTy() values inlined from another crate, the\n+                // impl_id will be DUMMY_NODE_ID, which would cause problems\n+                // here. But we should never run into an impl from another crate\n+                // in this pass.\n+                assert!(impl_id != ast::DUMMY_NODE_ID);\n+\n                 tcx.prohibit_type_params(base_segments);\n                 let ty = tcx.node_id_to_type(impl_id);\n                 if let Some(free_substs) = self.get_free_substs() {"}, {"sha": "d609ad84a83831dd8920ab84b60e9791231f93f3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a5149617ff95a36405c4c9ac396a50b6ff3f17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d5a5149617ff95a36405c4c9ac396a50b6ff3f17", "patch": "@@ -2691,7 +2691,12 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Static(i, _) => (i, TypeStatic),\n         Def::Variant(i, _) => (i, TypeEnum),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeTrait),\n-        Def::SelfTy(_, Some(impl_id)) => return cx.map.local_def_id(impl_id),\n+        Def::SelfTy(_, Some(impl_id)) => {\n+            // For Def::SelfTy() values inlined from another crate, the\n+            // impl_id will be DUMMY_NODE_ID, which would cause problems.\n+            // But we should never run into an impl from another crate here.\n+            return cx.map.local_def_id(impl_id)\n+        }\n         _ => return def.def_id()\n     };\n     if did.is_local() { return did }"}]}