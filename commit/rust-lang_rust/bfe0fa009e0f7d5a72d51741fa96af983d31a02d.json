{"sha": "bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZTBmYTAwOWUwZjdkNWE3MmQ1MTc0MWZhOTZhZjk4M2QzMWEwMmQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-24T18:35:38Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-24T18:35:43Z"}, "message": "Resolve derive attribute input macro paths in ide layer", "tree": {"sha": "5ac6035d918e07699ff9ab85321e1d0d87919be5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ac6035d918e07699ff9ab85321e1d0d87919be5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "html_url": "https://github.com/rust-lang/rust/commit/bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e45e47c83e31e1aae0a37acb94ea89f367ffa74", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e45e47c83e31e1aae0a37acb94ea89f367ffa74", "html_url": "https://github.com/rust-lang/rust/commit/2e45e47c83e31e1aae0a37acb94ea89f367ffa74"}], "stats": {"total": 214, "additions": 164, "deletions": 50}, "files": [{"sha": "ef4fa9680070c8a6516cc5625c45b260f1e7a552", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 57, "deletions": 22, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "patch": "@@ -5,7 +5,7 @@ use hir::{AsAssocItem, InFile, ModuleDef, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n     defs::{Definition, NameClass, NameRefClass},\n-    helpers::pick_best_token,\n+    helpers::{pick_best_token, try_resolve_derive_input_at},\n     RootDatabase,\n };\n use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, T};\n@@ -78,38 +78,49 @@ pub(crate) fn goto_definition(\n             } else {\n                 reference_definition(&sema, Either::Left(&lt))\n             },\n-            ast::TokenTree(tt) => try_lookup_include_path(sema.db, tt, token, position.file_id)?,\n+            ast::TokenTree(tt) => try_lookup_include_path_or_derive(&sema, tt, token, position.file_id)?,\n             _ => return None,\n         }\n     };\n \n     Some(RangeInfo::new(original_token.text_range(), navs))\n }\n \n-fn try_lookup_include_path(\n-    db: &RootDatabase,\n+fn try_lookup_include_path_or_derive(\n+    sema: &Semantics<RootDatabase>,\n     tt: ast::TokenTree,\n     token: SyntaxToken,\n     file_id: FileId,\n ) -> Option<Vec<NavigationTarget>> {\n-    let path = ast::String::cast(token)?.value()?.into_owned();\n-    let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n-    let name = macro_call.path()?.segment()?.name_ref()?;\n-    if !matches!(&*name.text(), \"include\" | \"include_str\" | \"include_bytes\") {\n-        return None;\n-    }\n-    let file_id = db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n-    let size = db.file_text(file_id).len().try_into().ok()?;\n-    Some(vec![NavigationTarget {\n-        file_id,\n-        full_range: TextRange::new(0.into(), size),\n-        name: path.into(),\n-        focus_range: None,\n-        kind: None,\n-        container_name: None,\n-        description: None,\n-        docs: None,\n-    }])\n+    match ast::String::cast(token.clone()) {\n+        Some(token) => {\n+            let path = token.value()?.into_owned();\n+            let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n+            let name = macro_call.path()?.segment()?.name_ref()?;\n+            if !matches!(&*name.text(), \"include\" | \"include_str\" | \"include_bytes\") {\n+                return None;\n+            }\n+            let file_id = sema.db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n+            let size = sema.db.file_text(file_id).len().try_into().ok()?;\n+            Some(vec![NavigationTarget {\n+                file_id,\n+                full_range: TextRange::new(0.into(), size),\n+                name: path.into(),\n+                focus_range: None,\n+                kind: None,\n+                container_name: None,\n+                description: None,\n+                docs: None,\n+            }])\n+        }\n+        None => try_resolve_derive_input_at(\n+            sema,\n+            &tt.syntax().ancestors().nth(2).and_then(ast::Attr::cast)?,\n+            &token,\n+        )\n+        .and_then(|it| it.try_to_nav(sema.db))\n+        .map(|it| vec![it]),\n+    }\n }\n \n /// finds the trait definition of an impl'd item\n@@ -1383,4 +1394,28 @@ impl Twait for Stwuct {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn goto_def_derive_input() {\n+        check(\n+            r#\"\n+#[rustc_builtin_macro]\n+pub macro Copy {}\n+       // ^^^^\n+#[derive(Copy$0)]\n+struct Foo;\n+            \"#,\n+        );\n+        check(\n+            r#\"\n+mod foo {\n+    #[rustc_builtin_macro]\n+    pub macro Copy {}\n+           // ^^^^\n+}\n+#[derive(foo::Copy$0)]\n+struct Foo;\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "5a23e05ae8810d6658ec36b9ee6753b795207d00", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "patch": "@@ -5,7 +5,7 @@ use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     helpers::{\n         generated_lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES},\n-        pick_best_token, FamousDefs,\n+        pick_best_token, try_resolve_derive_input_at, FamousDefs,\n     },\n     RootDatabase,\n };\n@@ -129,8 +129,12 @@ pub(crate) fn hover(\n                         })?;\n                     range = Some(idl_range);\n                     resolve_doc_path_for_def(db, def, &link, ns).map(Definition::ModuleDef)\n-                } else if let res@Some(_) = try_hover_for_attribute(&token) {\n-                    return res;\n+                } else if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n+                    if let res@Some(_) = try_hover_for_lint(&attr, &token) {\n+                        return res;\n+                    } else {\n+                        try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro)\n+                    }\n                 } else {\n                     None\n                 }\n@@ -197,8 +201,7 @@ pub(crate) fn hover(\n     Some(RangeInfo::new(range, res))\n }\n \n-fn try_hover_for_attribute(token: &SyntaxToken) -> Option<RangeInfo<HoverResult>> {\n-    let attr = token.ancestors().find_map(ast::Attr::cast)?;\n+fn try_hover_for_lint(attr: &ast::Attr, token: &SyntaxToken) -> Option<RangeInfo<HoverResult>> {\n     let (path, tt) = attr.as_simple_call()?;\n     if !tt.syntax().text_range().contains(token.text_range().start()) {\n         return None;\n@@ -3839,4 +3842,48 @@ use crate as foo$0;\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_derive_input() {\n+        check(\n+            r#\"\n+#[rustc_builtin_macro]\n+pub macro Copy {}\n+#[derive(Copy$0)]\n+struct Foo;\n+            \"#,\n+            expect![[r#\"\n+                *(Copy)*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                pub macro Copy\n+                ```\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+mod foo {\n+    #[rustc_builtin_macro]\n+    pub macro Copy {}\n+}\n+#[derive(foo::Copy$0)]\n+struct Foo;\n+            \"#,\n+            expect![[r#\"\n+                *(foo::Copy)*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                pub macro Copy\n+                ```\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "6ace8ce83c650e486ee1e1891b50ff63408e9e6a", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "patch": "@@ -3,6 +3,7 @@\n use hir::{AsAssocItem, HasVisibility, Semantics};\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n+    helpers::try_resolve_derive_input_at,\n     RootDatabase, SymbolKind,\n };\n use rustc_hash::FxHashMap;\n@@ -87,7 +88,18 @@ pub(super) fn element(\n                 _ => Highlight::from(SymbolKind::LifetimeParam) | HlMod::Definition,\n             }\n         }\n-        IDENT if parent_matches::<ast::TokenTree>(&element) => HlTag::None.into(),\n+        IDENT if parent_matches::<ast::TokenTree>(&element) => {\n+            if let Some((attr, token)) =\n+                element.ancestors().nth(2).and_then(ast::Attr::cast).zip(element.as_token())\n+            {\n+                match try_resolve_derive_input_at(sema, &attr, token) {\n+                    Some(makro) => highlight_def(sema.db, krate, Definition::Macro(makro)),\n+                    None => HlTag::None.into(),\n+                }\n+            } else {\n+                HlTag::None.into()\n+            }\n+        }\n         p if p.is_punct() => match p {\n             T![&] if parent_matches::<ast::BinExpr>(&element) => HlOperator::Bitwise.into(),\n             T![&] => {"}, {"sha": "42416afa2514ef4ba4d5a32cd445a5b2174acddc", "filename": "crates/ide/src/syntax_highlighting/test_data/highlighting.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html?ref=bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "patch": "@@ -91,7 +91,7 @@\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n-<span class=\"attribute attribute\">#</span><span class=\"attribute attribute\">[</span><span class=\"builtin_attr attribute\">derive</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">Copy</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute attribute\">]</span>\n+<span class=\"attribute attribute\">#</span><span class=\"attribute attribute\">[</span><span class=\"builtin_attr attribute\">derive</span><span class=\"parenthesis attribute\">(</span><span class=\"macro attribute\">Copy</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute attribute\">]</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">FooCopy</span> <span class=\"brace\">{</span>\n     <span class=\"field declaration\">x</span><span class=\"colon\">:</span> <span class=\"builtin_type\">u32</span><span class=\"comma\">,</span>\n <span class=\"brace\">}</span>"}, {"sha": "2cee442bac9687d1a6a753fb79ada5a4181a93cc", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "patch": "@@ -43,8 +43,8 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     let expr = match_expr.expr()?;\n \n     let mut arms: Vec<MatchArm> = match_arm_list.arms().collect();\n-    if arms.len() == 1 {\n-        if let Some(Pat::WildcardPat(..)) = arms[0].pat() {\n+    if let [arm] = arms.as_slice() {\n+        if let Some(Pat::WildcardPat(..)) = arm.pat() {\n             arms.clear();\n         }\n     }\n@@ -73,9 +73,9 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n             .filter_map(|variant| build_pat(ctx.db(), module, variant))\n             .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n \n-        let missing_pats: Box<dyn Iterator<Item = _>> = if Some(enum_def)\n-            == FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option().map(lift_enum)\n-        {\n+        let option_enum =\n+            FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option().map(lift_enum);\n+        let missing_pats: Box<dyn Iterator<Item = _>> = if Some(enum_def) == option_enum {\n             // Match `Some` variant first.\n             cov_mark::hit!(option_order);\n             Box::new(missing_pats.rev())\n@@ -136,7 +136,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n                 .arms()\n                 .find(|arm| matches!(arm.pat(), Some(ast::Pat::WildcardPat(_))));\n             if let Some(arm) = catch_all_arm {\n-                arm.remove()\n+                arm.remove();\n             }\n             let mut first_new_arm = None;\n             for arm in missing_arms {\n@@ -214,13 +214,7 @@ impl ExtendedEnum {\n fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<ExtendedEnum> {\n     sema.type_of_expr(expr)?.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n         Some(Adt::Enum(e)) => Some(ExtendedEnum::Enum(e)),\n-        _ => {\n-            if ty.is_bool() {\n-                Some(ExtendedEnum::Bool)\n-            } else {\n-                None\n-            }\n-        }\n+        _ => ty.is_bool().then(|| ExtendedEnum::Bool),\n     })\n }\n \n@@ -237,13 +231,7 @@ fn resolve_tuple_of_enum_def(\n                 // For now we only handle expansion for a tuple of enums. Here\n                 // we map non-enum items to None and rely on `collect` to\n                 // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n-                _ => {\n-                    if ty.is_bool() {\n-                        Some(ExtendedEnum::Bool)\n-                    } else {\n-                        None\n-                    }\n-                }\n+                _ => ty.is_bool().then(|| ExtendedEnum::Bool),\n             })\n         })\n         .collect()"}, {"sha": "f9da39f833d4f782534f726612543c6b569a376b", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfe0fa009e0f7d5a72d51741fa96af983d31a02d/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=bfe0fa009e0f7d5a72d51741fa96af983d31a02d", "patch": "@@ -12,7 +12,7 @@ use either::Either;\n use hir::{Crate, Enum, ItemInNs, MacroDef, Module, ModuleDef, Name, ScopeDef, Semantics, Trait};\n use syntax::{\n     ast::{self, make, LoopBodyOwner},\n-    AstNode, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent,\n+    AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent, T,\n };\n \n use crate::RootDatabase;\n@@ -25,6 +25,38 @@ pub fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n     }\n }\n \n+/// Resolves the path at the cursor token as a derive macro if it inside a token tree of a derive attribute.\n+pub fn try_resolve_derive_input_at(\n+    sema: &Semantics<RootDatabase>,\n+    derive_attr: &ast::Attr,\n+    cursor: &SyntaxToken,\n+) -> Option<MacroDef> {\n+    use itertools::Itertools;\n+    if cursor.kind() != T![ident] {\n+        return None;\n+    }\n+    let tt = match derive_attr.as_simple_call() {\n+        Some((name, tt))\n+            if name == \"derive\" && tt.syntax().text_range().contains_range(cursor.text_range()) =>\n+        {\n+            tt\n+        }\n+        _ => return None,\n+    };\n+    let tokens: Vec<_> = cursor\n+        .siblings_with_tokens(Direction::Prev)\n+        .flat_map(SyntaxElement::into_token)\n+        .take_while(|tok| tok.kind() != T!['('] && tok.kind() != T![,])\n+        .collect();\n+    let path = ast::Path::parse(&tokens.into_iter().rev().join(\"\")).ok()?;\n+    match sema.scope(tt.syntax()).speculative_resolve(&path) {\n+        Some(hir::PathResolution::Macro(makro)) if makro.kind() == hir::MacroKind::Derive => {\n+            Some(makro)\n+        }\n+        _ => None,\n+    }\n+}\n+\n /// Picks the token with the highest rank returned by the passed in function.\n pub fn pick_best_token(\n     tokens: TokenAtOffset<SyntaxToken>,"}]}