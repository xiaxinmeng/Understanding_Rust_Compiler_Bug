{"sha": "4db1874f4c26a2c88acb5e46b413e9c4adce3477", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYjE4NzRmNGMyNmEyYzg4YWNiNWU0NmI0MTNlOWM0YWRjZTM0Nzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-15T15:48:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-15T15:48:41Z"}, "message": "Auto merge of #34570 - jseyfried:no_rename, r=nrc\n\nSimplify the macro hygiene algorithm\n\nThis PR removes renaming from the hygiene algorithm and treats differently marked identifiers as unequal.\n\nThis change makes the scope of identifiers in `macro_rules!` items empty. That is, identifiers in `macro_rules!` definitions do not inherit any semantics from the `macro_rules!`'s scope.\n\nSince `macro_rules!` macros are items, the scope of their identifiers \"should\" be the same as that of other items; in particular, the scope should contain only items. Since all items are unhygienic today, this would mean the scope should be empty.\n\nHowever, the scope of an identifier in a `macro_rules!` statement today is the scope that the identifier would have if it replaced the `macro_rules!` (excluding anything unhygienic, i.e. locals only).\n\nTo continue to support this, this PR tracks the scope of each `macro_rules!` and uses it in `resolve` to ensure that an identifier expanded from a `macro_rules!` gets a chance to resolve to the locals in the `macro_rules!`'s scope.\n\nThis PR is a pure refactoring. After this PR,\n - `syntax::ext::expand` is much simpler.\n - We can expand macros in any order without causing problems for hygiene (needed for macro modularization).\n - We can deprecate or remove today's `macro_rules!` scope easily.\n - Expansion performance improves by 25%, post-expansion memory usage decreases by ~5%.\n - Expanding a block is no longer quadratic in the number of `let` statements (fixes #10607).\n\nr? @nrc", "tree": {"sha": "fc2f8bc9199b543239eeb39d531895e500e74542", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc2f8bc9199b543239eeb39d531895e500e74542"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4db1874f4c26a2c88acb5e46b413e9c4adce3477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4db1874f4c26a2c88acb5e46b413e9c4adce3477", "html_url": "https://github.com/rust-lang/rust/commit/4db1874f4c26a2c88acb5e46b413e9c4adce3477", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4db1874f4c26a2c88acb5e46b413e9c4adce3477/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "html_url": "https://github.com/rust-lang/rust/commit/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355"}, {"sha": "c1a6ff2d6b1dccd5af1c6cb9b9e67066af4c0247", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1a6ff2d6b1dccd5af1c6cb9b9e67066af4c0247", "html_url": "https://github.com/rust-lang/rust/commit/c1a6ff2d6b1dccd5af1c6cb9b9e67066af4c0247"}], "stats": {"total": 1057, "additions": 251, "deletions": 806}, "files": [{"sha": "3b1124a911e5d2ad9bb9b8a3acf91f9d531bc34e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 13, "deletions": 57, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -50,7 +50,6 @@ use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::fold::Folder;\n use syntax::parse::{self, PResult, token};\n use syntax::util::node_count::NodeCounter;\n use syntax;\n@@ -695,6 +694,19 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n                                          sess.diagnostic())\n     });\n \n+    let resolver_arenas = Resolver::arenas();\n+    let mut resolver = Resolver::new(sess, make_glob_map, &resolver_arenas);\n+\n+    let krate = time(sess.time_passes(), \"assigning node ids\", || resolver.assign_node_ids(krate));\n+\n+    if sess.opts.debugging_opts.input_stats {\n+        println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n+    }\n+\n+    if sess.opts.debugging_opts.ast_json {\n+        println!(\"{}\", json::as_json(&krate));\n+    }\n+\n     time(time_passes,\n          \"checking for inline asm in case the target doesn't support it\",\n          || no_asm::check_crate(sess, &krate));\n@@ -710,15 +722,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         })\n     })?;\n \n-    if sess.opts.debugging_opts.input_stats {\n-        println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n-    }\n-\n-    krate = assign_node_ids(sess, krate);\n-\n-    let resolver_arenas = Resolver::arenas();\n-    let mut resolver = Resolver::new(sess, make_glob_map, &resolver_arenas);\n-\n     // Collect defintions for def ids.\n     time(sess.time_passes(), \"collecting defs\", || resolver.definitions.collect(&krate));\n \n@@ -783,53 +786,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     })\n }\n \n-pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n-    use syntax::ptr::P;\n-    use syntax::util::move_map::MoveMap;\n-\n-    struct NodeIdAssigner<'a> {\n-        sess: &'a Session,\n-    }\n-\n-    impl<'a> Folder for NodeIdAssigner<'a> {\n-        fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n-            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-            self.sess.next_node_id()\n-        }\n-\n-        fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n-            block.map(|mut block| {\n-                block.id = self.new_id(block.id);\n-\n-                let stmt = block.stmts.pop();\n-                block.stmts = block.stmts.move_flat_map(|s| self.fold_stmt(s).into_iter());\n-                if let Some(ast::Stmt { node: ast::StmtKind::Expr(expr), span, .. }) = stmt {\n-                    let expr = self.fold_expr(expr);\n-                    block.stmts.push(ast::Stmt {\n-                        id: expr.id,\n-                        node: ast::StmtKind::Expr(expr),\n-                        span: span,\n-                    });\n-                } else if let Some(stmt) = stmt {\n-                    block.stmts.extend(self.fold_stmt(stmt));\n-                }\n-\n-                block\n-            })\n-        }\n-    }\n-\n-    let krate = time(sess.time_passes(),\n-                     \"assigning node ids\",\n-                     || NodeIdAssigner { sess: sess }.fold_crate(krate));\n-\n-    if sess.opts.debugging_opts.ast_json {\n-        println!(\"{}\", json::as_json(&krate));\n-    }\n-\n-    krate\n-}\n-\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis."}, {"sha": "d4465822229e953baf1e4d8e38a76138d85cbbd7", "filename": "src/librustc_resolve/assign_ids.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Resolver;\n+use rustc::session::Session;\n+use syntax::ast;\n+use syntax::ext::mtwt;\n+use syntax::fold::{self, Folder};\n+use syntax::ptr::P;\n+use syntax::util::move_map::MoveMap;\n+use syntax::util::small_vector::SmallVector;\n+\n+use std::collections::HashMap;\n+use std::mem;\n+\n+impl<'a> Resolver<'a> {\n+    pub fn assign_node_ids(&mut self, krate: ast::Crate) -> ast::Crate {\n+        NodeIdAssigner {\n+            sess: self.session,\n+            macros_at_scope: &mut self.macros_at_scope,\n+        }.fold_crate(krate)\n+    }\n+}\n+\n+struct NodeIdAssigner<'a> {\n+    sess: &'a Session,\n+    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<ast::Mrk>>,\n+}\n+\n+impl<'a> Folder for NodeIdAssigner<'a> {\n+    fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n+        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+        self.sess.next_node_id()\n+    }\n+\n+    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n+        block.map(|mut block| {\n+            block.id = self.new_id(block.id);\n+\n+            let stmt = block.stmts.pop();\n+            let mut macros = Vec::new();\n+            block.stmts = block.stmts.move_flat_map(|stmt| {\n+                if let ast::StmtKind::Item(ref item) = stmt.node {\n+                    if let ast::ItemKind::Mac(..) = item.node {\n+                        macros.push(mtwt::outer_mark(item.ident.ctxt));\n+                        return None;\n+                    }\n+                }\n+\n+                let stmt = self.fold_stmt(stmt).pop().unwrap();\n+                if !macros.is_empty() {\n+                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n+                }\n+                Some(stmt)\n+            });\n+\n+            stmt.and_then(|mut stmt| {\n+                // Avoid wasting a node id on a trailing expression statement,\n+                // which shares a HIR node with the expression itself.\n+                if let ast::StmtKind::Expr(expr) = stmt.node {\n+                    let expr = self.fold_expr(expr);\n+                    stmt.id = expr.id;\n+                    stmt.node = ast::StmtKind::Expr(expr);\n+                    Some(stmt)\n+                } else {\n+                    self.fold_stmt(stmt).pop()\n+                }\n+            }).map(|stmt| {\n+                if !macros.is_empty() {\n+                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n+                }\n+                block.stmts.push(stmt);\n+            });\n+\n+            block\n+        })\n+    }\n+\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        match item.node {\n+            ast::ItemKind::Mac(..) => SmallVector::zero(),\n+            _ => fold::noop_fold_item(item, self),\n+        }\n+    }\n+}"}, {"sha": "2535c264ef8f647fc516231ae8a55a2ed93375f5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 72, "deletions": 29, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -83,6 +83,7 @@ mod diagnostics;\n mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n+mod assign_ids;\n \n enum SuggestionType {\n     Macro(String),\n@@ -461,7 +462,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = HashMap<Name, BindingInfo>;\n+type BindingMap = HashMap<ast::Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -651,6 +652,9 @@ enum RibKind<'a> {\n \n     // We passed through a module.\n     ModuleRibKind(Module<'a>),\n+\n+    // We passed through a `macro_rules!` statement with the given expansion\n+    MacroDefinition(ast::Mrk),\n }\n \n #[derive(Copy, Clone)]\n@@ -667,7 +671,7 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: HashMap<Name, Def>,\n+    bindings: HashMap<ast::Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n@@ -927,6 +931,10 @@ pub struct Resolver<'a> {\n \n     pub definitions: Definitions,\n \n+    // Maps the node id of a statement to the expansions of the `macro_rules!`s\n+    // immediately above the statement (if appropriate).\n+    macros_at_scope: HashMap<NodeId, Vec<ast::Mrk>>,\n+\n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n@@ -1113,6 +1121,7 @@ impl<'a> Resolver<'a> {\n             session: session,\n \n             definitions: Definitions::new(),\n+            macros_at_scope: HashMap::new(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1384,15 +1393,17 @@ impl<'a> Resolver<'a> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_ident_in_lexical_scope(&mut self,\n-                                      ident: ast::Ident,\n+                                      mut ident: ast::Ident,\n                                       ns: Namespace,\n                                       record_used: bool)\n                                       -> Option<LexicalScopeBinding<'a>> {\n-        let name = match ns { ValueNS => mtwt::resolve(ident), TypeNS => ident.name };\n+        if ns == TypeNS {\n+            ident = ast::Ident::with_empty_ctxt(ident.name);\n+        }\n \n         // Walk backwards up the ribs in scope.\n         for i in (0 .. self.get_ribs(ns).len()).rev() {\n-            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&name).cloned() {\n+            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::LocalDef(LocalDef {\n                     ribs: Some((ns, i)),\n@@ -1419,6 +1430,16 @@ impl<'a> Resolver<'a> {\n                     };\n                 }\n             }\n+\n+            if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n+                // If an invocation of this macro created `ident`, give up on `ident`\n+                // and switch to `ident`'s source from the macro definition.\n+                if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n+                    if mac == source_macro {\n+                        ident = source_ident;\n+                    }\n+                }\n+            }\n         }\n \n         None\n@@ -1555,18 +1576,27 @@ impl<'a> Resolver<'a> {\n \n     /// Searches the current set of local scopes for labels.\n     /// Stops after meeting a closure.\n-    fn search_label(&self, name: Name) -> Option<Def> {\n+    fn search_label(&self, mut ident: ast::Ident) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {\n                     // Continue\n                 }\n+                MacroDefinition(mac) => {\n+                    // If an invocation of this macro created `ident`, give up on `ident`\n+                    // and switch to `ident`'s source from the macro definition.\n+                    if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n+                        if mac == source_macro {\n+                            ident = source_ident;\n+                        }\n+                    }\n+                }\n                 _ => {\n                     // Do not resolve labels across function boundary\n                     return None;\n                 }\n             }\n-            let result = rib.bindings.get(&name).cloned();\n+            let result = rib.bindings.get(&ident).cloned();\n             if result.is_some() {\n                 return result;\n             }\n@@ -1715,7 +1745,7 @@ impl<'a> Resolver<'a> {\n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(space, index as u32, def_id, name);\n-                    function_type_rib.bindings.insert(name, def);\n+                    function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }\n@@ -1886,7 +1916,7 @@ impl<'a> Resolver<'a> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        self_type_rib.bindings.insert(keywords::SelfType.name(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n         self.type_ribs.pop();\n@@ -1997,7 +2027,7 @@ impl<'a> Resolver<'a> {\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(mtwt::resolve(ident.node), binding_info);\n+                    binding_map.insert(ident.node, binding_info);\n                 }\n             }\n             true\n@@ -2019,15 +2049,14 @@ impl<'a> Resolver<'a> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                     None => {\n-                        resolve_error(self,\n-                                      p.span,\n-                                      ResolutionError::VariableNotBoundInPattern(key, 1, i + 1));\n+                        let error = ResolutionError::VariableNotBoundInPattern(key.name, 1, i + 1);\n+                        resolve_error(self, p.span, error);\n                     }\n                     Some(binding_i) => {\n                         if binding_0.binding_mode != binding_i.binding_mode {\n                             resolve_error(self,\n                                           binding_i.span,\n-                                          ResolutionError::VariableBoundWithDifferentMode(key,\n+                                          ResolutionError::VariableBoundWithDifferentMode(key.name,\n                                                                                           i + 1));\n                         }\n                     }\n@@ -2038,7 +2067,7 @@ impl<'a> Resolver<'a> {\n                 if !map_0.contains_key(&key) {\n                     resolve_error(self,\n                                   binding.span,\n-                                  ResolutionError::VariableNotBoundInPattern(key, i + 1, 1));\n+                                  ResolutionError::VariableNotBoundInPattern(key.name, i + 1, 1));\n                 }\n             }\n         }\n@@ -2068,6 +2097,7 @@ impl<'a> Resolver<'a> {\n         let orig_module = self.current_module;\n         let anonymous_module = self.module_map.get(&block.id).cloned(); // clones a reference\n \n+        let mut num_macro_definition_ribs = 0;\n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");\n             self.value_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n@@ -2078,10 +2108,24 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Descend into the block.\n-        visit::walk_block(self, block);\n+        for stmt in &block.stmts {\n+            if let Some(marks) = self.macros_at_scope.remove(&stmt.id) {\n+                num_macro_definition_ribs += marks.len() as u32;\n+                for mark in marks {\n+                    self.value_ribs.push(Rib::new(MacroDefinition(mark)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(mark)));\n+                }\n+            }\n+\n+            self.visit_stmt(stmt);\n+        }\n \n         // Move back up.\n         self.current_module = orig_module;\n+        for _ in 0 .. num_macro_definition_ribs {\n+            self.value_ribs.pop();\n+            self.label_ribs.pop();\n+        }\n         self.value_ribs.pop();\n         if let Some(_) = anonymous_module {\n             self.type_ribs.pop();\n@@ -2172,16 +2216,15 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut HashMap<Name, NodeId>)\n+                     bindings: &mut HashMap<ast::Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n         // must not add it if it's in the bindings map\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n-        let renamed = mtwt::resolve(ident.node);\n         let mut def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n-        match bindings.get(&renamed).cloned() {\n+        match bindings.get(&ident.node).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n                 resolve_error(\n@@ -2203,7 +2246,7 @@ impl<'a> Resolver<'a> {\n             Some(..) if pat_src == PatternSource::Match => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                def = self.value_ribs.last_mut().unwrap().bindings[&renamed];\n+                def = self.value_ribs.last_mut().unwrap().bindings[&ident.node];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n@@ -2212,8 +2255,8 @@ impl<'a> Resolver<'a> {\n             None => {\n                 // A completely fresh binding, add to the lists if it's valid.\n                 if ident.node.name != keywords::Invalid.name() {\n-                    bindings.insert(renamed, outer_pat_id);\n-                    self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n+                    bindings.insert(ident.node, outer_pat_id);\n+                    self.value_ribs.last_mut().unwrap().bindings.insert(ident.node, def);\n                 }\n             }\n         }\n@@ -2274,7 +2317,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut HashMap<Name, NodeId>) {\n+                       bindings: &mut HashMap<ast::Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -2497,7 +2540,7 @@ impl<'a> Resolver<'a> {\n             Def::Local(_, node_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | ModuleRibKind(..) => {\n+                        NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n@@ -2546,7 +2589,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | MethodRibKind(_) | ClosureRibKind(..) |\n-                        ModuleRibKind(..) => {\n+                        ModuleRibKind(..) | MacroDefinition(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind => {\n@@ -2747,7 +2790,7 @@ impl<'a> Resolver<'a> {\n         let names = self.value_ribs\n                     .iter()\n                     .rev()\n-                    .flat_map(|rib| rib.bindings.keys());\n+                    .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n \n         if let Some(found) = find_best_match_for_name(names, name, None) {\n             if name != found {\n@@ -2758,7 +2801,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_labeled_block(&mut self, label: Option<ast::Ident>, id: NodeId, block: &Block) {\n         if let Some(label) = label {\n-            let (label, def) = (mtwt::resolve(label), Def::Label(id));\n+            let def = Def::Label(id);\n             self.with_label_rib(|this| {\n                 this.label_ribs.last_mut().unwrap().bindings.insert(label, def);\n                 this.visit_block(block);\n@@ -2965,15 +3008,15 @@ impl<'a> Resolver<'a> {\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(mtwt::resolve(label.node), def);\n+                        rib.bindings.insert(label.node, def);\n                     }\n \n                     visit::walk_expr(this, expr);\n                 })\n             }\n \n             ExprKind::Break(Some(label)) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(mtwt::resolve(label.node)) {\n+                match self.search_label(label.node) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,"}, {"sha": "6b662c6779a4bd118e2dcffbe9c81b47a91c92b6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -26,7 +26,6 @@ use tokenstream::{TokenTree};\n \n use std::fmt;\n use std::rc::Rc;\n-use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n@@ -46,7 +45,7 @@ pub struct SyntaxContext(pub u32);\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n-#[derive(Clone, Copy, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Ident {\n     pub name: Name,\n     pub ctxt: SyntaxContext\n@@ -93,40 +92,6 @@ impl Ident {\n     }\n }\n \n-impl PartialEq for Ident {\n-    fn eq(&self, other: &Ident) -> bool {\n-        if self.ctxt != other.ctxt {\n-            // There's no one true way to compare Idents. They can be compared\n-            // non-hygienically `id1.name == id2.name`, hygienically\n-            // `mtwt::resolve(id1) == mtwt::resolve(id2)`, or even member-wise\n-            // `(id1.name, id1.ctxt) == (id2.name, id2.ctxt)` depending on the situation.\n-            // Ideally, PartialEq should not be implemented for Ident at all, but that\n-            // would be too impractical, because many larger structures (Token, in particular)\n-            // including Idents as their parts derive PartialEq and use it for non-hygienic\n-            // comparisons. That's why PartialEq is implemented and defaults to non-hygienic\n-            // comparison. Hash is implemented too and is consistent with PartialEq, i.e. only\n-            // the name of Ident is hashed. Still try to avoid comparing idents in your code\n-            // (especially as keys in hash maps), use one of the three methods listed above\n-            // explicitly.\n-            //\n-            // If you see this panic, then some idents from different contexts were compared\n-            // non-hygienically. It's likely a bug. Use one of the three comparison methods\n-            // listed above explicitly.\n-\n-            panic!(\"idents with different contexts are compared with operator `==`: \\\n-                {:?}, {:?}.\", self, other);\n-        }\n-\n-        self.name == other.name\n-    }\n-}\n-\n-impl Hash for Ident {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.name.hash(state)\n-    }\n-}\n-\n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}#{}\", self.name, self.ctxt.0)"}, {"sha": "7ebcd12cdb9512853b9122c49079f8690a381e65", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -26,7 +26,6 @@ use parse::token::{InternedString, intern, str_to_ident};\n use ptr::P;\n use util::small_vector::SmallVector;\n use util::lev_distance::find_best_match_for_name;\n-use ext::mtwt;\n use fold::Folder;\n \n use std::collections::{HashMap, HashSet};\n@@ -483,15 +482,12 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n pub struct BlockInfo {\n     /// Should macros escape from this scope?\n     pub macros_escape: bool,\n-    /// What are the pending renames?\n-    pub pending_renames: mtwt::RenameList,\n }\n \n impl BlockInfo {\n     pub fn new() -> BlockInfo {\n         BlockInfo {\n             macros_escape: false,\n-            pending_renames: Vec::new(),\n         }\n     }\n }"}, {"sha": "3e9837a6995c3f06ba9791404a010603a49ec61d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 34, "deletions": 558, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -8,23 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, PatKind};\n-use ast::{Local, Ident, Mac_, Name, SpannedIdent};\n+use ast::{Block, Crate, Ident, Mac_, Name, PatKind};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast;\n use attr::HasAttrs;\n use ext::mtwt;\n use attr;\n use attr::AttrMetaMethods;\n-use codemap::{Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{dummy_spanned, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use util::move_map::MoveMap;\n-use parse::token::{fresh_mark, fresh_name, intern, keywords};\n+use parse::token::{fresh_mark, intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n@@ -96,89 +94,32 @@ impl MacroGenerable for Option<P<ast::Expr>> {\n     }\n }\n \n-pub fn expand_expr(mut expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n+pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n     match expr.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n             return expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, fld);\n         }\n+        _ => P(noop_fold_expr(expr, fld)),\n+    }\n+}\n \n-        ast::ExprKind::While(cond, body, opt_ident) => {\n-            let cond = fld.fold_expr(cond);\n-            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            expr.node = ast::ExprKind::While(cond, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::WhileLet(pat, cond, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n-            let cond = fld.fold_expr(cond);\n-\n-            // Hygienic renaming of the body.\n-            let ((body, opt_ident), mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                (body, opt_ident),\n-                                |rename_fld, fld, (body, opt_ident)| {\n-                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            expr.node = ast::ExprKind::WhileLet(rewritten_pats.remove(0), cond, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::Loop(loop_block, opt_ident) => {\n-            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            expr.node = ast::ExprKind::Loop(loop_block, opt_ident);\n-        }\n-\n-        ast::ExprKind::ForLoop(pat, head, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n-\n-            // Hygienic renaming of the for loop body (for loop binds its pattern).\n-            let ((body, opt_ident), mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                (body, opt_ident),\n-                                |rename_fld, fld, (body, opt_ident)| {\n-                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            let head = fld.fold_expr(head);\n-            expr.node = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::IfLet(pat, sub_expr, body, else_opt) => {\n-            let pat = fld.fold_pat(pat);\n-\n-            // Hygienic renaming of the body.\n-            let (body, mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                body,\n-                                |rename_fld, fld, body| {\n-                fld.fold_block(rename_fld.fold_block(body))\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n-            let sub_expr = fld.fold_expr(sub_expr);\n-            expr.node = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n-        }\n-\n-        ast::ExprKind::Closure(capture_clause, fn_decl, block, fn_decl_span) => {\n-            let (rewritten_fn_decl, rewritten_block)\n-                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            expr.node = ast::ExprKind::Closure(capture_clause,\n-                                               rewritten_fn_decl,\n-                                               rewritten_block,\n-                                               fn_decl_span);\n-        }\n-\n-        _ => expr = noop_fold_expr(expr, fld),\n-    };\n-    P(expr)\n+struct MacroScopePlaceholder;\n+impl MacResult for MacroScopePlaceholder {\n+    fn make_items(self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n+        Some(SmallVector::one(P(ast::Item {\n+            ident: keywords::Invalid.ident(),\n+            attrs: Vec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::ItemKind::Mac(dummy_spanned(ast::Mac_ {\n+                path: ast::Path { span: syntax_pos::DUMMY_SP, global: false, segments: Vec::new() },\n+                tts: Vec::new(),\n+            })),\n+            vis: ast::Visibility::Inherited,\n+            span: syntax_pos::DUMMY_SP,\n+        })))\n+    }\n }\n \n /// Expand a macro invocation. Returns the result of expansion.\n@@ -219,6 +160,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n         };\n \n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n+        let marked_tts = mark_tts(&tts, mark);\n         match *extension {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n@@ -237,7 +179,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     },\n                 });\n \n-                let marked_tts = mark_tts(&tts, mark);\n                 Some(expandfun.expand(fld.cx, call_site, &marked_tts))\n             }\n \n@@ -257,7 +198,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     }\n                 });\n \n-                let marked_tts = mark_tts(&tts, mark);\n                 Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n             }\n \n@@ -286,15 +226,14 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     span: call_site,\n                     imported_from: None,\n                     use_locally: true,\n-                    body: tts,\n+                    body: marked_tts,\n                     export: attr::contains_name(&attrs, \"macro_export\"),\n                     allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n                     attrs: attrs,\n                 });\n \n                 // macro_rules! has a side effect but expands to nothing.\n-                fld.cx.bt_pop();\n-                None\n+                Some(Box::new(MacroScopePlaceholder))\n             }\n \n             MultiDecorator(..) | MultiModifier(..) => {\n@@ -327,41 +266,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n     fully_expanded\n }\n \n-/// Rename loop label and expand its loop body\n-///\n-/// The renaming procedure for loop is different in the sense that the loop\n-/// body is in a block enclosed by loop head so the renaming of loop label\n-/// must be propagated to the enclosed context.\n-fn expand_loop_block(loop_block: P<Block>,\n-                     opt_ident: Option<SpannedIdent>,\n-                     fld: &mut MacroExpander) -> (P<Block>, Option<SpannedIdent>) {\n-    match opt_ident {\n-        Some(label) => {\n-            let new_label = fresh_name(label.node);\n-            let rename = (label.node, new_label);\n-\n-            // The rename *must not* be added to the pending list of current\n-            // syntax context otherwise an unrelated `break` or `continue` in\n-            // the same context will pick that up in the deferred renaming pass\n-            // and be renamed incorrectly.\n-            let mut rename_list = vec!(rename);\n-            let mut rename_fld = IdentRenamer{renames: &mut rename_list};\n-            let renamed_ident = rename_fld.fold_ident(label.node);\n-\n-            // The rename *must* be added to the enclosed syntax context for\n-            // `break` or `continue` to pick up because by definition they are\n-            // in a block enclosed by loop head.\n-            fld.cx.syntax_env.push_frame();\n-            fld.cx.syntax_env.info().pending_renames.push(rename);\n-            let expanded_block = expand_block_elts(loop_block, fld);\n-            fld.cx.syntax_env.pop_frame();\n-\n-            (expanded_block, Some(Spanned { node: renamed_ident, span: label.span }))\n-        }\n-        None => (fld.fold_block(loop_block), opt_ident)\n-    }\n-}\n-\n // eval $e with a new exts frame.\n // must be a macro so that $e isn't evaluated too early.\n macro_rules! with_exts_frame {\n@@ -381,20 +285,6 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n         .into_iter().map(|i| i.expect_item()).collect()\n }\n \n-/// Expand item_kind\n-fn expand_item_kind(item: ast::ItemKind, fld: &mut MacroExpander) -> ast::ItemKind {\n-    match item {\n-        ast::ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n-            let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(decl, body, fld);\n-            let expanded_generics = fold::noop_fold_generics(generics,fld);\n-            ast::ItemKind::Fn(rewritten_fn_decl, unsafety, constness, abi,\n-                        expanded_generics, rewritten_body)\n-        }\n-        _ => noop_fold_item_kind(item, fld)\n-    }\n-}\n-\n // does this attribute list contain \"macro_use\" ?\n fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n     for attr in attrs {\n@@ -425,16 +315,9 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n \n /// Expand a stmt\n fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n-    // perform all pending renames\n-    let stmt = {\n-        let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n-        let mut rename_fld = IdentRenamer{renames:pending_renames};\n-        rename_fld.fold_stmt(stmt).expect_one(\"rename_fold didn't return one value\")\n-    };\n-\n     let (mac, style, attrs) = match stmt.node {\n         StmtKind::Mac(mac) => mac.unwrap(),\n-        _ => return expand_non_macro_stmt(stmt, fld)\n+        _ => return noop_fold_stmt(stmt, fld)\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n@@ -451,167 +334,6 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     fully_expanded\n }\n \n-// expand a non-macro stmt. this is essentially the fallthrough for\n-// expand_stmt, above.\n-fn expand_non_macro_stmt(stmt: Stmt, fld: &mut MacroExpander)\n-                         -> SmallVector<Stmt> {\n-    // is it a let?\n-    match stmt.node {\n-        StmtKind::Local(local) => {\n-            // take it apart:\n-            let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n-                // expand the ty since TyKind::FixedLengthVec contains an Expr\n-                // and thus may have a macro use\n-                let expanded_ty = ty.map(|t| fld.fold_ty(t));\n-                // expand the pat (it might contain macro uses):\n-                let expanded_pat = fld.fold_pat(pat);\n-                // find the PatIdents in the pattern:\n-                // oh dear heaven... this is going to include the enum\n-                // names, as well... but that should be okay, as long as\n-                // the new names are gensyms for the old ones.\n-                // generate fresh names, push them to a new pending list\n-                let idents = pattern_bindings(&expanded_pat);\n-                let mut new_pending_renames =\n-                    idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n-                // rewrite the pattern using the new names (the old\n-                // ones have already been applied):\n-                let rewritten_pat = {\n-                    // nested binding to allow borrow to expire:\n-                    let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n-                    rename_fld.fold_pat(expanded_pat)\n-                };\n-                // add them to the existing pending renames:\n-                fld.cx.syntax_env.info().pending_renames\n-                      .extend(new_pending_renames);\n-                Local {\n-                    id: id,\n-                    ty: expanded_ty,\n-                    pat: rewritten_pat,\n-                    // also, don't forget to expand the init:\n-                    init: init.map(|e| fld.fold_expr(e)),\n-                    span: span,\n-                    attrs: fold::fold_thin_attrs(attrs, fld),\n-                }\n-            });\n-            SmallVector::one(Stmt {\n-                id: stmt.id,\n-                node: StmtKind::Local(rewritten_local),\n-                span: stmt.span,\n-            })\n-        }\n-        _ => noop_fold_stmt(stmt, fld),\n-    }\n-}\n-\n-// expand the arm of a 'match', renaming for macro hygiene\n-fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n-    // expand pats... they might contain macro uses:\n-    let expanded_pats = arm.pats.move_map(|pat| fld.fold_pat(pat));\n-    if expanded_pats.is_empty() {\n-        panic!(\"encountered match arm with 0 patterns\");\n-    }\n-\n-    // apply renaming and then expansion to the guard and the body:\n-    let ((rewritten_guard, rewritten_body), rewritten_pats) =\n-        rename_in_scope(expanded_pats,\n-                        fld,\n-                        (arm.guard, arm.body),\n-                        |rename_fld, fld, (ag, ab)|{\n-        let rewritten_guard = ag.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n-        let rewritten_body = fld.fold_expr(rename_fld.fold_expr(ab));\n-        (rewritten_guard, rewritten_body)\n-    });\n-\n-    ast::Arm {\n-        attrs: fold::fold_attrs(arm.attrs, fld),\n-        pats: rewritten_pats,\n-        guard: rewritten_guard,\n-        body: rewritten_body,\n-    }\n-}\n-\n-fn rename_in_scope<X, F>(pats: Vec<P<ast::Pat>>,\n-                         fld: &mut MacroExpander,\n-                         x: X,\n-                         f: F)\n-                         -> (X, Vec<P<ast::Pat>>)\n-    where F: Fn(&mut IdentRenamer, &mut MacroExpander, X) -> X\n-{\n-    // all of the pats must have the same set of bindings, so use the\n-    // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&pats[0]);\n-    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n-    // apply the renaming, but only to the PatIdents:\n-    let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n-    let rewritten_pats = pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n-\n-    let mut rename_fld = IdentRenamer{ renames:&new_renames };\n-    (f(&mut rename_fld, fld, x), rewritten_pats)\n-}\n-\n-/// A visitor that extracts the PatKind::Ident (binding) paths\n-/// from a given thingy and puts them in a mutable\n-/// array\n-#[derive(Clone)]\n-struct PatIdentFinder {\n-    ident_accumulator: Vec<ast::Ident>\n-}\n-\n-impl Visitor for PatIdentFinder {\n-    fn visit_pat(&mut self, pattern: &ast::Pat) {\n-        match *pattern {\n-            ast::Pat { id: _, node: PatKind::Ident(_, ref path1, ref inner), span: _ } => {\n-                self.ident_accumulator.push(path1.node);\n-                // visit optional subpattern of PatKind::Ident:\n-                if let Some(ref subpat) = *inner {\n-                    self.visit_pat(subpat)\n-                }\n-            }\n-            // use the default traversal for non-PatIdents\n-            _ => visit::walk_pat(self, pattern)\n-        }\n-    }\n-}\n-\n-/// find the PatKind::Ident paths in a pattern\n-fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n-    let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n-    name_finder.visit_pat(pat);\n-    name_finder.ident_accumulator\n-}\n-\n-/// find the PatKind::Ident paths in a\n-fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n-    let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n-    for arg in &fn_decl.inputs {\n-        pat_idents.visit_pat(&arg.pat);\n-    }\n-    pat_idents.ident_accumulator\n-}\n-\n-// expand a block. pushes a new exts_frame, then calls expand_block_elts\n-pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    // see note below about treatment of exts table\n-    with_exts_frame!(fld.cx.syntax_env,false,\n-                     expand_block_elts(blk, fld))\n-}\n-\n-// expand the elements of a block.\n-pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, stmts, rules, span}| {\n-        let new_stmts = stmts.into_iter().flat_map(|x| {\n-            // perform pending renames and expand macros in the statement\n-            fld.fold_stmt(x).into_iter()\n-        }).collect();\n-        Block {\n-            id: fld.new_id(id),\n-            stmts: new_stmts,\n-            rules: rules,\n-            span: span\n-        }\n-    })\n-}\n-\n fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     match p.node {\n         PatKind::Mac(_) => {}\n@@ -625,62 +347,16 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     })\n }\n \n-/// A tree-folder that applies every rename in its (mutable) list\n-/// to every identifier, including both bindings and varrefs\n-/// (and lots of things that will turn out to be neither)\n-pub struct IdentRenamer<'a> {\n-    renames: &'a mtwt::RenameList,\n-}\n-\n-impl<'a> Folder for IdentRenamer<'a> {\n-    fn fold_ident(&mut self, id: Ident) -> Ident {\n-        mtwt::apply_renames(self.renames, id)\n-    }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}\n-\n-/// A tree-folder that applies every rename in its list to\n-/// the idents that are in PatKind::Ident patterns. This is more narrowly\n-/// focused than IdentRenamer, and is needed for FnDecl,\n-/// where we want to rename the args but not the fn name or the generics etc.\n-pub struct PatIdentRenamer<'a> {\n-    renames: &'a mtwt::RenameList,\n-}\n-\n-impl<'a> Folder for PatIdentRenamer<'a> {\n-    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        match pat.node {\n-            PatKind::Ident(..) => {},\n-            _ => return noop_fold_pat(pat, self)\n-        }\n-\n-        pat.map(|ast::Pat {id, node, span}| match node {\n-            PatKind::Ident(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n-                let new_ident = mtwt::apply_renames(self.renames, ident);\n-                let new_node =\n-                    PatKind::Ident(binding_mode,\n-                                  Spanned{span: sp, node: new_ident},\n-                                  sub.map(|p| self.fold_pat(p)));\n-                ast::Pat {\n-                    id: id,\n-                    node: new_node,\n-                    span: span,\n-                }\n-            },\n-            _ => unreachable!()\n-        })\n-    }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}\n-\n fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n     match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n+                if match it.node {\n+                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n+                    _ => unreachable!(),\n+                } {\n+                    return SmallVector::one(Annotatable::Item(it));\n+                }\n                 it.and_then(|it| match it.node {\n                     ItemKind::Mac(mac) =>\n                         expand_mac_invoc(mac, Some(it.ident), it.attrs, it.span, fld),\n@@ -774,21 +450,6 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n                  -> SmallVector<ast::ImplItem> {\n     match ii.node {\n-        ast::ImplItemKind::Method(..) => SmallVector::one(ast::ImplItem {\n-            id: ii.id,\n-            ident: ii.ident,\n-            attrs: ii.attrs,\n-            vis: ii.vis,\n-            defaultness: ii.defaultness,\n-            node: match ii.node {\n-                ast::ImplItemKind::Method(sig, body) => {\n-                    let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                    ast::ImplItemKind::Method(sig, body)\n-                }\n-                _ => unreachable!()\n-            },\n-            span: ii.span,\n-        }),\n         ast::ImplItemKind::Macro(mac) => {\n             expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n         }\n@@ -799,61 +460,13 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n                      -> SmallVector<ast::TraitItem> {\n     match ti.node {\n-        ast::TraitItemKind::Method(_, Some(_)) => {\n-            SmallVector::one(ast::TraitItem {\n-                id: ti.id,\n-                ident: ti.ident,\n-                attrs: ti.attrs,\n-                node: match ti.node  {\n-                    ast::TraitItemKind::Method(sig, Some(body)) => {\n-                        let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                        ast::TraitItemKind::Method(sig, Some(body))\n-                    }\n-                    _ => unreachable!()\n-                },\n-                span: ti.span,\n-            })\n-        }\n         ast::TraitItemKind::Macro(mac) => {\n             expand_mac_invoc(mac, None, ti.attrs, ti.span, fld)\n         }\n         _ => fold::noop_fold_trait_item(ti, fld)\n     }\n }\n \n-/// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n-/// PatIdents in its arguments to perform renaming in the FnDecl and\n-/// the block, returning both the new FnDecl and the new Block.\n-fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Block>,\n-                                       fld: &mut MacroExpander)\n-                                       -> (P<ast::FnDecl>, P<ast::Block>) {\n-    let expanded_decl = fld.fold_fn_decl(fn_decl);\n-    let idents = fn_decl_arg_bindings(&expanded_decl);\n-    let renames =\n-        idents.iter().map(|id| (*id,fresh_name(*id))).collect();\n-    // first, a renamer for the PatIdents, for the fn_decl:\n-    let mut rename_pat_fld = PatIdentRenamer{renames: &renames};\n-    let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(expanded_decl);\n-    // now, a renamer for *all* idents, for the body:\n-    let mut rename_fld = IdentRenamer{renames: &renames};\n-    let rewritten_body = fld.fold_block(rename_fld.fold_block(block));\n-    (rewritten_fn_decl,rewritten_body)\n-}\n-\n-fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n-                            fld: &mut MacroExpander)\n-                            -> (ast::MethodSig, P<ast::Block>) {\n-    let (rewritten_fn_decl, rewritten_body)\n-        = expand_and_rename_fn_decl_and_block(sig.decl, body, fld);\n-    (ast::MethodSig {\n-        generics: fld.fold_generics(sig.generics),\n-        abi: sig.abi,\n-        unsafety: sig.unsafety,\n-        constness: sig.constness,\n-        decl: rewritten_fn_decl\n-    }, rewritten_body)\n-}\n-\n pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n         ast::TyKind::Mac(mac) => {\n@@ -976,25 +589,17 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         result\n     }\n \n-    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        expand_item_kind(item, self)\n-    }\n-\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         expand_stmt(stmt, self)\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n         let was_in_block = ::std::mem::replace(&mut self.cx.in_block, true);\n-        let result = expand_block(block, self);\n+        let result = with_exts_frame!(self.cx.syntax_env, false, noop_fold_block(block, self));\n         self.cx.in_block = was_in_block;\n         result\n     }\n \n-    fn fold_arm(&mut self, arm: ast::Arm) -> ast::Arm {\n-        expand_arm(arm, self)\n-    }\n-\n     fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n         expand_annotatable(Annotatable::TraitItem(P(i)), self)\n             .into_iter().map(|i| i.expect_trait_item()).collect()\n@@ -1145,18 +750,11 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n \n #[cfg(test)]\n mod tests {\n-    use super::{pattern_bindings, expand_crate};\n-    use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer, ExpansionConfig};\n+    use super::{expand_crate, ExpansionConfig};\n     use ast;\n-    use ast::Name;\n-    use syntax_pos;\n     use ext::base::{ExtCtxt, DummyMacroLoader};\n-    use ext::mtwt;\n-    use fold::Folder;\n     use parse;\n-    use parse::token;\n     use util::parser_testing::{string_to_parser};\n-    use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;\n     use visit::Visitor;\n \n@@ -1177,32 +775,6 @@ mod tests {\n         }\n     }\n \n-    // find the variable references in a crate\n-    fn crate_varrefs(the_crate : &ast::Crate) -> Vec<ast::Path> {\n-        let mut path_finder = PathExprFinderContext{path_accumulator:Vec::new()};\n-        visit::walk_crate(&mut path_finder, the_crate);\n-        path_finder.path_accumulator\n-    }\n-\n-    /// A Visitor that extracts the identifiers from a thingy.\n-    // as a side note, I'm starting to want to abstract over these....\n-    struct IdentFinder {\n-        ident_accumulator: Vec<ast::Ident>\n-    }\n-\n-    impl Visitor for IdentFinder {\n-        fn visit_ident(&mut self, _: syntax_pos::Span, id: ast::Ident){\n-            self.ident_accumulator.push(id);\n-        }\n-    }\n-\n-    /// Find the idents in a crate\n-    fn crate_idents(the_crate: &ast::Crate) -> Vec<ast::Ident> {\n-        let mut ident_finder = IdentFinder{ident_accumulator: Vec::new()};\n-        visit::walk_crate(&mut ident_finder, the_crate);\n-        ident_finder.ident_accumulator\n-    }\n-\n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n@@ -1264,13 +836,6 @@ mod tests {\n         expand_crate(ecx, vec![], crate_ast).0\n     }\n \n-    // find the pat_ident paths in a crate\n-    fn crate_bindings(the_crate : &ast::Crate) -> Vec<ast::Ident> {\n-        let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n-        visit::walk_crate(&mut name_finder, the_crate);\n-        name_finder.ident_accumulator\n-    }\n-\n     #[test] fn macro_tokens_should_match(){\n         expand_crate_str(\n             \"macro_rules! m((a)=>(13)) ;fn main(){m!(a);}\".to_string());\n@@ -1287,93 +852,4 @@ mod tests {\n     // create a really evil test case where a $x appears inside a binding of $x\n     // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n-\n-    #[test]\n-    fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_string()));\n-macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}));\n-foo_module!();\n-\".to_string();\n-        let cr = expand_crate_str(crate_str);\n-        // find the xx binding\n-        let bindings = crate_bindings(&cr);\n-        let cxbinds: Vec<&ast::Ident> =\n-            bindings.iter().filter(|b| b.name.as_str() == \"xx\").collect();\n-        let cxbinds: &[&ast::Ident] = &cxbinds[..];\n-        let cxbind = match (cxbinds.len(), cxbinds.get(0)) {\n-            (1, Some(b)) => *b,\n-            _ => panic!(\"expected just one binding for ext_cx\")\n-        };\n-        let resolved_binding = mtwt::resolve(*cxbind);\n-        let varrefs = crate_varrefs(&cr);\n-\n-        // the xx binding should bind all of the xx varrefs:\n-        for (idx,v) in varrefs.iter().filter(|p| {\n-            p.segments.len() == 1\n-            && p.segments[0].identifier.name.as_str() == \"xx\"\n-        }).enumerate() {\n-            if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n-                println!(\"uh oh, xx binding didn't match xx varref:\");\n-                println!(\"this is xx varref \\\\# {}\", idx);\n-                println!(\"binding: {}\", cxbind);\n-                println!(\"resolves to: {}\", resolved_binding);\n-                println!(\"varref: {}\", v.segments[0].identifier);\n-                println!(\"resolves to: {}\",\n-                         mtwt::resolve(v.segments[0].identifier));\n-                mtwt::with_sctable(|x| mtwt::display_sctable(x));\n-            }\n-            assert_eq!(mtwt::resolve(v.segments[0].identifier),\n-                       resolved_binding);\n-        };\n-    }\n-\n-    #[test]\n-    fn pat_idents(){\n-        let pat = string_to_pat(\n-            \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_string());\n-        let idents = pattern_bindings(&pat);\n-        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n-    }\n-\n-    // test the list of identifier patterns gathered by the visitor. Note that\n-    // 'None' is listed as an identifier pattern because we don't yet know that\n-    // it's the name of a 0-ary variant, and that 'i' appears twice in succession.\n-    #[test]\n-    fn crate_bindings_test(){\n-        let the_crate = string_to_crate(\"fn main (a: i32) -> i32 {|b| {\n-        match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n-        let idents = crate_bindings(&the_crate);\n-        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n-    }\n-\n-    // test the IdentRenamer directly\n-    #[test]\n-    fn ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n-        let f_ident = token::str_to_ident(\"f\");\n-        let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"i32\");\n-        let renames = vec!((x_ident,Name(16)));\n-        let mut renamer = IdentRenamer{renames: &renames};\n-        let renamed_crate = renamer.fold_crate(the_crate);\n-        let idents = crate_idents(&renamed_crate);\n-        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),Name(16),Name(16)]);\n-    }\n-\n-    // test the PatIdentRenamer; only PatIdents get renamed\n-    #[test]\n-    fn pat_ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n-        let f_ident = token::str_to_ident(\"f\");\n-        let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"i32\");\n-        let renames = vec!((x_ident,Name(16)));\n-        let mut renamer = PatIdentRenamer{renames: &renames};\n-        let renamed_crate = renamer.fold_crate(the_crate);\n-        let idents = crate_idents(&renamed_crate);\n-        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        let x_name = x_ident.name;\n-        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),x_name,x_name]);\n-    }\n }"}, {"sha": "d2f6df9d5dbd3f1936609ee2b613a257c70fe5eb", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 28, "deletions": 92, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -17,37 +17,27 @@\n \n pub use self::SyntaxContext_::*;\n \n-use ast::{Ident, Mrk, Name, SyntaxContext};\n+use ast::{Ident, Mrk, SyntaxContext};\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n \n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having\n /// managed pointers everywhere (that caused an ICE).\n-/// the `marks` and `renames` fields are side-tables\n-/// that ensure that adding the same mark to the same context\n-/// gives you back the same context as before. This should cut\n-/// down on memory use *a lot*; applying a mark to a tree containing\n-/// 50 identifiers would otherwise generate 50 new contexts.\n+/// The `marks` ensures that adding the same mark to the\n+/// same context gives you back the same context as before.\n pub struct SCTable {\n     table: RefCell<Vec<SyntaxContext_>>,\n     marks: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-    renames: RefCell<HashMap<Name,SyntaxContext>>,\n }\n \n #[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n-    Rename (Name),\n-    /// actually, IllegalCtxt may not be necessary.\n-    IllegalCtxt\n }\n \n-/// A list of ident->name renamings\n-pub type RenameList = Vec<(Ident, Name)>;\n-\n /// Extend a syntax context with a given mark\n pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n     with_sctable(|table| apply_mark_internal(m, ctxt, table))\n@@ -65,32 +55,6 @@ fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxCo\n     }\n }\n \n-/// Extend a syntax context with a given rename\n-pub fn apply_rename(from: Ident, to: Name, ident: Ident) -> Ident {\n-    with_sctable(|table| apply_rename_internal(from, to, ident, table))\n-}\n-\n-/// Extend a syntax context with a given rename and sctable (explicit memoization)\n-fn apply_rename_internal(from: Ident, to: Name, ident: Ident, table: &SCTable) -> Ident {\n-    if (ident.name, ident.ctxt) != (from.name, from.ctxt) {\n-        return ident;\n-    }\n-    let ctxt = *table.renames.borrow_mut().entry(to).or_insert_with(|| {\n-        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(to)))\n-    });\n-    Ident { ctxt: ctxt, ..ident }\n-}\n-\n-/// Apply a list of renamings to a context\n-// if these rename lists get long, it would make sense\n-// to consider memoizing this fold. This may come up\n-// when we add hygiene to item names.\n-pub fn apply_renames(renames: &RenameList, ident: Ident) -> Ident {\n-    renames.iter().fold(ident, |ident, &(from, to)| {\n-        apply_rename(from, to, ident)\n-    })\n-}\n-\n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn with_sctable<T, F>(op: F) -> T where\n     F: FnOnce(&SCTable) -> T,\n@@ -99,21 +63,11 @@ pub fn with_sctable<T, F>(op: F) -> T where\n     SCTABLE_KEY.with(move |slot| op(slot))\n }\n \n-// Make a fresh syntax context table with EmptyCtxt in slot zero\n-// and IllegalCtxt in slot one.\n+// Make a fresh syntax context table with EmptyCtxt in slot zero.\n fn new_sctable_internal() -> SCTable {\n     SCTable {\n-        table: RefCell::new(vec!(EmptyCtxt, IllegalCtxt)),\n+        table: RefCell::new(vec![EmptyCtxt]),\n         marks: RefCell::new(HashMap::new()),\n-        renames: RefCell::new(HashMap::new()),\n-    }\n-}\n-\n-/// Print out an SCTable for debugging\n-pub fn display_sctable(table: &SCTable) {\n-    error!(\"SC table:\");\n-    for (idx,val) in table.table.borrow().iter().enumerate() {\n-        error!(\"{:4} : {:?}\",idx,val);\n     }\n }\n \n@@ -122,16 +76,14 @@ pub fn clear_tables() {\n     with_sctable(|table| {\n         *table.table.borrow_mut() = Vec::new();\n         *table.marks.borrow_mut() = HashMap::new();\n-        *table.renames.borrow_mut() = HashMap::new();\n     });\n }\n \n /// Reset the tables to their initial state\n pub fn reset_tables() {\n     with_sctable(|table| {\n-        *table.table.borrow_mut() = vec!(EmptyCtxt, IllegalCtxt);\n+        *table.table.borrow_mut() = vec![EmptyCtxt];\n         *table.marks.borrow_mut() = HashMap::new();\n-        *table.renames.borrow_mut() = HashMap::new();\n     });\n }\n \n@@ -141,25 +93,6 @@ fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n     (vec.len() - 1) as u32\n }\n \n-/// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve(id: Ident) -> Name {\n-    with_sctable(|sctable| {\n-        resolve_internal(id, sctable)\n-    })\n-}\n-\n-/// Resolve a syntax object to a name, per MTWT.\n-/// adding memoization to resolve 500+ seconds in resolve for librustc (!)\n-fn resolve_internal(id: Ident, table: &SCTable) -> Name {\n-    match table.table.borrow()[id.ctxt.0 as usize] {\n-        EmptyCtxt => id.name,\n-        // ignore marks here:\n-        Mark(_, subctxt) => resolve_internal(Ident::new(id.name, subctxt), table),\n-        Rename(name) => name,\n-        IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n-    }\n-}\n-\n /// Return the outer mark for a context with a mark at the outside.\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n@@ -171,15 +104,24 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     })\n }\n \n+/// If `ident` is macro expanded, return the source ident from the macro definition\n+/// and the mark of the expansion that created the macro definition.\n+pub fn source(ident: Ident) -> Option<(Ident /* source ident */, Mrk /* source macro */)> {\n+    with_sctable(|sctable| {\n+        let ctxts = sctable.table.borrow();\n+        if let Mark(_expansion_mark, macro_ctxt) = ctxts[ident.ctxt.0 as usize] {\n+            if let Mark(definition_mark, orig_ctxt) = ctxts[macro_ctxt.0 as usize] {\n+                return Some((Ident::new(ident.name, orig_ctxt), definition_mark));\n+            }\n+        }\n+        None\n+    })\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use ast::{EMPTY_CTXT, Ident, Mrk, Name, SyntaxContext};\n-    use super::{resolve, apply_mark_internal, new_sctable_internal};\n-    use super::{SCTable, Mark};\n-\n-    fn id(n: u32, s: SyntaxContext) -> Ident {\n-        Ident::new(Name(n), s)\n-    }\n+    use ast::{EMPTY_CTXT, Mrk, SyntaxContext};\n+    use super::{apply_mark_internal, new_sctable_internal, Mark, SCTable};\n \n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n@@ -192,27 +134,21 @@ mod tests {\n     #[test] fn unfold_marks_test() {\n         let mut t = new_sctable_internal();\n \n-        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),SyntaxContext(3));\n+        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),SyntaxContext(2));\n         {\n             let table = t.table.borrow();\n-            assert!((*table)[2] == Mark(7,EMPTY_CTXT));\n-            assert!((*table)[3] == Mark(3,SyntaxContext(2)));\n+            assert!((*table)[1] == Mark(7,EMPTY_CTXT));\n+            assert!((*table)[2] == Mark(3,SyntaxContext(1)));\n         }\n     }\n \n-    #[test]\n-    fn mtwt_resolve_test(){\n-        let a = 40;\n-        assert_eq!(resolve(id(a,EMPTY_CTXT)),Name(a));\n-    }\n-\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n-        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),SyntaxContext(3));\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(1));\n+        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),SyntaxContext(2));\n         // using the same one again should result in the same index:\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(1));\n         // I'm assuming that the rename table will behave the same....\n     }\n }"}, {"sha": "fe9d3ef7c234dff8c364e9f4c9bdffb94183c150", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -15,7 +15,6 @@ pub use self::Lit::*;\n pub use self::Token::*;\n \n use ast::{self, BinOpKind};\n-use ext::mtwt;\n use ptr::P;\n use util::interner::Interner;\n use tokenstream;\n@@ -313,17 +312,6 @@ impl Token {\n             _ => false,\n         }\n     }\n-\n-    /// Hygienic identifier equality comparison.\n-    ///\n-    /// See `styntax::ext::mtwt`.\n-    pub fn mtwt_eq(&self, other : &Token) -> bool {\n-        match (self, other) {\n-            (&Ident(id1), &Ident(id2)) | (&Lifetime(id1), &Lifetime(id2)) =>\n-                mtwt::resolve(id1) == mtwt::resolve(id2),\n-            _ => *self == *other\n-        }\n-    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash)]\n@@ -650,21 +638,3 @@ pub fn fresh_name(src: ast::Ident) -> ast::Name {\n pub fn fresh_mark() -> ast::Mrk {\n     gensym(\"mark\").0\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ast;\n-    use ext::mtwt;\n-\n-    fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n-        ast::Ident::new(id.name, mtwt::apply_mark(m, id.ctxt))\n-    }\n-\n-    #[test] fn mtwt_token_eq_test() {\n-        assert!(Gt.mtwt_eq(&Gt));\n-        let a = str_to_ident(\"bac\");\n-        let a1 = mark_ident(a,92);\n-        assert!(Ident(a).mtwt_eq(&Ident(a1)));\n-    }\n-}"}, {"sha": "327696e87b08e26fc98ddbc9725f42a1c0a45580", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -185,6 +185,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         mod_folded\n     }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n struct EntryPointCleaner {\n@@ -234,6 +236,8 @@ impl fold::Folder for EntryPointCleaner {\n \n         SmallVector::one(folded)\n     }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,"}, {"sha": "d72386190ecd2768326ca42afec211098279a76d", "filename": "src/test/run-pass/hygiene.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Ftest%2Frun-pass%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db1874f4c26a2c88acb5e46b413e9c4adce3477/src%2Ftest%2Frun-pass%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene.rs?ref=4db1874f4c26a2c88acb5e46b413e9c4adce3477", "patch": "@@ -106,6 +106,13 @@ fn match_hygiene() {\n     m!(Ok(x), x);\n }\n \n+fn label_hygiene() {\n+    'a: loop {\n+        macro_rules! m { () => { break 'a; } }\n+        m!();\n+    }\n+}\n+\n fn main() {\n     f();\n     g();"}]}