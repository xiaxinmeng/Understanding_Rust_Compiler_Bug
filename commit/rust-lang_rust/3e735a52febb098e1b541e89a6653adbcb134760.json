{"sha": "3e735a52febb098e1b541e89a6653adbcb134760", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNzM1YTUyZmViYjA5OGUxYjU0MWU4OWE2NjUzYWRiY2IxMzQ3NjA=", "commit": {"author": {"name": "Smitty", "email": "me@smitop.com", "date": "2021-06-18T21:33:33Z"}, "committer": {"name": "Smitty", "email": "me@smitop.com", "date": "2021-06-29T23:08:29Z"}, "message": "Unwrap allocated Location at creation", "tree": {"sha": "3b501e152a99e8753b39b13932e6cdead59e9b73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b501e152a99e8753b39b13932e6cdead59e9b73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e735a52febb098e1b541e89a6653adbcb134760", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e735a52febb098e1b541e89a6653adbcb134760", "html_url": "https://github.com/rust-lang/rust/commit/3e735a52febb098e1b541e89a6653adbcb134760", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e735a52febb098e1b541e89a6653adbcb134760/comments", "author": {"login": "syvb", "id": 10530973, "node_id": "MDQ6VXNlcjEwNTMwOTcz", "avatar_url": "https://avatars.githubusercontent.com/u/10530973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/syvb", "html_url": "https://github.com/syvb", "followers_url": "https://api.github.com/users/syvb/followers", "following_url": "https://api.github.com/users/syvb/following{/other_user}", "gists_url": "https://api.github.com/users/syvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/syvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/syvb/subscriptions", "organizations_url": "https://api.github.com/users/syvb/orgs", "repos_url": "https://api.github.com/users/syvb/repos", "events_url": "https://api.github.com/users/syvb/events{/privacy}", "received_events_url": "https://api.github.com/users/syvb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "syvb", "id": 10530973, "node_id": "MDQ6VXNlcjEwNTMwOTcz", "avatar_url": "https://avatars.githubusercontent.com/u/10530973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/syvb", "html_url": "https://github.com/syvb", "followers_url": "https://api.github.com/users/syvb/followers", "following_url": "https://api.github.com/users/syvb/following{/other_user}", "gists_url": "https://api.github.com/users/syvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/syvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/syvb/subscriptions", "organizations_url": "https://api.github.com/users/syvb/orgs", "repos_url": "https://api.github.com/users/syvb/repos", "events_url": "https://api.github.com/users/syvb/events{/privacy}", "received_events_url": "https://api.github.com/users/syvb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43b55cf8935e4f96b143efff1a43bb30c3d55545", "url": "https://api.github.com/repos/rust-lang/rust/commits/43b55cf8935e4f96b143efff1a43bb30c3d55545", "html_url": "https://github.com/rust-lang/rust/commit/43b55cf8935e4f96b143efff1a43bb30c3d55545"}], "stats": {"total": 23, "additions": 9, "deletions": 14}, "files": [{"sha": "6a514e9f62fce655b5aa56822f1e595cc1d67df0", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e735a52febb098e1b541e89a6653adbcb134760/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e735a52febb098e1b541e89a6653adbcb134760/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=3e735a52febb098e1b541e89a6653adbcb134760", "patch": "@@ -31,11 +31,7 @@ pub(crate) fn const_caller_location(\n     trace!(\"const_caller_location: {}:{}:{}\", file, line, col);\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n-    // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n-    // pointless, since that would require allocating more memory than a Location.\n-    let loc_place = ecx\n-        .alloc_caller_location(file, line, col)\n-        .expect(\"not enough memory to allocate location?\");\n+    let loc_place = ecx.alloc_caller_location(file, line, col);\n     if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &loc_place).is_err() {\n         bug!(\"intern_const_alloc_recursive should not error in this case\")\n     }"}, {"sha": "4e4166dad50e29b83c7b49c00905fe344941f659", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e735a52febb098e1b541e89a6653adbcb134760/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e735a52febb098e1b541e89a6653adbcb134760/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=3e735a52febb098e1b541e89a6653adbcb134760", "patch": "@@ -137,7 +137,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match intrinsic_name {\n             sym::caller_location => {\n                 let span = self.find_closest_untracked_caller_location();\n-                let location = self.alloc_caller_location_for_span(span)?;\n+                let location = self.alloc_caller_location_for_span(span);\n                 self.write_scalar(location.ptr, dest)?;\n             }\n "}, {"sha": "4a3278030b5d91a0e7a4586c4fca6305060a36d7", "filename": "compiler/rustc_mir/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e735a52febb098e1b541e89a6653adbcb134760/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e735a52febb098e1b541e89a6653adbcb134760/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=3e735a52febb098e1b541e89a6653adbcb134760", "patch": "@@ -9,7 +9,7 @@ use rustc_target::abi::LayoutOf;\n \n use crate::interpret::{\n     intrinsics::{InterpCx, Machine},\n-    InterpResult, MPlaceTy, MemoryKind, Scalar,\n+    MPlaceTy, MemoryKind, Scalar,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -79,7 +79,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         filename: Symbol,\n         line: u32,\n         col: u32,\n-    ) -> InterpResult<'static, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let file =\n             self.allocate_str(&filename.as_str(), MemoryKind::CallerLocation, Mutability::Not);\n         let line = Scalar::from_u32(line);\n@@ -91,7 +91,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .type_of(self.tcx.require_lang_item(LangItem::PanicLocation, None))\n             .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n-        let location = self.allocate(loc_layout, MemoryKind::CallerLocation)?;\n+        // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n+        // pointless, since that would require allocating more memory than a Location.\n+        let location = self.allocate(loc_layout, MemoryKind::CallerLocation).unwrap();\n \n         // Initialize fields.\n         self.write_immediate(file.to_ref(), &self.mplace_field(&location, 0).unwrap().into())\n@@ -101,7 +103,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.write_scalar(col, &self.mplace_field(&location, 2).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n \n-        Ok(location)\n+        location\n     }\n \n     crate fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n@@ -114,10 +116,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         )\n     }\n \n-    pub fn alloc_caller_location_for_span(\n-        &mut self,\n-        span: Span,\n-    ) -> InterpResult<'static, MPlaceTy<'tcx, M::PointerTag>> {\n+    pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n         let (file, line, column) = self.location_triple_for_span(span);\n         self.alloc_caller_location(file, line, column)\n     }"}]}