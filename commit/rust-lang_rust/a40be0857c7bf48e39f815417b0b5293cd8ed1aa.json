{"sha": "a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MGJlMDg1N2M3YmY0OGUzOWY4MTU0MTdiMGI1MjkzY2Q4ZWQxYWE=", "commit": {"author": {"name": "Tyler Julian", "email": "tjulian@uber.com", "date": "2017-01-11T03:11:56Z"}, "committer": {"name": "Tyler Julian", "email": "tjulian@uber.com", "date": "2017-02-04T20:00:19Z"}, "message": "libstd/net: Add `peek` APIs to UdpSocket and TcpStream\n\nThese methods enable socket reads without side-effects. That is,\nrepeated calls to peek() return identical data. This is accomplished\nby providing the POSIX flag MSG_PEEK to the underlying socket read\noperations.\n\nThis also moves the current implementation of recv_from out of the\nplatform-independent sys_common and into respective sys/windows and\nsys/unix implementations. This allows for more platform-dependent\nimplementations.", "tree": {"sha": "f142739d4a6f706f583380436bcb28e4ca6f8ffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f142739d4a6f706f583380436bcb28e4ca6f8ffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "html_url": "https://github.com/rust-lang/rust/commit/a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/comments", "author": null, "committer": null, "parents": [{"sha": "9749df52b7ecfc8123e392b9d49786e2abf20320", "url": "https://api.github.com/repos/rust-lang/rust/commits/9749df52b7ecfc8123e392b9d49786e2abf20320", "html_url": "https://github.com/rust-lang/rust/commit/9749df52b7ecfc8123e392b9d49786e2abf20320"}], "stats": {"total": 268, "additions": 251, "deletions": 17}, "files": [{"sha": "cb7f66732175e6171587ed69656b7aae7dd2e6ec", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "patch": "@@ -1 +1 @@\n-Subproject commit 7d57bdcdbb56540f37afe5a934ce12d33a6ca7fc\n+Subproject commit cb7f66732175e6171587ed69656b7aae7dd2e6ec"}, {"sha": "3c06409e3b18e88987a47efed6e71bf8ab952761", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "patch": "@@ -275,6 +275,7 @@\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n #![feature(panic_unwind)]\n+#![feature(peek)]\n #![feature(placement_in_syntax)]\n #![feature(prelude_import)]\n #![feature(pub_restricted)]"}, {"sha": "ba6160cc723316ff42165012d6cbd4c9942172a6", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "patch": "@@ -296,6 +296,29 @@ impl TcpStream {\n         self.0.write_timeout()\n     }\n \n+    /// Receives data on the socket from the remote adress to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(peek)]\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8000\")\n+    ///                        .expect(\"couldn't bind to address\");\n+    /// let mut buf = [0; 10];\n+    /// let len = stream.peek(&mut buf).expect(\"peek failed\");\n+    /// ```\n+    #[unstable(feature = \"peek\", issue = \"38980\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n     /// Sets the value of the `TCP_NODELAY` option on this socket.\n     ///\n     /// If set, this option disables the Nagle algorithm. This means that\n@@ -1405,4 +1428,35 @@ mod tests {\n             Err(e) => panic!(\"unexpected error {}\", e),\n         }\n     }\n+\n+    #[test]\n+    fn peek() {\n+        each_ip(&mut |addr| {\n+            let (txdone, rxdone) = channel();\n+\n+            let srv = t!(TcpListener::bind(&addr));\n+            let _t = thread::spawn(move|| {\n+                let mut cl = t!(srv.accept()).0;\n+                cl.write(&[1,3,3,7]).unwrap();\n+                t!(rxdone.recv());\n+            });\n+\n+            let mut c = t!(TcpStream::connect(&addr));\n+            let mut b = [0; 10];\n+            for _ in 1..3 {\n+                let len = c.peek(&mut b).unwrap();\n+                assert_eq!(len, 4);\n+            }\n+            let len = c.read(&mut b).unwrap();\n+            assert_eq!(len, 4);\n+\n+            t!(c.set_nonblocking(true));\n+            match c.peek(&mut b) {\n+                Ok(_) => panic!(\"expected error\"),\n+                Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+                Err(e) => panic!(\"unexpected error {}\", e),\n+            }\n+            t!(txdone.send(()));\n+        })\n+    }\n }"}, {"sha": "2f28f475dc88b65c2cde824a0f08042942e8bc33", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "patch": "@@ -83,6 +83,30 @@ impl UdpSocket {\n         self.0.recv_from(buf)\n     }\n \n+    /// Receives data from the socket, without removing it from the queue.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n+    ///\n+    /// On success, returns the number of bytes peeked and the address from\n+    /// whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(peek)]\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let mut buf = [0; 10];\n+    /// let (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n+    ///                                         .expect(\"Didn't receive data\");\n+    /// ```\n+    #[unstable(feature = \"peek\", issue = \"38980\")]\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.0.peek_from(buf)\n+    }\n+\n     /// Sends data on the socket to the given address. On success, returns the\n     /// number of bytes written.\n     ///\n@@ -579,6 +603,37 @@ impl UdpSocket {\n         self.0.recv(buf)\n     }\n \n+    /// Receives data on the socket from the remote adress to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method will fail if the socket is not connected. The `connect` method\n+    /// will connect this socket to a remote address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(peek)]\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n+    /// let mut buf = [0; 10];\n+    /// match socket.peek(&mut buf) {\n+    ///     Ok(received) => println!(\"received {} bytes\", received),\n+    ///     Err(e) => println!(\"peek function failed: {:?}\", e),\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"peek\", issue = \"38980\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n     /// Moves this UDP socket into or out of nonblocking mode.\n     ///\n     /// On Unix this corresponds to calling fcntl, and on Windows this\n@@ -869,6 +924,48 @@ mod tests {\n         assert_eq!(b\"hello world\", &buf[..]);\n     }\n \n+    #[test]\n+    fn connect_send_peek_recv() {\n+        each_ip(&mut |addr, _| {\n+            let socket = t!(UdpSocket::bind(&addr));\n+            t!(socket.connect(addr));\n+\n+            t!(socket.send(b\"hello world\"));\n+\n+            for _ in 1..3 {\n+                let mut buf = [0; 11];\n+                let size = t!(socket.peek(&mut buf));\n+                assert_eq!(b\"hello world\", &buf[..]);\n+                assert_eq!(size, 11);\n+            }\n+\n+            let mut buf = [0; 11];\n+            let size = t!(socket.recv(&mut buf));\n+            assert_eq!(b\"hello world\", &buf[..]);\n+            assert_eq!(size, 11);\n+        })\n+    }\n+\n+    #[test]\n+    fn peek_from() {\n+        each_ip(&mut |addr, _| {\n+            let socket = t!(UdpSocket::bind(&addr));\n+            t!(socket.send_to(b\"hello world\", &addr));\n+\n+            for _ in 1..3 {\n+                let mut buf = [0; 11];\n+                let (size, _) = t!(socket.peek_from(&mut buf));\n+                assert_eq!(b\"hello world\", &buf[..]);\n+                assert_eq!(size, 11);\n+            }\n+\n+            let mut buf = [0; 11];\n+            let (size, _) = t!(socket.recv_from(&mut buf));\n+            assert_eq!(b\"hello world\", &buf[..]);\n+            assert_eq!(size, 11);\n+        })\n+    }\n+\n     #[test]\n     fn ttl() {\n         let ttl = 100;"}, {"sha": "5efddca110f0506a048828e4611ddd2aac2eb723", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "patch": "@@ -10,12 +10,13 @@\n \n use ffi::CStr;\n use io;\n-use libc::{self, c_int, size_t, sockaddr, socklen_t, EAI_SYSTEM};\n+use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n+use mem;\n use net::{SocketAddr, Shutdown};\n use str;\n use sys::fd::FileDesc;\n use sys_common::{AsInner, FromInner, IntoInner};\n-use sys_common::net::{getsockopt, setsockopt};\n+use sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n use time::Duration;\n \n pub use sys::{cvt, cvt_r};\n@@ -155,8 +156,46 @@ impl Socket {\n         self.0.duplicate().map(Socket)\n     }\n \n+    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::recv(self.0.raw(),\n+                       buf.as_mut_ptr() as *mut c_void,\n+                       buf.len(),\n+                       flags)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n+        self.recv_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, MSG_PEEK)\n+    }\n+\n+    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n+                            -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n+\n+        let n = cvt(unsafe {\n+            libc::recvfrom(self.0.raw(),\n+                        buf.as_mut_ptr() as *mut c_void,\n+                        buf.len(),\n+                        flags,\n+                        &mut storage as *mut _ as *mut _,\n+                        &mut addrlen)\n+        })?;\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, MSG_PEEK)\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {"}, {"sha": "9f03f5c9717fc935a4302029dd8dd341c741422f", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "patch": "@@ -244,6 +244,7 @@ pub const IP_ADD_MEMBERSHIP: c_int = 12;\n pub const IP_DROP_MEMBERSHIP: c_int = 13;\n pub const IPV6_ADD_MEMBERSHIP: c_int = 12;\n pub const IPV6_DROP_MEMBERSHIP: c_int = 13;\n+pub const MSG_PEEK: c_int = 0x2;\n \n #[repr(C)]\n pub struct ip_mreq {"}, {"sha": "adf6210d82e897542d990bd43bcfb7b4cf2bf807", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "patch": "@@ -147,19 +147,59 @@ impl Socket {\n         Ok(socket)\n     }\n \n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n         let len = cmp::min(buf.len(), i32::max_value() as usize) as i32;\n         unsafe {\n-            match c::recv(self.0, buf.as_mut_ptr() as *mut c_void, len, 0) {\n+            match c::recv(self.0, buf.as_mut_ptr() as *mut c_void, len, flags) {\n                 -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n                 -1 => Err(last_error()),\n                 n => Ok(n as usize)\n             }\n         }\n     }\n \n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, c::MSG_PEEK)\n+    }\n+\n+    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n+                            -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: c::SOCKADDR_STORAGE_LH = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n+        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+\n+        // On unix when a socket is shut down all further reads return 0, so we\n+        // do the same on windows to map a shut down socket to returning EOF.\n+        unsafe {\n+            match c::recvfrom(self.0,\n+                              buf.as_mut_ptr() as *mut c_void,\n+                              len,\n+                              flags,\n+                              &mut storage as *mut _ as *mut _,\n+                              &mut addrlen) {\n+                -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => {\n+                    Ok((0, net::sockaddr_to_addr(&storage, addrlen as usize)?))\n+                },\n+                -1 => Err(last_error()),\n+                n => Ok((n as usize, net::sockaddr_to_addr(&storage, addrlen as usize)?)),\n+            }\n+        }\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, c::MSG_PEEK)\n+    }\n+\n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         let mut me = self;\n         (&mut me).read_to_end(buf)"}, {"sha": "3cdeb511945756d7d8c451ad4ff89ff6aac8f164", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40be0857c7bf48e39f815417b0b5293cd8ed1aa/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=a40be0857c7bf48e39f815417b0b5293cd8ed1aa", "patch": "@@ -91,7 +91,7 @@ fn sockname<F>(f: F) -> io::Result<SocketAddr>\n     }\n }\n \n-fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n+pub fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n                     len: usize) -> io::Result<SocketAddr> {\n     match storage.ss_family as c_int {\n         c::AF_INET => {\n@@ -222,6 +222,10 @@ impl TcpStream {\n         self.inner.timeout(c::SO_SNDTIMEO)\n     }\n \n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.peek(buf)\n+    }\n+\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n@@ -441,17 +445,11 @@ impl UdpSocket {\n     }\n \n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        let mut storage: c::sockaddr_storage = unsafe { mem::zeroed() };\n-        let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n-        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+        self.inner.recv_from(buf)\n+    }\n \n-        let n = cvt(unsafe {\n-            c::recvfrom(*self.inner.as_inner(),\n-                        buf.as_mut_ptr() as *mut c_void,\n-                        len, 0,\n-                        &mut storage as *mut _ as *mut _, &mut addrlen)\n-        })?;\n-        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.inner.peek_from(buf)\n     }\n \n     pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n@@ -578,6 +576,10 @@ impl UdpSocket {\n         self.inner.read(buf)\n     }\n \n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.peek(buf)\n+    }\n+\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let ret = cvt(unsafe {"}]}