{"sha": "dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c", "node_id": "C_kwDOAAsO6NoAKGRjYTVmNWJmOGY1NWZhYWFiODRmYjIzZGIxYjRjNWViZGM0MDRjMGM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-27T20:56:14Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-27T21:23:06Z"}, "message": "Drive-by: Rename expr_t to base_ty", "tree": {"sha": "d00ed172381228a569c18f269d80dfd8484767d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d00ed172381228a569c18f269d80dfd8484767d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c", "html_url": "https://github.com/rust-lang/rust/commit/dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "html_url": "https://github.com/rust-lang/rust/commit/332cc8fb752fe98c21837ed6f3571f6adb0d08b8"}], "stats": {"total": 52, "additions": 26, "deletions": 26}, "files": [{"sha": "604ba22a1236f98878caab77b824889358a0945d", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c", "patch": "@@ -2141,15 +2141,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n     ) -> Ty<'tcx> {\n         debug!(\"check_field(expr: {:?}, base: {:?}, field: {:?})\", expr, base, field);\n-        let expr_t = self.check_expr(base);\n-        let expr_t = self.structurally_resolved_type(base.span, expr_t);\n+        let base_ty = self.check_expr(base);\n+        let base_ty = self.structurally_resolved_type(base.span, base_ty);\n         let mut private_candidate = None;\n-        let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, _)) = autoderef.next() {\n-            debug!(\"base_t: {:?}\", base_t);\n-            match base_t.kind() {\n+        let mut autoderef = self.autoderef(expr.span, base_ty);\n+        while let Some((deref_base_ty, _)) = autoderef.next() {\n+            debug!(\"deref_base_ty: {:?}\", deref_base_ty);\n+            match deref_base_ty.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n-                    debug!(\"struct named {:?}\", base_t);\n+                    debug!(\"struct named {:?}\", deref_base_ty);\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident_and_get_scope(field, base_def.did(), self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n@@ -2197,23 +2197,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, expr_t, field, did);\n+            self.ban_private_field_access(expr, base_ty, field, did);\n             return field_ty;\n         }\n \n         if field.name == kw::Empty {\n-        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n-            self.ban_take_value_of_method(expr, expr_t, field);\n-        } else if !expr_t.is_primitive_ty() {\n-            self.ban_nonexisting_field(field, base, expr, expr_t);\n+        } else if self.method_exists(field, base_ty, expr.hir_id, true) {\n+            self.ban_take_value_of_method(expr, base_ty, field);\n+        } else if !base_ty.is_primitive_ty() {\n+            self.ban_nonexisting_field(field, base, expr, base_ty);\n         } else {\n             let field_name = field.to_string();\n             let mut err = type_error_struct!(\n                 self.tcx().sess,\n                 field.span,\n-                expr_t,\n+                base_ty,\n                 E0610,\n-                \"`{expr_t}` is a primitive type and therefore doesn't have fields\",\n+                \"`{base_ty}` is a primitive type and therefore doesn't have fields\",\n             );\n             let is_valid_suffix = |field: &str| {\n                 if field == \"f32\" || field == \"f64\" {\n@@ -2251,7 +2251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     None\n                 }\n             };\n-            if let ty::Infer(ty::IntVar(_)) = expr_t.kind()\n+            if let ty::Infer(ty::IntVar(_)) = base_ty.kind()\n                 && let ExprKind::Lit(Spanned {\n                     node: ast::LitKind::Int(_, ast::LitIntType::Unsuffixed),\n                     ..\n@@ -2351,40 +2351,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn ban_nonexisting_field(\n         &self,\n-        field: Ident,\n+        ident: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n-        expr_t: Ty<'tcx>,\n+        base_ty: Ty<'tcx>,\n     ) {\n         debug!(\n-            \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, expr_ty={:?}\",\n-            field, base, expr, expr_t\n+            \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, base_ty={:?}\",\n+            ident, base, expr, base_ty\n         );\n-        let mut err = self.no_such_field_err(field, expr_t, base.hir_id);\n+        let mut err = self.no_such_field_err(ident, base_ty, base.hir_id);\n \n-        match *expr_t.peel_refs().kind() {\n+        match *base_ty.peel_refs().kind() {\n             ty::Array(_, len) => {\n-                self.maybe_suggest_array_indexing(&mut err, expr, base, field, len);\n+                self.maybe_suggest_array_indexing(&mut err, expr, base, ident, len);\n             }\n             ty::RawPtr(..) => {\n-                self.suggest_first_deref_field(&mut err, expr, base, field);\n+                self.suggest_first_deref_field(&mut err, expr, base, ident);\n             }\n             ty::Adt(def, _) if !def.is_enum() => {\n-                self.suggest_fields_on_recordish(&mut err, def, field, expr.span);\n+                self.suggest_fields_on_recordish(&mut err, def, ident, expr.span);\n             }\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n             ty::Opaque(_, _) => {\n-                self.suggest_await_on_field_access(&mut err, field, base, expr_t.peel_refs());\n+                self.suggest_await_on_field_access(&mut err, ident, base, base_ty.peel_refs());\n             }\n             ty::FnDef(def_id, _) => {\n                 self.check_call_constructor(&mut err, base, def_id);\n             }\n             _ => {}\n         }\n \n-        if field.name == kw::Await {\n+        if ident.name == kw::Await {\n             // We know by construction that `<expr>.await` is either on Rust 2015\n             // or results in `ExprKind::Await`. Suggest switching the edition to 2018.\n             err.note(\"to `.await` a `Future`, switch to Rust 2018 or later\");"}]}