{"sha": "dc4f39c43f0f798c414474263b8d3e5b90c32e27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNGYzOWM0M2YwZjc5OGM0MTQ0NzQyNjNiOGQzZTViOTBjMzJlMjc=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-25T00:29:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-25T00:29:42Z"}, "message": "Rollup merge of #77079 - poliorcetics:more-self-in-docs, r=jyn514\n\nUse `Self` in docs when possible\n\nFixes #76542.\n\nI used `rg '\\s*//[!/]\\s+fn [\\w_]+\\(&?self, ' .` in `library/` to find instances, I found some with that and some by manually checking.\n\n@rustbot modify labels: C-enhancement T-doc", "tree": {"sha": "f46c0bdc901073a65a4c1b0b30ad49b27f52bd3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f46c0bdc901073a65a4c1b0b30ad49b27f52bd3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc4f39c43f0f798c414474263b8d3e5b90c32e27", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfbTn2CRBK7hj4Ov3rIwAAdHIIABOB5na+5RlZIrTYYFI0Uino\nD19h7JOQrj+xgeU06mCix+L7rVc1BpS0D7w6Nn+nFDv76kkJwCm4yJq2BEdCiTbK\nwD8M/VZ0q9buQt6bT9J6xRr+g22xrQM5AoxjLRckXNH3Vh3mu4UsHmj4tsw8kdbS\nLFQPJwJKZa7QJRSIWAzE8zhL5cyBvoHEAYdfFod12PZyXidhx/3RXYvJqOlW5Zj/\neBJPRD6AFvj4MUpA9UlG5IUg02+9ix7j+FwqRfY+UePfCedPeREKqYLNurTMNCl9\nEDTUmawNR6T/lvBaDTnAUYVboJrpsKToQqrrqu4g3IhOzjEwoA7uElszL0rk92s=\n=D2O/\n-----END PGP SIGNATURE-----\n", "payload": "tree f46c0bdc901073a65a4c1b0b30ad49b27f52bd3c\nparent 28e0bc997e66ad2514da00d587c1955b46c409d9\nparent ec4e9cd12a380bb61791c489baaaae2e9454546d\nauthor Jonas Schievink <jonasschievink@gmail.com> 1600993782 +0200\ncommitter GitHub <noreply@github.com> 1600993782 +0200\n\nRollup merge of #77079 - poliorcetics:more-self-in-docs, r=jyn514\n\nUse `Self` in docs when possible\n\nFixes #76542.\n\nI used `rg '\\s*//[!/]\\s+fn [\\w_]+\\(&?self, ' .` in `library/` to find instances, I found some with that and some by manually checking.\n\n@rustbot modify labels: C-enhancement T-doc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4f39c43f0f798c414474263b8d3e5b90c32e27", "html_url": "https://github.com/rust-lang/rust/commit/dc4f39c43f0f798c414474263b8d3e5b90c32e27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc4f39c43f0f798c414474263b8d3e5b90c32e27/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28e0bc997e66ad2514da00d587c1955b46c409d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/28e0bc997e66ad2514da00d587c1955b46c409d9", "html_url": "https://github.com/rust-lang/rust/commit/28e0bc997e66ad2514da00d587c1955b46c409d9"}, {"sha": "ec4e9cd12a380bb61791c489baaaae2e9454546d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4e9cd12a380bb61791c489baaaae2e9454546d", "html_url": "https://github.com/rust-lang/rust/commit/ec4e9cd12a380bb61791c489baaaae2e9454546d"}], "stats": {"total": 117, "additions": 60, "deletions": 57}, "files": [{"sha": "f2852b1cc2b8099c4b51ffbedbf69f9e893480e0", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=dc4f39c43f0f798c414474263b8d3e5b90c32e27", "patch": "@@ -30,7 +30,7 @@\n //! // Explicitly implement the trait so the queue becomes a min-heap\n //! // instead of a max-heap.\n //! impl Ord for State {\n-//!     fn cmp(&self, other: &State) -> Ordering {\n+//!     fn cmp(&self, other: &Self) -> Ordering {\n //!         // Notice that the we flip the ordering on costs.\n //!         // In case of a tie we compare positions - this step is necessary\n //!         // to make implementations of `PartialEq` and `Ord` consistent.\n@@ -41,7 +41,7 @@\n //!\n //! // `PartialOrd` needs to be implemented as well.\n //! impl PartialOrd for State {\n-//!     fn partial_cmp(&self, other: &State) -> Option<Ordering> {\n+//!     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n //!         Some(self.cmp(other))\n //!     }\n //! }"}, {"sha": "ee79a94cc66ab6b1da732740e733f664a24bfb88", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=dc4f39c43f0f798c414474263b8d3e5b90c32e27", "patch": "@@ -726,19 +726,19 @@ impl PartialOrd for Ordering {\n /// }\n ///\n /// impl PartialOrd for Person {\n-///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n+///     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n ///         Some(self.cmp(other))\n ///     }\n /// }\n ///\n /// impl Ord for Person {\n-///     fn cmp(&self, other: &Person) -> Ordering {\n+///     fn cmp(&self, other: &Self) -> Ordering {\n ///         self.height.cmp(&other.height)\n ///     }\n /// }\n ///\n /// impl PartialEq for Person {\n-///     fn eq(&self, other: &Person) -> bool {\n+///     fn eq(&self, other: &Self) -> bool {\n ///         self.height == other.height\n ///     }\n /// }"}, {"sha": "cdf742057b7b6f37458e1a009f774f2815dd6127", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=dc4f39c43f0f798c414474263b8d3e5b90c32e27", "patch": "@@ -643,9 +643,9 @@ macro_rules! impls {\n /// }\n ///\n /// impl<R: ResType> ExternalResource<R> {\n-///     fn new() -> ExternalResource<R> {\n+///     fn new() -> Self {\n ///         let size_of_res = mem::size_of::<R>();\n-///         ExternalResource {\n+///         Self {\n ///             resource_handle: foreign_lib::new(size_of_res),\n ///             resource_type: PhantomData,\n ///         }"}, {"sha": "19f86ced5007ceb72e5de4647cb363b21732c231", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=dc4f39c43f0f798c414474263b8d3e5b90c32e27", "patch": "@@ -128,10 +128,10 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// }\n ///\n /// impl Sub for Point {\n-///     type Output = Point;\n+///     type Output = Self;\n ///\n-///     fn sub(self, other: Point) -> Point {\n-///         Point {\n+///     fn sub(self, other: Self) -> Self::Output {\n+///         Self {\n ///             x: self.x - other.x,\n ///             y: self.y - other.y,\n ///         }\n@@ -241,7 +241,7 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///         // Reduce to lowest terms by dividing by the greatest common\n ///         // divisor.\n ///         let gcd = gcd(numerator, denominator);\n-///         Rational {\n+///         Self {\n ///             numerator: numerator / gcd,\n ///             denominator: denominator / gcd,\n ///         }\n@@ -255,7 +255,7 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     fn mul(self, rhs: Self) -> Self {\n ///         let numerator = self.numerator * rhs.numerator;\n ///         let denominator = self.denominator * rhs.denominator;\n-///         Rational::new(numerator, denominator)\n+///         Self::new(numerator, denominator)\n ///     }\n /// }\n ///\n@@ -291,7 +291,7 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     type Output = Self;\n ///\n ///     fn mul(self, rhs: Scalar) -> Self::Output {\n-///         Vector { value: self.value.iter().map(|v| v * rhs.value).collect() }\n+///         Self { value: self.value.iter().map(|v| v * rhs.value).collect() }\n ///     }\n /// }\n ///\n@@ -369,7 +369,7 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///         // Reduce to lowest terms by dividing by the greatest common\n ///         // divisor.\n ///         let gcd = gcd(numerator, denominator);\n-///         Rational {\n+///         Self {\n ///             numerator: numerator / gcd,\n ///             denominator: denominator / gcd,\n ///         }\n@@ -387,7 +387,7 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n ///         let numerator = self.numerator * rhs.denominator;\n ///         let denominator = self.denominator * rhs.numerator;\n-///         Rational::new(numerator, denominator)\n+///         Self::new(numerator, denominator)\n ///     }\n /// }\n ///\n@@ -423,7 +423,7 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     type Output = Self;\n ///\n ///     fn div(self, rhs: Scalar) -> Self::Output {\n-///         Vector { value: self.value.iter().map(|v| v / rhs.value).collect() }\n+///         Self { value: self.value.iter().map(|v| v / rhs.value).collect() }\n ///     }\n /// }\n ///\n@@ -515,7 +515,7 @@ div_impl_float! { f32 f64 }\n ///         let len = self.slice.len();\n ///         let rem = len % modulus;\n ///         let start = len - rem;\n-///         SplitSlice {slice: &self.slice[start..]}\n+///         Self {slice: &self.slice[start..]}\n ///     }\n /// }\n ///\n@@ -615,7 +615,7 @@ rem_impl_float! { f32 f64 }\n /// }\n ///\n /// impl Neg for Sign {\n-///     type Output = Sign;\n+///     type Output = Self;\n ///\n ///     fn neg(self) -> Self::Output {\n ///         match self {"}, {"sha": "6120da50c3cdfe4036a3d8c0d1b68cc760fd2eba", "filename": "library/core/src/ops/bit.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fbit.rs?ref=dc4f39c43f0f798c414474263b8d3e5b90c32e27", "patch": "@@ -15,7 +15,7 @@\n /// }\n ///\n /// impl Not for Answer {\n-///     type Output = Answer;\n+///     type Output = Self;\n ///\n ///     fn not(self) -> Self::Output {\n ///         match self {\n@@ -85,7 +85,7 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n ///     // rhs is the \"right-hand side\" of the expression `a & b`\n ///     fn bitand(self, rhs: Self) -> Self::Output {\n-///         Scalar(self.0 & rhs.0)\n+///         Self(self.0 & rhs.0)\n ///     }\n /// }\n ///\n@@ -106,10 +106,13 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitAnd for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitand(self, BooleanVector(rhs): Self) -> Self::Output {\n-///         let BooleanVector(lhs) = self;\n+///     fn bitand(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n+///         Self(lhs.iter()\n+///                 .zip(rhs.iter())\n+///                 .map(|(x, y)| *x && *y)\n+///                 .collect())\n ///     }\n /// }\n ///\n@@ -179,8 +182,8 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     type Output = Self;\n ///\n ///     // rhs is the \"right-hand side\" of the expression `a | b`\n-///     fn bitor(self, rhs: Self) -> Self {\n-///         Scalar(self.0 | rhs.0)\n+///     fn bitor(self, rhs: Self) -> Self::Output {\n+///         Self(self.0 | rhs.0)\n ///     }\n /// }\n ///\n@@ -201,10 +204,10 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitOr for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitor(self, BooleanVector(rhs): Self) -> Self::Output {\n-///         let BooleanVector(lhs) = self;\n+///     fn bitor(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n+///         Self(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n ///     }\n /// }\n ///\n@@ -275,7 +278,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n ///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n ///     fn bitxor(self, rhs: Self) -> Self::Output {\n-///         Scalar(self.0 ^ rhs.0)\n+///         Self(self.0 ^ rhs.0)\n ///     }\n /// }\n ///\n@@ -296,13 +299,13 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitXor for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitxor(self, BooleanVector(rhs): Self) -> Self::Output {\n-///         let BooleanVector(lhs) = self;\n+///     fn bitxor(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter()\n-///                          .zip(rhs.iter())\n-///                          .map(|(x, y)| (*x || *y) && !(*x && *y))\n-///                          .collect())\n+///         Self(lhs.iter()\n+///                 .zip(rhs.iter())\n+///                 .map(|(x, y)| (*x || *y) && !(*x && *y))\n+///                 .collect())\n ///     }\n /// }\n ///\n@@ -375,9 +378,9 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl Shl<Scalar> for Scalar {\n ///     type Output = Self;\n ///\n-///     fn shl(self, Scalar(rhs): Self) -> Scalar {\n-///         let Scalar(lhs) = self;\n-///         Scalar(lhs << rhs)\n+///     fn shl(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n+///         Self(lhs << rhs)\n ///     }\n /// }\n ///\n@@ -400,10 +403,10 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     fn shl(self, rhs: usize) -> Self::Output {\n ///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(rhs);\n-///         let mut spun_vector: Vec<T> = vec![];\n+///         let mut spun_vector = vec![];\n ///         spun_vector.extend_from_slice(b);\n ///         spun_vector.extend_from_slice(a);\n-///         SpinVector { vec: spun_vector }\n+///         Self { vec: spun_vector }\n ///     }\n /// }\n ///\n@@ -493,9 +496,9 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n /// impl Shr<Scalar> for Scalar {\n ///     type Output = Self;\n ///\n-///     fn shr(self, Scalar(rhs): Self) -> Scalar {\n-///         let Scalar(lhs) = self;\n-///         Scalar(lhs >> rhs)\n+///     fn shr(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n+///         Self(lhs >> rhs)\n ///     }\n /// }\n ///\n@@ -518,10 +521,10 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///     fn shr(self, rhs: usize) -> Self::Output {\n ///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n-///         let mut spun_vector: Vec<T> = vec![];\n+///         let mut spun_vector = vec![];\n ///         spun_vector.extend_from_slice(b);\n ///         spun_vector.extend_from_slice(a);\n-///         SpinVector { vec: spun_vector }\n+///         Self { vec: spun_vector }\n ///     }\n /// }\n ///\n@@ -606,7 +609,7 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n /// impl BitAndAssign for Scalar {\n ///     // rhs is the \"right-hand side\" of the expression `a &= b`\n ///     fn bitand_assign(&mut self, rhs: Self) {\n-///         *self = Scalar(self.0 & rhs.0)\n+///         *self = Self(self.0 & rhs.0)\n ///     }\n /// }\n ///\n@@ -640,11 +643,11 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///     // `rhs` is the \"right-hand side\" of the expression `a &= b`.\n ///     fn bitand_assign(&mut self, rhs: Self) {\n ///         assert_eq!(self.0.len(), rhs.0.len());\n-///         *self = BooleanVector(self.0\n-///                                   .iter()\n-///                                   .zip(rhs.0.iter())\n-///                                   .map(|(x, y)| *x && *y)\n-///                                   .collect());\n+///         *self = Self(self.0\n+///                          .iter()\n+///                          .zip(rhs.0.iter())\n+///                          .map(|(x, y)| *x && *y)\n+///                          .collect());\n ///     }\n /// }\n ///"}, {"sha": "354ad6b7b7333b0cc4a2b42083db8dca7b808738", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4f39c43f0f798c414474263b8d3e5b90c32e27/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=dc4f39c43f0f798c414474263b8d3e5b90c32e27", "patch": "@@ -49,18 +49,18 @@\n //! }\n //!\n //! impl Add for Point {\n-//!     type Output = Point;\n+//!     type Output = Self;\n //!\n-//!     fn add(self, other: Point) -> Point {\n-//!         Point {x: self.x + other.x, y: self.y + other.y}\n+//!     fn add(self, other: Self) -> Self {\n+//!         Self {x: self.x + other.x, y: self.y + other.y}\n //!     }\n //! }\n //!\n //! impl Sub for Point {\n-//!     type Output = Point;\n+//!     type Output = Self;\n //!\n-//!     fn sub(self, other: Point) -> Point {\n-//!         Point {x: self.x - other.x, y: self.y - other.y}\n+//!     fn sub(self, other: Self) -> Self {\n+//!         Self {x: self.x - other.x, y: self.y - other.y}\n //!     }\n //! }\n //!"}]}