{"sha": "1531fbe9becc9b5d84a9360fb75440efc41b7db7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MzFmYmU5YmVjYzliNWQ4NGE5MzYwZmI3NTQ0MGVmYzQxYjdkYjc=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-02-10T19:34:46Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-02-18T21:29:25Z"}, "message": "Cleanup formatting", "tree": {"sha": "e1aaf69015968f316167285844e5412f393e3e31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1aaf69015968f316167285844e5412f393e3e31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1531fbe9becc9b5d84a9360fb75440efc41b7db7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlqJ8DUACgkQtAh+UQ6Y\nsWQ6ow/7B/ymGDQYkZ6w3G95qayFYEWmgNcOXZYoQTAmSimh60E/DZG1sf/jNtll\nZHWsBTaY9mXen2RPORt1DJP1zry2wbVQVBYdM4nQ/7p6GgorMVIZVwYS0Sb506gv\nX8VzfOCqGAxI0gdh7RmtpLfpCkBPFbyZ4peecNQV+rd1KGxUAhNKPgw8MgIDw0jN\n3ufXG/b6WyIVRAH5xuifPBCnnalFgY1FEWIb6Z00DOyay/Mgc147RfRKqGsfB7Lt\nM+maoDlipH+wqEdKcFqsObb8CjT3Pg8gfFBXfkEIBLp8xQBE7B+fozb9TacEBCE/\nb8oCxLKEjeGtVOtafDKIli8LA07Nq6uT98eqQm1LSRfsTtZUYu8DgbaxsE/gV64/\nJ2YCCdesQWzoXhnrVx8KdQRkBeQMUp97OGcwmBNLBm0RM7yHhQopzVHGA1DcelYd\nrrBYsSv5hO6zDDp9UNIwD/JEUTqc1Es7ZD4QBB+OgvDMqCdXjIDubbq/semas/wf\n28OWeZbcZ7NQXK1/5ecZUDz/IJB65WXMrf/MVWOHLqEwlr2PYUgPotnhAfXxKd1t\neUazJEJQmy/c/JR9j+jpzdt/bRvQ6rXCfyHjQnlV0CRYP9o2XCI18kK8BZkkJ/jh\nVXMqKxT+v5gamXFaJOWaEc0oAWEH+6dr5brG39vURnzhAYjXzCs=\n=qNfE\n-----END PGP SIGNATURE-----", "payload": "tree e1aaf69015968f316167285844e5412f393e3e31\nparent 9d7165fcb19b1116a293317c059b01f771cd4876\nauthor Aaron Hill <aa1ronham@gmail.com> 1518291286 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1518989365 -0500\n\nCleanup formatting\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1531fbe9becc9b5d84a9360fb75440efc41b7db7", "html_url": "https://github.com/rust-lang/rust/commit/1531fbe9becc9b5d84a9360fb75440efc41b7db7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1531fbe9becc9b5d84a9360fb75440efc41b7db7/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d7165fcb19b1116a293317c059b01f771cd4876", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7165fcb19b1116a293317c059b01f771cd4876", "html_url": "https://github.com/rust-lang/rust/commit/9d7165fcb19b1116a293317c059b01f771cd4876"}], "stats": {"total": 116, "additions": 37, "deletions": 79}, "files": [{"sha": "cfeb456acefe6b8995168ca59e3e99b71a239e29", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1531fbe9becc9b5d84a9360fb75440efc41b7db7", "patch": "@@ -429,7 +429,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: None,\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n-            allow_negative_impls: false\n+            allow_negative_impls: false,\n         }\n     }\n \n@@ -442,7 +442,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: Some(mode),\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n-            allow_negative_impls: false\n+            allow_negative_impls: false,\n         }\n     }\n \n@@ -455,7 +455,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: None,\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n-            allow_negative_impls\n+            allow_negative_impls,\n         }\n     }\n "}, {"sha": "5951af6d70e802392ce2c64bd6c4c1b5d36c6507", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=1531fbe9becc9b5d84a9360fb75440efc41b7db7", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n             // Due to the way projections are handled by SelectionContext, we need to run\n             // evaluate_predicates twice: once on the original param env, and once on the result of\n-            // the first evaluate_predicates call\n+            // the first evaluate_predicates call.\n             //\n             // The problem is this: most of rustc, including SelectionContext and traits::project,\n             // are designed to work with a concrete usage of a type (e.g. Vec<u8>\n@@ -338,7 +338,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             // We fix the first assumption by manually clearing out all of the InferCtxt's caches\n             // in between calls to SelectionContext.select. This allows us to keep all of the\n             // intermediate types we create bound to the 'tcx lifetime, rather than needing to lift\n-            // them between calls\n+            // them between calls.\n             //\n             // We fix the second assumption by reprocessing the result of our first call to\n             // evaluate_predicates. Using the example of '<T as SomeTrait>::SomeItem = K', our first\n@@ -457,13 +457,8 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         infcx.freshen(p)\n     }\n \n-    fn evaluate_nested_obligations<\n-        'b,\n-        'c,\n-        'd,\n-        'cx,\n-        T: Iterator<Item = Obligation<'cx, ty::Predicate<'cx>>>,\n-    >(\n+    fn evaluate_nested_obligations<'b, 'c, 'd, 'cx,\n+                                    T: Iterator<Item = Obligation<'cx, ty::Predicate<'cx>>>>(\n         &self,\n         ty: ty::Ty,\n         nested: T,\n@@ -732,8 +727,8 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         }\n     }\n \n-    // This is very simiiar to handle_lifetimes. Instead of matching ty::Region's to ty::Region's,\n-    // however, we match ty::RegionVid's to ty::Region's\n+    // This is very similar to handle_lifetimes. However, instead of matching ty::Region's\n+    // to each other, we match ty::RegionVid's to ty::Region's\n     fn map_vid_to_region<'cx>(\n         &self,\n         regions: &RegionConstraintData<'cx>,\n@@ -843,7 +838,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n     // with determining if a given set up constraints/predicates *are* met, given some\n     // starting conditions (e.g. user-provided code). For this reason, it's easier\n     // to perform the calculations we need on our own, rather than trying to make\n-    // existing inference/solver code do what we want\n+    // existing inference/solver code do what we want.\n     fn handle_lifetimes<'cx>(\n         &self,\n         regions: &RegionConstraintData<'cx>,\n@@ -852,8 +847,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         // Our goal is to 'flatten' the list of constraints by eliminating\n         // all intermediate RegionVids. At the end, all constraints should\n         // be between Regions (aka region variables). This gives us the information\n-        // we need to create the Generics\n-        //\n+        // we need to create the Generics.\n         let mut finished = FxHashMap();\n \n         let mut vid_map: FxHashMap<RegionTarget, RegionDeps> = FxHashMap();\n@@ -1021,7 +1015,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)>,\n         lifetime_to_bounds: FxHashMap<Lifetime, FxHashSet<Lifetime>>,\n     ) -> Vec<WherePredicate> {\n-        let final_predicates = ty_to_bounds\n+        ty_to_bounds\n             .into_iter()\n             .flat_map(|(ty, mut bounds)| {\n                 if let Some(data) = ty_to_fn.get(&ty) {\n@@ -1096,9 +1090,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         bounds: bounds.into_iter().collect(),\n                     }),\n             )\n-            .collect();\n-\n-        final_predicates\n+            .collect()\n     }\n \n     // Converts the calculated ParamEnv and lifetime information to a clean::Generics, suitable for\n@@ -1380,7 +1372,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n     }\n \n     // This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n-    // refactorying either librustdoc or librustc. In particular, allowing new DefIds to be\n+    // refactoring either librustdoc or librustc. In particular, allowing new DefIds to be\n     // registered after the AST is constructed would require storing the defid mapping in a\n     // RefCell, decreasing the performance for normal compilation for very little gain.\n     //"}, {"sha": "290579681243d8d90b9e7f19fe99d7b285d0edae", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=1531fbe9becc9b5d84a9360fb75440efc41b7db7", "patch": "@@ -120,7 +120,6 @@ pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n     cx.tcx.get_attrs(did).clean(cx)\n }\n \n-\n /// Record an external fully qualified name in the external_paths cache.\n ///\n /// These names are used later on by HTML rendering to generate things like\n@@ -267,7 +266,6 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n \n     cx.populated_all_crate_impls.set(true);\n \n-\n     for &cnum in tcx.crates().iter() {\n         for did in tcx.all_trait_implementations(cnum).iter() {\n             build_impl(cx, *did, &mut impls);\n@@ -373,7 +371,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             for_,\n             items: trait_items,\n             polarity: Some(polarity.clean(cx)),\n-            synthetic: false\n+            synthetic: false,\n         }),\n         source: tcx.def_span(did).clean(cx),\n         name: None,"}, {"sha": "da9c372e58b5d5f2fee13c509c9fa3a00cd48591", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1531fbe9becc9b5d84a9360fb75440efc41b7db7", "patch": "@@ -3077,7 +3077,7 @@ impl Path {\n                 params: PathParameters::AngleBracketed {\n                     lifetimes: Vec::new(),\n                     types: Vec::new(),\n-                    bindings: Vec::new()\n+                    bindings: Vec::new(),\n                 }\n             }]\n         }\n@@ -3152,23 +3152,23 @@ fn strip_type(ty: Type) -> Type {\n     match ty {\n         Type::ResolvedPath { path, typarams, did, is_generic } => {\n             Type::ResolvedPath { path: strip_path(&path), typarams, did, is_generic }\n-        },\n+        }\n         Type::Tuple(inner_tys) => {\n             Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n-        },\n+        }\n         Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n         Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n         Type::Unique(inner_ty) => Type::Unique(Box::new(strip_type(*inner_ty))),\n         Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n         Type::BorrowedRef { lifetime, mutability, type_ } => {\n             Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n-        },\n+        }\n         Type::QPath { name, self_type, trait_ } => {\n             Type::QPath {\n                 name,\n                 self_type: Box::new(strip_type(*self_type)), trait_: Box::new(strip_type(*trait_))\n             }\n-        },\n+        }\n         _ => ty\n     }\n }\n@@ -3180,15 +3180,15 @@ fn strip_path(path: &Path) -> Path {\n             params: PathParameters::AngleBracketed {\n                 lifetimes: Vec::new(),\n                 types: Vec::new(),\n-                bindings: Vec::new()\n+                bindings: Vec::new(),\n             }\n         }\n     }).collect();\n \n     Path {\n         global: path.global,\n         def: path.def.clone(),\n-        segments\n+        segments,\n     }\n }\n \n@@ -3361,7 +3361,6 @@ pub fn get_auto_traits_with_node_id(cx: &DocContext, id: ast::NodeId, name: Stri\n }\n \n pub fn get_auto_traits_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n-\n     let finder = AutoTraitFinder {\n         cx,\n     };\n@@ -3404,7 +3403,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                 for_: self.for_.clean(cx),\n                 items,\n                 polarity: Some(self.polarity.clean(cx)),\n-                synthetic: false\n+                synthetic: false,\n             })\n         });\n         ret\n@@ -3819,8 +3818,6 @@ impl Clean<TypeBinding> for hir::TypeBinding {\n     }\n }\n \n-\n-\n pub fn def_id_to_path(cx: &DocContext, did: DefId, name: Option<String>) -> Vec<String> {\n     let crate_name = name.unwrap_or_else(|| cx.tcx.crate_name(did.krate).to_string());\n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n@@ -3835,15 +3832,14 @@ pub fn def_id_to_path(cx: &DocContext, did: DefId, name: Option<String>) -> Vec<\n     once(crate_name).chain(relative).collect()\n }\n \n-\n // Start of code copied from rust-clippy\n \n pub fn get_trait_def_id(tcx: &TyCtxt, path: &[&str], use_local: bool) -> Option<DefId> {\n-    return if use_local {\n+    if use_local {\n         path_to_def_local(tcx, path)\n     } else {\n         path_to_def(tcx, path)\n-    };\n+    }\n }\n \n pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n@@ -3878,7 +3874,6 @@ pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n     let crates = tcx.crates();\n \n-\n     let krate = crates\n         .iter()\n         .find(|&&krate| tcx.crate_name(krate) == path[0]);\n@@ -3902,7 +3897,7 @@ pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n                     if path_it.peek().is_none() {\n                         return match item.def {\n                             def::Def::Trait(did) => Some(did),\n-                            _ => None\n+                            _ => None,\n                         }\n                     }\n \n@@ -3942,7 +3937,7 @@ fn get_path_for_type(tcx: TyCtxt, def_id: DefId, def_ctor: fn(DefId) -> Def) ->\n         segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n             name: ast::Name::intern(&s),\n             parameters: None,\n-            infer_types: false\n+            infer_types: false,\n         }).collect())\n     }\n }\n@@ -3970,24 +3965,20 @@ enum SimpleBound {\n \n enum AutoTraitResult {\n     ExplicitImpl,\n-\n     PositiveImpl(Generics),\n-\n     NegativeImpl,\n }\n \n impl AutoTraitResult {\n-\n     fn is_auto(&self) -> bool {\n         match *self {\n             AutoTraitResult::PositiveImpl(_) | AutoTraitResult::NegativeImpl => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n }\n \n impl From<TyParamBound> for SimpleBound {\n-\n     fn from(bound: TyParamBound) -> Self {\n         match bound.clone() {\n             TyParamBound::RegionBound(l) => SimpleBound::RegionBound(l),\n@@ -4001,7 +3992,7 @@ impl From<TyParamBound> for SimpleBound {\n                                             t.generic_params,\n                                             mod_)\n                 },\n-                _ => panic!(\"Unexpected bound {:?}\", bound)\n+                _ => panic!(\"Unexpected bound {:?}\", bound),\n             }\n         }\n     }"}, {"sha": "df7371cdf817b805c6d5e7c2a8f958bd003b26be", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=1531fbe9becc9b5d84a9360fb75440efc41b7db7", "patch": "@@ -239,13 +239,11 @@ pub fn run_core(search_paths: SearchPaths,\n                                   .collect()\n         };\n \n-        let send_trait;\n-\n-        if crate_name == Some(\"core\".to_string()) {\n-            send_trait = clean::get_trait_def_id(&tcx, &[\"marker\", \"Send\"], true);\n+        let send_trait = if crate_name == Some(\"core\".to_string()) {\n+            clean::get_trait_def_id(&tcx, &[\"marker\", \"Send\"], true)\n         } else {\n-            send_trait = clean::get_trait_def_id(&tcx, &[\"core\", \"marker\", \"Send\"], false)\n-        }\n+            clean::get_trait_def_id(&tcx, &[\"core\", \"marker\", \"Send\"], false)\n+        };\n \n         let ctxt = DocContext {\n             tcx,\n@@ -262,7 +260,7 @@ pub fn run_core(search_paths: SearchPaths,\n             send_trait: send_trait,\n             fake_def_ids: RefCell::new(FxHashMap()),\n             all_fake_def_ids: RefCell::new(FxHashSet()),\n-            generated_synthetics: RefCell::new(FxHashSet())\n+            generated_synthetics: RefCell::new(FxHashSet()),\n         };\n         debug!(\"crate: {:?}\", tcx.hir.krate());\n "}, {"sha": "2e06267a32590bdb89e198f950a62889e7bde7e6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1531fbe9becc9b5d84a9360fb75440efc41b7db7", "patch": "@@ -169,7 +169,6 @@ pub enum ExternalLocation {\n     Unknown,\n }\n \n-\n /// Metadata about implementations for a type or trait.\n #[derive(Clone)]\n pub struct Impl {\n@@ -523,7 +522,6 @@ pub fn run(mut krate: clean::Crate,\n         themes,\n     };\n \n-\n     // If user passed in `--playground-url` arg, we fill in crate name here\n     if let Some(url) = playground_url {\n         markdown::PLAYGROUND.with(|slot| {\n@@ -2512,22 +2510,6 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             }\n             write!(w, \"</ul>\")?;\n         }\n-\n-        write!(w, r#\"<script type=\"text/javascript\">\n-               window.inlined_types=new Set();\"#)?;\n-\n-        write!(w, r#\"<script type=\"text/javascript\" async\n-                     src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n-             </script>\"#,\n-        root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n-        path = if it.def_id.is_local() {\n-            cx.current.join(\"/\")\n-        } else {\n-            let (ref path, _) = cache.external_paths[&it.def_id];\n-            path[..path.len() - 1].join(\"/\")\n-        },\n-        ty = it.type_().css_class(),\n-        name = *it.name.as_ref().unwrap())?;\n     } else {\n         // even without any implementations to write in, we still want the heading and list, so the\n         // implementors javascript file pulled in below has somewhere to write the impls into"}, {"sha": "0894d33f44f0faf091ceadd8505328180a8810cc", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/1531fbe9becc9b5d84a9360fb75440efc41b7db7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=1531fbe9becc9b5d84a9360fb75440efc41b7db7", "patch": "@@ -1569,20 +1569,17 @@\n         for (var i = 0; i < libs.length; ++i) {\n             if (libs[i] === currentCrate) { continue; }\n             var structs = imp[libs[i]];\n+\n+            struct_loop:\n             for (var j = 0; j < structs.length; ++j) {\n                 var struct = structs[j];\n                 var list = struct.synthetic ? synthetic_implementors : implementors;\n \n-                var bail = false;\n                 for (var k = 0; k < struct.types.length; k++) {\n                     if (window.inlined_types.has(struct.types[k])) {\n-                        bail = true;\n-                        break;\n+                        continue struct_loop;\n                     }\n                 }\n-                if (bail) {\n-                    continue;\n-                }\n \n                 var code = document.createElement('code');\n                 code.innerHTML = struct.text;"}]}