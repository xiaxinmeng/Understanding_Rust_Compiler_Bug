{"sha": "4bcaddeeb23544eb2c86b600c3d775e2773758c2", "node_id": "C_kwDOAAsO6NoAKDRiY2FkZGVlYjIzNTQ0ZWIyYzg2YjYwMGMzZDc3NWUyNzczNzU4YzI", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-09-01T09:43:35Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-09-05T13:25:57Z"}, "message": "separate the receiver from arguments in HIR under /clippy", "tree": {"sha": "565a007c45f4d890796abe66ad5d014f7fb7c4f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/565a007c45f4d890796abe66ad5d014f7fb7c4f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bcaddeeb23544eb2c86b600c3d775e2773758c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcaddeeb23544eb2c86b600c3d775e2773758c2", "html_url": "https://github.com/rust-lang/rust/commit/4bcaddeeb23544eb2c86b600c3d775e2773758c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bcaddeeb23544eb2c86b600c3d775e2773758c2/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ae329232b368c6ca7352d403de9e34a71debc4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ae329232b368c6ca7352d403de9e34a71debc4b", "html_url": "https://github.com/rust-lang/rust/commit/9ae329232b368c6ca7352d403de9e34a71debc4b"}], "stats": {"total": 1220, "additions": 662, "deletions": 558}, "files": [{"sha": "2bc275ceff0be50cad4cabffd08cbe40e1751958", "filename": "book/src/development/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -66,7 +66,7 @@ Starting with an `expr`, you can check whether it is calling a specific method\n impl<'tcx> LateLintPass<'tcx> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         // Check our expr is calling a method\n-        if let hir::ExprKind::MethodCall(path, _, [_self_arg, ..]) = &expr.kind\n+        if let hir::ExprKind::MethodCall(path, _, _self_arg, ..) = &expr.kind\n             // Check the name of this method is `some_method`\n             && path.ident.name == sym!(some_method)\n             // Optionally, check the type of the self argument."}, {"sha": "7cd198ace86c0e3ff3f3edf4c9b44dc862b68429", "filename": "clippy_lints/src/assertions_on_result_states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fassertions_on_result_states.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fassertions_on_result_states.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_result_states.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnResultStates {\n             && matches!(cx.tcx.get_diagnostic_name(macro_call.def_id), Some(sym::assert_macro))\n             && let Some((condition, panic_expn)) = find_assert_args(cx, e, macro_call.expn)\n             && matches!(panic_expn, PanicExpn::Empty)\n-            && let ExprKind::MethodCall(method_segment, [recv], _) = condition.kind\n+            && let ExprKind::MethodCall(method_segment, recv, [], _) = condition.kind\n             && let result_type_with_refs = cx.typeck_results().expr_ty(recv)\n             && let result_type = result_type_with_refs.peel_refs()\n             && is_type_diagnostic_item(cx, result_type, sym::Result)"}, {"sha": "d9e2c9c8578f711f2a4f3c2a6185edbfafecefb8", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n             // do not lint if the closure is called using an iterator (see #1141)\n             if_chain! {\n                 if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, [self_arg, ..], _) = &parent.kind;\n+                if let ExprKind::MethodCall(_, self_arg, ..) = &parent.kind;\n                 let caller = self.cx.typeck_results().expr_ty(self_arg);\n                 if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n                 if implements_trait(self.cx, caller, iter_id, &[]);\n@@ -117,7 +117,8 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                             );\n                         }\n                     } else {\n-                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n+                        let span =\n+                            block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n                         if span.from_expansion() || expr.span.from_expansion() {\n                             return;\n                         }"}, {"sha": "656d639f0efd9838c272c92d6aa0e5d2e3fa7179", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -270,8 +270,8 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n                 ))\n             })\n         },\n-        ExprKind::MethodCall(path, args, _) if args.len() == 1 => {\n-            let type_of_receiver = cx.typeck_results().expr_ty(&args[0]);\n+        ExprKind::MethodCall(path, receiver, [], _) => {\n+            let type_of_receiver = cx.typeck_results().expr_ty(receiver);\n             if !is_type_diagnostic_item(cx, type_of_receiver, sym::Option)\n                 && !is_type_diagnostic_item(cx, type_of_receiver, sym::Result)\n             {\n@@ -285,7 +285,7 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n                     let path: &str = path.ident.name.as_str();\n                     a == path\n                 })\n-                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, args[0].span)?, neg_method)))\n+                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, receiver.span)?, neg_method)))\n         },\n         _ => None,\n     }"}, {"sha": "3f1edabe6c5040621bb2903b0df2e2ea07843270", "filename": "clippy_lints/src/casts/cast_abs_to_unsigned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -20,7 +20,7 @@ pub(super) fn check(\n     if meets_msrv(msrv, msrvs::UNSIGNED_ABS)\n         && let ty::Int(from) = cast_from.kind()\n         && let ty::Uint(to) = cast_to.kind()\n-        && let ExprKind::MethodCall(method_path, args, _) = cast_expr.kind\n+        && let ExprKind::MethodCall(method_path, receiver, ..) = cast_expr.kind\n         && method_path.ident.name.as_str() == \"abs\"\n     {\n         let span = if from.bit_width() == to.bit_width() {\n@@ -37,7 +37,7 @@ pub(super) fn check(\n             span,\n             &format!(\"casting the result of `{cast_from}::abs()` to {cast_to}\"),\n             \"replace with\",\n-            format!(\"{}.unsigned_abs()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+            format!(\"{}.unsigned_abs()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             Applicability::MachineApplicable,\n         );\n     }"}, {"sha": "406547a4454e6a1abeb91b894a599f36c9109191", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -44,7 +44,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n                 .saturating_sub(constant_int(cx, right).map_or(0, |s| u64::try_from(s).expect(\"shift too high\"))),\n             _ => nbits,\n         },\n-        ExprKind::MethodCall(method, [left, right], _) => {\n+        ExprKind::MethodCall(method, left, [right], _) => {\n             if signed {\n                 return nbits;\n             }\n@@ -55,7 +55,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             };\n             apply_reductions(cx, nbits, left, signed).min(max_bits.unwrap_or(u64::max_value()))\n         },\n-        ExprKind::MethodCall(method, [_, lo, hi], _) => {\n+        ExprKind::MethodCall(method, _, [lo, hi], _) => {\n             if method.ident.as_str() == \"clamp\" {\n                 //FIXME: make this a diagnostic item\n                 if let (Some(lo_bits), Some(hi_bits)) = (get_constant_bits(cx, lo), get_constant_bits(cx, hi)) {\n@@ -64,7 +64,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             }\n             nbits\n         },\n-        ExprKind::MethodCall(method, [_value], _) => {\n+        ExprKind::MethodCall(method, _value, [], _) => {\n             if method.ident.name.as_str() == \"signum\" {\n                 0 // do not lint if cast comes from a `signum` function\n             } else {"}, {"sha": "da7b12f67266a31898f5fcec7484eb11f6e8f865", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             cx.typeck_results().expr_ty(expr),\n         );\n         lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-    } else if let ExprKind::MethodCall(method_path, [self_arg, ..], _) = &expr.kind {\n+    } else if let ExprKind::MethodCall(method_path, self_arg, ..) = &expr.kind {\n         if method_path.ident.name == sym!(cast)\n             && let Some(generic_args) = method_path.args\n             && let [GenericArg::Type(cast_to)] = generic_args.args\n@@ -64,7 +64,7 @@ fn is_used_as_unaligned(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n         return false;\n     };\n     match parent.kind {\n-        ExprKind::MethodCall(name, [self_arg, ..], _) if self_arg.hir_id == e.hir_id => {\n+        ExprKind::MethodCall(name, self_arg, ..) if self_arg.hir_id == e.hir_id => {\n             if matches!(name.ident.as_str(), \"read_unaligned\" | \"write_unaligned\")\n                 && let Some(def_id) = cx.typeck_results().type_dependent_def_id(parent.hir_id)\n                 && let Some(def_id) = cx.tcx.impl_of_method(def_id)"}, {"sha": "5b59350be042c9ee173a398e36c403a81c86e01a", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -41,14 +41,14 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             }\n \n             // Don't lint for the result of methods that always return non-negative values.\n-            if let ExprKind::MethodCall(path, _, _) = cast_op.kind {\n+            if let ExprKind::MethodCall(path, ..) = cast_op.kind {\n                 let mut method_name = path.ident.name.as_str();\n                 let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n \n                 if_chain! {\n                     if method_name == \"unwrap\";\n                     if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n-                    if let ExprKind::MethodCall(inner_path, _, _) = &arglist[0][0].kind;\n+                    if let ExprKind::MethodCall(inner_path, ..) = &arglist[0].0.kind;\n                     then {\n                         method_name = inner_path.ident.name.as_str();\n                     }"}, {"sha": "64c5de5104206c73ee9eecb29dced83d11cbf658", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -69,10 +69,7 @@ struct NumericFallbackVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'tcx>) -> Self {\n-        Self {\n-            ty_bounds: vec![TyBound::Nothing],\n-            cx,\n-        }\n+        Self { ty_bounds: vec![TyBound::Nothing], cx }\n     }\n \n     /// Check whether a passed literal has potential to cause fallback or not.\n@@ -129,19 +126,21 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                     }\n                     return;\n                 }\n-            },\n+            }\n \n-            ExprKind::MethodCall(_, args, _) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n-                    for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {\n+                    for (expr, bound) in\n+                        iter::zip(std::iter::once(*receiver).chain(args.iter()), fn_sig.inputs())\n+                    {\n                         self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n                     return;\n                 }\n-            },\n+            }\n \n             ExprKind::Struct(_, fields, base) => {\n                 let ty = self.cx.typeck_results().expr_ty(expr);\n@@ -176,15 +175,15 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                         return;\n                     }\n                 }\n-            },\n+            }\n \n             ExprKind::Lit(lit) => {\n                 let ty = self.cx.typeck_results().expr_ty(expr);\n                 self.check_lit(lit, ty, expr.hir_id);\n                 return;\n-            },\n+            }\n \n-            _ => {},\n+            _ => {}\n         }\n \n         walk_expr(self, expr);\n@@ -198,7 +197,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 } else {\n                     self.ty_bounds.push(TyBound::Nothing);\n                 }\n-            },\n+            }\n \n             _ => self.ty_bounds.push(TyBound::Nothing),\n         }"}, {"sha": "fd6ed36cb192a0d40078b46e8aba373bca8e0215", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -581,7 +581,7 @@ fn try_parse_ref_op<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) -> Option<(RefOp, &'tcx Expr<'tcx>)> {\n     let (def_id, arg) = match expr.kind {\n-        ExprKind::MethodCall(_, [arg], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n+        ExprKind::MethodCall(_, arg, [], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(path),\n@@ -796,16 +796,19 @@ fn walk_parents<'tcx>(\n                             },\n                         })\n                     }),\n-                ExprKind::MethodCall(_, args, _) => {\n+                ExprKind::MethodCall(_, receiver, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n-                    args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n-                        if i == 0 {\n-                            // Check for calls to trait methods where the trait is implemented on a reference.\n-                            // Two cases need to be handled:\n-                            // * `self` methods on `&T` will never have auto-borrow\n-                            // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n-                            //   priority.\n-                            if e.hir_id != child_id {\n+                    std::iter::once(receiver)\n+                        .chain(args.iter())\n+                        .position(|arg| arg.hir_id == child_id)\n+                        .map(|i| {\n+                            if i == 0 {\n+                                // Check for calls to trait methods where the trait is implemented on a reference.\n+                                // Two cases need to be handled:\n+                                // * `self` methods on `&T` will never have auto-borrow\n+                                // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n+                                //   priority.\n+                                if e.hir_id != child_id {\n                                 Position::ReborrowStable(precedence)\n                             } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n                                 && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n@@ -834,20 +837,20 @@ fn walk_parents<'tcx>(\n                             } else {\n                                 Position::MethodReceiver\n                             }\n-                        } else {\n-                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n-                            if let ty::Param(param_ty) = ty.kind() {\n-                                needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n                             } else {\n-                                ty_auto_deref_stability(\n-                                    cx,\n-                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n-                                    precedence,\n-                                )\n-                                .position_for_arg()\n+                                let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n+                                if let ty::Param(param_ty) = ty.kind() {\n+                                    needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                                } else {\n+                                    ty_auto_deref_stability(\n+                                        cx,\n+                                        cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n+                                        precedence,\n+                                    )\n+                                    .position_for_arg()\n+                                }\n                             }\n-                        }\n-                    })\n+                        })\n                 },\n                 ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),"}, {"sha": "512872cedc1ea04d6f45be24bb378f77fa7372cf", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -828,7 +828,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.cx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.cx, receiver_ty, sym::Result)\n             {"}, {"sha": "e70df3f53c75de24d99388251cc906c4b444987c", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -245,8 +245,8 @@ fn try_parse_contains<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Optio\n     match expr.kind {\n         ExprKind::MethodCall(\n             _,\n+            map,\n             [\n-                map,\n                 Expr {\n                     kind: ExprKind::AddrOf(_, _, key),\n                     span: key_span,\n@@ -280,7 +280,7 @@ struct InsertExpr<'tcx> {\n     value: &'tcx Expr<'tcx>,\n }\n fn try_parse_insert<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n-    if let ExprKind::MethodCall(_, [map, key, value], _) = expr.kind {\n+    if let ExprKind::MethodCall(_, map, [key, value], _) = expr.kind {\n         let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n         if match_def_path(cx, id, &paths::BTREEMAP_INSERT) || match_def_path(cx, id, &paths::HASHMAP_INSERT) {\n             Some(InsertExpr { map, key, value })"}, {"sha": "1c0a93c71fde0989b64e32c89f6ee1cf6f06a46d", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n             if !is_adjusted(cx, &body.value);\n             if let ExprKind::Call(callee, args) = body.value.kind;\n             if let ExprKind::Path(_) = callee.kind;\n-            if check_inputs(cx, body.params, args);\n+            if check_inputs(cx, body.params, None, args);\n             let callee_ty = cx.typeck_results().expr_ty_adjusted(callee);\n             let call_ty = cx.typeck_results().type_dependent_def_id(body.value.hir_id)\n                 .map_or(callee_ty, |id| cx.tcx.type_of(id));\n@@ -146,8 +146,8 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n \n         if_chain!(\n             if !is_adjusted(cx, &body.value);\n-            if let ExprKind::MethodCall(path, args, _) = body.value.kind;\n-            if check_inputs(cx, body.params, args);\n+            if let ExprKind::MethodCall(path, receiver, args, _) = body.value.kind;\n+            if check_inputs(cx, body.params, Some(receiver), args);\n             let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n             let substs = cx.typeck_results().node_substs(body.value.hir_id);\n             let call_ty = cx.tcx.bound_type_of(method_def_id).subst(cx.tcx, substs);\n@@ -167,12 +167,17 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n     }\n }\n \n-fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_>]) -> bool {\n-    if params.len() != call_args.len() {\n+fn check_inputs(\n+    cx: &LateContext<'_>,\n+    params: &[Param<'_>],\n+    receiver: Option<&Expr<'_>>,\n+    call_args: &[Expr<'_>],\n+) -> bool {\n+    if receiver.map_or(params.len() != call_args.len(), |_| params.len() != call_args.len() + 1) {\n         return false;\n     }\n     let binding_modes = cx.typeck_results().pat_binding_modes();\n-    std::iter::zip(params, call_args).all(|(param, arg)| {\n+    let check_inputs = |param: &Param<'_>, arg| {\n         match param.pat.kind {\n             PatKind::Binding(_, id, ..) if path_to_local_id(arg, id) => {},\n             _ => return false,\n@@ -200,7 +205,13 @@ fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_\n             },\n             _ => false,\n         }\n-    })\n+    };\n+    if let Some(receiver) = receiver {\n+        std::iter::zip(params, std::iter::once(receiver).chain(call_args.iter()))\n+            .all(|(param, arg)| check_inputs(param, arg))\n+    } else {\n+        std::iter::zip(params, call_args).all(|(param, arg)| check_inputs(param, arg))\n+    }\n }\n \n fn check_sig<'tcx>(cx: &LateContext<'tcx>, closure_ty: Ty<'tcx>, call_ty: Ty<'tcx>) -> bool {"}, {"sha": "9c76f63f5f7556afa0960a52a96858e3cf9a9a78", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -45,10 +45,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, [write_call], _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n-            if let ExprKind::MethodCall(write_fun, [write_recv, write_arg], _) = look_in_block(cx, &write_call.kind);\n+            if let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind);\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {"}, {"sha": "790eea63f58c49e048e58caf039c5e4360765a61", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -84,7 +84,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+                let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n                 if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                     || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n                 {"}, {"sha": "728db41d600438e39803cc21dee554a1e0879820", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -164,30 +164,30 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     suggestion.maybe_par()\n }\n \n-fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some(method) = get_specialized_log_method(cx, &args[1]) {\n+fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some(method) = get_specialized_log_method(cx, &args[0]) {\n         span_lint_and_sugg(\n             cx,\n             SUBOPTIMAL_FLOPS,\n             expr.span,\n             \"logarithm for bases 2, 10 and e can be computed more accurately\",\n             \"consider using\",\n-            format!(\"{}.{}()\", Sugg::hir(cx, &args[0], \"..\").maybe_par(), method),\n+            format!(\"{}.{}()\", Sugg::hir(cx, receiver, \"..\").maybe_par(), method),\n             Applicability::MachineApplicable,\n         );\n     }\n }\n \n // TODO: Lint expressions of the form `(x + y).ln()` where y > 1 and\n // suggest usage of `(x + (y - 1)).ln_1p()` instead\n-fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>) {\n     if let ExprKind::Binary(\n         Spanned {\n             node: BinOpKind::Add, ..\n         },\n         lhs,\n         rhs,\n-    ) = &args[0].kind\n+    ) = receiver.kind\n     {\n         let recv = match (\n             constant(cx, cx.typeck_results(), lhs),\n@@ -235,9 +235,9 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n     }\n }\n \n-fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), receiver) {\n         let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n             \"exp\"\n         } else if F32(2.0) == value || F64(2.0) == value {\n@@ -252,32 +252,32 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n             expr.span,\n             \"exponent for bases 2 and e can be computed more accurately\",\n             \"consider using\",\n-            format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[1]), method),\n+            format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[0]), method),\n             Applicability::MachineApplicable,\n         );\n     }\n \n     // Check argument\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n         let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n             (\n                 SUBOPTIMAL_FLOPS,\n                 \"square-root of a number can be computed more efficiently and accurately\",\n-                format!(\"{}.sqrt()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+                format!(\"{}.sqrt()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             )\n         } else if F32(1.0 / 3.0) == value || F64(1.0 / 3.0) == value {\n             (\n                 IMPRECISE_FLOPS,\n                 \"cube-root of a number can be computed more accurately\",\n-                format!(\"{}.cbrt()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+                format!(\"{}.cbrt()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             )\n         } else if let Some(exponent) = get_integer_from_float_constant(&value) {\n             (\n                 SUBOPTIMAL_FLOPS,\n                 \"exponentiation with integer powers can be computed more efficiently\",\n                 format!(\n                     \"{}.powi({})\",\n-                    Sugg::hir(cx, &args[0], \"..\").maybe_par(),\n+                    Sugg::hir(cx, receiver, \"..\").maybe_par(),\n                     numeric_literal::format(&exponent.to_string(), None, false)\n                 ),\n             )\n@@ -297,13 +297,14 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n }\n \n-fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n         if value == Int(2) {\n             if let Some(parent) = get_parent_expr(cx, expr) {\n                 if let Some(grandparent) = get_parent_expr(cx, parent) {\n-                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, args, _) = grandparent.kind {\n-                        if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, receiver, ..) = grandparent.kind\n+                    {\n+                        if method_name.as_str() == \"sqrt\" && detect_hypot(cx, receiver).is_some() {\n                             return;\n                         }\n                     }\n@@ -327,8 +328,8 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                         \"consider using\",\n                         format!(\n                             \"{}.mul_add({}, {})\",\n-                            Sugg::hir(cx, &args[0], \"..\").maybe_par(),\n-                            Sugg::hir(cx, &args[0], \"..\"),\n+                            Sugg::hir(cx, receiver, \"..\").maybe_par(),\n+                            Sugg::hir(cx, receiver, \"..\"),\n                             Sugg::hir(cx, other_addend, \"..\"),\n                         ),\n                         Applicability::MachineApplicable,\n@@ -339,14 +340,14 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n }\n \n-fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n+fn detect_hypot(cx: &LateContext<'_>, receiver: &Expr<'_>) -> Option<String> {\n     if let ExprKind::Binary(\n         Spanned {\n             node: BinOpKind::Add, ..\n         },\n         add_lhs,\n         add_rhs,\n-    ) = args[0].kind\n+    ) = receiver.kind\n     {\n         // check if expression of the form x * x + y * y\n         if_chain! {\n@@ -363,12 +364,12 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: lmethod_name, .. },\n-                [largs_0, largs_1, ..],\n+                largs_0, [largs_1, ..],\n                 _\n             ) = &add_lhs.kind;\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: rmethod_name, .. },\n-                [rargs_0, rargs_1, ..],\n+                rargs_0, [rargs_1, ..],\n                 _\n             ) = &add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n@@ -384,8 +385,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n     None\n }\n \n-fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some(message) = detect_hypot(cx, args) {\n+fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>) {\n+    if let Some(message) = detect_hypot(cx, receiver) {\n         span_lint_and_sugg(\n             cx,\n             IMPRECISE_FLOPS,\n@@ -406,7 +407,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n-        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &lhs.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = &lhs.kind;\n         if cx.typeck_results().expr_ty(self_arg).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n@@ -450,8 +451,8 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     ) = &expr.kind\n     {\n         if let Some(parent) = get_parent_expr(cx, expr) {\n-            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, args, _) = parent.kind {\n-                if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, receiver, ..) = parent.kind {\n+                if method_name.as_str() == \"sqrt\" && detect_hypot(cx, receiver).is_some() {\n                     return;\n                 }\n             }\n@@ -586,14 +587,14 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, args_a, _) = expr_a.kind;\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, args_b, _) = expr_b.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, args_a, _) = expr_a.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, args_b, _) = expr_b.kind;\n         then {\n             return method_name_a.as_str() == method_name_b.as_str() &&\n                 args_a.len() == args_b.len() &&\n                 (\n                     [\"ln\", \"log2\", \"log10\"].contains(&method_name_a.as_str()) ||\n-                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && eq_expr_value(cx, &args_a[1], &args_b[1])\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 1 && eq_expr_value(cx, &args_a[0], &args_b[0])\n                 );\n         }\n     }\n@@ -612,8 +613,8 @@ fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             rhs,\n         ) = &expr.kind;\n         if are_same_base_logs(cx, lhs, rhs);\n-        if let ExprKind::MethodCall(_, [largs_self, ..], _) = &lhs.kind;\n-        if let ExprKind::MethodCall(_, [rargs_self, ..], _) = &rhs.kind;\n+        if let ExprKind::MethodCall(_, largs_self, ..) = &lhs.kind;\n+        if let ExprKind::MethodCall(_, rargs_self, ..) = &rhs.kind;\n         then {\n             span_lint_and_sugg(\n                 cx,\n@@ -711,16 +712,16 @@ impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n             return;\n         }\n \n-        if let ExprKind::MethodCall(path, args, _) = &expr.kind {\n-            let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n+        if let ExprKind::MethodCall(path, receiver, args, _) = &expr.kind {\n+            let recv_ty = cx.typeck_results().expr_ty(receiver);\n \n             if recv_ty.is_floating_point() {\n                 match path.ident.name.as_str() {\n-                    \"ln\" => check_ln1p(cx, expr, args),\n-                    \"log\" => check_log_base(cx, expr, args),\n-                    \"powf\" => check_powf(cx, expr, args),\n-                    \"powi\" => check_powi(cx, expr, args),\n-                    \"sqrt\" => check_hypot(cx, expr, args),\n+                    \"ln\" => check_ln1p(cx, expr, receiver),\n+                    \"log\" => check_log_base(cx, expr, receiver, args),\n+                    \"powf\" => check_powf(cx, expr, receiver, args),\n+                    \"powi\" => check_powi(cx, expr, receiver, args),\n+                    \"sqrt\" => check_hypot(cx, expr, receiver),\n                     _ => {},\n                 }\n             }"}, {"sha": "2a55c48cf7731abb590b4d392d4512d90453e4fc", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -99,7 +99,12 @@ fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n     }\n }\n \n-fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &Expr<'_>) {\n+fn check_format_in_format_args(\n+    cx: &LateContext<'_>,\n+    call_site: Span,\n+    name: Symbol,\n+    arg: &Expr<'_>,\n+) {\n     let expn_data = arg.span.ctxt().outer_expn_data();\n     if expn_data.call_site.from_expansion() {\n         return;\n@@ -126,7 +131,7 @@ fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symb\n fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Expr<'_>) {\n     if_chain! {\n         if !value.span.from_expansion();\n-        if let ExprKind::MethodCall(_, [receiver], _) = value.kind;\n+        if let ExprKind::MethodCall(_, receiver, [], _) = value.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(value.hir_id);\n         if is_diag_trait_item(cx, method_def_id, sym::ToString);\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);\n@@ -177,10 +182,7 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n \n // Returns true if `hir_id` is referred to by multiple format params\n fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n-    args.params()\n-        .filter(|param| param.value.hir_id == hir_id)\n-        .at_most_one()\n-        .is_err()\n+    args.params().filter(|param| param.value.hir_id == hir_id).at_most_one().is_err()\n }\n \n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n@@ -190,11 +192,7 @@ where\n     let mut n_total = 0;\n     let mut n_needed = 0;\n     loop {\n-        if let Some(Adjustment {\n-            kind: Adjust::Deref(overloaded_deref),\n-            target,\n-        }) = iter.next()\n-        {\n+        if let Some(Adjustment { kind: Adjust::Deref(overloaded_deref), target }) = iter.next() {\n             n_total += 1;\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;"}, {"sha": "b628fd9f758143fa537dae4112d95a032696d5fb", "filename": "clippy_lints/src/format_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_impl.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for FormatImpl {\n fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         // Get the hir_id of the object we are calling the method on\n-        if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = expr.kind;\n         // Is the method to_string() ?\n         if path.ident.name == sym::to_string;\n         // Is the method a part of the ToString trait? (i.e. not to_string() implemented"}, {"sha": "9b9f1872bfc1d2cf5b42a86253b05ccb2db63927", "filename": "clippy_lints/src/format_push_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fformat_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fformat_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_push_string.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -54,7 +54,7 @@ fn is_format(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n impl<'tcx> LateLintPass<'tcx> for FormatPushString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let arg = match expr.kind {\n-            ExprKind::MethodCall(_, [_, arg], _) => {\n+            ExprKind::MethodCall(_, _, [arg], _) => {\n                 if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) &&\n                 match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n                     arg"}, {"sha": "a17b23f5edc8609074d202d7f85d974be80d84dc", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n             return;\n         }\n         match expr.kind {\n-            Call(_, args) | MethodCall(_, args, _) => {\n+            Call(_, args) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n                     if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n@@ -230,6 +230,24 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                     tys.clear();\n                 }\n             },\n+            MethodCall(_, receiver, args, _) => {\n+                let mut tys = DefIdSet::default();\n+                for arg in std::iter::once(receiver).chain(args.iter()) {\n+                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                        && is_mutable_ty(\n+                            self.cx,\n+                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n+                            arg.span,\n+                            &mut tys,\n+                        )\n+                        && is_mutated_static(arg)\n+                    {\n+                        self.mutates_static = true;\n+                        return;\n+                    }\n+                    tys.clear();\n+                }\n+            },\n             Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n                 self.mutates_static |= is_mutated_static(target);\n             },"}, {"sha": "3bbfa52e810392c98cadd63e7cea7e32dd30ec3e", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -88,11 +88,12 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, args, _) => {\n+            hir::ExprKind::MethodCall(_, receiver, args, _) => {\n                 let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n                 if type_is_unsafe_function(self.cx, base_type) {\n+                    self.check_arg(receiver);\n                     for arg in args {\n                         self.check_arg(arg);\n                     }"}, {"sha": "9ea8c494cfcdab4a0fd71e5dbe80433fd4e2f8b1", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -129,7 +129,7 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n \n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n         if path.ident.as_str() == \"lock\";\n         let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n         if is_type_diagnostic_item(cx, ty, sym::Mutex);"}, {"sha": "fca3cb46a2e9cbb927a10156c2a297b2d6063250", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -123,43 +123,43 @@ use self::Heuristic::{All, Always, Any, First};\n /// is an upper bound, e.g., some methods can return a possibly\n /// infinite iterator at worst, e.g., `take_while`.\n const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n-    (\"zip\", 2, All, Infinite),\n-    (\"chain\", 2, Any, Infinite),\n-    (\"cycle\", 1, Always, Infinite),\n-    (\"map\", 2, First, Infinite),\n-    (\"by_ref\", 1, First, Infinite),\n-    (\"cloned\", 1, First, Infinite),\n-    (\"rev\", 1, First, Infinite),\n-    (\"inspect\", 1, First, Infinite),\n-    (\"enumerate\", 1, First, Infinite),\n-    (\"peekable\", 2, First, Infinite),\n-    (\"fuse\", 1, First, Infinite),\n-    (\"skip\", 2, First, Infinite),\n-    (\"skip_while\", 1, First, Infinite),\n-    (\"filter\", 2, First, Infinite),\n-    (\"filter_map\", 2, First, Infinite),\n-    (\"flat_map\", 2, First, Infinite),\n-    (\"unzip\", 1, First, Infinite),\n-    (\"take_while\", 2, First, MaybeInfinite),\n-    (\"scan\", 3, First, MaybeInfinite),\n+    (\"zip\", 1, All, Infinite),\n+    (\"chain\", 1, Any, Infinite),\n+    (\"cycle\", 0, Always, Infinite),\n+    (\"map\", 1, First, Infinite),\n+    (\"by_ref\", 0, First, Infinite),\n+    (\"cloned\", 0, First, Infinite),\n+    (\"rev\", 0, First, Infinite),\n+    (\"inspect\", 0, First, Infinite),\n+    (\"enumerate\", 0, First, Infinite),\n+    (\"peekable\", 1, First, Infinite),\n+    (\"fuse\", 0, First, Infinite),\n+    (\"skip\", 1, First, Infinite),\n+    (\"skip_while\", 0, First, Infinite),\n+    (\"filter\", 1, First, Infinite),\n+    (\"filter_map\", 1, First, Infinite),\n+    (\"flat_map\", 1, First, Infinite),\n+    (\"unzip\", 0, First, Infinite),\n+    (\"take_while\", 1, First, MaybeInfinite),\n+    (\"scan\", 2, First, MaybeInfinite),\n ];\n \n fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(method, args, _) => {\n+        ExprKind::MethodCall(method, receiver, args, _) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return (match heuristic {\n                         Always => Infinite,\n-                        First => is_infinite(cx, &args[0]),\n-                        Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n-                        All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n+                        First => is_infinite(cx, receiver),\n+                        Any => is_infinite(cx, receiver).or(is_infinite(cx, &args[0])),\n+                        All => is_infinite(cx, receiver).and(is_infinite(cx, &args[0])),\n                     })\n                     .and(cap);\n                 }\n             }\n-            if method.ident.name == sym!(flat_map) && args.len() == 2 {\n-                if let ExprKind::Closure(&Closure { body, .. }) = args[1].kind {\n+            if method.ident.name == sym!(flat_map) && args.len() == 1 {\n+                if let ExprKind::Closure(&Closure { body, .. }) = args[0].kind {\n                     let body = cx.tcx.hir().body(body);\n                     return is_infinite(cx, &body.value);\n                 }\n@@ -179,29 +179,29 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n /// the names and argument lengths of methods that *may* exhaust their\n /// iterators\n const POSSIBLY_COMPLETING_METHODS: [(&str, usize); 6] = [\n-    (\"find\", 2),\n-    (\"rfind\", 2),\n-    (\"position\", 2),\n-    (\"rposition\", 2),\n-    (\"any\", 2),\n-    (\"all\", 2),\n+    (\"find\", 1),\n+    (\"rfind\", 1),\n+    (\"position\", 1),\n+    (\"rposition\", 1),\n+    (\"any\", 1),\n+    (\"all\", 1),\n ];\n \n /// the names and argument lengths of methods that *always* exhaust\n /// their iterators\n const COMPLETING_METHODS: [(&str, usize); 12] = [\n-    (\"count\", 1),\n-    (\"fold\", 3),\n-    (\"for_each\", 2),\n-    (\"partition\", 2),\n-    (\"max\", 1),\n-    (\"max_by\", 2),\n-    (\"max_by_key\", 2),\n-    (\"min\", 1),\n-    (\"min_by\", 2),\n-    (\"min_by_key\", 2),\n-    (\"sum\", 1),\n-    (\"product\", 1),\n+    (\"count\", 0),\n+    (\"fold\", 2),\n+    (\"for_each\", 1),\n+    (\"partition\", 1),\n+    (\"max\", 0),\n+    (\"max_by\", 1),\n+    (\"max_by_key\", 1),\n+    (\"min\", 0),\n+    (\"min_by\", 1),\n+    (\"min_by_key\", 1),\n+    (\"sum\", 0),\n+    (\"product\", 0),\n ];\n \n /// the paths of types that are known to be infinitely allocating\n@@ -218,34 +218,34 @@ const INFINITE_COLLECTORS: &[Symbol] = &[\n \n fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(method, args, _) => {\n+        ExprKind::MethodCall(method, receiver, args, _) => {\n             for &(name, len) in &COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             }\n             for &(name, len) in &POSSIBLY_COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n-                    return MaybeInfinite.and(is_infinite(cx, &args[0]));\n+                    return MaybeInfinite.and(is_infinite(cx, receiver));\n                 }\n             }\n-            if method.ident.name == sym!(last) && args.len() == 1 {\n+            if method.ident.name == sym!(last) {\n                 let not_double_ended = cx\n                     .tcx\n                     .get_diagnostic_item(sym::DoubleEndedIterator)\n                     .map_or(false, |id| {\n-                        !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n+                        !implements_trait(cx, cx.typeck_results().expr_ty(receiver), id, &[])\n                     });\n                 if not_double_ended {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             } else if method.ident.name == sym!(collect) {\n                 let ty = cx.typeck_results().expr_ty(expr);\n                 if INFINITE_COLLECTORS\n                     .iter()\n                     .any(|diag_item| is_type_diagnostic_item(cx, ty, *diag_item))\n                 {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             }\n         },"}, {"sha": "25f366bfe6a801479ff2e911ff4fca6a83edcac9", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -370,15 +370,15 @@ fn check_for_is_empty<'tcx>(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+    if let (&ExprKind::MethodCall(method_path, receiver, ..), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {\n                 return;\n             }\n         }\n \n-        check_len(cx, span, method_path.ident.name, args, &lit.node, op, compare_to);\n+        check_len(cx, span, method_path.ident.name, receiver, &lit.node, op, compare_to);\n     } else {\n         check_empty_expr(cx, span, method, lit, op);\n     }\n@@ -388,7 +388,7 @@ fn check_len(\n     cx: &LateContext<'_>,\n     span: Span,\n     method_name: Symbol,\n-    args: &[Expr<'_>],\n+    receiver: &Expr<'_>,\n     lit: &LitKind,\n     op: &str,\n     compare_to: u32,\n@@ -399,7 +399,7 @@ fn check_len(\n             return;\n         }\n \n-        if method_name == sym::len && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if method_name == sym::len && has_is_empty(cx, receiver) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n@@ -410,7 +410,7 @@ fn check_len(\n                 format!(\n                     \"{}{}.is_empty()\",\n                     op,\n-                    snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability)\n+                    snippet_with_applicability(cx, receiver.span, \"_\", &mut applicability)\n                 ),\n                 applicability,\n             );"}, {"sha": "3fc569af89ecb4f386ba4a5b973494b4e31b9279", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -119,7 +119,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n \n     let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n         if_chain! {\n-            if let ExprKind::MethodCall(method, [recv], _) = end.kind;\n+            if let ExprKind::MethodCall(method, recv, [], _) = end.kind;\n             if method.ident.name == sym::len;\n             if path_to_local(recv) == path_to_local(base);\n             then {\n@@ -341,7 +341,7 @@ fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Opti\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, [arg], _) = expr.kind;\n+        if let ExprKind::MethodCall(method, arg, [], _) = expr.kind;\n         if method.ident.name == sym::clone;\n         then { arg } else { expr }\n     }"}, {"sha": "8412875b11b7ecbfae00e57166f5712f5a61307c", "filename": "clippy_lints/src/loops/missing_spin_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -33,7 +33,7 @@ fn unpack_cond<'tcx>(cond: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Block(Block { stmts: [], expr: None, ..}, _) = body.kind;\n-        if let ExprKind::MethodCall(method, [callee, ..], _) = unpack_cond(cond).kind;\n+        if let ExprKind::MethodCall(method, callee, ..) = unpack_cond(cond).kind;\n         if [sym::load, sym::compare_exchange, sym::compare_exchange_weak].contains(&method.ident.name);\n         if let ty::Adt(def, _substs) = cx.typeck_results().expr_ty(callee).kind();\n         if cx.tcx.is_diagnostic_item(sym::AtomicBool, def.did());"}, {"sha": "74f3bda9f43efb0fe0749d4e069640cc634bba4e", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -742,7 +742,7 @@ fn check_for_loop<'tcx>(\n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n \n-    if let ExprKind::MethodCall(method, [self_arg], _) = arg.kind {\n+    if let ExprKind::MethodCall(method, self_arg, [], _) = arg.kind {\n         let method_name = method.ident.as_str();\n         // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n         match method_name {"}, {"sha": "6e6faa79adc9e7df8e2d43df4efc1fe3e086bbcd", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -25,11 +25,11 @@ pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n }\n fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, args, _) = expr.kind;\n-        if let ExprKind::MethodCall(chain_method, _, _) = args[0].kind;\n-        if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n+        if let ExprKind::MethodCall(method, receiver, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(chain_method, ..) = receiver.kind;\n+        if chain_method.ident.name == sym!(collect) && is_trait_method(cx, receiver, sym::Iterator);\n         then {\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(receiver);\n             let mut applicability = Applicability::MaybeIncorrect;\n             let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = method.ident.name.as_str();\n@@ -41,7 +41,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n                     \"len\" => \"count()\".to_string(),\n                     \"is_empty\" => is_empty_sugg,\n                     \"contains\" => {\n-                        let contains_arg = snippet_with_applicability(cx, args[1].span, \"??\", &mut applicability);\n+                        let contains_arg = snippet_with_applicability(cx, args[0].span, \"??\", &mut applicability);\n                         let (arg, pred) = contains_arg\n                             .strip_prefix('&')\n                             .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n@@ -80,7 +80,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                 if let StmtKind::Local(local) = stmt.kind;\n                 if let PatKind::Binding(_, id, ..) = local.pat.kind;\n                 if let Some(init_expr) = local.init;\n-                if let ExprKind::MethodCall(method_name, &[ref iter_source], ..) = init_expr.kind;\n+                if let ExprKind::MethodCall(method_name, iter_source, [], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n                 let ty = cx.typeck_results().expr_ty(init_expr);\n                 if is_type_diagnostic_item(cx, ty, sym::Vec) ||\n@@ -203,7 +203,7 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n-        if let ExprKind::MethodCall(method_name, [recv, args @ ..], _) = &expr.kind {\n+        if let ExprKind::MethodCall(method_name, recv, [args @ ..], _) = &expr.kind {\n             if method_name.ident.name == sym!(collect) && is_trait_method(self.cx, expr, sym::Iterator) {\n                 self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(recv));\n                 self.visit_expr(recv);"}, {"sha": "ffcf83e4605e2d3cbb84986e80fadbbc7b21a5da", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -188,7 +188,7 @@ pub(super) fn check<'tcx>(\n \n fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, [recv], _) = expr.kind;\n+        if let ExprKind::MethodCall(method, recv, [], _) = expr.kind;\n         if method.ident.name == sym::len;\n         if let ExprKind::Path(QPath::Resolved(_, path)) = recv.kind;\n         if path.segments.len() == 1;\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(meth, [args_0, args_1, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(meth, args_0, [args_1, ..], _) = &expr.kind;\n             if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(args_1, args_0, expr);\n@@ -356,9 +356,12 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprKind::MethodCall(_, args, _) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-                for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args) {\n+                for (ty, expr) in iter::zip(\n+                    self.cx.tcx.fn_sig(def_id).inputs().skip_binder(),\n+                    std::iter::once(receiver).chain(args.iter()),\n+                ) {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {"}, {"sha": "116e589cad6f3495d87ccccbf1fdf9e238b9c1da", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -120,8 +120,9 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Repeat(e, _)\n         | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n         ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, main_loop_id),\n-        ExprKind::Array(es) | ExprKind::MethodCall(_, es, _) | ExprKind::Tup(es) => {\n-            never_loop_expr_all(&mut es.iter(), main_loop_id)\n+        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), main_loop_id),\n+        ExprKind::MethodCall(_, receiver, es, _) => {\n+            never_loop_expr_all(&mut std::iter::once(receiver).chain(es.iter()), main_loop_id)\n         },\n         ExprKind::Struct(_, fields, base) => {\n             let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), main_loop_id);"}, {"sha": "23f47091f77f91f953af18f036f9c3ad4e130ea9", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -180,10 +180,9 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n     if_chain! {\n             // Extract method being called\n             if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n-            if let ExprKind::MethodCall(path, args, _) = &semi_stmt.kind;\n+            if let ExprKind::MethodCall(path, self_expr, args, _) = &semi_stmt.kind;\n             // Figure out the parameters for the method call\n-            if let Some(self_expr) = args.get(0);\n-            if let Some(pushed_item) = args.get(1);\n+            if let Some(pushed_item) = args.get(0);\n             // Check that the method being called is push() on a Vec\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::Vec);\n             if path.ident.name.as_str() == \"push\";"}, {"sha": "f4b47808dfaa362b8b7f9ce3d6625d87d07d8a48", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -35,32 +35,29 @@ pub(super) fn check<'tcx>(\n         ) => (arg, \"&mut \"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name == rustc_span::sym::iter => (arg, \"&\"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name.as_str() == \"iter_mut\" => (arg, \"&mut \"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name == rustc_span::sym::into_iter => (arg, \"\"),\n         // Only check for arrays edition 2021 or later, as this case will trigger a compiler error otherwise."}, {"sha": "735d704a43cee343dcdb0ea76dea3a02566e6815", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -11,7 +11,14 @@ use rustc_lint::LateContext;\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n     let (init, has_trailing_exprs) = match (loop_block.stmts, loop_block.expr) {\n         ([stmt, stmts @ ..], expr) => {\n-            if let StmtKind::Local(&Local { init: Some(e), els: None, .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n+            if let StmtKind::Local(&Local {\n+                init: Some(e),\n+                els: None,\n+                ..\n+            })\n+            | StmtKind::Semi(e)\n+            | StmtKind::Expr(e) = stmt.kind\n+            {\n                 (e, !stmts.is_empty() || expr.is_some())\n             } else {\n                 return;"}, {"sha": "2c54033f8597502c6fb8db8c276f6f91d450377c", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Res::Def(_, pat_did) = pat_path.res;\n         if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n         // check for call to `Iterator::next`\n-        if let ExprKind::MethodCall(method_name, [iter_expr], _) = let_expr.kind;\n+        if let ExprKind::MethodCall(method_name, iter_expr, [], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;\n         if is_trait_method(cx, let_expr, sym::Iterator);\n         if let Some(iter_expr_struct) = try_parse_iter_expr(cx, iter_expr);"}, {"sha": "6655c92b1da8da05a2f2f983bbe9fd8e28eaf439", "filename": "clippy_lints/src/manual_bits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_bits.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -134,7 +134,7 @@ fn create_sugg(cx: &LateContext<'_>, expr: &Expr<'_>, base_sugg: String) -> Stri\n fn is_ty_conversion(expr: &Expr<'_>) -> bool {\n     if let ExprKind::Cast(..) = expr.kind {\n         true\n-    } else if let ExprKind::MethodCall(path, [_], _) = expr.kind\n+    } else if let ExprKind::MethodCall(path, _, [], _) = expr.kind\n         && path.ident.name == rustc_span::sym::try_into\n     {\n         // This is only called for `usize` which implements `TryInto`. Therefore,"}, {"sha": "f28c37d3dca7e0d9d49417fe4c832197d70229cb", "filename": "clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_retain.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -66,9 +66,9 @@ impl<'tcx> LateLintPass<'tcx> for ManualRetain {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if let Some(parent_expr) = get_parent_expr(cx, expr)\n             && let Assign(left_expr, collect_expr, _) = &parent_expr.kind\n-            && let hir::ExprKind::MethodCall(seg, _, _) = &collect_expr.kind\n+            && let hir::ExprKind::MethodCall(seg, ..) = &collect_expr.kind\n             && seg.args.is_none()\n-            && let hir::ExprKind::MethodCall(_, [target_expr], _) = &collect_expr.kind\n+            && let hir::ExprKind::MethodCall(_, target_expr, [], _) = &collect_expr.kind\n             && let Some(collect_def_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id)\n             && match_def_path(cx, collect_def_id, &paths::CORE_ITER_COLLECT) {\n             check_into_iter(cx, parent_expr, left_expr, target_expr, self.msrv);\n@@ -87,10 +87,10 @@ fn check_into_iter(\n     target_expr: &hir::Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) {\n-    if let hir::ExprKind::MethodCall(_, [into_iter_expr, _], _) = &target_expr.kind\n+    if let hir::ExprKind::MethodCall(_, into_iter_expr, [_], _) = &target_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &into_iter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &into_iter_expr.kind\n         && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n         && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n         && match_acceptable_type(cx, left_expr, msrv)\n@@ -106,14 +106,14 @@ fn check_iter(\n     target_expr: &hir::Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) {\n-    if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+    if let hir::ExprKind::MethodCall(_, filter_expr, [], _) = &target_expr.kind\n         && let Some(copied_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && (match_def_path(cx, copied_def_id, &paths::CORE_ITER_COPIED)\n             || match_def_path(cx, copied_def_id, &paths::CORE_ITER_CLONED))\n-        && let hir::ExprKind::MethodCall(_, [iter_expr, _], _) = &filter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, iter_expr, [_], _) = &filter_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &iter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &iter_expr.kind\n         && let Some(iter_expr_def_id) = cx.typeck_results().type_dependent_def_id(iter_expr.hir_id)\n         && match_acceptable_def_path(cx, iter_expr_def_id)\n         && match_acceptable_type(cx, left_expr, msrv)\n@@ -130,13 +130,13 @@ fn check_to_owned(\n     msrv: Option<RustcVersion>,\n ) {\n     if meets_msrv(msrv,  msrvs::STRING_RETAIN)\n-        && let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let hir::ExprKind::MethodCall(_, filter_expr, [], _) = &target_expr.kind\n         && let Some(to_owned_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && match_def_path(cx, to_owned_def_id, &paths::TO_OWNED_METHOD)\n-        && let hir::ExprKind::MethodCall(_, [chars_expr, _], _) = &filter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, chars_expr, [_], _) = &filter_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [str_expr], _) = &chars_expr.kind\n+        && let hir::ExprKind::MethodCall(_, str_expr, [], _) = &chars_expr.kind\n         && let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id)\n         && match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS)\n         && let ty = cx.typeck_results().expr_ty(str_expr).peel_refs()\n@@ -147,7 +147,7 @@ fn check_to_owned(\n }\n \n fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::Expr<'_>, filter_expr: &hir::Expr<'_>) {\n-    if let hir::ExprKind::MethodCall(_, [_, closure], _) = filter_expr.kind\n+    if let hir::ExprKind::MethodCall(_, _, [closure], _) = filter_expr.kind\n         && let hir::ExprKind::Closure(&hir::Closure { body, ..}) = closure.kind\n         && let filter_body = cx.tcx.hir().body(body)\n         && let [filter_params] = filter_body.params"}, {"sha": "6acfb2ae3471c3b3a4f3840b609d490af95e0cfe", "filename": "clippy_lints/src/manual_string_new.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmanual_string_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmanual_string_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_string_new.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -55,8 +55,8 @@ impl LateLintPass<'_> for ManualStringNew {\n             ExprKind::Call(func, args) => {\n                 parse_call(cx, expr.span, func, args);\n             },\n-            ExprKind::MethodCall(path_segment, args, _) => {\n-                parse_method_call(cx, expr.span, path_segment, args);\n+            ExprKind::MethodCall(path_segment, receiver, ..) => {\n+                parse_method_call(cx, expr.span, path_segment, receiver);\n             },\n             _ => (),\n         }\n@@ -88,14 +88,9 @@ fn warn_then_suggest(cx: &LateContext<'_>, span: Span) {\n }\n \n /// Tries to parse an expression as a method call, emitting the warning if necessary.\n-fn parse_method_call(cx: &LateContext<'_>, span: Span, path_segment: &PathSegment<'_>, args: &[Expr<'_>]) {\n-    if args.is_empty() {\n-        // When parsing TryFrom::try_from(...).expect(...), we will have more than 1 arg.\n-        return;\n-    }\n-\n+fn parse_method_call(cx: &LateContext<'_>, span: Span, path_segment: &PathSegment<'_>, receiver: &Expr<'_>) {\n     let ident = path_segment.ident.as_str();\n-    let method_arg_kind = &args[0].kind;\n+    let method_arg_kind = &receiver.kind;\n     if [\"to_string\", \"to_owned\", \"into\"].contains(&ident) && is_expr_kind_empty_str(method_arg_kind) {\n         warn_then_suggest(cx, span);\n     } else if let ExprKind::Call(func, args) = method_arg_kind {"}, {"sha": "7941c8c9c7e39bc4c2f941d765f19904569c7bbd", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n \n         if_chain! {\n             if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n-            if let ExprKind::MethodCall(_, [target_arg, pattern], _) = cond.kind;\n+            if let ExprKind::MethodCall(_, target_arg, [pattern], _) = cond.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n             if let ExprKind::Path(target_path) = &target_arg.kind;\n             then {\n@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n // Returns `Some(arg)` if `expr` matches `arg.len()` and `None` otherwise.\n fn len_arg<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(_, [arg], _) = expr.kind;\n+        if let ExprKind::MethodCall(_, arg, [], _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, method_def_id, &paths::STR_LEN);\n         then {"}, {"sha": "33d744815299f040f56a967423b248e65eb6ea5c", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -200,8 +200,13 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     )\n }\n \n-fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n-    let var_arg = &map_args[0];\n+fn lint_map_unit_fn(\n+    cx: &LateContext<'_>,\n+    stmt: &hir::Stmt<'_>,\n+    expr: &hir::Expr<'_>,\n+    map_args: (&hir::Expr<'_>, &[hir::Expr<'_>]),\n+) {\n+    let var_arg = &map_args.0;\n \n     let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym::Option) {\n         (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n@@ -210,7 +215,7 @@ fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr\n     } else {\n         return;\n     };\n-    let fn_arg = &map_args[1];\n+    let fn_arg = &map_args.1[0];\n \n     if is_unit_function(cx, fn_arg) {\n         let mut applicability = Applicability::MachineApplicable;"}, {"sha": "8588ab1ed8db781d159aa74363f4eddbf8642562", "filename": "clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n             };\n \n         if_chain! {\n-            if let ExprKind::MethodCall(ok_path, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let ExprKind::MethodCall(ok_path, result_types_0, ..) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n             if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() method use std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::Result);"}, {"sha": "1e80b6cf2d838ecf4d6c64d8fcb353ed214b0d0e", "filename": "clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -48,7 +48,7 @@ struct MatchExprVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for MatchExprVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n         match ex.kind {\n-            ExprKind::MethodCall(segment, [receiver], _) if self.case_altered(segment.ident.as_str(), receiver) => {},\n+            ExprKind::MethodCall(segment, receiver, [], _) if self.case_altered(segment.ident.as_str(), receiver) => {},\n             _ => walk_expr(self, ex),\n         }\n     }"}, {"sha": "f7443471e31dda274d656766223512c64de39ccb", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -120,7 +120,7 @@ fn find_sugg_for_if_let<'tcx>(\n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {\n         if keyword == \"while\";\n-        if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n+        if let ExprKind::MethodCall(method_path, ..) = let_expr.kind;\n         if method_path.ident.name == sym::next;\n         if is_trait_method(cx, let_expr, sym::Iterator);\n         then {"}, {"sha": "86a9df034979be06feb7484f112acf00b2f9529a", "filename": "clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n         self.is_chain_end = false;\n \n         match ex.kind {\n-            ExprKind::MethodCall(_, [ref expr, ..], _) => {\n+            ExprKind::MethodCall(_, expr, ..) => {\n                 self.visit_expr(expr);\n             }\n             ExprKind::Binary(_, left, right) => {\n@@ -331,8 +331,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n             ExprKind::Index(..) |\n             ExprKind::Ret(..) |\n             ExprKind::Repeat(..) |\n-            ExprKind::Yield(..) |\n-            ExprKind::MethodCall(..) => walk_expr(self, ex),\n+            ExprKind::Yield(..) => walk_expr(self, ex),\n             ExprKind::AddrOf(_, _, _) |\n             ExprKind::Block(_, _) |\n             ExprKind::Break(_, _) |"}, {"sha": "fef90f6eba49525eb5c0f827aee1e823d97808df", "filename": "clippy_lints/src/methods/bytecount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -42,11 +42,11 @@ pub(super) fn check<'tcx>(\n         if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n         if !is_local_used(cx, needle, arg_id);\n         then {\n-            let haystack = if let ExprKind::MethodCall(path, args, _) =\n+            let haystack = if let ExprKind::MethodCall(path, receiver, [], _) =\n                     filter_recv.kind {\n                 let p = path.ident.name;\n-                if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n-                    &args[0]\n+                if p == sym::iter || p == sym!(iter_mut) {\n+                    receiver\n                 } else {\n                     filter_recv\n                 }"}, {"sha": "51aec21527a7116e8d253911e12611ba829af055", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check(\n         if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n+            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0].0).peel_refs();\n \n             if *self_ty.kind() != ty::Str {\n                 return false;\n@@ -37,7 +37,7 @@ pub(super) fn check(\n                 \"like this\",\n                 format!(\"{}{}.{}({})\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0].0.span, \"..\", &mut applicability),\n                         suggest,\n                         snippet_with_applicability(cx, arg_char.span, \"..\", &mut applicability)),\n                 applicability,"}, {"sha": "b85bfec2b12ba33de410c2902678864a1fdc0f50", "filename": "clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n                 \"like this\",\n                 format!(\"{}{}.{}('{}')\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0].0.span, \"..\", &mut applicability),\n                         suggest,\n                         c.escape_default()),\n                 applicability,"}, {"sha": "9ae6297ec2f67e05d17a3ec0021fdb576e8a134b", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -14,9 +14,15 @@ use super::CLONE_ON_COPY;\n \n /// Checks for the `CLONE_ON_COPY` lint.\n #[allow(clippy::too_many_lines)]\n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol, args: &[Expr<'_>]) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &Expr<'_>,\n+    args: &[Expr<'_>],\n+) {\n     let arg = match args {\n-        [arg] if method_name == sym::clone => arg,\n+        [] if method_name == sym::clone => receiver,\n         _ => return,\n     };\n     if cx\n@@ -81,7 +87,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                 // &*x is a nop, &x.clone() is not\n                 ExprKind::AddrOf(..) => return,\n                 // (*x).func() is useless, x.clone().func() can work in case func borrows self\n-                ExprKind::MethodCall(_, [self_arg, ..], _)\n+                ExprKind::MethodCall(_, self_arg, ..)\n                     if expr.hir_id == self_arg.hir_id && ty != cx.typeck_results().expr_ty_adjusted(expr) =>\n                 {\n                     return;\n@@ -91,7 +97,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                     hir_callee.kind,\n                     ExprKind::Path(QPath::LangItem(rustc_hir::LangItem::TryTraitBranch, _, _))\n                 ),\n-                ExprKind::MethodCall(_, [self_arg, ..], _) if expr.hir_id == self_arg.hir_id => true,\n+                ExprKind::MethodCall(_, self_arg, ..) if expr.hir_id == self_arg.hir_id => true,\n                 ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n                 | ExprKind::Field(..)\n                 | ExprKind::Index(..) => true,"}, {"sha": "7098d564cfc8980d448668c7b2cdb047635d72c0", "filename": "clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -10,11 +10,17 @@ use rustc_span::symbol::{sym, Symbol};\n \n use super::CLONE_ON_REF_PTR;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n-    if !(args.len() == 1 && method_name == sym::clone) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n+    if !(args.is_empty() && method_name == sym::clone) {\n         return;\n     }\n-    let arg = &args[0];\n+    let arg = receiver;\n     let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n \n     if let ty::Adt(_, subst) = obj_ty.kind() {"}, {"sha": "501646863fe156c4fab56cc8452f2e23cf7e65f9", "filename": "clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n         // If the parent node's `to` argument is the same as the `to` argument\n         // of the last replace call in the current chain, don't lint as it was already linted\n         if let Some(parent) = get_parent_expr(cx, expr)\n-            && let Some((\"replace\", [_, current_from, current_to], _)) = method_call(parent)\n+            && let Some((\"replace\", _, [current_from, current_to], _)) = method_call(parent)\n             && eq_expr_value(cx, to, current_to)\n             && from_kind == cx.typeck_results().expr_ty(current_from).peel_refs().kind()\n         {\n@@ -48,7 +48,7 @@ fn collect_replace_calls<'tcx>(\n     let mut from_args = VecDeque::new();\n \n     let _: Option<()> = for_each_expr(expr, |e| {\n-        if let Some((\"replace\", [_, from, to], _)) = method_call(e) {\n+        if let Some((\"replace\", _, [from, to], _)) = method_call(e) {\n             if eq_expr_value(cx, to_arg, to) && cx.typeck_results().expr_ty(from).peel_refs().is_char() {\n                 methods.push_front(e);\n                 from_args.push_front(from);\n@@ -78,7 +78,7 @@ fn check_consecutive_replace_calls<'tcx>(\n         .collect();\n     let app = Applicability::MachineApplicable;\n     let earliest_replace_call = replace_methods.methods.front().unwrap();\n-    if let Some((_, [..], span_lo)) = method_call(earliest_replace_call) {\n+    if let Some((_, _, [..], span_lo)) = method_call(earliest_replace_call) {\n         span_lint_and_sugg(\n             cx,\n             COLLAPSIBLE_STR_REPLACE,"}, {"sha": "bd846d71d4668ed29288ea248849193432903462", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -19,6 +19,7 @@ pub(super) fn check<'tcx>(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n+    receiver: &'tcx hir::Expr<'tcx>,\n     args: &'tcx [hir::Expr<'tcx>],\n ) {\n     // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n@@ -28,16 +29,13 @@ pub(super) fn check<'tcx>(\n         loop {\n             arg_root = match &arg_root.kind {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n-                hir::ExprKind::MethodCall(method_name, call_args, _) => {\n-                    if call_args.len() == 1\n-                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym::as_ref)\n-                        && {\n-                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n-                            let base_type = arg_type.peel_refs();\n-                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::String)\n-                        }\n-                    {\n-                        &call_args[0]\n+                hir::ExprKind::MethodCall(method_name, receiver, [], ..) => {\n+                    if (method_name.ident.name == sym::as_str || method_name.ident.name == sym::as_ref) && {\n+                        let arg_type = cx.typeck_results().expr_ty(receiver);\n+                        let base_type = arg_type.peel_refs();\n+                        *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::String)\n+                    } {\n+                        receiver\n                     } else {\n                         break;\n                     }\n@@ -114,11 +112,11 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].kind) {\n+    if args.len() != 1 || name != \"expect\" || !is_call(&args[0].kind) {\n         return;\n     }\n \n-    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let receiver_type = cx.typeck_results().expr_ty_adjusted(receiver);\n     let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::Option) {\n         \"||\"\n     } else if is_type_diagnostic_item(cx, receiver_type, sym::Result) {\n@@ -127,7 +125,7 @@ pub(super) fn check<'tcx>(\n         return;\n     };\n \n-    let arg_root = get_arg_root(cx, &args[1]);\n+    let arg_root = get_arg_root(cx, &args[0]);\n \n     let span_replace_word = method_span.with_hi(expr.span.hi());\n "}, {"sha": "37b28463527cc5c3bcfe01233a19770ed0f6fe76", "filename": "clippy_lints/src/methods/extend_with_drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n     if_chain! {\n         if is_type_diagnostic_item(cx, ty, sym::Vec);\n         //check source object\n-        if let ExprKind::MethodCall(src_method, [drain_vec, drain_arg], _) = &arg.kind;\n+        if let ExprKind::MethodCall(src_method, drain_vec, [drain_arg], _) = &arg.kind;\n         if src_method.ident.as_str() == \"drain\";\n         let src_ty = cx.typeck_results().expr_ty(drain_vec);\n         //check if actual src type is mutable for code suggestion"}, {"sha": "9dc839afc6256e8c9b89d8d51d3e8fd1c74f9543", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -28,11 +28,11 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n             let closure_expr = peel_blocks(&body.value);\n             let arg_id = body.params[0].pat.hir_id;\n             match closure_expr.kind {\n-                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, args, _) => {\n+                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, receiver, ..) => {\n                     if_chain! {\n                     if ident.name == method_name;\n-                    if let hir::ExprKind::Path(path) = &args[0].kind;\n-                    if let Res::Local(ref local) = cx.qpath_res(path, args[0].hir_id);\n+                    if let hir::ExprKind::Path(path) = &receiver.kind;\n+                    if let Res::Local(ref local) = cx.qpath_res(path, receiver.hir_id);\n                     then {\n                         return arg_id == *local\n                     }\n@@ -106,7 +106,7 @@ pub(super) fn check<'tcx>(\n             };\n             // closure ends with is_some() or is_ok()\n             if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n-            if let ExprKind::MethodCall(path, [filter_arg], _) = filter_body.value.kind;\n+            if let ExprKind::MethodCall(path, filter_arg, [], _) = filter_body.value.kind;\n             if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).peel_refs().ty_adt_def();\n             if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did()) {\n                 Some(false)\n@@ -123,13 +123,13 @@ pub(super) fn check<'tcx>(\n             if let [map_param] = map_body.params;\n             if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n             // closure ends with expect() or unwrap()\n-            if let ExprKind::MethodCall(seg, [map_arg, ..], _) = map_body.value.kind;\n+            if let ExprKind::MethodCall(seg, map_arg, ..) = map_body.value.kind;\n             if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n \n             // .filter(..).map(|y| f(y).copied().unwrap())\n             //                     ~~~~\n             let map_arg_peeled = match map_arg.kind {\n-                ExprKind::MethodCall(method, [original_arg], _) if acceptable_methods(method) => {\n+                ExprKind::MethodCall(method, original_arg, [], _) if acceptable_methods(method) => {\n                     original_arg\n                 },\n                 _ => map_arg,"}, {"sha": "02aada87202c26cd2afb3d744e0f304850c7d1c1", "filename": "clippy_lints/src/methods/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n     ) = arg.kind\n \n         // LHS of subtraction is \"x.len()\"\n-        && let ExprKind::MethodCall(lhs_path, [lhs_recv], _) = &lhs.kind\n+        && let ExprKind::MethodCall(lhs_path, lhs_recv, [], _) = &lhs.kind\n         && lhs_path.ident.name == sym::len\n \n         // RHS of subtraction is 1"}, {"sha": "e1c9b5248a8a4f912c434a6f1a8886d9e59b7dcd", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -12,13 +12,19 @@ use rustc_span::symbol::{sym, Symbol};\n use super::INEFFICIENT_TO_STRING;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+pub fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n     if_chain! {\n-        if args.len() == 1 && method_name == sym::to_string;\n+        if args.is_empty() && method_name == sym::to_string;\n         if let Some(to_string_meth_did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);\n         if let Some(substs) = cx.typeck_results().node_substs_opt(expr.hir_id);\n-        let arg_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+        let arg_ty = cx.typeck_results().expr_ty_adjusted(receiver);\n         let self_ty = substs.type_at(0);\n         let (deref_self_ty, deref_count) = walk_ptrs_ty_depth(self_ty);\n         if deref_count >= 1;\n@@ -35,7 +41,7 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n                         self_ty, deref_self_ty\n                     ));\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let arg_snippet = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n+                    let arg_snippet = snippet_with_applicability(cx, receiver.span, \"..\", &mut applicability);\n                     diag.span_suggestion(\n                         expr.span,\n                         \"try dereferencing the receiver\","}, {"sha": "11e76841e9f054425257442a1e2f7e825d7f21d1", "filename": "clippy_lints/src/methods/into_iter_on_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -16,9 +16,9 @@ pub(super) fn check(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     method_name: Symbol,\n-    args: &[hir::Expr<'_>],\n+    receiver: &hir::Expr<'_>,\n ) {\n-    let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let self_ty = cx.typeck_results().expr_ty_adjusted(receiver);\n     if_chain! {\n         if let ty::Ref(..) = self_ty.kind();\n         if method_name == sym::into_iter;"}, {"sha": "a669cbbbcc602c77c4fc59c6bad177892751111f", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -35,7 +35,7 @@ fn is_full_range(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -\n         && range.end.map_or(true, |e| {\n             if range.limits == RangeLimits::HalfOpen\n                 && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n-                && let ExprKind::MethodCall(name, [self_arg], _) = e.kind\n+                && let ExprKind::MethodCall(name, self_arg, [], _) = e.kind\n                 && name.ident.name == sym::len\n                 && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n             {"}, {"sha": "e04bb1c50792f4674f9c9bfd8512369c0f8703c1", "filename": "clippy_lints/src/methods/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -48,7 +48,7 @@ pub(super) fn check<'tcx>(\n                                 }\n                             }\n                         },\n-                        hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n+                        hir::ExprKind::MethodCall(method, obj, [], _) => if_chain! {\n                             if ident_eq(name, obj) && method.ident.name == sym::clone;\n                             if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n                             if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);"}, {"sha": "16fdd36c0260b25beb0231423a64106850774ea4", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -3161,11 +3161,13 @@ impl_lint_pass!(Methods => [\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n-fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx str, &'tcx [hir::Expr<'tcx>], Span)> {\n-    if let ExprKind::MethodCall(path, args, _) = recv.kind {\n-        if !args.iter().any(|e| e.span.from_expansion()) {\n+fn method_call<'tcx>(\n+    recv: &'tcx hir::Expr<'tcx>,\n+) -> Option<(&'tcx str, &'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>], Span)> {\n+    if let ExprKind::MethodCall(path, receiver, args, _) = recv.kind {\n+        if !args.iter().any(|e| e.span.from_expansion()) && !receiver.span.from_expansion() {\n             let name = path.ident.name.as_str();\n-            return Some((name, args, path.ident.span));\n+            return Some((name, receiver, args, path.ident.span));\n         }\n     }\n     None\n@@ -3183,17 +3185,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             hir::ExprKind::Call(func, args) => {\n                 from_iter_instead_of_collect::check(cx, expr, args, func);\n             },\n-            hir::ExprKind::MethodCall(method_call, args, _) => {\n+            hir::ExprKind::MethodCall(method_call, receiver, args, _) => {\n                 let method_span = method_call.ident.span;\n-                or_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), args);\n-                expect_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), args);\n-                clone_on_copy::check(cx, expr, method_call.ident.name, args);\n-                clone_on_ref_ptr::check(cx, expr, method_call.ident.name, args);\n-                inefficient_to_string::check(cx, expr, method_call.ident.name, args);\n-                single_char_add_str::check(cx, expr, args);\n-                into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, args);\n-                single_char_pattern::check(cx, expr, method_call.ident.name, args);\n-                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args, self.msrv);\n+                or_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), receiver, args);\n+                expect_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), receiver, args);\n+                clone_on_copy::check(cx, expr, method_call.ident.name, receiver, args);\n+                clone_on_ref_ptr::check(cx, expr, method_call.ident.name, receiver, args);\n+                inefficient_to_string::check(cx, expr, method_call.ident.name, receiver, args);\n+                single_char_add_str::check(cx, expr, receiver, args);\n+                into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, receiver);\n+                single_char_pattern::check(cx, expr, method_call.ident.name, receiver, args);\n+                unnecessary_to_owned::check(cx, expr, method_call.ident.name, receiver, args, self.msrv);\n             },\n             hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n@@ -3379,7 +3381,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n impl Methods {\n     #[allow(clippy::too_many_lines)]\n     fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n+        if let Some((name, recv, [args @ ..], span)) = method_call(expr) {\n             match (name, args) {\n                 (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                     zst_offset::check(cx, expr, recv);\n@@ -3399,40 +3401,40 @@ impl Methods {\n                 (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n                 (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, self.msrv),\n                 (\"collect\", []) => match method_call(recv) {\n-                    Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n+                    Some((name @ (\"cloned\" | \"copied\"), recv2, [], _)) => {\n                         iter_cloned_collect::check(cx, name, expr, recv2);\n                     },\n-                    Some((\"map\", [m_recv, m_arg], _)) => {\n+                    Some((\"map\", m_recv, [m_arg], _)) => {\n                         map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n                     },\n-                    Some((\"take\", [take_self_arg, take_arg], _)) => {\n+                    Some((\"take\", take_self_arg, [take_arg], _)) => {\n                         if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n                             manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n                         }\n                     },\n                     _ => {},\n                 },\n                 (\"count\", []) if is_trait_method(cx, expr, sym::Iterator) => match method_call(recv) {\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n-                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n+                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), recv2, [], _)) => {\n                         iter_count::check(cx, expr, recv2, name2);\n                     },\n-                    Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n-                    Some((\"filter\", [recv2, arg], _)) => bytecount::check(cx, expr, recv2, arg),\n-                    Some((\"bytes\", [recv2], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n+                    Some((\"map\", _, [arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    Some((\"filter\", recv2, [arg], _)) => bytecount::check(cx, expr, recv2, arg),\n+                    Some((\"bytes\", recv2, [], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {\n                     iter_with_drain::check(cx, expr, recv, span, arg);\n                 },\n                 (\"ends_with\", [arg]) => {\n-                    if let ExprKind::MethodCall(_, _, span) = expr.kind {\n+                    if let ExprKind::MethodCall(.., span) = expr.kind {\n                         case_sensitive_file_extension_comparisons::check(cx, expr, span, recv, arg);\n                     }\n                 },\n                 (\"expect\", [_]) => match method_call(recv) {\n-                    Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n-                    Some((\"err\", [recv], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n+                    Some((\"ok\", recv, [], _)) => ok_expect::check(cx, expr, recv),\n+                    Some((\"err\", recv, [], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n                     _ => expect_used::check(cx, expr, recv, false, self.allow_expect_in_tests),\n                 },\n                 (\"expect_err\", [_]) => expect_used::check(cx, expr, recv, true, self.allow_expect_in_tests),\n@@ -3452,13 +3454,13 @@ impl Methods {\n                     flat_map_option::check(cx, expr, arg, span);\n                 },\n                 (\"flatten\", []) => match method_call(recv) {\n-                    Some((\"map\", [recv, map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n+                    Some((\"map\", recv, [map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n                     _ => {},\n                 },\n                 (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n                 (\"for_each\", [_]) => {\n-                    if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n+                    if let Some((\"inspect\", _, [_], span2)) = method_call(recv) {\n                         inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n@@ -3478,12 +3480,12 @@ impl Methods {\n                     iter_on_single_or_empty_collections::check(cx, expr, name, recv);\n                 },\n                 (\"join\", [join_arg]) => {\n-                    if let Some((\"collect\", _, span)) = method_call(recv) {\n+                    if let Some((\"collect\", _, _, span)) = method_call(recv) {\n                         unnecessary_join::check(cx, expr, recv, join_arg, span);\n                     }\n                 },\n                 (\"last\", []) | (\"skip\", [_]) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, [args2 @ ..], _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3498,7 +3500,7 @@ impl Methods {\n                     } else {\n                         map_err_ignore::check(cx, expr, m_arg);\n                     }\n-                    if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n+                    if let Some((name, recv2, [args @ ..], span2)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n                             (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n@@ -3518,7 +3520,7 @@ impl Methods {\n                     manual_ok_or::check(cx, expr, recv, def, map);\n                 },\n                 (\"next\", []) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n+                    if let Some((name2, recv2, [args2 @ ..], _)) = method_call(recv) {\n                         match (name2, args2) {\n                             (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n                             (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n@@ -3531,10 +3533,10 @@ impl Methods {\n                     }\n                 },\n                 (\"nth\", [n_arg]) => match method_call(recv) {\n-                    Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n-                    Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n-                    Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                    Some((\"bytes\", recv2, [], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n+                    Some((\"iter\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                    Some((\"iter_mut\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n                     _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n                 },\n                 (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n@@ -3591,7 +3593,7 @@ impl Methods {\n                 },\n                 (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n                 (\"take\", [_arg]) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, [args2 @ ..], _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3614,13 +3616,13 @@ impl Methods {\n                 },\n                 (\"unwrap\", []) => {\n                     match method_call(recv) {\n-                        Some((\"get\", [recv, get_arg], _)) => {\n+                        Some((\"get\", recv, [get_arg], _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, false);\n                         },\n-                        Some((\"get_mut\", [recv, get_arg], _)) => {\n+                        Some((\"get_mut\", recv, [get_arg], _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, true);\n                         },\n-                        Some((\"or\", [recv, or_arg], or_span)) => {\n+                        Some((\"or\", recv, [or_arg], or_span)) => {\n                             or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n                         },\n                         _ => {},\n@@ -3629,27 +3631,27 @@ impl Methods {\n                 },\n                 (\"unwrap_err\", []) => unwrap_used::check(cx, expr, recv, true, self.allow_unwrap_in_tests),\n                 (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n-                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n+                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), lhs, [rhs], _)) => {\n                         manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                     },\n-                    Some((\"map\", [m_recv, m_arg], span)) => {\n+                    Some((\"map\", m_recv, [m_arg], span)) => {\n                         option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n                     },\n-                    Some((\"then_some\", [t_recv, t_arg], _)) => {\n+                    Some((\"then_some\", t_recv, [t_arg], _)) => {\n                         obfuscated_if_else::check(cx, expr, t_recv, t_arg, u_arg);\n                     },\n                     _ => {},\n                 },\n                 (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n-                    Some((\"map\", [recv, map_arg], _))\n+                    Some((\"map\", recv, [map_arg], _))\n                         if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, self.msrv) => {},\n                     _ => {\n                         unwrap_or_else_default::check(cx, expr, recv, u_arg);\n                         unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n                     },\n                 },\n                 (\"zip\", [arg]) => {\n-                    if let ExprKind::MethodCall(name, [iter_recv], _) = recv.kind\n+                    if let ExprKind::MethodCall(name, iter_recv, [], _) = recv.kind\n                         && name.ident.name == sym::iter\n                     {\n                         range_zip_with_len::check(cx, expr, iter_recv, arg);\n@@ -3662,7 +3664,7 @@ impl Methods {\n }\n \n fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n-    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call(recv) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), f_recv, [arg], span)) = method_call(recv) {\n         search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span);\n     }\n }"}, {"sha": "903fa306f935a8e6b005c7c67e6323b6ad706a27", "filename": "clippy_lints/src/methods/open_options.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -36,12 +36,12 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprKind::MethodCall(path, arguments, _) = argument.kind {\n-        let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n+    if let ExprKind::MethodCall(path, receiver, arguments, _) = argument.kind {\n+        let obj_ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n-        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n-            let argument_option = match arguments[1].kind {\n+        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 1 {\n+            let argument_option = match arguments[0].kind {\n                 ExprKind::Lit(ref span) => {\n                     if let Spanned {\n                         node: LitKind::Bool(lit),\n@@ -77,7 +77,7 @@ fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec\n                 _ => (),\n             }\n \n-            get_open_options(cx, &arguments[0], options);\n+            get_open_options(cx, receiver, options);\n         }\n     }\n }"}, {"sha": "81c67b4ca6a59d0816908e88e600eeff66e13e38", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -56,13 +56,12 @@ pub(super) fn check<'tcx>(\n             let closure_expr = peel_blocks(&closure_body.value);\n \n             match &closure_expr.kind {\n-                hir::ExprKind::MethodCall(_, args, _) => {\n+                hir::ExprKind::MethodCall(_, receiver, [], _) => {\n                     if_chain! {\n-                        if args.len() == 1;\n-                        if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);\n+                        if path_to_local_id(receiver, closure_body.params[0].pat.hir_id);\n                         let adj = cx\n                             .typeck_results()\n-                            .expr_adjustments(&args[0])\n+                            .expr_adjustments(receiver)\n                             .iter()\n                             .map(|x| &x.kind)\n                             .collect::<Box<[_]>>();"}, {"sha": "76876d8662936846bb7766db36547df3903900a5", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -20,6 +20,7 @@ pub(super) fn check<'tcx>(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n+    receiver: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],\n ) {\n     /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n@@ -144,7 +145,7 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if let [self_arg, arg] = args {\n+    if let [arg] = args {\n         let inner_arg = if let hir::ExprKind::Block(\n             hir::Block {\n                 stmts: [],\n@@ -163,11 +164,11 @@ pub(super) fn check<'tcx>(\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, arg, or_has_args, expr.span, method_span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };\n-                    check_general_case(cx, name, method_span, self_arg, arg, expr.span, fun_span);\n+                    check_general_case(cx, name, method_span, receiver, arg, expr.span, fun_span);\n                 }\n             },\n             hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n-                check_general_case(cx, name, method_span, self_arg, arg, expr.span, None);\n+                check_general_case(cx, name, method_span, receiver, arg, expr.span, None);\n             },\n             _ => (),\n         }"}, {"sha": "867a3b4023770e6e162bc2227960022866d10cc5", "filename": "clippy_lints/src/methods/range_zip_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'\n         if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n-        if let ExprKind::MethodCall(len_path, [len_recv], _) = end.kind;\n+        if let ExprKind::MethodCall(len_path, len_recv, [], _) = end.kind;\n         if len_path.ident.name == sym::len;\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = recv.kind;"}, {"sha": "81450fd8c6c3c565faa9350ef60f2b868e181e03", "filename": "clippy_lints/src/methods/single_char_add_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -3,12 +3,12 @@ use clippy_utils::{match_def_path, paths};\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n         if match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n-            single_char_push_string::check(cx, expr, args);\n+            single_char_push_string::check(cx, expr, receiver, args);\n         } else if match_def_path(cx, fn_def_id, &paths::INSERT_STR) {\n-            single_char_insert_string::check(cx, expr, args);\n+            single_char_insert_string::check(cx, expr, receiver, args);\n         }\n     }\n }"}, {"sha": "18b6b5be175d14f34ecb22093fc49d354482ce53", "filename": "clippy_lints/src/methods/single_char_insert_string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -8,12 +8,12 @@ use rustc_lint::LateContext;\n use super::SINGLE_CHAR_ADD_STR;\n \n /// lint for length-1 `str`s as argument for `insert_str`\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n-    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[2], &mut applicability) {\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n         let base_string_snippet =\n-            snippet_with_applicability(cx, args[0].span.source_callsite(), \"_\", &mut applicability);\n-        let pos_arg = snippet_with_applicability(cx, args[1].span, \"..\", &mut applicability);\n+            snippet_with_applicability(cx, receiver.span.source_callsite(), \"_\", &mut applicability);\n+        let pos_arg = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n         let sugg = format!(\"{}.insert({}, {})\", base_string_snippet, pos_arg, extension_string);\n         span_lint_and_sugg(\n             cx,"}, {"sha": "4221c52d5cd79a57924fa2b8af6ed4caaf3b8c4a", "filename": "clippy_lints/src/methods/single_char_pattern.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -10,37 +10,43 @@ use rustc_span::symbol::Symbol;\n use super::SINGLE_CHAR_PATTERN;\n \n const PATTERN_METHODS: [(&str, usize); 24] = [\n-    (\"contains\", 1),\n-    (\"starts_with\", 1),\n-    (\"ends_with\", 1),\n-    (\"find\", 1),\n-    (\"rfind\", 1),\n-    (\"split\", 1),\n-    (\"split_inclusive\", 1),\n-    (\"rsplit\", 1),\n-    (\"split_terminator\", 1),\n-    (\"rsplit_terminator\", 1),\n-    (\"splitn\", 2),\n-    (\"rsplitn\", 2),\n-    (\"split_once\", 1),\n-    (\"rsplit_once\", 1),\n-    (\"matches\", 1),\n-    (\"rmatches\", 1),\n-    (\"match_indices\", 1),\n-    (\"rmatch_indices\", 1),\n-    (\"strip_prefix\", 1),\n-    (\"strip_suffix\", 1),\n-    (\"trim_start_matches\", 1),\n-    (\"trim_end_matches\", 1),\n-    (\"replace\", 1),\n-    (\"replacen\", 1),\n+    (\"contains\", 0),\n+    (\"starts_with\", 0),\n+    (\"ends_with\", 0),\n+    (\"find\", 0),\n+    (\"rfind\", 0),\n+    (\"split\", 0),\n+    (\"split_inclusive\", 0),\n+    (\"rsplit\", 0),\n+    (\"split_terminator\", 0),\n+    (\"rsplit_terminator\", 0),\n+    (\"splitn\", 1),\n+    (\"rsplitn\", 1),\n+    (\"split_once\", 0),\n+    (\"rsplit_once\", 0),\n+    (\"matches\", 0),\n+    (\"rmatches\", 0),\n+    (\"match_indices\", 0),\n+    (\"rmatch_indices\", 0),\n+    (\"strip_prefix\", 0),\n+    (\"strip_suffix\", 0),\n+    (\"trim_start_matches\", 0),\n+    (\"trim_end_matches\", 0),\n+    (\"replace\", 0),\n+    (\"replacen\", 0),\n ];\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    _expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n     for &(method, pos) in &PATTERN_METHODS {\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(&args[0]).kind();\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(receiver).kind();\n             if *ty.kind() == ty::Str;\n             if method_name.as_str() == method && args.len() > pos;\n             let arg = &args[pos];"}, {"sha": "9ea6751956abb2c42b1492e917c64eaa36a8617c", "filename": "clippy_lints/src/methods/single_char_push_string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -8,11 +8,11 @@ use rustc_lint::LateContext;\n use super::SINGLE_CHAR_ADD_STR;\n \n /// lint for length-1 `str`s as argument for `push_str`\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n-    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[0], &mut applicability) {\n         let base_string_snippet =\n-            snippet_with_applicability(cx, args[0].span.source_callsite(), \"..\", &mut applicability);\n+            snippet_with_applicability(cx, receiver.span.source_callsite(), \"..\", &mut applicability);\n         let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n         span_lint_and_sugg(\n             cx,"}, {"sha": "8f2f4752514718d2ff8eacb8c650d051b5f7b3ce", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -292,7 +292,7 @@ fn parse_iter_usage<'tcx>(\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, [_, args @ ..], _) = e.kind {\n+            let (name, args) = if let ExprKind::MethodCall(name, _, [args @ ..], _) = e.kind {\n                 (name, args)\n             } else {\n                 return None;\n@@ -327,7 +327,7 @@ fn parse_iter_usage<'tcx>(\n                         } else {\n                             if_chain! {\n                                 if let Some((_, Node::Expr(next_expr))) = iter.next();\n-                                if let ExprKind::MethodCall(next_name, [_], _) = next_expr.kind;\n+                                if let ExprKind::MethodCall(next_name, _, [], _) = next_expr.kind;\n                                 if next_name.ident.name == sym::next;\n                                 if next_expr.span.ctxt() == ctxt;\n                                 if let Some(next_id) = cx.typeck_results().type_dependent_def_id(next_expr.hir_id);\n@@ -367,7 +367,7 @@ fn parse_iter_usage<'tcx>(\n                 }\n             },\n             _ if e.span.ctxt() != ctxt => (None, span),\n-            ExprKind::MethodCall(name, [_], _)\n+            ExprKind::MethodCall(name, _, [], _)\n                 if name.ident.name == sym::unwrap\n                     && cx\n                         .typeck_results()"}, {"sha": "143dcee350521075ee0acd3acd3459107fa02708", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         return;\n     }\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n-        let target = &arglists[0][0];\n+        let target = &arglists[0].0;\n         let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n         let ref_str = if *self_ty.kind() == ty::Str {\n             \"\""}, {"sha": "95138c0e25b034a088447c327bda976b0a15b3e4", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -43,7 +43,7 @@ pub fn check_for_loop_iter(\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             let snippet = if_chain! {\n-                if let ExprKind::MethodCall(maybe_iter_method_name, [collection], _) = receiver.kind;\n+                if let ExprKind::MethodCall(maybe_iter_method_name, collection, [], _) = receiver.kind;\n                 if maybe_iter_method_name.ident.name == sym::iter;\n \n                 if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);"}, {"sha": "a187a8d6016f871325c2d58ca803d19add8ca842", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -54,7 +54,7 @@ pub(super) fn check<'tcx>(\n                 // This is a duplicate of what's happening in clippy_lints::methods::method_call,\n                 // which isn't ideal, We want to get the method call span,\n                 // but prefer to avoid changing the signature of the function itself.\n-                if let hir::ExprKind::MethodCall(_, _, span) = expr.kind {\n+                if let hir::ExprKind::MethodCall(.., span) = expr.kind {\n                     span_lint_and_then(cx, UNNECESSARY_LAZY_EVALUATIONS, expr.span, msg, |diag| {\n                         diag.span_suggestion(\n                             span,"}, {"sha": "6f25acca1de6123e1a08586d8edd57f17fe192d8", "filename": "clippy_lints/src/methods/unnecessary_sort_by.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -50,9 +50,13 @@ fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n-        (ExprKind::MethodCall(left_segment, left_args, _), ExprKind::MethodCall(right_segment, right_args, _)) => {\n+        (\n+            ExprKind::MethodCall(left_segment, left_receiver, left_args, _),\n+            ExprKind::MethodCall(right_segment, right_receiver, right_args, _),\n+        ) => {\n             left_segment.ident == right_segment.ident\n                 && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n+                && mirrored_exprs(left_receiver, a_ident, right_receiver, b_ident)\n         },\n         // Two tuples with mirrored contents\n         (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => {\n@@ -125,7 +129,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Exp\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n-        if let ExprKind::MethodCall(method_path, [left_expr, right_expr], _) = closure_body.value.kind;\n+        if let ExprKind::MethodCall(method_path, left_expr, [right_expr], _) = closure_body.value.kind;\n         if method_path.ident.name == sym::cmp;\n         if is_trait_method(cx, &closure_body.value, sym::Ord);\n         then {"}, {"sha": "9dceb9af2f2234b09673affa472dce6887b57bdf", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -24,12 +24,13 @@ pub fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n     method_name: Symbol,\n-    args: &'tcx [Expr<'tcx>],\n+    receiver: &'tcx Expr<'_>,\n+    args: &'tcx [Expr<'_>],\n     msrv: Option<RustcVersion>,\n ) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-        if let [receiver] = args;\n+        if args.is_empty();\n         then {\n             if is_cloned_or_copied(cx, method_name, method_def_id) {\n                 unnecessary_iter_cloned::check(cx, expr, method_name, receiver);\n@@ -245,9 +246,14 @@ fn check_other_call_arg<'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n-        if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n+        if let Some((callee_def_id, call_substs, call_receiver, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n         let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n-        if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n+        let index = if let Some(call_receiver) = call_receiver {\n+            std::iter::once(call_receiver).chain(call_args.iter()).position(|arg| arg.hir_id == maybe_arg.hir_id)\n+        } else {\n+            call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id)\n+        };\n+        if let Some(i) = index;\n         if let Some(input) = fn_sig.inputs().get(i);\n         let (input, n_refs) = peel_mid_ty_refs(*input);\n         if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n@@ -342,22 +348,22 @@ fn skip_addr_of_ancestors<'tcx>(\n fn get_callee_substs_and_args<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n-) -> Option<(DefId, SubstsRef<'tcx>, &'tcx [Expr<'tcx>])> {\n+) -> Option<(DefId, SubstsRef<'tcx>, Option<&'tcx Expr<'tcx>>, &'tcx [Expr<'tcx>])> {\n     if_chain! {\n         if let ExprKind::Call(callee, args) = expr.kind;\n         let callee_ty = cx.typeck_results().expr_ty(callee);\n         if let ty::FnDef(callee_def_id, _) = callee_ty.kind();\n         then {\n             let substs = cx.typeck_results().node_substs(callee.hir_id);\n-            return Some((*callee_def_id, substs, args));\n+            return Some((*callee_def_id, substs, None, args));\n         }\n     }\n     if_chain! {\n-        if let ExprKind::MethodCall(_, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(_, receiver, args, _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         then {\n             let substs = cx.typeck_results().node_substs(expr.hir_id);\n-            return Some((method_def_id, substs, args));\n+            return Some((method_def_id, substs, Some(receiver), args));\n         }\n     }\n     None"}, {"sha": "ae6b165fdc36650d8517e9d2b1f450a934ecc0b3", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -28,7 +28,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind {\n+    if let hir::ExprKind::MethodCall(path, self_arg, ..) = &expr.kind {\n         if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(self_arg)) {\n             Some(self_arg)\n         } else {\n@@ -139,9 +139,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n                         self.addr_of_exprs.push(parent);\n                         return;\n                     },\n-                    ExprKind::MethodCall(_, args, _) => {\n+                    ExprKind::MethodCall(.., args, _) => {\n                         if_chain! {\n-                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if args.iter().all(|arg| !self.is_binding(arg));\n                             if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n                             let method_ty = self.cx.tcx.type_of(method_def_id);\n                             let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();"}, {"sha": "c618f6b5d92659a0a9564d4297449b669fc98c97", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -75,23 +75,22 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                     .qpath_res(qpath, path.hir_id)\n                     .opt_def_id()\n                     .and_then(|def_id| match cx.tcx.get_diagnostic_name(def_id) {\n-                        Some(sym::cmp_min) => fetch_const(cx, args, MinMax::Min),\n-                        Some(sym::cmp_max) => fetch_const(cx, args, MinMax::Max),\n+                        Some(sym::cmp_min) => fetch_const(cx, None, args, MinMax::Min),\n+                        Some(sym::cmp_max) => fetch_const(cx, None, args, MinMax::Max),\n                         _ => None,\n                     })\n             } else {\n                 None\n             }\n         },\n-        ExprKind::MethodCall(path, args, _) => {\n+        ExprKind::MethodCall(path, receiver, args @ [_], _) => {\n             if_chain! {\n-                if let [obj, _] = args;\n-                if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n+                if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n                 then {\n                     if path.ident.name == sym!(max) {\n-                        fetch_const(cx, args, MinMax::Max)\n+                        fetch_const(cx, Some(receiver), args, MinMax::Max)\n                     } else if path.ident.name == sym!(min) {\n-                        fetch_const(cx, args, MinMax::Min)\n+                        fetch_const(cx, Some(receiver), args, MinMax::Min)\n                     } else {\n                         None\n                     }\n@@ -104,16 +103,26 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n     }\n }\n \n-fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n-    if args.len() != 2 {\n+fn fetch_const<'a>(\n+    cx: &LateContext<'_>,\n+    receiver: Option<&'a Expr<'a>>,\n+    args: &'a [Expr<'a>],\n+    m: MinMax,\n+) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n+    if (receiver.is_some() && args.len() != 1) || (receiver.is_none() && args.len() != 2) {\n         return None;\n     }\n-    constant_simple(cx, cx.typeck_results(), &args[0]).map_or_else(\n-        || constant_simple(cx, cx.typeck_results(), &args[1]).map(|c| (m, c, &args[0])),\n+    let (arg0, arg1) = if let Some(receiver) = receiver {\n+        (receiver, &args[0])\n+    } else {\n+        (&args[0], &args[1])\n+    };\n+    constant_simple(cx, cx.typeck_results(), arg0).map_or_else(\n+        || constant_simple(cx, cx.typeck_results(), arg1).map(|c| (m, c, arg0)),\n         |c| {\n-            if constant_simple(cx, cx.typeck_results(), &args[1]).is_none() {\n+            if constant_simple(cx, cx.typeck_results(), arg1).is_none() {\n                 // otherwise ignore\n-                Some((m, c, &args[1]))\n+                Some((m, c, arg1))\n             } else {\n                 None\n             }"}, {"sha": "82dc03ef5c5bce3c264c505ef9ff5b5075a115b4", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -43,18 +43,24 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                 if let ExprKind::Path(ref path) = fn_expr.kind {\n                     check_arguments(\n                         cx,\n-                        arguments,\n+                        arguments.iter().collect(),\n                         cx.typeck_results().expr_ty(fn_expr),\n                         &rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false)),\n                         \"function\",\n                     );\n                 }\n             },\n-            ExprKind::MethodCall(path, arguments, _) => {\n+            ExprKind::MethodCall(path, receiver, arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.bound_type_of(def_id).subst(cx.tcx, substs);\n-                check_arguments(cx, arguments, method_type, path.ident.as_str(), \"method\");\n+                check_arguments(\n+                    cx,\n+                    std::iter::once(receiver).chain(arguments.iter()).collect(),\n+                    method_type,\n+                    path.ident.as_str(),\n+                    \"method\",\n+                );\n             },\n             _ => (),\n         }\n@@ -63,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n \n fn check_arguments<'tcx>(\n     cx: &LateContext<'tcx>,\n-    arguments: &[Expr<'_>],\n+    arguments: Vec<&Expr<'_>>,\n     type_definition: Ty<'tcx>,\n     name: &str,\n     fn_kind: &str,"}, {"sha": "f8cc3fbb3cdfaeacdcc0332fb432c05586d767eb", "filename": "clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -56,12 +56,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessForEach {\n \n         if_chain! {\n             // Check the method name is `for_each`.\n-            if let ExprKind::MethodCall(method_name, [for_each_recv, for_each_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(method_name, for_each_recv, [for_each_arg], _) = expr.kind;\n             if method_name.ident.name == Symbol::intern(\"for_each\");\n             // Check `for_each` is an associated function of `Iterator`.\n             if is_trait_method(cx, expr, sym::Iterator);\n             // Checks the receiver of `for_each` is also a method call.\n-            if let ExprKind::MethodCall(_, [iter_recv], _) = for_each_recv.kind;\n+            if let ExprKind::MethodCall(_, iter_recv, [], _) = for_each_recv.kind;\n             // Skip the lint if the call chain is too long. e.g. `v.field.iter().for_each()` or\n             // `v.foo().iter().for_each()` must be skipped.\n             if matches!("}, {"sha": "25fb4f0f4cff199ed2aa961faad136b0e533e1d0", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -43,7 +43,7 @@ declare_lint_pass!(NonOctalUnixPermissions => [NON_OCTAL_UNIX_PERMISSIONS]);\n impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         match &expr.kind {\n-            ExprKind::MethodCall(path, [func, param], _) => {\n+            ExprKind::MethodCall(path, func, [param], _) => {\n                 let obj_ty = cx.typeck_results().expr_ty(func).peel_refs();\n \n                 if_chain! {"}, {"sha": "17d5fa2152bbffe438f627e0d41103f9c063df95", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -304,13 +304,13 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                             }\n                             return;\n                         },\n-                        ExprKind::MethodCall(_, args, _)\n+                        ExprKind::MethodCall(_, receiver, args, _)\n                             if typeck.type_dependent_def_id(parent.hir_id).map_or(false, |id| {\n                                 id == param.fn_id\n                                     && has_matching_substs(param.fn_kind, typeck.node_substs(parent.hir_id))\n                             }) =>\n                         {\n-                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                            if let Some(idx) = std::iter::once(receiver).chain(args.iter()).position(|arg| arg.hir_id == child_id) {\n                                 param.uses.push(Usage::new(span, idx));\n                             }\n                             return;"}, {"sha": "638a514ff9b361f7e33e3bc02d86f25e3214688f", "filename": "clippy_lints/src/operators/cmp_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -38,7 +38,7 @@ fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'t\n fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n     let typeck = cx.typeck_results();\n     let (arg, arg_span) = match expr.kind {\n-        ExprKind::MethodCall(.., [arg], _)\n+        ExprKind::MethodCall(_, arg, [], _)\n             if typeck\n                 .type_dependent_def_id(expr.hir_id)\n                 .and_then(|id| cx.tcx.trait_of_item(id))"}, {"sha": "827a2b26709350dc1ad9ceb3f678cca5ab26a82d", "filename": "clippy_lints/src/operators/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -17,7 +17,7 @@ pub(crate) fn check<'tcx>(\n     right: &'tcx Expr<'_>,\n ) {\n     if op == BinOpKind::Div\n-        && let ExprKind::MethodCall(method_path, [self_arg], _) = left.kind\n+        && let ExprKind::MethodCall(method_path, self_arg, [], _) = left.kind\n         && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_arg).peel_refs(), sym::Duration)\n         && let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right)\n     {"}, {"sha": "97ddcdb24799d12ac2a73d9202a2b724b6249fb4", "filename": "clippy_lints/src/operators/float_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -113,7 +113,7 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, self_arg, ..) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)"}, {"sha": "63c9faf0396fd3d8ffdd6a610113147827b552df", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -591,8 +591,11 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             set_skip_flag();\n                         }\n                     },\n-                    ExprKind::MethodCall(name, expr_args @ [self_arg, ..], _) => {\n-                        let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n+                    ExprKind::MethodCall(name, self_arg, expr_args, _) => {\n+                        let i = std::iter::once(self_arg)\n+                            .chain(expr_args.iter())\n+                            .position(|arg| arg.hir_id == child_id)\n+                            .unwrap_or(0);\n                         if i == 0 {\n                             // Check if the method can be renamed.\n                             let name = name.ident.as_str();"}, {"sha": "4dc65da3ea1fd9fd8227823a0ce416c6c573a466", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -93,7 +93,7 @@ fn expr_as_ptr_offset_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n-    if let ExprKind::MethodCall(path_segment, [arg_0, arg_1, ..], _) = &expr.kind {\n+    if let ExprKind::MethodCall(path_segment, arg_0, [arg_1, ..], _) = &expr.kind {\n         if is_expr_ty_raw_ptr(cx, arg_0) {\n             if path_segment.ident.name == sym::offset {\n                 return Some((arg_0, arg_1, Method::Offset));"}, {"sha": "6fddbd419bcd83eb48d0a32c04214dfdf5edf345", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -86,7 +86,7 @@ fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Ex\n     if_chain! {\n         if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n         if !is_else_clause(cx.tcx, expr);\n-        if let ExprKind::MethodCall(segment, [caller, ..], _) = &cond.kind;\n+        if let ExprKind::MethodCall(segment, caller, ..) = &cond.kind;\n         let caller_ty = cx.typeck_results().expr_ty(caller);\n         let if_block = IfBlockType::IfIs(caller, caller_ty, segment.ident.name, then, r#else);\n         if is_early_return(sym::Option, cx, &if_block) || is_early_return(sym::Result, cx, &if_block);"}, {"sha": "94dec191103c587d02a2bc8501cfc0ac02cc0bb1", "filename": "clippy_lints/src/read_zero_byte_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for ReadZeroByteVec {\n                 // finds use of `_.read(&mut v)`\n                 let mut read_found = false;\n                 let mut visitor = expr_visitor_no_bodies(|expr| {\n-                    if let ExprKind::MethodCall(path, [_self, arg], _) = expr.kind\n+                    if let ExprKind::MethodCall(path, _self, [arg], _) = expr.kind\n                         && let PathSegment { ident: read_or_read_exact, .. } = *path\n                         && matches!(read_or_read_exact.as_str(), \"read\" | \"read_exact\")\n                         && let ExprKind::AddrOf(_, hir::Mutability::Mut, inner) = arg.kind"}, {"sha": "ac4e29e9dfdfa0f5d5c95b93b2b6883284aeb757", "filename": "clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -108,7 +108,7 @@ fn get_pointee_ty_and_count_expr<'tcx>(\n     };\n     if_chain! {\n         // Find calls to copy_{from,to}{,_nonoverlapping} and write_bytes methods\n-        if let ExprKind::MethodCall(method_path, [ptr_self, .., count], _) = expr.kind;\n+        if let ExprKind::MethodCall(method_path, ptr_self, [.., count], _) = expr.kind;\n         let method_ident = method_path.ident.as_str();\n         if METHODS.iter().any(|m| *m == method_ident);\n "}, {"sha": "b35782184670320ebbdb796bc5eaf2464f4eb66a", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, [self_arg, extend_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, [extend_arg], _) = expr.kind;\n             if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(extend);\n             if self.is_repeat_take(extend_arg);\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Checks if the given expression is resizing a vector with 0\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if self.initialization_found\n-            && let ExprKind::MethodCall(path, [self_arg, len_arg, fill_arg], _) = expr.kind\n+            && let ExprKind::MethodCall(path, self_arg, [len_arg, fill_arg], _) = expr.kind\n             && path_to_local_id(self_arg, self.vec_alloc.local_id)\n             && path.ident.name == sym!(resize)\n             // Check that is filled with 0\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n                 // Check that len expression is equals to `with_capacity` expression\n                 if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n                     self.slow_expression = Some(InitializationType::Resize(expr));\n-                } else if let ExprKind::MethodCall(path, _, _) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n+                } else if let ExprKind::MethodCall(path, ..) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n                     self.slow_expression = Some(InitializationType::Resize(expr));\n                 }\n             }\n@@ -233,15 +233,15 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if give expression is `repeat(0).take(...)`\n     fn is_repeat_take(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::MethodCall(take_path, [recv, len_arg, ..], _) = expr.kind;\n+            if let ExprKind::MethodCall(take_path, recv, [len_arg, ..], _) = expr.kind;\n             if take_path.ident.name == sym!(take);\n             // Check that take is applied to `repeat(0)`\n             if self.is_repeat_zero(recv);\n             then {\n                 // Check that len expression is equals to `with_capacity` expression\n                 if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n                     return true;\n-                } else if let ExprKind::MethodCall(path, _, _) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n+                } else if let ExprKind::MethodCall(path, ..) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n                     return true;\n                 }\n             }"}, {"sha": "662d399ca538a6918a07b3a69d14996ca1febc6d", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -262,15 +262,15 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n             let (method_names, expressions, _) = method_calls(left, 1);\n             if method_names.len() == 1;\n             if expressions.len() == 1;\n-            if expressions[0].len() == 1;\n+            if expressions[0].1.is_empty();\n             if method_names[0] == sym!(as_bytes);\n \n             // Check for slicer\n             if let ExprKind::Struct(QPath::LangItem(LangItem::Range, ..), _, _) = right.kind;\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let string_expression = &expressions[0][0];\n+                let string_expression = &expressions[0].0;\n \n                 let snippet_app = snippet_with_applicability(\n                     cx,\n@@ -291,12 +291,12 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, args, _) = &e.kind;\n+            if let ExprKind::MethodCall(path, receiver, ..) = &e.kind;\n             if path.ident.name == sym!(as_bytes);\n-            if let ExprKind::Lit(lit) = &args[0].kind;\n+            if let ExprKind::Lit(lit) = &receiver.kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;\n             then {\n-                let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n+                let callsite = snippet(cx, receiver.span.source_callsite(), r#\"\"foo\"\"#);\n                 let mut applicability = Applicability::MachineApplicable;\n                 if callsite.starts_with(\"include_str!\") {\n                     span_lint_and_sugg(\n@@ -305,7 +305,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                         e.span,\n                         \"calling `as_bytes()` on `include_str!(..)`\",\n                         \"consider using `include_bytes!(..)` instead\",\n-                        snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n+                        snippet_with_applicability(cx, receiver.span, r#\"\"foo\"\"#, &mut applicability).replacen(\n                             \"include_str\",\n                             \"include_bytes\",\n                             1,\n@@ -314,7 +314,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                     );\n                 } else if lit_content.as_str().is_ascii()\n                     && lit_content.as_str().len() <= MAX_LENGTH_BYTE_STRING_LIT\n-                    && !args[0].span.from_expansion()\n+                    && !receiver.span.from_expansion()\n                 {\n                     span_lint_and_sugg(\n                         cx,\n@@ -324,7 +324,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                         \"consider using a byte string literal instead\",\n                         format!(\n                             \"b{}\",\n-                            snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n+                            snippet_with_applicability(cx, receiver.span, r#\"\"foo\"\"#, &mut applicability)\n                         ),\n                         applicability,\n                     );\n@@ -333,9 +333,9 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, [recv], _) = &e.kind;\n+            if let ExprKind::MethodCall(path, recv, [], _) = &e.kind;\n             if path.ident.name == sym!(into_bytes);\n-            if let ExprKind::MethodCall(path, [recv], _) = &recv.kind;\n+            if let ExprKind::MethodCall(path, recv, [], _) = &recv.kind;\n             if matches!(path.ident.name.as_str(), \"to_owned\" | \"to_string\");\n             if let ExprKind::Lit(lit) = &recv.kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;\n@@ -393,7 +393,7 @@ declare_lint_pass!(StrToString => [STR_TO_STRING]);\n impl<'tcx> LateLintPass<'tcx> for StrToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n             if path.ident.name == sym::to_string;\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, ty, ..) = ty.kind();\n@@ -443,7 +443,7 @@ declare_lint_pass!(StringToString => [STRING_TO_STRING]);\n impl<'tcx> LateLintPass<'tcx> for StringToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n             if path.ident.name == sym::to_string;\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if is_type_diagnostic_item(cx, ty, sym::String);\n@@ -487,11 +487,11 @@ impl<'tcx> LateLintPass<'tcx> for TrimSplitWhitespace {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         let tyckres = cx.typeck_results();\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [split_recv], split_ws_span) = expr.kind;\n+            if let ExprKind::MethodCall(path, split_recv, [], split_ws_span) = expr.kind;\n             if path.ident.name == sym!(split_whitespace);\n             if let Some(split_ws_def_id) = tyckres.type_dependent_def_id(expr.hir_id);\n             if cx.tcx.is_diagnostic_item(sym::str_split_whitespace, split_ws_def_id);\n-            if let ExprKind::MethodCall(path, [_trim_recv], trim_span) = split_recv.kind;\n+            if let ExprKind::MethodCall(path, _trim_recv, [], trim_span) = split_recv.kind;\n             if let trim_fn_name @ (\"trim\" | \"trim_start\" | \"trim_end\") = path.ident.name.as_str();\n             if let Some(trim_def_id) = tyckres.type_dependent_def_id(split_recv.hir_id);\n             if is_one_of_trim_diagnostic_items(cx, trim_def_id);"}, {"sha": "78403d9fdb7e6f17a81b1f4069105878369d0e9b", "filename": "clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n             if let ExprKind::Path(path) = &func.kind;\n             if let Some(did) = cx.qpath_res(path, func.hir_id).opt_def_id();\n             if match_libc_symbol(cx, did, \"strlen\");\n-            if let ExprKind::MethodCall(path, [self_arg], _) = recv.kind;\n+            if let ExprKind::MethodCall(path, self_arg, [], _) = recv.kind;\n             if !recv.span.from_expansion();\n             if path.ident.name == sym::as_ptr;\n             then {"}, {"sha": "651201f34ed28d46471e08ff6b2a9610679d2ad9", "filename": "clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -39,27 +39,25 @@ declare_lint_pass!(ToDigitIsSome => [TO_DIGIT_IS_SOME]);\n impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(is_some_path, is_some_args, _) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(is_some_path, to_digit_expr, [], _) = &expr.kind;\n             if is_some_path.ident.name.as_str() == \"is_some\";\n-            if let [to_digit_expr] = &**is_some_args;\n             then {\n                 let match_result = match &to_digit_expr.kind {\n-                    hir::ExprKind::MethodCall(to_digits_path, to_digit_args, _) => {\n+                    hir::ExprKind::MethodCall(to_digits_path, char_arg, [radix_arg], _) => {\n                         if_chain! {\n-                            if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";\n                             let char_arg_ty = cx.typeck_results().expr_ty_adjusted(char_arg);\n                             if *char_arg_ty.kind() == ty::Char;\n                             then {\n-                                Some((true, char_arg, radix_arg))\n+                                Some((true, *char_arg, radix_arg))\n                             } else {\n                                 None\n                             }\n                         }\n                     }\n                     hir::ExprKind::Call(to_digits_call, to_digit_args) => {\n                         if_chain! {\n-                            if let [char_arg, radix_arg] = &**to_digit_args;\n+                            if let [char_arg, radix_arg] = *to_digit_args;\n                             if let hir::ExprKind::Path(to_digits_path) = &to_digits_call.kind;\n                             if let to_digits_call_res = cx.qpath_res(to_digits_path, to_digits_call.hir_id);\n                             if let Some(to_digits_def_id) = to_digits_call_res.opt_def_id();"}, {"sha": "3f99bd3f31567c43592b9e2301557857096f65e7", "filename": "clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funinit_vec.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -177,7 +177,7 @@ fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt\n                     });\n                 }\n             },\n-            ExprKind::MethodCall(path, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n+            ExprKind::MethodCall(path, self_expr, [_], _) if is_reserve(cx, path, self_expr) => {\n                 return Some(TargetVec {\n                     location: VecLocation::Expr(self_expr),\n                     init_kind: None,\n@@ -211,7 +211,7 @@ fn extract_set_len_self<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Opt\n         }\n     });\n     match expr.kind {\n-        ExprKind::MethodCall(path, [self_expr, _], _) => {\n+        ExprKind::MethodCall(path, self_expr, [_], _) => {\n             let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n             if is_type_diagnostic_item(cx, self_type, sym::Vec) && path.ident.name.as_str() == \"set_len\" {\n                 Some((self_expr, expr.span))"}, {"sha": "851eef7b332417658b090489fa968aa0850923f4", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -144,8 +144,9 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n \n impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::MethodCall(_, args, _) = expr.kind {\n+        if let ExprKind::MethodCall(_, receiver, args, _) = expr.kind {\n             let arg_indices = get_args_to_check(cx, expr);\n+            let args = std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>();\n             for (i, trait_name) in arg_indices {\n                 if i < args.len() {\n                     match check_arg(cx, &args[i]) {"}, {"sha": "35824b03170afb87e139373715ad3b1caca492e5", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -128,7 +128,7 @@ fn needs_inferred_result_ty(\n     locals_to_check: &mut Vec<HirId>,\n     seen_locals: &mut HirIdSet,\n ) -> bool {\n-    let (id, args) = match e.kind {\n+    let (id, receiver, args) = match e.kind {\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(ref path),\n@@ -137,11 +137,11 @@ fn needs_inferred_result_ty(\n             },\n             args,\n         ) => match cx.qpath_res(path, *hir_id) {\n-            Res::Def(DefKind::AssocFn | DefKind::Fn, id) => (id, args),\n+            Res::Def(DefKind::AssocFn | DefKind::Fn, id) => (id, None, args),\n             _ => return false,\n         },\n-        ExprKind::MethodCall(_, args, _) => match cx.typeck_results().type_dependent_def_id(e.hir_id) {\n-            Some(id) => (id, args),\n+        ExprKind::MethodCall(_, receiver, args, _) => match cx.typeck_results().type_dependent_def_id(e.hir_id) {\n+            Some(id) => (id, Some(receiver), args),\n             None => return false,\n         },\n         ExprKind::Path(QPath::Resolved(None, path)) => {\n@@ -156,6 +156,11 @@ fn needs_inferred_result_ty(\n     };\n     let sig = cx.tcx.fn_sig(id).skip_binder();\n     if let ty::Param(output_ty) = *sig.output().kind() {\n+        let args: Vec<&Expr<'_>> = if let Some(receiver) = receiver {\n+            std::iter::once(receiver).chain(args.iter()).collect()\n+        } else {\n+            args.iter().collect()\n+        };\n         sig.inputs().iter().zip(args).all(|(&ty, arg)| {\n             !ty.is_param(output_ty.index) || each_value_source_needs_inference(cx, arg, locals_to_check, seen_locals)\n         })"}, {"sha": "7ffb53dcf455f371e313cade841426bdeae0fd92", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -30,26 +30,27 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         }\n     }\n \n-    match expr.kind {\n-        ExprKind::Call(_, args) | ExprKind::MethodCall(_, args, _) => {\n-            let args_to_recover = args\n-                .iter()\n-                .filter(|arg| {\n-                    if cx.typeck_results().expr_ty(arg).is_unit() && !utils::is_unit_literal(arg) {\n-                        !matches!(\n-                            &arg.kind,\n-                            ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n-                        )\n-                    } else {\n-                        false\n-                    }\n-                })\n-                .collect::<Vec<_>>();\n-            if !args_to_recover.is_empty() && !is_from_proc_macro(cx, expr) {\n-                lint_unit_args(cx, expr, &args_to_recover);\n+    let args: Vec<_> = match expr.kind {\n+        ExprKind::Call(_, args) => args.iter().collect(),\n+        ExprKind::MethodCall(_, receiver, args, _) => std::iter::once(receiver).chain(args.iter()).collect(),\n+        _ => return,\n+    };\n+\n+    let args_to_recover = args\n+        .into_iter()\n+        .filter(|arg| {\n+            if cx.typeck_results().expr_ty(arg).is_unit() && !utils::is_unit_literal(arg) {\n+                !matches!(\n+                    &arg.kind,\n+                    ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n+                )\n+            } else {\n+                false\n             }\n-        },\n-        _ => (),\n+        })\n+        .collect::<Vec<_>>();\n+    if !args_to_recover.is_empty() && !is_from_proc_macro(cx, expr) {\n+        lint_unit_args(cx, expr, &args_to_recover.as_slice());\n     }\n }\n "}, {"sha": "b38d71784fcfc74475b7f07042267479929aabe8", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n                     check_map_error(cx, res, expr);\n                 }\n             },\n-            hir::ExprKind::MethodCall(path, [ref arg_0, ..], _) => match path.ident.as_str() {\n+            hir::ExprKind::MethodCall(path, arg_0, ..) => match path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_map_error(cx, arg_0, expr);\n                 },\n@@ -94,9 +94,9 @@ fn try_remove_await<'a>(expr: &'a hir::Expr<'a>) -> Option<&hir::Expr<'a>> {\n \n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n-    while let hir::ExprKind::MethodCall(path, args, _) = call.kind {\n+    while let hir::ExprKind::MethodCall(path, receiver, ..) = call.kind {\n         if matches!(path.ident.as_str(), \"or\" | \"or_else\" | \"ok\") {\n-            call = &args[0];\n+            call = receiver;\n         } else {\n             break;\n         }\n@@ -110,7 +110,7 @@ fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<\n }\n \n fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>, is_await: bool) {\n-    if let hir::ExprKind::MethodCall(path, _, _) = call.kind {\n+    if let hir::ExprKind::MethodCall(path, ..) = call.kind {\n         let symbol = path.ident.as_str();\n         let read_trait = if is_await {\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)"}, {"sha": "7fbfecf96ec3dafdbf5113a87222709144417b68", "filename": "clippy_lints/src/unused_peekable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_peekable.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -149,7 +149,8 @@ impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n                                     ident: method_name_ident,\n                                     ..\n                                 },\n-                                [self_arg, remaining_args @ ..],\n+                                self_arg,\n+                                [remaining_args @ ..],\n                                 _,\n                             ) => {\n                                 let method_name = method_name_ident.name.as_str();"}, {"sha": "9092156be150a30634c382add42dd2fcc6a5e1e1", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -154,13 +154,13 @@ fn collect_unwrap_info<'tcx>(\n         return collect_unwrap_info(cx, if_expr, expr, branch, !invert, false);\n     } else {\n         if_chain! {\n-            if let ExprKind::MethodCall(method_name, args, _) = &expr.kind;\n-            if let Some(local_id) = path_to_local(&args[0]);\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            if let ExprKind::MethodCall(method_name, receiver, args, _) = &expr.kind;\n+            if let Some(local_id) = path_to_local(receiver);\n+            let ty = cx.typeck_results().expr_ty(receiver);\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, name) || is_relevant_result_call(cx, ty, name);\n             then {\n-                assert!(args.len() == 1);\n+                assert!(args.len() == 0);\n                 let unwrappable = match name {\n                     \"is_some\" | \"is_ok\" => true,\n                     \"is_err\" | \"is_none\" => false,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(method_name, [self_arg, ..], _) = expr.kind;\n+                if let ExprKind::MethodCall(method_name, self_arg, ..) = expr.kind;\n                 if let Some(id) = path_to_local(self_arg);\n                 if [sym::unwrap, sym::expect, sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = [sym::unwrap, sym::expect].contains(&method_name.ident.name);"}, {"sha": "b3ca15f7648bc082bdb8ea71694d65631c9c6200", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         // check for `expect`\n         if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n             {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n             {"}, {"sha": "f1b6463ad0f7c62a375aa8cfad9f7a086729cf19", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 }\n             },\n \n-            ExprKind::MethodCall(name, .., [recv, ..], _) => {\n+            ExprKind::MethodCall(name, recv, ..) => {\n                 if is_trait_method(cx, e, sym::Into) && name.ident.as_str() == \"into\" {\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(recv);"}, {"sha": "fec4ee93e7bce47573743a006cd5f0661ad8ccd8", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -402,10 +402,11 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 self.expr(func);\n                 self.slice(args, |e| self.expr(e));\n             },\n-            ExprKind::MethodCall(method_name, args, _) => {\n-                bind!(self, method_name, args);\n-                kind!(\"MethodCall({method_name}, {args}, _)\");\n+            ExprKind::MethodCall(method_name, receiver, args, _) => {\n+                bind!(self, method_name, receiver, args);\n+                kind!(\"MethodCall({method_name}, {receiver}, {args}, _)\");\n                 self.ident(field!(method_name.ident));\n+                self.expr(receiver);\n                 self.slice(args, |e| self.expr(e));\n             },\n             ExprKind::Tup(elements) => {"}, {"sha": "ae1c11ef83c31cab317d5702cdacd8082c4100d2", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -687,7 +687,7 @@ impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n             if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n             let args = arg_lists[1];\n             if args.len() == 1;\n-            let self_arg = &args[0];\n+            let self_arg = &args.0;\n             let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n             if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n             then {"}, {"sha": "542c6a37d567bb09e9bad4433bcaaae15abf79b0", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -100,7 +100,7 @@ impl VecPushSearcher {\n                         || get_parent_expr(cx, last_place)\n                             .map_or(false, |e| matches!(e.kind, ExprKind::AddrOf(_, Mutability::Mut, _)));\n                 },\n-                ExprKind::MethodCall(_, [recv, ..], _)\n+                ExprKind::MethodCall(_, recv, ..)\n                     if recv.hir_id == e.hir_id\n                         && adjusted_mut == Mutability::Mut\n                         && !adjusted_ty.peel_refs().is_slice() =>\n@@ -201,7 +201,7 @@ impl<'tcx> LateLintPass<'tcx> for VecInitThenPush {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let Some(searcher) = self.searcher.take() {\n             if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind\n-                && let ExprKind::MethodCall(name, [self_arg, _], _) = expr.kind\n+                && let ExprKind::MethodCall(name, self_arg, [_], _) = expr.kind\n                 && path_to_local_id(self_arg, searcher.local_id)\n                 && name.ident.as_str() == \"push\"\n             {"}, {"sha": "e8d2d579f097e5451a870788145360c3e7510c40", "filename": "clippy_utils/src/check_proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -118,9 +118,9 @@ fn expr_search_pat(tcx: TyCtxt<'_>, e: &Expr<'_>) -> (Pat, Pat) {\n         ExprKind::Unary(UnOp::Neg, e) => (Pat::Str(\"-\"), expr_search_pat(tcx, e).1),\n         ExprKind::Lit(ref lit) => lit_search_pat(&lit.node),\n         ExprKind::Array(_) | ExprKind::Repeat(..) => (Pat::Str(\"[\"), Pat::Str(\"]\")),\n-        ExprKind::Call(e, []) | ExprKind::MethodCall(_, [e], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n+        ExprKind::Call(e, []) | ExprKind::MethodCall(_, e, [], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n         ExprKind::Call(first, [.., last])\n-        | ExprKind::MethodCall(_, [first, .., last], _)\n+        | ExprKind::MethodCall(_, first, [.., last], _)\n         | ExprKind::Binary(_, first, last)\n         | ExprKind::Tup([first, .., last])\n         | ExprKind::Assign(first, last, _)"}, {"sha": "ad95369b9ef707091919fa59ea167a906c35e14e", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -155,13 +155,7 @@ where\n     });\n }\n \n-pub fn span_lint_hir(\n-    cx: &LateContext<'_>,\n-    lint: &'static Lint,\n-    hir_id: HirId,\n-    sp: Span,\n-    msg: &str,\n-) {\n+pub fn span_lint_hir(cx: &LateContext<'_>, lint: &'static Lint, hir_id: HirId, sp: Span, msg: &str) {\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |diag| {\n         let mut diag = diag.build(msg);\n         docs_link(&mut diag, lint);"}, {"sha": "124a00d817847ae7a827a6c8694e0a9e1d888e83", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -45,12 +45,7 @@ impl ops::BitOrAssign for EagernessSuggestion {\n }\n \n /// Determine the eagerness of the given function call.\n-fn fn_eagerness<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    fn_id: DefId,\n-    name: Symbol,\n-    args: &'tcx [Expr<'_>],\n-) -> EagernessSuggestion {\n+fn fn_eagerness<'tcx>(cx: &LateContext<'tcx>, fn_id: DefId, name: Symbol, have_one_arg: bool) -> EagernessSuggestion {\n     use EagernessSuggestion::{Eager, Lazy, NoChange};\n     let name = name.as_str();\n \n@@ -59,7 +54,7 @@ fn fn_eagerness<'tcx>(\n         None => return Lazy,\n     };\n \n-    if (name.starts_with(\"as_\") || name == \"len\" || name == \"is_empty\") && args.len() == 1 {\n+    if (name.starts_with(\"as_\") || name == \"len\" || name == \"is_empty\") && have_one_arg {\n         if matches!(\n             cx.tcx.crate_name(fn_id.krate),\n             sym::std | sym::core | sym::alloc | sym::proc_macro\n@@ -127,10 +122,11 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                     },\n                     Res::Def(_, id) => match path {\n                         QPath::Resolved(_, p) => {\n-                            self.eagerness |= fn_eagerness(self.cx, id, p.segments.last().unwrap().ident.name, args);\n+                            self.eagerness |=\n+                                fn_eagerness(self.cx, id, p.segments.last().unwrap().ident.name, !args.is_empty());\n                         },\n                         QPath::TypeRelative(_, name) => {\n-                            self.eagerness |= fn_eagerness(self.cx, id, name.ident.name, args);\n+                            self.eagerness |= fn_eagerness(self.cx, id, name.ident.name, !args.is_empty());\n                         },\n                         QPath::LangItem(..) => self.eagerness = Lazy,\n                     },\n@@ -141,12 +137,12 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                     self.eagerness |= NoChange;\n                     return;\n                 },\n-                ExprKind::MethodCall(name, args, _) => {\n+                ExprKind::MethodCall(name, ..) => {\n                     self.eagerness |= self\n                         .cx\n                         .typeck_results()\n                         .type_dependent_def_id(e.hir_id)\n-                        .map_or(Lazy, |id| fn_eagerness(self.cx, id, name.ident.name, args));\n+                        .map_or(Lazy, |id| fn_eagerness(self.cx, id, name.ident.name, true));\n                 },\n                 ExprKind::Index(_, e) => {\n                     let ty = self.cx.typeck_results().expr_ty_adjusted(e);"}, {"sha": "6cb6544df4bc1ff553ffb3a39755abf7103ac930", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -282,8 +282,14 @@ impl HirEqInterExpr<'_, '_, '_> {\n                             && self.eq_expr(l.body, r.body)\n                     })\n             },\n-            (&ExprKind::MethodCall(l_path, l_args, _), &ExprKind::MethodCall(r_path, r_args, _)) => {\n-                self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+            (\n+                &ExprKind::MethodCall(l_path, l_receiver, l_args, _),\n+                &ExprKind::MethodCall(r_path, r_receiver, r_args, _),\n+            ) => {\n+                self.inner.allow_side_effects\n+                    && self.eq_path_segment(l_path, r_path)\n+                    && self.eq_expr(l_receiver, r_receiver)\n+                    && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(le, ll), &ExprKind::Repeat(re, rl)) => {\n                 self.eq_expr(le, re) && self.eq_array_length(ll, rl)\n@@ -743,8 +749,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprKind::MethodCall(path, args, ref _fn_span) => {\n+            ExprKind::MethodCall(path, receiver, args, ref _fn_span) => {\n                 self.hash_name(path.ident.name);\n+                self.hash_expr(receiver);\n                 self.hash_exprs(args);\n             },\n             ExprKind::ConstBlock(ref l_id) => {"}, {"sha": "ed1f8af989fe18e5b112c9ed9a5dcc0d9ac7c939", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -1036,21 +1036,21 @@ pub fn can_move_expr_to_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'\n pub fn method_calls<'tcx>(\n     expr: &'tcx Expr<'tcx>,\n     max_depth: usize,\n-) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n+) -> (Vec<Symbol>, Vec<(&'tcx Expr<'tcx>, &'tcx [Expr<'tcx>])>, Vec<Span>) {\n     let mut method_names = Vec::with_capacity(max_depth);\n     let mut arg_lists = Vec::with_capacity(max_depth);\n     let mut spans = Vec::with_capacity(max_depth);\n \n     let mut current = expr;\n     for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, args, _) = &current.kind {\n-            if args.iter().any(|e| e.span.from_expansion()) {\n+        if let ExprKind::MethodCall(path, receiver, args, _) = &current.kind {\n+            if receiver.span.from_expansion() || args.iter().any(|e| e.span.from_expansion()) {\n                 break;\n             }\n             method_names.push(path.ident.name);\n-            arg_lists.push(&**args);\n+            arg_lists.push((*receiver, &**args));\n             spans.push(path.ident.span);\n-            current = &args[0];\n+            current = receiver;\n         } else {\n             break;\n         }\n@@ -1065,18 +1065,18 @@ pub fn method_calls<'tcx>(\n /// `method_chain_args(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n /// containing the `Expr`s for\n /// `.bar()` and `.baz()`\n-pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n+pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<(&'a Expr<'a>, &'a [Expr<'a>])>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprKind::MethodCall(path, args, _) = current.kind {\n+        if let ExprKind::MethodCall(path, receiver, args, _) = current.kind {\n             if path.ident.name.as_str() == *method_name {\n-                if args.iter().any(|e| e.span.from_expansion()) {\n+                if receiver.span.from_expansion() || args.iter().any(|e| e.span.from_expansion()) {\n                     return None;\n                 }\n-                matched.push(args); // build up `matched` backwards\n-                current = &args[0]; // go to parent expression\n+                matched.push((receiver, args)); // build up `matched` backwards\n+                current = receiver; // go to parent expression\n             } else {\n                 return None;\n             }\n@@ -1239,8 +1239,10 @@ pub fn get_enclosing_loop_or_multi_call_closure<'tcx>(\n                                     ty_is_fn_once_param(cx.tcx, ty.skip_binder(), predicates).then_some(())\n                                 })\n                             },\n-                            ExprKind::MethodCall(_, args, _) => {\n-                                let i = args.iter().position(|arg| arg.hir_id == id)?;\n+                            ExprKind::MethodCall(_, receiver, args, _) => {\n+                                let i = std::iter::once(receiver)\n+                                    .chain(args.iter())\n+                                    .position(|arg| arg.hir_id == id)?;\n                                 let id = cx.typeck_results().type_dependent_def_id(e.hir_id)?;\n                                 let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n                                 ty_is_fn_once_param(cx.tcx, ty, cx.tcx.param_env(id).caller_bounds()).then_some(())"}, {"sha": "0226f74906b5152b66a678c960200fcd844564da", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -36,7 +36,7 @@ fn extract_clone_suggestions<'tcx>(\n         if abort {\n             return false;\n         }\n-        if let ExprKind::MethodCall(seg, [recv], _) = expr.kind {\n+        if let ExprKind::MethodCall(seg, recv, [], _) = expr.kind {\n             if path_to_local_id(recv, id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     abort = true;"}, {"sha": "cca71bbf76e2877196898bec350b5435dbcbeaf5", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -373,12 +373,14 @@ fn binop_to_string(op: AssocOp, lhs: &str, rhs: &str) -> String {\n         | AssocOp::LessEqual\n         | AssocOp::NotEqual\n         | AssocOp::Greater\n-        | AssocOp::GreaterEqual => format!(\n-            \"{} {} {}\",\n-            lhs,\n-            op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n-            rhs\n-        ),\n+        | AssocOp::GreaterEqual => {\n+            format!(\n+                \"{} {} {}\",\n+                lhs,\n+                op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n+                rhs\n+            )\n+        },\n         AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n         AssocOp::AssignOp(op) => {\n             format!(\"{} {}= {}\", lhs, token_kind_to_string(&token::BinOp(op)), rhs)\n@@ -868,15 +870,15 @@ impl<'tcx> DerefDelegate<'_, 'tcx> {\n     /// indicates whether the function from `parent_expr` takes its args by double reference\n     fn func_takes_arg_by_double_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n         let ty = match parent_expr.kind {\n-            ExprKind::MethodCall(_, call_args, _) => {\n+            ExprKind::MethodCall(_, receiver, call_args, _) => {\n                 if let Some(sig) = self\n                     .cx\n                     .typeck_results()\n                     .type_dependent_def_id(parent_expr.hir_id)\n                     .map(|did| self.cx.tcx.fn_sig(did).skip_binder())\n                 {\n-                    call_args\n-                        .iter()\n+                    std::iter::once(receiver)\n+                        .chain(call_args.iter())\n                         .position(|arg| arg.hir_id == cmt_hir_id)\n                         .map(|i| sig.inputs()[i])\n                 } else {\n@@ -933,14 +935,14 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                     match &parent_expr.kind {\n                         // given expression is the self argument and will be handled completely by the compiler\n                         // i.e.: `|x| x.is_something()`\n-                        ExprKind::MethodCall(_, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n+                        ExprKind::MethodCall(_, self_expr, ..) if self_expr.hir_id == cmt.hir_id => {\n                             let _ = write!(self.suggestion_start, \"{}{}\", start_snip, ident_str_with_proj);\n                             self.next_pos = span.hi();\n                             return;\n                         },\n                         // item is used in a call\n                         // i.e.: `Call`: `|x| please(x)` or `MethodCall`: `|x| [1, 2, 3].contains(x)`\n-                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, [_, call_args @ ..], _) => {\n+                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, _, [call_args @ ..], _) => {\n                             let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n                             let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n "}, {"sha": "6a62002a4d12e3274f14773f79c9ac41b3524aec", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -620,7 +620,13 @@ pub fn for_each_unconsumed_temporary<'tcx, B>(\n                     helper(typeck, true, arg, f)?;\n                 }\n             },\n-            ExprKind::MethodCall(_, args, _) | ExprKind::Tup(args) | ExprKind::Array(args) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n+                helper(typeck, true, receiver, f)?;\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::Tup(args) | ExprKind::Array(args) => {\n                 for arg in args {\n                     helper(typeck, true, arg, f)?;\n                 }"}, {"sha": "b5bbc9e213c6e928330105b81cd6b0e7fb17fd45", "filename": "tests/ui/author/struct.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcaddeeb23544eb2c86b600c3d775e2773758c2/tests%2Fui%2Fauthor%2Fstruct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bcaddeeb23544eb2c86b600c3d775e2773758c2/tests%2Fui%2Fauthor%2Fstruct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fstruct.stdout?ref=4bcaddeeb23544eb2c86b600c3d775e2773758c2", "patch": "@@ -53,11 +53,11 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::MethodCall(method_name, args, _) = expr.kind;\n+    if let ExprKind::MethodCall(method_name, receiver, args, _) = expr.kind;\n     if method_name.ident.as_str() == \"test\";\n-    if args.len() == 1;\n-    if let ExprKind::Path(ref qpath) = args[0].kind;\n+    if let ExprKind::Path(ref qpath) = receiver.kind;\n     if match_qpath(qpath, &[\"test_method_call\"]);\n+    if args.is_empty();\n     then {\n         // report your lint here\n     }"}]}