{"sha": "9978574c9e18ac2feb2daf0758ec00e407be75ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5Nzg1NzRjOWUxOGFjMmZlYjJkYWYwNzU4ZWMwMGU0MDdiZTc1Y2E=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-11-25T04:39:22Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:43:01Z"}, "message": "Fix rebasing errors, convert some BodyCache::body() calls to reborrows", "tree": {"sha": "3cf08e3992c19b39b9b4a6413de8427dfa55bdf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cf08e3992c19b39b9b4a6413de8427dfa55bdf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9978574c9e18ac2feb2daf0758ec00e407be75ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9978574c9e18ac2feb2daf0758ec00e407be75ca", "html_url": "https://github.com/rust-lang/rust/commit/9978574c9e18ac2feb2daf0758ec00e407be75ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9978574c9e18ac2feb2daf0758ec00e407be75ca/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64654ce1f171faad7461db90435bffefe0390151", "url": "https://api.github.com/repos/rust-lang/rust/commits/64654ce1f171faad7461db90435bffefe0390151", "html_url": "https://github.com/rust-lang/rust/commit/64654ce1f171faad7461db90435bffefe0390151"}], "stats": {"total": 77, "additions": 39, "deletions": 38}, "files": [{"sha": "e135f8d1be98d3d0070bbdd796ef0a051b26a1ba", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=9978574c9e18ac2feb2daf0758ec00e407be75ca", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if self.body_cache.local_decls[*local].is_user_variable.is_some() =>\n+            } if self.body.local_decls[*local].is_user_variable() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n                 let suggestion = match local_decl.local_info {"}, {"sha": "b8a275e5b34b47dcb7c42f6b0abd12b4f9f532a7", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9978574c9e18ac2feb2daf0758ec00e407be75ca", "patch": "@@ -1406,9 +1406,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(body.body(), tcx).ty;\n+                let place_ty = place.ty(&*body, tcx).ty;\n                 let place_ty = self.normalize(place_ty, location);\n-                let rv_ty = rv.ty(body.body(), tcx);\n+                let rv_ty = rv.ty(&*body, tcx);\n                 let rv_ty = self.normalize(rv_ty, location);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1460,7 +1460,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(body.body(), tcx).ty;\n+                let place_type = place.ty(&*body, tcx).ty;\n                 let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1482,7 +1482,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(box(ref place, ref projection), variance) => {\n-                let place_ty = place.ty(body.body(), tcx).ty;\n+                let place_ty = place.ty(&*body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1998,7 +1998,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // While this is located in `nll::typeck` this error is not an NLL error, it's\n                     // a required check to make sure that repeated elements implement `Copy`.\n                     let span = body.source_info(location).span;\n-                    let ty = operand.ty(body.body(), tcx);\n+                    let ty = operand.ty(&*body, tcx);\n                     if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                         // To determine if `const_in_array_repeat_expressions` feature gate should\n                         // be mentioned, need to check if the rvalue is promotable.\n@@ -2052,7 +2052,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Cast(cast_kind, op, ty) => {\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        let fn_sig = op.ty(body.body(), tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(&*body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2081,7 +2081,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(body.body(), tcx).kind {\n+                        let sig = match op.ty(&*body, tcx).kind {\n                             ty::Closure(def_id, substs) => {\n                                 substs.as_closure().sig_ty(def_id, tcx).fn_sig(tcx)\n                             }\n@@ -2107,7 +2107,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        let fn_sig = op.ty(body.body(), tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(&*body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2139,7 +2139,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n                             def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(body.body(), tcx), &[ty.into()]),\n+                            substs: tcx.mk_substs_trait(op.ty(&*body, tcx), &[ty.into()]),\n                         };\n \n                         self.prove_trait_ref(\n@@ -2150,7 +2150,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(body.body(), tcx).kind {\n+                        let ty_from = match op.ty(&*body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::Mutability::Mutable,\n@@ -2198,7 +2198,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ArrayToPointer)  => {\n-                        let ty_from = op.ty(body.body(), tcx);\n+                        let ty_from = op.ty(&*body, tcx);\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(\n@@ -2260,7 +2260,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        let ty_from = op.ty(body.body(), tcx);\n+                        let ty_from = op.ty(&*body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n@@ -2327,9 +2327,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | Rvalue::BinaryOp(BinOp::Le, left, right)\n             | Rvalue::BinaryOp(BinOp::Gt, left, right)\n             | Rvalue::BinaryOp(BinOp::Ge, left, right) => {\n-                let ty_left = left.ty(body.body(), tcx);\n+                let ty_left = left.ty(&*body, tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n-                    let ty_right = right.ty(body.body(), tcx);\n+                    let ty_right = right.ty(&*body, tcx);\n                     let common_ty = self.infcx.next_ty_var(\n                         TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::MiscVariable,"}, {"sha": "62b4a4ccc9894182ed1dff542cde6d27c723c31d", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=9978574c9e18ac2feb2daf0758ec00e407be75ca", "patch": "@@ -51,7 +51,7 @@ pub trait Qualif {\n             });\n             let qualif = base_qualif && Self::in_any_value_of_ty(\n                 cx,\n-                Place::ty_from(place.base, proj_base, cx.body.body(), cx.tcx)\n+                Place::ty_from(place.base, proj_base, &*cx.body, cx.tcx)\n                     .projection_ty(cx.tcx, elem)\n                     .ty,\n             );\n@@ -155,7 +155,7 @@ pub trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n                     if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body.body(), cx.tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, proj_base, &*cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, per_local, PlaceRef {\n                                 base: &place.base,\n@@ -221,7 +221,7 @@ impl Qualif for HasMutInterior {\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(cx.body.body(), cx.tcx);\n+                        let ty = rvalue.ty(&*cx.body, cx.tcx);\n                         assert_eq!(Self::in_any_value_of_ty(cx, ty), true);\n                         return true;\n                     }"}, {"sha": "9004c5be987fd6ea20bfe3bf4bc88fcf2fda8514", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=9978574c9e18ac2feb2daf0758ec00e407be75ca", "patch": "@@ -77,7 +77,7 @@ where\n         args: &[mir::Operand<'tcx>],\n         return_place: &mir::Place<'tcx>,\n     ) {\n-        let return_ty = return_place.ty(self.item.body.body(), self.item.tcx).ty;\n+        let return_ty = return_place.ty(&*self.item.body, self.item.tcx).ty;\n         let qualif = Q::in_call(\n             self.item,\n             &|l| self.qualifs_per_local.contains(l),"}, {"sha": "86e1d6584fc2e22ff1513a7a9fc1957a23103ada", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=9978574c9e18ac2feb2daf0758ec00e407be75ca", "patch": "@@ -172,7 +172,7 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         let indirectly_mutable = old_dataflow::do_dataflow(\n             item.tcx,\n-            item.body.body(),\n+            &*item.body,\n             item.def_id,\n             &item.tcx.get_attrs(item.def_id),\n             &dead_unwinds,\n@@ -304,7 +304,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         // Special-case reborrows to be more like a copy of a reference.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body.body(), place) {\n+            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, &*self.body, place) {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -390,7 +390,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body.body(), self.tcx);\n+                let operand_ty = operand.ty(&*self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n \n@@ -401,7 +401,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body.body(), self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(&*self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -475,7 +475,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body.body(), self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, &*self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n                         if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n@@ -499,7 +499,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             ProjectionElem::Subslice {..} |\n             ProjectionElem::Field(..) |\n             ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body.body(), self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, &*self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -548,7 +548,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(self.body.body(), self.tcx);\n+                let fn_ty = func.ty(&*self.body, self.tcx);\n \n                 let def_id = match fn_ty.kind {\n                     ty::FnDef(def_id, _) => def_id,\n@@ -609,7 +609,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // Check to see if the type of this place can ever have a drop impl. If not, this\n                 // `Drop` terminator is frivolous.\n                 let ty_needs_drop = dropped_place\n-                    .ty(self.body.body(), self.tcx)\n+                    .ty(&*self.body, self.tcx)\n                     .ty\n                     .needs_drop(self.tcx, self.param_env);\n "}, {"sha": "df4cb7615336af3c6d810cffaf201ea38fd8b05b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=9978574c9e18ac2feb2daf0758ec00e407be75ca", "patch": "@@ -231,6 +231,7 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyCache<'_>> {\n         &rustc_peek::SanityCheck,\n         &uniform_array_move_out::UniformArrayMoveOut,\n     ]);\n+    body.ensure_predecessors();\n     tcx.alloc_steal_mir(body)\n }\n "}, {"sha": "4af9ccb83acedc50003af5ea2b1fb762d7db61aa", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=9978574c9e18ac2feb2daf0758ec00e407be75ca", "patch": "@@ -349,7 +349,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 let ty = Place::ty_from(\n                                         &place.base,\n                                         proj_base,\n-                                        self.body.body(),\n+                                        &*self.body,\n                                         self.tcx\n                                     )\n                                     .projection_ty(self.tcx, elem)\n@@ -372,7 +372,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         }\n \n                         if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(self.body.body(), self.tcx).ty;\n+                            let ty = place.ty(&*self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n@@ -521,7 +521,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.base, proj_base, self.body.body(), self.tcx).ty;\n+                                Place::ty_from(place.base, proj_base, &*self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -570,7 +570,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n-                let operand_ty = operand.ty(self.body.body(), self.tcx);\n+                let operand_ty = operand.ty(&*self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -584,7 +584,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body.body(), self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(&*self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -619,7 +619,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(self.body.body(), self.tcx).ty;\n+                    let ty = place.ty(&*self.body, self.tcx).ty;\n \n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -646,7 +646,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n                     let base_ty =\n-                        Place::ty_from(&place.base, proj_base, self.body.body(), self.tcx).ty;\n+                        Place::ty_from(&place.base, proj_base, &*self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         place = PlaceRef {\n                             base: &place.base,\n@@ -672,7 +672,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.base, proj_base, self.body.body(), self.tcx)\n+                        let ty = Place::ty_from(place.base, proj_base, &*self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -705,7 +705,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n-        let fn_ty = callee.ty(self.body.body(), self.tcx);\n+        let fn_ty = callee.ty(&*self.body, self.tcx);\n \n         if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {"}, {"sha": "2235de9a1533a16ecb1b91e5b017ab0eb6b73235", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978574c9e18ac2feb2daf0758ec00e407be75ca/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=9978574c9e18ac2feb2daf0758ec00e407be75ca", "patch": "@@ -33,7 +33,7 @@ use itertools::Itertools as _;\n pub struct SimplifyArmIdentity;\n \n impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         for bb in basic_blocks {\n             // Need 3 statements:\n@@ -151,7 +151,7 @@ fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarFie\n pub struct SimplifyBranchSame;\n \n impl<'tcx> MirPass<'tcx> for SimplifyBranchSame {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let mut did_remove_blocks = false;\n         let bbs = body.basic_blocks_mut();\n         for bb_idx in bbs.indices() {"}]}