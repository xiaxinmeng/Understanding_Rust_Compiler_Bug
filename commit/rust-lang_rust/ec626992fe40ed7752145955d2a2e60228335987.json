{"sha": "ec626992fe40ed7752145955d2a2e60228335987", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNjI2OTkyZmU0MGVkNzc1MjE0NTk1NWQyYTJlNjAyMjgzMzU5ODc=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-07-05T22:45:56Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-07-07T21:22:07Z"}, "message": "Fix bug when opaque type was nested in another type.\n\nPreviously, types like (Foo, u8) would not be handled correctly\n(where Foo is an 'existential type')", "tree": {"sha": "43189792ec2f6731345df65aaf9430075f810427", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43189792ec2f6731345df65aaf9430075f810427"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec626992fe40ed7752145955d2a2e60228335987", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl0iYn8ACgkQtAh+UQ6Y\nsWQfnhAAmLeg3FqerClPOZQH2oq5UCe58vHKMAtN/tfYyVyDhnyJFo8Ca84YIGqs\nhg4HuBzBTR4XuqBGExqefmL+vMMfVJgSGJupuA7ZNAcpMgYyoonK8H5BDs20zlct\nUZfY3lp0FoCpWlUwY5ZbixfkWZjHoCbe9QozgaCroPcVwsfmxODBRjmyTGQ9XDBy\nyPoZK8AsSV2bJrRcC2aEZCHPgCKxV6Uy7pCOMRN2FzlAqGsItk+/maiIRTzMO3df\n6XhLFyTuAXpkcYDIpGlu7e8uPx4VdFqLhNrsxxcgiclrDisU8I1ykSpV1P2b3r0G\ndCJx5fbcAPqmbcmITmGw8biAplOorpEZNNNdZCXIwysqAA0Goe3adiS7fgzvm2LC\nTgYRzKhvdfzchEUahB55+TSP5mDQ1+RYxhxWBvfjHLIPytPiFvRyyoLg3nudCkee\nJd/SuIViiNVIaQqzkDXiWojAZqU1OH14IAsyer/9LFoWNPrOYAVNUawxoXUWlWQe\nxQJ8TB8Pzu5ZK4DG/mmFDswJerWqz7/McD02/nNq5IngPSwS3SvNWPzTer/S6nJb\n2YPu+rudWLGzqmLALPfc+dg4oAe1bFmonoCa1w01TAZq9+vh4FKCES6BtunaoRGb\ng6d7/HonEPn5QoIuiTWlCsHfF7CLkLLUvnaaFZE+1oBN3V4MHac=\n=BZPk\n-----END PGP SIGNATURE-----", "payload": "tree 43189792ec2f6731345df65aaf9430075f810427\nparent 8ba9b1019c6e6c514826c5466e84d93f665f975f\nauthor Aaron Hill <aa1ronham@gmail.com> 1562366756 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1562534527 -0400\n\nFix bug when opaque type was nested in another type.\n\nPreviously, types like (Foo, u8) would not be handled correctly\n(where Foo is an 'existential type')\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec626992fe40ed7752145955d2a2e60228335987", "html_url": "https://github.com/rust-lang/rust/commit/ec626992fe40ed7752145955d2a2e60228335987", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec626992fe40ed7752145955d2a2e60228335987/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ba9b1019c6e6c514826c5466e84d93f665f975f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ba9b1019c6e6c514826c5466e84d93f665f975f", "html_url": "https://github.com/rust-lang/rust/commit/8ba9b1019c6e6c514826c5466e84d93f665f975f"}], "stats": {"total": 95, "additions": 67, "deletions": 28}, "files": [{"sha": "a505750b1a12d0ab856de6119abad409c1f8aabe", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ec626992fe40ed7752145955d2a2e60228335987/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec626992fe40ed7752145955d2a2e60228335987/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=ec626992fe40ed7752145955d2a2e60228335987", "patch": "@@ -1253,51 +1253,58 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             &anon_ty,\n                             locations.span(body),\n                         ));\n-\n-                    let revealed_ty_is_opaque = revealed_ty.is_impl_trait();\n-\n                     debug!(\n                         \"eq_opaque_type_and_type: \\\n                          instantiated output_ty={:?} \\\n                          opaque_type_map={:#?} \\\n-                         revealed_ty={:?} \\\n-                         revealed_ty_is_opaque={}\",\n-                        output_ty, opaque_type_map, revealed_ty, revealed_ty_is_opaque\n+                         revealed_ty={:?}\",\n+                        output_ty, opaque_type_map, revealed_ty\n                     );\n                     obligations.add(infcx\n                         .at(&ObligationCause::dummy(), param_env)\n                         .eq(output_ty, revealed_ty)?);\n \n-                    // This is 'true' when we're using an existential\n-                    // type without 'revelaing' it. For example, code like this:\n-                    //\n-                    // existential type Foo: Debug;\n-                    // fn foo1() -> Foo { ... }\n-                    // fn foo2() -> Foo { foo1() }\n-                    //\n-                    // In 'foo2', we're not revealing the type of 'Foo' - we're\n-                    // just treating it as the opaque type. All of the constraints\n-                    // in our 'opaque_type_map' apply to the concrete type,\n-                    // not to the opaque type itself. Therefore, it's enough\n-                    // to simply equate the output and opque 'revealed_type',\n-                    // as we do above\n-                    if revealed_ty_is_opaque {\n-                        return Ok(InferOk { value: None, obligations: obligations.into_vec() });\n-                    }\n-\n                     for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n                         let opaque_defn_ty = tcx.type_of(opaque_def_id);\n                         let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n                         let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n+                        let concrete_is_opaque = infcx\n+                            .resolve_vars_if_possible(&opaque_decl.concrete_ty).is_impl_trait();\n+\n                         debug!(\n-                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n+                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?} \\\n+                            concrete_is_opaque={}\",\n                             opaque_decl.concrete_ty,\n                             infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty),\n-                            opaque_defn_ty\n+                            opaque_defn_ty,\n+                            concrete_is_opaque\n                         );\n-                        obligations.add(infcx\n-                            .at(&ObligationCause::dummy(), param_env)\n-                            .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+\n+                        // concrete_is_opaque is 'true' when we're using an existential\n+                        // type without 'revelaing' it. For example, code like this:\n+                        //\n+                        // existential type Foo: Debug;\n+                        // fn foo1() -> Foo { ... }\n+                        // fn foo2() -> Foo { foo1() }\n+                        //\n+                        // In 'foo2', we're not revealing the type of 'Foo' - we're\n+                        // just treating it as the opaque type.\n+                        //\n+                        // When this occurs, we do *not* want to try to equate\n+                        // the concrete type with the underlying defining type\n+                        // of the existential type - this will always fail, since\n+                        // the defining type of an existential type is always\n+                        // some other type (e.g. not itself)\n+                        // Essentially, none of the normal obligations apply here -\n+                        // we're just passing around some unknown opaque type,\n+                        // without actually looking at the underlying type it\n+                        // gets 'revealed' into\n+\n+                        if !concrete_is_opaque {\n+                            obligations.add(infcx\n+                                .at(&ObligationCause::dummy(), param_env)\n+                                .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+                        }\n                     }\n \n                     debug!(\"eq_opaque_type_and_type: equated\");"}, {"sha": "31c145ea89a33d2fcb98ad8d2d5226b8dda96722", "filename": "src/test/run-pass/existential_type_tuple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec626992fe40ed7752145955d2a2e60228335987/src%2Ftest%2Frun-pass%2Fexistential_type_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec626992fe40ed7752145955d2a2e60228335987/src%2Ftest%2Frun-pass%2Fexistential_type_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexistential_type_tuple.rs?ref=ec626992fe40ed7752145955d2a2e60228335987", "patch": "@@ -0,0 +1,32 @@\n+#![feature(existential_type)]\n+\n+#![allow(dead_code)]\n+\n+pub trait MyTrait {}\n+\n+impl MyTrait for bool {}\n+\n+struct Blah {\n+    my_foo: Foo,\n+    my_u8: u8\n+}\n+\n+impl Blah {\n+    fn new() -> Blah {\n+        Blah {\n+            my_foo: make_foo(),\n+            my_u8: 12\n+        }\n+    }\n+    fn into_inner(self) -> (Foo, u8) {\n+        (self.my_foo, self.my_u8)\n+    }\n+}\n+\n+fn make_foo() -> Foo {\n+    true\n+}\n+\n+existential type Foo: MyTrait;\n+\n+fn main() {}"}]}