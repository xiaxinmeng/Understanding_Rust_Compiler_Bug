{"sha": "4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZDA1ZTViZTJlMjhlOGFmY2I0MmRiMWZlM2ZkNWNiYmE3YWQ1NmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-10-26T05:23:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-02T21:14:19Z"}, "message": "convert GEP to i32", "tree": {"sha": "f8a589da728efb25f2897f4ea2043b1e2b6363da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8a589da728efb25f2897f4ea2043b1e2b6363da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "html_url": "https://github.com/rust-lang/rust/commit/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "html_url": "https://github.com/rust-lang/rust/commit/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a"}], "stats": {"total": 182, "additions": 67, "deletions": 115}, "files": [{"sha": "fb974b80452860d9d3b869c3717675768046da11", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "patch": "@@ -78,11 +78,11 @@ const closure_elt_bindings: int = 1;\n \n const closure_elt_ty_params: int = 2;\n \n-const vec_elt_fill: uint = 0u;\n+const vec_elt_fill: int = 0;\n \n-const vec_elt_alloc: uint = 1u;\n+const vec_elt_alloc: int = 1;\n \n-const vec_elt_elems: uint = 2u;\n+const vec_elt_elems: int = 2;\n \n const worst_case_glue_call_args: int = 7;\n "}, {"sha": "9688e351ffefc2bed287eeb87f0ca0433fdd25e2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 41, "deletions": 89, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "patch": "@@ -659,14 +659,6 @@ fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n     }\n }\n \n-// Simple wrapper around GEP that takes an array of ints and wraps them\n-// in C_int()\n-fn GEPi(cx: @block_ctxt, base: ValueRef, ixs: [int]) -> ValueRef {\n-    let v: [ValueRef] = [];\n-    for i: int in ixs { v += [C_int(bcx_ccx(cx), i)]; }\n-    ret InBoundsGEP(cx, base, v);\n-}\n-\n // Increment a pointer by a given amount and then cast it to be a pointer\n // to a given type.\n fn bump_ptr(bcx: @block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n@@ -898,10 +890,8 @@ fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n    result {\n     let ti = none::<@tydesc_info>;\n     let tydesc = get_tydesc(cx, t, escapes, tps_normal, ti).result;\n-    let ccx = bcx_ccx(cx);\n     ret rslt(tydesc.bcx,\n-             GEP(tydesc.bcx, tydesc.val, [C_int(ccx, 0),\n-                                          C_int(ccx, field)]));\n+             GEPi(tydesc.bcx, tydesc.val, [0, field]));\n }\n \n \n@@ -1230,7 +1220,7 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n     let lltydescs = [mutable];\n     let p = 0u;\n     while p < ty_param_count {\n-        let llparam = GEP(load_env_bcx, lltyparams, [C_int(ccx, p as int)]);\n+        let llparam = GEPi(load_env_bcx, lltyparams, [p as int]);\n         llparam = Load(load_env_bcx, llparam);\n         std::vec::grow_set(lltydescs, ty_params[p], 0 as ValueRef, llparam);\n         p += 1u;\n@@ -1354,8 +1344,7 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     let rc_ptr =\n-        GEP(cx, box_ptr, [C_int(ccx, 0),\n-                          C_int(ccx, abi::box_rc_field_refcnt)]);\n+        GEPi(cx, box_ptr, [0, abi::box_rc_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n     rc = Add(cx, rc, C_int(ccx, 1));\n     Store(cx, rc, rc_ptr);\n@@ -1369,9 +1358,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n     let bcx = alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_box(body_mt) {\n         v = PointerCast(bcx, v, type_of_1(bcx, t));\n-        let ccx = bcx_ccx(bcx);\n-        let body = GEP(bcx, v, [C_int(ccx, 0),\n-                                C_int(ccx, abi::box_rc_field_body)]);\n+        let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         if !bcx_ccx(bcx).sess.get_opts().do_gc {\n             trans_non_gc_free(bcx, v)\n@@ -1391,11 +1378,9 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         let ccx = bcx_ccx(bcx);\n         let llbox_ty = T_opaque_obj_ptr(ccx);\n         let b = PointerCast(bcx, v, llbox_ty);\n-        let body = GEP(bcx, b, [C_int(ccx, 0),\n-                                C_int(ccx, abi::box_rc_field_body)]);\n+        let body = GEPi(bcx, b, [0, abi::box_rc_field_body]);\n         let tydescptr =\n-            GEP(bcx, body, [C_int(ccx, 0),\n-                            C_int(ccx, abi::obj_body_elt_tydesc)]);\n+            GEPi(bcx, body, [0, abi::obj_body_elt_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n         let ti = none;\n         call_tydesc_glue_full(bcx, body, tydesc,\n@@ -1409,14 +1394,11 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         // Then free the body.\n         let ccx = bcx_ccx(bcx);\n         v = PointerCast(bcx, v, T_opaque_closure_ptr(ccx));\n-        let body = GEP(bcx, v, [C_int(ccx, 0),\n-                                C_int(ccx, abi::box_rc_field_body)]);\n+        let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n         let bindings =\n-            GEP(bcx, body, [C_int(ccx, 0),\n-                            C_int(ccx, abi::closure_elt_bindings)]);\n+            GEPi(bcx, body, [0, abi::closure_elt_bindings]);\n         let tydescptr =\n-            GEP(bcx, body, [C_int(ccx, 0),\n-                            C_int(ccx, abi::closure_elt_tydesc)]);\n+            GEPi(bcx, body, [0, abi::closure_elt_tydesc]);\n         let ti = none;\n         call_tydesc_glue_full(bcx, bindings, Load(bcx, tydescptr),\n                               abi::tydesc_field_drop_glue, ti);\n@@ -1440,16 +1422,14 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n           }\n           ty::ty_obj(_) {\n             let box_cell =\n-                GEP(bcx, v0, [C_int(ccx, 0),\n-                              C_int(ccx, abi::obj_field_box)]);\n+                GEPi(bcx, v0, [0, abi::obj_field_box]);\n             decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n           }\n           ty::ty_res(did, inner, tps) {\n             trans_res_drop(bcx, v0, did, inner, tps)\n           }\n           ty::ty_fn(_, _, _, _, _) {\n-            let box_cell = GEP(bcx, v0, [C_int(ccx, 0),\n-                                         C_int(ccx, abi::fn_field_box)]);\n+            let box_cell = GEPi(bcx, v0, [0, abi::fn_field_box]);\n             decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n           }\n           _ {\n@@ -1516,8 +1496,7 @@ fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n     let null_test = IsNull(cx, box_ptr);\n     CondBr(cx, null_test, next_cx.llbb, rc_adj_cx.llbb);\n     let rc_ptr =\n-        GEP(rc_adj_cx, box_ptr, [C_int(ccx, 0),\n-                                 C_int(ccx, abi::box_rc_field_refcnt)]);\n+        GEPi(rc_adj_cx, box_ptr, [0, abi::box_rc_field_refcnt]);\n     let rc = Load(rc_adj_cx, rc_ptr);\n     rc = Sub(rc_adj_cx, rc, C_int(ccx, 1));\n     Store(rc_adj_cx, rc, rc_ptr);\n@@ -1730,8 +1709,8 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         let ccx = bcx_ccx(cx);\n         let lltagty = T_opaque_tag_ptr(ccx);\n         let av_tag = PointerCast(cx, av, lltagty);\n-        let lldiscrim_a_ptr = GEP(cx, av_tag, [C_int(ccx, 0), C_int(ccx, 0)]);\n-        let llunion_a_ptr = GEP(cx, av_tag, [C_int(ccx, 0), C_int(ccx, 1)]);\n+        let lldiscrim_a_ptr = GEPi(cx, av_tag, [0, 0]);\n+        let llunion_a_ptr = GEPi(cx, av_tag, [0, 1]);\n         let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n \n         // NB: we must hit the discriminant first so that structural\n@@ -1756,15 +1735,11 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         ret next_cx;\n       }\n       ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _, _) {\n-        let ccx = bcx_ccx(cx);\n-        let box_cell_a = GEP(cx, av, [C_int(ccx, 0),\n-                                      C_int(ccx, abi::fn_field_box)]);\n+        let box_cell_a = GEPi(cx, av, [0, abi::fn_field_box]);\n         ret iter_boxpp(cx, box_cell_a, f);\n       }\n       ty::ty_obj(_) {\n-        let ccx = bcx_ccx(cx);\n-        let box_cell_a = GEP(cx, av, [C_int(ccx, 0),\n-                                      C_int(ccx, abi::obj_field_box)]);\n+        let box_cell_a = GEPi(cx, av, [0, abi::obj_field_box]);\n         ret iter_boxpp(cx, box_cell_a, f);\n       }\n       _ { bcx_ccx(cx).sess.unimpl(\"type in iter_structural_ty\"); }\n@@ -1880,18 +1855,15 @@ fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n       }\n     }\n \n-    let ccx = bcx_ccx(cx);\n     let llrawptr = PointerCast(cx, v, T_ptr(T_i8()));\n     let lltydescs =\n-        GEP(cx, tydesc, [C_int(ccx, 0),\n-                         C_int(ccx, abi::tydesc_field_first_param)]);\n+        GEPi(cx, tydesc, [0, abi::tydesc_field_first_param]);\n     lltydescs = Load(cx, lltydescs);\n \n     let llfn;\n     alt static_glue_fn {\n       none. {\n-        let llfnptr = GEP(cx, tydesc, [C_int(ccx, 0),\n-                                       C_int(ccx, field)]);\n+        let llfnptr = GEPi(cx, tydesc, [0, field]);\n         llfn = Load(cx, llfnptr);\n       }\n       some(sgf) { llfn = sgf; }\n@@ -1930,18 +1902,15 @@ fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     let lltydesc = r.val;\n     bcx = r.bcx;\n     lazily_emit_tydesc_glue(bcx, abi::tydesc_field_cmp_glue, ti);\n-    let ccx = bcx_ccx(bcx);\n     let lltydescs =\n-        GEP(bcx, lltydesc, [C_int(ccx, 0),\n-                            C_int(ccx, abi::tydesc_field_first_param)]);\n+        GEPi(bcx, lltydesc, [0, abi::tydesc_field_first_param]);\n     lltydescs = Load(bcx, lltydescs);\n \n     let llfn;\n     alt ti {\n       none. {\n         let llfnptr =\n-            GEP(bcx, lltydesc, [C_int(ccx, 0),\n-                                C_int(ccx, abi::tydesc_field_cmp_glue)]);\n+            GEPi(bcx, lltydesc, [0, abi::tydesc_field_cmp_glue]);\n         llfn = Load(bcx, llfnptr);\n       }\n       some(sti) { llfn = option::get(sti.cmp_glue); }\n@@ -2411,8 +2380,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     while true {\n         alt ty::struct(ccx.tcx, t1) {\n           ty::ty_box(mt) {\n-            let body = GEP(cx, v1, [C_int(ccx, 0),\n-                                    C_int(ccx, abi::box_rc_field_body)]);\n+            let body = GEPi(cx, v1, [0, abi::box_rc_field_body]);\n             t1 = mt.ty;\n \n             // Since we're changing levels of box indirection, we may have\n@@ -2432,7 +2400,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n           }\n           ty::ty_res(did, inner, tps) {\n             t1 = ty::substitute_type_params(ccx.tcx, tps, inner);\n-            v1 = GEP(cx, v1, [C_int(ccx, 0), C_int(ccx, 1)]);\n+            v1 = GEPi(cx, v1, [0, 1]);\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(ccx.tcx, did);\n@@ -3031,8 +2999,7 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             let lltagty = type_of_tag(ccx, sp, tid, tag_ty);\n             let bcx = alloc_result.bcx;\n             let lltagptr = PointerCast(bcx, lltagblob, T_ptr(lltagty));\n-            let lldiscrimptr = GEP(bcx, lltagptr, [C_int(ccx, 0),\n-                                                   C_int(ccx, 0)]);\n+            let lldiscrimptr = GEPi(bcx, lltagptr, [0, 0]);\n             let d = if std::vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n                 let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n                 let lldiscrim = Load(bcx, lldiscrim_gv);\n@@ -3075,13 +3042,11 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n     let mths = alt ty::struct(tcx, o_ty) { ty::ty_obj(ms) { ms } };\n \n     let ix = ty::method_idx(ccx.sess, bcx.sp, field, mths);\n-    let vtbl = Load(bcx, GEP(bcx, o, [C_int(ccx, 0),\n-                                      C_int(ccx, abi::obj_field_vtbl)]));\n+    let vtbl = Load(bcx, GEPi(bcx, o, [0, abi::obj_field_vtbl]));\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n     vtbl = PointerCast(bcx, vtbl, vtbl_type);\n \n-    let v = GEP(bcx, vtbl, [C_int(ccx, 0),\n-                            C_int(ccx, ix as int)]);\n+    let v = GEPi(bcx, vtbl, [0, ix as int]);\n     let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, mths[ix]);\n     let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n     let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n@@ -3225,13 +3190,10 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n         let val =\n             alt ty::struct(ccx.tcx, t) {\n               ty::ty_box(_) {\n-                InBoundsGEP(sub.bcx, sub.val,\n-                            [C_int(ccx, 0),\n-                             C_int(ccx, abi::box_rc_field_body)])\n+                GEPi(sub.bcx, sub.val, [0, abi::box_rc_field_body])\n               }\n               ty::ty_res(_, _, _) {\n-                InBoundsGEP(sub.bcx, sub.val, [C_int(ccx, 0),\n-                                               C_int(ccx, 1)])\n+                GEPi(sub.bcx, sub.val, [0, 1])\n               }\n               ty::ty_tag(_, _) {\n                 let ety = ty::expr_ty(ccx.tcx, e);\n@@ -3453,11 +3415,9 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n                          [0, abi::box_rc_field_body,\n                           abi::closure_elt_bindings, 0]);\n         let lltargetenv =\n-            Load(cx, GEP(cx, pair, [C_int(ccx, 0),\n-                                    C_int(ccx, abi::fn_field_box)]));\n+            Load(cx, GEPi(cx, pair, [0, abi::fn_field_box]));\n         let lltargetfn = Load\n-            (cx, GEP(cx, pair, [C_int(ccx, 0),\n-                                C_int(ccx, abi::fn_field_code)]));\n+            (cx, GEPi(cx, pair, [0, abi::fn_field_code]));\n         bcx = cx;\n         (lltargetfn, lltargetenv, 1)\n       }\n@@ -3803,7 +3763,6 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n-    let ccx = bcx_ccx(in_cx);\n     let tcx = bcx_tcx(in_cx);\n     let fn_expr_ty = ty::expr_ty(tcx, f);\n \n@@ -3828,11 +3787,9 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n             faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n         }\n         let pair = faddr;\n-        faddr = GEP(bcx, pair, [C_int(ccx, 0),\n-                                C_int(ccx, abi::fn_field_code)]);\n+        faddr = GEPi(bcx, pair, [0, abi::fn_field_code]);\n         faddr = Load(bcx, faddr);\n-        let llclosure = GEP(bcx, pair, [C_int(ccx, 0),\n-                                        C_int(ccx, abi::fn_field_box)]);\n+        let llclosure = GEPi(bcx, pair, [0, abi::fn_field_box]);\n         llenv = Load(bcx, llclosure);\n       }\n     }\n@@ -5100,25 +5057,23 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     let fields_tup_ty = ty::mk_tup(fcx.lcx.ccx.tcx, field_tys);\n     let n_typarams = std::vec::len::<ast::ty_param>(bcx.fcx.lcx.obj_typarams);\n     let llobj_box_ty: TypeRef = T_obj_ptr(ccx, n_typarams);\n-    let box_cell = GEP(bcx, llself.v, [C_int(ccx, 0),\n-                                       C_int(ccx, abi::obj_field_box)]);\n+    let box_cell = GEPi(bcx, llself.v, [0, abi::obj_field_box]);\n     let box_ptr = Load(bcx, box_cell);\n     box_ptr = PointerCast(bcx, box_ptr, llobj_box_ty);\n     let obj_typarams =\n-        GEP(bcx, box_ptr,\n-            [C_int(ccx, 0), C_int(ccx, abi::box_rc_field_body),\n-             C_int(ccx, abi::obj_body_elt_typarams)]);\n+        GEPi(bcx, box_ptr, [0, abi::box_rc_field_body,\n+                            abi::obj_body_elt_typarams]);\n \n     // The object fields immediately follow the type parameters, so we skip\n     // over them to get the pointer.\n     let obj_fields =\n-        PointerCast(bcx, GEP(bcx, obj_typarams, [C_int(ccx, 1)]),\n+        PointerCast(bcx, GEPi(bcx, obj_typarams, [1]),\n                     T_ptr(type_of_or_i8(bcx, fields_tup_ty)));\n \n     let i: int = 0;\n     for p: ast::ty_param in fcx.lcx.obj_typarams {\n         let lltyparam: ValueRef =\n-            GEP(bcx, obj_typarams, [C_int(ccx, 0), C_int(ccx, i)]);\n+            GEPi(bcx, obj_typarams, [0, i]);\n         lltyparam = Load(bcx, lltyparam);\n         fcx.lltydescs += [lltyparam];\n         i += 1;\n@@ -5307,10 +5262,9 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         } else {\n             let lltagptr =\n                 PointerCast(bcx, fcx.llretptr, T_opaque_tag_ptr(ccx));\n-            let lldiscrimptr = GEP(bcx, lltagptr, [C_int(ccx, 0),\n-                                                   C_int(ccx, 0)]);\n+            let lldiscrimptr = GEPi(bcx, lltagptr, [0, 0]);\n             Store(bcx, C_int(ccx, index), lldiscrimptr);\n-            GEP(bcx, lltagptr, [C_int(ccx, 0), C_int(ccx, 1)])\n+            GEPi(bcx, lltagptr, [0, 1])\n         };\n     i = 0u;\n     let t_id = ast_util::local_def(tag_id);\n@@ -5558,11 +5512,9 @@ fn create_real_fn_pair(cx: @block_ctxt, llfnty: TypeRef, llfn: ValueRef,\n fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n                 llenvptr: ValueRef) {\n     let ccx = bcx_ccx(bcx);\n-    let code_cell = GEP(bcx, pair, [C_int(ccx, 0),\n-                                    C_int(ccx, abi::fn_field_code)]);\n+    let code_cell = GEPi(bcx, pair, [0, abi::fn_field_code]);\n     Store(bcx, llfn, code_cell);\n-    let env_cell = GEP(bcx, pair, [C_int(ccx, 0),\n-                                   C_int(ccx, abi::fn_field_box)]);\n+    let env_cell = GEPi(bcx, pair, [0, abi::fn_field_box]);\n     let llenvblobptr =\n         PointerCast(bcx, llenvptr, T_opaque_closure_ptr(ccx));\n     Store(bcx, llenvblobptr, env_cell);\n@@ -5801,7 +5753,7 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n         r =\n             trans_native_call(new_raw_block_ctxt(bcx.fcx, bcx.llbb),\n                               ccx.externs, ccx.llmod, name, call_args);\n-        rptr = BitCast(bcx, fcx.llretptr, T_ptr(T_i32()));\n+        rptr = BitCast(bcx, fcx.llretptr, T_ptr(ccx.int_type));\n       }\n     }\n     // We don't store the return value if it's nil, to avoid stomping on a nil"}, {"sha": "ce9768d88a405707337a5765651e83126b745820", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "patch": "@@ -259,7 +259,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     if size > 0u && vec::len(variants) != 1u {\n         let tagptr =\n             PointerCast(bcx, val, trans_common::T_opaque_tag_ptr(ccx));\n-        blobptr = GEP(bcx, tagptr, [C_int(ccx, 0), C_int(ccx, 1)]);\n+        blobptr = GEPi(bcx, tagptr, [0, 1]);\n     }\n     let i = 0u;\n     let vdefs_tg = vdefs.tg;\n@@ -438,10 +438,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n         let box = Load(bcx, val);\n-        let unboxed =\n-            InBoundsGEP(bcx, box,\n-                        [C_int(ccx, 0),\n-                         C_int(ccx, back::abi::box_rc_field_body)]);\n+        let unboxed = GEPi(bcx, box, [0, back::abi::box_rc_field_body]);\n         compile_submatch(bcx, enter_box(m, col, val), [unboxed] + vals_left,\n                          f, exits);\n         ret;\n@@ -468,8 +465,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                 let tagptr =\n                     PointerCast(bcx, val,\n                                 trans_common::T_opaque_tag_ptr(ccx));\n-                let discrimptr = GEP(bcx, tagptr, [C_int(ccx, 0),\n-                                                   C_int(ccx, 0)]);\n+                let discrimptr = GEPi(bcx, tagptr, [0, 0]);\n                 test_val = Load(bcx, discrimptr);\n                 kind = switch;\n             }\n@@ -738,9 +734,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n       ast::pat_box(inner) {\n         let box = Load(bcx, val);\n         let unboxed =\n-            InBoundsGEP(bcx, box,\n-                        [C_int(ccx, 0),\n-                         C_int(ccx, back::abi::box_rc_field_body)]);\n+            GEPi(bcx, box, [0, back::abi::box_rc_field_body]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) {"}, {"sha": "fbc96d5c21db4311d4327a01662087dbb8e6d33c", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "patch": "@@ -4,7 +4,7 @@ import lib::llvm::llvm;\n import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, Opcode,\n               ModuleRef};\n import trans_common::{block_ctxt, T_ptr, T_nil, T_int, T_i8, T_i1,\n-                      val_ty, val_str, bcx_ccx};\n+                      val_ty, val_str, bcx_ccx, C_i32};\n \n fn B(cx: @block_ctxt) -> BuilderRef {\n     let b = *cx.fcx.lcx.ccx.builder;\n@@ -325,6 +325,14 @@ fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     }\n }\n \n+// Simple wrapper around GEP that takes an array of ints and wraps them\n+// in C_i32()\n+fn GEPi(cx: @block_ctxt, base: ValueRef, ixs: [int]) -> ValueRef {\n+    let v: [ValueRef] = [];\n+    for i: int in ixs { v += [C_i32(i as i32)]; }\n+    ret InBoundsGEP(cx, base, v);\n+}\n+\n fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }"}, {"sha": "8580f53a6243cb9fbe2ce76e1f58b13c5cef9417", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "patch": "@@ -770,6 +770,10 @@ fn C_bool(b: bool) -> ValueRef {\n     } else { ret C_integral(T_bool(), 0u, False); }\n }\n \n+fn C_i32(i: i32) -> ValueRef {\n+    ret C_integral(T_i32(), i as uint, True);\n+}\n+\n fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n     ret C_integral(cx.int_type, i as uint, True);\n }"}, {"sha": "5df7164328cca7c9d4d7d3ac9ad0e5ae87a9bd3a", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=4bd05e5be2e28e8afcb42db1fe3fd5cbba7ad56b", "patch": "@@ -8,16 +8,16 @@ import trans::{call_memmove, trans_shared_malloc, llsize_of, type_of_or_i8,\n                llderivedtydescs_block_ctxt, lazily_emit_tydesc_glue,\n                get_tydesc, load_inbounds,\n                node_id_type, new_sub_block_ctxt, tps_normal, do_spill_noroot,\n-               GEPi, alloc_ty, dest};\n+               alloc_ty, dest};\n import trans_build::*;\n import trans_common::*;\n \n fn get_fill(bcx: @block_ctxt, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, GEPi(bcx, vptr, [0, abi::vec_elt_fill as int]))\n+    Load(bcx, GEPi(bcx, vptr, [0, abi::vec_elt_fill]))\n }\n fn get_dataptr(bcx: @block_ctxt, vptr: ValueRef, unit_ty: TypeRef)\n     -> ValueRef {\n-    let ptr = GEPi(bcx, vptr, [0, abi::vec_elt_elems as int]);\n+    let ptr = GEPi(bcx, vptr, [0, abi::vec_elt_elems]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n@@ -33,12 +33,8 @@ fn alloc_raw(bcx: @block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n     let {bcx: bcx, val: vecptr} =\n         trans_shared_malloc(bcx, T_ptr(llvecty), vecsize);\n-    Store(bcx, fill,\n-          InBoundsGEP(bcx, vecptr, [C_int(ccx, 0),\n-                                    C_uint(ccx, abi::vec_elt_fill)]));\n-    Store(bcx, alloc,\n-          InBoundsGEP(bcx, vecptr, [C_int(ccx, 0),\n-                                    C_uint(ccx, abi::vec_elt_alloc)]));\n+    Store(bcx, fill, GEPi(bcx, vecptr, [0, abi::vec_elt_fill]));\n+    Store(bcx, alloc, GEPi(bcx, vecptr, [0, abi::vec_elt_alloc]));\n     ret {bcx: bcx, val: vecptr};\n }\n \n@@ -80,9 +76,7 @@ fn duplicate(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) -> result {\n         trans_shared_malloc(bcx, val_ty(vptr), size);\n     let bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n-    Store(bcx, fill,\n-          InBoundsGEP(bcx, newptr, [C_int(ccx, 0),\n-                                    C_uint(ccx, abi::vec_elt_alloc)]));\n+    Store(bcx, fill, GEPi(bcx, newptr, [0, abi::vec_elt_alloc]));\n     if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n         bcx = iter_vec(bcx, newptr, vec_ty, trans::take_ty);\n     }"}]}