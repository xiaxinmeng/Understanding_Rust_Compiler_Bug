{"sha": "0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMDRhYTc4ZTVlOGE3ZTNjNDgxNDEwMjgxMzdjMWE2OWU3ZTMyZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-19T11:10:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-19T11:10:32Z"}, "message": "auto merge of #7871 : pcwalton/rust/de-at-match, r=brson\n\nThis will be needed to add `'static` bounds to `@`.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "c8952dbe4a2702c9bc11e58619bc1d24da4dc835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8952dbe4a2702c9bc11e58619bc1d24da4dc835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "html_url": "https://github.com/rust-lang/rust/commit/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32586faa6adb890bc25caa8b5cb692e8c37e4a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/32586faa6adb890bc25caa8b5cb692e8c37e4a89", "html_url": "https://github.com/rust-lang/rust/commit/32586faa6adb890bc25caa8b5cb692e8c37e4a89"}, {"sha": "458b564601f1373505086cd714927d38e32727ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/458b564601f1373505086cd714927d38e32727ca", "html_url": "https://github.com/rust-lang/rust/commit/458b564601f1373505086cd714927d38e32727ca"}], "stats": {"total": 154, "additions": 91, "deletions": 63}, "files": [{"sha": "b125232a7aac857ac02c4dbcf946d8f1a42480a7", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 91, "deletions": 63, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "patch": "@@ -17,8 +17,8 @@\n  *\n  * ## Matching\n  *\n- * The basic state of the code is maintained in an array `m` of `@Match`\n- * objects.  Each `@Match` describes some list of patterns, all of which must\n+ * The basic state of the code is maintained in an array `m` of `Match`\n+ * objects.  Each `Match` describes some list of patterns, all of which must\n  * match against the current list of values.  If those patterns match, then\n  * the arm listed in the match is the correct arm.  A given arm may have\n  * multiple corresponding match entries, one for each alternative that\n@@ -316,6 +316,7 @@ pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n     }\n }\n \n+#[deriving(Clone)]\n pub enum TransBindingMode {\n     TrByValue(/*llbinding:*/ ValueRef),\n     TrByRef,\n@@ -329,6 +330,7 @@ pub enum TransBindingMode {\n  * - `trmode` is the trans binding mode\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n+ #[deriving(Clone)]\n pub struct BindingInfo {\n     llmatch: ValueRef,\n     trmode: TransBindingMode,\n@@ -338,15 +340,17 @@ pub struct BindingInfo {\n \n pub type BindingsMap = HashMap<ident, BindingInfo>;\n \n+#[deriving(Clone)]\n pub struct ArmData<'self> {\n     bodycx: block,\n     arm: &'self ast::arm,\n-    bindings_map: BindingsMap\n+    bindings_map: @BindingsMap\n }\n \n+#[deriving(Clone)]\n pub struct Match<'self> {\n     pats: ~[@ast::pat],\n-    data: @ArmData<'self>\n+    data: ArmData<'self>\n }\n \n pub fn match_to_str(bcx: block, m: &Match) -> ~str {\n@@ -358,11 +362,11 @@ pub fn match_to_str(bcx: block, m: &Match) -> ~str {\n     }\n }\n \n-pub fn matches_to_str(bcx: block, m: &[@Match]) -> ~str {\n-    fmt!(\"%?\", m.map(|n| match_to_str(bcx, *n)))\n+pub fn matches_to_str(bcx: block, m: &[Match]) -> ~str {\n+    fmt!(\"%?\", m.map(|n| match_to_str(bcx, n)))\n }\n \n-pub fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n+pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for m.iter().advance |br| {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n@@ -373,10 +377,10 @@ pub fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n }\n \n pub fn expand_nested_bindings<'r>(bcx: block,\n-                                  m: &[@Match<'r>],\n+                                  m: &[Match<'r>],\n                                   col: uint,\n                                   val: ValueRef)\n-                              -> ~[@Match<'r>] {\n+                              -> ~[Match<'r>] {\n     debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -397,11 +401,12 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n                     br.data.bindings_map.get(&path_to_ident(path));\n \n                 Store(bcx, val, binding_info.llmatch);\n-                @Match {pats: pats, data: br.data}\n-            }\n-            _ => {\n-                *br\n+                Match {\n+                    pats: pats,\n+                    data: br.data.clone()\n+                }\n             }\n+            _ => (*br).clone(),\n         }\n     }\n }\n@@ -419,11 +424,11 @@ pub type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n pub fn enter_match<'r>(bcx: block,\n                        dm: DefMap,\n-                       m: &[@Match<'r>],\n+                       m: &[Match<'r>],\n                        col: uint,\n                        val: ValueRef,\n                        e: enter_pat)\n-                    -> ~[@Match<'r>] {\n+                    -> ~[Match<'r>] {\n     debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -453,7 +458,10 @@ pub fn enter_match<'r>(bcx: block,\n                     _ => {}\n                 }\n \n-                result.push(@Match {pats: pats, data: br.data});\n+                result.push(Match {\n+                    pats: pats,\n+                    data: br.data.clone()\n+                });\n             }\n             None => ()\n         }\n@@ -466,10 +474,10 @@ pub fn enter_match<'r>(bcx: block,\n \n pub fn enter_default<'r>(bcx: block,\n                          dm: DefMap,\n-                         m: &[@Match<'r>],\n+                         m: &[Match<'r>],\n                          col: uint,\n                          val: ValueRef)\n-                      -> ~[@Match<'r>] {\n+                      -> ~[Match<'r>] {\n     debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -511,12 +519,12 @@ pub fn enter_default<'r>(bcx: block,\n //             wildcards\n \n pub fn enter_opt<'r>(bcx: block,\n-                     m: &[@Match<'r>],\n+                     m: &[Match<'r>],\n                      opt: &Opt,\n                      col: uint,\n                      variant_size: uint,\n                      val: ValueRef)\n-                  -> ~[@Match<'r>] {\n+                  -> ~[Match<'r>] {\n     debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -624,11 +632,11 @@ pub fn enter_opt<'r>(bcx: block,\n \n pub fn enter_rec_or_struct<'r>(bcx: block,\n                                dm: DefMap,\n-                               m: &[@Match<'r>],\n+                               m: &[Match<'r>],\n                                col: uint,\n                                fields: &[ast::ident],\n                                val: ValueRef)\n-                            -> ~[@Match<'r>] {\n+                            -> ~[Match<'r>] {\n     debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -659,11 +667,11 @@ pub fn enter_rec_or_struct<'r>(bcx: block,\n \n pub fn enter_tup<'r>(bcx: block,\n                      dm: DefMap,\n-                     m: &[@Match<'r>],\n+                     m: &[Match<'r>],\n                      col: uint,\n                      val: ValueRef,\n                      n_elts: uint)\n-                  -> ~[@Match<'r>] {\n+                  -> ~[Match<'r>] {\n     debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -685,11 +693,11 @@ pub fn enter_tup<'r>(bcx: block,\n \n pub fn enter_tuple_struct<'r>(bcx: block,\n                               dm: DefMap,\n-                              m: &[@Match<'r>],\n+                              m: &[Match<'r>],\n                               col: uint,\n                               val: ValueRef,\n                               n_elts: uint)\n-                          -> ~[@Match<'r>] {\n+                          -> ~[Match<'r>] {\n     debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -711,10 +719,10 @@ pub fn enter_tuple_struct<'r>(bcx: block,\n \n pub fn enter_box<'r>(bcx: block,\n                      dm: DefMap,\n-                     m: &[@Match<'r>],\n+                     m: &[Match<'r>],\n                      col: uint,\n                      val: ValueRef)\n-                 -> ~[@Match<'r>] {\n+                 -> ~[Match<'r>] {\n     debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -738,10 +746,10 @@ pub fn enter_box<'r>(bcx: block,\n \n pub fn enter_uniq<'r>(bcx: block,\n                       dm: DefMap,\n-                      m: &[@Match<'r>],\n+                      m: &[Match<'r>],\n                       col: uint,\n                       val: ValueRef)\n-                  -> ~[@Match<'r>] {\n+                  -> ~[Match<'r>] {\n     debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -765,10 +773,10 @@ pub fn enter_uniq<'r>(bcx: block,\n \n pub fn enter_region<'r>(bcx: block,\n                         dm: DefMap,\n-                        m: &[@Match<'r>],\n+                        m: &[Match<'r>],\n                         col: uint,\n                         val: ValueRef)\n-                    -> ~[@Match<'r>] {\n+                    -> ~[Match<'r>] {\n     debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -793,7 +801,7 @@ pub fn enter_region<'r>(bcx: block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n+pub fn get_options(bcx: block, m: &[Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -943,7 +951,7 @@ pub fn extract_vec_elems(bcx: block,\n \n // NB: This function does not collect fields from struct-like enum variants.\n pub fn collect_record_or_struct_fields(bcx: block,\n-                                       m: &[@Match],\n+                                       m: &[Match],\n                                        col: uint)\n                                     -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n@@ -971,7 +979,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n }\n \n pub fn pats_require_rooting(bcx: block,\n-                            m: &[@Match],\n+                            m: &[Match],\n                             col: uint)\n                          -> bool {\n     do m.iter().any |br| {\n@@ -982,7 +990,7 @@ pub fn pats_require_rooting(bcx: block,\n }\n \n pub fn root_pats_as_necessary(mut bcx: block,\n-                              m: &[@Match],\n+                              m: &[Match],\n                               col: uint,\n                               val: ValueRef)\n                            -> block {\n@@ -1012,23 +1020,23 @@ macro_rules! any_pat (\n     )\n )\n \n-pub fn any_box_pat(m: &[@Match], col: uint) -> bool {\n+pub fn any_box_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_box(_))\n }\n \n-pub fn any_uniq_pat(m: &[@Match], col: uint) -> bool {\n+pub fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_uniq(_))\n }\n \n-pub fn any_region_pat(m: &[@Match], col: uint) -> bool {\n+pub fn any_region_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_region(_))\n }\n \n-pub fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n+pub fn any_tup_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_tup(_))\n }\n \n-pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n+pub fn any_tuple_struct_pat(bcx: block, m: &[Match], col: uint) -> bool {\n     do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -1046,7 +1054,7 @@ pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n \n pub type mk_fail = @fn() -> BasicBlockRef;\n \n-pub fn pick_col(m: &[@Match]) -> uint {\n+pub fn pick_col(m: &[Match]) -> uint {\n     fn score(p: &ast::pat) -> uint {\n         match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n@@ -1201,7 +1209,7 @@ fn insert_lllocals(bcx: block,\n pub fn compile_guard(bcx: block,\n                      guard_expr: @ast::expr,\n                      data: &ArmData,\n-                     m: &[@Match],\n+                     m: &[Match],\n                      vals: &[ValueRef],\n                      chk: Option<mk_fail>)\n                   -> block {\n@@ -1214,8 +1222,10 @@ pub fn compile_guard(bcx: block,\n \n     let mut bcx = bcx;\n     let mut temp_cleanups = ~[];\n-    bcx = store_non_ref_bindings(bcx, &data.bindings_map, Some(&mut temp_cleanups));\n-    bcx = insert_lllocals(bcx, &data.bindings_map, BindLocal, false);\n+    bcx = store_non_ref_bindings(bcx,\n+                                 data.bindings_map,\n+                                 Some(&mut temp_cleanups));\n+    bcx = insert_lllocals(bcx, data.bindings_map, BindLocal, false);\n \n     let val = unpack_result!(bcx, {\n         do with_scope_result(bcx, guard_expr.info(),\n@@ -1254,7 +1264,7 @@ pub fn compile_guard(bcx: block,\n }\n \n pub fn compile_submatch(bcx: block,\n-                        m: &[@Match],\n+                        m: &[Match],\n                         vals: &[ValueRef],\n                         chk: Option<mk_fail>) {\n     debug!(\"compile_submatch(bcx=%s, m=%s, vals=%?)\",\n@@ -1276,12 +1286,15 @@ pub fn compile_submatch(bcx: block,\n         return;\n     }\n     if m[0].pats.len() == 0u {\n-        let data = m[0].data;\n+        let data = &m[0].data;\n         match data.arm.guard {\n             Some(guard_expr) => {\n-                bcx = compile_guard(bcx, guard_expr, m[0].data,\n+                bcx = compile_guard(bcx,\n+                                    guard_expr,\n+                                    &m[0].data,\n                                     m.slice(1, m.len()),\n-                                    vals, chk);\n+                                    vals,\n+                                    chk);\n             }\n             _ => ()\n         }\n@@ -1291,13 +1304,23 @@ pub fn compile_submatch(bcx: block,\n \n     let col = pick_col(m);\n     let val = vals[col];\n-    let m = {\n-        if has_nested_bindings(m, col) {\n-            expand_nested_bindings(bcx, m, col, val)\n-        } else {\n-            m.to_owned()\n-        }\n-    };\n+\n+    if has_nested_bindings(m, col) {\n+        let expanded = expand_nested_bindings(bcx, m, col, val);\n+        compile_submatch_continue(bcx, expanded, vals, chk, col, val)\n+    } else {\n+        compile_submatch_continue(bcx, m, vals, chk, col, val)\n+    }\n+}\n+\n+fn compile_submatch_continue(mut bcx: block,\n+                             m: &[Match],\n+                             vals: &[ValueRef],\n+                             chk: Option<mk_fail>,\n+                             col: uint,\n+                             val: ValueRef) {\n+    let tcx = bcx.tcx();\n+    let dm = tcx.def_map;\n \n     let vals_left = vec::append(vals.slice(0u, col).to_owned(),\n                                 vals.slice(col + 1u, vals.len()));\n@@ -1670,12 +1693,17 @@ pub fn trans_match_inner(scope_cx: block,\n     for arms.iter().advance |arm| {\n         let body = scope_block(bcx, arm.body.info(), \"case_body\");\n         let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n-        let arm_data = @ArmData {bodycx: body,\n-                                 arm: arm,\n-                                 bindings_map: bindings_map};\n-        arm_datas.push(arm_data);\n+        let arm_data = ArmData {\n+            bodycx: body,\n+            arm: arm,\n+            bindings_map: @bindings_map\n+        };\n+        arm_datas.push(arm_data.clone());\n         for arm.pats.iter().advance |p| {\n-            matches.push(@Match {pats: ~[*p], data: arm_data});\n+            matches.push(Match {\n+                pats: ~[*p],\n+                data: arm_data.clone(),\n+            });\n         }\n     }\n \n@@ -1703,11 +1731,11 @@ pub fn trans_match_inner(scope_cx: block,\n         // is just to reduce code space.  See extensive comment at the start\n         // of the file for more details.\n         if arm_data.arm.guard.is_none() {\n-            bcx = store_non_ref_bindings(bcx, &arm_data.bindings_map, None);\n+            bcx = store_non_ref_bindings(bcx, arm_data.bindings_map, None);\n         }\n \n         // insert bindings into the lllocals map and add cleanups\n-        bcx = insert_lllocals(bcx, &arm_data.bindings_map, BindLocal, true);\n+        bcx = insert_lllocals(bcx, arm_data.bindings_map, BindLocal, true);\n \n         bcx = controlflow::trans_block(bcx, &arm_data.arm.body, dest);\n         bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));"}]}