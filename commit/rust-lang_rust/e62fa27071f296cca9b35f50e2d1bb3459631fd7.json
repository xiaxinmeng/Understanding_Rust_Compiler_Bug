{"sha": "e62fa27071f296cca9b35f50e2d1bb3459631fd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MmZhMjcwNzFmMjk2Y2NhOWIzNWY1MGUyZDFiYjM0NTk2MzFmZDc=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-05-19T06:47:48Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-05-19T06:47:48Z"}, "message": "Refactor borrowck to share more code with fact dumping\n\nFollowing up my changes in #50798, I wanted to grab at least the low-hanging\nfruit for code deduplication.", "tree": {"sha": "b144c12c0d6daccd5326c98e2529a45e50e83792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b144c12c0d6daccd5326c98e2529a45e50e83792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e62fa27071f296cca9b35f50e2d1bb3459631fd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e62fa27071f296cca9b35f50e2d1bb3459631fd7", "html_url": "https://github.com/rust-lang/rust/commit/e62fa27071f296cca9b35f50e2d1bb3459631fd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e62fa27071f296cca9b35f50e2d1bb3459631fd7/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "965eef92c45297e2c54ca429e1c1bf7e324f3351", "url": "https://api.github.com/repos/rust-lang/rust/commits/965eef92c45297e2c54ca429e1c1bf7e324f3351", "html_url": "https://github.com/rust-lang/rust/commit/965eef92c45297e2c54ca429e1c1bf7e324f3351"}], "stats": {"total": 1551, "additions": 583, "deletions": 968}, "files": [{"sha": "82f06232b8e0a764907ff15f6f6e27aad9397797", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 493, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/e62fa27071f296cca9b35f50e2d1bb3459631fd7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62fa27071f296cca9b35f50e2d1bb3459631fd7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e62fa27071f296cca9b35f50e2d1bb3459631fd7", "patch": "@@ -46,20 +46,21 @@ use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n use util::collect_writes::FindAssignments;\n \n-use std::iter;\n-\n use self::borrow_set::{BorrowSet, BorrowData};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n+use self::path_utils::*;\n+\n crate mod borrow_set;\n mod error_reporting;\n mod flows;\n mod location;\n crate mod place_ext;\n mod prefixes;\n+mod path_utils;\n \n pub(crate) mod nll;\n \n@@ -657,12 +658,6 @@ enum MutateMode {\n     WriteAndRead,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum Control {\n-    Continue,\n-    Break,\n-}\n-\n use self::ShallowOrDeep::{Deep, Shallow};\n use self::ReadOrWrite::{Activation, Read, Reservation, Write};\n \n@@ -782,15 +777,6 @@ impl InitializationRequiringAction {\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    /// Returns true if the borrow represented by `kind` is\n-    /// allowed to be split into separate Reservation and\n-    /// Activation phases.\n-    fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n-        self.tcx.two_phase_borrows()\n-            && (kind.allows_two_phase_borrow()\n-                || self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n-    }\n-\n     /// Invokes `access_place` as appropriate for dropping the value\n     /// at `drop_place`. Note that the *actual* `Drop` in the MIR is\n     /// always for a variable (e.g., `Drop(x)`) -- but we recursively\n@@ -950,11 +936,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let mut error_reported = false;\n-        self.each_borrow_involving_path(\n+        let tcx = self.tcx;\n+        let mir = self.mir;\n+        let borrow_set = self.borrow_set.clone();\n+        each_borrow_involving_path(\n+            self,\n+            tcx,\n+            mir,\n             context,\n             (sd, place_span.0),\n-            flow_state,\n-            |this, borrow_index, borrow| match (rw, borrow.kind) {\n+            &borrow_set,\n+            flow_state.borrows_in_scope(),\n+            |this: &mut Self, borrow_index: BorrowIndex, borrow: &BorrowData<'tcx>|\n+            match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n                 // borrow); so don't check if they interfere.\n@@ -979,8 +973,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if !this.is_active(borrow, context.loc) {\n-                        assert!(this.allow_two_phase_borrow(borrow.kind));\n+                    if !is_active(&this.dominators, borrow, context.loc) {\n+                        assert!(allow_two_phase_borrow(&this.tcx, borrow.kind));\n                         return Control::Continue;\n                     }\n \n@@ -1115,7 +1109,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n-                        if self.allow_two_phase_borrow(bk) {\n+                        if allow_two_phase_borrow(&self.tcx, bk) {\n                             (Deep, Reservation(wk))\n                         } else {\n                             (Deep, Write(wk))\n@@ -1310,7 +1304,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // that is merged.\n         let sd = if might_be_alive { Deep } else { Shallow(None) };\n \n-        if self.places_conflict(place, root_place, sd) {\n+        if places_conflict(self.tcx, self.mir, place, root_place, sd) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead\n             // of just a span here.\n@@ -1326,27 +1320,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Reports an error if this is a borrow of local data.\n     /// This is called for all Yield statements on movable generators\n     fn check_for_local_borrow(&mut self, borrow: &BorrowData<'tcx>, yield_span: Span) {\n-        fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n-            match place {\n-                Place::Static(..) => false,\n-                Place::Local(..) => true,\n-                Place::Projection(box proj) => {\n-                    match proj.elem {\n-                        // Reborrow of already borrowed data is ignored\n-                        // Any errors will be caught on the initial borrow\n-                        ProjectionElem::Deref => false,\n-\n-                        // For interior references and downcasts, find out if the base is local\n-                        ProjectionElem::Field(..)\n-                        | ProjectionElem::Index(..)\n-                        | ProjectionElem::ConstantIndex { .. }\n-                        | ProjectionElem::Subslice { .. }\n-                        | ProjectionElem::Downcast(..) => borrow_of_local_data(&proj.base),\n-                    }\n-                }\n-            }\n-        }\n-\n         debug!(\"check_for_local_borrow({:?})\", borrow);\n \n         if borrow_of_local_data(&borrow.borrowed_place) {\n@@ -1420,7 +1393,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         for i in flow_state.ever_inits.iter_incoming() {\n             let init = self.move_data.inits[i];\n             let init_place = &self.move_data.move_paths[init.path].place;\n-            if self.places_conflict(&init_place, place, Deep) {\n+            if places_conflict(self.tcx, self.mir, &init_place, place, Deep) {\n                 self.report_illegal_reassignment(context, (place, span), init.span);\n                 break;\n             }\n@@ -2063,453 +2036,6 @@ enum Overlap {\n     Disjoint,\n }\n \n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    // Given that the bases of `elem1` and `elem2` are always either equal\n-    // or disjoint (and have the same type!), return the overlap situation\n-    // between `elem1` and `elem2`.\n-    fn place_element_conflict(&self, elem1: &Place<'tcx>, elem2: &Place<'tcx>) -> Overlap {\n-        match (elem1, elem2) {\n-            (Place::Local(l1), Place::Local(l2)) => {\n-                if l1 == l2 {\n-                    // the same local - base case, equal\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n-                    Overlap::EqualOrDisjoint\n-                } else {\n-                    // different locals - base case, disjoint\n-                    debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n-                    Overlap::Disjoint\n-                }\n-            }\n-            (Place::Static(static1), Place::Static(static2)) => {\n-                if static1.def_id != static2.def_id {\n-                    debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                    Overlap::Disjoint\n-                } else if self.tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n-                    // We ignore mutable statics - they can only be unsafe code.\n-                    debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                    Overlap::Disjoint\n-                } else {\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                    Overlap::EqualOrDisjoint\n-                }\n-            }\n-            (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n-                Overlap::Disjoint\n-            }\n-            (Place::Projection(pi1), Place::Projection(pi2)) => {\n-                match (&pi1.elem, &pi2.elem) {\n-                    (ProjectionElem::Deref, ProjectionElem::Deref) => {\n-                        // derefs (e.g. `*x` vs. `*x`) - recur.\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n-                        Overlap::EqualOrDisjoint\n-                    }\n-                    (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n-                        if f1 == f2 {\n-                            // same field (e.g. `a.y` vs. `a.y`) - recur.\n-                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                            Overlap::EqualOrDisjoint\n-                        } else {\n-                            let ty = pi1.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                            match ty.sty {\n-                                ty::TyAdt(def, _) if def.is_union() => {\n-                                    // Different fields of a union, we are basically stuck.\n-                                    debug!(\"place_element_conflict: STUCK-UNION\");\n-                                    Overlap::Arbitrary\n-                                }\n-                                _ => {\n-                                    // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n-                                    debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                                    Overlap::Disjoint\n-                                }\n-                            }\n-                        }\n-                    }\n-                    (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n-                        // different variants are treated as having disjoint fields,\n-                        // even if they occupy the same \"space\", because it's\n-                        // impossible for 2 variants of the same enum to exist\n-                        // (and therefore, to be borrowed) at the same time.\n-                        //\n-                        // Note that this is different from unions - we *do* allow\n-                        // this code to compile:\n-                        //\n-                        // ```\n-                        // fn foo(x: &mut Result<i32, i32>) {\n-                        //     let mut v = None;\n-                        //     if let Ok(ref mut a) = *x {\n-                        //         v = Some(a);\n-                        //     }\n-                        //     // here, you would *think* that the\n-                        //     // *entirety* of `x` would be borrowed,\n-                        //     // but in fact only the `Ok` variant is,\n-                        //     // so the `Err` variant is *entirely free*:\n-                        //     if let Err(ref mut a) = *x {\n-                        //         v = Some(a);\n-                        //     }\n-                        //     drop(v);\n-                        // }\n-                        // ```\n-                        if v1 == v2 {\n-                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                            Overlap::EqualOrDisjoint\n-                        } else {\n-                            debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                            Overlap::Disjoint\n-                        }\n-                    }\n-                    (ProjectionElem::Index(..), ProjectionElem::Index(..))\n-                    | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n-                    | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n-                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n-                    | (\n-                        ProjectionElem::ConstantIndex { .. },\n-                        ProjectionElem::ConstantIndex { .. },\n-                    )\n-                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n-                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n-                    | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n-                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n-                        // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n-                        // (if the indexes differ) or equal (if they are the same), so this\n-                        // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n-                        //\n-                        // Note that by construction, MIR at borrowck can't subdivide\n-                        // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n-                        // are only present in slice patterns, and we \"merge together\" nested\n-                        // slice patterns. That means we don't have to think about these. It's\n-                        // probably a good idea to assert this somewhere, but I'm too lazy.\n-                        //\n-                        // FIXME(#8636) we might want to return Disjoint if\n-                        // both projections are constant and disjoint.\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n-                        Overlap::EqualOrDisjoint\n-                    }\n-\n-                    (ProjectionElem::Deref, _)\n-                    | (ProjectionElem::Field(..), _)\n-                    | (ProjectionElem::Index(..), _)\n-                    | (ProjectionElem::ConstantIndex { .. }, _)\n-                    | (ProjectionElem::Subslice { .. }, _)\n-                    | (ProjectionElem::Downcast(..), _) => bug!(\n-                        \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-                        elem1,\n-                        elem2\n-                    ),\n-                }\n-            }\n-            (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n-                \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n-                elem1,\n-                elem2\n-            ),\n-        }\n-    }\n-\n-    /// Returns whether an access of kind `access` to `access_place` conflicts with\n-    /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n-    /// locations, this function is symmetric between `borrow_place` & `access_place`).\n-    fn places_conflict(\n-        &mut self,\n-        borrow_place: &Place<'tcx>,\n-        access_place: &Place<'tcx>,\n-        access: ShallowOrDeep,\n-    ) -> bool {\n-        debug!(\n-            \"places_conflict({:?},{:?},{:?})\",\n-            borrow_place, access_place, access\n-        );\n-\n-        // Return all the prefixes of `place` in reverse order, including\n-        // downcasts.\n-        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>> {\n-            let mut result = vec![];\n-            let mut place = place;\n-            loop {\n-                result.push(place);\n-                match place {\n-                    Place::Projection(interior) => {\n-                        place = &interior.base;\n-                    }\n-                    Place::Local(_) | Place::Static(_) => {\n-                        result.reverse();\n-                        return result;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let borrow_components = place_elements(borrow_place);\n-        let access_components = place_elements(access_place);\n-        debug!(\n-            \"places_conflict: components {:?} / {:?}\",\n-            borrow_components, access_components\n-        );\n-\n-        let borrow_components = borrow_components\n-            .into_iter()\n-            .map(Some)\n-            .chain(iter::repeat(None));\n-        let access_components = access_components\n-            .into_iter()\n-            .map(Some)\n-            .chain(iter::repeat(None));\n-        // The borrowck rules for proving disjointness are applied from the \"root\" of the\n-        // borrow forwards, iterating over \"similar\" projections in lockstep until\n-        // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n-        // a monoid and report a conflict if the product ends up not being `Disjoint`.\n-        //\n-        // At each step, if we didn't run out of borrow or place, we know that our elements\n-        // have the same type, and that they only overlap if they are the identical.\n-        //\n-        // For example, if we are comparing these:\n-        // BORROW:  (*x1[2].y).z.a\n-        // ACCESS:  (*x1[i].y).w.b\n-        //\n-        // Then our steps are:\n-        //       x1         |   x1          -- places are the same\n-        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n-        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n-        //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n-        //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n-        //\n-        // Because `zip` does potentially bad things to the iterator inside, this loop\n-        // also handles the case where the access might be a *prefix* of the borrow, e.g.\n-        //\n-        // BORROW:  (*x1[2].y).z.a\n-        // ACCESS:  x1[i].y\n-        //\n-        // Then our steps are:\n-        //       x1         |   x1          -- places are the same\n-        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n-        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n-        //\n-        // -- here we run out of access - the borrow can access a part of it. If this\n-        // is a full deep access, then we *know* the borrow conflicts with it. However,\n-        // if the access is shallow, then we can proceed:\n-        //\n-        //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n-        //                                     are disjoint\n-        //\n-        // Our invariant is, that at each step of the iteration:\n-        //  - If we didn't run out of access to match, our borrow and access are comparable\n-        //    and either equal or disjoint.\n-        //  - If we did run out of accesss, the borrow can access a part of it.\n-        for (borrow_c, access_c) in borrow_components.zip(access_components) {\n-            // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-            debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n-            match (borrow_c, access_c) {\n-                (None, _) => {\n-                    // If we didn't run out of access, the borrow can access all of our\n-                    // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n-                    // so we have a conflict.\n-                    //\n-                    // If we did, then we still know that the borrow can access a *part*\n-                    // of our place that our access cares about (a borrow of `a.b.c`\n-                    // with an access to `a.b`), so we still have a conflict.\n-                    //\n-                    // FIXME: Differs from AST-borrowck; includes drive-by fix\n-                    // to #38899. Will probably need back-compat mode flag.\n-                    debug!(\"places_conflict: full borrow, CONFLICT\");\n-                    return true;\n-                }\n-                (Some(borrow_c), None) => {\n-                    // We know that the borrow can access a part of our place. This\n-                    // is a conflict if that is a part our access cares about.\n-\n-                    let (base, elem) = match borrow_c {\n-                        Place::Projection(box Projection { base, elem }) => (base, elem),\n-                        _ => bug!(\"place has no base?\"),\n-                    };\n-                    let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-                    match (elem, &base_ty.sty, access) {\n-                        (_, _, Shallow(Some(ArtificialField::Discriminant)))\n-                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n-                            // The discriminant and array length are like\n-                            // additional fields on the type; they do not\n-                            // overlap any existing data there. Furthermore,\n-                            // they cannot actually be a prefix of any\n-                            // borrowed place (at least in MIR as it is\n-                            // currently.)\n-                            //\n-                            // e.g. a (mutable) borrow of `a[5]` while we read the\n-                            // array length of `a`.\n-                            debug!(\"places_conflict: implicit field\");\n-                            return false;\n-                        }\n-\n-                        (ProjectionElem::Deref, _, Shallow(None)) => {\n-                            // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n-                            // prefix thereof - the shallow access can't touch anything behind\n-                            // the pointer.\n-                            debug!(\"places_conflict: shallow access behind ptr\");\n-                            return false;\n-                        }\n-                        (\n-                            ProjectionElem::Deref,\n-                            ty::TyRef( _, _, hir::MutImmutable),\n-                            _,\n-                        ) => {\n-                            // the borrow goes through a dereference of a shared reference.\n-                            //\n-                            // I'm not sure why we are tracking these borrows - shared\n-                            // references can *always* be aliased, which means the\n-                            // permission check already account for this borrow.\n-                            debug!(\"places_conflict: behind a shared ref\");\n-                            return false;\n-                        }\n-\n-                        (ProjectionElem::Deref, _, Deep)\n-                        | (ProjectionElem::Field { .. }, _, _)\n-                        | (ProjectionElem::Index { .. }, _, _)\n-                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n-                        | (ProjectionElem::Subslice { .. }, _, _)\n-                        | (ProjectionElem::Downcast { .. }, _, _) => {\n-                            // Recursive case. This can still be disjoint on a\n-                            // further iteration if this a shallow access and\n-                            // there's a deref later on, e.g. a borrow\n-                            // of `*x.y` while accessing `x`.\n-                        }\n-                    }\n-                }\n-                (Some(borrow_c), Some(access_c)) => {\n-                    match self.place_element_conflict(&borrow_c, access_c) {\n-                        Overlap::Arbitrary => {\n-                            // We have encountered different fields of potentially\n-                            // the same union - the borrow now partially overlaps.\n-                            //\n-                            // There is no *easy* way of comparing the fields\n-                            // further on, because they might have different types\n-                            // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n-                            // `.y` come from different structs).\n-                            //\n-                            // We could try to do some things here - e.g. count\n-                            // dereferences - but that's probably not a good\n-                            // idea, at least for now, so just give up and\n-                            // report a conflict. This is unsafe code anyway so\n-                            // the user could always use raw pointers.\n-                            debug!(\"places_conflict: arbitrary -> conflict\");\n-                            return true;\n-                        }\n-                        Overlap::EqualOrDisjoint => {\n-                            // This is the recursive case - proceed to the next element.\n-                        }\n-                        Overlap::Disjoint => {\n-                            // We have proven the borrow disjoint - further\n-                            // projections will remain disjoint.\n-                            debug!(\"places_conflict: disjoint\");\n-                            return false;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        unreachable!(\"iter::repeat returned None\")\n-    }\n-\n-    /// This function iterates over all of the in-scope borrows that\n-    /// conflict with an access to a place, invoking the `op` callback\n-    /// for each one.\n-    ///\n-    /// \"Current borrow\" here means a borrow that reaches the point in\n-    /// the control-flow where the access occurs.\n-    ///\n-    /// The borrow's phase is represented by the IsActive parameter\n-    /// passed to the callback.\n-    fn each_borrow_involving_path<F>(\n-        &mut self,\n-        _context: Context,\n-        access_place: (ShallowOrDeep, &Place<'tcx>),\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n-        mut op: F,\n-    ) where\n-        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n-    {\n-        let (access, place) = access_place;\n-\n-        // FIXME: analogous code in check_loans first maps `place` to\n-        // its base_path.\n-\n-        // check for loan restricting path P being used. Accounts for\n-        // borrows of P, P.a.b, etc.\n-        let borrow_set = self.borrow_set.clone();\n-        for i in flow_state.borrows_in_scope() {\n-            let borrowed = &borrow_set[i];\n-\n-            if self.places_conflict(&borrowed.borrowed_place, place, access) {\n-                debug!(\n-                    \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n-                    i, borrowed, place, access\n-                );\n-                let ctrl = op(self, i, borrowed);\n-                if ctrl == Control::Break {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    fn is_active(\n-        &self,\n-        borrow_data: &BorrowData<'tcx>,\n-        location: Location\n-    ) -> bool {\n-        debug!(\"is_active(borrow_data={:?}, location={:?})\", borrow_data, location);\n-\n-        // If this is not a 2-phase borrow, it is always active.\n-        let activation_location = match borrow_data.activation_location {\n-            Some(v) => v,\n-            None => return true,\n-        };\n-\n-        // Otherwise, it is active for every location *except* in between\n-        // the reservation and the activation:\n-        //\n-        //       X\n-        //      /\n-        //     R      <--+ Except for this\n-        //    / \\        | diamond\n-        //    \\ /        |\n-        //     A  <------+\n-        //     |\n-        //     Z\n-        //\n-        // Note that we assume that:\n-        // - the reservation R dominates the activation A\n-        // - the activation A post-dominates the reservation R (ignoring unwinding edges).\n-        //\n-        // This means that there can't be an edge that leaves A and\n-        // comes back into that diamond unless it passes through R.\n-        //\n-        // Suboptimal: In some cases, this code walks the dominator\n-        // tree twice when it only has to be walked once. I am\n-        // lazy. -nmatsakis\n-\n-        // If dominated by the activation A, then it is active. The\n-        // activation occurs upon entering the point A, so this is\n-        // also true if location == activation_location.\n-        if activation_location.dominates(location, &self.dominators) {\n-            return true;\n-        }\n-\n-        // The reservation starts *on exiting* the reservation block,\n-        // so check if the location is dominated by R.successor. If so,\n-        // this point falls in between the reservation and location.\n-        let reserve_location = borrow_data.reserve_location.successor_within_block();\n-        if reserve_location.dominates(location, &self.dominators) {\n-            false\n-        } else {\n-            // Otherwise, this point is outside the diamond, so\n-            // consider the borrow active. This could happen for\n-            // example if the borrow remains active around a loop (in\n-            // which case it would be active also for the point R,\n-            // which would generate an error).\n-            true\n-        }\n-    }\n-}\n-\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // FIXME (#16118): function intended to allow the borrow checker\n     // to be less precise in its handling of Box while still allowing"}, {"sha": "6c5e45a25af32f041ad61359cfe5a0e60143ee1f", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 57, "deletions": 475, "changes": 532, "blob_url": "https://github.com/rust-lang/rust/blob/e62fa27071f296cca9b35f50e2d1bb3459631fd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62fa27071f296cca9b35f50e2d1bb3459631fd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=e62fa27071f296cca9b35f50e2d1bb3459631fd7", "patch": "@@ -16,21 +16,20 @@ use borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n use borrow_check::{Context, ContextKind};\n use borrow_check::{LocalMutationIsAllowed, MutateMode};\n use borrow_check::ArtificialField;\n-use borrow_check::{ReadKind, WriteKind, Overlap};\n+use borrow_check::{ReadKind, WriteKind};\n use borrow_check::nll::facts::AllFacts;\n+use borrow_check::path_utils::*;\n use dataflow::move_paths::indexes::BorrowIndex;\n-use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, Location, Mir, Place, Rvalue, Projection};\n-use rustc::mir::{Local, ProjectionElem};\n+use rustc::mir::{BasicBlock, Location, Mir, Place, Rvalue, Local};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::mir::{Field, Operand, BorrowKind};\n use rustc::ty::{self, ParamEnv};\n use rustc_data_structures::indexed_vec::Idx;\n-use std::iter;\n+use rustc_data_structures::control_flow_graph::dominators::Dominators;\n \n pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -47,19 +46,19 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n \n     let param_env = infcx.tcx.param_env(mir_def_id);\n \n-    let mut all_facts_taken = all_facts.take().unwrap();\n-    {\n+    if let Some(all_facts) = all_facts {\n+        let dominators = mir.dominators();\n         let mut ig = InvalidationGenerator {\n-            all_facts: &mut all_facts_taken,\n+            all_facts,\n             borrow_set,\n             infcx,\n             location_table,\n             mir,\n+            dominators,\n             param_env,\n         };\n         ig.visit_mir(mir);\n     }\n-    *all_facts = Some(all_facts_taken);\n }\n \n /// 'cg = the duration of the constraint generation process itself.\n@@ -68,6 +67,7 @@ struct InvalidationGenerator<'cg, 'cx: 'cg, 'tcx: 'cx, 'gcx: 'tcx> {\n     all_facts: &'cg mut AllFacts,\n     location_table: &'cg LocationTable,\n     mir: &'cg Mir<'tcx>,\n+    dominators: Dominators<BasicBlock>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n     param_env: ParamEnv<'gcx>,\n }\n@@ -402,7 +402,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n-                        if self.allow_two_phase_borrow(bk) {\n+                        if allow_two_phase_borrow(&self.infcx.tcx, bk) {\n                             (Deep, Reservation(wk))\n                         } else {\n                             (Deep, Write(wk))\n@@ -484,487 +484,69 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n             sd,\n             rw,\n         );\n-        self.each_borrow_involving_path(\n+        let tcx = self.infcx.tcx;\n+        let mir = self.mir;\n+        let borrow_set = self.borrow_set.clone();\n+        let indices = self.borrow_set.borrows.indices();\n+        each_borrow_involving_path(\n+            self,\n+            tcx,\n+            mir,\n             context,\n             (sd, place),\n-            |this, borrow_index, borrow| match (rw, borrow.kind) {\n-                // Obviously an activation is compatible with its own\n-                // reservation (or even prior activating uses of same\n-                // borrow); so don't check if they interfere.\n-                //\n-                // NOTE: *reservations* do conflict with themselves;\n-                // thus aren't injecting unsoundenss w/ this check.)\n-                (Activation(_, activating), _) if activating == borrow_index => {\n-                    // Activating a borrow doesn't generate any invalidations, since we\n-                    // have already taken the reservation\n-                }\n-\n-                (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n-                    // Reads/reservations don't invalidate shared borrows\n-                }\n+            &borrow_set.clone(),\n+            indices,\n+            |this: &mut Self, borrow_index: BorrowIndex, borrow: &BorrowData<'tcx>| {\n+                match (rw, borrow.kind) {\n+                    // Obviously an activation is compatible with its own\n+                    // reservation (or even prior activating uses of same\n+                    // borrow); so don't check if they interfere.\n+                    //\n+                    // NOTE: *reservations* do conflict with themselves;\n+                    // thus aren't injecting unsoundenss w/ this check.)\n+                    (Activation(_, activating), _) if activating == borrow_index => {\n+                        // Activating a borrow doesn't generate any invalidations, since we\n+                        // have already taken the reservation\n+                    }\n \n-                (Read(_), BorrowKind::Unique) | (Read(_), BorrowKind::Mut { .. }) => {\n-                    // Reading from mere reservations of mutable-borrows is OK.\n-                    if !this.is_active(borrow, context.loc) {\n-                        // If the borrow isn't active yet, reads don't invalidate it\n-                        assert!(this.allow_two_phase_borrow(borrow.kind));\n-                        return;\n+                    (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                        // Reads/reservations don't invalidate shared borrows\n                     }\n \n-                    // Unique and mutable borrows are invalidated by reads from any\n-                    // involved path\n-                    this.generate_invalidates(borrow_index, context.loc);\n-                }\n+                    (Read(_), BorrowKind::Unique) | (Read(_), BorrowKind::Mut { .. }) => {\n+                        // Reading from mere reservations of mutable-borrows is OK.\n+                        if !is_active(&this.dominators, borrow, context.loc) {\n+                            // If the borrow isn't active yet, reads don't invalidate it\n+                            assert!(allow_two_phase_borrow(&this.infcx.tcx, borrow.kind));\n+                            return Control::Continue;\n+                        }\n+\n+                        // Unique and mutable borrows are invalidated by reads from any\n+                        // involved path\n+                        this.generate_invalidates(borrow_index, context.loc);\n+                    }\n \n-                (Reservation(_), BorrowKind::Unique)\n-                | (Reservation(_), BorrowKind::Mut { .. })\n-                | (Activation(_, _), _)\n-                | (Write(_), _) => {\n-                    // unique or mutable borrows are invalidated by writes.\n-                    // Reservations count as writes since we need to check\n-                    // that activating the borrow will be OK\n-                    // TOOD(bob_twinkles) is this actually the right thing to do?\n-                    this.generate_invalidates(borrow_index, context.loc);\n+                    (Reservation(_), BorrowKind::Unique)\n+                        | (Reservation(_), BorrowKind::Mut { .. })\n+                        | (Activation(_, _), _)\n+                        | (Write(_), _) => {\n+                            // unique or mutable borrows are invalidated by writes.\n+                            // Reservations count as writes since we need to check\n+                            // that activating the borrow will be OK\n+                            // TOOD(bob_twinkles) is this actually the right thing to do?\n+                            this.generate_invalidates(borrow_index, context.loc);\n+                        }\n                 }\n+                Control::Continue\n             },\n         );\n     }\n \n-    /// Returns true if the borrow represented by `kind` is\n-    /// allowed to be split into separate Reservation and\n-    /// Activation phases.\n-    fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n-        self.infcx.tcx.two_phase_borrows()\n-            && (kind.allows_two_phase_borrow()\n-                || self.infcx.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n-    }\n \n     /// Generate a new invalidates(L, B) fact\n     fn generate_invalidates(&mut self, b: BorrowIndex, l: Location) {\n         let lidx = self.location_table.mid_index(l);\n         self.all_facts.invalidates.push((lidx, b));\n     }\n-\n-    /// This function iterates over all borrows that intersect with an\n-    /// an access to a place, invoking the `op` callback for each one.\n-    ///\n-    /// \"Current borrow\" here means a borrow that reaches the point in\n-    /// the control-flow where the access occurs.\n-    ///\n-    /// The borrow's phase is represented by the IsActive parameter\n-    /// passed to the callback.\n-    fn each_borrow_involving_path<F>(\n-        &mut self,\n-        _context: Context,\n-        access_place: (ShallowOrDeep, &Place<'tcx>),\n-        mut op: F,\n-    ) where\n-        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>),\n-    {\n-        let (access, place) = access_place;\n-\n-        // FIXME: analogous code in check_loans first maps `place` to\n-        // its base_path.\n-\n-        // check for loan restricting path P being used. Accounts for\n-        // borrows of P, P.a.b, etc.\n-        let borrow_set = self.borrow_set.clone();\n-        for i in borrow_set.borrows.indices() {\n-            let borrowed = &borrow_set[i];\n-\n-            if self.places_conflict(&borrowed.borrowed_place, place, access) {\n-                debug!(\n-                    \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n-                    i, borrowed, place, access\n-                );\n-                op(self, i, borrowed);\n-            }\n-        }\n-    }\n-\n-    /// Determine if a given two-phase borrow is active using dominator information\n-    fn is_active(&self, borrow: &BorrowData, location: Location) -> bool {\n-        // If it's not two-phase, the borrow is definitely active\n-        if !self.allow_two_phase_borrow(borrow.kind) {\n-            return true;\n-        }\n-        if borrow.activation_location.is_none() {\n-            return false;\n-        }\n-        let activation_location = borrow.activation_location.unwrap();\n-        if activation_location.block == location.block {\n-            activation_location.statement_index >= location.statement_index\n-        } else {\n-            self.mir.dominators().is_dominated_by(location.block, activation_location.block)\n-        }\n-    }\n-\n-    /// Returns whether an access of kind `access` to `access_place` conflicts with\n-    /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n-    /// locations, this function is symmetric between `borrow_place` & `access_place`).\n-    fn places_conflict(\n-        &mut self,\n-        borrow_place: &Place<'tcx>,\n-        access_place: &Place<'tcx>,\n-        access: ShallowOrDeep,\n-    ) -> bool {\n-        debug!(\n-            \"places_conflict({:?},{:?},{:?})\",\n-            borrow_place, access_place, access\n-        );\n-\n-        // Return all the prefixes of `place` in reverse order, including\n-        // downcasts.\n-        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>> {\n-            let mut result = vec![];\n-            let mut place = place;\n-            loop {\n-                result.push(place);\n-                match place {\n-                    Place::Projection(interior) => {\n-                        place = &interior.base;\n-                    }\n-                    Place::Local(_) | Place::Static(_) => {\n-                        result.reverse();\n-                        return result;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let borrow_components = place_elements(borrow_place);\n-        let access_components = place_elements(access_place);\n-        debug!(\n-            \"places_conflict: components {:?} / {:?}\",\n-            borrow_components, access_components\n-        );\n-\n-        let borrow_components = borrow_components\n-            .into_iter()\n-            .map(Some)\n-            .chain(iter::repeat(None));\n-        let access_components = access_components\n-            .into_iter()\n-            .map(Some)\n-            .chain(iter::repeat(None));\n-        // The borrowck rules for proving disjointness are applied from the \"root\" of the\n-        // borrow forwards, iterating over \"similar\" projections in lockstep until\n-        // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n-        // a monoid and report a conflict if the product ends up not being `Disjoint`.\n-        //\n-        // At each step, if we didn't run out of borrow or place, we know that our elements\n-        // have the same type, and that they only overlap if they are the identical.\n-        //\n-        // For example, if we are comparing these:\n-        // BORROW:  (*x1[2].y).z.a\n-        // ACCESS:  (*x1[i].y).w.b\n-        //\n-        // Then our steps are:\n-        //       x1         |   x1          -- places are the same\n-        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n-        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n-        //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n-        //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n-        //\n-        // Because `zip` does potentially bad things to the iterator inside, this loop\n-        // also handles the case where the access might be a *prefix* of the borrow, e.g.\n-        //\n-        // BORROW:  (*x1[2].y).z.a\n-        // ACCESS:  x1[i].y\n-        //\n-        // Then our steps are:\n-        //       x1         |   x1          -- places are the same\n-        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n-        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n-        //\n-        // -- here we run out of access - the borrow can access a part of it. If this\n-        // is a full deep access, then we *know* the borrow conflicts with it. However,\n-        // if the access is shallow, then we can proceed:\n-        //\n-        //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n-        //                                     are disjoint\n-        //\n-        // Our invariant is, that at each step of the iteration:\n-        //  - If we didn't run out of access to match, our borrow and access are comparable\n-        //    and either equal or disjoint.\n-        //  - If we did run out of accesss, the borrow can access a part of it.\n-        for (borrow_c, access_c) in borrow_components.zip(access_components) {\n-            // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-            debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n-            match (borrow_c, access_c) {\n-                (None, _) => {\n-                    // If we didn't run out of access, the borrow can access all of our\n-                    // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n-                    // so we have a conflict.\n-                    //\n-                    // If we did, then we still know that the borrow can access a *part*\n-                    // of our place that our access cares about (a borrow of `a.b.c`\n-                    // with an access to `a.b`), so we still have a conflict.\n-                    //\n-                    // FIXME: Differs from AST-borrowck; includes drive-by fix\n-                    // to #38899. Will probably need back-compat mode flag.\n-                    debug!(\"places_conflict: full borrow, CONFLICT\");\n-                    return true;\n-                }\n-                (Some(borrow_c), None) => {\n-                    // We know that the borrow can access a part of our place. This\n-                    // is a conflict if that is a part our access cares about.\n-\n-                    let (base, elem) = match borrow_c {\n-                        Place::Projection(box Projection { base, elem }) => (base, elem),\n-                        _ => bug!(\"place has no base?\"),\n-                    };\n-                    let base_ty = base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n-\n-                    match (elem, &base_ty.sty, access) {\n-                        (_, _, Shallow(Some(ArtificialField::Discriminant)))\n-                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n-                            // The discriminant and array length are like\n-                            // additional fields on the type; they do not\n-                            // overlap any existing data there. Furthermore,\n-                            // they cannot actually be a prefix of any\n-                            // borrowed place (at least in MIR as it is\n-                            // currently.)\n-                            //\n-                            // e.g. a (mutable) borrow of `a[5]` while we read the\n-                            // array length of `a`.\n-                            debug!(\"places_conflict: implicit field\");\n-                            return false;\n-                        }\n-\n-                        (ProjectionElem::Deref, _, Shallow(None)) => {\n-                            // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n-                            // prefix thereof - the shallow access can't touch anything behind\n-                            // the pointer.\n-                            debug!(\"places_conflict: shallow access behind ptr\");\n-                            return false;\n-                        }\n-                        (\n-                            ProjectionElem::Deref,\n-                            ty::TyRef( _, _, hir::MutImmutable),\n-                            _,\n-                        ) => {\n-                            // the borrow goes through a dereference of a shared reference.\n-                            //\n-                            // I'm not sure why we are tracking these borrows - shared\n-                            // references can *always* be aliased, which means the\n-                            // permission check already account for this borrow.\n-                            debug!(\"places_conflict: behind a shared ref\");\n-                            return false;\n-                        }\n-\n-                        (ProjectionElem::Deref, _, Deep)\n-                        | (ProjectionElem::Field { .. }, _, _)\n-                        | (ProjectionElem::Index { .. }, _, _)\n-                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n-                        | (ProjectionElem::Subslice { .. }, _, _)\n-                        | (ProjectionElem::Downcast { .. }, _, _) => {\n-                            // Recursive case. This can still be disjoint on a\n-                            // further iteration if this a shallow access and\n-                            // there's a deref later on, e.g. a borrow\n-                            // of `*x.y` while accessing `x`.\n-                        }\n-                    }\n-                }\n-                (Some(borrow_c), Some(access_c)) => {\n-                    match self.place_element_conflict(&borrow_c, access_c) {\n-                        Overlap::Arbitrary => {\n-                            // We have encountered different fields of potentially\n-                            // the same union - the borrow now partially overlaps.\n-                            //\n-                            // There is no *easy* way of comparing the fields\n-                            // further on, because they might have different types\n-                            // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n-                            // `.y` come from different structs).\n-                            //\n-                            // We could try to do some things here - e.g. count\n-                            // dereferences - but that's probably not a good\n-                            // idea, at least for now, so just give up and\n-                            // report a conflict. This is unsafe code anyway so\n-                            // the user could always use raw pointers.\n-                            debug!(\"places_conflict: arbitrary -> conflict\");\n-                            return true;\n-                        }\n-                        Overlap::EqualOrDisjoint => {\n-                            // This is the recursive case - proceed to the next element.\n-                        }\n-                        Overlap::Disjoint => {\n-                            // We have proven the borrow disjoint - further\n-                            // projections will remain disjoint.\n-                            debug!(\"places_conflict: disjoint\");\n-                            return false;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        unreachable!(\"iter::repeat returned None\")\n-    }\n-\n-    // Given that the bases of `elem1` and `elem2` are always either equal\n-    // or disjoint (and have the same type!), return the overlap situation\n-    // between `elem1` and `elem2`.\n-    fn place_element_conflict(&self, elem1: &Place<'tcx>, elem2: &Place<'tcx>) -> Overlap {\n-        match (elem1, elem2) {\n-            (Place::Local(l1), Place::Local(l2)) => {\n-                if l1 == l2 {\n-                    // the same local - base case, equal\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n-                    Overlap::EqualOrDisjoint\n-                } else {\n-                    // different locals - base case, disjoint\n-                    debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n-                    Overlap::Disjoint\n-                }\n-            }\n-            (Place::Static(static1), Place::Static(static2)) => {\n-                if static1.def_id != static2.def_id {\n-                    debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                    Overlap::Disjoint\n-                } else if self.infcx.tcx.is_static(static1.def_id) ==\n-                          Some(hir::Mutability::MutMutable) {\n-                    // We ignore mutable statics - they can only be unsafe code.\n-                    debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                    Overlap::Disjoint\n-                } else {\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                    Overlap::EqualOrDisjoint\n-                }\n-            }\n-            (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n-                Overlap::Disjoint\n-            }\n-            (Place::Projection(pi1), Place::Projection(pi2)) => {\n-                match (&pi1.elem, &pi2.elem) {\n-                    (ProjectionElem::Deref, ProjectionElem::Deref) => {\n-                        // derefs (e.g. `*x` vs. `*x`) - recur.\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n-                        Overlap::EqualOrDisjoint\n-                    }\n-                    (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n-                        if f1 == f2 {\n-                            // same field (e.g. `a.y` vs. `a.y`) - recur.\n-                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                            Overlap::EqualOrDisjoint\n-                        } else {\n-                            let ty = pi1.base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n-                            match ty.sty {\n-                                ty::TyAdt(def, _) if def.is_union() => {\n-                                    // Different fields of a union, we are basically stuck.\n-                                    debug!(\"place_element_conflict: STUCK-UNION\");\n-                                    Overlap::Arbitrary\n-                                }\n-                                _ => {\n-                                    // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n-                                    debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                                    Overlap::Disjoint\n-                                }\n-                            }\n-                        }\n-                    }\n-                    (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n-                        // different variants are treated as having disjoint fields,\n-                        // even if they occupy the same \"space\", because it's\n-                        // impossible for 2 variants of the same enum to exist\n-                        // (and therefore, to be borrowed) at the same time.\n-                        //\n-                        // Note that this is different from unions - we *do* allow\n-                        // this code to compile:\n-                        //\n-                        // ```\n-                        // fn foo(x: &mut Result<i32, i32>) {\n-                        //     let mut v = None;\n-                        //     if let Ok(ref mut a) = *x {\n-                        //         v = Some(a);\n-                        //     }\n-                        //     // here, you would *think* that the\n-                        //     // *entirety* of `x` would be borrowed,\n-                        //     // but in fact only the `Ok` variant is,\n-                        //     // so the `Err` variant is *entirely free*:\n-                        //     if let Err(ref mut a) = *x {\n-                        //         v = Some(a);\n-                        //     }\n-                        //     drop(v);\n-                        // }\n-                        // ```\n-                        if v1 == v2 {\n-                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                            Overlap::EqualOrDisjoint\n-                        } else {\n-                            debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                            Overlap::Disjoint\n-                        }\n-                    }\n-                    (ProjectionElem::Index(..), ProjectionElem::Index(..))\n-                    | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n-                    | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n-                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n-                    | (\n-                        ProjectionElem::ConstantIndex { .. },\n-                        ProjectionElem::ConstantIndex { .. },\n-                    )\n-                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n-                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n-                    | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n-                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n-                        // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n-                        // (if the indexes differ) or equal (if they are the same), so this\n-                        // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n-                        //\n-                        // Note that by construction, MIR at borrowck can't subdivide\n-                        // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n-                        // are only present in slice patterns, and we \"merge together\" nested\n-                        // slice patterns. That means we don't have to think about these. It's\n-                        // probably a good idea to assert this somewhere, but I'm too lazy.\n-                        //\n-                        // FIXME(#8636) we might want to return Disjoint if\n-                        // both projections are constant and disjoint.\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n-                        Overlap::EqualOrDisjoint\n-                    }\n-\n-                    (ProjectionElem::Deref, _)\n-                    | (ProjectionElem::Field(..), _)\n-                    | (ProjectionElem::Index(..), _)\n-                    | (ProjectionElem::ConstantIndex { .. }, _)\n-                    | (ProjectionElem::Subslice { .. }, _)\n-                    | (ProjectionElem::Downcast(..), _) => bug!(\n-                        \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-                        elem1,\n-                        elem2\n-                    ),\n-                }\n-            }\n-            (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n-                \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n-                elem1,\n-                elem2\n-            ),\n-        }\n-    }\n }\n \n-\n-/// Determines if a given borrow is borrowing local data\n-/// This is called for all Yield statements on movable generators\n-fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n-    match place {\n-        Place::Static(..) => false,\n-        Place::Local(..) => true,\n-        Place::Projection(box proj) => {\n-            match proj.elem {\n-                // Reborrow of already borrowed data is ignored\n-                // Any errors will be caught on the initial borrow\n-                ProjectionElem::Deref => false,\n-\n-                // For interior references and downcasts, find out if the base is local\n-                ProjectionElem::Field(..)\n-                    | ProjectionElem::Index(..)\n-                    | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::Downcast(..) => borrow_of_local_data(&proj.base),\n-            }\n-        }\n-    }\n-}"}, {"sha": "d8d160b73e6142997d60897a3e1c0e9a1e3d54b3", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/e62fa27071f296cca9b35f50e2d1bb3459631fd7/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62fa27071f296cca9b35f50e2d1bb3459631fd7/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=e62fa27071f296cca9b35f50e2d1bb3459631fd7", "patch": "@@ -0,0 +1,507 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Returns true if the borrow represented by `kind` is\n+/// allowed to be split into separate Reservation and\n+/// Activation phases.\n+use borrow_check::ArtificialField;\n+use borrow_check::borrow_set::{BorrowSet, BorrowData};\n+use borrow_check::{Context, Overlap};\n+use borrow_check::{ShallowOrDeep, Deep, Shallow};\n+use dataflow::indexes::BorrowIndex;\n+use rustc::hir;\n+use rustc::mir::{BasicBlock, Location, Mir, Place};\n+use rustc::mir::{Projection, ProjectionElem, BorrowKind};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::control_flow_graph::dominators::Dominators;\n+use std::iter;\n+\n+pub(super) fn allow_two_phase_borrow<'a, 'tcx, 'gcx: 'tcx>(\n+    tcx: &TyCtxt<'a, 'gcx, 'tcx>,\n+    kind: BorrowKind\n+) -> bool {\n+    tcx.two_phase_borrows()\n+        && (kind.allows_two_phase_borrow()\n+            || tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+}\n+\n+/// Control for the path borrow checking code\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub(super) enum Control {\n+    Continue,\n+    Break,\n+}\n+\n+/// Encapsulates the idea of iterating over every borrow that involves a particular path\n+pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n+    s: &mut S,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    _context: Context,\n+    access_place: (ShallowOrDeep, &Place<'tcx>),\n+    borrow_set: &BorrowSet<'tcx>,\n+    candidates: I,\n+    mut op: F,\n+) where\n+    F: FnMut(&mut S, BorrowIndex, &BorrowData<'tcx>) -> Control,\n+    I: Iterator<Item=BorrowIndex>\n+{\n+    let (access, place) = access_place;\n+\n+    // FIXME: analogous code in check_loans first maps `place` to\n+    // its base_path.\n+\n+    // check for loan restricting path P being used. Accounts for\n+    // borrows of P, P.a.b, etc.\n+    for i in candidates {\n+        let borrowed = &borrow_set[i];\n+\n+        if places_conflict(tcx, mir, &borrowed.borrowed_place, place, access) {\n+            debug!(\n+                \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n+                i, borrowed, place, access\n+            );\n+            let ctrl = op(s, i, borrowed);\n+            if ctrl == Control::Break {\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn places_conflict<'a, 'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    borrow_place: &Place<'tcx>,\n+    access_place: &Place<'tcx>,\n+    access: ShallowOrDeep,\n+) -> bool {\n+    debug!(\n+        \"places_conflict({:?},{:?},{:?})\",\n+        borrow_place, access_place, access\n+    );\n+\n+    let borrow_components = place_elements(borrow_place);\n+    let access_components = place_elements(access_place);\n+    debug!(\n+        \"places_conflict: components {:?} / {:?}\",\n+        borrow_components, access_components\n+    );\n+\n+    let borrow_components = borrow_components\n+        .into_iter()\n+        .map(Some)\n+        .chain(iter::repeat(None));\n+    let access_components = access_components\n+        .into_iter()\n+        .map(Some)\n+        .chain(iter::repeat(None));\n+    // The borrowck rules for proving disjointness are applied from the \"root\" of the\n+    // borrow forwards, iterating over \"similar\" projections in lockstep until\n+    // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n+    // a monoid and report a conflict if the product ends up not being `Disjoint`.\n+    //\n+    // At each step, if we didn't run out of borrow or place, we know that our elements\n+    // have the same type, and that they only overlap if they are the identical.\n+    //\n+    // For example, if we are comparing these:\n+    // BORROW:  (*x1[2].y).z.a\n+    // ACCESS:  (*x1[i].y).w.b\n+    //\n+    // Then our steps are:\n+    //       x1         |   x1          -- places are the same\n+    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+    //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n+    //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n+    //\n+    // Because `zip` does potentially bad things to the iterator inside, this loop\n+    // also handles the case where the access might be a *prefix* of the borrow, e.g.\n+    //\n+    // BORROW:  (*x1[2].y).z.a\n+    // ACCESS:  x1[i].y\n+    //\n+    // Then our steps are:\n+    //       x1         |   x1          -- places are the same\n+    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+    //\n+    // -- here we run out of access - the borrow can access a part of it. If this\n+    // is a full deep access, then we *know* the borrow conflicts with it. However,\n+    // if the access is shallow, then we can proceed:\n+    //\n+    //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n+    //                                     are disjoint\n+    //\n+    // Our invariant is, that at each step of the iteration:\n+    //  - If we didn't run out of access to match, our borrow and access are comparable\n+    //    and either equal or disjoint.\n+    //  - If we did run out of accesss, the borrow can access a part of it.\n+    for (borrow_c, access_c) in borrow_components.zip(access_components) {\n+        // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+        debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n+        match (borrow_c, access_c) {\n+            (None, _) => {\n+                // If we didn't run out of access, the borrow can access all of our\n+                // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n+                // so we have a conflict.\n+                //\n+                // If we did, then we still know that the borrow can access a *part*\n+                // of our place that our access cares about (a borrow of `a.b.c`\n+                // with an access to `a.b`), so we still have a conflict.\n+                //\n+                // FIXME: Differs from AST-borrowck; includes drive-by fix\n+                // to #38899. Will probably need back-compat mode flag.\n+                debug!(\"places_conflict: full borrow, CONFLICT\");\n+                return true;\n+            }\n+            (Some(borrow_c), None) => {\n+                // We know that the borrow can access a part of our place. This\n+                // is a conflict if that is a part our access cares about.\n+\n+                let (base, elem) = match borrow_c {\n+                    Place::Projection(box Projection { base, elem }) => (base, elem),\n+                    _ => bug!(\"place has no base?\"),\n+                };\n+                let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+\n+                match (elem, &base_ty.sty, access) {\n+                    (_, _, Shallow(Some(ArtificialField::Discriminant)))\n+                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                            // The discriminant and array length are like\n+                            // additional fields on the type; they do not\n+                            // overlap any existing data there. Furthermore,\n+                            // they cannot actually be a prefix of any\n+                            // borrowed place (at least in MIR as it is\n+                            // currently.)\n+                            //\n+                            // e.g. a (mutable) borrow of `a[5]` while we read the\n+                            // array length of `a`.\n+                            debug!(\"places_conflict: implicit field\");\n+                            return false;\n+                        }\n+\n+                    (ProjectionElem::Deref, _, Shallow(None)) => {\n+                        // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                        // prefix thereof - the shallow access can't touch anything behind\n+                        // the pointer.\n+                        debug!(\"places_conflict: shallow access behind ptr\");\n+                        return false;\n+                    }\n+                    (\n+                        ProjectionElem::Deref,\n+                        ty::TyRef( _, _, hir::MutImmutable),\n+                        _,\n+                    ) => {\n+                        // the borrow goes through a dereference of a shared reference.\n+                        //\n+                        // I'm not sure why we are tracking these borrows - shared\n+                        // references can *always* be aliased, which means the\n+                        // permission check already account for this borrow.\n+                        debug!(\"places_conflict: behind a shared ref\");\n+                        return false;\n+                    }\n+\n+                    (ProjectionElem::Deref, _, Deep)\n+                        | (ProjectionElem::Field { .. }, _, _)\n+                        | (ProjectionElem::Index { .. }, _, _)\n+                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                        | (ProjectionElem::Subslice { .. }, _, _)\n+                        | (ProjectionElem::Downcast { .. }, _, _) => {\n+                            // Recursive case. This can still be disjoint on a\n+                            // further iteration if this a shallow access and\n+                            // there's a deref later on, e.g. a borrow\n+                            // of `*x.y` while accessing `x`.\n+                        }\n+                }\n+            }\n+            (Some(borrow_c), Some(access_c)) => {\n+                match place_element_conflict(tcx, mir, &borrow_c, access_c) {\n+                    Overlap::Arbitrary => {\n+                        // We have encountered different fields of potentially\n+                        // the same union - the borrow now partially overlaps.\n+                        //\n+                        // There is no *easy* way of comparing the fields\n+                        // further on, because they might have different types\n+                        // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                        // `.y` come from different structs).\n+                        //\n+                        // We could try to do some things here - e.g. count\n+                        // dereferences - but that's probably not a good\n+                        // idea, at least for now, so just give up and\n+                        // report a conflict. This is unsafe code anyway so\n+                        // the user could always use raw pointers.\n+                        debug!(\"places_conflict: arbitrary -> conflict\");\n+                        return true;\n+                    }\n+                    Overlap::EqualOrDisjoint => {\n+                        // This is the recursive case - proceed to the next element.\n+                    }\n+                    Overlap::Disjoint => {\n+                        // We have proven the borrow disjoint - further\n+                        // projections will remain disjoint.\n+                        debug!(\"places_conflict: disjoint\");\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    unreachable!(\"iter::repeat returned None\")\n+}\n+\n+/// Return all the prefixes of `place` in reverse order, including\n+/// downcasts.\n+fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>> {\n+    let mut result = vec![];\n+    let mut place = place;\n+    loop {\n+        result.push(place);\n+        match place {\n+            Place::Projection(interior) => {\n+                place = &interior.base;\n+            }\n+            Place::Local(_) | Place::Static(_) => {\n+                result.reverse();\n+                return result;\n+            }\n+        }\n+    }\n+}\n+\n+// Given that the bases of `elem1` and `elem2` are always either equal\n+// or disjoint (and have the same type!), return the overlap situation\n+// between `elem1` and `elem2`.\n+fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    elem1: &Place<'tcx>,\n+    elem2: &Place<'tcx>\n+) -> Overlap {\n+    match (elem1, elem2) {\n+        (Place::Local(l1), Place::Local(l2)) => {\n+            if l1 == l2 {\n+                // the same local - base case, equal\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                // different locals - base case, disjoint\n+                debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (Place::Static(static1), Place::Static(static2)) => {\n+            if static1.def_id != static2.def_id {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                Overlap::Disjoint\n+            } else if tcx.is_static(static1.def_id) ==\n+                        Some(hir::Mutability::MutMutable) {\n+                // We ignore mutable statics - they can only be unsafe code.\n+                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                Overlap::Disjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                Overlap::EqualOrDisjoint\n+            }\n+        }\n+        (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n+            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+            Overlap::Disjoint\n+        }\n+        (Place::Projection(pi1), Place::Projection(pi2)) => {\n+            match (&pi1.elem, &pi2.elem) {\n+                (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+                    // derefs (e.g. `*x` vs. `*x`) - recur.\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+                    Overlap::EqualOrDisjoint\n+                }\n+                (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+                    if f1 == f2 {\n+                        // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n+                        match ty.sty {\n+                            ty::TyAdt(def, _) if def.is_union() => {\n+                                // Different fields of a union, we are basically stuck.\n+                                debug!(\"place_element_conflict: STUCK-UNION\");\n+                                Overlap::Arbitrary\n+                            }\n+                            _ => {\n+                                // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                                debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                                Overlap::Disjoint\n+                            }\n+                        }\n+                    }\n+                }\n+                (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+                    // different variants are treated as having disjoint fields,\n+                    // even if they occupy the same \"space\", because it's\n+                    // impossible for 2 variants of the same enum to exist\n+                    // (and therefore, to be borrowed) at the same time.\n+                    //\n+                    // Note that this is different from unions - we *do* allow\n+                    // this code to compile:\n+                    //\n+                    // ```\n+                    // fn foo(x: &mut Result<i32, i32>) {\n+                    //     let mut v = None;\n+                    //     if let Ok(ref mut a) = *x {\n+                    //         v = Some(a);\n+                    //     }\n+                    //     // here, you would *think* that the\n+                    //     // *entirety* of `x` would be borrowed,\n+                    //     // but in fact only the `Ok` variant is,\n+                    //     // so the `Err` variant is *entirely free*:\n+                    //     if let Err(ref mut a) = *x {\n+                    //         v = Some(a);\n+                    //     }\n+                    //     drop(v);\n+                    // }\n+                    // ```\n+                    if v1 == v2 {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::Index(..), ProjectionElem::Index(..))\n+                | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n+                | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n+                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n+                | (\n+                    ProjectionElem::ConstantIndex { .. },\n+                    ProjectionElem::ConstantIndex { .. },\n+                )\n+                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                    // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+                    // (if the indexes differ) or equal (if they are the same), so this\n+                    // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n+                    //\n+                    // Note that by construction, MIR at borrowck can't subdivide\n+                    // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n+                    // are only present in slice patterns, and we \"merge together\" nested\n+                    // slice patterns. That means we don't have to think about these. It's\n+                    // probably a good idea to assert this somewhere, but I'm too lazy.\n+                    //\n+                    // FIXME(#8636) we might want to return Disjoint if\n+                    // both projections are constant and disjoint.\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                    Overlap::EqualOrDisjoint\n+                }\n+\n+                (ProjectionElem::Deref, _)\n+                | (ProjectionElem::Field(..), _)\n+                | (ProjectionElem::Index(..), _)\n+                | (ProjectionElem::ConstantIndex { .. }, _)\n+                | (ProjectionElem::Subslice { .. }, _)\n+                | (ProjectionElem::Downcast(..), _) => bug!(\n+                    \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+                    elem1,\n+                    elem2\n+                ),\n+            }\n+        }\n+        (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n+            \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+            elem1,\n+            elem2\n+        ),\n+    }\n+}\n+\n+pub(super) fn is_active<'tcx>(\n+    dominators: &Dominators<BasicBlock>,\n+    borrow_data: &BorrowData<'tcx>,\n+    location: Location\n+) -> bool {\n+    debug!(\"is_active(borrow_data={:?}, location={:?})\", borrow_data, location);\n+\n+    // If this is not a 2-phase borrow, it is always active.\n+    let activation_location = match borrow_data.activation_location {\n+        Some(v) => v,\n+        None => return true,\n+    };\n+\n+    // Otherwise, it is active for every location *except* in between\n+    // the reservation and the activation:\n+    //\n+    //       X\n+    //      /\n+    //     R      <--+ Except for this\n+    //    / \\        | diamond\n+    //    \\ /        |\n+    //     A  <------+\n+    //     |\n+    //     Z\n+    //\n+    // Note that we assume that:\n+    // - the reservation R dominates the activation A\n+    // - the activation A post-dominates the reservation R (ignoring unwinding edges).\n+    //\n+    // This means that there can't be an edge that leaves A and\n+    // comes back into that diamond unless it passes through R.\n+    //\n+    // Suboptimal: In some cases, this code walks the dominator\n+    // tree twice when it only has to be walked once. I am\n+    // lazy. -nmatsakis\n+\n+    // If dominated by the activation A, then it is active. The\n+    // activation occurs upon entering the point A, so this is\n+    // also true if location == activation_location.\n+    if activation_location.dominates(location, dominators) {\n+        return true;\n+    }\n+\n+    // The reservation starts *on exiting* the reservation block,\n+    // so check if the location is dominated by R.successor. If so,\n+    // this point falls in between the reservation and location.\n+    let reserve_location = borrow_data.reserve_location.successor_within_block();\n+    if reserve_location.dominates(location, dominators) {\n+        false\n+    } else {\n+        // Otherwise, this point is outside the diamond, so\n+        // consider the borrow active. This could happen for\n+        // example if the borrow remains active around a loop (in\n+        // which case it would be active also for the point R,\n+        // which would generate an error).\n+        true\n+    }\n+}\n+\n+/// Determines if a given borrow is borrowing local data\n+/// This is called for all Yield statements on movable generators\n+pub(super) fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n+    match place {\n+        Place::Static(..) => false,\n+        Place::Local(..) => true,\n+        Place::Projection(box proj) => {\n+            match proj.elem {\n+                // Reborrow of already borrowed data is ignored\n+                // Any errors will be caught on the initial borrow\n+                ProjectionElem::Deref => false,\n+\n+                // For interior references and downcasts, find out if the base is local\n+                ProjectionElem::Field(..)\n+                    | ProjectionElem::Index(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. }\n+                | ProjectionElem::Downcast(..) => borrow_of_local_data(&proj.base),\n+            }\n+        }\n+    }\n+}"}]}