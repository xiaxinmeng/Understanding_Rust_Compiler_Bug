{"sha": "773e8a5ad1fa012bc1574c6733a700e094a48e3d", "node_id": "C_kwDOAAsO6NoAKDc3M2U4YTVhZDFmYTAxMmJjMTU3NGM2NzMzYTcwMGUwOTRhNDhlM2Q", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-05T01:08:17Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-28T01:02:15Z"}, "message": "RTN", "tree": {"sha": "522700a419e0388d6ce179496ac564c1eb14bad6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/522700a419e0388d6ce179496ac564c1eb14bad6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/773e8a5ad1fa012bc1574c6733a700e094a48e3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/773e8a5ad1fa012bc1574c6733a700e094a48e3d", "html_url": "https://github.com/rust-lang/rust/commit/773e8a5ad1fa012bc1574c6733a700e094a48e3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/773e8a5ad1fa012bc1574c6733a700e094a48e3d/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb9ca9223d42a13bc15bddd1c2dce506db2fcb21", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9ca9223d42a13bc15bddd1c2dce506db2fcb21", "html_url": "https://github.com/rust-lang/rust/commit/fb9ca9223d42a13bc15bddd1c2dce506db2fcb21"}], "stats": {"total": 171, "additions": 120, "deletions": 51}, "files": [{"sha": "97b87b985d0977345c2a1d04c2d0f5d4970951a5", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/773e8a5ad1fa012bc1574c6733a700e094a48e3d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773e8a5ad1fa012bc1574c6733a700e094a48e3d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=773e8a5ad1fa012bc1574c6733a700e094a48e3d", "patch": "@@ -987,8 +987,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, ParamMode::Explicit, itctx).0\n                 }\n+                GenericArgs::Parenthesized(data)\n+                    if self.tcx.features().return_type_notation =>\n+                {\n+                    // TODO: Check the parens + no return type\n+                    GenericArgsCtor {\n+                        args: Default::default(),\n+                        bindings: &[],\n+                        parenthesized: true,\n+                        span: data.span,\n+                    }\n+                }\n                 GenericArgs::Parenthesized(data) => {\n                     self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n+                    // TODO: Add a RTN feature error if the parens are shaped correctly\n                     self.lower_angle_bracketed_parameter_data(\n                         &data.as_angle_bracketed_args(),\n                         ParamMode::Explicit,"}, {"sha": "0565bc6dffe0edc2f99b73753c9122b4c6cce89f", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 103, "deletions": 50, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/773e8a5ad1fa012bc1574c6733a700e094a48e3d/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773e8a5ad1fa012bc1574c6733a700e094a48e3d/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=773e8a5ad1fa012bc1574c6733a700e094a48e3d", "patch": "@@ -854,16 +854,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n-    fn trait_defines_associated_type_named(&self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n-        self.tcx()\n-            .associated_items(trait_def_id)\n-            .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, trait_def_id)\n-            .is_some()\n-    }\n-    fn trait_defines_associated_const_named(&self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n+    fn trait_defines_associated_item_named(\n+        &self,\n+        trait_def_id: DefId,\n+        assoc_kind: ty::AssocKind,\n+        assoc_name: Ident,\n+    ) -> bool {\n         self.tcx()\n             .associated_items(trait_def_id)\n-            .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Const, trait_def_id)\n+            .find_by_name_and_kind(self.tcx(), assoc_name, assoc_kind, trait_def_id)\n             .is_some()\n     }\n \n@@ -1087,24 +1086,42 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let tcx = self.tcx();\n \n-        let candidate =\n-            if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n-                // Simple case: X is defined in the current trait.\n+        // TODO: rtn comment goes here\n+        let associated_return_type_bound =\n+            binding.gen_args.parenthesized && self.tcx().features().associated_return_type_bounds;\n+\n+        let candidate = if return_type_notation {\n+            if self.trait_defines_associated_item_named(\n+                trait_ref.def_id(),\n+                ty::AssocKind::Fn,\n+                binding.item_name,\n+            ) {\n                 trait_ref\n             } else {\n-                // Otherwise, we have to walk through the supertraits to find\n-                // those that do.\n-                self.one_bound_for_assoc_type(\n-                    || traits::supertraits(tcx, trait_ref),\n-                    trait_ref.print_only_trait_path(),\n-                    binding.item_name,\n-                    path_span,\n-                    match binding.kind {\n-                        ConvertedBindingKind::Equality(term) => Some(term),\n-                        _ => None,\n-                    },\n-                )?\n-            };\n+                // TODO: error\n+                todo!()\n+            }\n+        } else if self.trait_defines_associated_item_named(\n+            trait_ref.def_id(),\n+            ty::AssocKind::Type,\n+            binding.item_name,\n+        ) {\n+            // Simple case: X is defined in the current trait.\n+            trait_ref\n+        } else {\n+            // Otherwise, we have to walk through the supertraits to find\n+            // those that do.\n+            self.one_bound_for_assoc_type(\n+                || traits::supertraits(tcx, trait_ref),\n+                trait_ref.print_only_trait_path(),\n+                binding.item_name,\n+                path_span,\n+                match binding.kind {\n+                    ConvertedBindingKind::Equality(term) => Some(term),\n+                    _ => None,\n+                },\n+            )?\n+        };\n \n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n@@ -1116,9 +1133,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .filter_by_name_unhygienic(assoc_ident.name)\n                 .find(|i| i.kind == kind && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident)\n         };\n-        let assoc_item = find_item_of_kind(ty::AssocKind::Type)\n-            .or_else(|| find_item_of_kind(ty::AssocKind::Const))\n-            .expect(\"missing associated type\");\n+        let assoc_item = if return_type_notation {\n+            find_item_of_kind(ty::AssocKind::Fn)\n+        } else {\n+            find_item_of_kind(ty::AssocKind::Type)\n+                .or_else(|| find_item_of_kind(ty::AssocKind::Const))\n+        }\n+        .expect(\"missing associated type\");\n \n         if !assoc_item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n             tcx.sess\n@@ -1145,28 +1166,54 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .or_insert(binding.span);\n         }\n \n-        // Include substitutions for generic parameters of associated types\n-        let projection_ty = candidate.map_bound(|trait_ref| {\n-            let ident = Ident::new(assoc_item.name, binding.item_name.span);\n-            let item_segment = hir::PathSegment {\n-                ident,\n-                hir_id: binding.hir_id,\n-                res: Res::Err,\n-                args: Some(binding.gen_args),\n-                infer_args: false,\n+        let projection_ty = if associated_return_type_bound {\n+            let generics = self.tcx().generics_of(assoc_item.def_id);\n+            if !generics.params.is_empty() {\n+                todo!();\n+            }\n+            let output = self.tcx().fn_sig(assoc_item.def_id).skip_binder().output();\n+            let fn_bound_vars = output.bound_vars();\n+\n+            let output = if let ty::Alias(ty::Projection, alias_ty) = *output.skip_binder().kind()\n+                && tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n+            {\n+                alias_ty\n+            } else {\n+                todo!(\"found return type of {output:?}\");\n             };\n \n-            let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n-                path_span,\n-                assoc_item.def_id,\n-                &item_segment,\n-                trait_ref.substs,\n-            );\n+            let trait_bound_vars = candidate.bound_vars();\n+            let shifted_output = tcx.shift_bound_var_indices(trait_bound_vars.len(), output);\n+            let subst_output =\n+                ty::EarlyBinder(shifted_output).subst(tcx, candidate.skip_binder().substs);\n+            let bound_vars =\n+                tcx.mk_bound_variable_kinds_from_iter(trait_bound_vars.iter().chain(fn_bound_vars));\n+\n+            ty::Binder::bind_with_vars(subst_output, bound_vars)\n+        } else {\n+            // Include substitutions for generic parameters of associated types\n+            candidate.map_bound(|trait_ref| {\n+                let ident = Ident::new(assoc_item.name, binding.item_name.span);\n+                let item_segment = hir::PathSegment {\n+                    ident,\n+                    hir_id: binding.hir_id,\n+                    res: Res::Err,\n+                    args: Some(binding.gen_args),\n+                    infer_args: false,\n+                };\n \n-            debug!(?substs_trait_ref_and_assoc_item);\n+                let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n+                    path_span,\n+                    assoc_item.def_id,\n+                    &item_segment,\n+                    trait_ref.substs,\n+                );\n \n-            self.tcx().mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n-        });\n+                debug!(?substs_trait_ref_and_assoc_item);\n+\n+                self.tcx().mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n+            })\n+        };\n \n         if !speculative {\n             // Find any late-bound regions declared in `ty` that are not\n@@ -1206,6 +1253,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         match binding.kind {\n+            ConvertedBindingKind::Equality(..) if associated_return_type_bound => {\n+                // TODO: error\n+                todo!()\n+            }\n             ConvertedBindingKind::Equality(mut term) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n                 // the \"projection predicate\" for:\n@@ -1267,7 +1318,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n                 let param_ty = tcx.mk_alias(ty::Projection, projection_ty.skip_binder());\n-                self.add_bounds(param_ty, ast_bounds.iter(), bounds, candidate.bound_vars());\n+                self.add_bounds(param_ty, ast_bounds.iter(), bounds, projection_ty.bound_vars());\n             }\n         }\n         Ok(())\n@@ -1808,10 +1859,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n     {\n-        let mut matching_candidates = all_candidates()\n-            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_name));\n-        let mut const_candidates = all_candidates()\n-            .filter(|r| self.trait_defines_associated_const_named(r.def_id(), assoc_name));\n+        let mut matching_candidates = all_candidates().filter(|r| {\n+            self.trait_defines_associated_item_named(r.def_id(), ty::AssocKind::Type, assoc_name)\n+        });\n+        let mut const_candidates = all_candidates().filter(|r| {\n+            self.trait_defines_associated_item_named(r.def_id(), ty::AssocKind::Const, assoc_name)\n+        });\n \n         let (bound, next_cand) = match (matching_candidates.next(), const_candidates.next()) {\n             (Some(bound), _) => (bound, matching_candidates.next()),"}, {"sha": "72f230e628df72e8d3fb59466d67a65066917757", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/773e8a5ad1fa012bc1574c6733a700e094a48e3d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773e8a5ad1fa012bc1574c6733a700e094a48e3d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=773e8a5ad1fa012bc1574c6733a700e094a48e3d", "patch": "@@ -550,7 +550,11 @@ impl<'a> Parser<'a> {\n \n                     // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                     if let AssocConstraintKind::Bound { .. } = kind {\n-                        self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n+                        if gen_args.as_ref().map_or(false, |args| args.is_parenthesized()) {\n+                            self.sess.gated_spans.gate(sym::return_type_notation, span);\n+                        } else {\n+                            self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n+                        }\n                     }\n                     let constraint =\n                         AssocConstraint { id: ast::DUMMY_NODE_ID, ident, gen_args, kind, span };"}]}