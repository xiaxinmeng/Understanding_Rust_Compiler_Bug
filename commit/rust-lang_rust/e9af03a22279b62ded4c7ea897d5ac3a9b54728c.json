{"sha": "e9af03a22279b62ded4c7ea897d5ac3a9b54728c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YWYwM2EyMjI3OWI2MmRlZDRjN2VhODk3ZDVhYzNhOWI1NDcyOGM=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2017-06-28T23:00:00Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2017-07-22T18:37:52Z"}, "message": "Add `new_checked(\u2026) -> Option<Self>` to NonZero, Unique, and Shared.", "tree": {"sha": "74c970d0be0c79dab61ba3196d808aa665a05a44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74c970d0be0c79dab61ba3196d808aa665a05a44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9af03a22279b62ded4c7ea897d5ac3a9b54728c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9af03a22279b62ded4c7ea897d5ac3a9b54728c", "html_url": "https://github.com/rust-lang/rust/commit/e9af03a22279b62ded4c7ea897d5ac3a9b54728c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9af03a22279b62ded4c7ea897d5ac3a9b54728c/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8d485f53dbe87e0d7b4ad14904fd7b0447a8cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d485f53dbe87e0d7b4ad14904fd7b0447a8cbe", "html_url": "https://github.com/rust-lang/rust/commit/f8d485f53dbe87e0d7b4ad14904fd7b0447a8cbe"}], "stats": {"total": 84, "additions": 65, "deletions": 19}, "files": [{"sha": "0564d73dd6d089102074e92cb8e68fb59088a344", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e9af03a22279b62ded4c7ea897d5ac3a9b54728c/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9af03a22279b62ded4c7ea897d5ac3a9b54728c/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=e9af03a22279b62ded4c7ea897d5ac3a9b54728c", "patch": "@@ -16,22 +16,48 @@\n use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-pub unsafe trait Zeroable {}\n-\n-unsafe impl<T:?Sized> Zeroable for *const T {}\n-unsafe impl<T:?Sized> Zeroable for *mut T {}\n-unsafe impl Zeroable for isize {}\n-unsafe impl Zeroable for usize {}\n-unsafe impl Zeroable for i8 {}\n-unsafe impl Zeroable for u8 {}\n-unsafe impl Zeroable for i16 {}\n-unsafe impl Zeroable for u16 {}\n-unsafe impl Zeroable for i32 {}\n-unsafe impl Zeroable for u32 {}\n-unsafe impl Zeroable for i64 {}\n-unsafe impl Zeroable for u64 {}\n-unsafe impl Zeroable for i128 {}\n-unsafe impl Zeroable for u128 {}\n+pub unsafe trait Zeroable {\n+    /// Whether this value is zero\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_zeroable_for_pointer_types {\n+    ( $( $Ptr: ty )+ ) => {\n+        $(\n+            /// For fat pointers to be considered \"zero\", only the \"data\" part needs to be null.\n+            unsafe impl<T: ?Sized> Zeroable for $Ptr {\n+                #[inline]\n+                fn is_zero(&self) -> bool {\n+                    // Cast because `is_null` is only available on thin pointers\n+                    (*self as *mut u8).is_null()\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+macro_rules! impl_zeroable_for_integer_types {\n+    ( $( $Int: ty )+ ) => {\n+        $(\n+            unsafe impl Zeroable for $Int {\n+                #[inline]\n+                fn is_zero(&self) -> bool {\n+                    *self == 0\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+impl_zeroable_for_pointer_types! {\n+    *const T\n+    *mut T\n+}\n+\n+impl_zeroable_for_integer_types! {\n+    usize u8 u16 u32 u64 u128\n+    isize i8 i16 i32 i64 i128\n+}\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n@@ -43,10 +69,20 @@ impl<T: Zeroable> NonZero<T> {\n     /// Creates an instance of NonZero with the provided value.\n     /// You must indeed ensure that the value is actually \"non-zero\".\n     #[inline]\n-    pub const unsafe fn new(inner: T) -> NonZero<T> {\n+    pub const unsafe fn new(inner: T) -> Self {\n         NonZero(inner)\n     }\n \n+    /// Creates an instance of NonZero with the provided value.\n+    #[inline]\n+    pub fn new_checked(inner: T) -> Option<Self> {\n+        if inner.is_zero() {\n+            None\n+        } else {\n+            Some(NonZero(inner))\n+        }\n+    }\n+\n     /// Gets the inner value.\n     pub fn get(self) -> T {\n         self.0"}, {"sha": "e83ca63834ab57d6db22192f67e6cd02fd172d7b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9af03a22279b62ded4c7ea897d5ac3a9b54728c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9af03a22279b62ded4c7ea897d5ac3a9b54728c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e9af03a22279b62ded4c7ea897d5ac3a9b54728c", "patch": "@@ -1110,10 +1110,15 @@ impl<T: ?Sized> Unique<T> {\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub const unsafe fn new(ptr: *mut T) -> Unique<T> {\n+    pub const unsafe fn new(ptr: *mut T) -> Self {\n         Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n+    /// Creates a new `Unique` if `ptr` is non-null.\n+    pub fn new_checked(ptr: *mut T) -> Option<Self> {\n+        NonZero::new_checked(ptr as *const T).map(|nz| Unique { pointer: nz, _marker: PhantomData })\n+    }\n+\n     /// Acquires the underlying `*mut` pointer.\n     pub fn as_ptr(self) -> *mut T {\n         self.pointer.get() as *mut T\n@@ -1224,10 +1229,15 @@ impl<T: ?Sized> Shared<T> {\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub unsafe fn new(ptr: *mut T) -> Self {\n+    pub const unsafe fn new(ptr: *mut T) -> Self {\n         Shared { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n+    /// Creates a new `Shared` if `ptr` is non-null.\n+    pub fn new_checked(ptr: *mut T) -> Option<Self> {\n+        NonZero::new_checked(ptr as *const T).map(|nz| Shared { pointer: nz, _marker: PhantomData })\n+    }\n+\n     /// Acquires the underlying `*mut` pointer.\n     pub fn as_ptr(self) -> *mut T {\n         self.pointer.get() as *mut T"}]}