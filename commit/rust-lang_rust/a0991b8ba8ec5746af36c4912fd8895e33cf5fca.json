{"sha": "a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "node_id": "C_kwDOAAsO6NoAKGEwOTkxYjhiYThlYzU3NDZhZjM2YzQ5MTJmZDg4OTVlMzNjZjVmY2E", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-02T15:17:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-02T15:17:30Z"}, "message": "Rollup merge of #99987 - Alexendoo:parse-format-position-span, r=fee1-dead\n\nAlways include a position span in `rustc_parse_format::Argument`\n\nMoves the spans from the `Position` enum to always be included in the `Argument` struct. Doesn't make any changes to use it in rustc, but it will be useful for some upcoming Clippy lints", "tree": {"sha": "2291e971171bbe26a72fa758510b9860f927826d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2291e971171bbe26a72fa758510b9860f927826d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi6UAKCRBK7hj4Ov3rIwAAAxkIAD5DBL1llI+/aGh3a2HmOISV\nEUSqhY8ASdsLtdmkRJffkpENU18dj2Axo6IvPS3BhkbBgqx50O8Mwnt+sx6n6QAQ\nRxnoRU+rTWI/rd2iucqGcQzClb1joFa9zXZGbyFOBpaHtFm8diAvsOb+kxD4M87V\nSPIEx1Rm107K8nq9spxFUBN6p4ilx38dj0aCy2WYkzCoUk7bdCPJQod8/CAV6Woz\nWaGWvKQ56BBo9ezq4tqit5xiuNQgL3VWJ/bidIcTwvFEz+fXcrPv5w1EawfNMY63\nlWxRtEKQo43YNDfHuqn/EcHavOFEI7zckFlKrzD4Ctxhzxr8NgCkGoKt5RZbm/s=\n=Ea8m\n-----END PGP SIGNATURE-----\n", "payload": "tree 2291e971171bbe26a72fa758510b9860f927826d\nparent 792bc5a0102d0973d42183a2b267850bb905236f\nparent 2a0b51d852e3765d257284f91fc3246084c96ee5\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1659453450 +0200\ncommitter GitHub <noreply@github.com> 1659453450 +0200\n\nRollup merge of #99987 - Alexendoo:parse-format-position-span, r=fee1-dead\n\nAlways include a position span in `rustc_parse_format::Argument`\n\nMoves the spans from the `Position` enum to always be included in the `Argument` struct. Doesn't make any changes to use it in rustc, but it will be useful for some upcoming Clippy lints\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "html_url": "https://github.com/rust-lang/rust/commit/a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "792bc5a0102d0973d42183a2b267850bb905236f", "url": "https://api.github.com/repos/rust-lang/rust/commits/792bc5a0102d0973d42183a2b267850bb905236f", "html_url": "https://github.com/rust-lang/rust/commit/792bc5a0102d0973d42183a2b267850bb905236f"}, {"sha": "2a0b51d852e3765d257284f91fc3246084c96ee5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a0b51d852e3765d257284f91fc3246084c96ee5", "html_url": "https://github.com/rust-lang/rust/commit/2a0b51d852e3765d257284f91fc3246084c96ee5"}], "stats": {"total": 137, "additions": 96, "deletions": 41}, "files": [{"sha": "bb64394e21eba5d7c16bf174373a3365de8401d5", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "patch": "@@ -656,7 +656,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                     let span = arg_spans.next().unwrap_or(template_sp);\n \n                     let operand_idx = match arg.position {\n-                        parse::ArgumentIs(idx, _) | parse::ArgumentImplicitlyIs(idx) => {\n+                        parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n                             if idx >= args.operands.len()\n                                 || named_pos.contains_key(&idx)\n                                 || args.reg_args.contains(&idx)\n@@ -702,11 +702,12 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                                 Some(idx)\n                             }\n                         }\n-                        parse::ArgumentNamed(name, span) => {\n+                        parse::ArgumentNamed(name) => {\n                             match args.named_args.get(&Symbol::intern(name)) {\n                                 Some(&idx) => Some(idx),\n                                 None => {\n                                     let msg = format!(\"there is no argument named `{}`\", name);\n+                                    let span = arg.position_span;\n                                     ecx.struct_span_err(\n                                         template_span\n                                             .from_inner(InnerSpan::new(span.start, span.end)),"}, {"sha": "f536d0b5900bccaf1170671c27fa6db0fb1b2f5c", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "patch": "@@ -381,8 +381,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         match *p {\n             parse::String(_) => {}\n             parse::NextArgument(ref mut arg) => {\n-                if let parse::ArgumentNamed(s, _) = arg.position {\n-                    arg.position = parse::ArgumentIs(lookup(s), None);\n+                if let parse::ArgumentNamed(s) = arg.position {\n+                    arg.position = parse::ArgumentIs(lookup(s));\n                 }\n                 if let parse::CountIsName(s, _) = arg.format.width {\n                     arg.format.width = parse::CountIsParam(lookup(s));\n@@ -417,14 +417,14 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n-                    parse::ArgumentIs(i, arg_end) => {\n+                    parse::ArgumentIs(i) => {\n                         self.unused_names_lint.maybe_add_positional_named_arg(\n                             i,\n                             self.args.len(),\n                             i,\n                             PositionalNamedArgType::Arg,\n                             self.curpiece,\n-                            arg_end,\n+                            Some(arg.position_span),\n                             &self.names,\n                         );\n \n@@ -442,8 +442,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                         );\n                         Exact(i)\n                     }\n-                    parse::ArgumentNamed(s, span) => {\n+                    parse::ArgumentNamed(s) => {\n                         let symbol = Symbol::intern(s);\n+                        let span = arg.position_span;\n                         Named(symbol, InnerSpan::new(span.start, span.end))\n                     }\n                 };\n@@ -878,8 +879,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                         // track the current argument ourselves.\n                         let i = self.curarg;\n                         self.curarg += 1;\n-                        parse::ArgumentIs(i, None)\n+                        parse::ArgumentIs(i)\n                     },\n+                    position_span: arg.position_span,\n                     format: parse::FormatSpec {\n                         fill: arg.format.fill,\n                         align: parse::AlignUnknown,"}, {"sha": "a7ff9711691fb2dfd8fbfdccff0c2455206786a3", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "patch": "@@ -70,6 +70,9 @@ pub enum Piece<'a> {\n pub struct Argument<'a> {\n     /// Where to find this argument\n     pub position: Position<'a>,\n+    /// The span of the position indicator. Includes any whitespace in implicit\n+    /// positions (`{  }`).\n+    pub position_span: InnerSpan,\n     /// How to format the argument\n     pub format: FormatSpec<'a>,\n }\n@@ -105,9 +108,9 @@ pub enum Position<'a> {\n     /// The argument is implied to be located at an index\n     ArgumentImplicitlyIs(usize),\n     /// The argument is located at a specific index given in the format,\n-    ArgumentIs(usize, Option<InnerSpan>),\n+    ArgumentIs(usize),\n     /// The argument has a name.\n-    ArgumentNamed(&'a str, InnerSpan),\n+    ArgumentNamed(&'a str),\n }\n \n impl Position<'_> {\n@@ -216,14 +219,15 @@ impl<'a> Iterator for Parser<'a> {\n                 '{' => {\n                     let curr_last_brace = self.last_opening_brace;\n                     let byte_pos = self.to_span_index(pos);\n-                    self.last_opening_brace = Some(byte_pos.to(InnerOffset(byte_pos.0 + 1)));\n+                    let lbrace_end = InnerOffset(byte_pos.0 + 1);\n+                    self.last_opening_brace = Some(byte_pos.to(lbrace_end));\n                     self.cur.next();\n                     if self.consume('{') {\n                         self.last_opening_brace = curr_last_brace;\n \n                         Some(String(self.string(pos + 1)))\n                     } else {\n-                        let arg = self.argument();\n+                        let arg = self.argument(lbrace_end);\n                         if let Some(rbrace_byte_idx) = self.must_consume('}') {\n                             let lbrace_inner_offset = self.to_span_index(pos);\n                             let rbrace_inner_offset = self.to_span_index(rbrace_byte_idx);\n@@ -477,8 +481,16 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `Argument` structure, or what's contained within braces inside the format string.\n-    fn argument(&mut self) -> Argument<'a> {\n+    fn argument(&mut self, start: InnerOffset) -> Argument<'a> {\n         let pos = self.position();\n+\n+        let end = self\n+            .cur\n+            .clone()\n+            .find(|(_, ch)| !ch.is_whitespace())\n+            .map_or(start, |(end, _)| self.to_span_index(end));\n+        let position_span = start.to(end);\n+\n         let format = match self.mode {\n             ParseMode::Format => self.format(),\n             ParseMode::InlineAsm => self.inline_asm(),\n@@ -494,31 +506,19 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Argument { position: pos, format }\n+        Argument { position: pos, position_span, format }\n     }\n \n     /// Parses a positional argument for a format. This could either be an\n     /// integer index of an argument, a named argument, or a blank string.\n     /// Returns `Some(parsed_position)` if the position is not implicitly\n     /// consuming a macro argument, `None` if it's the case.\n     fn position(&mut self) -> Option<Position<'a>> {\n-        let start_position = self.cur.peek().map(|item| item.0);\n         if let Some(i) = self.integer() {\n-            let inner_span = start_position.and_then(|start| {\n-                self.cur\n-                    .peek()\n-                    .cloned()\n-                    .and_then(|item| Some(self.to_span_index(start).to(self.to_span_index(item.0))))\n-            });\n-            Some(ArgumentIs(i, inner_span))\n+            Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(start, c)) if rustc_lexer::is_id_start(c) => {\n-                    let word = self.word();\n-                    let end = start + word.len();\n-                    let span = self.to_span_index(start).to(self.to_span_index(end));\n-                    Some(ArgumentNamed(word, span))\n-                }\n+                Some(&(_, c)) if rustc_lexer::is_id_start(c) => Some(ArgumentNamed(self.word())),\n \n                 // This is an `ArgumentNext`.\n                 // Record the fact and do the resolution after parsing the"}, {"sha": "578530696105d5595e6ae4e5a324af849f2a0c11", "filename": "compiler/rustc_parse_format/src/tests.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs?ref=a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "patch": "@@ -58,14 +58,22 @@ fn invalid06() {\n \n #[test]\n fn format_nothing() {\n-    same(\"{}\", &[NextArgument(Argument { position: ArgumentImplicitlyIs(0), format: fmtdflt() })]);\n+    same(\n+        \"{}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n+            format: fmtdflt(),\n+        })],\n+    );\n }\n #[test]\n fn format_position() {\n     same(\n         \"{3}\",\n         &[NextArgument(Argument {\n-            position: ArgumentIs(3, Some(InnerSpan { start: 2, end: 3 })),\n+            position: ArgumentIs(3),\n+            position_span: InnerSpan { start: 2, end: 3 },\n             format: fmtdflt(),\n         })],\n     );\n@@ -75,17 +83,30 @@ fn format_position_nothing_else() {\n     same(\n         \"{3:}\",\n         &[NextArgument(Argument {\n-            position: ArgumentIs(3, Some(InnerSpan { start: 2, end: 3 })),\n+            position: ArgumentIs(3),\n+            position_span: InnerSpan { start: 2, end: 3 },\n             format: fmtdflt(),\n         })],\n     );\n }\n #[test]\n+fn format_named() {\n+    same(\n+        \"{name}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentNamed(\"name\"),\n+            position_span: InnerSpan { start: 2, end: 6 },\n+            format: fmtdflt(),\n+        })],\n+    )\n+}\n+#[test]\n fn format_type() {\n     same(\n         \"{3:x}\",\n         &[NextArgument(Argument {\n-            position: ArgumentIs(3, Some(InnerSpan { start: 2, end: 3 })),\n+            position: ArgumentIs(3),\n+            position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -105,7 +126,8 @@ fn format_align_fill() {\n     same(\n         \"{3:>}\",\n         &[NextArgument(Argument {\n-            position: ArgumentIs(3, Some(InnerSpan { start: 2, end: 3 })),\n+            position: ArgumentIs(3),\n+            position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignRight,\n@@ -122,7 +144,8 @@ fn format_align_fill() {\n     same(\n         \"{3:0<}\",\n         &[NextArgument(Argument {\n-            position: ArgumentIs(3, Some(InnerSpan { start: 2, end: 3 })),\n+            position: ArgumentIs(3),\n+            position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n                 fill: Some('0'),\n                 align: AlignLeft,\n@@ -139,7 +162,8 @@ fn format_align_fill() {\n     same(\n         \"{3:*<abcd}\",\n         &[NextArgument(Argument {\n-            position: ArgumentIs(3, Some(InnerSpan { start: 2, end: 3 })),\n+            position: ArgumentIs(3),\n+            position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n                 fill: Some('*'),\n                 align: AlignLeft,\n@@ -160,6 +184,7 @@ fn format_counts() {\n         \"{:10x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -177,6 +202,7 @@ fn format_counts() {\n         \"{:10$.10x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -193,7 +219,8 @@ fn format_counts() {\n     same(\n         \"{1:0$.10x}\",\n         &[NextArgument(Argument {\n-            position: ArgumentIs(1, Some(InnerSpan { start: 2, end: 3 })),\n+            position: ArgumentIs(1),\n+            position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -211,6 +238,7 @@ fn format_counts() {\n         \"{:.*x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(1),\n+            position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -228,6 +256,7 @@ fn format_counts() {\n         \"{:.10$x}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -245,6 +274,7 @@ fn format_counts() {\n         \"{:a$.b$?}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -265,6 +295,7 @@ fn format_flags() {\n         \"{:-}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -282,6 +313,7 @@ fn format_flags() {\n         \"{:+#}\",\n         &[NextArgument(Argument {\n             position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n@@ -303,7 +335,8 @@ fn format_mixture() {\n         &[\n             String(\"abcd \"),\n             NextArgument(Argument {\n-                position: ArgumentIs(3, Some(InnerSpan { start: 7, end: 8 })),\n+                position: ArgumentIs(3),\n+                position_span: InnerSpan { start: 7, end: 8 },\n                 format: FormatSpec {\n                     fill: None,\n                     align: AlignUnknown,\n@@ -320,3 +353,22 @@ fn format_mixture() {\n         ],\n     );\n }\n+#[test]\n+fn format_whitespace() {\n+    same(\n+        \"{ }\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 3 },\n+            format: fmtdflt(),\n+        })],\n+    );\n+    same(\n+        \"{  }\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 4 },\n+            format: fmtdflt(),\n+        })],\n+    );\n+}"}, {"sha": "9227bbf011dbfcb2c2d43475778289ed38f2bbf5", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "patch": "@@ -300,7 +300,7 @@ impl<'tcx> OnUnimplementedFormatString {\n             match token {\n                 Piece::String(_) => (), // Normal string, no need to check it\n                 Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s, _) => {\n+                    Position::ArgumentNamed(s) => {\n                         match Symbol::intern(s) {\n                             // `{Self}` is allowed\n                             kw::SelfUpper => (),\n@@ -386,7 +386,7 @@ impl<'tcx> OnUnimplementedFormatString {\n             .map(|p| match p {\n                 Piece::String(s) => s,\n                 Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s, _) => {\n+                    Position::ArgumentNamed(s) => {\n                         let s = Symbol::intern(s);\n                         match generic_map.get(&s) {\n                             Some(val) => val,"}, {"sha": "32718200c0b3a037a2793855e81d0f835bbddcab", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0991b8ba8ec5746af36c4912fd8895e33cf5fca/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=a0991b8ba8ec5746af36c4912fd8895e33cf5fca", "patch": "@@ -441,7 +441,7 @@ impl SimpleFormatArgs {\n         };\n \n         match arg.position {\n-            ArgumentIs(n, _) | ArgumentImplicitlyIs(n) => {\n+            ArgumentIs(n) | ArgumentImplicitlyIs(n) => {\n                 if self.unnamed.len() <= n {\n                     // Use a dummy span to mark all unseen arguments.\n                     self.unnamed.resize_with(n, || vec![DUMMY_SP]);\n@@ -462,7 +462,7 @@ impl SimpleFormatArgs {\n                     }\n                 }\n             },\n-            ArgumentNamed(n, _) => {\n+            ArgumentNamed(n) => {\n                 let n = Symbol::intern(n);\n                 if let Some(x) = self.named.iter_mut().find(|x| x.0 == n) {\n                     match x.1.as_slice() {"}]}