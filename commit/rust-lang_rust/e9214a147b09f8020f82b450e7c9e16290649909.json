{"sha": "e9214a147b09f8020f82b450e7c9e16290649909", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MjE0YTE0N2IwOWY4MDIwZjgyYjQ1MGU3YzllMTYyOTA2NDk5MDk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-09-12T16:04:30Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-09-12T16:04:30Z"}, "message": "codegen: be more explicit about setting giving names to allocas.", "tree": {"sha": "1dfc718fc854fc15e18901cd5226c45ad4248807", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dfc718fc854fc15e18901cd5226c45ad4248807"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9214a147b09f8020f82b450e7c9e16290649909", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9214a147b09f8020f82b450e7c9e16290649909", "html_url": "https://github.com/rust-lang/rust/commit/e9214a147b09f8020f82b450e7c9e16290649909", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9214a147b09f8020f82b450e7c9e16290649909/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f71826e8f26fd4fa331574caa462960db8ed961a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f71826e8f26fd4fa331574caa462960db8ed961a", "html_url": "https://github.com/rust-lang/rust/commit/f71826e8f26fd4fa331574caa462960db8ed961a"}], "stats": {"total": 97, "additions": 42, "deletions": 55}, "files": [{"sha": "2ca517dc3b1a7e8319ece659d0e02c43db65bdf7", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -229,7 +229,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 // We instead thus allocate some scratch space...\n                 let scratch_size = cast.size(bx);\n                 let scratch_align = cast.align(bx);\n-                let llscratch = bx.alloca(cast.llvm_type(bx), \"abi_cast\", scratch_align);\n+                let llscratch = bx.alloca(cast.llvm_type(bx), scratch_align);\n                 bx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value..."}, {"sha": "423a01ad1f9374a6da0a7f61b914bbe6434f4a86", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -387,23 +387,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         )\n     }\n \n-    fn alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n-        bx.dynamic_alloca(ty, name, align)\n+        bx.dynamic_alloca(ty, align)\n     }\n \n-    fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = if name.is_empty() {\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED)\n-            } else {\n-                let name = SmallCStr::new(name);\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty,\n-                                      name.as_ptr())\n-            };\n+            let alloca = llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n@@ -412,16 +406,9 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn array_alloca(&mut self,\n                         ty: &'ll Type,\n                         len: &'ll Value,\n-                        name: &str,\n                         align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = if name.is_empty() {\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED)\n-            } else {\n-                let name = SmallCStr::new(name);\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len,\n-                                           name.as_ptr())\n-            };\n+            let alloca = llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }"}, {"sha": "5fbfe9138f2a46518bdcd2354bf215bde28c1002", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -871,7 +871,7 @@ fn codegen_msvc_try(\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = bx.type_ptr_to(bx.type_i64());\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let slot = bx.alloca(i64p, \"slot\", ptr_align);\n+        let slot = bx.alloca(i64p, ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));"}, {"sha": "d3c59c526c8add0284eb27ec64fcf52139cdf51d", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let llslot = match op.val {\n                     Immediate(_) | Pair(..) => {\n                         let scratch =\n-                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout, \"ret\");\n+                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout);\n                         op.val.store(&mut bx, scratch);\n                         scratch.llval\n                     }\n@@ -767,7 +767,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             match (arg, op.val) {\n                 (&mir::Operand::Copy(_), Ref(_, None, _)) |\n                 (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n-                    let tmp = PlaceRef::alloca(&mut bx, op.layout, \"const\");\n+                    let tmp = PlaceRef::alloca(&mut bx, op.layout);\n                     op.val.store(&mut bx, tmp);\n                     op.val = Ref(tmp.llval, None, tmp.align);\n                 }\n@@ -925,7 +925,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Immediate(_) | Pair(..) => {\n                 match arg.mode {\n                     PassMode::Indirect(..) | PassMode::Cast(_) => {\n-                        let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                        let scratch = PlaceRef::alloca(bx, arg.layout);\n                         op.val.store(bx, scratch);\n                         (scratch.llval, scratch.align, true)\n                     }\n@@ -940,7 +940,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                     // have scary latent bugs around.\n \n-                    let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                    let scratch = PlaceRef::alloca(bx, arg.layout);\n                     base::memcpy_ty(bx, scratch.llval, scratch.align, llval, align,\n                                     op.layout, MemFlags::empty());\n                     (scratch.llval, scratch.align, true)\n@@ -1017,7 +1017,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n                 cx.tcx().types.i32\n             ]));\n-            let slot = PlaceRef::alloca(bx, layout, \"personalityslot\");\n+            let slot = PlaceRef::alloca(bx, layout);\n             self.personality_slot = Some(slot);\n             slot\n         }\n@@ -1116,15 +1116,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout);\n                         tmp.storage_live(bx);\n                         llargs.push(tmp.llval);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result, so we create a temporary `alloca` for the\n                         // result.\n-                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout);\n                         tmp.storage_live(bx);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n@@ -1174,7 +1174,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.layout_of(self.monomorphized_place_ty(&dst.as_ref()));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n-                    let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n+                    let place = PlaceRef::alloca(bx, dst_layout);\n                     place.storage_live(bx);\n                     self.codegen_transmute_into(bx, src, place);\n                     let op = bx.load_operand(place);\n@@ -1227,7 +1227,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if let PassMode::Cast(_) = ret_ty.mode {\n-                    let tmp = PlaceRef::alloca(bx, ret_ty.layout, \"tmp_ret\");\n+                    let tmp = PlaceRef::alloca(bx, ret_ty.layout);\n                     tmp.storage_live(bx);\n                     bx.store_arg_ty(&ret_ty, llval, tmp);\n                     let op = bx.load_operand(tmp);"}, {"sha": "df72980383e29fabe79d061e4a1bd2c2bfdb4482", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -268,11 +268,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n                 if layout.is_unsized() {\n                     let indirect_place =\n-                        PlaceRef::alloca_unsized_indirect(&mut bx, layout, &name.as_str());\n+                        PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                    bx.set_var_name(indirect_place.llval, name);\n                     // FIXME: add an appropriate debuginfo\n                     LocalRef::UnsizedPlace(indirect_place)\n                 } else {\n-                    let place = PlaceRef::alloca(&mut bx, layout, &name.as_str());\n+                    let place = PlaceRef::alloca(&mut bx, layout);\n+                    bx.set_var_name(place.llval, name);\n                     if dbg {\n                         let (scope, span) = fx.debug_loc(mir::SourceInfo {\n                             span: decl.source_info.span,\n@@ -293,14 +295,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     if layout.is_unsized() {\n-                        let indirect_place = PlaceRef::alloca_unsized_indirect(\n-                            &mut bx,\n-                            layout,\n-                            &format!(\"{:?}\", local),\n-                        );\n+                        let indirect_place = PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                        bx.set_var_name(indirect_place.llval, format_args!(\"{:?}\", local));\n                         LocalRef::UnsizedPlace(indirect_place)\n                     } else {\n-                        LocalRef::Place(PlaceRef::alloca(&mut bx, layout, &format!(\"{:?}\", local)))\n+                        let place = PlaceRef::alloca(&mut bx, layout);\n+                        bx.set_var_name(place.llval, format_args!(\"{:?}\", local));\n+                        LocalRef::Place(place)\n                     }\n                 } else {\n                     // If this is an immediate local, we do not create an\n@@ -470,7 +471,8 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n+            bx.set_var_name(place.llval, name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n@@ -558,11 +560,13 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             llarg_idx += 1;\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n-            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout);\n+            bx.set_var_name(tmp.llval, name);\n             indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n-            let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca(bx, arg.layout);\n+            bx.set_var_name(tmp.llval, name);\n             if fx.fn_ty.c_variadic && last_arg_idx.map(|idx| arg_index == idx).unwrap_or(false) {\n                 let va_list_did = match tcx.lang_items().va_list() {\n                     Some(did) => did,"}, {"sha": "aa85d0284f7f99bbee10b92a74539b66a496cf8c", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, \"unsized_tmp\", max_align);\n+        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, max_align);\n         bx.memcpy(lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place."}, {"sha": "d3e6cef8195d718af634794a432db0e4ea48fab6", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -71,25 +71,21 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n-        name: &str\n     ) -> Self {\n-        debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n-        let tmp = bx.alloca(bx.cx().backend_type(layout), name, layout.align.abi);\n+        let tmp = bx.alloca(bx.cx().backend_type(layout), layout.align.abi);\n         Self::new_sized(tmp, layout)\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n     pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n-        name: &str,\n     ) -> Self {\n-        debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n         let ptr_ty = bx.cx().tcx().mk_mut_ptr(layout.ty);\n         let ptr_layout = bx.cx().layout_of(ptr_ty);\n-        Self::alloca(bx, ptr_layout, name)\n+        Self::alloca(bx, ptr_layout)\n     }\n \n     pub fn len<Cx: ConstMethods<'tcx, Value = V>>("}, {"sha": "da8a7971107bee4b9760966a3583b1dca97f4384", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"codegen_rvalue: creating ugly alloca\");\n-                        let scratch = PlaceRef::alloca(&mut bx, operand.layout, \"__unsize_temp\");\n+                        let scratch = PlaceRef::alloca(&mut bx, operand.layout);\n                         scratch.storage_live(&mut bx);\n                         operand.val.store(&mut bx, scratch);\n                         base::coerce_unsized_into(&mut bx, scratch, dest);"}, {"sha": "1886701fb3a88d95e1c9d4c274c1afe2f64039b6", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -109,13 +109,12 @@ pub trait BuilderMethods<'a, 'tcx>:\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value);\n \n-    fn alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n-    fn dynamic_alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n+    fn alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n+    fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn array_alloca(\n         &mut self,\n         ty: Self::Type,\n         len: Self::Value,\n-        name: &str,\n         align: Align,\n     ) -> Self::Value;\n "}, {"sha": "05888c0e733ad10bbcb52a7a40a238d9e29c319c", "filename": "src/test/codegen/personality_lifetimes.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9214a147b09f8020f82b450e7c9e16290649909/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9214a147b09f8020f82b450e7c9e16290649909/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs?ref=e9214a147b09f8020f82b450e7c9e16290649909", "patch": "@@ -20,12 +20,13 @@ pub fn test() {\n     let _s = S;\n     // Check that the personality slot alloca gets a lifetime start in each cleanup block, not just\n     // in the first one.\n+    // CHECK: [[SLOT:%[0-9]+]] = alloca { i8*, i32 }\n     // CHECK-LABEL: cleanup:\n-    // CHECK: bitcast{{.*}}personalityslot\n-    // CHECK-NEXT: call void @llvm.lifetime.start\n+    // CHECK: [[BITCAST:%[0-9]+]] = bitcast { i8*, i32 }* [[SLOT]] to i8*\n+    // CHECK-NEXT: call void @llvm.lifetime.start.{{.*}}({{.*}}, i8* [[BITCAST]])\n     // CHECK-LABEL: cleanup1:\n-    // CHECK: bitcast{{.*}}personalityslot\n-    // CHECK-NEXT: call void @llvm.lifetime.start\n+    // CHECK: [[BITCAST1:%[0-9]+]] = bitcast { i8*, i32 }* [[SLOT]] to i8*\n+    // CHECK-NEXT: call void @llvm.lifetime.start.{{.*}}({{.*}}, i8* [[BITCAST1]])\n     might_unwind();\n     let _t = S;\n     might_unwind();"}]}