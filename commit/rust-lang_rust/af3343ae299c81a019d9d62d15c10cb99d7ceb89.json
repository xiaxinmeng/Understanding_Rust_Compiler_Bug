{"sha": "af3343ae299c81a019d9d62d15c10cb99d7ceb89", "node_id": "C_kwDOAAsO6NoAKGFmMzM0M2FlMjk5YzgxYTAxOWQ5ZDYyZDE1YzEwY2I5OWQ3Y2ViODk", "commit": {"author": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-08-28T16:45:19Z"}, "committer": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-09-06T15:41:08Z"}, "message": "Migrate E0623", "tree": {"sha": "683f76b723443c113bde8fd96146741dfeb349c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/683f76b723443c113bde8fd96146741dfeb349c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af3343ae299c81a019d9d62d15c10cb99d7ceb89", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEAWou4Gq79HasRseDspeR1Nh440UFAmMXahQACgkQspeR1Nh4\n40Xj2w//an1YXD5snhPjijtdKUNldK46c039i8N1p+84e8odhgfCOJbM9PAzL6mn\n00CkAIxnOEtIsQBl9Urx4GdmGIRq+VZtjMYBp5LxPEX/FzmYSTpDhXHcV4rWJfwD\naHGP8Us/UhY5BltOymvKBUGzGAtyM433Nac+dcbainpCi0oy32yLyM2ggIq/ot2K\nP5ceG9xZjmOnwmWNah670qlvUGtYtPxhv8/ZzHZKHnIqclGZnBm+7XRnOwuCcXPa\nSBEF979S5yhDI1jQNmHilqR81iSpiL3loxhSbKRWM5vILC8HCbTch/U3JA0gf0tJ\nZpGjSjDxD03DDZMRX5GtttaCAe9H1zjRGhtJRXaChuCHPaOQrlSYSPRNauLbEwVp\nCAV3fYYU4CLhbTDYdW3WEOBZx/bNvllO4X4EdxJBhWnjS81I9hAowE9bE3BcmI7h\ny82sqjHb2tqJlzbCaFgLlO25T1ufdZv2jO8hzVYAT54RySqosBNDUy0P4JehcbgK\nroc9I8ftnvHEq1E6beBb47Juk2PThFfQ7eLcvCO5hKqN01DsHJLPpT7zWr2rTrbI\nenxX/CnK3CHIzdeoE8Ik1/TROcGDF23kzj2DtJB5wKNjRWxuY+DlsB5iLAiXxYb3\nu+iIH29fI5szqewNgV/PS0lADODy66Pc6YbqDH34E8H8PBDEpV0=\n=3b1r\n-----END PGP SIGNATURE-----", "payload": "tree 683f76b723443c113bde8fd96146741dfeb349c3\nparent 3c7278846102bb829c9a789e91bc43f0ed612943\nauthor Nikita Tomashevich <quant3234@gmail.com> 1661705119 +0300\ncommitter Nikita Tomashevich <quant3234@gmail.com> 1662478868 +0300\n\nMigrate E0623\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af3343ae299c81a019d9d62d15c10cb99d7ceb89", "html_url": "https://github.com/rust-lang/rust/commit/af3343ae299c81a019d9d62d15c10cb99d7ceb89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af3343ae299c81a019d9d62d15c10cb99d7ceb89/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c7278846102bb829c9a789e91bc43f0ed612943", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c7278846102bb829c9a789e91bc43f0ed612943", "html_url": "https://github.com/rust-lang/rust/commit/3c7278846102bb829c9a789e91bc43f0ed612943"}], "stats": {"total": 355, "additions": 234, "deletions": 121}, "files": [{"sha": "478a4bdf8a96610f3e4514168a180d77a3235295", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/af3343ae299c81a019d9d62d15c10cb99d7ceb89/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af3343ae299c81a019d9d62d15c10cb99d7ceb89/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=af3343ae299c81a019d9d62d15c10cb99d7ceb89", "patch": "@@ -104,9 +104,36 @@ infer_relate_object_bound = ...so that it can be closed over into an object\n infer_data_borrowed = ...so that the type `{$name}` is not borrowed for too long\n infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n-[true] ...\n-*[false] {\"\"}\n+    [true] ...\n+    *[false] {\"\"}\n }\n infer_relate_param_bound_2 = ...that is required by this bound\n infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+\n+infer_nothing = {\"\"}\n+\n+infer_lifetime_mismatch = lifetime mismatch\n+\n+infer_declared_different = this parameter and the return type are declared with different lifetimes...\n+infer_data_returned = ...but data{$label_var1_exists ->\n+    [true] {\" \"}from `{$label_var1}`\n+    *[false] {\"\"}\n+} is returned here\n+\n+infer_data_lifetime_flow = ...but data with one lifetime flows into the other here\n+infer_declared_multiple = this type is declared with multiple lifetimes...\n+infer_types_declared_different = these two types are declared with different lifetimes...\n+infer_data_flows = ...but data{$label_var1_exists ->\n+    [true] -> {\" \"}from `{$label_var1}`\n+    *[false] -> {\"\"}\n+} flows{$label_var2_exists ->\n+    [true] -> {\" \"}into `{$label_var2}`\n+    *[false] -> {\"\"}\n+} here\n+\n+infer_lifetime_param_suggestion = consider introducing a named lifetime parameter{$is_impl ->\n+    [true] {\" \"}and update trait if needed\n+    *[false] {\"\"}\n+}\n+infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime"}, {"sha": "932ba1f35afcf4649275411c147404a24aa3c25f", "filename": "compiler/rustc_infer/src/errors.rs", "status": "modified", "additions": 170, "deletions": 3, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/af3343ae299c81a019d9d62d15c10cb99d7ceb89/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3343ae299c81a019d9d62d15c10cb99d7ceb89/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs?ref=af3343ae299c81a019d9d62d15c10cb99d7ceb89", "patch": "@@ -1,7 +1,13 @@\n-use rustc_errors::{fluent, AddSubdiagnostic, DiagnosticMessage, DiagnosticStyledString};\n-use rustc_hir::FnRetTy;\n+use hir::GenericParamKind;\n+use rustc_errors::{\n+    fluent, AddSubdiagnostic, Applicability, DiagnosticMessage, DiagnosticStyledString,\n+};\n+use rustc_hir as hir;\n+use rustc_hir::{FnRetTy, Ty};\n use rustc_macros::SessionDiagnostic;\n-use rustc_span::{BytePos, Span};\n+use rustc_middle::ty::{Region, TyCtxt};\n+use rustc_span::symbol::kw;\n+use rustc_span::{symbol::Ident, BytePos, Span};\n \n use crate::infer::error_reporting::{\n     need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n@@ -252,3 +258,164 @@ impl AddSubdiagnostic for RegionOriginNote<'_> {\n         };\n     }\n }\n+\n+pub enum LifetimeMismatchLabels {\n+    InRet {\n+        param_span: Span,\n+        ret_span: Span,\n+        span: Span,\n+        label_var1: Option<Ident>,\n+    },\n+    Normal {\n+        hir_equal: bool,\n+        ty_sup: Span,\n+        ty_sub: Span,\n+        span: Span,\n+        label_var1: Option<Ident>,\n+        label_var2: Option<Ident>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for LifetimeMismatchLabels {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            LifetimeMismatchLabels::InRet { param_span, ret_span, span, label_var1 } => {\n+                diag.span_label(param_span, fluent::infer::declared_different);\n+                diag.span_label(ret_span, fluent::infer::nothing);\n+                diag.span_label(span, fluent::infer::data_returned);\n+                diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n+                diag.set_arg(\"label_var1\", label_var1.map(|x| x.to_string()).unwrap_or_default());\n+            }\n+            LifetimeMismatchLabels::Normal {\n+                hir_equal,\n+                ty_sup,\n+                ty_sub,\n+                span,\n+                label_var1,\n+                label_var2,\n+            } => {\n+                if hir_equal {\n+                    diag.span_label(ty_sup, fluent::infer::declared_multiple);\n+                    diag.span_label(ty_sub, fluent::infer::nothing);\n+                    diag.span_label(span, fluent::infer::data_lifetime_flow);\n+                } else {\n+                    diag.span_label(ty_sup, fluent::infer::types_declared_different);\n+                    diag.span_label(ty_sub, fluent::infer::nothing);\n+                    diag.span_label(span, fluent::infer::data_flows);\n+                    diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n+                    diag.set_arg(\n+                        \"label_var1\",\n+                        label_var1.map(|x| x.to_string()).unwrap_or_default(),\n+                    );\n+                    diag.set_arg(\"label_var2_exists\", label_var2.is_some());\n+                    diag.set_arg(\n+                        \"label_var2\",\n+                        label_var2.map(|x| x.to_string()).unwrap_or_default(),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AddLifetimeParamsSuggestion<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub sub: Region<'a>,\n+    pub ty_sup: &'a Ty<'a>,\n+    pub ty_sub: &'a Ty<'a>,\n+    pub add_note: bool,\n+}\n+\n+impl AddSubdiagnostic for AddLifetimeParamsSuggestion<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut mk_suggestion = || {\n+            let (\n+                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n+                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n+            ) = (self.ty_sub, self.ty_sup) else {\n+                return false;\n+            };\n+\n+            if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n+                return false;\n+            };\n+\n+            let Some(anon_reg) = self.tcx.is_suitable_region(self.sub) else {\n+                return false;\n+            };\n+\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n+\n+            let node = self.tcx.hir().get(hir_id);\n+            let is_impl = matches!(&node, hir::Node::ImplItem(_));\n+            let generics = match node {\n+                hir::Node::Item(&hir::Item {\n+                    kind: hir::ItemKind::Fn(_, ref generics, ..),\n+                    ..\n+                })\n+                | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n+                | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n+                _ => return false,\n+            };\n+\n+            let suggestion_param_name = generics\n+                .params\n+                .iter()\n+                .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n+                .map(|p| p.name.ident().name)\n+                .find(|i| *i != kw::UnderscoreLifetime);\n+            let introduce_new = suggestion_param_name.is_none();\n+            let suggestion_param_name =\n+                suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n+\n+            debug!(?lifetime_sup.span);\n+            debug!(?lifetime_sub.span);\n+            let make_suggestion = |span: rustc_span::Span| {\n+                if span.is_empty() {\n+                    (span, format!(\"{}, \", suggestion_param_name))\n+                } else if let Ok(\"&\") = self.tcx.sess.source_map().span_to_snippet(span).as_deref()\n+                {\n+                    (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n+                } else {\n+                    (span, suggestion_param_name.clone())\n+                }\n+            };\n+            let mut suggestions =\n+                vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n+\n+            if introduce_new {\n+                let new_param_suggestion = if let Some(first) =\n+                    generics.params.iter().find(|p| !p.name.ident().span.is_empty())\n+                {\n+                    (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n+                } else {\n+                    (generics.span, format!(\"<{}>\", suggestion_param_name))\n+                };\n+\n+                suggestions.push(new_param_suggestion);\n+            }\n+\n+            diag.multipart_suggestion(\n+                fluent::infer::lifetime_param_suggestion,\n+                suggestions,\n+                Applicability::MaybeIncorrect,\n+            );\n+            diag.set_arg(\"is_impl\", is_impl);\n+            true\n+        };\n+        if mk_suggestion() && self.add_note {\n+            diag.note(fluent::infer::lifetime_param_suggestion_elided);\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::lifetime_mismatch, code = \"E0623\")]\n+pub struct LifetimeMismatch<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub labels: LifetimeMismatchLabels,\n+    #[subdiagnostic]\n+    pub suggestion: AddLifetimeParamsSuggestion<'a>,\n+}"}, {"sha": "ebd59a3fef7954aaa02b63ceb95a3a8aa6edeeea", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 31, "deletions": 116, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/af3343ae299c81a019d9d62d15c10cb99d7ceb89/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3343ae299c81a019d9d62d15c10cb99d7ceb89/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=af3343ae299c81a019d9d62d15c10cb99d7ceb89", "patch": "@@ -1,18 +1,20 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n+use crate::errors::AddLifetimeParamsSuggestion;\n+use crate::errors::LifetimeMismatch;\n+use crate::errors::LifetimeMismatchLabels;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::SubregionOrigin;\n use crate::infer::TyCtxt;\n \n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n-use rustc_hir as hir;\n-use rustc_hir::{GenericParamKind, Ty};\n+use rustc_errors::AddSubdiagnostic;\n+use rustc_errors::{Diagnostic, ErrorGuaranteed};\n+use rustc_hir::Ty;\n use rustc_middle::ty::Region;\n-use rustc_span::symbol::kw;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -98,137 +100,50 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_param_sup.pat.simple_ident() {\n-            Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n-            None => String::new(),\n-        };\n-\n-        let span_label_var2 = match anon_param_sub.pat.simple_ident() {\n-            Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n-            None => String::new(),\n-        };\n-\n         debug!(\n             \"try_report_anon_anon_conflict: sub_is_ret_type={:?} sup_is_ret_type={:?}\",\n             sub_is_ret_type, sup_is_ret_type\n         );\n \n-        let mut err = struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\");\n-\n-        match (sup_is_ret_type, sub_is_ret_type) {\n+        let labels = match (sup_is_ret_type, sub_is_ret_type) {\n             (ret_capture @ Some(ret_span), _) | (_, ret_capture @ Some(ret_span)) => {\n                 let param_span =\n                     if sup_is_ret_type == ret_capture { ty_sub.span } else { ty_sup.span };\n-\n-                err.span_label(\n+                LifetimeMismatchLabels::InRet {\n                     param_span,\n-                    \"this parameter and the return type are declared with different lifetimes...\",\n-                );\n-                err.span_label(ret_span, \"\");\n-                err.span_label(span, format!(\"...but data{} is returned here\", span_label_var1));\n-            }\n-\n-            (None, None) => {\n-                if ty_sup.hir_id == ty_sub.hir_id {\n-                    err.span_label(ty_sup.span, \"this type is declared with multiple lifetimes...\");\n-                    err.span_label(ty_sub.span, \"\");\n-                    err.span_label(span, \"...but data with one lifetime flows into the other here\");\n-                } else {\n-                    err.span_label(\n-                        ty_sup.span,\n-                        \"these two types are declared with different lifetimes...\",\n-                    );\n-                    err.span_label(ty_sub.span, \"\");\n-                    err.span_label(\n-                        span,\n-                        format!(\"...but data{} flows{} here\", span_label_var1, span_label_var2),\n-                    );\n+                    ret_span,\n+                    span,\n+                    label_var1: anon_param_sup.pat.simple_ident(),\n                 }\n             }\n-        }\n \n-        if suggest_adding_lifetime_params(self.tcx(), sub, ty_sup, ty_sub, &mut err) {\n-            err.note(\"each elided lifetime in input position becomes a distinct lifetime\");\n-        }\n+            (None, None) => LifetimeMismatchLabels::Normal {\n+                hir_equal: ty_sup.hir_id == ty_sub.hir_id,\n+                ty_sup: ty_sup.span,\n+                ty_sub: ty_sub.span,\n+                span,\n+                label_var1: anon_param_sup.pat.simple_ident(),\n+                label_var2: anon_param_sub.pat.simple_ident(),\n+            },\n+        };\n \n-        let reported = err.emit();\n+        let suggestion =\n+            AddLifetimeParamsSuggestion { tcx: self.tcx(), sub, ty_sup, ty_sub, add_note: true };\n+        let err = LifetimeMismatch { span, labels, suggestion };\n+        let reported = self.tcx().sess.emit_err(err);\n         Some(reported)\n     }\n }\n \n+/// Currently only used in rustc_borrowck, probably should be\n+/// removed in favour of public_errors::AddLifetimeParamsSuggestion\n pub fn suggest_adding_lifetime_params<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sub: Region<'tcx>,\n-    ty_sup: &Ty<'_>,\n-    ty_sub: &Ty<'_>,\n+    ty_sup: &'tcx Ty<'_>,\n+    ty_sub: &'tcx Ty<'_>,\n     err: &mut Diagnostic,\n-) -> bool {\n-    let (\n-        hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n-        hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n-    ) = (ty_sub, ty_sup) else {\n-        return false;\n-    };\n-\n-    if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n-        return false;\n-    };\n-\n-    let Some(anon_reg) = tcx.is_suitable_region(sub) else {\n-        return false;\n-    };\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n-\n-    let node = tcx.hir().get(hir_id);\n-    let is_impl = matches!(&node, hir::Node::ImplItem(_));\n-    let generics = match node {\n-        hir::Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, ref generics, ..), .. })\n-        | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n-        | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n-        _ => return false,\n-    };\n-\n-    let suggestion_param_name = generics\n-        .params\n-        .iter()\n-        .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n-        .map(|p| p.name.ident().name)\n-        .find(|i| *i != kw::UnderscoreLifetime);\n-    let introduce_new = suggestion_param_name.is_none();\n-    let suggestion_param_name =\n-        suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n-\n-    debug!(?lifetime_sup.span);\n-    debug!(?lifetime_sub.span);\n-    let make_suggestion = |span: rustc_span::Span| {\n-        if span.is_empty() {\n-            (span, format!(\"{}, \", suggestion_param_name))\n-        } else if let Ok(\"&\") = tcx.sess.source_map().span_to_snippet(span).as_deref() {\n-            (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n-        } else {\n-            (span, suggestion_param_name.clone())\n-        }\n-    };\n-    let mut suggestions =\n-        vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n-\n-    if introduce_new {\n-        let new_param_suggestion =\n-            if let Some(first) = generics.params.iter().find(|p| !p.name.ident().span.is_empty()) {\n-                (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n-            } else {\n-                (generics.span, format!(\"<{}>\", suggestion_param_name))\n-            };\n-\n-        suggestions.push(new_param_suggestion);\n-    }\n-\n-    let mut sugg = String::from(\"consider introducing a named lifetime parameter\");\n-    if is_impl {\n-        sugg.push_str(\" and update trait if needed\");\n-    }\n-    err.multipart_suggestion(sugg, suggestions, Applicability::MaybeIncorrect);\n-\n-    true\n+) {\n+    let suggestion = AddLifetimeParamsSuggestion { tcx, sub, ty_sup, ty_sub, add_note: false };\n+    suggestion.add_to_diagnostic(err);\n }"}, {"sha": "5810616fcdbf1428313a4d9a63f02cc577ed47b1", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3343ae299c81a019d9d62d15c10cb99d7ceb89/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3343ae299c81a019d9d62d15c10cb99d7ceb89/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=af3343ae299c81a019d9d62d15c10cb99d7ceb89", "patch": "@@ -36,5 +36,9 @@ extern crate tracing;\n extern crate rustc_middle;\n \n mod errors;\n+pub mod public_errors {\n+    // Probably would be useful in rustc_borrowck\n+    pub use super::errors::AddLifetimeParamsSuggestion;\n+}\n pub mod infer;\n pub mod traits;"}]}