{"sha": "e71202aecf47db99225101f842474490121d8a69", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MTIwMmFlY2Y0N2RiOTkyMjUxMDFmODQyNDc0NDkwMTIxZDhhNjk=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-05-05T21:53:57Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-05-15T05:52:31Z"}, "message": "Change dynamic_library::open_external to take ToCStr\n\n`std::unstable::dynamic_library::open_external` currently takes a\n`Path`, but because `Paths` produce normalized strings, this can\nchange the semantics of lookups in a given environment. This patch\ngeneralizes the function to take a `ToCStr`-bounded type, which\nincludes both `Path`s and `str`s.\n\nCloses #11650.", "tree": {"sha": "e0def54255b05ed7e024fcf5879fc6596fedb48a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0def54255b05ed7e024fcf5879fc6596fedb48a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e71202aecf47db99225101f842474490121d8a69", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e71202aecf47db99225101f842474490121d8a69", "html_url": "https://github.com/rust-lang/rust/commit/e71202aecf47db99225101f842474490121d8a69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e71202aecf47db99225101f842474490121d8a69/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "046062d3bf0597fb2f40f7cacbbe4f438506247d", "url": "https://api.github.com/repos/rust-lang/rust/commits/046062d3bf0597fb2f40f7cacbbe4f438506247d", "html_url": "https://github.com/rust-lang/rust/commit/046062d3bf0597fb2f40f7cacbbe4f438506247d"}], "stats": {"total": 31, "additions": 23, "deletions": 8}, "files": [{"sha": "68bfde84e2a2dc76966e272e5823854a55e323e6", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e71202aecf47db99225101f842474490121d8a69/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71202aecf47db99225101f842474490121d8a69/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=e71202aecf47db99225101f842474490121d8a69", "patch": "@@ -45,12 +45,22 @@ impl Drop for DynamicLibrary {\n }\n \n impl DynamicLibrary {\n+    // FIXME (#12938): Until DST lands, we cannot decompose &str into\n+    // & and str, so we cannot usefully take ToCStr arguments by\n+    // reference (without forcing an additional & around &str). So we\n+    // are instead temporarily adding an instance for &Path, so that\n+    // we can take ToCStr as owned. When DST lands, the &Path instance\n+    // should be removed, and arguments bound by ToCStr should be\n+    // passed by reference. (Here: in the `open` method.)\n+\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n-    pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> {\n+    pub fn open<T: ToCStr>(filename: Option<T>)\n+                        -> Result<DynamicLibrary, ~str> {\n         unsafe {\n+            let mut filename = filename;\n             let maybe_library = dl::check_for_errors_in(|| {\n-                match filename {\n+                match filename.take() {\n                     Some(name) => dl::open_external(name),\n                     None => dl::open_internal()\n                 }\n@@ -114,7 +124,8 @@ mod test {\n     fn test_loading_cosine() {\n         // The math library does not need to be loaded since it is already\n         // statically linked in\n-        let libm = match DynamicLibrary::open(None) {\n+        let none: Option<Path> = None; // appease the typechecker\n+        let libm = match DynamicLibrary::open(none) {\n             Err(error) => fail!(\"Could not load self as module: {}\", error),\n             Ok(libm) => libm\n         };\n@@ -142,7 +153,7 @@ mod test {\n     fn test_errors_do_not_crash() {\n         // Open /dev/null as a library to get an error, and make sure\n         // that only causes an error, and not a crash.\n-        let path = GenericPath::new(\"/dev/null\");\n+        let path = Path::new(\"/dev/null\");\n         match DynamicLibrary::open(Some(&path)) {\n             Err(_) => {}\n             Ok(_) => fail!(\"Successfully opened the empty library.\")\n@@ -157,12 +168,11 @@ mod test {\n pub mod dl {\n     use c_str::ToCStr;\n     use libc;\n-    use path;\n     use ptr;\n     use str;\n     use result::*;\n \n-    pub unsafe fn open_external(filename: &path::Path) -> *u8 {\n+    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n         filename.with_c_str(|raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int) as *u8\n         })\n@@ -223,9 +233,14 @@ pub mod dl {\n     use os;\n     use ptr;\n     use result::{Ok, Err, Result};\n+    use str;\n+    use c_str::ToCStr;\n \n-    pub unsafe fn open_external(filename: &path::Path) -> *u8 {\n-        os::win32::as_utf16_p(filename.as_str().unwrap(), |raw_name| {\n+    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n+        // Windows expects Unicode data\n+        let filename_cstr = filename.to_c_str();\n+        let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n+        os::win32::as_utf16_p(filename_str, |raw_name| {\n             LoadLibraryW(raw_name as *libc::c_void) as *u8\n         })\n     }"}]}