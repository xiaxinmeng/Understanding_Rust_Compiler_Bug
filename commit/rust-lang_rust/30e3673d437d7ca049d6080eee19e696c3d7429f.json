{"sha": "30e3673d437d7ca049d6080eee19e696c3d7429f", "node_id": "C_kwDOAAsO6NoAKDMwZTM2NzNkNDM3ZDdjYTA0OWQ2MDgwZWVlMTllNjk2YzNkNzQyOWY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-04T22:21:15Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-08T02:06:48Z"}, "message": "Add associated item binding to non-param-ty where clause suggestions", "tree": {"sha": "2be19a3d0efde4f4799201313c83153d9bcdcb95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2be19a3d0efde4f4799201313c83153d9bcdcb95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30e3673d437d7ca049d6080eee19e696c3d7429f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30e3673d437d7ca049d6080eee19e696c3d7429f", "html_url": "https://github.com/rust-lang/rust/commit/30e3673d437d7ca049d6080eee19e696c3d7429f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30e3673d437d7ca049d6080eee19e696c3d7429f/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dbbf0f49398d6c74fd3337dd171fac6c7aa3d12", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dbbf0f49398d6c74fd3337dd171fac6c7aa3d12", "html_url": "https://github.com/rust-lang/rust/commit/0dbbf0f49398d6c74fd3337dd171fac6c7aa3d12"}], "stats": {"total": 121, "additions": 65, "deletions": 56}, "files": [{"sha": "a56fac7c4dd2ca8bd7b8a1beee419a7b195aff2d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=30e3673d437d7ca049d6080eee19e696c3d7429f", "patch": "@@ -12,7 +12,7 @@ pub mod util;\n use crate::infer::canonical::Canonical;\n use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtKind, Predicate, Ty, TyCtxt};\n+use crate::ty::{self, AdtKind, Ty, TyCtxt};\n \n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n@@ -416,7 +416,7 @@ pub enum ObligationCauseCode<'tcx> {\n     BinOp {\n         rhs_span: Option<Span>,\n         is_lit: bool,\n-        output_pred: Option<Predicate<'tcx>>,\n+        output_ty: Option<Ty<'tcx>>,\n     },\n }\n "}, {"sha": "fc6a77d400d47071ff700acf2c23a36bb43ce9f3", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=30e3673d437d7ca049d6080eee19e696c3d7429f", "patch": "@@ -102,13 +102,25 @@ pub fn suggest_arbitrary_trait_bound<'tcx>(\n     generics: &hir::Generics<'_>,\n     err: &mut Diagnostic,\n     trait_pred: PolyTraitPredicate<'tcx>,\n+    associated_ty: Option<(&'static str, Ty<'tcx>)>,\n ) -> bool {\n     if !trait_pred.is_suggestable(tcx, false) {\n         return false;\n     }\n \n     let param_name = trait_pred.skip_binder().self_ty().to_string();\n-    let constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n+    let mut constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n+\n+    if let Some((name, term)) = associated_ty {\n+        // FIXME: this case overlaps with code in TyCtxt::note_and_explain_type_err.\n+        // That should be extracted into a helper function.\n+        if constraint.ends_with('>') {\n+            constraint = format!(\"{}, {}={}>\", &constraint[..constraint.len() - 1], name, term);\n+        } else {\n+            constraint.push_str(&format!(\"<{}={}>\", name, term));\n+        }\n+    }\n+\n     let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n \n     // Skip, there is a param named Self"}, {"sha": "595c68166bc8ff6607b731079a82a4833197087b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=30e3673d437d7ca049d6080eee19e696c3d7429f", "patch": "@@ -25,8 +25,7 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n-    ProjectionPredicate, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n-    TypeVisitable,\n+    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_session::Limit;\n@@ -174,7 +173,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-        proj_pred: Option<ty::PolyProjectionPredicate<'tcx>>,\n+        associated_item: Option<(&'static str, Ty<'tcx>)>,\n         body_id: hir::HirId,\n     );\n \n@@ -467,7 +466,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         mut err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-        proj_pred: Option<ty::PolyProjectionPredicate<'tcx>>,\n+        associated_ty: Option<(&'static str, Ty<'tcx>)>,\n         body_id: hir::HirId,\n     ) {\n         let trait_pred = self.resolve_numeric_literals_with_default(trait_pred);\n@@ -604,21 +603,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         trait_pred.print_modifiers_and_trait_path().to_string()\n                     );\n \n-                    if let Some(proj_pred) = proj_pred {\n-                        let ProjectionPredicate { projection_ty, term } = proj_pred.skip_binder();\n-                        let item = self.tcx.associated_item(projection_ty.item_def_id);\n-\n+                    if let Some((name, term)) = associated_ty {\n                         // FIXME: this case overlaps with code in TyCtxt::note_and_explain_type_err.\n                         // That should be extracted into a helper function.\n                         if constraint.ends_with('>') {\n                             constraint = format!(\n                                 \"{}, {}={}>\",\n                                 &constraint[..constraint.len() - 1],\n-                                item.name,\n+                                name,\n                                 term\n                             );\n                         } else {\n-                            constraint.push_str(&format!(\"<{}={}>\", item.name, term));\n+                            constraint.push_str(&format!(\"<{}={}>\", name, term));\n                         }\n                     }\n \n@@ -648,7 +644,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ..\n                 }) if !param_ty => {\n                     // Missing generic type parameter bound.\n-                    if suggest_arbitrary_trait_bound(self.tcx, generics, &mut err, trait_pred) {\n+                    if suggest_arbitrary_trait_bound(\n+                        self.tcx,\n+                        generics,\n+                        &mut err,\n+                        trait_pred,\n+                        associated_ty,\n+                    ) {\n                         return;\n                     }\n                 }"}, {"sha": "2196a799fd0b693e2f7e23498447f0729734885c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=30e3673d437d7ca049d6080eee19e696c3d7429f", "patch": "@@ -409,7 +409,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rhs_span: opt_input_expr.map(|expr| expr.span),\n                     is_lit: opt_input_expr\n                         .map_or(false, |expr| matches!(expr.kind, ExprKind::Lit(_))),\n-                    output_pred: None,\n+                    output_ty: None,\n                 },\n             ),\n             self.param_env,"}, {"sha": "249e9c66ba72ad958334b0613d826abefdaee4a7", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=30e3673d437d7ca049d6080eee19e696c3d7429f", "patch": "@@ -20,10 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{\n-    self, AssocKind, DefIdTree, GenericParamDefKind, ProjectionPredicate, ProjectionTy,\n-    ToPredicate, Ty, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TypeVisitable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n@@ -337,22 +334,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        let opt_output_ty =\n-            expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n-        let opt_output_assoc_item = self.tcx.associated_items(trait_def_id).find_by_name_and_kind(\n-            self.tcx,\n-            Ident::from_str(\"Output\"),\n-            AssocKind::Type,\n-            trait_def_id,\n-        );\n-        let output_pred =\n-            opt_output_ty.zip(opt_output_assoc_item).map(|(output_ty, output_assoc_item)| {\n-                ty::Binder::dummy(ty::PredicateKind::Projection(ProjectionPredicate {\n-                    projection_ty: ProjectionTy { substs, item_def_id: output_assoc_item.def_id },\n-                    term: output_ty.into(),\n-                }))\n-                .to_predicate(self.tcx)\n-            });\n+        let output_ty = expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n \n         (\n             traits::Obligation::new(\n@@ -363,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         rhs_span: opt_input_expr.map(|expr| expr.span),\n                         is_lit: opt_input_expr\n                             .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                        output_pred,\n+                        output_ty,\n                     },\n                 ),\n                 self.param_env,\n@@ -518,7 +500,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rhs_span: opt_input_expr.map(|expr| expr.span),\n                     is_lit: opt_input_expr\n                         .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                    output_pred: None,\n+                    output_ty: None,\n                 },\n             )\n         } else {"}, {"sha": "4754717c29aba777494a494f9822e8f7b9cfdad9", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e3673d437d7ca049d6080eee19e696c3d7429f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=30e3673d437d7ca049d6080eee19e696c3d7429f", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -310,10 +310,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // error types are considered \"builtin\"\n             Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n             Err(errors) => {\n-                let (_, item) = lang_item_for_op(self.tcx, Op::Binary(op, is_assign), op.span);\n-                let missing_trait =\n-                    item.map(|def_id| with_no_trimmed_paths!(self.tcx.def_path_str(def_id)));\n-                let (mut err, use_output) = match is_assign {\n+                let (_, trait_def_id) =\n+                    lang_item_for_op(self.tcx, Op::Binary(op, is_assign), op.span);\n+                let missing_trait = trait_def_id\n+                    .map(|def_id| with_no_trimmed_paths!(self.tcx.def_path_str(def_id)));\n+                let (mut err, output_def_id) = match is_assign {\n                     IsAssign::Yes => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -328,7 +329,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n                         );\n                         self.note_unmet_impls_on_type(&mut err, errors);\n-                        (err, false)\n+                        (err, None)\n                     }\n                     IsAssign::No => {\n                         let message = match op.node {\n@@ -368,19 +369,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 lhs_ty\n                             ),\n                         };\n-                        let use_output = item.map_or(false, |def_id| {\n-                            self.tcx.associated_item_def_ids(def_id).iter().any(|item_def_id| {\n-                                self.tcx.opt_associated_item(*item_def_id).unwrap().name\n-                                    == sym::Output\n-                            })\n+                        let output_def_id = trait_def_id.and_then(|def_id| {\n+                            self.tcx\n+                                .associated_item_def_ids(def_id)\n+                                .iter()\n+                                .find(|item_def_id| {\n+                                    self.tcx.associated_item(*item_def_id).name == sym::Output\n+                                })\n+                                .cloned()\n                         });\n                         let mut err = struct_span_err!(self.tcx.sess, op.span, E0369, \"{message}\");\n                         if !lhs_expr.span.eq(&rhs_expr.span) {\n                             err.span_label(lhs_expr.span, lhs_ty.to_string());\n                             err.span_label(rhs_expr.span, rhs_ty.to_string());\n                         }\n                         self.note_unmet_impls_on_type(&mut err, errors);\n-                        (err, use_output)\n+                        (err, output_def_id)\n                     }\n                 };\n \n@@ -488,20 +492,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if let Some(trait_pred) =\n                                     error.obligation.predicate.to_opt_poly_trait_pred()\n                                 {\n-                                    let proj_pred = match error.obligation.cause.code() {\n+                                    let output_associated_item = match error.obligation.cause.code()\n+                                    {\n                                         ObligationCauseCode::BinOp {\n-                                            output_pred: Some(output_pred),\n+                                            output_ty: Some(output_ty),\n                                             ..\n-                                        } if use_output => {\n-                                            output_pred.to_opt_poly_projection_pred()\n+                                        } => {\n+                                            // Make sure that we're attaching `Output = ..` to the right trait predicate\n+                                            if let Some(output_def_id) = output_def_id\n+                                                && let Some(trait_def_id) = trait_def_id\n+                                                && self.tcx.parent(output_def_id) == trait_def_id\n+                                            {\n+                                                Some((\"Output\", *output_ty))\n+                                            } else {\n+                                                None\n+                                            }\n                                         }\n                                         _ => None,\n                                     };\n \n                                     self.suggest_restricting_param_bound(\n                                         &mut err,\n                                         trait_pred,\n-                                        proj_pred,\n+                                        output_associated_item,\n                                         self.body_id,\n                                     );\n                                 }"}, {"sha": "b67e334d40ac23f0fda1c06cdf65ce2cb73435b5", "filename": "src/test/ui/traits/resolution-in-overloaded-op.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30e3673d437d7ca049d6080eee19e696c3d7429f/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30e3673d437d7ca049d6080eee19e696c3d7429f/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr?ref=30e3673d437d7ca049d6080eee19e696c3d7429f", "patch": "@@ -8,8 +8,8 @@ LL |     a * b\n    |\n help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n-LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64> {\n-   |                                                  ++++++++++++++++++\n+LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64, Output=f64> {\n+   |                                                  ++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}]}