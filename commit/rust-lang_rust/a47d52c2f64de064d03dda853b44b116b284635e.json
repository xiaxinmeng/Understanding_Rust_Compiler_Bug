{"sha": "a47d52c2f64de064d03dda853b44b116b284635e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0N2Q1MmMyZjY0ZGUwNjRkMDNkZGE4NTNiNDRiMTE2YjI4NDYzNWU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-03-19T04:31:40Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-03-28T16:13:09Z"}, "message": "collections: remove List\n\nIt was decided in a meeting that this module wasn't needed,\nand more thought should be put into a persistent collections\nlibrary.", "tree": {"sha": "505b46ae35bfceaa341015b016a4a75f3438c030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/505b46ae35bfceaa341015b016a4a75f3438c030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a47d52c2f64de064d03dda853b44b116b284635e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a47d52c2f64de064d03dda853b44b116b284635e", "html_url": "https://github.com/rust-lang/rust/commit/a47d52c2f64de064d03dda853b44b116b284635e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a47d52c2f64de064d03dda853b44b116b284635e/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8601a3d8b91ad3b653d143307611f2f5c75617e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8601a3d8b91ad3b653d143307611f2f5c75617e", "html_url": "https://github.com/rust-lang/rust/commit/b8601a3d8b91ad3b653d143307611f2f5c75617e"}], "stats": {"total": 297, "additions": 34, "deletions": 263}, "files": [{"sha": "722d9a722056c0fc736a2aa6000587eae0d03469", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a47d52c2f64de064d03dda853b44b116b284635e/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47d52c2f64de064d03dda853b44b116b284635e/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a47d52c2f64de064d03dda853b44b116b284635e", "patch": "@@ -27,8 +27,6 @@\n \n extern crate collections;\n \n-use collections::list::{List, Cons, Nil};\n-\n use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n use std::cell::{Cell, RefCell};\n@@ -87,7 +85,7 @@ pub struct Arena {\n     // access the head.\n     priv head: Chunk,\n     priv copy_head: Chunk,\n-    priv chunks: RefCell<@List<Chunk>>,\n+    priv chunks: RefCell<Vec<Chunk>>,\n }\n \n impl Arena {\n@@ -99,7 +97,7 @@ impl Arena {\n         Arena {\n             head: chunk(initial_size, false),\n             copy_head: chunk(initial_size, true),\n-            chunks: RefCell::new(@Nil),\n+            chunks: RefCell::new(Vec::new()),\n         }\n     }\n }\n@@ -117,7 +115,7 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            for chunk in self.chunks.get().iter() {\n+            for chunk in self.chunks.borrow().iter() {\n                 if !chunk.is_copy.get() {\n                     destroy_chunk(chunk);\n                 }\n@@ -179,7 +177,7 @@ impl Arena {\n     fn alloc_copy_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.set(@Cons(self.copy_head.clone(), self.chunks.get()));\n+        self.chunks.borrow_mut().push(self.copy_head.clone());\n         self.copy_head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), true);\n \n@@ -219,7 +217,7 @@ impl Arena {\n                          -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.set(@Cons(self.head.clone(), self.chunks.get()));\n+        self.chunks.borrow_mut().push(self.head.clone());\n         self.head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), false);\n "}, {"sha": "2ffc1d2fddc526a65338e205115fef0b80d8a5c2", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a47d52c2f64de064d03dda853b44b116b284635e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47d52c2f64de064d03dda853b44b116b284635e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=a47d52c2f64de064d03dda853b44b116b284635e", "patch": "@@ -33,7 +33,6 @@ pub use deque::Deque;\n pub use dlist::DList;\n pub use enum_set::EnumSet;\n pub use hashmap::{HashMap, HashSet};\n-pub use list::List;\n pub use lru_cache::LruCache;\n pub use priority_queue::PriorityQueue;\n pub use ringbuf::RingBuf;\n@@ -47,7 +46,6 @@ pub mod deque;\n pub mod dlist;\n pub mod enum_set;\n pub mod hashmap;\n-pub mod list;\n pub mod lru_cache;\n pub mod priority_queue;\n pub mod ringbuf;"}, {"sha": "18da9671419eeff111c0abd7ae060778cf9c4d1b", "filename": "src/libcollections/list.rs", "status": "removed", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/b8601a3d8b91ad3b653d143307611f2f5c75617e/src%2Flibcollections%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8601a3d8b91ad3b653d143307611f2f5c75617e/src%2Flibcollections%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flist.rs?ref=b8601a3d8b91ad3b653d143307611f2f5c75617e", "patch": "@@ -1,237 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A standard, garbage-collected linked list.\n-\n-use std::container::Container;\n-\n-#[deriving(Clone, Eq)]\n-#[allow(missing_doc)]\n-pub enum List<T> {\n-    Cons(T, @List<T>),\n-    Nil,\n-}\n-\n-pub struct Items<'a, T> {\n-    priv head: &'a List<T>,\n-    priv next: Option<&'a @List<T>>\n-}\n-\n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        match self.next {\n-            None => match *self.head {\n-                Nil => None,\n-                Cons(ref value, ref tail) => {\n-                    self.next = Some(tail);\n-                    Some(value)\n-                }\n-            },\n-            Some(next) => match **next {\n-                Nil => None,\n-                Cons(ref value, ref tail) => {\n-                    self.next = Some(tail);\n-                    Some(value)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> List<T> {\n-    /// Returns a forward iterator\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items {\n-            head: self,\n-            next: None\n-        }\n-    }\n-\n-    /// Returns the first element of a list\n-    pub fn head<'a>(&'a self) -> Option<&'a T> {\n-        match *self {\n-          Nil => None,\n-          Cons(ref head, _) => Some(head)\n-        }\n-    }\n-\n-    /// Returns all but the first element of a list\n-    pub fn tail(&self) -> Option<@List<T>> {\n-        match *self {\n-            Nil => None,\n-            Cons(_, tail) => Some(tail)\n-        }\n-    }\n-}\n-\n-impl<T> Container for List<T> {\n-    /// Returns the length of a list\n-    fn len(&self) -> uint { self.iter().len() }\n-\n-    /// Returns true if the list is empty\n-    fn is_empty(&self) -> bool { match *self { Nil => true, _ => false } }\n-}\n-\n-impl<T:Eq> List<T> {\n-    /// Returns true if a list contains an element with the given value\n-    pub fn contains(&self, element: T) -> bool {\n-        self.iter().any(|list_element| *list_element == element)\n-    }\n-}\n-\n-impl<T:'static + Clone> List<T> {\n-    /// Create a list from a vector\n-    pub fn from_vec(v: &[T]) -> List<T> {\n-        match v.len() {\n-            0 => Nil,\n-            _ => v.rev_iter().fold(Nil, |tail, value: &T| Cons(value.clone(), @tail))\n-        }\n-    }\n-\n-    /// Appends one list to another, returning a new list\n-    pub fn append(&self, other: List<T>) -> List<T> {\n-        match other {\n-            Nil => return self.clone(),\n-            _ => match *self {\n-                Nil => return other,\n-                Cons(ref value, tail) => Cons(value.clone(), @tail.append(other))\n-            }\n-        }\n-    }\n-\n-    /// Push one element into the front of a list, returning a new list\n-    pub fn unshift(&self, element: T) -> List<T> {\n-        Cons(element, @(self.clone()))\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use list::{List, Nil};\n-    use list;\n-\n-    #[test]\n-    fn test_iter() {\n-        let list = List::from_vec([0, 1, 2]);\n-        let mut iter = list.iter();\n-        assert_eq!(&0, iter.next().unwrap());\n-        assert_eq!(&1, iter.next().unwrap());\n-        assert_eq!(&2, iter.next().unwrap());\n-        assert_eq!(None, iter.next());\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        let empty : list::List<int> = List::from_vec([]);\n-        let full1 = List::from_vec([1]);\n-        let full2 = List::from_vec(['r', 'u']);\n-\n-        assert!(empty.is_empty());\n-        assert!(!full1.is_empty());\n-        assert!(!full2.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.head().unwrap(), &0);\n-\n-        let mut tail = list.tail().unwrap();\n-        assert_eq!(tail.head().unwrap(), &1);\n-\n-        tail = tail.tail().unwrap();\n-        assert_eq!(tail.head().unwrap(), &2);\n-    }\n-\n-    #[test]\n-    fn test_from_vec_empty() {\n-        let empty : list::List<int> = List::from_vec([]);\n-        assert!(empty == Nil::<int>);\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        fn add_(a: uint, b: &uint) -> uint { a + *b }\n-        fn subtract_(a: uint, b: &uint) -> uint { a - *b }\n-\n-        let empty = Nil::<uint>;\n-        assert_eq!(empty.iter().fold(0u, add_), 0u);\n-        assert_eq!(empty.iter().fold(10u, subtract_), 10u);\n-\n-        let list = List::from_vec([0u, 1u, 2u, 3u, 4u]);\n-        assert_eq!(list.iter().fold(0u, add_), 10u);\n-        assert_eq!(list.iter().fold(10u, subtract_), 0u);\n-    }\n-\n-    #[test]\n-    fn test_find_success() {\n-        fn match_(i: & &int) -> bool { **i == 2 }\n-\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.iter().find(match_).unwrap(), &2);\n-    }\n-\n-    #[test]\n-    fn test_find_fail() {\n-        fn match_(_i: & &int) -> bool { false }\n-\n-        let empty = Nil::<int>;\n-        assert_eq!(empty.iter().find(match_), None);\n-\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.iter().find(match_), None);\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        fn match_(i: &int) -> bool { *i == 2 }\n-\n-        let empty = Nil::<int>;\n-        assert_eq!(empty.iter().any(match_), false);\n-\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.iter().any(match_), true);\n-    }\n-\n-    #[test]\n-    fn test_contains() {\n-        let empty = Nil::<int>;\n-        assert!((!empty.contains(5)));\n-\n-        let list = List::from_vec([5, 8, 6]);\n-        assert!((list.contains(5)));\n-        assert!((!list.contains(7)));\n-        assert!((list.contains(8)));\n-    }\n-\n-    #[test]\n-    fn test_len() {\n-        let empty = Nil::<int>;\n-        assert_eq!(empty.len(), 0u);\n-\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.len(), 3u);\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        assert!(List::from_vec([1, 2, 3, 4]) ==\n-                List::from_vec([1, 2]).append(List::from_vec([3, 4])));\n-    }\n-\n-    #[test]\n-    fn test_unshift() {\n-        let list = List::from_vec([1]);\n-        let new_list = list.unshift(0);\n-        assert_eq!(list.len(), 1u);\n-        assert_eq!(new_list.len(), 2u);\n-        assert!(new_list == List::from_vec([0, 1]));\n-    }\n-}"}, {"sha": "9943ed17b3aca6f68ff7b459c9492e6eaf993cc8", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a47d52c2f64de064d03dda853b44b116b284635e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47d52c2f64de064d03dda853b44b116b284635e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=a47d52c2f64de064d03dda853b44b116b284635e", "patch": "@@ -72,7 +72,6 @@ use util::nodemap::{DefIdMap, FnvHashMap};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n-use collections::List;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n@@ -327,7 +326,7 @@ pub fn require_same_types(tcx: &ty::ctxt,\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::Region\n-pub type isr_alist = @List<(ty::BoundRegion, ty::Region)>;\n+pub type isr_alist = @Vec<(ty::BoundRegion, ty::Region)>;\n \n trait get_region<'a, T:'static> {\n     fn get(&'a self, br: ty::BoundRegion) -> ty::Region;"}, {"sha": "fc7e6a03bcfbd03aae345358858b448b04e7feaf", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a47d52c2f64de064d03dda853b44b116b284635e/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47d52c2f64de064d03dda853b44b116b284635e/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=a47d52c2f64de064d03dda853b44b116b284635e", "patch": "@@ -13,12 +13,16 @@\n extern crate collections;\n extern crate time;\n \n-use collections::list::{List, Cons, Nil};\n use time::precise_time_s;\n use std::os;\n use std::task;\n use std::vec;\n \n+#[deriving(Clone)]\n+enum List<T> {\n+    Nil, Cons(T, @List<T>)\n+}\n+\n enum UniqueList {\n     ULNil, ULCons(~UniqueList)\n }"}, {"sha": "7e120658aaefd149e019fd4470c57d5bc3f073e5", "filename": "src/test/run-pass/log-knows-the-names-of-variants-in-std.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a47d52c2f64de064d03dda853b44b116b284635e/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47d52c2f64de064d03dda853b44b116b284635e/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs?ref=a47d52c2f64de064d03dda853b44b116b284635e", "patch": "@@ -10,9 +10,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate collections;\n-use collections::list::List;\n-\n #[deriving(Clone)]\n enum foo {\n   a(uint),\n@@ -24,9 +21,21 @@ fn check_log<T>(exp: ~str, v: T) {\n }\n \n pub fn main() {\n-    let x = List::from_vec([a(22u), b(~\"hi\")]);\n-    let exp = ~\"Cons(a(22u), @Cons(b(~\\\"hi\\\"), @Nil))\";\n+    let mut x = Some(a(22u));\n+    let exp = ~\"Some(a(22u))\";\n+    let act = format!(\"{:?}\", x);\n+    assert_eq!(act, exp);\n+    check_log(exp, x);\n+\n+    x = Some(b(~\"hi\"));\n+    let exp = ~\"Some(b(~\\\"hi\\\"))\";\n+    let act = format!(\"{:?}\", x);\n+    assert_eq!(act, exp);\n+    check_log(exp, x);\n+\n+    x = None;\n+    let exp = ~\"None\";\n     let act = format!(\"{:?}\", x);\n-    assert!(act == exp);\n+    assert_eq!(act, exp);\n     check_log(exp, x);\n }"}, {"sha": "70654da893298d416ff054f59d6afb8d61a1ed94", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a47d52c2f64de064d03dda853b44b116b284635e/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47d52c2f64de064d03dda853b44b116b284635e/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=a47d52c2f64de064d03dda853b44b116b284635e", "patch": "@@ -16,21 +16,21 @@ extern crate collections;\n \n use collections::list::{List, Cons, Nil};\n \n-fn pure_length_go<T>(ls: @List<T>, acc: uint) -> uint {\n-    match *ls { Nil => { acc } Cons(_, tl) => { pure_length_go(tl, acc + 1u) } }\n+fn pure_length_go<T>(ls: &List<T>, acc: uint) -> uint {\n+    match *ls { Nil => { acc } Cons(_, ref tl) => { pure_length_go(&**tl, acc + 1u) } }\n }\n \n-fn pure_length<T>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n+fn pure_length<T>(ls: &List<T>) -> uint { pure_length_go(ls, 0u) }\n \n-fn nonempty_list<T>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n+fn nonempty_list<T>(ls: &List<T>) -> bool { pure_length(ls) > 0u }\n \n-fn safe_head<T:Clone>(ls: @List<T>) -> T {\n+fn safe_head<T:Clone>(ls: &List<T>) -> T {\n     assert!(!ls.is_empty());\n     return ls.head().unwrap().clone();\n }\n \n pub fn main() {\n-    let mylist = @Cons(@1u, @Nil);\n-    assert!((nonempty_list(mylist)));\n-    assert_eq!(*safe_head(mylist), 1u);\n+    let mylist = Cons(1u, ~Nil);\n+    assert!((nonempty_list(&mylist)));\n+    assert_eq!(safe_head(&mylist), 1u);\n }"}]}