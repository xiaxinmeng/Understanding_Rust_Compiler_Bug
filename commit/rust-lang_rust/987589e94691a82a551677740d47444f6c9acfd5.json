{"sha": "987589e94691a82a551677740d47444f6c9acfd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NzU4OWU5NDY5MWE4MmE1NTE2Nzc3NDBkNDc0NDRmNmM5YWNmZDU=", "commit": {"author": {"name": "Jeffrey Yasskin", "email": "jyasskin@gmail.com", "date": "2010-07-24T19:33:29Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-07T00:17:04Z"}, "message": "Change the destructor-ordering test to use channels instead of a shared mutable object.\nThis test used to take advantage of a hole in the type system that allows\nobjects with destructors to refer to stateful objects.", "tree": {"sha": "b92d1528f6a05ed9250b489f300241a43bdb1777", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b92d1528f6a05ed9250b489f300241a43bdb1777"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/987589e94691a82a551677740d47444f6c9acfd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/987589e94691a82a551677740d47444f6c9acfd5", "html_url": "https://github.com/rust-lang/rust/commit/987589e94691a82a551677740d47444f6c9acfd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/987589e94691a82a551677740d47444f6c9acfd5/comments", "author": {"login": "jyasskin", "id": 83420, "node_id": "MDQ6VXNlcjgzNDIw", "avatar_url": "https://avatars.githubusercontent.com/u/83420?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyasskin", "html_url": "https://github.com/jyasskin", "followers_url": "https://api.github.com/users/jyasskin/followers", "following_url": "https://api.github.com/users/jyasskin/following{/other_user}", "gists_url": "https://api.github.com/users/jyasskin/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyasskin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyasskin/subscriptions", "organizations_url": "https://api.github.com/users/jyasskin/orgs", "repos_url": "https://api.github.com/users/jyasskin/repos", "events_url": "https://api.github.com/users/jyasskin/events{/privacy}", "received_events_url": "https://api.github.com/users/jyasskin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdb842f9e6d28b51fa51935d66c77011f27a436b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdb842f9e6d28b51fa51935d66c77011f27a436b", "html_url": "https://github.com/rust-lang/rust/commit/fdb842f9e6d28b51fa51935d66c77011f27a436b"}], "stats": {"total": 118, "additions": 79, "deletions": 39}, "files": [{"sha": "aaf2e94f68eaf061aab9b000b2acad3e9874cd9e", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/987589e94691a82a551677740d47444f6c9acfd5/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/987589e94691a82a551677740d47444f6c9acfd5/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=987589e94691a82a551677740d47444f6c9acfd5", "patch": "@@ -389,6 +389,7 @@ TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     test/run-pass/child-outlives-parent.rs \\\n                     test/run-pass/clone-with-exterior.rs \\\n                     test/run-pass/constrained-type.rs \\\n+                    test/run-pass/destructor-ordering.rs \\\n                     test/run-pass/obj-as.rs \\\n                     test/run-pass/vec-slice.rs \\\n                     test/run-pass/fn-lval.rs \\"}, {"sha": "f7f5b8c82c3d4f80a347f2f9074fb4eefce3b5b7", "filename": "src/test/run-pass/destructor-ordering.rs", "status": "modified", "additions": 78, "deletions": 39, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/987589e94691a82a551677740d47444f6c9acfd5/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987589e94691a82a551677740d47444f6c9acfd5/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs?ref=987589e94691a82a551677740d47444f6c9acfd5", "patch": "@@ -1,76 +1,115 @@\n-// We share an instance of this type among all the destructor-order\n-// checkers.  It tracks how many destructors have run so far and\n-// 'fail's when one runs out of order.\n-// FIXME: Make it easier to collect a failure message.\n-state obj order_tracker(mutable int init) {\n-  fn assert_order(int expected, str fail_message) {\n-    if (expected != init) {\n-      log expected;\n+// This test checks that destructors run in the right order.  Because\n+// stateful objects can't have destructors, we have the destructors\n+// record their expected order into a channel when they execute (so\n+// the object becomes 'io' rather than 'state').  Then each test case\n+// asserts that the channel produces values in ascending order.\n+//\n+// FIXME: Write an int->str function and concatenate the whole failure\n+// message into a single log statement (or, even better, a print).\n+//\n+// FIXME: check_order should take only 1 line in a test, not 2+a block\n+// block. Since destructor-having objects can't refer to mutable state\n+// (like the port), we'd need a with-like construct to do the same for\n+// stateful objects within a scope.\n+//\n+// FIXME #21: Each test should execute in its own task, so it can fail\n+// independently, writing its error message to a channel that the\n+// parent task aggregates.\n+\n+type order_info = rec(int order, str msg);\n+\n+io fn check_order(port[order_info] expected_p) {\n+  chan(expected_p) <| rec(order=-1, msg=\"\");\n+  let mutable int actual = 0;\n+  auto expected <- expected_p;  // FIXME #121: Workaround for while(true) bug.\n+  auto done = -1;  // FIXME: Workaround for typechecking bug.\n+  while(expected.order != done) {\n+    if (expected.order != actual) {\n+      log expected.order;\n       log \" != \";\n-      log init;\n-      log fail_message;\n+      log actual;\n+      log expected.msg;\n       fail;\n     }\n-    init += 1;\n+    actual += 1;\n+    expected <- expected_p;\n   }\n }\n \n \n-obj dorder(@order_tracker tracker, int order, str message) {\n+obj dorder(chan[order_info] expected, int order, str message) {\n   drop {\n-    tracker.assert_order(order, message);\n+    expected <| rec(order=order, msg=message);\n   }\n }\n \n-fn test_simple() {\n-  auto tracker = @order_tracker(0);\n+io fn test_simple() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n   dorder(tracker, 1, \"Reverse decl order\");\n   dorder(tracker, 0, \"Reverse decl order\");\n+  check_order(tracker_p);\n }\n \n-fn test_block() {\n-  auto tracker = @order_tracker(0);\n-  dorder(tracker, 2, \"Before block\");\n+io fn test_block() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n   {\n-    dorder(tracker, 0, \"Inside block\");\n+    dorder(tracker, 2, \"Before block\");\n+    {\n+      dorder(tracker, 0, \"Inside block\");\n+    }\n+    dorder(tracker, 1, \"After block\");\n   }\n-  dorder(tracker, 1, \"After block\");\n+  check_order(tracker_p);\n }\n \n-fn test_decl_v_init() {\n-  auto tracker = @order_tracker(0);\n-  auto var1;\n-  auto var2;\n-  var2 = dorder(tracker, 0, \"decl, not init\");\n-  var1 = dorder(tracker, 1, \"decl, not init\");\n+io fn test_decl_v_init() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n+  {\n+    auto var1;\n+    auto var2;\n+    var2 = dorder(tracker, 0, \"decl, not init\");\n+    var1 = dorder(tracker, 1, \"decl, not init\");\n+  }\n+  check_order(tracker_p);\n }\n \n-fn test_overwritten_obj() {\n-  auto tracker = @order_tracker(0);\n-  auto var1 = dorder(tracker, 0, \"overwritten object destroyed first\");\n-  auto var2 = dorder(tracker, 2, \"destroyed at end of scope\");\n-  var1 = dorder(tracker, 3, \"overwriter deleted in rev decl order\");\n+io fn test_overwritten_obj() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n   {\n-    dorder(tracker, 1, \"overwritten object destroyed before end of scope\");\n+    auto var1 = dorder(tracker, 0, \"overwritten object destroyed first\");\n+    auto var2 = dorder(tracker, 2, \"destroyed at end of scope\");\n+    var1 = dorder(tracker, 3, \"overwriter deleted in rev decl order\");\n+    {\n+      dorder(tracker, 1, \"overwritten object destroyed before end of scope\");\n+    }\n   }\n+  check_order(tracker_p);\n }\n \n // Used to embed dorder objects into an expression.  Note that the\n // parameters don't get destroyed.\n fn combine_dorders(dorder d1, dorder d2) -> int {\n   ret 1;\n }\n-fn test_expression_destroyed_right_to_left() {\n-  auto tracker = @order_tracker(0);\n-  combine_dorders(dorder(tracker, 4, \"\"), dorder(tracker, 3, \"\"))\n-    / combine_dorders(dorder(tracker, 2, \"\"), dorder(tracker, 1, \"\"));\n+io fn test_expression_destroyed_right_to_left() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n   {\n-    dorder(tracker, 0,\n-           \"expression objects live to end of block, not statement\");\n+    combine_dorders(dorder(tracker, 4, \"\"), dorder(tracker, 3, \"\"))\n+      / combine_dorders(dorder(tracker, 2, \"\"), dorder(tracker, 1, \"\"));\n+    {\n+      dorder(tracker, 0,\n+             \"expression objects live to end of block, not statement\");\n+    }\n   }\n+  check_order(tracker_p);\n }\n \n-fn main() {\n+io fn main() {\n   test_simple();\n   test_block();\n   test_decl_v_init();"}]}