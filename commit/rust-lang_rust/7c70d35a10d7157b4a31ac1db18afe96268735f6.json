{"sha": "7c70d35a10d7157b4a31ac1db18afe96268735f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNzBkMzVhMTBkNzE1N2I0YTMxYWMxZGIxOGFmZTk2MjY4NzM1ZjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T00:46:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T01:53:14Z"}, "message": "rewrite unify in a modal style, extend result module", "tree": {"sha": "c852c3ad865269dcee01613dfcf3d0ff2ea11844", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c852c3ad865269dcee01613dfcf3d0ff2ea11844"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c70d35a10d7157b4a31ac1db18afe96268735f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c70d35a10d7157b4a31ac1db18afe96268735f6", "html_url": "https://github.com/rust-lang/rust/commit/7c70d35a10d7157b4a31ac1db18afe96268735f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c70d35a10d7157b4a31ac1db18afe96268735f6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9086c6f5a2ac3e09c358d05700bfbcb18378bdf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9086c6f5a2ac3e09c358d05700bfbcb18378bdf6", "html_url": "https://github.com/rust-lang/rust/commit/9086c6f5a2ac3e09c358d05700bfbcb18378bdf6"}], "stats": {"total": 631, "additions": 369, "deletions": 262}, "files": [{"sha": "0efd38904a09ad84781772d5abb3008572c69071", "filename": "src/libcore/result.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7c70d35a10d7157b4a31ac1db18afe96268735f6/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c70d35a10d7157b4a31ac1db18afe96268735f6/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7c70d35a10d7157b4a31ac1db18afe96268735f6", "patch": "@@ -89,6 +89,86 @@ fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n     }\n }\n \n+// ______________________________________________________________________\n+// Note:\n+//\n+// These helper functions are written in a \"pre-chained\" (a.k.a,\n+// deforested) style because I have found that, in practice, this is\n+// the most concise way to do things.  That means that they do not not\n+// terminate with a call to `ok(v)` but rather `nxt(v)`.  If you would\n+// like to just get the result, just pass in `ok` as `nxt`.\n+\n+#[doc = \"\n+Maps each element in the vector `ts` using the operation `op`.  Should an\n+error occur, no further mappings are performed and the error is returned.\n+Should no error occur, a vector containing the result of each map is\n+passed to the `nxt` function.\n+\n+Here is an example which increments every integer in a vector,\n+checking for overflow:\n+\n+    fn inc_conditionally(x: uint) -> result<uint,str> {\n+        if x == uint::max_value { ret err(\\\"overflow\\\"); }\n+        else { ret ok(x+1u); }\n+    }\n+    map([1u, 2u, 3u], inc_conditionally) {|incd|\n+        assert incd == [2u, 3u, 4u];\n+    }\n+\n+Note: if you have to combine a deforested style transform with map,\n+you should use `ok` for the `nxt` operation, as shown here (this is an\n+alternate version of the previous example where the\n+`inc_conditionally()` routine is deforested):\n+\n+    fn inc_conditionally<T>(x: uint,\n+                            nxt: fn(uint) -> result<T,str>) -> result<T,str> {\n+        if x == uint::max_value { ret err(\\\"overflow\\\"); }\n+        else { ret nxt(x+1u); }\n+    }\n+    map([1u, 2u, 3u], inc_conditionally(_, ok)) {|incd|\n+        assert incd == [2u, 3u, 4u];\n+    }\n+\"]\n+fn map<T,U:copy,V:copy,W>(ts: [T],\n+                          op: fn(T) -> result<V,U>,\n+                          nxt: fn([V]) -> result<W,U>) -> result<W,U> {\n+    let mut vs: [V] = [];\n+    vec::reserve(vs, vec::len(ts));\n+    for t in ts {\n+        alt op(t) {\n+          ok(v) { vs += [v]; }\n+          err(u) { ret err(u); }\n+        }\n+    }\n+    ret nxt(vs);\n+}\n+\n+#[doc = \"Same as map, but it operates over two parallel vectors.\n+\n+A precondition is used here to ensure that the vectors are the same\n+length.  While we do not often use preconditions in the standard\n+library, a precondition is used here because result::t is generally\n+used in 'careful' code contexts where it is both appropriate and easy\n+to accommodate an error like the vectors being of different lengths.\"]\n+fn map2<S,T,U:copy,V:copy,W>(ss: [S], ts: [T],\n+                             op: fn(S,T) -> result<V,U>,\n+                             nxt: fn([V]) -> result<W,U>)\n+    : vec::same_length(ss, ts)\n+    -> result<W,U> {\n+    let n = vec::len(ts);\n+    let mut vs = [];\n+    vec::reserve(vs, n);\n+    let mut i = 0u;\n+    while i < n {\n+        alt op(ss[i],ts[i]) {\n+          ok(v) { vs += [v]; }\n+          err(u) { ret err(u); }\n+        }\n+        i += 1u;\n+    }\n+    ret nxt(vs);\n+}\n+\n #[cfg(test)]\n mod tests {\n     fn op1() -> result::result<int, str> { result::ok(666) }"}, {"sha": "dd9a86c4b6a199cabfc3a4825def0d18ff5e11b5", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 263, "deletions": 234, "changes": 497, "blob_url": "https://github.com/rust-lang/rust/blob/7c70d35a10d7157b4a31ac1db18afe96268735f6/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c70d35a10d7157b4a31ac1db18afe96268735f6/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=7c70d35a10d7157b4a31ac1db18afe96268735f6", "patch": "@@ -287,6 +287,7 @@ enum type_err {\n     terr_ref_mutability,\n     terr_vec_mutability,\n     terr_tuple_size(uint, uint),\n+    terr_ty_param_size(uint, uint),\n     terr_record_size(uint, uint),\n     terr_record_mutability,\n     terr_record_fields(ast::ident, ast::ident),\n@@ -1550,26 +1551,21 @@ fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n //\n //     http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf\n mod unify {\n-    export fixup_result;\n+    import result::{result, ok, err, chain, map, map2};\n+\n     export fixup_vars;\n-    export fix_ok;\n-    export fix_err;\n     export mk_var_bindings;\n     export resolve_type_structure;\n     export resolve_type_var;\n-    export result;\n     export unify;\n-    export ures_ok;\n-    export ures_err;\n     export var_bindings;\n     export precise, in_bindings;\n \n-    enum result { ures_ok(t), ures_err(type_err), }\n-    enum union_result { unres_ok, unres_err(type_err), }\n-    enum fixup_result {\n-        fix_ok(t), // fixup succeeded\n-        fix_err(int), // fixup failed because a type variable was unresolved\n-    }\n+    type ures<T> = result<T,type_err>;\n+\n+    // in case of failure, value is the idx of an unresolved type var\n+    type fres<T> = result<T,int>;\n+\n     type var_bindings =\n         {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n \n@@ -1584,8 +1580,10 @@ mod unify {\n     }\n \n     // Unifies two sets.\n-    fn union(cx: @uctxt, set_a: uint, set_b: uint,\n-             variance: variance) -> union_result {\n+    fn union<T:copy>(\n+        cx: @uctxt, set_a: uint, set_b: uint,\n+        variance: variance, nxt: fn() -> ures<T>) -> ures<T> {\n+\n         let vb = alt cx.st {\n             in_bindings(vb) { vb }\n             _ { cx.tcx.sess.bug(\"someone forgot to document an invariant \\\n@@ -1606,76 +1604,80 @@ mod unify {\n         alt smallintmap::find(vb.types, root_a) {\n           none {\n             alt smallintmap::find(vb.types, root_b) {\n-              none { ufind::union(vb.sets, set_a, set_b); ret unres_ok; }\n-              some(t_b) { replace_type(vb, t_b); ret unres_ok; }\n+              none { ufind::union(vb.sets, set_a, set_b); ret nxt(); }\n+              some(t_b) { replace_type(vb, t_b); ret nxt(); }\n             }\n           }\n           some(t_a) {\n             alt smallintmap::find(vb.types, root_b) {\n-              none { replace_type(vb, t_a); ret unres_ok; }\n+              none { replace_type(vb, t_a); ret nxt(); }\n               some(t_b) {\n-                alt unify_step(cx, t_a, t_b, variance) {\n-                  ures_ok(t_c) { replace_type(vb, t_c); ret unres_ok; }\n-                  ures_err(terr) { ret unres_err(terr); }\n-                }\n+                ret unify_step(cx, t_a, t_b, variance) {|t_c|\n+                    replace_type(vb, t_c);\n+                    nxt()\n+                };\n               }\n             }\n           }\n         }\n     }\n \n-    fn record_var_binding(cx: @uctxt, key: int, typ: t, variance: variance)\n-        -> result {\n+    fn record_var_binding<T:copy>(\n+        cx: @uctxt, key: int,\n+        typ: t, variance: variance,\n+        nxt: fn(t) -> ures<T>) -> ures<T> {\n+\n         let vb = alt check cx.st { in_bindings(vb) { vb } };\n         ufind::grow(vb.sets, (key as uint) + 1u);\n         let root = ufind::find(vb.sets, key as uint);\n         let result_type = typ;\n         alt smallintmap::find(vb.types, root) {\n           some(old_type) {\n-            alt unify_step(cx, old_type, typ, variance) {\n-              ures_ok(unified_type) { result_type = unified_type; }\n-              rs { ret rs; }\n+            alt unify_step(cx, old_type, typ, variance, {|v| ok(v)}) {\n+              ok(unified_type) { result_type = unified_type; }\n+              err(e) { ret err(e); }\n             }\n           }\n           none {/* fall through */ }\n         }\n         smallintmap::insert(vb.types, root, result_type);\n-        ret ures_ok(mk_var(cx.tcx, key));\n+        ret nxt(mk_var(cx.tcx, key));\n     }\n \n     // Simple structural type comparison.\n-    fn struct_cmp(cx: @uctxt, expected: t, actual: t) -> result {\n+    fn struct_cmp<T:copy>(\n+        cx: @uctxt, expected: t, actual: t,\n+        nxt: fn(t) -> ures<T>) -> ures<T> {\n+\n         let tcx = cx.tcx;\n         let cfg = tcx.sess.targ_cfg;\n         if mach_sty(cfg, expected) == mach_sty(cfg, actual) {\n-            ret ures_ok(expected);\n+            ret nxt(expected);\n         }\n-        ret ures_err(terr_mismatch);\n+        ret err(terr_mismatch);\n     }\n \n     // Right now this just checks that the lists of constraints are\n     // pairwise equal.\n-    fn unify_constrs(base_t: t, expected: [@type_constr],\n-                     actual: [@type_constr]) -> result {\n-        let expected_len = vec::len(expected);\n-        let actual_len = vec::len(actual);\n-\n-        if expected_len != actual_len {\n-            ret ures_err(terr_constr_len(expected_len, actual_len));\n-        }\n-        let i = 0u;\n-        let rslt;\n-        for c: @type_constr in expected {\n-            rslt = unify_constr(base_t, c, actual[i]);\n-            alt rslt { ures_ok(_) { } ures_err(_) { ret rslt; } }\n-            i += 1u;\n+    fn unify_constrs<T:copy>(\n+        expected: [@type_constr],\n+        actual: [@type_constr],\n+        nxt: fn([@type_constr]) -> ures<T>) -> ures<T> {\n+\n+        if check vec::same_length(expected, actual) {\n+            map2(expected, actual,\n+                 {|e,a| unify_constr(e, a, {|v| ok(v)})}, nxt)\n+        } else {\n+            ret err(terr_constr_len(expected.len(), actual.len()));\n         }\n-        ret ures_ok(base_t);\n     }\n-    fn unify_constr(base_t: t, expected: @type_constr,\n-                    actual_constr: @type_constr) -> result {\n-        let ok_res = ures_ok(base_t);\n-        let err_res = ures_err(terr_constr_mismatch(expected, actual_constr));\n+\n+    fn unify_constr<T:copy>(\n+        expected: @type_constr,\n+        actual_constr: @type_constr,\n+        nxt: fn(@type_constr) -> ures<T>) -> ures<T> {\n+\n+        let err_res = err(terr_constr_mismatch(expected, actual_constr));\n         if expected.node.id != actual_constr.node.id { ret err_res; }\n         let expected_arg_len = vec::len(expected.node.args);\n         let actual_arg_len = vec::len(actual_constr.node.args);\n@@ -1703,13 +1705,14 @@ mod unify {\n             }\n             i += 1u;\n         }\n-        ret ok_res;\n+        ret nxt(expected);\n     }\n \n     // Unifies two mutability flags.\n-    fn unify_mut(expected: ast::mutability, actual: ast::mutability,\n-                 variance: variance) ->\n-       option<(ast::mutability, variance)> {\n+    fn unify_mut<T:copy>(\n+        expected: ast::mutability, actual: ast::mutability,\n+        variance: variance, mut_err: type_err,\n+        nxt: fn(ast::mutability, variance) -> ures<T>) -> ures<T> {\n \n         // If you're unifying on something mutable then we have to\n         // be invariant on the inner type\n@@ -1722,20 +1725,25 @@ mod unify {\n           }\n         };\n \n-        if expected == actual { ret some((expected, newvariance)); }\n+        if expected == actual {\n+            ret nxt(expected, newvariance);\n+        }\n         if variance == covariant {\n             if expected == ast::m_const {\n-                ret some((actual, newvariance));\n+                ret nxt(actual, newvariance);\n             }\n         } else if variance == contravariant {\n             if actual == ast::m_const {\n-                ret some((expected, newvariance));\n+                ret nxt(expected, newvariance);\n             }\n         }\n-        ret none;\n+        ret err(mut_err);\n     }\n-    fn unify_fn_proto(e_proto: ast::proto, a_proto: ast::proto,\n-                      variance: variance) -> option<result> {\n+\n+    fn unify_fn_proto<T:copy>(\n+        e_proto: ast::proto, a_proto: ast::proto, variance: variance,\n+        nxt: fn(ast::proto) -> ures<T>) -> ures<T> {\n+\n         // Prototypes form a diamond-shaped partial order:\n         //\n         //        block\n@@ -1757,90 +1765,91 @@ mod unify {\n         }\n \n         ret alt variance {\n-          invariant if e_proto == a_proto { none }\n-          covariant if sub_proto(a_proto, e_proto) { none }\n-          contravariant if sub_proto(e_proto, a_proto) { none }\n-          _ { some(ures_err(terr_mismatch)) }\n+          invariant if e_proto == a_proto { nxt(e_proto) }\n+          covariant if sub_proto(a_proto, e_proto) { nxt(e_proto) }\n+          contravariant if sub_proto(e_proto, a_proto) { nxt(e_proto) }\n+          _ { ret err(terr_mismatch) }\n         };\n     }\n-    fn unify_args(cx: @uctxt, e_args: [arg], a_args: [arg],\n-                  variance: variance) -> either<result, [arg]> {\n-        if !vec::same_length(e_args, a_args) {\n-            ret either::left(ures_err(terr_arg_count));\n-        }\n-        // The variance changes (flips basically) when descending\n-        // into arguments of function types\n-        let variance = variance_transform(variance, contravariant);\n-        // Would use vec::map2(), but for the need to return in case of\n-        // error:\n-        let i = 0u, result = [];\n-        for expected_input in e_args {\n-            let actual_input = a_args[i];\n-            i += 1u;\n \n-            // Unify the result modes.\n-            let result_mode =\n-                alt unify_mode(cx.tcx, expected_input.mode,\n-                               actual_input.mode) {\n-                  result::err(err) { ret either::left(ures_err(err)); }\n-                  result::ok(m) { m }\n-                };\n+    fn unify_arg<T:copy>(\n+        cx: @uctxt, e_arg: arg, a_arg: arg,\n+        variance: variance,\n+        nxt: fn(arg) -> ures<T>) -> ures<T> {\n \n-            alt unify_step(cx, expected_input.ty, actual_input.ty,\n-                           variance) {\n-              ures_ok(rty) { result += [{mode: result_mode, ty: rty}]; }\n-              err { ret either::left(err); }\n+        // Unify the result modes.\n+        chain(unify_mode(cx.tcx, e_arg.mode, a_arg.mode)) {|mode|\n+            unify_step(cx, e_arg.ty, a_arg.ty, variance) {|ty|\n+                nxt({mode: mode, ty: ty})\n             }\n         }\n-        either::right(result)\n     }\n-    fn unify_fn(cx: @uctxt, e_f: fn_ty, a_f: fn_ty, variance: variance)\n-        -> result {\n-        alt unify_fn_proto(e_f.proto, a_f.proto, variance) {\n-          some(err) { ret err; }\n-          none { /* fall through */ }\n+\n+    fn unify_args<T:copy>(\n+        cx: @uctxt, e_args: [arg], a_args: [arg],\n+        variance: variance, nxt: fn([arg]) -> ures<T>) -> ures<T> {\n+\n+        if check vec::same_length(e_args, a_args) {\n+            // The variance changes (flips basically) when descending\n+            // into arguments of function types\n+            let variance = variance_transform(variance, contravariant);\n+            map2(e_args, a_args,\n+                 {|e,a| unify_arg(cx, e, a, variance, {|v| ok(v)})},\n+                 nxt)\n+        } else {\n+            ret err(terr_arg_count);\n         }\n+    }\n \n-        if a_f.ret_style != ast::noreturn && a_f.ret_style != e_f.ret_style {\n+    fn unify_ret_style<T:copy>(\n+        e_ret_style: ret_style,\n+        a_ret_style: ret_style,\n+        nxt: fn(ret_style) -> ures<T>) -> ures<T> {\n+\n+        if a_ret_style != ast::noreturn && a_ret_style != e_ret_style {\n             /* even though typestate checking is mostly\n                responsible for checking control flow annotations,\n                this check is necessary to ensure that the\n                annotation in an object method matches the\n                declared object type */\n-            ret ures_err(terr_ret_style_mismatch(e_f.ret_style,\n-                                                 a_f.ret_style));\n+            ret err(terr_ret_style_mismatch(e_ret_style, a_ret_style));\n+        } else {\n+            nxt(a_ret_style)\n         }\n-        let result_ins = alt unify_args(cx, e_f.inputs, a_f.inputs,\n-                                        variance) {\n-            either::left(err) { ret err; }\n-            either::right(ts) { ts }\n-        };\n+    }\n \n-        // Check the output.\n-        alt unify_step(cx, e_f.output, a_f.output, variance) {\n-          ures_ok(rty) {\n-            ures_ok(mk_fn(cx.tcx, {proto: e_f.proto,\n-                                   inputs: result_ins,\n-                                   output: rty\n-                                   with a_f}))\n-          }\n-          x { x }\n+    fn unify_fn<T:copy>(\n+        cx: @uctxt, e_f: fn_ty, a_f: fn_ty, variance: variance,\n+        nxt: fn(t) -> ures<T>) -> ures<T> {\n+\n+        unify_fn_proto(e_f.proto, a_f.proto, variance) {|proto|\n+            unify_ret_style(e_f.ret_style, a_f.ret_style) {|rs|\n+                unify_args(cx, e_f.inputs, a_f.inputs, variance) {|args|\n+                    unify_step(cx, e_f.output, a_f.output, variance) {|rty|\n+                        let cs = e_f.constraints; // FIXME: Unify?\n+                        nxt(mk_fn(cx.tcx, {proto: proto,\n+                                           inputs: args,\n+                                           output: rty,\n+                                           ret_style: rs,\n+                                           constraints: cs}))\n+                    }\n+                }\n+            }\n         }\n     }\n \n     // If the given type is a variable, returns the structure of that type.\n-    fn resolve_type_structure(vb: @var_bindings, typ: t) ->\n-       fixup_result {\n+    fn resolve_type_structure(vb: @var_bindings, typ: t) -> fres<t> {\n         alt get(typ).struct {\n           ty_var(vid) {\n-            if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n+            if vid as uint >= ufind::set_count(vb.sets) { ret err(vid); }\n             let root_id = ufind::find(vb.sets, vid as uint);\n             alt smallintmap::find::<t>(vb.types, root_id) {\n-              none { ret fix_err(vid); }\n-              some(rt) { ret fix_ok(rt); }\n+              none { ret err(vid); }\n+              some(rt) { ret ok(rt); }\n             }\n           }\n-          _ { ret fix_ok(typ); }\n+          _ { ret ok(typ); }\n         }\n     }\n \n@@ -1886,199 +1895,214 @@ mod unify {\n         }\n     }\n \n-    fn unify_tps(cx: @uctxt, expected_tps: [t], actual_tps: [t],\n-                 variance: variance, finish: fn([t]) -> t) -> result {\n-        let result_tps = [], i = 0u;\n-        for exp in expected_tps {\n-            let act = actual_tps[i];\n-            i += 1u;\n-            let result = unify_step(cx, exp, act, variance);\n-            alt result {\n-              ures_ok(rty) { result_tps += [rty]; }\n-              _ { ret result; }\n-            }\n+    fn unify_tys<T:copy>(\n+        cx: @uctxt, expected_tps: [t], actual_tps: [t],\n+        variance: variance, nxt: fn([t]) -> ures<T>)\n+        : vec::same_length(expected_tps, actual_tps)\n+        -> ures<T> {\n+\n+        map2(expected_tps, actual_tps,\n+             {|e,a| unify_step(cx, e, a, variance, {|v| ok(v)})},\n+             nxt)\n+    }\n+\n+    fn unify_tps<T:copy>(\n+        cx: @uctxt, expected_tps: [t], actual_tps: [t],\n+        variance: variance, nxt: fn([t]) -> ures<T>)\n+        -> ures<T> {\n+\n+        if check vec::same_length(expected_tps, actual_tps) {\n+            map2(expected_tps, actual_tps,\n+                 {|e,a| unify_step(cx, e, a, variance, {|v| ok(v)})},\n+                 nxt)\n+        } else {\n+            err(terr_ty_param_size(expected_tps.len(),\n+                                   actual_tps.len()))\n         }\n-        ures_ok(finish(result_tps))\n-    }\n-    fn unify_mt(cx: @uctxt, e_mt: mt, a_mt: mt, variance: variance,\n-                mut_err: type_err, finish: fn(ctxt, mt) -> t) -> result {\n-        alt unify_mut(e_mt.mutbl, a_mt.mutbl, variance) {\n-          none { ures_err(mut_err) }\n-          some((mutt, var)) {\n-            alt unify_step(cx, e_mt.ty, a_mt.ty, var) {\n-              ures_ok(result_sub) {\n-                ures_ok(finish(cx.tcx, {ty: result_sub, mutbl: mutt}))\n-              }\n-              err { err }\n+    }\n+\n+    fn unify_mt<T:copy>(\n+        cx: @uctxt, e_mt: mt, a_mt: mt, variance: variance,\n+        mut_err: type_err,\n+        nxt: fn(mt) -> ures<T>) -> ures<T> {\n+        unify_mut(e_mt.mutbl, a_mt.mutbl, variance, mut_err) {|mutbl,var|\n+            unify_step(cx, e_mt.ty, a_mt.ty, var) {|ty|\n+                nxt({ty: ty, mutbl: mutbl})\n             }\n-          }\n         }\n     }\n-    fn unify_regions(cx: @uctxt, e_region: region, a_region: region,\n-                     variance: variance) -> option<region> {\n+\n+    fn unify_regions<T:copy>(\n+        cx: @uctxt, e_region: region, a_region: region,\n+        variance: variance,\n+        nxt: fn(region) -> ures<T>) -> ures<T> {\n         let sub, super;\n         alt variance {\n             covariant { super = e_region; sub = a_region; }\n             contravariant { super = a_region; sub = e_region; }\n             invariant {\n-                ret if e_region == a_region { some(e_region) } else { none };\n+              ret if e_region == a_region {\n+                  nxt(e_region)\n+              } else {\n+                  err(terr_regions_differ)\n+              };\n             }\n         }\n \n         if sub == ty::re_inferred || super == ty::re_inferred {\n-            ret if sub == super { some(super) } else { none };\n+            ret if sub == super {\n+                nxt(super)\n+            } else {\n+                err(terr_regions_differ)\n+            };\n         }\n \n         // Outer regions are subtypes of inner regions. (This is somewhat\n         // surprising!)\n         let superscope = region::region_to_scope(cx.tcx.region_map, super);\n         let subscope = region::region_to_scope(cx.tcx.region_map, sub);\n         if region::scope_contains(cx.tcx.region_map, subscope, superscope) {\n-            ret some(super);\n+            ret nxt(super);\n         }\n-        ret none;\n+        ret err(terr_regions_differ);\n     }\n \n-    fn unify_step(cx: @uctxt, expected: t, actual: t,\n-                  variance: variance) -> result {\n+    fn unify_field<T:copy>(\n+        cx: @uctxt, e_field: field, a_field: field,\n+        variance: variance,\n+        nxt: fn(field) -> ures<T>) -> ures<T> {\n+\n+        if e_field.ident != a_field.ident {\n+            ret err(terr_record_fields(e_field.ident,\n+                                       a_field.ident));\n+        }\n+\n+        unify_mt(cx, e_field.mt, a_field.mt, variance,\n+                 terr_record_mutability) {|mt|\n+            nxt({ident: e_field.ident, mt: mt})\n+        }\n+    }\n+\n+    fn unify_step<T:copy>(\n+        cx: @uctxt, expected: t, actual: t,\n+        variance: variance, nxt: fn(t) -> ures<T>) -> ures<T> {\n+\n         // Fast path.\n-        if expected == actual { ret ures_ok(expected); }\n+        if expected == actual { ret nxt(expected); }\n \n         alt (get(expected).struct, get(actual).struct) {\n           (ty_var(e_id), ty_var(a_id)) {\n-            alt union(cx, e_id as uint, a_id as uint, variance) {\n-              unres_ok { ures_ok(actual) }\n-              unres_err(err) { ures_err(err) }\n+            union(cx, e_id as uint, a_id as uint, variance) {||\n+                nxt(actual)\n             }\n           }\n           (_, ty_var(a_id)) {\n             let v = variance_transform(variance, contravariant);\n-            record_var_binding(cx, a_id, expected, v)\n+            record_var_binding(cx, a_id, expected, v, nxt)\n           }\n           (ty_var(e_id), _) {\n             let v = variance_transform(variance, covariant);\n-            record_var_binding(cx, e_id, actual, v)\n+            record_var_binding(cx, e_id, actual, v, nxt)\n           }\n-          (_, ty_bot) { ures_ok(expected) }\n-          (ty_bot, _) { ures_ok(actual) }\n+          (_, ty_bot) { nxt(expected) }\n+          (ty_bot, _) { nxt(actual) }\n           (ty_nil, _) | (ty_bool, _) | (ty_int(_), _) | (ty_uint(_), _) |\n           (ty_float(_), _) | (ty_str, _) | (ty_send_type, _) {\n-            struct_cmp(cx, expected, actual)\n+            struct_cmp(cx, expected, actual, nxt)\n           }\n           (ty_param(e_n, _), ty_param(a_n, _)) if e_n == a_n {\n-            ures_ok(expected)\n+            nxt(expected)\n           }\n           (ty_enum(e_id, e_tps), ty_enum(a_id, a_tps)) if e_id == a_id {\n-            unify_tps(cx, e_tps, a_tps, variance, {|tps|\n-                mk_enum(cx.tcx, e_id, tps)\n-            })\n+            unify_tps(cx, e_tps, a_tps, variance) {|tps|\n+                nxt(mk_enum(cx.tcx, e_id, tps))\n+            }\n           }\n           (ty_iface(e_id, e_tps), ty_iface(a_id, a_tps)) if e_id == a_id {\n-            unify_tps(cx, e_tps, a_tps, variance, {|tps|\n-                mk_iface(cx.tcx, e_id, tps)\n-            })\n+            unify_tps(cx, e_tps, a_tps, variance) {|tps|\n+                nxt(mk_iface(cx.tcx, e_id, tps))\n+            }\n           }\n           (ty_class(e_id, e_tps), ty_class(a_id, a_tps)) if e_id == a_id {\n-            unify_tps(cx, e_tps, a_tps, variance, {|tps|\n-                mk_class(cx.tcx, e_id, tps)\n-            })\n+            unify_tps(cx, e_tps, a_tps, variance) {|tps|\n+                nxt(mk_class(cx.tcx, e_id, tps))\n+            }\n           }\n           (ty_box(e_mt), ty_box(a_mt)) {\n-            unify_mt(cx, e_mt, a_mt, variance, terr_box_mutability, mk_box)\n+            unify_mt(cx, e_mt, a_mt, variance, terr_box_mutability,\n+                     {|mt| nxt(mk_box(cx.tcx, mt))})\n           }\n           (ty_uniq(e_mt), ty_uniq(a_mt)) {\n-            unify_mt(cx, e_mt, a_mt, variance, terr_box_mutability, mk_uniq)\n+            unify_mt(cx, e_mt, a_mt, variance, terr_box_mutability,\n+                     {|mt| nxt(mk_uniq(cx.tcx, mt))})\n           }\n           (ty_vec(e_mt), ty_vec(a_mt)) {\n-            unify_mt(cx, e_mt, a_mt, variance, terr_vec_mutability, mk_vec)\n+            unify_mt(cx, e_mt, a_mt, variance, terr_vec_mutability,\n+                     {|mt| nxt(mk_vec(cx.tcx, mt))})\n           }\n           (ty_ptr(e_mt), ty_ptr(a_mt)) {\n-            unify_mt(cx, e_mt, a_mt, variance, terr_ptr_mutability, mk_ptr)\n+            unify_mt(cx, e_mt, a_mt, variance, terr_ptr_mutability,\n+                     {|mt| nxt(mk_ptr(cx.tcx, mt))})\n           }\n           (ty_rptr(e_region, e_mt), ty_rptr(a_region, a_mt)) {\n-            alt unify_regions(cx, e_region, a_region, variance) {\n-                none { ures_err(terr_regions_differ) }\n-                some(r_region) {\n-                    unify_mt(cx, e_mt, a_mt, variance, terr_ref_mutability,\n-                             bind mk_rptr(_, r_region, _))\n-                }\n+            unify_regions(cx, e_region, a_region, variance) {|r|\n+                unify_mt(cx, e_mt, a_mt, variance, terr_ref_mutability,\n+                         {|mt| nxt(mk_rptr(cx.tcx, r, mt))})\n             }\n           }\n           (ty_res(e_id, e_inner, e_tps), ty_res(a_id, a_inner, a_tps))\n           if e_id == a_id {\n-            alt unify_step(cx, e_inner, a_inner, variance) {\n-              ures_ok(res_inner) {\n-                unify_tps(cx, e_tps, a_tps, variance, {|tps|\n-                    mk_res(cx.tcx, a_id, res_inner, tps)\n-                })\n+              unify_step(cx, e_inner, a_inner, variance) {|t|\n+                  unify_tps(cx, e_tps, a_tps, variance) {|tps|\n+                      nxt(mk_res(cx.tcx, a_id, t, tps))\n+                  }\n               }\n-              err { err }\n-            }\n           }\n           (ty_rec(e_fields), ty_rec(a_fields)) {\n-            let e_len = e_fields.len(), a_len = a_fields.len();\n-            if e_len != a_len {\n-                ret ures_err(terr_record_size(e_len, a_len));\n-            }\n-            let result_fields = [], i = 0u;\n-            while i < a_len {\n-                let e_field = e_fields[i], a_field = a_fields[i];\n-                if e_field.ident != a_field.ident {\n-                    ret ures_err(terr_record_fields(e_field.ident,\n-                                                    a_field.ident));\n-                }\n-                alt unify_mt(cx, e_field.mt, a_field.mt, variance,\n-                             terr_record_mutability, {|cx, mt|\n-                    result_fields += [{mt: mt with e_field}];\n-                    mk_nil(cx)\n-                }) {\n-                  ures_ok(_) {}\n-                  err { ret err; }\n-                }\n-                i += 1u;\n-            }\n-            ures_ok(mk_rec(cx.tcx, result_fields))\n+              if check vec::same_length(e_fields, a_fields) {\n+                  map2(e_fields, a_fields,\n+                       {|e,a| unify_field(cx, e, a, variance, {|v| ok(v)})},\n+                       {|fields| nxt(mk_rec(cx.tcx, fields))})\n+              } else {\n+                  ret err(terr_record_size(e_fields.len(),\n+                                           a_fields.len()));\n+              }\n           }\n           (ty_tup(e_elems), ty_tup(a_elems)) {\n-            let e_len = e_elems.len(), a_len = a_elems.len();\n-            if e_len != a_len { ret ures_err(terr_tuple_size(e_len, a_len)); }\n-            let result_elems = [], i = 0u;\n-            while i < a_len {\n-                alt unify_step(cx, e_elems[i], a_elems[i], variance) {\n-                  ures_ok(rty) { result_elems += [rty]; }\n-                  err { ret err; }\n+            if check vec::same_length(e_elems, a_elems) {\n+                unify_tys(cx, e_elems, a_elems, variance) {|elems|\n+                    nxt(mk_tup(cx.tcx, elems))\n                 }\n-                i += 1u;\n+            } else {\n+                err(terr_tuple_size(e_elems.len(), a_elems.len()))\n             }\n-            ures_ok(mk_tup(cx.tcx, result_elems))\n           }\n           (ty_fn(e_fty), ty_fn(a_fty)) {\n-            unify_fn(cx, e_fty, a_fty, variance)\n+            unify_fn(cx, e_fty, a_fty, variance, nxt)\n           }\n           (ty_constr(e_t, e_constrs), ty_constr(a_t, a_constrs)) {\n             // unify the base types...\n-            alt unify_step(cx, e_t, a_t, variance) {\n-              ures_ok(rty) {\n+            unify_step(cx, e_t, a_t, variance) {|rty|\n                 // FIXME: probably too restrictive --\n                 // requires the constraints to be syntactically equal\n-                unify_constrs(expected, e_constrs, a_constrs)\n-              }\n-              err { err }\n+                unify_constrs(e_constrs, a_constrs) {|constrs|\n+                    nxt(mk_constr(cx.tcx, rty, constrs))\n+                }\n             }\n           }\n           (ty_constr(e_t, _), _) {\n             // If the actual type is *not* a constrained type,\n             // then we go ahead and just ignore the constraints on\n             // the expected type. typestate handles the rest.\n-            unify_step(cx, e_t, actual, variance)\n+            unify_step(cx, e_t, actual, variance, nxt)\n           }\n-          _ { ures_err(terr_mismatch) }\n+          _ { err(terr_mismatch) }\n         }\n     }\n     fn unify(expected: t, actual: t, st: unify_style,\n-             tcx: ctxt) -> result {\n+             tcx: ctxt) -> ures<t> {\n         let cx = @{st: st, tcx: tcx};\n-        ret unify_step(cx, expected, actual, covariant);\n+        ret unify_step(cx, expected, actual, covariant, {|v| ok(v)});\n     }\n     fn dump_var_bindings(tcx: ctxt, vb: @var_bindings) {\n         let i = 0u;\n@@ -2104,7 +2128,7 @@ mod unify {\n     //    iff the span is present (so that if we already know we're going\n     //    to error anyway, we don't complain)\n     fn fixup_vars(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n-                  typ: t) -> fixup_result {\n+                  typ: t) -> fres<t> {\n         fn subst_vars(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n                       unresolved: @mutable option<int>,\n                       vars_seen: std::list::list<int>, vid: int) -> t {\n@@ -2142,25 +2166,25 @@ mod unify {\n             tcx, sp, vb, unresolved, std::list::nil, _)), typ);\n         let ur = *unresolved;\n         alt ur {\n-          none { ret fix_ok(rty); }\n-          some(var_id) { ret fix_err(var_id); }\n+          none { ret ok(rty); }\n+          some(var_id) { ret err(var_id); }\n         }\n     }\n     fn resolve_type_var(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n-                        vid: int) -> fixup_result {\n-        if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n+                        vid: int) -> fres<t> {\n+        if vid as uint >= ufind::set_count(vb.sets) { ret err(vid); }\n         let root_id = ufind::find(vb.sets, vid as uint);\n         alt smallintmap::find::<t>(vb.types, root_id) {\n-          none { ret fix_err(vid); }\n+          none { ret err(vid); }\n           some(rt) { ret fixup_vars(tcx, sp, vb, rt); }\n         }\n     }\n }\n \n fn same_type(cx: ctxt, a: t, b: t) -> bool {\n     alt unify::unify(a, b, unify::precise, cx) {\n-      unify::ures_ok(_) { true }\n-      _ { false }\n+      result::ok(_) { true }\n+      result::err(_) { false }\n     }\n }\n \n@@ -2181,6 +2205,11 @@ fn type_err_to_str(err: type_err) -> str {\n       terr_vec_mutability { ret \"vectors differ in mutability\"; }\n       terr_ptr_mutability { ret \"pointers differ in mutability\"; }\n       terr_ref_mutability { ret \"references differ in mutability\"; }\n+      terr_ty_param_size(e_sz, a_sz) {\n+        ret \"expected a type with \" + uint::to_str(e_sz, 10u) +\n+                \" type params but found one with \" + uint::to_str(a_sz, 10u) +\n+                \" type params\";\n+      }\n       terr_tuple_size(e_sz, a_sz) {\n         ret \"expected a tuple with \" + uint::to_str(e_sz, 10u) +\n                 \" elements but found one with \" + uint::to_str(a_sz, 10u) +"}, {"sha": "b5e6bd77695810308d5b19fc5858685056837e62", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7c70d35a10d7157b4a31ac1db18afe96268735f6/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c70d35a10d7157b4a31ac1db18afe96268735f6/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=7c70d35a10d7157b4a31ac1db18afe96268735f6", "patch": "@@ -12,7 +12,6 @@ import middle::ty::{node_id_to_type, arg, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_class_items};\n import util::ppaux::ty_to_str;\n-import middle::ty::unify::{ures_ok, ures_err, fix_ok, fix_err};\n import std::smallintmap;\n import std::map::{hashmap, new_int_hash};\n import syntax::print::pprust::*;\n@@ -200,8 +199,8 @@ fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n // Type tests\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     alt ty::unify::resolve_type_structure(fcx.var_bindings, tp) {\n-      fix_ok(typ_s) { ret typ_s; }\n-      fix_err(_) {\n+      result::ok(typ_s) { ret typ_s; }\n+      result::err(_) {\n         fcx.ccx.tcx.sess.span_fatal\n             (sp, \"the type of this value must be known in this context\");\n       }\n@@ -218,12 +217,11 @@ fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n // is not known yet.\n fn structure_of_maybe(fcx: @fn_ctxt, _sp: span, typ: ty::t) ->\n    option<ty::sty> {\n-    let r =\n-        ty::unify::resolve_type_structure(fcx.var_bindings, typ);\n-    ret alt r {\n-          fix_ok(typ_s) { some(ty::get(typ_s).struct) }\n-          fix_err(_) { none }\n-        }\n+    let r = ty::unify::resolve_type_structure(fcx.var_bindings, typ);\n+    alt r {\n+      result::ok(typ_s) { some(ty::get(typ_s).struct) }\n+      result::err(_) { none }\n+    }\n }\n \n fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n@@ -759,13 +757,13 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n                                              self_full(self_ty, impl_tps));\n         }\n         alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n-          ty::unify::ures_err(err) {\n+          result::err(err) {\n             tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                               \"` has an incompatible type: \" +\n                               ty::type_err_to_str(err));\n             impl_fty\n           }\n-          ty::unify::ures_ok(tp) { tp }\n+          result::ok(tp) { tp }\n         }\n     }\n }\n@@ -1046,7 +1044,7 @@ mod collect {\n // Type unification\n mod unify {\n     fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n-       ty::unify::result {\n+        result<ty::t, ty::type_err> {\n         ret ty::unify::unify(expected, actual,\n                              ty::unify::in_bindings(fcx.var_bindings),\n                              fcx.ccx.tcx);\n@@ -1089,8 +1087,8 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n \n fn resolve_type_vars_if_possible(fcx: @fn_ctxt, typ: ty::t) -> ty::t {\n     alt ty::unify::fixup_vars(fcx.ccx.tcx, none, fcx.var_bindings, typ) {\n-      fix_ok(new_type) { ret new_type; }\n-      fix_err(_) { ret typ; }\n+      result::ok(new_type) { ret new_type; }\n+      result::err(_) { ret typ; }\n     }\n }\n \n@@ -1140,8 +1138,8 @@ mod demand {\n \n \n         alt unify::unify(fcx, expected, actual) {\n-          ures_ok(t) { ret mk_result(fcx, t, ty_param_subst_var_ids); }\n-          ures_err(err) {\n+          result::ok(t) { ret mk_result(fcx, t, ty_param_subst_var_ids); }\n+          result::err(err) {\n             let e_err = resolve_type_vars_if_possible(fcx, expected);\n             let a_err = resolve_type_vars_if_possible(fcx, actual);\n             fcx.ccx.tcx.sess.span_err(sp,\n@@ -1161,8 +1159,8 @@ mod demand {\n // Returns true if the two types unify and false if they don't.\n fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n     alt unify::unify(fcx, expected, actual) {\n-      ures_ok(_) { ret true; }\n-      ures_err(_) { ret false; }\n+      result::ok(_) { ret true; }\n+      result::err(_) { ret false; }\n     }\n }\n \n@@ -1204,8 +1202,8 @@ mod writeback {\n         if !ty::type_has_vars(typ) { ret some(typ); }\n         alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp), fcx.var_bindings,\n                                   typ) {\n-          fix_ok(new_type) { ret some(new_type); }\n-          fix_err(vid) {\n+          result::ok(new_type) { ret some(new_type); }\n+          result::err(vid) {\n             if !fcx.ccx.tcx.sess.has_errors() {\n                 fcx.ccx.tcx.sess.span_err(sp, \"cannot determine a type \\\n                                                for this expression\");\n@@ -1296,8 +1294,8 @@ mod writeback {\n             ty::unify::resolve_type_var(wbcx.fcx.ccx.tcx, some(l.span),\n                                         wbcx.fcx.var_bindings, var_id);\n         alt fix_rslt {\n-          fix_ok(lty) { write_ty(wbcx.fcx.ccx.tcx, l.node.id, lty); }\n-          fix_err(_) {\n+          result::ok(lty) { write_ty(wbcx.fcx.ccx.tcx, l.node.id, lty); }\n+          result::err(_) {\n             wbcx.fcx.ccx.tcx.sess.span_err(l.span,\n                                            \"cannot determine a type \\\n                                                 for this local variable\");\n@@ -1849,7 +1847,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                     bind_params(fcx, self_ty, n_tps)\n                 } else { {vars: [], ty: self_ty} };\n                 alt unify::unify(fcx, ty, self_ty) {\n-                  ures_ok(_) {\n+                  result::ok(_) {\n                     if option::is_some(result) {\n                         // FIXME[impl] score specificity to resolve ambiguity?\n                         if !complained {\n@@ -1867,7 +1865,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                         });\n                     }\n                   }\n-                  _ {}\n+                  result::err(_) {}\n                 }\n               }\n               _ {}\n@@ -3311,7 +3309,7 @@ mod dict {\n                         } else { {vars: [], ty: self_ty} };\n                         let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n                         alt unify::unify(fcx, ty, self_ty) {\n-                          ures_ok(_) {\n+                          result::ok(_) {\n                             if option::is_some(found) {\n                                 tcx.sess.span_err(\n                                     sp, \"multiple applicable implementations \\\n@@ -3327,7 +3325,7 @@ mod dict {\n                                                          subres));\n                             }\n                           }\n-                          _ {}\n+                          result::err(_) {}\n                         }\n                     }\n                 }\n@@ -3348,8 +3346,8 @@ mod dict {\n     fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n         alt ty::unify::fixup_vars(tcx, some(sp), fcx.var_bindings, ty) {\n-          fix_ok(new_type) { new_type }\n-          fix_err(vid) {\n+          result::ok(new_type) { new_type }\n+          result::err(vid) {\n             tcx.sess.span_fatal(sp, \"could not determine a type for a \\\n                                      bounded type parameter\");\n           }"}]}