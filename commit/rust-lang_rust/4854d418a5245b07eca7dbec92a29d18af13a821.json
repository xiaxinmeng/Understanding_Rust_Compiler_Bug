{"sha": "4854d418a5245b07eca7dbec92a29d18af13a821", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NTRkNDE4YTUyNDViMDdlY2E3ZGJlYzkyYTI5ZDE4YWYxM2E4MjE=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-06T22:36:23Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-13T21:38:27Z"}, "message": "do direct splice syscall and probe availability to get android builds to work\n\nAndroid builds use feature level 14, the libc wrapper for splice is gated\non feature level 21+ so we have to invoke the syscall directly.\nAdditionally the emulator doesn't seem to support it so we also have to\nadd ENOSYS checks.", "tree": {"sha": "0e33ad776b624690bd080cb1ac04a72717ff7d99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e33ad776b624690bd080cb1ac04a72717ff7d99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4854d418a5245b07eca7dbec92a29d18af13a821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4854d418a5245b07eca7dbec92a29d18af13a821", "html_url": "https://github.com/rust-lang/rust/commit/4854d418a5245b07eca7dbec92a29d18af13a821", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4854d418a5245b07eca7dbec92a29d18af13a821/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dfc377aa12293ace29f9a055f0aeb634d107ed9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dfc377aa12293ace29f9a055f0aeb634d107ed9", "html_url": "https://github.com/rust-lang/rust/commit/3dfc377aa12293ace29f9a055f0aeb634d107ed9"}], "stats": {"total": 76, "additions": 72, "deletions": 4}, "files": [{"sha": "99533dd3c07d6c9381024eebac46ab4f68c37d5a", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4854d418a5245b07eca7dbec92a29d18af13a821/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4854d418a5245b07eca7dbec92a29d18af13a821/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=4854d418a5245b07eca7dbec92a29d18af13a821", "patch": "@@ -58,6 +58,7 @@ use crate::os::unix::fs::FileTypeExt;\n use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n use crate::ptr;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::cvt;\n \n #[cfg(test)]\n@@ -440,7 +441,6 @@ pub(super) enum CopyResult {\n /// If the initial file offset was 0 then `Fallback` will only contain `0`.\n pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n     use crate::cmp;\n-    use crate::sync::atomic::{AtomicBool, Ordering};\n \n     // Kernel prior to 4.5 don't have copy_file_range\n     // We store the availability in a global to avoid unnecessary syscalls\n@@ -534,6 +534,30 @@ enum SpliceMode {\n /// performs splice or sendfile between file descriptors\n /// Does _not_ fall back to a generic copy loop.\n fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) -> CopyResult {\n+    static HAS_SENDFILE: AtomicBool = AtomicBool::new(true);\n+    static HAS_SPLICE: AtomicBool = AtomicBool::new(true);\n+\n+    syscall! {\n+        fn splice(\n+            srcfd: libc::c_int,\n+            src_offset: *const i64,\n+            dstfd: libc::c_int,\n+            dst_offset: *const i64,\n+            len: libc::size_t,\n+            flags: libc::c_int\n+        ) -> libc::ssize_t\n+    }\n+\n+    match mode {\n+        SpliceMode::Sendfile if !HAS_SENDFILE.load(Ordering::Relaxed) => {\n+            return CopyResult::Fallback(0);\n+        }\n+        SpliceMode::Splice if !HAS_SPLICE.load(Ordering::Relaxed) => {\n+            return CopyResult::Fallback(0);\n+        }\n+        _ => (),\n+    }\n+\n     let mut written = 0u64;\n     while written < len {\n         let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n@@ -543,7 +567,7 @@ fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) ->\n                 cvt(unsafe { libc::sendfile(writer, reader, ptr::null_mut(), chunk_size) })\n             }\n             SpliceMode::Splice => cvt(unsafe {\n-                libc::splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n+                splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n             }),\n         };\n \n@@ -552,8 +576,18 @@ fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) ->\n             Ok(ret) => written += ret as u64,\n             Err(err) => {\n                 return match err.raw_os_error() {\n-                    Some(os_err) if os_err == libc::EINVAL => {\n-                        // splice/sendfile do not support this particular file descritor (EINVAL)\n+                    Some(libc::ENOSYS | libc::EPERM) => {\n+                        // syscall not supported (ENOSYS)\n+                        // syscall is disallowed, e.g. by seccomp (EPERM)\n+                        match mode {\n+                            SpliceMode::Sendfile => HAS_SENDFILE.store(false, Ordering::Relaxed),\n+                            SpliceMode::Splice => HAS_SPLICE.store(false, Ordering::Relaxed),\n+                        }\n+                        assert_eq!(written, 0);\n+                        CopyResult::Fallback(0)\n+                    }\n+                    Some(libc::EINVAL) => {\n+                        // splice/sendfile do not support this particular file descriptor (EINVAL)\n                         assert_eq!(written, 0);\n                         CopyResult::Fallback(0)\n                     }"}, {"sha": "21b121c26fffc07ae45c42b1c5e24fd099210e7c", "filename": "library/std/src/sys/unix/kernel_copy/tests.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4854d418a5245b07eca7dbec92a29d18af13a821/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4854d418a5245b07eca7dbec92a29d18af13a821/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs?ref=4854d418a5245b07eca7dbec92a29d18af13a821", "patch": "@@ -121,6 +121,7 @@ fn bench_file_to_socket_copy(b: &mut test::Bencher) {\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n #[bench]\n fn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n+    use super::CopyResult;\n     use crate::io::ErrorKind;\n     use crate::process::{ChildStdin, ChildStdout};\n     use crate::sys_common::FromInner;\n@@ -135,6 +136,21 @@ fn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n \n     let local_end = crate::sync::Arc::new(acceptor.accept().unwrap().0);\n \n+    // the data flow in this benchmark:\n+    //\n+    //                      socket(tx)  local_source\n+    // remote_end (write)  +-------->   (splice to)\n+    //                                  write_end\n+    //                                     +\n+    //                                     |\n+    //                                     | pipe\n+    //                                     v\n+    //                                  read_end\n+    // remote_end (read)   <---------+  (splice to) *\n+    //                      socket(rx)  local_end\n+    //\n+    // * benchmark loop using io::copy\n+\n     crate::thread::spawn(move || {\n         let mut sink_buf = vec![0u8; 1024 * 1024];\n         remote_end.set_nonblocking(true).unwrap();\n@@ -156,6 +172,24 @@ fn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n         }\n     });\n \n+    // check that splice works, otherwise the benchmark would hang\n+    let probe = super::sendfile_splice(\n+        super::SpliceMode::Splice,\n+        local_end.as_raw_fd(),\n+        write_end.as_raw_fd(),\n+        1,\n+    );\n+\n+    match probe {\n+        CopyResult::Ended(Ok(1)) => {\n+            // splice works\n+        }\n+        _ => {\n+            eprintln!(\"splice failed, skipping benchmark\");\n+            return;\n+        }\n+    }\n+\n     let local_source = local_end.clone();\n     crate::thread::spawn(move || {\n         loop {"}]}