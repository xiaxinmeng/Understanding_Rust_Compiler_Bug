{"sha": "c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxOTBmNjYwNjBlZTNhZTRhYTg0YTFjMjkxYjNhOTVjZTc3ZTZkYzg=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-09-19T08:45:28Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-09-21T01:48:31Z"}, "message": "Moved GatherLocalsVisitor to its own file", "tree": {"sha": "e74b1bf8786b5ebde864f06a2636f5a86eda247a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e74b1bf8786b5ebde864f06a2636f5a86eda247a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8", "html_url": "https://github.com/rust-lang/rust/commit/c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e770645aade4b7e34898a9f102bd5e4d5589f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e770645aade4b7e34898a9f102bd5e4d5589f32", "html_url": "https://github.com/rust-lang/rust/commit/3e770645aade4b7e34898a9f102bd5e4d5589f32"}], "stats": {"total": 238, "additions": 126, "deletions": 112}, "files": [{"sha": "1d505cfa698045099cffe945fbc0f7199fdfe95a", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8", "patch": "@@ -0,0 +1,120 @@\n+use crate::check::{FnCtxt, LocalTy, UserType};\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::PatKind;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_middle::ty::Ty;\n+use rustc_span::Span;\n+use rustc_trait_selection::traits;\n+\n+pub(super) struct GatherLocalsVisitor<'a, 'tcx> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    parent_id: hir::HirId,\n+}\n+\n+impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n+    pub(super) fn new(fcx: &'a FnCtxt<'a, 'tcx>, parent_id: hir::HirId) -> Self {\n+        Self { fcx, parent_id }\n+    }\n+\n+    fn assign(&mut self, span: Span, nid: hir::HirId, ty_opt: Option<LocalTy<'tcx>>) -> Ty<'tcx> {\n+        match ty_opt {\n+            None => {\n+                // Infer the variable's type.\n+                let var_ty = self.fcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span,\n+                });\n+                self.fcx\n+                    .locals\n+                    .borrow_mut()\n+                    .insert(nid, LocalTy { decl_ty: var_ty, revealed_ty: var_ty });\n+                var_ty\n+            }\n+            Some(typ) => {\n+                // Take type that the user specified.\n+                self.fcx.locals.borrow_mut().insert(nid, typ);\n+                typ.revealed_ty\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n+    type Map = intravisit::ErasedMap<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    // Add explicitly-declared locals.\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n+        let local_ty = match local.ty {\n+            Some(ref ty) => {\n+                let o_ty = self.fcx.to_ty(&ty);\n+\n+                let revealed_ty = if self.fcx.tcx.features().impl_trait_in_bindings {\n+                    self.fcx.instantiate_opaque_types_from_value(self.parent_id, &o_ty, ty.span)\n+                } else {\n+                    o_ty\n+                };\n+\n+                let c_ty = self\n+                    .fcx\n+                    .inh\n+                    .infcx\n+                    .canonicalize_user_type_annotation(&UserType::Ty(revealed_ty));\n+                debug!(\n+                    \"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n+                    ty.hir_id, o_ty, revealed_ty, c_ty\n+                );\n+                self.fcx\n+                    .typeck_results\n+                    .borrow_mut()\n+                    .user_provided_types_mut()\n+                    .insert(ty.hir_id, c_ty);\n+\n+                Some(LocalTy { decl_ty: o_ty, revealed_ty })\n+            }\n+            None => None,\n+        };\n+        self.assign(local.span, local.hir_id, local_ty);\n+\n+        debug!(\n+            \"local variable {:?} is assigned type {}\",\n+            local.pat,\n+            self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&local.hir_id).unwrap().decl_ty)\n+        );\n+        intravisit::walk_local(self, local);\n+    }\n+\n+    // Add pattern bindings.\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n+        if let PatKind::Binding(_, _, ident, _) = p.kind {\n+            let var_ty = self.assign(p.span, p.hir_id, None);\n+\n+            if !self.fcx.tcx.features().unsized_locals {\n+                self.fcx.require_type_is_sized(var_ty, p.span, traits::VariableType(p.hir_id));\n+            }\n+\n+            debug!(\n+                \"pattern binding {} is assigned to {} with type {:?}\",\n+                ident,\n+                self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&p.hir_id).unwrap().decl_ty),\n+                var_ty\n+            );\n+        }\n+        intravisit::walk_pat(self, p);\n+    }\n+\n+    // Don't descend into the bodies of nested closures.\n+    fn visit_fn(\n+        &mut self,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx hir::FnDecl<'tcx>,\n+        _: hir::BodyId,\n+        _: Span,\n+        _: hir::HirId,\n+    ) {\n+    }\n+}"}, {"sha": "2b8940f1813d1d334a667d74998b2e00d2e6b43e", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 6, "deletions": 112, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=c190f66060ee3ae4aa84a1c291b3a95ce77e6dc8", "patch": "@@ -72,6 +72,7 @@ mod compare_method;\n pub mod demand;\n pub mod dropck;\n mod expr;\n+mod gather_locals;\n mod generator_interior;\n pub mod intrinsic;\n pub mod method;\n@@ -87,6 +88,7 @@ pub mod writeback;\n use crate::astconv::{\n     AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, PathSeg,\n };\n+use crate::check::gather_locals::GatherLocalsVisitor;\n use crate::check::util::MaybeInProgressTables;\n use rustc_ast as ast;\n use rustc_ast::util::parser::ExprPrecedence;\n@@ -98,9 +100,9 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder,\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{ExprKind, GenericArg, HirIdMap, ItemKind, Node, PatKind, QPath};\n+use rustc_hir::{ExprKind, GenericArg, HirIdMap, ItemKind, Node, QPath};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_infer::infer;\n@@ -997,7 +999,7 @@ fn typeck_with_fallback<'tcx>(\n             };\n \n             // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor { fcx: &fcx, parent_id: id }.visit_body(body);\n+            GatherLocalsVisitor::new(&fcx, id).visit_body(body);\n \n             fcx.check_expr_coercable_to_type(&body.value, revealed_ty, None);\n \n@@ -1097,114 +1099,6 @@ fn check_abi(tcx: TyCtxt<'_>, span: Span, abi: Abi) {\n     }\n }\n \n-struct GatherLocalsVisitor<'a, 'tcx> {\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n-    parent_id: hir::HirId,\n-}\n-\n-impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n-    fn assign(&mut self, span: Span, nid: hir::HirId, ty_opt: Option<LocalTy<'tcx>>) -> Ty<'tcx> {\n-        match ty_opt {\n-            None => {\n-                // Infer the variable's type.\n-                let var_ty = self.fcx.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::TypeInference,\n-                    span,\n-                });\n-                self.fcx\n-                    .locals\n-                    .borrow_mut()\n-                    .insert(nid, LocalTy { decl_ty: var_ty, revealed_ty: var_ty });\n-                var_ty\n-            }\n-            Some(typ) => {\n-                // Take type that the user specified.\n-                self.fcx.locals.borrow_mut().insert(nid, typ);\n-                typ.revealed_ty\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n-    type Map = intravisit::ErasedMap<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-\n-    // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n-        let local_ty = match local.ty {\n-            Some(ref ty) => {\n-                let o_ty = self.fcx.to_ty(&ty);\n-\n-                let revealed_ty = if self.fcx.tcx.features().impl_trait_in_bindings {\n-                    self.fcx.instantiate_opaque_types_from_value(self.parent_id, &o_ty, ty.span)\n-                } else {\n-                    o_ty\n-                };\n-\n-                let c_ty = self\n-                    .fcx\n-                    .inh\n-                    .infcx\n-                    .canonicalize_user_type_annotation(&UserType::Ty(revealed_ty));\n-                debug!(\n-                    \"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n-                    ty.hir_id, o_ty, revealed_ty, c_ty\n-                );\n-                self.fcx\n-                    .typeck_results\n-                    .borrow_mut()\n-                    .user_provided_types_mut()\n-                    .insert(ty.hir_id, c_ty);\n-\n-                Some(LocalTy { decl_ty: o_ty, revealed_ty })\n-            }\n-            None => None,\n-        };\n-        self.assign(local.span, local.hir_id, local_ty);\n-\n-        debug!(\n-            \"local variable {:?} is assigned type {}\",\n-            local.pat,\n-            self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&local.hir_id).unwrap().decl_ty)\n-        );\n-        intravisit::walk_local(self, local);\n-    }\n-\n-    // Add pattern bindings.\n-    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n-        if let PatKind::Binding(_, _, ident, _) = p.kind {\n-            let var_ty = self.assign(p.span, p.hir_id, None);\n-\n-            if !self.fcx.tcx.features().unsized_locals {\n-                self.fcx.require_type_is_sized(var_ty, p.span, traits::VariableType(p.hir_id));\n-            }\n-\n-            debug!(\n-                \"pattern binding {} is assigned to {} with type {:?}\",\n-                ident,\n-                self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&p.hir_id).unwrap().decl_ty),\n-                var_ty\n-            );\n-        }\n-        intravisit::walk_pat(self, p);\n-    }\n-\n-    // Don't descend into the bodies of nested closures.\n-    fn visit_fn(\n-        &mut self,\n-        _: intravisit::FnKind<'tcx>,\n-        _: &'tcx hir::FnDecl<'tcx>,\n-        _: hir::BodyId,\n-        _: Span,\n-        _: hir::HirId,\n-    ) {\n-    }\n-}\n-\n /// When `check_fn` is invoked on a generator (i.e., a body that\n /// includes yield), it returns back some information about the yield\n /// points.\n@@ -1285,7 +1179,7 @@ fn check_fn<'a, 'tcx>(\n \n     let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id()).expect_local();\n     let outer_hir_id = hir.local_def_id_to_hir_id(outer_def_id);\n-    GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n+    GatherLocalsVisitor::new(&fcx, outer_hir_id).visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside)."}]}