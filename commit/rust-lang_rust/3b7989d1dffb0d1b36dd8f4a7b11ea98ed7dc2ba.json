{"sha": "3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNzk4OWQxZGZmYjBkMWIzNmRkOGY0YTdiMTFlYTk4ZWQ3ZGMyYmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-07T18:50:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-07T19:05:16Z"}, "message": "avoid computing liveness when a variable doesn't need it\n\nIn particular, we skip computing liveness for a variable X if all the\nregions in its type are known to outlive free regions.", "tree": {"sha": "b71d00a961029b2f55f5c13179ec1fe45d5f1772", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b71d00a961029b2f55f5c13179ec1fe45d5f1772"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "html_url": "https://github.com/rust-lang/rust/commit/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "887296e8c32165de83deb5156f0255c1f286ee6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/887296e8c32165de83deb5156f0255c1f286ee6a", "html_url": "https://github.com/rust-lang/rust/commit/887296e8c32165de83deb5156f0255c1f286ee6a"}], "stats": {"total": 205, "additions": 146, "deletions": 59}, "files": [{"sha": "1a1094b570bd107ca5de46a493a8874f75eb554a", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "patch": "@@ -24,6 +24,8 @@ crate struct ConstraintGraph<D: ConstraintGraphDirecton> {\n \n crate type NormalConstraintGraph = ConstraintGraph<Normal>;\n \n+crate type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n+\n /// Marker trait that controls whether a `R1: R2` constraint\n /// represents an edge `R1 -> R2` or `R2 -> R1`.\n crate trait ConstraintGraphDirecton: Copy + 'static {"}, {"sha": "4cb92262ff08590a9d2c6f8ab00f4c25419eb13d", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "patch": "@@ -46,6 +46,12 @@ impl ConstraintSet {\n         graph::ConstraintGraph::new(graph::Normal, self, num_region_vars)\n     }\n \n+    /// Like `graph`, but constraints a reverse graph where `R1: R2`\n+    /// represents an edge `R2 -> R1`.\n+    crate fn reverse_graph(&self, num_region_vars: usize) -> graph::ReverseConstraintGraph {\n+        graph::ConstraintGraph::new(graph::Reverse, self, num_region_vars)\n+    }\n+\n     /// Compute cycles (SCCs) in the graph of regions. In particular,\n     /// find all regions R1, R2 such that R1: R2 and R2: R1 and group\n     /// them into an SCC, and find the relationships between SCCs."}, {"sha": "20bf53f4d953b9ff05202a5d17a9809116ca1931", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/liveness_map.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs?ref=3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "patch": "@@ -16,21 +16,25 @@\n //! liveness code so that it only operates over variables with regions in their\n //! types, instead of all variables.\n \n+use borrow_check::nll::ToRegionVid;\n use rustc::mir::{Local, Mir};\n-use rustc::ty::TypeFoldable;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::ty::{RegionVid, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use util::liveness::LiveVariableMap;\n \n-use rustc_data_structures::indexed_vec::Idx;\n-\n-/// Map between Local and LocalWithRegion indices: this map is supplied to the\n-/// liveness code so that it will only analyze those variables whose types\n-/// contain regions.\n+/// Map between Local and LocalWithRegion indices: the purpose of this\n+/// map is to define the subset of local variables for which we need\n+/// to do a liveness computation. We only need to compute whether a\n+/// variable `X` is live if that variable contains some region `R` in\n+/// its type where `R` is not known to outlive a free region (i.e.,\n+/// where `R` may be valid for just a subset of the fn body).\n crate struct NllLivenessMap {\n-    /// For each local variable, contains either None (if the type has no regions)\n-    /// or Some(i) with a suitable index.\n+    /// For each local variable, contains `Some(i)` if liveness is\n+    /// needed for this variable.\n     pub from_local: IndexVec<Local, Option<LocalWithRegion>>,\n-    /// For each LocalWithRegion, maps back to the original Local index.\n+\n+    /// For each `LocalWithRegion`, maps back to the original `Local` index.\n     pub to_local: IndexVec<LocalWithRegion, Local>,\n }\n \n@@ -51,21 +55,32 @@ impl LiveVariableMap for NllLivenessMap {\n }\n \n impl NllLivenessMap {\n-    /// Iterates over the variables in Mir and assigns each Local whose type contains\n-    /// regions a LocalWithRegion index. Returns a map for converting back and forth.\n-    pub fn compute(mir: &Mir) -> Self {\n+    crate fn compute(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        free_regions: &FxHashSet<RegionVid>,\n+        mir: &Mir<'tcx>,\n+    ) -> Self {\n         let mut to_local = IndexVec::default();\n         let from_local: IndexVec<Local, Option<_>> = mir.local_decls\n             .iter_enumerated()\n             .map(|(local, local_decl)| {\n-                if local_decl.ty.has_free_regions() {\n-                    Some(to_local.push(local))\n-                } else {\n+                if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n+                    free_regions.contains(&r.to_region_vid())\n+                }) {\n+                    // If all the regions in the type are free regions\n+                    // (or there are no regions), then we don't need\n+                    // to track liveness for this variable.\n                     None\n+                } else {\n+                    Some(to_local.push(local))\n                 }\n             })\n             .collect();\n \n+        debug!(\"{} total variables\", mir.local_decls.len());\n+        debug!(\"{} variables need liveness\", to_local.len());\n+        debug!(\"{} regions outlive free regions\", free_regions.len());\n+\n         Self {\n             from_local,\n             to_local,"}, {"sha": "d3ef2a369094a733964b9839def3885fc6e4e684", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::{NllLivenessMap, LocalWithRegion};\n+use borrow_check::nll::constraints::ConstraintSet;\n use borrow_check::nll::type_check::AtLocation;\n+use borrow_check::nll::{LocalWithRegion, NllLivenessMap};\n+use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n@@ -18,10 +20,10 @@ use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n-use rustc::ty::{Ty, TypeFoldable};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc::ty::{RegionVid, Ty, TypeFoldable};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::rc::Rc;\n-use util::liveness::{LivenessResults, LiveVariableMap };\n+use util::liveness::{LiveVariableMap, LivenessResults};\n \n use super::TypeChecker;\n \n@@ -41,9 +43,18 @@ pub(super) fn generate<'gcx, 'tcx>(\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> (LivenessResults<LocalWithRegion>, NllLivenessMap) {\n-    let liveness_map = NllLivenessMap::compute(&mir);\n+    let free_regions = {\n+        let borrowck_context = cx.borrowck_context.as_ref().unwrap();\n+        regions_that_outlive_free_regions(\n+            cx.infcx.num_region_vars(),\n+            &borrowck_context.universal_regions,\n+            &borrowck_context.constraints.outlives_constraints,\n+        )\n+    };\n+    let liveness_map = NllLivenessMap::compute(cx.tcx(), &free_regions, mir);\n     let liveness = LivenessResults::compute(mir, &liveness_map);\n \n+    // For everything else, it is only live where it is actually used.\n     {\n         let mut generator = TypeLivenessGenerator {\n             cx,\n@@ -63,6 +74,45 @@ pub(super) fn generate<'gcx, 'tcx>(\n     (liveness, liveness_map)\n }\n \n+/// Compute all regions that are (currently) known to outlive free\n+/// regions. For these regions, we do not need to compute\n+/// liveness, since the outlives constraints will ensure that they\n+/// are live over the whole fn body anyhow.\n+fn regions_that_outlive_free_regions(\n+    num_region_vars: usize,\n+    universal_regions: &UniversalRegions<'tcx>,\n+    constraint_set: &ConstraintSet,\n+) -> FxHashSet<RegionVid> {\n+    // Build a graph of the outlives constraints thus far. This is\n+    // a reverse graph, so for each constraint `R1: R2` we have an\n+    // edge `R2 -> R1`. Therefore, if we find all regions\n+    // reachable from each free region, we will have all the\n+    // regions that are forced to outlive some free region.\n+    let rev_constraint_graph = constraint_set.reverse_graph(num_region_vars);\n+    let rev_region_graph = rev_constraint_graph.region_graph(constraint_set);\n+\n+    // Stack for the depth-first search. Start out with all the free regions.\n+    let mut stack: Vec<_> = universal_regions.universal_regions().collect();\n+\n+    // Set of all free regions, plus anything that outlives them. Initially\n+    // just contains the free regions.\n+    let mut outlives_free_region: FxHashSet<_> = stack.iter().cloned().collect();\n+\n+    // Do the DFS -- for each thing in the stack, find all things\n+    // that outlive it and add them to the set. If they are not,\n+    // push them onto the stack for later.\n+    while let Some(sub_region) = stack.pop() {\n+        stack.extend(\n+            rev_region_graph\n+                .outgoing_regions(sub_region)\n+                .filter(|&r| outlives_free_region.insert(r)),\n+        );\n+    }\n+\n+    // Return the final set of things we visited.\n+    outlives_free_region\n+}\n+\n struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n where\n     'typeck: 'gen,\n@@ -182,8 +232,13 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n \n         cx.tcx().for_each_free_region(&value, |live_region| {\n             if let Some(ref mut borrowck_context) = cx.borrowck_context {\n-                let region_vid = borrowck_context.universal_regions.to_region_vid(live_region);\n-                borrowck_context.constraints.liveness_constraints.add_element(region_vid, location);\n+                let region_vid = borrowck_context\n+                    .universal_regions\n+                    .to_region_vid(live_region);\n+                borrowck_context\n+                    .constraints\n+                    .liveness_constraints\n+                    .add_element(region_vid, location);\n \n                 if let Some(all_facts) = borrowck_context.all_facts {\n                     let start_index = borrowck_context.location_table.start_index(location);"}, {"sha": "52f1547bce6f86f33b7bcd359e41186aef326d06", "filename": "src/test/ui/borrowck/promote-ref-mut-in-let-issue-46557.nll.stderr", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr?ref=3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "patch": "@@ -1,30 +1,24 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:15:21\n    |\n-LL |   fn gimme_static_mut_let() -> &'static mut u32 {\n-   |  _______________________________________________-\n-LL | |     let ref mut x = 1234543; //~ ERROR\n-   | |                     ^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let ref mut x = 1234543; //~ ERROR\n+   |                     ^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:20:25\n    |\n-LL |   fn gimme_static_mut_let_nested() -> &'static mut u32 {\n-   |  ______________________________________________________-\n-LL | |     let (ref mut x, ) = (1234543, ); //~ ERROR\n-   | |                         ^^^^^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let (ref mut x, ) = (1234543, ); //~ ERROR\n+   |                         ^^^^^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:25:11"}, {"sha": "580dce3c0fe632691f65bc1d8d35d1e153275397", "filename": "src/test/ui/nll/get_default.nll.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr?ref=3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "patch": "@@ -63,9 +63,18 @@ LL |         match map.get() {\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n-...\n-LL |                 return v;\n-   |                        - borrow later used here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17"}, {"sha": "2f8eab907c7bb5185353420d28460e9ac2cd38e6", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "patch": "@@ -63,9 +63,18 @@ LL |         match map.get() {\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^ mutable borrow occurs here\n-...\n-LL |                 return v;\n-   |                        - borrow later used here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17"}, {"sha": "f441085f242edddc102c2078ba1fd1691134b523", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.stderr", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr?ref=3b7989d1dffb0d1b36dd8f4a7b11ea98ed7dc2ba", "patch": "@@ -1,16 +1,13 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/return-ref-mut-issue-46557.rs:17:21\n    |\n-LL |   fn gimme_static_mut() -> &'static mut u32 {\n-   |  ___________________________________________-\n-LL | |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n-   | |                     ^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n+   |                     ^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error: aborting due to previous error\n "}]}