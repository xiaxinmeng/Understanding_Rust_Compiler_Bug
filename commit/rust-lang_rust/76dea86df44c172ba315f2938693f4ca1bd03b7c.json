{"sha": "76dea86df44c172ba315f2938693f4ca1bd03b7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZGVhODZkZjQ0YzE3MmJhMzE1ZjI5Mzg2OTNmNGNhMWJkMDNiN2M=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-09T10:32:54Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-17T16:38:20Z"}, "message": "Factor out a struct that holds subfields of a pattern", "tree": {"sha": "ea97b2f957c760c2aedf6915b038687e30457844", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea97b2f957c760c2aedf6915b038687e30457844"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76dea86df44c172ba315f2938693f4ca1bd03b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76dea86df44c172ba315f2938693f4ca1bd03b7c", "html_url": "https://github.com/rust-lang/rust/commit/76dea86df44c172ba315f2938693f4ca1bd03b7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76dea86df44c172ba315f2938693f4ca1bd03b7c/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "160eebec21387c13e4966f5744b998e75e647fb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/160eebec21387c13e4966f5744b998e75e647fb8", "html_url": "https://github.com/rust-lang/rust/commit/160eebec21387c13e4966f5744b998e75e647fb8"}], "stats": {"total": 53, "additions": 43, "deletions": 10}, "files": [{"sha": "688af15bd74c82b37c109f2ebe08eb3ec55a06bf", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/76dea86df44c172ba315f2938693f4ca1bd03b7c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dea86df44c172ba315f2938693f4ca1bd03b7c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=76dea86df44c172ba315f2938693f4ca1bd03b7c", "patch": "@@ -441,7 +441,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Option<PatStack<'p, 'tcx>> {\n         let new_heads = specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns);\n         new_heads.map(|mut new_head| {\n@@ -503,7 +503,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n         self.0\n             .iter()\n@@ -722,10 +722,12 @@ impl Slice {\n     }\n }\n \n+/// A value can be decomposed into a constructor applied to some fields. This struct represents\n+/// the constructor. See also `Fields`.\n #[derive(Clone, Debug, PartialEq)]\n enum Constructor<'tcx> {\n-    /// The constructor of all patterns that don't vary by constructor,\n-    /// e.g., struct patterns and fixed-length arrays.\n+    /// The constructor for patterns that have a single constructor, like tuples, struct patterns\n+    /// and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n@@ -1027,6 +1029,38 @@ impl<'tcx> Constructor<'tcx> {\n     }\n }\n \n+/// A value can be decomposed into a constructor applied to some fields. This struct represents\n+/// those fields, generalized to allow patterns in each field. See also `Constructor`.\n+#[derive(Debug, Clone)]\n+enum Fields<'p, 'tcx> {\n+    Slice(&'p [Pat<'tcx>]),\n+}\n+\n+impl<'p, 'tcx> Fields<'p, 'tcx> {\n+    /// Creates a new list of wildcard fields for a given constructor.\n+    fn wildcards(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        constructor: &Constructor<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n+        debug!(\"Fields::wildcards({:#?}, {:?})\", constructor, ty);\n+        let pats = cx.pattern_arena.alloc_from_iter(constructor.wildcard_subpatterns(cx, ty));\n+        Fields::Slice(pats)\n+    }\n+\n+    fn len(&self) -> usize {\n+        match self {\n+            Fields::Slice(pats) => pats.len(),\n+        }\n+    }\n+\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = &'p Pat<'tcx>> + Captures<'a> {\n+        match self {\n+            Fields::Slice(pats) => pats.iter(),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n crate enum Usefulness<'tcx, 'p> {\n     /// Carries a list of unreachable subpatterns. Used only in the presence of or-patterns.\n@@ -1823,10 +1857,9 @@ fn is_useful_specialized<'p, 'tcx>(\n ) -> Usefulness<'tcx, 'p> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n-    let ctor_wild_subpatterns =\n-        cx.pattern_arena.alloc_from_iter(ctor.wildcard_subpatterns(cx, lty));\n-    let matrix = matrix.specialize_constructor(cx, &ctor, ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, ctor_wild_subpatterns)\n+    let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, lty);\n+    let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n+    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n         .map(|u| u.apply_constructor(cx, &ctor, lty))\n         .unwrap_or(NotUseful)\n@@ -2295,7 +2328,7 @@ fn constructor_covered_by_range<'tcx>(\n fn patterns_for_variant<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     subpatterns: &'p [FieldPat<'tcx>],\n-    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+    ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     is_non_exhaustive: bool,\n ) -> PatStack<'p, 'tcx> {\n     let mut result: SmallVec<_> = ctor_wild_subpatterns.iter().collect();\n@@ -2326,7 +2359,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n-    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+    ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n ) -> Option<PatStack<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n         // Only a wildcard pattern can match the special extra constructor"}]}