{"sha": "e92298187bceb0cc1cf423dd37e0f5fe30359a17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MjI5ODE4N2JjZWIwY2MxY2Y0MjNkZDM3ZTBmNWZlMzAzNTlhMTc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-18T23:38:35Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-18T23:38:35Z"}, "message": "Add bzero glue and preliminary code for dynamic size/align calculations.", "tree": {"sha": "a8ea621832055d8716821dcda1800b03c35f6eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8ea621832055d8716821dcda1800b03c35f6eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e92298187bceb0cc1cf423dd37e0f5fe30359a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e92298187bceb0cc1cf423dd37e0f5fe30359a17", "html_url": "https://github.com/rust-lang/rust/commit/e92298187bceb0cc1cf423dd37e0f5fe30359a17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e92298187bceb0cc1cf423dd37e0f5fe30359a17/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b86e8115d7489f2167942b32b9a62cdae3ef89b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b86e8115d7489f2167942b32b9a62cdae3ef89b6", "html_url": "https://github.com/rust-lang/rust/commit/b86e8115d7489f2167942b32b9a62cdae3ef89b6"}], "stats": {"total": 189, "additions": 174, "deletions": 15}, "files": [{"sha": "db17b9428748442f15d2a09893a945110f1fe52b", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e92298187bceb0cc1cf423dd37e0f5fe30359a17/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92298187bceb0cc1cf423dd37e0f5fe30359a17/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=e92298187bceb0cc1cf423dd37e0f5fe30359a17", "patch": "@@ -63,6 +63,10 @@ fn memcpy_glue_name() -> str {\n     ret \"rust_memcpy_glue\";\n }\n \n+fn bzero_glue_name() -> str {\n+    ret \"rust_bzero_glue\";\n+}\n+\n fn upcall_glue_name(int n) -> str {\n     ret \"rust_upcall_\" + util.common.istr(n);\n }"}, {"sha": "c3c8ee111312cb81172c81cd741b0dec229f152a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 170, "deletions": 15, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/e92298187bceb0cc1cf423dd37e0f5fe30359a17/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92298187bceb0cc1cf423dd37e0f5fe30359a17/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e92298187bceb0cc1cf423dd37e0f5fe30359a17", "patch": "@@ -52,7 +52,8 @@ type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef exit_task_glue,\n                     vec[ValueRef] upcall_glues,\n                     ValueRef no_op_type_glue,\n-                    ValueRef memcpy_glue);\n+                    ValueRef memcpy_glue,\n+                    ValueRef bzero_glue);\n \n tag arity { nullary; n_ary; }\n type tag_info = rec(type_handle th,\n@@ -632,19 +633,110 @@ fn find_scope_cx(@block_ctxt cx) -> @block_ctxt {\n     }\n }\n \n-fn size_of(TypeRef t) -> ValueRef {\n+fn umax(@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n+    auto cond = cx.build.ICmp(lib.llvm.LLVMIntULT, a, b);\n+    ret cx.build.Select(cond, b, a);\n+}\n+\n+fn align_to(@block_ctxt cx, ValueRef off, ValueRef align) -> ValueRef {\n+    auto mask = cx.build.Sub(align, C_int(1));\n+    auto bumped = cx.build.Add(off, mask);\n+    ret cx.build.And(bumped, cx.build.Not(mask));\n+}\n+\n+fn llsize_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMSizeOf(t), T_int(), False);\n }\n \n-fn align_of(TypeRef t) -> ValueRef {\n+fn llalign_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMAlignOf(t), T_int(), False);\n }\n \n+fn size_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+    if (!ty.type_has_dynamic_size(t)) {\n+        ret llsize_of(type_of(cx.fcx.ccx, t));\n+    }\n+    ret dynamic_size_of(cx, t);\n+}\n+\n+fn align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+    if (!ty.type_has_dynamic_size(t)) {\n+        ret llalign_of(type_of(cx.fcx.ccx, t));\n+    }\n+    ret dynamic_align_of(cx, t);\n+}\n+\n+fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+    alt (t.struct) {\n+        case (ty.ty_param(?p)) {\n+            auto szptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n+            ret cx.build.Load(szptr);\n+        }\n+        case (ty.ty_tup(?elts)) {\n+            //\n+            // C padding rules:\n+            //\n+            //\n+            //   - Pad after each element so that next element is aligned.\n+            //   - Pad after final structure member so that whole structure\n+            //     is aligned to max alignment of interior.\n+            //\n+            auto off = C_int(0);\n+            auto max_align = C_int(1);\n+            for (@ty.t e in elts) {\n+                auto elt_align = align_of(cx, e);\n+                auto elt_size = size_of(cx, e);\n+                auto aligned_off = align_to(cx, off, elt_align);\n+                off = cx.build.Add(aligned_off, elt_size);\n+                max_align = umax(cx, max_align, elt_align);\n+            }\n+            off = align_to(cx, off, max_align);\n+            ret off;\n+        }\n+        case (ty.ty_rec(?flds)) {\n+            auto off = C_int(0);\n+            auto max_align = C_int(1);\n+            for (ty.field f in flds) {\n+                auto elt_align = align_of(cx, f.ty);\n+                auto elt_size = size_of(cx, f.ty);\n+                auto aligned_off = align_to(cx, off, elt_align);\n+                off = cx.build.Add(aligned_off, elt_size);\n+                max_align = umax(cx, max_align, elt_align);\n+            }\n+            off = align_to(cx, off, max_align);\n+            ret off;\n+        }\n+    }\n+}\n+\n+fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> ValueRef {\n+    alt (t.struct) {\n+        case (ty.ty_param(?p)) {\n+            auto aptr = field_of_tydesc(cx, t, abi.tydesc_field_align);\n+            ret cx.build.Load(aptr);\n+        }\n+        case (ty.ty_tup(?elts)) {\n+            auto a = C_int(1);\n+            for (@ty.t e in elts) {\n+                a = umax(cx, a, align_of(cx, e));\n+            }\n+            ret a;\n+        }\n+        case (ty.ty_rec(?flds)) {\n+            auto a = C_int(1);\n+            for (ty.field f in flds) {\n+                a = umax(cx, a, align_of(cx, f.ty));\n+            }\n+            ret a;\n+        }\n+    }\n+}\n+\n fn trans_malloc_inner(@block_ctxt cx, TypeRef llptr_ty) -> result {\n     auto llbody_ty = lib.llvm.llvm.LLVMGetElementType(llptr_ty);\n     // FIXME: need a table to collect tydesc globals.\n     auto tydesc = C_int(0);\n-    auto sz = size_of(llbody_ty);\n+    auto sz = llsize_of(llbody_ty);\n     auto sub = trans_upcall(cx, \"upcall_malloc\", vec(sz, tydesc));\n     sub.val = sub.bcx.build.IntToPtr(sub.val, llptr_ty);\n     ret sub;\n@@ -699,8 +791,8 @@ fn make_tydesc(@crate_ctxt cx, @ty.t t) {\n     auto pvoid = T_ptr(T_i8());\n     auto glue_fn_ty = T_ptr(T_fn(vec(T_taskptr(), pvoid), T_void()));\n     auto tydesc = C_struct(vec(C_null(pvoid),\n-                               size_of(llty),\n-                               align_of(llty),\n+                               llsize_of(llty),\n+                               llalign_of(llty),\n                                take_glue,             // take_glue_off\n                                drop_glue,             // drop_glue_off\n                                C_null(glue_fn_ty),    // free_glue_off\n@@ -1146,7 +1238,7 @@ fn iter_sequence(@block_ctxt cx,\n                                           C_int(abi.vec_elt_fill)));\n \n         auto llunit_ty = type_of(cx.fcx.ccx, elt_ty);\n-        auto unit_sz = size_of(llunit_ty);\n+        auto unit_sz = size_of(cx, elt_ty);\n \n         auto len = cx.build.Load(lenptr);\n         if (trailing_null) {\n@@ -1249,6 +1341,15 @@ fn call_memcpy(@block_ctxt cx,\n                                   vec(dst_ptr, src_ptr, size)));\n }\n \n+fn call_bzero(@block_ctxt cx,\n+              ValueRef dst,\n+              ValueRef n_bytes) -> result {\n+    auto dst_ptr = cx.build.PointerCast(dst, T_ptr(T_i8()));\n+    auto size = cx.build.IntCast(n_bytes, T_int());\n+    ret res(cx, cx.build.FastCall(cx.fcx.ccx.glues.bzero_glue,\n+                                  vec(dst_ptr, size)));\n+}\n+\n fn memcpy_ty(@block_ctxt cx,\n              ValueRef dst,\n              ValueRef src,\n@@ -1901,7 +2002,7 @@ impure fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     auto v = lv.val;\n \n     auto llunit_ty = node_type(cx.fcx.ccx, ann);\n-    auto unit_sz = size_of(llunit_ty);\n+    auto unit_sz = size_of(cx, node_ann_type(cx.fcx.ccx, ann));\n     auto scaled_ix = ix.bcx.build.Mul(ix.val, unit_sz);\n \n     auto lim = ix.bcx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_fill)));\n@@ -2374,7 +2475,7 @@ impure fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     }\n \n     auto llunit_ty = type_of(cx.fcx.ccx, unit_ty);\n-    auto unit_sz = size_of(llunit_ty);\n+    auto unit_sz = size_of(cx, unit_ty);\n     auto data_sz = llvm.LLVMConstMul(C_int(_vec.len[@ast.expr](args) as int),\n                                      unit_sz);\n \n@@ -2681,9 +2782,15 @@ impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n                             sub = copy_ty(sub.bcx, true, llptr, sub.val, ty);\n                         }\n                         case (_) {\n-                            auto llty = type_of(cx.fcx.ccx, ty);\n-                            auto null = lib.llvm.llvm.LLVMConstNull(llty);\n-                            sub = res(cx, cx.build.Store(null, llptr));\n+                            if (middle.ty.type_has_dynamic_size(ty)) {\n+                                auto llsz = size_of(cx, ty);\n+                                sub = call_bzero(cx, llptr, llsz);\n+\n+                            } else {\n+                                auto llty = type_of(cx.fcx.ccx, ty);\n+                                auto null = lib.llvm.llvm.LLVMConstNull(llty);\n+                                sub = res(cx, cx.build.Store(null, llptr));\n+                            }\n                         }\n                     }\n                 }\n@@ -2779,8 +2886,14 @@ impure fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n     for each (@ast.local local in block_locals(b)) {\n-        auto ty = node_type(cx.fcx.ccx, local.ann);\n-        auto val = bcx.build.Alloca(ty);\n+        auto t = node_ann_type(cx.fcx.ccx, local.ann);\n+        auto val = C_int(0);\n+        if (ty.type_has_dynamic_size(t)) {\n+            auto n = size_of(bcx, t);\n+            val = bcx.build.ArrayAlloca(T_i8(), n);\n+        } else {\n+            val = bcx.build.Alloca(type_of(cx.fcx.ccx, t));\n+        }\n         cx.fcx.lllocals.insert(local.id, val);\n     }\n     auto r = res(bcx, C_nil());\n@@ -3684,6 +3797,47 @@ fn make_memcpy_glue(ModuleRef llmod) -> ValueRef {\n     ret fun;\n }\n \n+fn make_bzero_glue(ModuleRef llmod) -> ValueRef {\n+\n+    // We're not using the LLVM memset intrinsic. Same as with memcpy.\n+\n+    auto p8 = T_ptr(T_i8());\n+\n+    auto ty = T_fn(vec(p8, T_int()), T_void());\n+    auto fun = decl_fastcall_fn(llmod, abi.bzero_glue_name(), ty);\n+\n+    auto initbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"init\"));\n+    auto hdrbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"hdr\"));\n+    auto loopbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"loop\"));\n+    auto endbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"end\"));\n+\n+    auto dst = llvm.LLVMGetParam(fun, 0u);\n+    auto count = llvm.LLVMGetParam(fun, 1u);\n+\n+    // Init block.\n+    auto ib = new_builder(initbb);\n+    auto ip = ib.Alloca(T_int());\n+    ib.Store(C_int(0), ip);\n+    ib.Br(hdrbb);\n+\n+    // Loop-header block\n+    auto hb = new_builder(hdrbb);\n+    auto i = hb.Load(ip);\n+    hb.CondBr(hb.ICmp(lib.llvm.LLVMIntEQ, count, i), endbb, loopbb);\n+\n+    // Loop-body block\n+    auto lb = new_builder(loopbb);\n+    i = lb.Load(ip);\n+    lb.Store(C_integral(0, T_i8()), lb.GEP(dst, vec(i)));\n+    lb.Store(lb.Add(i, C_int(1)), ip);\n+    lb.Br(hdrbb);\n+\n+    // End block\n+    auto eb = new_builder(endbb);\n+    eb.RetVoid();\n+    ret fun;\n+}\n+\n fn make_glues(ModuleRef llmod) -> @glue_fns {\n     ret @rec(activate_glue = decl_glue(llmod, abi.activate_glue_name()),\n              yield_glue = decl_glue(llmod, abi.yield_glue_name()),\n@@ -3704,7 +3858,8 @@ fn make_glues(ModuleRef llmod) -> @glue_fns {\n               _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),\n                                      abi.n_upcall_glues as uint),\n              no_op_type_glue = make_no_op_type_glue(llmod),\n-             memcpy_glue = make_memcpy_glue(llmod));\n+             memcpy_glue = make_memcpy_glue(llmod),\n+             bzero_glue = make_bzero_glue(llmod));\n }\n \n fn trans_crate(session.session sess, @ast.crate crate, str output,"}]}