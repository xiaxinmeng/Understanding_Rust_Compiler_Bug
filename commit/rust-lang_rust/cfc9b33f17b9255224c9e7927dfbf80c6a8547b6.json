{"sha": "cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYzliMzNmMTdiOTI1NTIyNGM5ZTc5MjdkZmJmODBjNmE4NTQ3YjY=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2018-07-25T17:54:45Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2018-07-25T17:54:45Z"}, "message": "Merge branch 'master' into typos", "tree": {"sha": "02792bf6879dd52ff4a7a4ae8ce034d32802c695", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02792bf6879dd52ff4a7a4ae8ce034d32802c695"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "html_url": "https://github.com/rust-lang/rust/commit/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "949f0d9c72e901a001acd9c82bca6339be3b6b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/949f0d9c72e901a001acd9c82bca6339be3b6b0e", "html_url": "https://github.com/rust-lang/rust/commit/949f0d9c72e901a001acd9c82bca6339be3b6b0e"}, {"sha": "fde487c1dc61919b123a315f6a6132850b0a5fe3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fde487c1dc61919b123a315f6a6132850b0a5fe3", "html_url": "https://github.com/rust-lang/rust/commit/fde487c1dc61919b123a315f6a6132850b0a5fe3"}], "stats": {"total": 4777, "additions": 2648, "deletions": 2129}, "files": [{"sha": "c6bd67ae0f3df6ffed8283d7a9f74fa0236f3cbf", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -48,8 +48,6 @@ matrix:\n     - env: INTEGRATION=serde-rs/serde\n     - env: INTEGRATION=Geal/nom\n     - env: INTEGRATION=hyperium/hyper\n-    - env: INTEGRATION=rust-lang/cargo\n-    - env: INTEGRATION=rust-lang-nursery/rls\n \n script:\n   - |"}, {"sha": "48585df06031c48d04487839b627d1a07c845f33", "filename": "CHANGELOG.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,9 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.212\n+* Rustup to *rustc 1.29.0-nightly (e06c87544 2018-07-06)*\n+\n ## 0.0.211\n * Rustup to *rustc 1.28.0-nightly (e3bf634e0 2018-06-28)*\n \n@@ -504,7 +507,7 @@ All notable changes to this project will be documented in this file.\n ## 0.0.74 \u2014 2016-06-07\n * Fix bug with `cargo-clippy` JSON parsing\n * Add the `CLIPPY_DISABLE_DOCS_LINKS` environment variable to deactivate the\n-  \u201cfor further information visit *wiki-link*\u201d message.\n+  \u201cfor further information visit *lint-link*\u201d message.\n \n ## 0.0.73 \u2014 2016-06-05\n * Fix false positives in [`useless_let_if_seq`]\n@@ -609,7 +612,7 @@ All notable changes to this project will be documented in this file.\n [`AsRef`]: https://doc.rust-lang.org/std/convert/trait.AsRef.html\n [configuration file]: ./rust-clippy#configuration\n \n-<!-- begin autogenerated links to wiki -->\n+<!-- begin autogenerated links to lint list -->\n [`absurd_extreme_comparisons`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n [`almost_swapped`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#almost_swapped\n [`approx_constant`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant\n@@ -744,6 +747,7 @@ All notable changes to this project will be documented in this file.\n [`misaligned_transmute`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#misaligned_transmute\n [`misrefactored_assign_op`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#misrefactored_assign_op\n [`missing_docs_in_private_items`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#missing_docs_in_private_items\n+[`missing_inline_in_public_items`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#missing_inline_in_public_items\n [`mixed_case_hex_literals`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#mixed_case_hex_literals\n [`module_inception`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#module_inception\n [`modulo_one`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#modulo_one\n@@ -890,4 +894,4 @@ All notable changes to this project will be documented in this file.\n [`zero_prefixed_literal`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#zero_prefixed_literal\n [`zero_ptr`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#zero_ptr\n [`zero_width_space`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#zero_width_space\n-<!-- end autogenerated links to wiki -->\n+<!-- end autogenerated links to lint list -->"}, {"sha": "293418416a27402aba55f759a07f2608d2f051b5", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,4 @@\n-# Contributing to rust-clippy\n+# Contributing to Clippy\n \n Hello fellow Rustacean! Great to see your interest in compiler internals and lints!\n \n@@ -63,7 +63,7 @@ an AST expression). `match_def_path()` in Clippy's `utils` module can also be us\n \n ## Writing code\n \n-Compiling clippy from scratch can take almost a minute or more depending on your machine.\n+Compiling Clippy from scratch can take almost a minute or more depending on your machine.\n However, since Rust 1.24.0 incremental compilation is enabled by default and compile times for small changes should be quick.\n \n [Llogiq's blog post on lints](https://llogiq.github.io/2015/06/04/workflows.html) is a nice primer\n@@ -74,7 +74,7 @@ of this.\n \n ### Author lint\n \n-There is also the internal `author` lint to generate clippy code that detects the offending pattern. It does not work for all of the Rust syntax, but can give a good starting point.\n+There is also the internal `author` lint to generate Clippy code that detects the offending pattern. It does not work for all of the Rust syntax, but can give a good starting point.\n \n First, create a new UI test file in the `tests/ui/` directory with the pattern you want to match:\n \n@@ -93,9 +93,9 @@ a `.stdout` file with the generated code:\n // ./tests/ui/my_lint.stdout\n \n if_chain! {\n-    if let Expr_::ExprArray(ref elements) = stmt.node;\n+    if let ExprKind::Array(ref elements) = stmt.node;\n     if elements.len() == 1;\n-    if let Expr_::ExprLit(ref lit) = elements[0].node;\n+    if let ExprKind::Lit(ref lit) = elements[0].node;\n     if let LitKind::Int(7, _) = lit.node;\n     then {\n         // report your lint here\n@@ -148,7 +148,7 @@ Therefore you should use `tests/ui/update-all-references.sh` (after running\n ### Testing manually\n \n Manually testing against an example file is useful if you have added some\n-`println!`s and test suite output becomes unreadable.  To try clippy with your\n+`println!`s and test suite output becomes unreadable.  To try Clippy with your\n local modifications, run `cargo run --bin clippy-driver -- -L ./target/debug input.rs` from the\n working copy root.\n \n@@ -179,7 +179,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n ```\n \n The [`rustc_plugin::PluginRegistry`][plugin_registry] provides two methods to register lints: [register_early_lint_pass][reg_early_lint_pass] and [register_late_lint_pass][reg_late_lint_pass].\n-Both take an object that implements an [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass] respectively. This is done in every single lint. \n+Both take an object that implements an [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass] respectively. This is done in every single lint.\n It's worth noting that the majority of `clippy_lints/src/lib.rs` is autogenerated by `util/update_lints.py` and you don't have to add anything by hand. When you are writing your own lint, you can use that script to save you some time.\n \n ```rust"}, {"sha": "7c9fe25123760d7d419e1bf752ff014076f024ae", "filename": "Cargo.toml", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,7 +2,7 @@ cargo-features = [\"edition\"]\n \n [package]\n name = \"clippy\"\n-version = \"0.0.211\"\n+version = \"0.0.212\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -40,11 +40,51 @@ path = \"src/driver.rs\"\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.211\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.212\", path = \"clippy_lints\" }\n # end automatic update\n regex = \"1\"\n semver = \"0.9\"\n \n+# Not actually needed right now but required to make sure that clippy/ and cargo build\n+# with the same set of features in rust-lang/rust\n+num-traits = \"0.2\" # enable the default feature\n+backtrace = \"0.3\"\n+\n+# keep in sync with `cargo`'s `Cargo.toml'\n+[target.'cfg(windows)'.dependencies.winapi]\n+version = \"0.3\"\n+features = [\n+  # keep in sync with `cargo`'s `Cargo.toml'\n+  \"handleapi\",\n+  \"jobapi\",\n+  \"jobapi2\",\n+  \"minwindef\",\n+  \"ntdef\",\n+  \"ntstatus\",\n+  \"processenv\",\n+  \"processthreadsapi\",\n+  \"psapi\",\n+  \"synchapi\",\n+  \"winerror\",\n+  \"winbase\",\n+  \"wincon\",\n+  \"winnt\",\n+  # no idea where these come from\n+  \"basetsd\",\n+  \"lmcons\",\n+  \"memoryapi\",\n+  \"minschannel\",\n+  \"minwinbase\",\n+  \"ntsecapi\",\n+  \"profileapi\",\n+  \"schannel\",\n+  \"securitybaseapi\",\n+  \"synchapi\",\n+  \"sysinfoapi\",\n+  \"timezoneapi\",\n+  \"wincrypt\",\n+]\n+\n [dev-dependencies]\n cargo_metadata = \"0.5\"\n compiletest_rs = \"0.3.7\""}, {"sha": "749eae973047af002ef3b3f2c70a655d8184570d", "filename": "PUBLISH.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/PUBLISH.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/PUBLISH.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/PUBLISH.md?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,7 +1,8 @@\n-Steps to publish a new clippy version\n+Steps to publish a new Clippy version\n \n - Bump `package.version` in `./Cargo.toml` (no need to manually bump `dependencies.clippy_lints.version`).\n - Write a changelog entry.\n+- If a nightly update is needed, update `min_version.txt` using `rustc -vV > min_version.txt`\n - Run `./pre_publish.sh`\n - Review and commit all changed files\n - `git push`"}, {"sha": "41eacdba1a4a81f0a49e0c48688ac0c6a6553716", "filename": "README.md", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,6 @@\n-We are currently in the process of discussing Clippy 1.0 via the RFC process in https://github.com/rust-lang/rfcs/pull/2476 . The RFC's goal is to clarify policies around lint categorizations and the policy around which lints should be in the compiler and which lints should be in clippy. Please leave your thoughts on the RFC PR.\n+We are currently in the process of discussing Clippy 1.0 via the RFC process in https://github.com/rust-lang/rfcs/pull/2476 . The RFC's goal is to clarify policies around lint categorizations and the policy around which lints should be in the compiler and which lints should be in Clippy. Please leave your thoughts on the RFC PR.\n \n-# rust-clippy\n+# Clippy\n \n [![Build Status](https://travis-ci.org/rust-lang-nursery/rust-clippy.svg?branch=master)](https://travis-ci.org/rust-lang-nursery/rust-clippy)\n [![Windows Build status](https://ci.appveyor.com/api/projects/status/id677xpw1dguo7iw?svg=true)](https://ci.appveyor.com/project/rust-lang-libs/rust-clippy)\n@@ -9,9 +9,9 @@ We are currently in the process of discussing Clippy 1.0 via the RFC process in\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 272 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n+[There are 273 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n \n-We have a bunch of lint categories to allow you to choose how much clippy is supposed to ~~annoy~~ help you:\n+We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n \n * `clippy` (everything that has no false positives)\n * `clippy_pedantic` (everything)\n@@ -33,57 +33,59 @@ Table of contents:\n ## Usage\n \n Since this is a tool for helping the developer of a library or application\n-write better code, it is recommended not to include clippy as a hard dependency.\n+write better code, it is recommended not to include Clippy as a hard dependency.\n Options include using it as an optional dependency, as a cargo subcommand, or\n-as an included feature during build. All of these options are detailed below.\n+as an included feature during build. These options are detailed below.\n \n-As a general rule clippy will only work with the *latest* Rust nightly for now.\n+### As a cargo subcommand (`cargo clippy`)\n \n-To install Rust nightly, the recommended way is to use [rustup](https://rustup.rs/):\n+One way to use Clippy is by installing Clippy through rustup as a cargo\n+subcommand.\n \n-```terminal\n-rustup install nightly\n-```\n+#### Step 1: Install rustup\n \n-### As a cargo subcommand (`cargo clippy`)\n+You can install [rustup](http://rustup.rs/) on supported platforms. This will help\n+us install clippy and its dependencies.\n \n-One way to use clippy is by installing clippy through cargo as a cargo\n-subcommand.\n+If you already have rustup installed, update to ensure you have the latest\n+rustup and compiler:\n \n ```terminal\n-cargo +nightly install clippy\n+rustup update\n ```\n \n-(The `+nightly` is not necessary if your default `rustup` install is nightly)\n+#### Step 2: Install nightly toolchain\n \n-Now you can run clippy by invoking `cargo +nightly clippy`.\n+Rustup integration is still new, you will need a relatively new nightly (2018-07-15 or later).\n \n-To update the subcommand together with the latest nightly use the [rust-update](rust-update) script or run:\n+To install Rust nightly with [rustup](https://rustup.rs/):\n \n ```terminal\n-rustup update nightly\n-cargo +nightly install --force clippy\n+rustup install nightly\n ```\n \n-In case you are not using rustup, you need to set the environment flag\n-`SYSROOT` during installation so clippy knows where to find `librustc` and\n-similar crates.\n+#### Step 3: Install clippy\n+\n+Once you have rustup and the nightly toolchain installed, run the following command:\n \n ```terminal\n-SYSROOT=/path/to/rustc/sysroot cargo install clippy\n+rustup component add clippy-preview --toolchain=nightly\n ```\n \n-### Running clippy from the command line without installing it\n+Now you can run Clippy by invoking `cargo +nightly clippy`. If nightly is your\n+default toolchain in rustup, `cargo clippy` will work fine.\n+\n+### Running Clippy from the command line without installing it\n \n-To have cargo compile your crate with clippy without clippy installation\n+To have cargo compile your crate with Clippy without Clippy installation\n in your code, you can use:\n \n ```terminal\n cargo run --bin cargo-clippy --manifest-path=path_to_clippys_Cargo.toml\n ```\n \n *[Note](https://github.com/rust-lang-nursery/rust-clippy/wiki#a-word-of-warning):*\n-Be sure that clippy was compiled with the same version of rustc that cargo invokes here!\n+Be sure that Clippy was compiled with the same version of rustc that cargo invokes here!\n \n ## Configuration\n \n@@ -117,7 +119,7 @@ You can add options  to `allow`/`warn`/`deny`:\n Note: `deny` produces errors instead of warnings.\n \n For convenience, `cargo clippy` automatically defines a `cargo-clippy`\n-feature. This lets you set lint levels and compile with or without clippy\n+feature. This lets you set lint levels and compile with or without Clippy\n transparently:\n \n ```rust\n@@ -126,12 +128,12 @@ transparently:\n \n ## Updating rustc\n \n-Sometimes, rustc moves forward without clippy catching up. Therefore updating\n-rustc may leave clippy a non-functional state until we fix the resulting\n+Sometimes, rustc moves forward without Clippy catching up. Therefore updating\n+rustc may leave Clippy a non-functional state until we fix the resulting\n breakage.\n \n You can use the [rust-update](rust-update) script to update rustc only if\n-clippy would also update correctly.\n+Clippy would also update correctly.\n \n ## License\n "}, {"sha": "9d05678f718cb721fec00b8dc6f8f4979e8a3238", "filename": "build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,8 +1,8 @@\n-//! This build script ensures that clippy is not compiled with an\n+//! This build script ensures that Clippy is not compiled with an\n //! incompatible version of rust. It will panic with a descriptive\n //! error message instead.\n //!\n-//! We specifially want to ensure that clippy is only built with a\n+//! We specifially want to ensure that Clippy is only built with a\n //! rustc version that is newer or equal to the one specified in the\n //! `min_version.txt` file.\n //!\n@@ -63,7 +63,7 @@ fn check_rustc_version() {\n         eprintln!(\n             \"\\n{} {}\",\n             Red.bold().paint(\"error:\"),\n-            \"clippy requires a nightly version of Rust.\"\n+            \"Clippy requires a nightly version of Rust.\"\n         );\n         print_version_err(&current_version, &*current_date_str);\n         eprintln!(\n@@ -80,7 +80,7 @@ fn check_rustc_version() {\n         eprintln!(\n             \"\\n{} {}\",\n             Red.bold().paint(\"error:\"),\n-            \"clippy does not support this version of rustc nightly.\"\n+            \"Clippy does not support this version of rustc nightly.\"\n         );\n         eprintln!(\n             \"> {}{}{}\","}, {"sha": "4b304f6f2a6d4c966eeff64f0444072e13fd8677", "filename": "ci/base-tests.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/ci%2Fbase-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/ci%2Fbase-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbase-tests.sh?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -6,6 +6,7 @@ cargo test --features debugging\n mkdir -p ~/rust/cargo/bin\n cp target/debug/cargo-clippy ~/rust/cargo/bin/cargo-clippy\n cp target/debug/clippy-driver ~/rust/cargo/bin/clippy-driver\n+rm ~/.cargo/bin/cargo-clippy\n PATH=$PATH:~/rust/cargo/bin cargo clippy --all -- -D clippy\n cd clippy_workspace_tests && PATH=$PATH:~/rust/cargo/bin cargo clippy -- -D clippy && cd ..\n cd clippy_workspace_tests/src && PATH=$PATH:~/rust/cargo/bin cargo clippy -- -D clippy && cd ../.."}, {"sha": "a989b261ac7a6e4c9431f19efe48206a3fefb5a0", "filename": "ci/integration-tests.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/ci%2Fintegration-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/ci%2Fintegration-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fintegration-tests.sh?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n set -x\n+rm ~/.cargo/bin/cargo-clippy\n cargo install --force --path .\n \n echo \"Running integration test for crate ${INTEGRATION}\""}, {"sha": "5c3af20bde87853bae89b434ff73c083dbd0cad0", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,7 +3,7 @@ cargo-features = [\"edition\"]\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.211\"\n+version = \"0.0.212\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n@@ -21,8 +21,8 @@ edition = \"2018\"\n [dependencies]\n cargo_metadata = \"0.5\"\n itertools = \"0.7\"\n-lazy_static = \"1.0\"\n-matches = \"0.1.2\"\n+lazy_static = \"1.0.2\"\n+matches = \"0.1.7\"\n quine-mc_cluskey = \"0.2.2\"\n regex-syntax = \"0.6\"\n semver = \"0.9.0\"\n@@ -32,7 +32,7 @@ toml = \"0.4\"\n unicode-normalization = \"0.1\"\n pulldown-cmark = \"0.1\"\n url = \"1.7.0\"\n-if_chain = \"0.1\"\n+if_chain = \"0.1.3\"\n \n [features]\n debugging = []"}, {"sha": "cd2444ff31f0d458cba655975967b1180d7b2d89", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::span_lint;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use std::f64::consts as f64;\n use syntax::ast::{FloatTy, Lit, LitKind};\n use syntax::symbol;\n@@ -63,13 +64,13 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprLit(ref lit) = e.node {\n+        if let ExprKind::Lit(ref lit) = e.node {\n             check_lit(cx, lit, e);\n         }\n     }\n }\n \n-fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n+fn check_lit(cx: &LateContext<'_, '_>, lit: &Lit, e: &Expr) {\n     match lit.node {\n         LitKind::Float(s, FloatTy::F32) => check_known_consts(cx, e, s, \"f32\"),\n         LitKind::Float(s, FloatTy::F64) => check_known_consts(cx, e, s, \"f64\"),\n@@ -78,7 +79,7 @@ fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     }\n }\n \n-fn check_known_consts(cx: &LateContext, e: &Expr, s: symbol::Symbol, module: &str) {\n+fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr, s: symbol::Symbol, module: &str) {\n     let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {"}, {"sha": "b3d78d2d13f7951c3a9eb8138494b8c4dd9fd0f6", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::span_lint;\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n \n /// **What it does:** Checks for plain integer arithmetic.\n@@ -55,21 +56,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n             return;\n         }\n         match expr.node {\n-            hir::ExprBinary(ref op, ref l, ref r) => {\n+            hir::ExprKind::Binary(ref op, ref l, ref r) => {\n                 match op.node {\n-                    hir::BiAnd\n-                    | hir::BiOr\n-                    | hir::BiBitAnd\n-                    | hir::BiBitOr\n-                    | hir::BiBitXor\n-                    | hir::BiShl\n-                    | hir::BiShr\n-                    | hir::BiEq\n-                    | hir::BiLt\n-                    | hir::BiLe\n-                    | hir::BiNe\n-                    | hir::BiGe\n-                    | hir::BiGt => return,\n+                    hir::BinOpKind::And\n+                    | hir::BinOpKind::Or\n+                    | hir::BinOpKind::BitAnd\n+                    | hir::BinOpKind::BitOr\n+                    | hir::BinOpKind::BitXor\n+                    | hir::BinOpKind::Shl\n+                    | hir::BinOpKind::Shr\n+                    | hir::BinOpKind::Eq\n+                    | hir::BinOpKind::Lt\n+                    | hir::BinOpKind::Le\n+                    | hir::BinOpKind::Ne\n+                    | hir::BinOpKind::Ge\n+                    | hir::BinOpKind::Gt => return,\n                     _ => (),\n                 }\n                 let (l_ty, r_ty) = (cx.tables.expr_ty(l), cx.tables.expr_ty(r));\n@@ -81,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     self.span = Some(expr.span);\n                 }\n             },\n-            hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n+            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n                 let ty = cx.tables.expr_ty(arg);\n                 if ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");"}, {"sha": "1ce690abcfe95d87dd2cd7a3fc1ed964097f0d2b", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,8 @@ use crate::utils::{higher, sugg};\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast;\n \n /// **What it does:** Checks for compound assignment operations (`+=` and\n@@ -49,8 +51,10 @@ declare_clippy_lint! {\n /// **Why is this bad?** Most likely these are bugs where one meant to write `a\n /// op= b`.\n ///\n-/// **Known problems:** Someone might actually mean `a op= a op b`, but that\n-/// should rather be written as `a = (2 * a) op b` where applicable.\n+/// **Known problems:** Clippy cannot know for sure if `a op= a op b` should have\n+/// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore it suggests both.\n+/// If `a op= a op b` is really the correct behaviour it should be\n+/// written as `a = a op a op b` as it's less confusing.\n ///\n /// **Example:**\n /// ```rust\n@@ -76,7 +80,7 @@ impl LintPass for AssignOps {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {\n                     let lhs = &sugg::Sugg::hir(cx, lhs, \"..\");\n                     let rhs = &sugg::Sugg::hir(cx, rhs, \"..\");\n@@ -87,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                         format!(\"{} = {}\", lhs, sugg::make_binop(higher::binop(op.node), lhs, rhs)),\n                     );\n                 });\n-                if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n+                if let hir::ExprKind::Binary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs_other: &hir::Expr| {\n                             span_lint_and_then(\n@@ -131,8 +135,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     }\n                 }\n             },\n-            hir::ExprAssign(ref assignee, ref e) => {\n-                if let hir::ExprBinary(op, ref l, ref r) = e.node {\n+            hir::ExprKind::Assign(ref assignee, ref e) => {\n+                if let hir::ExprKind::Binary(op, ref l, ref r) = e.node {\n                     #[allow(cyclomatic_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);\n@@ -142,9 +146,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                              $cx:expr,\n                              $ty:expr,\n                              $rty:expr,\n-                             $($trait_name:ident:$full_trait_name:ident),+) => {\n+                             $($trait_name:ident),+) => {\n                                 match $op {\n-                                    $(hir::$full_trait_name => {\n+                                    $(hir::BinOpKind::$trait_name => {\n                                         let [krate, module] = crate::utils::paths::OPS_MODULE;\n                                         let path = [krate, module, concat!(stringify!($trait_name), \"Assign\")];\n                                         let trait_id = if let Some(trait_id) = get_trait_def_id($cx, &path) {\n@@ -159,7 +163,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                         if_chain! {\n                                             if parent_impl != ast::CRATE_NODE_ID;\n                                             if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n-                                            if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) =\n+                                            if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) =\n                                                 item.node;\n                                             if trait_ref.path.def.def_id() == trait_id;\n                                             then { return; }\n@@ -175,18 +179,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                             cx,\n                             ty,\n                             rty.into(),\n-                            Add: BiAdd,\n-                            Sub: BiSub,\n-                            Mul: BiMul,\n-                            Div: BiDiv,\n-                            Rem: BiRem,\n-                            And: BiAnd,\n-                            Or: BiOr,\n-                            BitAnd: BiBitAnd,\n-                            BitOr: BiBitOr,\n-                            BitXor: BiBitXor,\n-                            Shr: BiShr,\n-                            Shl: BiShl\n+                            Add,\n+                            Sub,\n+                            Mul,\n+                            Div,\n+                            Rem,\n+                            And,\n+                            Or,\n+                            BitAnd,\n+                            BitOr,\n+                            BitXor,\n+                            Shr,\n+                            Shl\n                         ) {\n                             span_lint_and_then(\n                                 cx,\n@@ -224,13 +228,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                         // a = b commutative_op a\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r) {\n                             match op.node {\n-                                hir::BiAdd\n-                                | hir::BiMul\n-                                | hir::BiAnd\n-                                | hir::BiOr\n-                                | hir::BiBitXor\n-                                | hir::BiBitAnd\n-                                | hir::BiBitOr => {\n+                                hir::BinOpKind::Add\n+                                | hir::BinOpKind::Mul\n+                                | hir::BinOpKind::And\n+                                | hir::BinOpKind::Or\n+                                | hir::BinOpKind::BitXor\n+                                | hir::BinOpKind::BitAnd\n+                                | hir::BinOpKind::BitOr => {\n                                     lint(assignee, l);\n                                 },\n                                 _ => {},\n@@ -244,11 +248,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     }\n }\n \n-fn is_commutative(op: hir::BinOp_) -> bool {\n-    use rustc::hir::BinOp_::*;\n+fn is_commutative(op: hir::BinOpKind) -> bool {\n+    use rustc::hir::BinOpKind::*;\n     match op {\n-        BiAdd | BiMul | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr | BiEq | BiNe => true,\n-        BiSub | BiDiv | BiRem | BiShl | BiShr | BiLt | BiLe | BiGe | BiGt => false,\n+        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n+        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n     }\n }\n "}, {"sha": "3d25f524afd87fabcc9e37097b3d731c203d6cdb", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -7,6 +7,8 @@ use crate::utils::{\n };\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, TyCtxt};\n use semver::Version;\n use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n@@ -39,22 +41,31 @@ declare_clippy_lint! {\n }\n \n /// **What it does:** Checks for `extern crate` and `use` items annotated with\n-/// lint attributes\n+/// lint attributes.\n+///\n+/// This lint whitelists `#[allow(unused_imports)]` and `#[allow(deprecated)]` on\n+/// `use` items and `#[allow(unused_imports)]` on `extern crate` items with a\n+/// `#[macro_use]` attribute.\n ///\n /// **Why is this bad?** Lint attributes have no effect on crate imports. Most\n-/// likely a `!` was\n-/// forgotten\n+/// likely a `!` was forgotten.\n ///\n-/// **Known problems:** Technically one might allow `unused_import` on a `use`\n-/// item,\n-/// but it's easier to remove the unused item.\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n+/// // Bad\n /// #[deny(dead_code)]\n /// extern crate foo;\n-/// #[allow(unused_import)]\n+/// #[forbid(dead_code)]\n /// use foo::bar;\n+///\n+/// // Ok\n+/// #[allow(unused_imports)]\n+/// use foo::baz;\n+/// #[allow(unused_imports)]\n+/// #[macro_use]\n+/// extern crate baz;\n /// ```\n declare_clippy_lint! {\n     pub USELESS_ATTRIBUTE,\n@@ -154,17 +165,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n             check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n         match item.node {\n-            ItemExternCrate(_) | ItemUse(_, _) => {\n+            ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.name() == \"macro_use\");\n+\n                 for attr in &item.attrs {\n                     if let Some(ref lint_list) = attr.meta_item_list() {\n                         match &*attr.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                                // whitelist `unused_imports` and `deprecated`\n+                                // whitelist `unused_imports` and `deprecated` for `use` items\n+                                // and `unused_imports` for `extern crate` items with `macro_use`\n                                 for lint in lint_list {\n-                                    if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n-                                        if let ItemUse(_, _) = item.node {\n-                                            return;\n-                                        }\n+                                    match item.node {\n+                                        ItemKind::Use(..) => if is_word(lint, \"unused_imports\")\n+                                                                || is_word(lint, \"deprecated\") {\n+                                                return\n+                                        },\n+                                        ItemKind::ExternCrate(..) => if is_word(lint, \"unused_imports\")\n+                                                                        && skip_unused_imports {\n+                                                return\n+                                        },\n+                                        _ => {},\n                                     }\n                                 }\n                                 let line_span = last_line_of_span(cx, attr.span);\n@@ -206,22 +226,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n }\n \n-fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n-    if let ItemFn(_, _, _, eid) = item.node {\n+fn is_relevant_item(tcx: TyCtxt<'_, '_, '_>, item: &Item) -> bool {\n+    if let ItemKind::Fn(_, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         true\n     }\n }\n \n-fn is_relevant_impl(tcx: TyCtxt, item: &ImplItem) -> bool {\n+fn is_relevant_impl(tcx: TyCtxt<'_, '_, '_>, item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n+fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n@@ -231,23 +251,23 @@ fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n     }\n }\n \n-fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n+fn is_relevant_block(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match stmt.node {\n-            StmtDecl(_, _) => true,\n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => is_relevant_expr(tcx, tables, expr),\n+            StmtKind::Decl(_, _) => true,\n+            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => is_relevant_expr(tcx, tables, expr),\n         }\n     } else {\n         block.expr.as_ref().map_or(false, |e| is_relevant_expr(tcx, tables, e))\n     }\n }\n \n-fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n+fn is_relevant_expr(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBlock(ref block, _) => is_relevant_block(tcx, tables, block),\n-        ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n-        ExprRet(None) | ExprBreak(_, None) => false,\n-        ExprCall(ref path_expr, _) => if let ExprPath(ref qpath) = path_expr.node {\n+        ExprKind::Block(ref block, _) => is_relevant_block(tcx, tables, block),\n+        ExprKind::Ret(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n+        ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n+        ExprKind::Call(ref path_expr, _) => if let ExprKind::Path(ref qpath) = path_expr.node {\n             if let Some(fun_id) = opt_def_id(tables.qpath_def(qpath, path_expr.hir_id)) {\n                 !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n             } else {\n@@ -260,7 +280,7 @@ fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool\n     }\n }\n \n-fn check_attrs(cx: &LateContext, span: Span, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attribute]) {\n     if in_macro(span) {\n         return;\n     }\n@@ -311,7 +331,7 @@ fn check_attrs(cx: &LateContext, span: Span, name: Name, attrs: &[Attribute]) {\n     }\n }\n \n-fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n+fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n     if let LitKind::Str(ref is, _) = lit.node {\n         if Version::parse(&is.as_str()).is_ok() {\n             return;\n@@ -338,7 +358,7 @@ fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {\n // sources that the user has no control over.\n // For some reason these attributes don't have any expansion info on them, so\n // we have to check it this way until there is a better way.\n-fn is_present_in_source(cx: &LateContext, span: Span) -> bool {\n+fn is_present_in_source(cx: &LateContext<'_, '_>, span: Span) -> bool {\n     if let Some(snippet) = snippet_opt(cx, span) {\n         if snippet.is_empty() {\n             return false;"}, {"sha": "249ebbde2f79fcd1ffa8717fb77c4d88017ccbee", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use crate::utils::{span_lint, span_lint_and_then};\n@@ -109,7 +111,7 @@ impl LintPass for BitMask {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n                     check_compare(cx, left, cmp.node, cmp_opt, e.span)\n@@ -119,13 +121,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n             }\n         }\n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref left, ref right) = e.node;\n-            if BinOp_::BiEq == op.node;\n-            if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n-            if BinOp_::BiBitAnd == op1.node;\n-            if let Expr_::ExprLit(ref lit) = right1.node;\n+            if let ExprKind::Binary(ref op, ref left, ref right) = e.node;\n+            if BinOpKind::Eq == op.node;\n+            if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.node;\n+            if BinOpKind::BitAnd == op1.node;\n+            if let ExprKind::Lit(ref lit) = right1.node;\n             if let LitKind::Int(n, _) = lit.node;\n-            if let Expr_::ExprLit(ref lit1) = right.node;\n+            if let ExprKind::Lit(ref lit1) = right.node;\n             if let LitKind::Int(0, _) = lit1.node;\n             if n.leading_zeros() == n.count_zeros();\n             if n > u128::from(self.verbose_bit_mask_threshold);\n@@ -143,22 +145,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n     }\n }\n \n-fn invert_cmp(cmp: BinOp_) -> BinOp_ {\n+fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n     match cmp {\n-        BiEq => BiEq,\n-        BiNe => BiNe,\n-        BiLt => BiGt,\n-        BiGt => BiLt,\n-        BiLe => BiGe,\n-        BiGe => BiLe,\n-        _ => BiOr, // Dummy\n+        BinOpKind::Eq => BinOpKind::Eq,\n+        BinOpKind::Ne => BinOpKind::Ne,\n+        BinOpKind::Lt => BinOpKind::Gt,\n+        BinOpKind::Gt => BinOpKind::Lt,\n+        BinOpKind::Le => BinOpKind::Ge,\n+        BinOpKind::Ge => BinOpKind::Le,\n+        _ => BinOpKind::Or, // Dummy\n     }\n }\n \n \n-fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u128, span: Span) {\n-    if let ExprBinary(ref op, ref left, ref right) = bit_op.node {\n-        if op.node != BiBitAnd && op.node != BiBitOr {\n+fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n+    if let ExprKind::Binary(ref op, ref left, ref right) = bit_op.node {\n+        if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n             return;\n         }\n         fetch_int_literal(cx, right)\n@@ -167,10 +169,10 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u12\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u128, cmp_value: u128, span: Span) {\n+fn check_bit_mask(cx: &LateContext<'_, '_>, bit_op: BinOpKind, cmp_op: BinOpKind, mask_value: u128, cmp_value: u128, span: Span) {\n     match cmp_op {\n-        BiEq | BiNe => match bit_op {\n-            BiBitAnd => if mask_value & cmp_value != cmp_value {\n+        BinOpKind::Eq | BinOpKind::Ne => match bit_op {\n+            BinOpKind::BitAnd => if mask_value & cmp_value != cmp_value {\n                 if cmp_value != 0 {\n                     span_lint(\n                         cx,\n@@ -186,7 +188,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else if mask_value == 0 {\n                 span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n-            BiBitOr => if mask_value | cmp_value != cmp_value {\n+            BinOpKind::BitOr => if mask_value | cmp_value != cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -200,8 +202,8 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             },\n             _ => (),\n         },\n-        BiLt | BiGe => match bit_op {\n-            BiBitAnd => if mask_value < cmp_value {\n+        BinOpKind::Lt | BinOpKind::Ge => match bit_op {\n+            BinOpKind::BitAnd => if mask_value < cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -215,7 +217,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else if mask_value == 0 {\n                 span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n-            BiBitOr => if mask_value >= cmp_value {\n+            BinOpKind::BitOr => if mask_value >= cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -229,11 +231,11 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else {\n                 check_ineffective_lt(cx, span, mask_value, cmp_value, \"|\");\n             },\n-            BiBitXor => check_ineffective_lt(cx, span, mask_value, cmp_value, \"^\"),\n+            BinOpKind::BitXor => check_ineffective_lt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n-        BiLe | BiGt => match bit_op {\n-            BiBitAnd => if mask_value <= cmp_value {\n+        BinOpKind::Le | BinOpKind::Gt => match bit_op {\n+            BinOpKind::BitAnd => if mask_value <= cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -247,7 +249,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else if mask_value == 0 {\n                 span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n-            BiBitOr => if mask_value > cmp_value {\n+            BinOpKind::BitOr => if mask_value > cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -261,14 +263,14 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else {\n                 check_ineffective_gt(cx, span, mask_value, cmp_value, \"|\");\n             },\n-            BiBitXor => check_ineffective_gt(cx, span, mask_value, cmp_value, \"^\"),\n+            BinOpKind::BitXor => check_ineffective_gt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n         _ => (),\n     }\n }\n \n-fn check_ineffective_lt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n+fn check_ineffective_lt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n     if c.is_power_of_two() && m < c {\n         span_lint(\n             cx,\n@@ -284,7 +286,7 @@ fn check_ineffective_lt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n     }\n }\n \n-fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n+fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n         span_lint(\n             cx,\n@@ -300,7 +302,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n     }\n }\n \n-fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n+fn fetch_int_literal(cx: &LateContext<'_, '_>, lit: &Expr) -> Option<u128> {\n     match constant(cx, cx.tables, lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,"}, {"sha": "cfec01d14aed98458942775c2272e9e0c38dceb0", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::span_lint;\n "}, {"sha": "f57a3571b579e7a99dde2f87eaf430ea9116178b", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n+use matches::matches;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::utils::*;\n@@ -56,10 +58,10 @@ struct ExVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let ExprClosure(_, _, eid, _, _) = expr.node {\n+        if let ExprKind::Closure(_, _, eid, _, _) = expr.node {\n             let body = self.cx.tcx.hir.body(eid);\n             let ex = &body.value;\n-            if matches!(ex.node, ExprBlock(_, _)) {\n+            if matches!(ex.node, ExprKind::Block(_, _)) {\n                 self.found_block = Some(ex);\n                 return;\n             }\n@@ -77,8 +79,8 @@ const COMPLEX_BLOCK_MESSAGE: &str = \"in an 'if' condition, avoid complex blocks\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIf(ref check, ref then, _) = expr.node {\n-            if let ExprBlock(ref block, _) = check.node {\n+        if let ExprKind::If(ref check, ref then, _) = expr.node {\n+            if let ExprKind::Block(ref block, _) = check.node {\n                 if block.rules == DefaultBlock {\n                     if block.stmts.is_empty() {\n                         if let Some(ref ex) = block.expr {"}, {"sha": "f1596476bfda012b65063ec430aa1469c6d9caf0", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir::intravisit::*;\n use syntax::ast::{LitKind, NodeId, DUMMY_NODE_ID};\n@@ -84,9 +85,9 @@ struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n }\n \n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n-    fn extract(&mut self, op: BinOp_, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n+    fn extract(&mut self, op: BinOpKind, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n         for a in a {\n-            if let ExprBinary(binop, ref lhs, ref rhs) = a.node {\n+            if let ExprKind::Binary(binop, ref lhs, ref rhs) = a.node {\n                 if binop.node == op {\n                     v = self.extract(op, &[lhs, rhs], v)?;\n                     continue;\n@@ -101,13 +102,13 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         // prevent folding of `cfg!` macros and the like\n         if !in_macro(e.span) {\n             match e.node {\n-                ExprUnary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n-                ExprBinary(binop, ref lhs, ref rhs) => match binop.node {\n-                    BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n-                    BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n+                ExprKind::Unary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprKind::Binary(binop, ref lhs, ref rhs) => match binop.node {\n+                    BinOpKind::Or => return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?)),\n+                    BinOpKind::And => return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?)),\n                     _ => (),\n                 },\n-                ExprLit(ref lit) => match lit.node {\n+                ExprKind::Lit(ref lit) => match lit.node {\n                     LitKind::Bool(true) => return Ok(Bool::True),\n                     LitKind::Bool(false) => return Ok(Bool::False),\n                     _ => (),\n@@ -121,8 +122,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 return Ok(Bool::Term(n as u8));\n             }\n             let negated = match e.node {\n-                ExprBinary(binop, ref lhs, ref rhs) => {\n- \n+                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+\n                     if !implements_ord(self.cx, lhs) {\n                         continue;\n                     }\n@@ -133,16 +134,16 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                             hir_id: DUMMY_HIR_ID,\n                             span: DUMMY_SP,\n                             attrs: ThinVec::new(),\n-                            node: ExprBinary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n+                            node: ExprKind::Binary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n                         }\n                     };\n                     match binop.node {\n-                        BiEq => mk_expr(BiNe),\n-                        BiNe => mk_expr(BiEq),\n-                        BiGt => mk_expr(BiLe),\n-                        BiGe => mk_expr(BiLt),\n-                        BiLt => mk_expr(BiGe),\n-                        BiLe => mk_expr(BiGt),\n+                        BinOpKind::Eq => mk_expr(BinOpKind::Ne),\n+                        BinOpKind::Ne => mk_expr(BinOpKind::Eq),\n+                        BinOpKind::Gt => mk_expr(BinOpKind::Le),\n+                        BinOpKind::Ge => mk_expr(BinOpKind::Lt),\n+                        BinOpKind::Lt => mk_expr(BinOpKind::Ge),\n+                        BinOpKind::Le => mk_expr(BinOpKind::Gt),\n                         _ => continue,\n                     }\n                 },\n@@ -178,23 +179,23 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n \n     fn simplify_not(&self, expr: &Expr) -> Option<String> {\n         match expr.node {\n-            ExprBinary(binop, ref lhs, ref rhs) => {\n+            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n \n                 if !implements_ord(self.cx, lhs) {\n                     return None;\n                 }\n \n                 match binop.node {\n-                    BiEq => Some(\" != \"),\n-                    BiNe => Some(\" == \"),\n-                    BiLt => Some(\" >= \"),\n-                    BiGt => Some(\" <= \"),\n-                    BiLe => Some(\" > \"),\n-                    BiGe => Some(\" < \"),\n+                    BinOpKind::Eq => Some(\" != \"),\n+                    BinOpKind::Ne => Some(\" == \"),\n+                    BinOpKind::Lt => Some(\" >= \"),\n+                    BinOpKind::Gt => Some(\" <= \"),\n+                    BinOpKind::Le => Some(\" > \"),\n+                    BinOpKind::Ge => Some(\" < \"),\n                     _ => None,\n                 }.and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n             },\n-            ExprMethodCall(ref path, _, ref args) if args.len() == 1 => {\n+            ExprKind::MethodCall(ref path, _, ref args) if args.len() == 1 => {\n                 let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n                 if !match_type(self.cx, type_of_receiver, &paths::OPTION) &&\n                     !match_type(self.cx, type_of_receiver, &paths::RESULT) {\n@@ -274,7 +275,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n }\n \n // The boolean part of the return indicates whether some simplifications have been applied.\n-fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n+fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n     let mut suggest_context = SuggestContext {\n         terminals,\n         cx,\n@@ -441,8 +442,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n             return;\n         }\n         match e.node {\n-            ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n-            ExprUnary(UnNot, ref inner) => if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n+            ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => self.bool_expr(e),\n+            ExprKind::Unary(UnNot, ref inner) => if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n                 self.bool_expr(e);\n             } else {\n                 walk_expr(self, e);"}, {"sha": "2d4279d3cc19d0dccc0bcb908ed40c1f5846f30d", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use syntax::ast::{Name, UintTy};\n use crate::utils::{contains_name, get_pat_name, match_type, paths, single_segment_path, snippet, span_lint_and_sugg,\n@@ -36,22 +38,22 @@ impl LintPass for ByteCount {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n-            if let ExprMethodCall(ref count, _, ref count_args) = expr.node;\n+            if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.node;\n             if count.ident.name == \"count\";\n             if count_args.len() == 1;\n-            if let ExprMethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n+            if let ExprKind::MethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n             if filter.ident.name == \"filter\";\n             if filter_args.len() == 2;\n-            if let ExprClosure(_, _, body_id, _, _) = filter_args[1].node;\n+            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].node;\n             then {\n                 let body = cx.tcx.hir.body(body_id);\n                 if_chain! {\n                     if body.arguments.len() == 1;\n                     if let Some(argname) = get_pat_name(&body.arguments[0].pat);\n-                    if let ExprBinary(ref op, ref l, ref r) = body.value.node;\n-                    if op.node == BiEq;\n+                    if let ExprKind::Binary(ref op, ref l, ref r) = body.value.node;\n+                    if op.node == BinOpKind::Eq;\n                     if match_type(cx,\n                                walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n                                &paths::SLICE_ITER);\n@@ -66,7 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                         if ty::TyUint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n                             return;\n                         }\n-                        let haystack = if let ExprMethodCall(ref path, _, ref args) =\n+                        let haystack = if let ExprKind::MethodCall(ref path, _, ref args) =\n                                 filter_args[0].node {\n                             let p = path.ident.name;\n                             if (p == \"iter\" || p == \"iter_mut\") && args.len() == 1 {\n@@ -98,13 +100,13 @@ fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n \n fn get_path_name(expr: &Expr) -> Option<Name> {\n     match expr.node {\n-        ExprBox(ref e) | ExprAddrOf(_, ref e) | ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n-        ExprBlock(ref b, _) => if b.stmts.is_empty() {\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) | ExprKind::Unary(UnOp::UnDeref, ref e) => get_path_name(e),\n+        ExprKind::Block(ref b, _) => if b.stmts.is_empty() {\n             b.expr.as_ref().and_then(|p| get_path_name(p))\n         } else {\n             None\n         },\n-        ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n+        ExprKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n         _ => None,\n     }\n }"}, {"sha": "2771006aad3b40652dae6e7f4bd8ae932e628661", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -13,6 +13,8 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast;\n \n use crate::utils::{in_macro, snippet_block, span_lint_and_sugg, span_lint_and_then};\n@@ -78,14 +80,14 @@ impl LintPass for CollapsibleIf {\n }\n \n impl EarlyLintPass for CollapsibleIf {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if !in_macro(expr.span) {\n             check_if(cx, expr)\n         }\n     }\n }\n \n-fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     match expr.node {\n         ast::ExprKind::If(ref check, ref then, ref else_) => if let Some(ref else_) = *else_ {\n             check_collapsible_maybe_if_let(cx, else_);\n@@ -99,7 +101,7 @@ fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n     }\n }\n \n-fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n+fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::Block(ref block, _) = else_.node;\n         if let Some(else_) = expr_block(block);\n@@ -120,7 +122,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n     }\n }\n \n-fn check_collapsible_no_if_let(cx: &EarlyContext, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n+fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n     if_chain! {\n         if let Some(inner) = expr_block(then);\n         if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;"}, {"sha": "1af0741d67fb193973465e0743ced0b7406be611", "filename": "clippy_lints/src/const_static_lifetime.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,6 @@\n use syntax::ast::*;\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use crate::utils::{in_macro, snippet, span_lint_and_then};\n \n /// **What it does:** Checks for constants with an explicit `'static` lifetime.\n@@ -34,7 +35,7 @@ impl LintPass for StaticConst {\n \n impl StaticConst {\n     // Recursively visit types\n-    fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext) {\n+    fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext<'_>) {\n         match ty.node {\n             // Be careful of nested structures (arrays and tuples)\n             TyKind::Array(ref ty, _) => {\n@@ -78,7 +79,7 @@ impl StaticConst {\n }\n \n impl EarlyLintPass for StaticConst {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if !in_macro(item.span) {\n             // Match only constants...\n             if let ItemKind::Const(ref var_type, _) = item.node {"}, {"sha": "84167553a54cd7d302c48f615e02cdc82791162e", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,7 @@\n #![allow(float_cmp)]\n \n use rustc::lint::LateContext;\n+use rustc::{span_bug, bug};\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n@@ -13,7 +14,6 @@ use std::mem;\n use std::rc::Rc;\n use syntax::ast::{FloatTy, LitKind};\n use syntax::ptr::P;\n-use rustc::middle::const_val::ConstVal;\n use crate::utils::{sext, unsext, clip};\n \n #[derive(Debug, Copy, Clone)]\n@@ -123,7 +123,7 @@ impl Hash for Constant {\n }\n \n impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt, cmp_type: &ty::TypeVariants, left: &Self, right: &Self) -> Option<Ordering> {\n+    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: &ty::TypeVariants<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n             (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n@@ -212,31 +212,31 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// simple constant folding: Insert an expression, get a constant or none.\n     pub fn expr(&mut self, e: &Expr) -> Option<Constant> {\n         match e.node {\n-            ExprPath(ref qpath) => self.fetch_path(qpath, e.hir_id),\n-            ExprBlock(ref block, _) => self.block(block),\n-            ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n-            ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty(e))),\n-            ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n-            ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprRepeat(ref value, _) => {\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id),\n+            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty(e))),\n+            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(ref value, _) => {\n                 let n = match self.tables.expr_ty(e).sty {\n                     ty::TyArray(_, n) => n.assert_usize(self.tcx).expect(\"array length\"),\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n as u64))\n             },\n-            ExprUnary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n                 UnNot => self.constant_not(&o, self.tables.expr_ty(e)),\n                 UnNeg => self.constant_negate(&o, self.tables.expr_ty(e)),\n                 UnDeref => Some(o),\n             }),\n-            ExprBinary(op, ref left, ref right) => self.binop(op, left, right),\n+            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n             // TODO: add other expressions\n             _ => None,\n         }\n     }\n \n-    fn constant_not(&self, o: &Constant, ty: ty::Ty) -> Option<Constant> {\n+    fn constant_not(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Bool(b) => Some(Bool(!b)),\n@@ -252,7 +252,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn constant_negate(&self, o: &Constant, ty: ty::Ty) -> Option<Constant> {\n+    fn constant_negate(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Int(value) => {\n@@ -280,7 +280,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             .collect::<Option<_>>()\n     }\n \n-    /// lookup a possibly constant expression from a ExprPath\n+    /// lookup a possibly constant expression from a ExprKind::Path\n     fn fetch_path(&mut self, qpath: &QPath, id: HirId) -> Option<Constant> {\n         let def = self.tables.qpath_def(qpath, id);\n         match def {\n@@ -341,84 +341,84 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                         let r = sext(self.tcx, r, ity);\n                         let zext = |n: i128| Constant::Int(unsext(self.tcx, n, ity));\n                         match op.node {\n-                            BiAdd => l.checked_add(r).map(zext),\n-                            BiSub => l.checked_sub(r).map(zext),\n-                            BiMul => l.checked_mul(r).map(zext),\n-                            BiDiv if r != 0 => l.checked_div(r).map(zext),\n-                            BiRem if r != 0 => l.checked_rem(r).map(zext),\n-                            BiShr => l.checked_shr(r as u128 as u32).map(zext),\n-                            BiShl => l.checked_shl(r as u128 as u32).map(zext),\n-                            BiBitXor => Some(zext(l ^ r)),\n-                            BiBitOr => Some(zext(l | r)),\n-                            BiBitAnd => Some(zext(l & r)),\n-                            BiEq => Some(Constant::Bool(l == r)),\n-                            BiNe => Some(Constant::Bool(l != r)),\n-                            BiLt => Some(Constant::Bool(l < r)),\n-                            BiLe => Some(Constant::Bool(l <= r)),\n-                            BiGe => Some(Constant::Bool(l >= r)),\n-                            BiGt => Some(Constant::Bool(l > r)),\n+                            BinOpKind::Add => l.checked_add(r).map(zext),\n+                            BinOpKind::Sub => l.checked_sub(r).map(zext),\n+                            BinOpKind::Mul => l.checked_mul(r).map(zext),\n+                            BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n+                            BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n+                            BinOpKind::Shr => l.checked_shr(r as u128 as u32).map(zext),\n+                            BinOpKind::Shl => l.checked_shl(r as u128 as u32).map(zext),\n+                            BinOpKind::BitXor => Some(zext(l ^ r)),\n+                            BinOpKind::BitOr => Some(zext(l | r)),\n+                            BinOpKind::BitAnd => Some(zext(l & r)),\n+                            BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                            BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                            BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                            BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                            BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                            BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                             _ => None,\n                         }\n                     }\n                     ty::TyUint(_) => {\n                         match op.node {\n-                            BiAdd => l.checked_add(r).map(Constant::Int),\n-                            BiSub => l.checked_sub(r).map(Constant::Int),\n-                            BiMul => l.checked_mul(r).map(Constant::Int),\n-                            BiDiv => l.checked_div(r).map(Constant::Int),\n-                            BiRem => l.checked_rem(r).map(Constant::Int),\n-                            BiShr => l.checked_shr(r as u32).map(Constant::Int),\n-                            BiShl => l.checked_shl(r as u32).map(Constant::Int),\n-                            BiBitXor => Some(Constant::Int(l ^ r)),\n-                            BiBitOr => Some(Constant::Int(l | r)),\n-                            BiBitAnd => Some(Constant::Int(l & r)),\n-                            BiEq => Some(Constant::Bool(l == r)),\n-                            BiNe => Some(Constant::Bool(l != r)),\n-                            BiLt => Some(Constant::Bool(l < r)),\n-                            BiLe => Some(Constant::Bool(l <= r)),\n-                            BiGe => Some(Constant::Bool(l >= r)),\n-                            BiGt => Some(Constant::Bool(l > r)),\n+                            BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n+                            BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n+                            BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n+                            BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n+                            BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n+                            BinOpKind::Shr => l.checked_shr(r as u32).map(Constant::Int),\n+                            BinOpKind::Shl => l.checked_shl(r as u32).map(Constant::Int),\n+                            BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n+                            BinOpKind::BitOr => Some(Constant::Int(l | r)),\n+                            BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n+                            BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                            BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                            BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                            BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                            BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                            BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                             _ => None,\n                         }\n                     },\n                     _ => None,\n                 }\n             },\n             (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n-                BiAdd => Some(Constant::F32(l + r)),\n-                BiSub => Some(Constant::F32(l - r)),\n-                BiMul => Some(Constant::F32(l * r)),\n-                BiDiv => Some(Constant::F32(l / r)),\n-                BiRem => Some(Constant::F32(l % r)),\n-                BiEq => Some(Constant::Bool(l == r)),\n-                BiNe => Some(Constant::Bool(l != r)),\n-                BiLt => Some(Constant::Bool(l < r)),\n-                BiLe => Some(Constant::Bool(l <= r)),\n-                BiGe => Some(Constant::Bool(l >= r)),\n-                BiGt => Some(Constant::Bool(l > r)),\n+                BinOpKind::Add => Some(Constant::F32(l + r)),\n+                BinOpKind::Sub => Some(Constant::F32(l - r)),\n+                BinOpKind::Mul => Some(Constant::F32(l * r)),\n+                BinOpKind::Div => Some(Constant::F32(l / r)),\n+                BinOpKind::Rem => Some(Constant::F32(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                 _ => None,\n             },\n             (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n-                BiAdd => Some(Constant::F64(l + r)),\n-                BiSub => Some(Constant::F64(l - r)),\n-                BiMul => Some(Constant::F64(l * r)),\n-                BiDiv => Some(Constant::F64(l / r)),\n-                BiRem => Some(Constant::F64(l % r)),\n-                BiEq => Some(Constant::Bool(l == r)),\n-                BiNe => Some(Constant::Bool(l != r)),\n-                BiLt => Some(Constant::Bool(l < r)),\n-                BiLe => Some(Constant::Bool(l <= r)),\n-                BiGe => Some(Constant::Bool(l >= r)),\n-                BiGt => Some(Constant::Bool(l > r)),\n+                BinOpKind::Add => Some(Constant::F64(l + r)),\n+                BinOpKind::Sub => Some(Constant::F64(l - r)),\n+                BinOpKind::Mul => Some(Constant::F64(l * r)),\n+                BinOpKind::Div => Some(Constant::F64(l / r)),\n+                BinOpKind::Rem => Some(Constant::F64(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                 _ => None,\n             },\n             (l, r) => match (op.node, l, r) {\n-                (BiAnd, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n-                (BiOr, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n-                (BiAnd, Constant::Bool(true), Some(r)) | (BiOr, Constant::Bool(false), Some(r)) => Some(r),\n-                (BiBitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n-                (BiBitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n-                (BiBitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n+                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n+                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n+                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => Some(r),\n+                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n+                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n+                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n                 _ => None,\n             },\n         }\n@@ -428,15 +428,15 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n pub fn miri_to_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, result: &ty::Const<'tcx>) -> Option<Constant> {\n     use rustc::mir::interpret::{Scalar, ConstValue};\n     match result.val {\n-        ConstVal::Value(ConstValue::Scalar(Scalar::Bits{ bits: b, ..})) => match result.ty.sty {\n+        ConstValue::Scalar(Scalar::Bits{ bits: b, ..}) => match result.ty.sty {\n             ty::TyBool => Some(Constant::Bool(b == 1)),\n             ty::TyUint(_) | ty::TyInt(_) => Some(Constant::Int(b)),\n             ty::TyFloat(FloatTy::F32) => Some(Constant::F32(f32::from_bits(b as u32))),\n             ty::TyFloat(FloatTy::F64) => Some(Constant::F64(f64::from_bits(b as u64))),\n             // FIXME: implement other conversion\n             _ => None,\n         },\n-        ConstVal::Value(ConstValue::ScalarPair(Scalar::Ptr(ptr), Scalar::Bits { bits: n, .. })) => match result.ty.sty {\n+        ConstValue::ScalarPair(Scalar::Ptr(ptr), Scalar::Bits { bits: n, .. }) => match result.ty.sty {\n             ty::TyRef(_, tam, _) => match tam.sty {\n                 ty::TyStr => {\n                     let alloc = tcx"}, {"sha": "5709526c6007e2c5ae85d9a3ffd74c8ef0b9ca7d", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty::Ty;\n use rustc::hir::*;\n use std::collections::HashMap;\n@@ -115,7 +116,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n         if !in_macro(expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(&Expr {\n-                node: ExprIf(_, _, Some(ref else_expr)),\n+                node: ExprKind::If(_, _, Some(ref else_expr)),\n                 ..\n             }) = get_parent_expr(cx, expr)\n             {\n@@ -133,7 +134,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n }\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n+fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block]) {\n     let eq: &dyn Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n \n     if let Some((i, j)) = search_same_sequenced(blocks, eq) {\n@@ -149,7 +150,7 @@ fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n }\n \n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n+fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr]) {\n     let hash: &dyn Fn(&&Expr) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx, cx.tables);\n         h.hash_expr(expr);\n@@ -171,8 +172,8 @@ fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n }\n \n /// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n-    if let ExprMatch(_, ref arms, MatchSource::Normal) = expr.node {\n+fn lint_match_arms(cx: &LateContext<'_, '_>, expr: &Expr) {\n+    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.node {\n         let hash = |&(_, arm): &(usize, &Arm)| -> u64 {\n             let mut h = SpanlessHash::new(cx, cx.tables);\n             h.hash_expr(&arm.body);\n@@ -236,12 +237,12 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n     let mut conds = SmallVector::new();\n     let mut blocks: SmallVector<&Block> = SmallVector::new();\n \n-    while let ExprIf(ref cond, ref then_expr, ref else_expr) = expr.node {\n+    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.node {\n         conds.push(&**cond);\n-        if let ExprBlock(ref block, _) = then_expr.node {\n+        if let ExprKind::Block(ref block, _) = then_expr.node {\n             blocks.push(block);\n         } else {\n-            panic!(\"ExprIf node is not an ExprBlock\");\n+            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n         if let Some(ref else_expr) = *else_expr {\n@@ -253,7 +254,7 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n \n     // final `else {..}`\n     if !blocks.is_empty() {\n-        if let ExprBlock(ref block, _) = expr.node {\n+        if let ExprKind::Block(ref block, _) = expr.node {\n             blocks.push(&**block);\n         }\n     }"}, {"sha": "d66e6f2849bb694efee3567102051603c37e3afa", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::cfg::CFG;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n@@ -147,14 +148,14 @@ struct CCHelper<'a, 'tcx: 'a> {\n impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprMatch(_, ref arms, _) => {\n+            ExprKind::Match(_, ref arms, _) => {\n                 walk_expr(self, e);\n                 let arms_n: u64 = arms.iter().map(|arm| arm.pats.len() as u64).sum();\n                 if arms_n > 1 {\n                     self.match_arms += arms_n - 2;\n                 }\n             },\n-            ExprCall(ref callee, _) => {\n+            ExprKind::Call(ref callee, _) => {\n                 walk_expr(self, e);\n                 let ty = self.cx.tables.node_id_to_type(callee.hir_id);\n                 match ty.sty {\n@@ -167,15 +168,15 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n                     _ => (),\n                 }\n             },\n-            ExprClosure(.., _) => (),\n-            ExprBinary(op, _, _) => {\n+            ExprKind::Closure(.., _) => (),\n+            ExprKind::Binary(op, _, _) => {\n                 walk_expr(self, e);\n                 match op.node {\n-                    BiAnd | BiOr => self.short_circuits += 1,\n+                    BinOpKind::And | BinOpKind::Or => self.short_circuits += 1,\n                     _ => (),\n                 }\n             },\n-            ExprRet(_) => self.returns += 1,\n+            ExprKind::Ret(_) => self.returns += 1,\n             _ => walk_expr(self, e),\n         }\n     }\n@@ -186,7 +187,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n \n #[cfg(feature = \"debugging\")]\n #[allow(too_many_arguments)]\n-fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, _: NodeId) {\n+fn report_cc_bug(_: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, _: NodeId) {\n     span_bug!(\n         span,\n         \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n@@ -200,7 +201,7 @@ fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, re\n }\n #[cfg(not(feature = \"debugging\"))]\n #[allow(too_many_arguments)]\n-fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, id: NodeId) {\n+fn report_cc_bug(cx: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, id: NodeId) {\n     if !is_allowed(cx, CYCLOMATIC_COMPLEXITY, id) {\n         cx.sess().span_note_without_error(\n             span,"}, {"sha": "4078237e8aa8453ac9f1d65907d5e8fe8f207a80", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::TypeVariants;\n \n use crate::utils::{any_parent_is_automatically_derived, match_def_path, opt_def_id, paths, span_lint_and_sugg};\n@@ -38,9 +40,9 @@ impl LintPass for DefaultTraitAccess {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ..) = expr.node;\n+            if let ExprKind::Call(ref path, ..) = expr.node;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.id);\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {"}, {"sha": "0689ef25c20715c0fbb8179c05efb6a1070afe94", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use syntax::codemap::Span;\n@@ -70,7 +72,7 @@ impl LintPass for Derive {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n             let ty = cx.tcx.type_of(cx.tcx.hir.local_def_id(item.id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n "}, {"sha": "2b11e8fa77d4d6c399d7c92e1cfba61bf2d96234", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n use itertools::Itertools;\n use pulldown_cmark;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast;\n use syntax::codemap::{BytePos, Span};\n use syntax_pos::Pos;\n@@ -51,11 +52,11 @@ impl LintPass for Doc {\n }\n \n impl EarlyLintPass for Doc {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &ast::Crate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &ast::Crate) {\n         check_attrs(cx, &self.valid_idents, &krate.attrs);\n     }\n \n-    fn check_item(&mut self, cx: &EarlyContext, item: &ast::Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         check_attrs(cx, &self.valid_idents, &item.attrs);\n     }\n }\n@@ -138,7 +139,7 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n     panic!(\"not a doc-comment: {}\", comment);\n }\n \n-pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n+pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n     let mut doc = String::new();\n     let mut spans = vec![];\n \n@@ -185,7 +186,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n }\n \n fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n-    cx: &EarlyContext,\n+    cx: &EarlyContext<'_>,\n     valid_idents: &[String],\n     docs: Events,\n     spans: &[(usize, Span)],\n@@ -231,7 +232,7 @@ fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n     }\n }\n \n-fn check_text(cx: &EarlyContext, valid_idents: &[String], text: &str, span: Span) {\n+fn check_text(cx: &EarlyContext<'_>, valid_idents: &[String], text: &str, span: Span) {\n     for word in text.split_whitespace() {\n         // Trim punctuation as in `some comment (see foo::bar).`\n         //                                                   ^^\n@@ -254,7 +255,7 @@ fn check_text(cx: &EarlyContext, valid_idents: &[String], text: &str, span: Span\n     }\n }\n \n-fn check_word(cx: &EarlyContext, word: &str, span: Span) {\n+fn check_word(cx: &EarlyContext<'_>, word: &str, span: Span) {\n     /// Checks if a string is camel-case, ie. contains at least two uppercase\n     /// letter (`Clippy` is\n     /// ok) and one lower-case letter (`NASA` is ok). Plural are also excluded"}, {"sha": "434ccb69921e7d916275350c8019706b3a076dcc", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n \n use crate::utils::{snippet, span_lint_and_sugg, SpanlessEq};\n@@ -41,13 +42,13 @@ impl<'a, 'tcx> DoubleComparisonPass {\n     fn check_binop(\n         &self,\n         cx: &LateContext<'a, 'tcx>,\n-        op: BinOp_,\n+        op: BinOpKind,\n         lhs: &'tcx Expr,\n         rhs: &'tcx Expr,\n         span: Span,\n     ) {\n         let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (lhs.node.clone(), rhs.node.clone()) {\n-            (ExprBinary(lb, llhs, lrhs), ExprBinary(rb, rlhs, rrhs)) => {\n+            (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n             }\n             _ => return,\n@@ -67,18 +68,18 @@ impl<'a, 'tcx> DoubleComparisonPass {\n             }}\n         }\n         match (op, lkind, rkind) {\n-            (BiOr, BiEq, BiLt) | (BiOr, BiLt, BiEq) => lint_double_comparison!(<=),\n-            (BiOr, BiEq, BiGt) | (BiOr, BiGt, BiEq) => lint_double_comparison!(>=),\n-            (BiOr, BiLt, BiGt) | (BiOr, BiGt, BiLt) => lint_double_comparison!(!=),\n-            (BiAnd, BiLe, BiGe) | (BiAnd, BiGe, BiLe) => lint_double_comparison!(==),\n+            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => lint_double_comparison!(<=),\n+            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => lint_double_comparison!(>=),\n+            (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => lint_double_comparison!(!=),\n+            (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => lint_double_comparison!(==),\n             _ => (),\n         };\n     }\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisonPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref kind, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.node {\n             self.check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }\n     }"}, {"sha": "abd5666385d029dbc710eaffb8e3f092842b6710", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,6 @@\n use syntax::ast::*;\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n+use rustc::{declare_lint, lint_array};\n \n /// **What it does:** Checks for unnecessary double parentheses.\n ///\n@@ -30,7 +31,7 @@ impl LintPass for DoubleParens {\n }\n \n impl EarlyLintPass for DoubleParens {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         match expr.node {\n             ExprKind::Paren(ref in_paren) => match in_paren.node {\n                 ExprKind::Paren(_) | ExprKind::Tup(_) => {"}, {"sha": "071afde986ad191b90ade8b1a5c4030d9652209e", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use rustc::hir::*;\n use crate::utils::{is_copy, match_def_path, opt_def_id, paths, span_note_and_lint};\n@@ -116,8 +118,8 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Call(ref path, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 1;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             then {"}, {"sha": "517befa7790f9011a735076d6b8422fa839c2c0d", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::codemap::Spanned;\n \n use crate::consts::{constant, Constant};\n@@ -38,8 +40,8 @@ impl LintPass for DurationSubsec {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprBinary(Spanned { node: BiDiv, .. }, ref left, ref right) = expr.node;\n-            if let ExprMethodCall(ref method_path, _ , ref args) = left.node;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.node;\n+            if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.node;\n             if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n             then {"}, {"sha": "39404bbafcca7cc53c608a6304da04ce3d70f8c1", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,9 +1,10 @@\n //! lint on if expressions with an else if, but without a final else branch\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n \n-use crate::utils::{in_external_macro, span_lint_and_sugg};\n+use crate::utils::span_lint_and_sugg;\n \n /// **What it does:** Checks for usage of if expressions with an `else if` branch,\n /// but without a final `else` branch.\n@@ -48,8 +49,8 @@ impl LintPass for ElseIfWithoutElse {\n }\n \n impl EarlyLintPass for ElseIfWithoutElse {\n-    fn check_expr(&mut self, cx: &EarlyContext, mut item: &Expr) {\n-        if in_external_macro(cx, item.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, mut item: &Expr) {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n "}, {"sha": "f95ae32d5611d87dfc9b24f8b0fe08f9a2a7b771", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n //! lint when there is an enum with no variants\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::span_lint_and_then;\n \n@@ -32,9 +33,9 @@ impl LintPass for EmptyEnum {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n         let did = cx.tcx.hir.local_def_id(item.id);\n-        if let ItemEnum(..) = item.node {\n+        if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def()\n                 .expect(\"already checked whether this is an enum\");"}, {"sha": "26ee6be5796ba1a4f3bc4916b414613c4faad732", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,8 @@\n use rustc::hir::*;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::codemap::Span;\n use crate::utils::SpanlessEq;\n use crate::utils::{get_item_name, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty};\n@@ -41,13 +43,13 @@ impl LintPass for HashMapLint {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIf(ref check, ref then_block, ref else_block) = expr.node {\n-            if let ExprUnary(UnOp::UnNot, ref check) = check.node {\n+        if let ExprKind::If(ref check, ref then_block, ref else_block) = expr.node {\n+            if let ExprKind::Unary(UnOp::UnNot, ref check) = check.node {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = {\n-                        else_block.is_none() && if let ExprBlock(ref then_block, _) = then_block.node {\n+                        else_block.is_none() && if let ExprKind::Block(ref then_block, _) = then_block.node {\n                             (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n                         } else {\n                             true\n@@ -88,10 +90,10 @@ fn check_cond<'a, 'tcx, 'b>(\n     check: &'b Expr,\n ) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n     if_chain! {\n-        if let ExprMethodCall(ref path, _, ref params) = check.node;\n+        if let ExprKind::MethodCall(ref path, _, ref params) = check.node;\n         if params.len() >= 2;\n         if path.ident.name == \"contains_key\";\n-        if let ExprAddrOf(_, ref key) = params[1].node;\n+        if let ExprKind::AddrOf(_, ref key) = params[1].node;\n         then {\n             let map = &params[0];\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n@@ -123,7 +125,7 @@ struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprMethodCall(ref path, _, ref params) = expr.node;\n+            if let ExprKind::MethodCall(ref path, _, ref params) = expr.node;\n             if params.len() == 3;\n             if path.ident.name == \"insert\";\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);"}, {"sha": "62cbead192907d9719f75defc0b99a07348adf1c", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,7 @@\n //! don't fit into an `i32`\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::ty::subst::Substs;\n@@ -47,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n         if cx.tcx.data_layout.pointer_size.bits() != 64 {\n             return;\n         }\n-        if let ItemEnum(ref def, _) = item.node {\n+        if let ItemKind::Enum(ref def, _) = item.node {\n             for var in &def.variants {\n                 let variant = &var.node;\n                 if let Some(ref anon_const) = variant.disr_expr {"}, {"sha": "6f8afc710de66173be773dc2099cb2c4e7692403", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,7 @@\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use crate::utils::span_lint;\n@@ -43,11 +44,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n }\n \n impl EnumGlobUse {\n-    fn lint_item(&self, cx: &LateContext, item: &Item) {\n-        if item.vis == Visibility::Public {\n+    fn lint_item(&self, cx: &LateContext<'_, '_>, item: &Item) {\n+        if item.vis.node.is_pub() {\n             return; // re-exports are fine\n         }\n-        if let ItemUse(ref path, UseKind::Glob) = item.node {\n+        if let ItemKind::Use(ref path, UseKind::Glob) = item.node {\n             if let Def::Enum(_) = path.def {\n                 span_lint(\n                     cx,"}, {"sha": "16c9212e5db86b344402feeb36a9d5abd831ce31", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n //! lint on enum variants that are prefixed or suffixed by the same characters\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::symbol::LocalInternedString;\n@@ -148,7 +149,7 @@ fn partial_rmatch(post: &str, name: &str) -> usize {\n // FIXME: #600\n #[allow(while_let_on_iterator)]\n fn check_variant(\n-    cx: &EarlyContext,\n+    cx: &EarlyContext<'_>,\n     threshold: u64,\n     def: &EnumDef,\n     item_name: &str,\n@@ -239,12 +240,12 @@ fn to_camel_case(item_name: &str) -> String {\n }\n \n impl EarlyLintPass for EnumVariantNames {\n-    fn check_item_post(&mut self, _cx: &EarlyContext, _item: &Item) {\n+    fn check_item_post(&mut self, _cx: &EarlyContext<'_>, _item: &Item) {\n         let last = self.modules.pop();\n         assert!(last.is_some());\n     }\n \n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         let item_name = item.ident.as_str();\n         let item_name_chars = item_name.chars().count();\n         let item_camel = to_camel_case(&item_name);\n@@ -262,7 +263,7 @@ impl EarlyLintPass for EnumVariantNames {\n                             );\n                         }\n                     }\n-                    if item.vis.node == VisibilityKind::Public {\n+                    if item.vis.node.is_pub() {\n                         let matching = partial_match(mod_camel, &item_camel);\n                         let rmatching = partial_rmatch(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();"}, {"sha": "dfbc3b126336eb136ed8f867bd4b2758921dad29", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use crate::utils::{in_macro, implements_trait, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq};\n \n /// **What it does:** Checks for equal operands to comparison, logical and\n@@ -52,7 +53,7 @@ impl LintPass for EqOp {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(op, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(op, ref left, ref right) = e.node {\n             if in_macro(e.span) {\n                 return;\n             }\n@@ -66,28 +67,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                 return;\n             }\n             let (trait_id, requires_ref) = match op.node {\n-                BiAdd => (cx.tcx.lang_items().add_trait(), false),\n-                BiSub => (cx.tcx.lang_items().sub_trait(), false),\n-                BiMul => (cx.tcx.lang_items().mul_trait(), false),\n-                BiDiv => (cx.tcx.lang_items().div_trait(), false),\n-                BiRem => (cx.tcx.lang_items().rem_trait(), false),\n+                BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n+                BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n+                BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n+                BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n+                BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n                 // don't lint short circuiting ops\n-                BiAnd | BiOr => return,\n-                BiBitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n-                BiBitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n-                BiBitOr => (cx.tcx.lang_items().bitor_trait(), false),\n-                BiShl => (cx.tcx.lang_items().shl_trait(), false),\n-                BiShr => (cx.tcx.lang_items().shr_trait(), false),\n-                BiNe | BiEq => (cx.tcx.lang_items().eq_trait(), true),\n-                BiLt | BiLe | BiGe | BiGt => (cx.tcx.lang_items().ord_trait(), true),\n+                BinOpKind::And | BinOpKind::Or => return,\n+                BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n+                BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n+                BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n+                BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n+                BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n+                BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n+                BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => (cx.tcx.lang_items().ord_trait(), true),\n             };\n             if let Some(trait_id) = trait_id {\n                 #[allow(match_same_arms)]\n                 match (&left.node, &right.node) {\n                     // do not suggest to dereference literals\n-                    (&ExprLit(..), _) | (_, &ExprLit(..)) => {},\n+                    (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar\n-                    (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n+                    (&ExprKind::AddrOf(_, ref l), &ExprKind::AddrOf(_, ref r)) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let rty = cx.tables.expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n@@ -128,7 +129,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                         }\n                     },\n                     // &foo == bar\n-                    (&ExprAddrOf(_, ref l), _) => {\n+                    (&ExprKind::AddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy) && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()]) {\n@@ -139,7 +140,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                         }\n                     },\n                     // foo == &bar\n-                    (_, &ExprAddrOf(_, ref r)) => {\n+                    (_, &ExprKind::AddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy) && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()]) {\n@@ -159,7 +160,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n \n fn is_valid_operator(op: BinOp) -> bool {\n     match op.node {\n-        BiSub | BiDiv | BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr => true,\n+        BinOpKind::Sub | BinOpKind::Div | BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Gt | BinOpKind::Ge | BinOpKind::Ne | BinOpKind::And | BinOpKind::Or | BinOpKind::BitXor | BinOpKind::BitAnd | BinOpKind::BitOr => true,\n         _ => false,\n     }\n }"}, {"sha": "4960a48b3c880c804e0f6a46dda160abebdf849b", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n use crate::consts::{constant_simple, Constant};\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n use crate::utils::{in_macro, span_lint};\n \n@@ -36,20 +37,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n-                BiMul | BiBitAnd => {\n+                BinOpKind::Mul | BinOpKind::BitAnd => {\n                     check(cx, left, e.span);\n                     check(cx, right, e.span);\n                 },\n-                BiDiv => check(cx, left, e.span),\n+                BinOpKind::Div => check(cx, left, e.span),\n                 _ => (),\n             }\n         }\n     }\n }\n \n-fn check(cx: &LateContext, e: &Expr, span: Span) {\n+fn check(cx: &LateContext<'_, '_>, e: &Expr, span: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         if v == 0 {\n             span_lint("}, {"sha": "ebbc2c34811b51e34c68697174733f7556da5c0b", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,7 @@ use rustc::hir::*;\n use rustc::hir::intravisit as visit;\n use rustc::hir::map::Node::{NodeExpr, NodeStmt};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt_, Categorization};\n use rustc::ty::{self, Ty};\n@@ -38,7 +39,7 @@ declare_clippy_lint! {\n     \"using `Box<T>` where unnecessary\"\n }\n \n-fn is_non_trait_box(ty: Ty) -> bool {\n+fn is_non_trait_box(ty: Ty<'_>) -> bool {\n     ty.is_box() && !ty.boxed_ty().is_trait()\n }\n \n@@ -108,11 +109,12 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             return;\n         }\n         if let Categorization::Rvalue(..) = cmt.cat {\n-            if let Some(NodeStmt(st)) = map.find(map.get_parent_node(cmt.id)) {\n-                if let StmtDecl(ref decl, _) = st.node {\n-                    if let DeclLocal(ref loc) = decl.node {\n+            let id = map.hir_to_node_id(cmt.hir_id);\n+            if let Some(NodeStmt(st)) = map.find(map.get_parent_node(id)) {\n+                if let StmtKind::Decl(ref decl, _) = st.node {\n+                    if let DeclKind::Local(ref loc) = decl.node {\n                         if let Some(ref ex) = loc.init {\n-                            if let ExprBox(..) = ex.node {\n+                            if let ExprKind::Box(..) = ex.node {\n                                 if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n                                     // let x = box (...)\n                                     self.set.insert(consume_pat.id);\n@@ -135,7 +137,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             }\n         }\n     }\n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, _: ty::BorrowKind, loan_cause: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, _: ty::BorrowKind, loan_cause: LoanCause) {\n         if let Categorization::Local(lid) = cmt.cat {\n             match loan_cause {\n                 // x.foo()"}, {"sha": "2071628a6cfeef18ee4bba432f26ad9b85fa95d3", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use rustc::hir::*;\n use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then};\n@@ -37,19 +38,19 @@ impl LintPass for EtaPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n-            ExprCall(_, ref args) | ExprMethodCall(_, _, ref args) => for arg in args {\n+            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => for arg in args {\n                 check_closure(cx, arg)\n             },\n             _ => (),\n         }\n     }\n }\n \n-fn check_closure(cx: &LateContext, expr: &Expr) {\n-    if let ExprClosure(_, ref decl, eid, _, _) = expr.node {\n+fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n+    if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n         let body = cx.tcx.hir.body(eid);\n         let ex = &body.value;\n-        if let ExprCall(ref caller, ref args) = ex.node {\n+        if let ExprKind::Call(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there\n                 // is no way the closure is the same as the function\n@@ -73,7 +74,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n             for (a1, a2) in iter_input_pats(decl, body).zip(args) {\n                 if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n-                    if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {\n+                    if let ExprKind::Path(QPath::Resolved(None, ref p)) = a2.node {\n                         if p.segments.len() != 1 {\n                             // If it's a proper path, it can't be a local variable\n                             return;"}, {"sha": "7ccf8c31569d864c3edfc3a1123a7ef1e917cab6", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,8 @@ use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast;\n use crate::utils::{get_parent_expr, span_lint, span_note_and_lint};\n \n@@ -62,7 +64,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n-            ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => if let ExprPath(ref qpath) = lhs.node {\n+            ExprKind::Assign(ref lhs, _) | ExprKind::AssignOp(_, ref lhs, _) => if let ExprKind::Path(ref qpath) = lhs.node {\n                 if let QPath::Resolved(_, ref path) = *qpath {\n                     if path.segments.len() == 1 {\n                         if let def::Def::Local(var) = cx.tables.qpath_def(qpath, lhs.hir_id) {\n@@ -82,8 +84,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         match stmt.node {\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n-            StmtDecl(ref d, _) => if let DeclLocal(ref local) = d.node {\n+            StmtKind::Expr(ref e, _) | StmtKind::Semi(ref e, _) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n+            StmtKind::Decl(ref d, _) => if let DeclKind::Local(ref local) = d.node {\n                 if let Local {\n                     init: Some(ref e), ..\n                 } = **local\n@@ -102,8 +104,8 @@ struct DivergenceVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n     fn maybe_walk_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprClosure(.., _) => {},\n-            ExprMatch(ref e, ref arms, _) => {\n+            ExprKind::Closure(.., _) => {},\n+            ExprKind::Match(ref e, ref arms, _) => {\n                 self.visit_expr(e);\n                 for arm in arms {\n                     if let Some(ref guard) = arm.guard {\n@@ -124,8 +126,8 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprContinue(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n-            ExprCall(ref func, _) => {\n+            ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n+            ExprKind::Call(ref func, _) => {\n                 let typ = self.cx.tables.expr_ty(func);\n                 match typ.sty {\n                     ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n@@ -137,7 +139,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                     _ => {},\n                 }\n             },\n-            ExprMethodCall(..) => {\n+            ExprKind::MethodCall(..) => {\n                 let borrowed_table = self.cx.tables;\n                 if borrowed_table.expr_ty(e).is_never() {\n                     self.report_diverging_sub_expr(e);\n@@ -173,7 +175,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n ///   logical operators are considered to have a defined evaluation order.\n ///\n /// When such a read is found, the lint is triggered.\n-fn check_for_unsequenced_reads(vis: &mut ReadVisitor) {\n+fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n     let map = &vis.cx.tcx.hir;\n     let mut cur_id = vis.write_expr.id;\n     loop {\n@@ -218,25 +220,25 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n     }\n \n     match expr.node {\n-        ExprArray(_) |\n-        ExprTup(_) |\n-        ExprMethodCall(..) |\n-        ExprCall(_, _) |\n-        ExprAssign(_, _) |\n-        ExprIndex(_, _) |\n-        ExprRepeat(_, _) |\n-        ExprStruct(_, _, _) => {\n+        ExprKind::Array(_) |\n+        ExprKind::Tup(_) |\n+        ExprKind::MethodCall(..) |\n+        ExprKind::Call(_, _) |\n+        ExprKind::Assign(_, _) |\n+        ExprKind::Index(_, _) |\n+        ExprKind::Repeat(_, _) |\n+        ExprKind::Struct(_, _, _) => {\n             walk_expr(vis, expr);\n         },\n-        ExprBinary(op, _, _) | ExprAssignOp(op, _, _) => {\n-            if op.node == BiAnd || op.node == BiOr {\n+        ExprKind::Binary(op, _, _) | ExprKind::AssignOp(op, _, _) => {\n+            if op.node == BinOpKind::And || op.node == BinOpKind::Or {\n                 // x && y and x || y always evaluate x first, so these are\n                 // strictly sequenced.\n             } else {\n                 walk_expr(vis, expr);\n             }\n         },\n-        ExprClosure(_, _, _, _, _) => {\n+        ExprKind::Closure(_, _, _, _, _) => {\n             // Either\n             //\n             // * `var` is defined in the closure body, in which case we've\n@@ -262,12 +264,12 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n \n fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> StopEarly {\n     match stmt.node {\n-        StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => check_expr(vis, expr),\n-        StmtDecl(ref decl, _) => {\n+        StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => check_expr(vis, expr),\n+        StmtKind::Decl(ref decl, _) => {\n             // If the declaration is of a local variable, check its initializer\n             // expression if it has one. Otherwise, keep going.\n             let local = match decl.node {\n-                DeclLocal(ref local) => Some(local),\n+                DeclKind::Local(ref local) => Some(local),\n                 _ => None,\n             };\n             local\n@@ -297,7 +299,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n         }\n \n         match expr.node {\n-            ExprPath(ref qpath) => {\n+            ExprKind::Path(ref qpath) => {\n                 if_chain! {\n                     if let QPath::Resolved(None, ref path) = *qpath;\n                     if path.segments.len() == 1;\n@@ -320,7 +322,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n             // We're about to descend a closure. Since we don't know when (or\n             // if) the closure will be evaluated, any reads in it might not\n             // occur here (or ever). Like above, bail to avoid false positives.\n-            ExprClosure(_, _, _, _, _) |\n+            ExprKind::Closure(_, _, _, _, _) |\n \n             // We want to avoid a false positive when a variable name occurs\n             // only to have its address taken, so we stop here. Technically,\n@@ -332,7 +334,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n             // ```\n             //\n             // TODO: fix this\n-            ExprAddrOf(_, _) => {\n+            ExprKind::AddrOf(_, _) => {\n                 return;\n             }\n             _ => {}\n@@ -346,9 +348,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n }\n \n /// Returns true if `expr` is the LHS of an assignment, like `expr = ...`.\n-fn is_in_assignment_position(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n-        if let ExprAssign(ref lhs, _) = parent.node {\n+        if let ExprKind::Assign(ref lhs, _) = parent.node {\n             return lhs.id == expr.id;\n         }\n     }"}, {"sha": "28819077f9bc68f99f6d51288355fa5865e7a114", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::TypeVariants;\n use std::f32;\n use std::f64;\n@@ -45,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n             if let TypeVariants::TyFloat(fty) = ty.sty;\n-            if let hir::ExprLit(ref lit) = expr.node;\n+            if let hir::ExprKind::Lit(ref lit) = expr.node;\n             if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n             if let Some(sugg) = self.check(sym, fty);\n             then {"}, {"sha": "22e6834ee884358cb878eebf4d7b4bc257d2c94f", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use crate::utils::{is_expn_of, match_def_path, resolve_node, span_lint};\n use crate::utils::opt_def_id;\n \n@@ -35,17 +37,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprMethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n+            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n             if unwrap_fun.ident.name == \"unwrap\";\n             // match call to write_fmt\n             if unwrap_args.len() > 0;\n-            if let ExprMethodCall(ref write_fun, _, ref write_args) =\n+            if let ExprKind::MethodCall(ref write_fun, _, ref write_args) =\n                 unwrap_args[0].node;\n             if write_fun.ident.name == \"write_fmt\";\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if write_args.len() > 0;\n-            if let ExprCall(ref dest_fun, _) = write_args[0].node;\n-            if let ExprPath(ref qpath) = dest_fun.node;\n+            if let ExprKind::Call(ref dest_fun, _) = write_args[0].node;\n+            if let ExprKind::Path(ref qpath) = dest_fun.node;\n             if let Some(dest_fun_id) =\n                 opt_def_id(resolve_node(cx, qpath, dest_fun.hir_id));\n             if let Some(dest_name) = if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stdout\"]) {"}, {"sha": "3db644911d78a75fd1dadb10c53de8ce3b2dd2b0", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::ty;\n use syntax_pos::Span;\n@@ -39,7 +41,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n         // check for `impl From<???> for ..`\n         let impl_def_id = cx.tcx.hir.local_def_id(item.id);\n         if_chain! {\n-            if let hir::ItemImpl(.., ref impl_items) = item.node;\n+            if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n             if match_def_path(cx.tcx, impl_trait_ref.def_id, &FROM_TRAIT);\n             then {\n@@ -63,8 +65,8 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n         fn visit_expr(&mut self, expr: &'tcx Expr) {\n             // check for `begin_panic`\n             if_chain! {\n-                if let ExprCall(ref func_expr, _) = expr.node;\n-                if let ExprPath(QPath::Resolved(_, ref path)) = func_expr.node;\n+                if let ExprKind::Call(ref func_expr, _) = expr.node;\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.node;\n                 if let Some(path_def_id) = opt_def_id(path.def);\n                 if match_def_path(self.tcx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(self.tcx, path_def_id, &BEGIN_PANIC_FMT);\n@@ -126,7 +128,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n }\n \n-fn match_type(tcx: ty::TyCtxt, ty: ty::Ty, path: &[&str]) -> bool {\n+fn match_type(tcx: ty::TyCtxt<'_, '_, '_>, ty: ty::Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(tcx, adt.did, path),\n         _ => false,"}, {"sha": "80fc4c3acfe48be0e728a702d180732b78bd85f7", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use syntax::ast::LitKind;\n use syntax_pos::Span;\n@@ -46,9 +48,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             match expr.node {\n \n                 // `format!(\"{}\", foo)` expansion\n-                ExprCall(ref fun, ref args) => {\n+                ExprKind::Call(ref fun, ref args) => {\n                     if_chain! {\n-                        if let ExprPath(ref qpath) = fun.node;\n+                        if let ExprKind::Path(ref qpath) = fun.node;\n                         if args.len() == 3;\n                         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n                         if match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n@@ -64,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     }\n                 },\n                 // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-                ExprMatch(ref matchee, _, _) => if let ExprTup(ref tup) = matchee.node {\n+                ExprKind::Match(ref matchee, _, _) => if let ExprKind::Tup(ref tup) = matchee.node {\n                     if tup.is_empty() {\n                         let sugg = format!(\"{}.to_string()\", snippet(cx, expr.span, \"<expr>\").into_owned());\n                         span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n@@ -81,10 +83,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n /// Checks if the expressions matches `&[\"\"]`\n fn check_single_piece(expr: &Expr) -> bool {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\"]\n-        if let ExprArray(ref exprs) = expr.node; // [\"\"]\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\"]\n+        if let ExprKind::Array(ref exprs) = expr.node; // [\"\"]\n         if exprs.len() == 1;\n-        if let ExprLit(ref lit) = exprs[0].node;\n+        if let ExprKind::Lit(ref lit) = exprs[0].node;\n         if let LitKind::Str(ref lit, _) = lit.node;\n         then {\n             return lit.as_str().is_empty();\n@@ -103,25 +105,25 @@ fn check_single_piece(expr: &Expr) -> bool {\n /// ```\n /// and that type of `__arg0` is `&str` or `String`\n /// then returns the span of first element of the matched tuple\n-fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n+fn get_single_string_arg(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Span> {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprMatch(ref match_expr, ref arms, _) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Match(ref match_expr, ref arms, _) = expr.node;\n         if arms.len() == 1;\n         if arms[0].pats.len() == 1;\n         if let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node;\n         if pat.len() == 1;\n-        if let ExprArray(ref exprs) = arms[0].body.node;\n+        if let ExprKind::Array(ref exprs) = arms[0].body.node;\n         if exprs.len() == 1;\n-        if let ExprCall(_, ref args) = exprs[0].node;\n+        if let ExprKind::Call(_, ref args) = exprs[0].node;\n         if args.len() == 2;\n-        if let ExprPath(ref qpath) = args[1].node;\n+        if let ExprKind::Path(ref qpath) = args[1].node;\n         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, args[1].hir_id));\n         if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n             if ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING) {\n-                if let ExprTup(ref values) = match_expr.node {\n+                if let ExprKind::Tup(ref values) = match_expr.node {\n                     return Some(values[0].span);\n                 }\n             }\n@@ -143,14 +145,14 @@ fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n /// ```\n fn check_unformatted(expr: &Expr) -> bool {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprArray(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Array(ref exprs) = expr.node;\n         if exprs.len() == 1;\n-        if let ExprStruct(_, ref fields, _) = exprs[0].node;\n+        if let ExprKind::Struct(_, ref fields, _) = exprs[0].node;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == \"format\");\n-        if let ExprStruct(_, ref fields, _) = format_field.expr.node;\n+        if let ExprKind::Struct(_, ref fields, _) = format_field.expr.node;\n         if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"width\");\n-        if let ExprPath(ref qpath) = align_field.expr.node;\n+        if let ExprKind::Path(ref qpath) = align_field.expr.node;\n         if last_path_segment(qpath).ident.name == \"Implied\";\n         then {\n             return true;"}, {"sha": "60001c792c0b41640ef5e0ededccf247cca773b6", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast;\n use crate::utils::{differing_macro_contexts, in_macro, snippet_opt, span_note_and_lint};\n use syntax::ptr::P;\n@@ -82,7 +83,7 @@ impl LintPass for Formatting {\n }\n \n impl EarlyLintPass for Formatting {\n-    fn check_block(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         for w in block.stmts.windows(2) {\n             match (&w[0].node, &w[1].node) {\n                 (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Expr(ref second)) |\n@@ -94,15 +95,15 @@ impl EarlyLintPass for Formatting {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         check_assign(cx, expr);\n         check_else_if(cx, expr);\n         check_array(cx, expr);\n     }\n }\n \n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n-fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_assign(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let ast::ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro(lhs.span) {\n             let eq_span = lhs.span.between(rhs.span);\n@@ -131,7 +132,7 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for weird `else if`.\n-fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_else_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let Some((then, &Some(ref else_))) = unsugar_if(expr) {\n         if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(then.span) {\n             // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to\n@@ -163,7 +164,7 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `POSSIBLE_MISSING_COMMA` lint for array\n-fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_array(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let ast::ExprKind::Array(ref array) = expr.node {\n         for element in array {\n             if let ast::ExprKind::Binary(ref op, ref lhs, _) = element.node {\n@@ -189,7 +190,7 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n-fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n+fn check_consecutive_ifs(cx: &EarlyContext<'_>, first: &ast::Expr, second: &ast::Expr) {\n     if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) && unsugar_if(first).is_some()\n         && unsugar_if(second).is_some()\n     {"}, {"sha": "8903766c330b4636dfc488d446ce4856bcd3bb4f", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,8 @@\n+use matches::matches;\n use rustc::hir::intravisit;\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use rustc::hir::def::Def;\n use std::collections::HashSet;\n@@ -86,7 +88,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         use rustc::hir::map::Node::*;\n \n         let is_impl = if let Some(NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(nodeid)) {\n-            matches!(item.node, hir::ItemImpl(_, _, _, _, Some(_), _, _))\n+            matches!(item.node, hir::ItemKind::Impl(_, _, _, _, Some(_), _, _))\n         } else {\n             false\n         };\n@@ -126,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n }\n \n impl<'a, 'tcx> Functions {\n-    fn check_arg_number(self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n+    fn check_arg_number(self, cx: &LateContext<'_, '_>, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n             span_lint(\n@@ -168,7 +170,7 @@ impl<'a, 'tcx> Functions {\n }\n \n fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<ast::NodeId> {\n-    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &ty.node) {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.node, &ty.node) {\n         Some(id)\n     } else {\n         None\n@@ -184,7 +186,7 @@ struct DerefVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprCall(ref f, ref args) => {\n+            hir::ExprKind::Call(ref f, ref args) => {\n                 let ty = self.tables.expr_ty(f);\n \n                 if type_is_unsafe_function(self.cx, ty) {\n@@ -193,7 +195,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprMethodCall(_, _, ref args) => {\n+            hir::ExprKind::MethodCall(_, _, ref args) => {\n                 let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n@@ -203,7 +205,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprUnary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n+            hir::ExprKind::Unary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n             _ => (),\n         }\n \n@@ -216,7 +218,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n-        if let hir::ExprPath(ref qpath) = ptr.node {\n+        if let hir::ExprKind::Path(ref qpath) = ptr.node {\n             if let Def::Local(id) = self.cx.tables.qpath_def(qpath, ptr.hir_id) {\n                 if self.ptrs.contains(&id) {\n                     span_lint("}, {"sha": "a0705f62544b6483155df66c46cfbddc6d132eea", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use syntax::ast::NodeId;\n use crate::utils::{in_macro, match_def_path, match_trait_method, same_tys, snippet, span_lint_and_then};\n@@ -43,19 +44,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n         }\n \n         match e.node {\n-            ExprMatch(_, ref arms, MatchSource::TryDesugar) => {\n+            ExprKind::Match(_, ref arms, MatchSource::TryDesugar) => {\n                 let e = match arms[0].body.node {\n-                    ExprRet(Some(ref e)) | ExprBreak(_, Some(ref e)) => e,\n+                    ExprKind::Ret(Some(ref e)) | ExprKind::Break(_, Some(ref e)) => e,\n                     _ => return,\n                 };\n-                if let ExprCall(_, ref args) = e.node {\n+                if let ExprKind::Call(_, ref args) = e.node {\n                     self.try_desugar_arm.push(args[0].id);\n                 } else {\n                     return;\n                 }\n             },\n \n-            ExprMethodCall(ref name, .., ref args) => {\n+            ExprKind::MethodCall(ref name, .., ref args) => {\n                 if match_trait_method(cx, e, &paths::INTO[..]) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n@@ -68,7 +69,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                 }\n             },\n \n-            ExprCall(ref path, ref args) => if let ExprPath(ref qpath) = path.node {\n+            ExprKind::Call(ref path, ref args) => if let ExprKind::Path(ref qpath) = path.node {\n                 if let Some(def_id) = opt_def_id(resolve_node(cx, qpath, path.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::FROM_FROM[..]) {\n                         let a = cx.tables.expr_ty(e);"}, {"sha": "23b34362171986d2b6ba43e1e432e6e357546841", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n use crate::consts::{constant_simple, Constant};\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n use crate::utils::{in_macro, snippet, span_lint, unsext, clip};\n use rustc::ty;\n@@ -36,19 +37,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n-                BiAdd | BiBitOr | BiBitXor => {\n+                BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n                     check(cx, left, 0, e.span, right.span);\n                     check(cx, right, 0, e.span, left.span);\n                 },\n-                BiShl | BiShr | BiSub => check(cx, right, 0, e.span, left.span),\n-                BiMul => {\n+                BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => check(cx, right, 0, e.span, left.span),\n+                BinOpKind::Mul => {\n                     check(cx, left, 1, e.span, right.span);\n                     check(cx, right, 1, e.span, left.span);\n                 },\n-                BiDiv => check(cx, right, 1, e.span, left.span),\n-                BiBitAnd => {\n+                BinOpKind::Div => check(cx, right, 1, e.span, left.span),\n+                BinOpKind::BitAnd => {\n                     check(cx, left, -1, e.span, right.span);\n                     check(cx, right, -1, e.span, left.span);\n                 },\n@@ -59,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n }\n \n #[allow(cast_possible_wrap)]\n-fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n+fn check(cx: &LateContext<'_, '_>, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         let check = match cx.tables.expr_ty(e).sty {\n             ty::TyInt(ity) => unsext(cx.tcx, -1i128, ity),"}, {"sha": "bc97584a23d867cb80f928d1ab6506e0b07c6074", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::{match_qpath, paths, snippet, span_lint_and_then};\n \n@@ -45,16 +46,20 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n+        if let ExprKind::Match(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n             if arms[0].pats.len() == 1 {\n                 let good_method = match arms[0].pats[0].node {\n-                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 && pats[0].node == PatKind::Wild => {\n-                        if match_qpath(path, &paths::RESULT_OK) {\n-                            \"is_ok()\"\n-                        } else if match_qpath(path, &paths::RESULT_ERR) {\n-                            \"is_err()\"\n-                        } else if match_qpath(path, &paths::OPTION_SOME) {\n-                            \"is_some()\"\n+                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 => {\n+                        if let PatKind::Wild = pats[0].node {\n+                            if match_qpath(path, &paths::RESULT_OK) {\n+                                \"is_ok()\"\n+                            } else if match_qpath(path, &paths::RESULT_ERR) {\n+                                \"is_err()\"\n+                            } else if match_qpath(path, &paths::OPTION_SOME) {\n+                                \"is_some()\"\n+                            } else {\n+                                return;\n+                            }\n                         } else {\n                             return;\n                         }"}, {"sha": "fea3069f37d3a40e7a9810fcfebdfd9284c527d5", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,9 +2,10 @@\n //! on the condition\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n \n-use crate::utils::{in_external_macro, span_help_and_lint};\n+use crate::utils::span_help_and_lint;\n \n /// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n /// else branch.\n@@ -46,8 +47,8 @@ impl LintPass for IfNotElse {\n }\n \n impl EarlyLintPass for IfNotElse {\n-    fn check_expr(&mut self, cx: &EarlyContext, item: &Expr) {\n-        if in_external_macro(cx, item.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n         if let ExprKind::If(ref cond, _, Some(ref els)) = item.node {"}, {"sha": "677f59d32cc5a70170821d490d4be95f498c2707", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -6,6 +6,7 @@ use crate::utils::higher;\n use crate::utils::higher::Range;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use syntax::ast::RangeLimits;\n \n@@ -94,7 +95,7 @@ impl LintPass for IndexingSlicing {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIndex(ref array, ref index) = &expr.node {\n+        if let ExprKind::Index(ref array, ref index) = &expr.node {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]\n@@ -154,7 +155,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n /// the range.\n fn to_const_range<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    range: Range,\n+    range: Range<'_>,\n     array_size: u128,\n ) -> Option<(u128, u128)> {\n     let s = range"}, {"sha": "8b8cb32deb1afedcb8aeca0e7bf4eb2831aeb24c", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,8 @@\n use super::utils::{get_arg_name, match_var, remove_blocks, snippet, span_lint_and_sugg};\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for matches being used to destructure a single-variant enum\n /// or tuple struct where a `let` will suffice.\n@@ -50,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n         if_chain! {\n             if let Some(ref expr) = local.init;\n-            if let Expr_::ExprMatch(ref target, ref arms, MatchSource::Normal) = expr.node;\n+            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.node;\n             if arms.len() == 1 && arms[0].pats.len() == 1 && arms[0].guard.is_none();\n             if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pats[0].node;\n             if args.len() == 1;"}, {"sha": "eaa93cb62f8789f0b0209fbd311a198f8fb3fd5b", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, paths, span_lint};\n \n /// **What it does:** Checks for iteration that is guaranteed to be infinite.\n@@ -139,9 +140,9 @@ static HEURISTICS: &[(&str, usize, Heuristic, Finiteness)] = &[\n     (\"scan\", 3, First, MaybeInfinite),\n ];\n \n-fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n+fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n-        ExprMethodCall(ref method, _, ref args) => {\n+        ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n                 if method.ident.name == name && args.len() == len {\n                     return (match heuristic {\n@@ -153,21 +154,21 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n                 }\n             }\n             if method.ident.name == \"flat_map\" && args.len() == 2 {\n-                if let ExprClosure(_, _, body_id, _, _) = args[1].node {\n+                if let ExprKind::Closure(_, _, body_id, _, _) = args[1].node {\n                     let body = cx.tcx.hir.body(body_id);\n                     return is_infinite(cx, &body.value);\n                 }\n             }\n             Finite\n         },\n-        ExprBlock(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n-        ExprBox(ref e) | ExprAddrOf(_, ref e) => is_infinite(cx, e),\n-        ExprCall(ref path, _) => if let ExprPath(ref qpath) = path.node {\n+        ExprKind::Block(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) => is_infinite(cx, e),\n+        ExprKind::Call(ref path, _) => if let ExprKind::Path(ref qpath) = path.node {\n             match_qpath(qpath, &paths::REPEAT).into()\n         } else {\n             Finite\n         },\n-        ExprStruct(..) => higher::range(cx, expr)\n+        ExprKind::Struct(..) => higher::range(cx, expr)\n             .map_or(false, |r| r.end.is_none())\n             .into(),\n         _ => Finite,\n@@ -203,9 +204,9 @@ static COMPLETING_METHODS: &[(&str, usize)] = &[\n     (\"product\", 1),\n ];\n \n-fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n+fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n-        ExprMethodCall(ref method, _, ref args) => {\n+        ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len) in COMPLETING_METHODS.iter() {\n                 if method.ident.name == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);\n@@ -224,11 +225,11 @@ fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n                 }\n             }\n         },\n-        ExprBinary(op, ref l, ref r) => if op.node.is_comparison() {\n+        ExprKind::Binary(op, ref l, ref r) => if op.node.is_comparison() {\n             return is_infinite(cx, l)\n                 .and(is_infinite(cx, r))\n                 .and(MaybeInfinite);\n-        }, // TODO: ExprLoop + Match\n+        }, // TODO: ExprKind::Loop + Match\n         _ => (),\n     }\n     Finite"}, {"sha": "fc06af81574e2de5add72571d07c5498ee2efbf6", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use std::collections::HashMap;\n use std::default::Default;\n use syntax_pos::Span;\n@@ -56,7 +57,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let Item_::ItemImpl(_, _, _, ref generics, None, _, _) = item.node {\n+        if let ItemKind::Impl(_, _, _, ref generics, None, _, _) = item.node {\n             // Remember for each inherent implementation encoutered its span and generics\n             self.impls\n                 .insert(item.hir_id.owner_def_id(), (item.span, generics.clone()));"}, {"sha": "70f88a76f45042adc32371566e70f1b215f26578", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n //! checks for `#[inline]` on trait methods without bodies\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use syntax::ast::{Attribute, Name};\n use crate::utils::span_lint_and_then;\n@@ -43,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_attrs(cx: &LateContext, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_, '_>, name: Name, attrs: &[Attribute]) {\n     for attr in attrs {\n         if attr.name() != \"inline\" {\n             continue;"}, {"sha": "9b6fc579a31ce8b1085d239ff20580711e43b358", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n //! lint on blocks unnecessarily using >= with a + 1 or - 1\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n \n use crate::utils::{snippet_opt, span_lint_and_then};\n@@ -60,7 +61,7 @@ impl IntPlusOne {\n         false\n     }\n \n-    fn check_binop(&self, cx: &EarlyContext, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n+    fn check_binop(&self, cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n         match (binop, &lhs.node, &rhs.node) {\n             // case where `x - 1 >= ...` or `-1 + x >= ...`\n             (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n@@ -126,7 +127,7 @@ impl IntPlusOne {\n \n     fn generate_recommendation(\n         &self,\n-        cx: &EarlyContext,\n+        cx: &EarlyContext<'_>,\n         binop: BinOpKind,\n         node: &Expr,\n         other_side: &Expr,\n@@ -149,15 +150,15 @@ impl IntPlusOne {\n         None\n     }\n \n-    fn emit_warning(&self, cx: &EarlyContext, block: &Expr, recommendation: String) {\n+    fn emit_warning(&self, cx: &EarlyContext<'_>, block: &Expr, recommendation: String) {\n         span_lint_and_then(cx, INT_PLUS_ONE, block.span, \"Unnecessary `>= y + 1` or `x - 1 >=`\", |db| {\n             db.span_suggestion(block.span, \"change `>= y + 1` to `> y` as shown\", recommendation);\n         });\n     }\n }\n \n impl EarlyLintPass for IntPlusOne {\n-    fn check_expr(&mut self, cx: &EarlyContext, item: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.node {\n             if let Some(ref rec) = self.check_binop(cx, kind.node, lhs, rhs) {\n                 self.emit_warning(cx, item, rec.clone());"}, {"sha": "b529cb3ac3813f231c7c18272d93db90621d75f0", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use rustc::hir::*;\n use crate::utils::{match_def_path, opt_def_id, paths, span_help_and_lint};\n@@ -35,8 +37,8 @@ impl LintPass for InvalidRef {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Call(ref path, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 0;\n             if let ty::TyRef(..) = cx.tables.expr_ty(expr).sty;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));"}, {"sha": "07ef086d694c77603c4af9dfccc817216bf96ee1", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,8 @@\n //! lint when items are used after statements\n \n+use matches::matches;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use crate::utils::{in_macro, span_lint};\n \n@@ -41,7 +43,7 @@ impl LintPass for ItemsAfterStatements {\n }\n \n impl EarlyLintPass for ItemsAfterStatements {\n-    fn check_block(&mut self, cx: &EarlyContext, item: &Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n         if in_macro(item.span) {\n             return;\n         }"}, {"sha": "2c03b6b5f682c2ed766d65d849aa2e52bc44f85d", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n //! lint when there is a large size difference between variants on an enum\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::{snippet_opt, span_lint_and_then};\n use rustc::ty::layout::LayoutOf;\n@@ -47,9 +48,9 @@ impl LintPass for LargeEnumVariant {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n         let did = cx.tcx.hir.local_def_id(item.id);\n-        if let ItemEnum(ref def, _) = item.node {\n+        if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def()\n                 .expect(\"already checked whether this is an enum\");"}, {"sha": "b73f912fad5ec69e56c1f5f13aca018876e53116", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use std::collections::HashSet;\n use syntax::ast::{Lit, LitKind, Name};\n@@ -68,8 +69,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n         }\n \n         match item.node {\n-            ItemTrait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n-            ItemImpl(_, _, _, _, None, _, ref impl_items) => check_impl_items(cx, item, impl_items),\n+            ItemKind::Trait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n+            ItemKind::Impl(_, _, _, _, None, _, ref impl_items) => check_impl_items(cx, item, impl_items),\n             _ => (),\n         }\n     }\n@@ -79,34 +80,34 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n             return;\n         }\n \n-        if let ExprBinary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n+        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n             match cmp {\n-                BiEq => {\n+                BinOpKind::Eq => {\n                     check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n                     check_cmp(cx, expr.span, right, left, \"\", 0); // 0 == len\n                 },\n-                BiNe => {\n+                BinOpKind::Ne => {\n                     check_cmp(cx, expr.span, left, right, \"!\", 0); // len != 0\n                     check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 != len\n                 },\n-                BiGt => {\n+                BinOpKind::Gt => {\n                     check_cmp(cx, expr.span, left, right, \"!\", 0); // len > 0\n                     check_cmp(cx, expr.span, right, left, \"\", 1); // 1 > len\n                 },\n-                BiLt => {\n+                BinOpKind::Lt => {\n                     check_cmp(cx, expr.span, left, right, \"\", 1); // len < 1\n                     check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 < len\n                 },\n-                BiGe => check_cmp(cx, expr.span, left, right, \"!\", 1), // len <= 1\n-                BiLe => check_cmp(cx, expr.span, right, left, \"!\", 1), // 1 >= len\n+                BinOpKind::Ge => check_cmp(cx, expr.span, left, right, \"!\", 1), // len <= 1\n+                BinOpKind::Le => check_cmp(cx, expr.span, right, left, \"!\", 1), // 1 >= len\n                 _ => (),\n             }\n         }\n     }\n }\n \n-fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n-    fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n+fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &TraitItemRef, name: &str) -> bool {\n         item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n@@ -118,7 +119,7 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n     }\n \n     // fill the set with current and super traits\n-    fn fill_trait_set(traitt: DefId, set: &mut HashSet<DefId>, cx: &LateContext) {\n+    fn fill_trait_set(traitt: DefId, set: &mut HashSet<DefId>, cx: &LateContext<'_, '_>) {\n         if set.insert(traitt) {\n             for supertrait in ::rustc::traits::supertrait_def_ids(cx.tcx, traitt) {\n                 fill_trait_set(supertrait, set, cx);\n@@ -153,8 +154,8 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n     }\n }\n \n-fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n-    fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n+fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplItemRef]) {\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &ImplItemRef, name: &str) -> bool {\n         item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n@@ -193,8 +194,8 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     }\n }\n \n-fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n-    if let (&ExprMethodCall(ref method_path, _, ref args), &ExprLit(ref lit)) = (&method.node, &lit.node) {\n+fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n+    if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.node, &lit.node) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name == \"is_empty\" {\n@@ -206,7 +207,7 @@ fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str,\n     }\n }\n \n-fn check_len(cx: &LateContext, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n+fn check_len(cx: &LateContext<'_, '_>, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n     if let Spanned {\n         node: LitKind::Int(lit, _),\n         ..\n@@ -231,9 +232,9 @@ fn check_len(cx: &LateContext, span: Span, method_name: Name, args: &[Expr], lit\n }\n \n /// Check if this type has an `is_empty` method.\n-fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n-    fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n+    fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if item.ident.name == \"is_empty\" {\n                 let sig = cx.tcx.fn_sig(item.def_id);\n@@ -248,7 +249,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     }\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n-    fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n+    fn has_is_empty_impl(cx: &LateContext<'_, '_>, id: DefId) -> bool {\n         cx.tcx.inherent_impls(id).iter().any(|imp| {\n             cx.tcx\n                 .associated_items(*imp)\n@@ -258,11 +259,10 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.sty {\n-        ty::TyDynamic(..) => cx.tcx\n-            .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n+        ty::TyDynamic(ref tt, ..) => cx.tcx\n+            .associated_items(tt.principal().expect(\"trait impl not found\").def_id())\n             .any(|item| is_is_empty(cx, &item)),\n-        ty::TyProjection(_) => ty.ty_to_def_id()\n-            .map_or(false, |id| has_is_empty_impl(cx, id)),\n+        ty::TyProjection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyStr => true,\n         _ => false,"}, {"sha": "57ca5eff95530b8646dc5dd14ac2f0214c9376e4", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::BindingAnnotation;\n use rustc::hir::def::Def;\n@@ -65,20 +67,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n         while let Some(stmt) = it.next() {\n             if_chain! {\n                 if let Some(expr) = it.peek();\n-                if let hir::StmtDecl(ref decl, _) = stmt.node;\n-                if let hir::DeclLocal(ref decl) = decl.node;\n+                if let hir::StmtKind::Decl(ref decl, _) = stmt.node;\n+                if let hir::DeclKind::Local(ref decl) = decl.node;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = decl.pat.node;\n-                if let hir::StmtExpr(ref if_, _) = expr.node;\n-                if let hir::ExprIf(ref cond, ref then, ref else_) = if_.node;\n+                if let hir::StmtKind::Expr(ref if_, _) = expr.node;\n+                if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.node;\n                 if !used_in_expr(cx, canonical_id, cond);\n-                if let hir::ExprBlock(ref then, _) = then.node;\n+                if let hir::ExprKind::Block(ref then, _) = then.node;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n                 if !used_in_expr(cx, canonical_id, value);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n                     let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n-                        if let hir::ExprBlock(ref else_, _) = else_.node {\n+                        if let hir::ExprKind::Block(ref else_, _) = else_.node {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)\n                             } else if let Some(ref default) = decl.init {\n@@ -140,7 +142,7 @@ struct UsedVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_chain! {\n-            if let hir::ExprPath(ref qpath) = expr.node;\n+            if let hir::ExprKind::Path(ref qpath) = expr.node;\n             if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n             if self.id == local_id;\n             then {\n@@ -163,9 +165,9 @@ fn check_assign<'a, 'tcx>(\n     if_chain! {\n         if block.expr.is_none();\n         if let Some(expr) = block.stmts.iter().last();\n-        if let hir::StmtSemi(ref expr, _) = expr.node;\n-        if let hir::ExprAssign(ref var, ref value) = expr.node;\n-        if let hir::ExprPath(ref qpath) = var.node;\n+        if let hir::StmtKind::Semi(ref expr, _) = expr.node;\n+        if let hir::ExprKind::Assign(ref var, ref value) = expr.node;\n+        if let hir::ExprKind::Path(ref qpath) = var.node;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, var.hir_id);\n         if decl == local_id;\n         then {"}, {"sha": "b08449d2bebf30ee1d4e6b81189694139cdcd8be", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -14,54 +14,41 @@\n #![feature(rust_2018_preview)]\n #![warn(rust_2018_idioms)]\n \n-#[macro_use]\n-extern crate rustc;\n-\n use toml;\n use rustc_plugin;\n+use rustc;\n \n-#[macro_use]\n-extern crate matches as matches_macro;\n-\n-#[macro_use]\n-extern crate serde_derive;\n-\n-#[macro_use]\n-extern crate lazy_static;\n-\n-#[macro_use]\n-extern crate if_chain;\n \n macro_rules! declare_clippy_lint {\n     { pub $name:tt, style, $description:tt } => {\n-        declare_lint! { pub $name, Warn, $description }\n+        declare_lint! { pub $name, Warn, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, correctness, $description:tt } => {\n-        declare_lint! { pub $name, Deny, $description }\n+        declare_lint! { pub $name, Deny, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, complexity, $description:tt } => {\n-        declare_lint! { pub $name, Warn, $description }\n+        declare_lint! { pub $name, Warn, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, perf, $description:tt } => {\n-        declare_lint! { pub $name, Warn, $description }\n+        declare_lint! { pub $name, Warn, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, pedantic, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, restriction, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, cargo, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, nursery, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, internal, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, internal_warn, $description:tt } => {\n-        declare_lint! { pub $name, Warn, $description }\n+        declare_lint! { pub $name, Warn, $description, report_in_external_macro: true }\n     };\n }\n \n@@ -134,6 +121,7 @@ pub mod minmax;\n pub mod misc;\n pub mod misc_early;\n pub mod missing_doc;\n+pub mod missing_inline;\n pub mod multiple_crate_versions;\n pub mod mut_mut;\n pub mod mut_reference;\n@@ -188,8 +176,12 @@ mod reexport {\n     crate use syntax::ast::{Name, NodeId};\n }\n \n+pub fn register_pre_expansion_lints(session: &rustc::session::Session, store: &mut rustc::lint::LintStore) {\n+    store.register_pre_expansion_pass(Some(session), box write::Pass);\n+}\n+\n #[cfg_attr(rustfmt, rustfmt_skip)]\n-pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n+pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>) {\n     let conf = match utils::conf::file_from_args(reg.args()) {\n         Ok(file_name) => {\n             // if the user specified a file, it must exist, otherwise default to `clippy.toml` but\n@@ -333,7 +325,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n     reg.register_late_lint_pass(box derive::Derive);\n     reg.register_late_lint_pass(box types::CharLitAsU8);\n-    reg.register_late_lint_pass(box write::Pass);\n     reg.register_late_lint_pass(box vec::Pass);\n     reg.register_early_lint_pass(box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold: conf.single_char_binding_names_threshold,\n@@ -364,6 +355,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box let_if_seq::LetIfSeq);\n     reg.register_late_lint_pass(box eval_order_dependence::EvalOrderDependence);\n     reg.register_late_lint_pass(box missing_doc::MissingDoc::new());\n+    reg.register_late_lint_pass(box missing_inline::MissingInline);\n     reg.register_late_lint_pass(box ok_if_let::Pass);\n     reg.register_late_lint_pass(box if_let_redundant_pattern_matching::Pass);\n     reg.register_late_lint_pass(box partialeq_ne_impl::Pass);\n@@ -422,6 +414,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         methods::WRONG_PUB_SELF_CONVENTION,\n         misc::FLOAT_CMP_CONST,\n         missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n+        missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS,\n         panic_unimplemented::UNIMPLEMENTED,\n         shadow::SHADOW_REUSE,\n         shadow::SHADOW_SAME,"}, {"sha": "cf7a016231e347f41dfb829918e2d93b405bec9d", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,11 +1,13 @@\n use crate::reexport::*;\n+use matches::matches;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::hir::intravisit::*;\n use std::collections::{HashMap, HashSet};\n use syntax::codemap::Span;\n-use crate::utils::{in_external_macro, last_path_segment, span_lint};\n+use crate::utils::{last_path_segment, span_lint};\n use syntax::symbol::keywords;\n \n /// **What it does:** Checks for lifetime annotations which can be removed by\n@@ -59,7 +61,7 @@ impl LintPass for LifetimePass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LifetimePass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, ref generics, id) = item.node {\n+        if let ItemKind::Fn(ref decl, _, ref generics, id) = item.node {\n             check_fn_inner(cx, decl, Some(id), generics, item.span);\n         }\n     }\n@@ -96,7 +98,7 @@ fn check_fn_inner<'a, 'tcx>(\n     generics: &'tcx Generics,\n     span: Span,\n ) {\n-    if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n+    if in_external_macro(cx.sess(), span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n \n@@ -126,7 +128,7 @@ fn check_fn_inner<'a, 'tcx>(\n                         GenericArg::Type(_) => None,\n                     });\n                     for bound in lifetimes {\n-                        if bound.name.ident().name != \"'static\" && !bound.is_elided() {\n+                        if bound.name != LifetimeName::Static && !bound.is_elided() {\n                             return;\n                         }\n                         bounds_lts.push(bound);\n@@ -251,7 +253,7 @@ fn allowed_lts_from(named_generics: &[GenericParam]) -> HashSet<RefLt> {\n \n fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n     for lt in bounds_lts {\n-        if lt.name.ident().name != \"'static\" {\n+        if lt.name != LifetimeName::Static {\n             vec.push(RefLt::Named(lt.name.ident().name));\n         }\n     }\n@@ -282,7 +284,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let Some(ref lt) = *lifetime {\n-            if lt.name.ident().name == \"'static\" {\n+            if lt.name == LifetimeName::Static {\n                 self.lts.push(RefLt::Static);\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);\n@@ -338,22 +340,29 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n         match ty.node {\n-            TyRptr(ref lt, _) if lt.is_elided() => {\n+            TyKind::Rptr(ref lt, _) if lt.is_elided() => {\n                 self.record(&None);\n             },\n-            TyPath(ref path) => {\n-                self.collect_anonymous_lifetimes(path, ty);\n-            },\n-            TyImplTraitExistential(exist_ty_id, _, _) => {\n-                if let ItemExistential(ref exist_ty) = self.cx.tcx.hir.expect_item(exist_ty_id.id).node {\n-                    for bound in &exist_ty.bounds {\n-                        if let GenericBound::Outlives(_) = *bound {\n-                            self.record(&None);\n+            TyKind::Path(ref path) => {\n+                if let QPath::Resolved(_, ref path) = *path {\n+                    if let Def::Existential(def_id) = path.def {\n+                        let node_id = self.cx.tcx.hir.as_local_node_id(def_id).unwrap();\n+                        if let ItemKind::Existential(ref exist_ty) = self.cx.tcx.hir.expect_item(node_id).node {\n+                            for bound in &exist_ty.bounds {\n+                                if let GenericBound::Outlives(_) = *bound {\n+                                    self.record(&None);\n+                                }\n+                            }\n+                        } else {\n+                            unreachable!()\n                         }\n+                        walk_ty(self, ty);\n+                        return;\n                     }\n                 }\n+                self.collect_anonymous_lifetimes(path, ty);\n             }\n-            TyTraitObject(ref bounds, ref lt) => {\n+            TyKind::TraitObject(ref bounds, ref lt) => {\n                 if !lt.is_elided() {\n                     self.abort = true;\n                 }"}, {"sha": "45f9af49a15fe279cadc8d8211be17272c46ff3e", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,9 +2,11 @@\n //! floating-point literal expressions.\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast::*;\n use syntax_pos;\n-use crate::utils::{in_external_macro, snippet_opt, span_lint_and_sugg};\n+use crate::utils::{snippet_opt, span_lint_and_sugg};\n \n /// **What it does:** Warns if a long integral or floating-point constant does\n /// not contain underscores.\n@@ -227,7 +229,7 @@ enum WarningType {\n }\n \n impl WarningType {\n-    crate fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: syntax_pos::Span) {\n+    crate fn display(&self, grouping_hint: &str, cx: &EarlyContext<'_>, span: syntax_pos::Span) {\n         match self {\n             WarningType::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n@@ -279,8 +281,8 @@ impl LintPass for LiteralDigitGrouping {\n }\n \n impl EarlyLintPass for LiteralDigitGrouping {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if in_external_macro(cx, expr.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n \n@@ -291,7 +293,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n }\n \n impl LiteralDigitGrouping {\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         match lit.node {\n             LitKind::Int(..) => {\n                 // Lint integral literals.\n@@ -419,8 +421,8 @@ impl LintPass for LiteralRepresentation {\n }\n \n impl EarlyLintPass for LiteralRepresentation {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if in_external_macro(cx, expr.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n \n@@ -436,7 +438,7 @@ impl LiteralRepresentation {\n             threshold,\n         }\n     }\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         // Lint integral literals.\n         if_chain! {\n             if let LitKind::Int(..) = lit.node;"}, {"sha": "b95bc01c013daf356a5fe00633f49108656533b9", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 110, "deletions": 108, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -6,6 +6,8 @@ use rustc::hir::def_id;\n use rustc::hir::intravisit::{walk_block, walk_decl, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc::hir::map::Node::{NodeBlock, NodeExpr, NodeStmt};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::middle::region;\n // use rustc::middle::region::CodeExtent;\n use rustc::middle::expr_use_visitor::*;\n@@ -21,9 +23,9 @@ use crate::utils::{sugg, sext};\n use crate::utils::usage::mutated_variables;\n use crate::consts::{constant, Constant};\n \n-use crate::utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n+use crate::utils::{get_enclosing_block, get_parent_expr, higher, is_integer_literal, is_refutable,\n             last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt,\n-            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then};\n+            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq};\n use crate::utils::paths;\n \n /// **What it does:** Checks for for-loops that manually copy items between\n@@ -411,7 +413,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         // check for never_loop\n         match expr.node {\n-            ExprWhile(_, ref block, _) | ExprLoop(ref block, _, _) => {\n+            ExprKind::While(_, ref block, _) | ExprKind::Loop(ref block, _, _) => {\n                 match never_loop_block(block, expr.id) {\n                     NeverLoopResult::AlwaysBreak =>\n                         span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n@@ -424,7 +426,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n-        if let ExprLoop(ref block, _, LoopSource::Loop) = expr.node {\n+        if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.node {\n             // also check for empty `loop {}` statements\n             if block.stmts.is_empty() && block.expr.is_none() {\n                 span_lint(\n@@ -440,15 +442,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let inner_stmt_expr = extract_expr_from_first_stmt(block);\n             // or extract the first expression (if any) from the block\n             if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(block)) {\n-                if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n+                if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n                         MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n                             if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none()\n                                 && arms[1].pats.len() == 1 && arms[1].guard.is_none()\n                                 && is_simple_break_expr(&arms[1].body)\n                             {\n-                                if in_external_macro(cx, expr.span) {\n+                                if in_external_macro(cx.sess(), expr.span) {\n                                     return;\n                                 }\n \n@@ -476,11 +478,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n             }\n         }\n-        if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n+        if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n             if let (\n                 &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                &ExprMethodCall(ref method_path, _, ref method_args),\n+                &ExprKind::MethodCall(ref method_path, _, ref method_args),\n             ) = (pat, &match_expr.node)\n             {\n                 let iter_expr = &method_args[0];\n@@ -505,14 +507,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         // check for while loops which conditions never change\n-        if let ExprWhile(ref cond, _, _) = expr.node {\n+        if let ExprKind::While(ref cond, _, _) = expr.node {\n             check_infinite_loop(cx, cond, expr);\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n-        if let StmtSemi(ref expr, _) = stmt.node {\n-            if let ExprMethodCall(ref method, _, ref args) = expr.node {\n+        if let StmtKind::Semi(ref expr, _) = stmt.node {\n+            if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && method.ident.name == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(\n                         cx,\n@@ -584,53 +586,53 @@ fn never_loop_block(block: &Block, main_loop_id: NodeId) -> NeverLoopResult {\n \n fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n     match stmt.node {\n-        StmtSemi(ref e, ..) | StmtExpr(ref e, ..) => Some(e),\n-        StmtDecl(ref d, ..) => decl_to_expr(d),\n+        StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n+        StmtKind::Decl(ref d, ..) => decl_to_expr(d),\n     }\n }\n \n fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n     match decl.node {\n-        DeclLocal(ref local) => local.init.as_ref().map(|p| &**p),\n+        DeclKind::Local(ref local) => local.init.as_ref().map(|p| &**p),\n         _ => None,\n     }\n }\n \n fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n     match expr.node {\n-        ExprBox(ref e) |\n-        ExprUnary(_, ref e) |\n-        ExprCast(ref e, _) |\n-        ExprType(ref e, _) |\n-        ExprField(ref e, _) |\n-        ExprAddrOf(_, ref e) |\n-        ExprStruct(_, _, Some(ref e)) |\n-        ExprRepeat(ref e, _) => never_loop_expr(e, main_loop_id),\n-        ExprArray(ref es) | ExprMethodCall(_, _, ref es) | ExprTup(ref es) => {\n+        ExprKind::Box(ref e) |\n+        ExprKind::Unary(_, ref e) |\n+        ExprKind::Cast(ref e, _) |\n+        ExprKind::Type(ref e, _) |\n+        ExprKind::Field(ref e, _) |\n+        ExprKind::AddrOf(_, ref e) |\n+        ExprKind::Struct(_, _, Some(ref e)) |\n+        ExprKind::Repeat(ref e, _) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es) | ExprKind::Tup(ref es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },\n-        ExprCall(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n-        ExprBinary(_, ref e1, ref e2) |\n-        ExprAssign(ref e1, ref e2) |\n-        ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n-        ExprIf(ref e, ref e2, ref e3) => {\n+        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n+        ExprKind::Binary(_, ref e1, ref e2) |\n+        ExprKind::Assign(ref e1, ref e2) |\n+        ExprKind::AssignOp(_, ref e1, ref e2) |\n+        ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n+        ExprKind::If(ref e, ref e2, ref e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n             let e3 = e3.as_ref().map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n-        ExprLoop(ref b, _, _) => {\n+        ExprKind::Loop(ref b, _, _) => {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n-        ExprWhile(ref e, ref b, _) => {\n+        ExprKind::While(ref e, ref b, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             let result = never_loop_block(b, main_loop_id);\n             // Break can come from the inner loop so remove them.\n             combine_seq(e, absorb_break(&result))\n         },\n-        ExprMatch(ref e, ref arms, _) => {\n+        ExprKind::Match(ref e, ref arms, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             if arms.is_empty() {\n                 e\n@@ -639,8 +641,8 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n                 combine_seq(e, arms)\n             }\n         },\n-        ExprBlock(ref b, _) => never_loop_block(b, main_loop_id),\n-        ExprContinue(d) => {\n+        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Continue(d) => {\n             let id = d.target_id\n                 .expect(\"target id can only be missing in the presence of compilation errors\");\n             if id == main_loop_id {\n@@ -649,22 +651,22 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprBreak(_, _) => {\n+        ExprKind::Break(_, _) => {\n             NeverLoopResult::AlwaysBreak\n         },\n-        ExprRet(ref e) => {\n+        ExprKind::Ret(ref e) => {\n             if let Some(ref e) = *e {\n                 combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n             } else {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprStruct(_, _, None) |\n-        ExprYield(_) |\n-        ExprClosure(_, _, _, _, _) |\n-        ExprInlineAsm(_, _, _) |\n-        ExprPath(_) |\n-        ExprLit(_) => NeverLoopResult::Otherwise,\n+        ExprKind::Struct(_, _, None) |\n+        ExprKind::Yield(_) |\n+        ExprKind::Closure(_, _, _, _, _) |\n+        ExprKind::InlineAsm(_, _, _) |\n+        ExprKind::Path(_) |\n+        ExprKind::Lit(_) => NeverLoopResult::Otherwise,\n     }\n }\n \n@@ -701,7 +703,7 @@ fn check_for_loop<'a, 'tcx>(\n \n fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> bool {\n     if_chain! {\n-        if let ExprPath(ref qpath) = expr.node;\n+        if let ExprKind::Path(ref qpath) = expr.node;\n         if let QPath::Resolved(None, ref path) = *qpath;\n         if path.segments.len() == 1;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, expr.hir_id);\n@@ -741,7 +743,7 @@ struct FixedOffsetVar {\n     offset: Offset,\n }\n \n-fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n+fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     let is_slice = match ty.sty {\n         ty::TyRef(_, subty, _) => is_slice_like(cx, subty),\n         ty::TySlice(..) | ty::TyArray(..) => true,\n@@ -754,24 +756,24 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> Option<FixedOffsetVar> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: ast::NodeId) -> Option<String> {\n         match e.node {\n-            ExprLit(ref l) => match l.node {\n+            ExprKind::Lit(ref l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n             },\n-            ExprPath(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            ExprKind::Path(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n             _ => None,\n         }\n     }\n \n-    if let ExprIndex(ref seqexpr, ref idx) = expr.node {\n+    if let ExprKind::Index(ref seqexpr, ref idx) = expr.node {\n         let ty = cx.tables.expr_ty(seqexpr);\n         if !is_slice_like(cx, ty) {\n             return None;\n         }\n \n         let offset = match idx.node {\n-            ExprBinary(op, ref lhs, ref rhs) => match op.node {\n-                BinOp_::BiAdd => {\n+            ExprKind::Binary(op, ref lhs, ref rhs) => match op.node {\n+                BinOpKind::Add => {\n                     let offset_opt = if same_var(cx, lhs, var) {\n                         extract_offset(cx, rhs, var)\n                     } else if same_var(cx, rhs, var) {\n@@ -782,10 +784,10 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n \n                     offset_opt.map(Offset::positive)\n                 },\n-                BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n+                BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n                 _ => None,\n             },\n-            ExprPath(..) => if same_var(cx, idx, var) {\n+            ExprKind::Path(..) => if same_var(cx, idx, var) {\n                 Some(Offset::positive(\"0\".into()))\n             } else {\n                 None\n@@ -810,7 +812,7 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     var: ast::NodeId,\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n-        if let ExprMethodCall(ref method, _, ref args) = expr.node;\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n         if method.ident.name == \"clone\";\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n@@ -832,7 +834,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n         e: &Expr,\n         var: ast::NodeId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n-        if let Expr_::ExprAssign(ref lhs, ref rhs) = e.node {\n+        if let ExprKind::Assign(ref lhs, ref rhs) = e.node {\n             match (get_fixed_offset_var(cx, lhs, var), fetch_cloned_fixed_offset_var(cx, rhs, var)) {\n                 (Some(offset_left), Some(offset_right)) => {\n                     // Source and destination must be different\n@@ -849,7 +851,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n         }\n     }\n \n-    if let Expr_::ExprBlock(ref b, _) = body.node {\n+    if let ExprKind::Block(ref b, _) = body.node {\n         let Block {\n             ref stmts,\n             ref expr,\n@@ -859,8 +861,8 @@ fn get_indexed_assignments<'a, 'tcx>(\n         stmts\n             .iter()\n             .map(|stmt| match stmt.node {\n-                Stmt_::StmtDecl(..) => None,\n-                Stmt_::StmtExpr(ref e, _node_id) | Stmt_::StmtSemi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n+                StmtKind::Decl(..) => None,\n+                StmtKind::Expr(ref e, _node_id) | StmtKind::Semi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n             })\n             .chain(\n                 expr.as_ref()\n@@ -906,7 +908,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n \n             let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| if let Some(end) = *end {\n                 if_chain! {\n-                    if let ExprMethodCall(ref method, _, ref len_args) = end.node;\n+                    if let ExprKind::MethodCall(ref method, _, ref len_args) = end.node;\n                     if method.ident.name == \"len\";\n                     if len_args.len() == 1;\n                     if let Some(arg) = len_args.get(0);\n@@ -1098,10 +1100,10 @@ fn check_for_loop_range<'a, 'tcx>(\n \n fn is_len_call(expr: &Expr, var: Name) -> bool {\n     if_chain! {\n-        if let ExprMethodCall(ref method, _, ref len_args) = expr.node;\n+        if let ExprKind::MethodCall(ref method, _, ref len_args) = expr.node;\n         if len_args.len() == 1;\n         if method.ident.name == \"len\";\n-        if let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node;\n+        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].node;\n         if path.segments.len() == 1;\n         if path.segments[0].ident.name == var;\n         then {\n@@ -1183,7 +1185,7 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n     }\n }\n \n-fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &str) {\n+fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_name: &str) {\n     let object = snippet(cx, args[0].span, \"_\");\n     let muta = if method_name == \"iter_mut\" {\n         \"mut \"\n@@ -1201,9 +1203,9 @@ fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &s\n     )\n }\n \n-fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n+fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Expr) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n-    if let ExprMethodCall(ref method, _, ref args) = arg.node {\n+    if let ExprKind::MethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n             let method_name = &*method.ident.as_str();\n@@ -1256,7 +1258,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n }\n \n /// Check for `for` loops over `Option`s and `Results`\n-fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n+fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n     let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(\n@@ -1377,7 +1379,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n                 MutMutable => \"_mut\",\n             };\n             let arg = match arg.node {\n-                ExprAddrOf(_, ref expr) => &**expr,\n+                ExprKind::AddrOf(_, ref expr) => &**expr,\n                 _ => arg,\n             };\n \n@@ -1418,7 +1420,7 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let Categorization::Local(id) = cmt.cat {\n                 if Some(id) == self.node_id_low {\n@@ -1451,7 +1453,7 @@ impl<'tcx> MutatePairDelegate {\n     }\n }\n \n-fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr) {\n+fn check_for_mut_range_bound(cx: &LateContext<'_, '_>, arg: &Expr, body: &Expr) {\n     if let Some(higher::Range {\n         start: Some(start),\n         end: Some(end),\n@@ -1470,7 +1472,7 @@ fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr) {\n     }\n }\n \n-fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n+fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n     if let Some(sp) = span {\n         span_lint(\n             cx,\n@@ -1481,9 +1483,9 @@ fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n+fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId> {\n     if_chain! {\n-        if let ExprPath(ref qpath) = bound.node;\n+        if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n         then {\n             let def = cx.tables.qpath_def(qpath, bound.hir_id);\n@@ -1503,7 +1505,7 @@ fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n     None\n }\n \n-fn check_for_mutation(cx: &LateContext, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n+fn check_for_mutation(cx: &LateContext<'_, '_>, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n         node_id_low: bound_ids[0],\n         node_id_high: bound_ids[1],\n@@ -1598,7 +1600,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n     fn check(&mut self, idx: &'tcx Expr, seqexpr: &'tcx Expr, expr: &'tcx Expr) -> bool {\n         if_chain! {\n             // the indexed container is referenced by a name\n-            if let ExprPath(ref seqpath) = seqexpr.node;\n+            if let ExprKind::Path(ref seqpath) = seqexpr.node;\n             if let QPath::Resolved(None, ref seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n             then {\n@@ -1655,7 +1657,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n             // a range index op\n-            if let ExprMethodCall(ref meth, _, ref args) = expr.node;\n+            if let ExprKind::MethodCall(ref meth, _, ref args) = expr.node;\n             if (meth.ident.name == \"index\" && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == \"index_mut\" && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n@@ -1664,14 +1666,14 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         if_chain! {\n             // an index op\n-            if let ExprIndex(ref seqexpr, ref idx) = expr.node;\n+            if let ExprKind::Index(ref seqexpr, ref idx) = expr.node;\n             if !self.check(idx, seqexpr, expr);\n             then { return }\n         }\n \n         if_chain! {\n             // directly using a variable\n-            if let ExprPath(ref qpath) = expr.node;\n+            if let ExprKind::Path(ref qpath) = expr.node;\n             if let QPath::Resolved(None, ref path) = *qpath;\n             if path.segments.len() == 1;\n             if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n@@ -1687,20 +1689,20 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         }\n         let old = self.prefer_mutable;\n         match expr.node {\n-            ExprAssignOp(_, ref lhs, ref rhs) |\n-            ExprAssign(ref lhs, ref rhs) => {\n+            ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+            ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.prefer_mutable = true;\n                 self.visit_expr(lhs);\n                 self.prefer_mutable = false;\n                 self.visit_expr(rhs);\n             },\n-            ExprAddrOf(mutbl, ref expr) => {\n+            ExprKind::AddrOf(mutbl, ref expr) => {\n                 if mutbl == MutMutable {\n                     self.prefer_mutable = true;\n                 }\n                 self.visit_expr(expr);\n             },\n-            ExprCall(ref f, ref args) => {\n+            ExprKind::Call(ref f, ref args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n                     let ty = self.cx.tables.expr_ty_adjusted(expr);\n@@ -1713,7 +1715,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprMethodCall(_, _, ref args) => {\n+            ExprKind::MethodCall(_, _, ref args) => {\n                 let def_id = self.cx.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n@@ -1780,7 +1782,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n /// Return true if the type of expr is one that provides `IntoIterator` impls\n /// for `&T` and `&mut T`, such as `Vec`.\n #[cfg_attr(rustfmt, rustfmt_skip)]\n-fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n+fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n     let ty = cx.tables.expr_ty(e);\n@@ -1795,7 +1797,7 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, ty, &paths::BTREESET)\n }\n \n-fn is_iterable_array(ty: Ty, cx: &LateContext) -> bool {\n+fn is_iterable_array(ty: Ty<'_>, cx: &LateContext<'_, '_>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n         ty::TyArray(_, n) => (0..=32).contains(&n.assert_usize(cx.tcx).expect(\"array length\")),\n@@ -1809,8 +1811,8 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n     if block.stmts.is_empty() {\n         return None;\n     }\n-    if let StmtDecl(ref decl, _) = block.stmts[0].node {\n-        if let DeclLocal(ref local) = decl.node {\n+    if let StmtKind::Decl(ref decl, _) = block.stmts[0].node {\n+        if let DeclKind::Local(ref local) = decl.node {\n             if let Some(ref expr) = local.init {\n                 Some(expr)\n             } else {\n@@ -1829,8 +1831,8 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     match block.expr {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n         None if !block.stmts.is_empty() => match block.stmts[0].node {\n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n-            StmtDecl(..) => None,\n+            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => Some(expr),\n+            StmtKind::Decl(..) => None,\n         },\n         _ => None,\n     }\n@@ -1841,8 +1843,8 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n /// passed expression. The expression may be within a block.\n fn is_simple_break_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBreak(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprBlock(ref b, _) => match extract_first_expr(b) {\n+        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n+        ExprKind::Block(ref b, _) => match extract_first_expr(b) {\n             Some(subexpr) => is_simple_break_expr(subexpr),\n             None => false,\n         },\n@@ -1882,9 +1884,9 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                 let state = self.states.entry(def_id).or_insert(VarState::Initial);\n \n                 match parent.node {\n-                    ExprAssignOp(op, ref lhs, ref rhs) => {\n+                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                         if lhs.id == expr.id {\n-                            if op.node == BiAdd && is_integer_literal(rhs, 1) {\n+                            if op.node == BinOpKind::Add && is_integer_literal(rhs, 1) {\n                                 *state = match *state {\n                                     VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n                                     _ => VarState::DontWarn,\n@@ -1895,8 +1897,8 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                             }\n                         }\n                     },\n-                    ExprAssign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n-                    ExprAddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n+                    ExprKind::Assign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n+                    ExprKind::AddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n                     _ => (),\n                 }\n             }\n@@ -1931,7 +1933,7 @@ struct InitializeVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     fn visit_decl(&mut self, decl: &'tcx Decl) {\n         // Look for declarations of the variable\n-        if let DeclLocal(ref local) = decl.node {\n+        if let DeclKind::Local(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n                 if let PatKind::Binding(_, _, ident, _) = local.pat.node {\n                     self.name = Some(ident.name);\n@@ -1955,7 +1957,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         if self.state == VarState::DontWarn {\n             return;\n         }\n-        if expr == self.end_expr {\n+        if SpanlessEq::new(self.cx).eq_expr(&expr, self.end_expr) {\n             self.past_loop = true;\n             return;\n         }\n@@ -1969,17 +1971,17 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         if var_def_id(self.cx, expr) == Some(self.var_id) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.node {\n-                    ExprAssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n+                    ExprKind::AssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n                         self.state = VarState::DontWarn;\n                     },\n-                    ExprAssign(ref lhs, ref rhs) if lhs.id == expr.id => {\n+                    ExprKind::Assign(ref lhs, ref rhs) if lhs.id == expr.id => {\n                         self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n                             VarState::Warn\n                         } else {\n                             VarState::DontWarn\n                         }\n                     },\n-                    ExprAddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n+                    ExprKind::AddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n                     _ => (),\n                 }\n             }\n@@ -2004,8 +2006,8 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n-    if let ExprPath(ref qpath) = expr.node {\n+fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<NodeId> {\n+    if let ExprKind::Path(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(node_id) = path_res {\n             return Some(node_id);\n@@ -2016,19 +2018,19 @@ fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n \n fn is_loop(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprLoop(..) | ExprWhile(..) => true,\n+        ExprKind::Loop(..) | ExprKind::While(..) => true,\n         _ => false,\n     }\n }\n \n fn is_conditional(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprIf(..) | ExprMatch(..) => true,\n+        ExprKind::If(..) | ExprKind::Match(..) => true,\n         _ => false,\n     }\n }\n \n-fn is_nested(cx: &LateContext, match_expr: &Expr, iter_expr: &Expr) -> bool {\n+fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     if_chain! {\n         if let Some(loop_block) = get_enclosing_block(cx, match_expr.id);\n         if let Some(map::Node::NodeExpr(loop_expr)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(loop_block.id));\n@@ -2039,7 +2041,7 @@ fn is_nested(cx: &LateContext, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     false\n }\n \n-fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n+fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n     let mut id = loop_expr.id;\n     let iter_name = if let Some(name) = path_name(iter_expr) {\n         name\n@@ -2053,7 +2055,7 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n         }\n         match cx.tcx.hir.find(parent) {\n             Some(NodeExpr(expr)) => match expr.node {\n-                ExprLoop(..) | ExprWhile(..) => {\n+                ExprKind::Loop(..) | ExprKind::While(..) => {\n                     return true;\n                 },\n                 _ => (),\n@@ -2111,7 +2113,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.node {\n-            ExprAssign(ref path, _) | ExprAssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n+            ExprKind::Assign(ref path, _) | ExprKind::AssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n                 self.nesting = RuledOut;\n             },\n             _ => walk_expr(self, expr),\n@@ -2137,7 +2139,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n }\n \n fn path_name(e: &Expr) -> Option<Name> {\n-    if let ExprPath(QPath::Resolved(_, ref path)) = e.node {\n+    if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n         let segments = &path.segments;\n         if segments.len() == 1 {\n             return Some(segments[0].ident.name);\n@@ -2193,7 +2195,7 @@ struct VarCollectorVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n     fn insert_def_id(&mut self, ex: &'tcx Expr) {\n         if_chain! {\n-            if let ExprPath(ref qpath) = ex.node;\n+            if let ExprKind::Path(ref qpath) = ex.node;\n             if let QPath::Resolved(None, _) = *qpath;\n             let def = self.cx.tables.qpath_def(qpath, ex.hir_id);\n             then {\n@@ -2214,9 +2216,9 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         match ex.node {\n-            ExprPath(_) => self.insert_def_id(ex),\n+            ExprKind::Path(_) => self.insert_def_id(ex),\n             // If there is any fuction/method call\u2026 we just stop analysis\n-            ExprCall(..) | ExprMethodCall(..) => self.skip = true,\n+            ExprKind::Call(..) | ExprKind::MethodCall(..) => self.skip = true,\n \n             _ => walk_expr(self, ex),\n         }"}, {"sha": "d8b14db605f291c240626e8b10dd6537ddc7ca49", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,9 +1,11 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n use crate::utils::{get_arg_ident, is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type,\n-            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n@@ -30,10 +32,10 @@ pub struct Pass;\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n-        if let ExprMethodCall(ref method, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n             if method.ident.name == \"map\" && args.len() == 2 {\n                 match args[1].node {\n-                    ExprClosure(_, ref decl, closure_eid, _, _) => {\n+                    ExprKind::Closure(_, ref decl, closure_eid, _, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n                         let closure_expr = remove_blocks(&body.value);\n                         if_chain! {\n@@ -62,11 +64,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                     }\n                                 }\n                                 // explicit clone() calls ( .map(|x| x.clone()) )\n-                                else if let ExprMethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n+                                else if let ExprKind::MethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n                                     if clone_call.ident.name == \"clone\" &&\n                                         clone_args.len() == 1 &&\n                                         match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_name(&clone_args[0], arg_ident)\n+                                        expr_eq_name(cx, &clone_args[0], arg_ident)\n                                     {\n                                         span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                             \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -77,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             }\n                         }\n                     },\n-                    ExprPath(ref path) => if match_qpath(path, &paths::CLONE) {\n+                    ExprKind::Path(ref path) => if match_qpath(path, &paths::CLONE) {\n                         let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n                         span_help_and_lint(\n                             cx,\n@@ -98,23 +100,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn expr_eq_name(expr: &Expr, id: ast::Ident) -> bool {\n+fn expr_eq_name(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n-        ExprPath(QPath::Resolved(None, ref path)) => {\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [\n                 PathSegment {\n                     ident: id,\n                     args: None,\n                     infer_types: true,\n                 },\n             ];\n-            !path.is_global() && path.segments[..] == arg_segment\n+            !path.is_global() && SpanlessEq::new(cx).eq_path_segments(&path.segments[..], &arg_segment)\n         },\n         _ => false,\n     }\n }\n \n-fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n+fn get_type_name(cx: &LateContext<'_, '_>, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         Some(\"iterator\")\n     } else if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(arg)), &paths::OPTION) {\n@@ -124,10 +126,10 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n     }\n }\n \n-fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n+fn only_derefs(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n-        ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n-        _ => expr_eq_name(expr, id),\n+        ExprKind::Unary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n+        _ => expr_eq_name(cx, expr, id),\n     }\n }\n "}, {"sha": "6ccf8daa71d64cbe7dc45b1f6463e2a37e080032", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,7 +1,9 @@\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n-use rustc_errors::{Applicability};\n+use rustc_errors::Applicability;\n use syntax::codemap::Span;\n use crate::utils::{in_macro, iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n use crate::utils::paths;\n@@ -82,15 +84,15 @@ impl LintPass for Pass {\n     }\n }\n \n-fn is_unit_type(ty: ty::Ty) -> bool {\n+fn is_unit_type(ty: ty::Ty<'_>) -> bool {\n     match ty.sty {\n         ty::TyTuple(slice) => slice.is_empty(),\n         ty::TyNever => true,\n         _ => false,\n     }\n }\n \n-fn is_unit_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n+fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n \n     if let ty::TyFnDef(id, _) = ty.sty {\n@@ -101,26 +103,26 @@ fn is_unit_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n     false\n }\n \n-fn is_unit_expression(cx: &LateContext, expr: &hir::Expr) -> bool {\n+fn is_unit_expression(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     is_unit_type(cx.tables.expr_ty(expr))\n }\n \n /// The expression inside a closure may or may not have surrounding braces and\n /// semicolons, which causes problems when generating a suggestion. Given an\n /// expression that evaluates to '()' or '!', recursively remove useless braces\n /// and semi-colons until is suitable for including in the suggestion template\n-fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Span> {\n+fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) -> Option<Span> {\n     if !is_unit_expression(cx, expr) {\n         return None;\n     }\n \n     match expr.node {\n-        hir::ExprCall(_, _) |\n-        hir::ExprMethodCall(_, _, _) => {\n+        hir::ExprKind::Call(_, _) |\n+        hir::ExprKind::MethodCall(_, _, _) => {\n             // Calls can't be reduced any more\n             Some(expr.span)\n         },\n-        hir::ExprBlock(ref block, _) => {\n+        hir::ExprKind::Block(ref block, _) => {\n             match (&block.stmts[..], block.expr.as_ref()) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n@@ -131,9 +133,9 @@ fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<S\n                     // If block only contains statements,\n                     // reduce `{ X; }` to `X` or `X;`\n                     match inner_stmt.node {\n-                        hir::StmtDecl(ref d, _) => Some(d.span),\n-                        hir::StmtExpr(ref e, _) => Some(e.span),\n-                        hir::StmtSemi(_, _) => Some(inner_stmt.span),\n+                        hir::StmtKind::Decl(ref d, _) => Some(d.span),\n+                        hir::StmtKind::Expr(ref e, _) => Some(e.span),\n+                        hir::StmtKind::Semi(_, _) => Some(inner_stmt.span),\n                     }\n                 },\n                 _ => {\n@@ -151,7 +153,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<S\n }\n \n fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Option<(&'tcx hir::Arg, &'a hir::Expr)> {\n-    if let hir::ExprClosure(_, ref decl, inner_expr_id, _, _) = expr.node {\n+    if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.node {\n         let body = cx.tcx.hir.body(inner_expr_id);\n         let body_expr = &body.value;\n \n@@ -173,10 +175,10 @@ fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Op\n /// `y` => `_y`\n ///\n /// Anything else will return `_`.\n-fn let_binding_name(cx: &LateContext, var_arg: &hir::Expr) -> String {\n+fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr) -> String {\n     match &var_arg.node {\n-        hir::ExprField(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n-        hir::ExprPath(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n+        hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n+        hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n         _ => \"_\".to_string()\n     }\n }\n@@ -189,7 +191,7 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     )\n }\n \n-fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n+fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n     let var_arg = &map_args[0];\n     let fn_arg = &map_args[1];\n \n@@ -242,13 +244,13 @@ fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_ar\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt) {\n         if in_macro(stmt.span) {\n             return;\n         }\n \n-        if let hir::StmtSemi(ref expr, _) = stmt.node {\n-            if let hir::ExprMethodCall(_, _, _) = expr.node {\n+        if let hir::StmtKind::Semi(ref expr, _) = stmt.node {\n+            if let hir::ExprKind::MethodCall(_, _, _) = expr.node {\n                 if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n                     lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n                 }"}, {"sha": "c7452f0027e914eb1debac9fb752d8fc9b8ac84e", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,12 +1,14 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use std::cmp::Ordering;\n use std::collections::Bound;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use crate::utils::paths;\n-use crate::utils::{expr_block, in_external_macro, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg,\n+use crate::utils::{expr_block, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg,\n             remove_blocks, snippet, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n use crate::utils::sugg::Sugg;\n use crate::consts::{constant, Constant};\n@@ -181,31 +183,31 @@ impl LintPass for MatchPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if in_external_macro(cx, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n+        if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.node {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n             check_wild_err_arm(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n         }\n-        if let ExprMatch(ref ex, ref arms, _) = expr.node {\n+        if let ExprKind::Match(ref ex, ref arms, _) = expr.node {\n             check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n }\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n-fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n       arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n       arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n         let els = remove_blocks(&arms[1].body);\n         let els = if is_unit_expr(els) {\n             None\n-        } else if let ExprBlock(_, _) = els.node {\n+        } else if let ExprKind::Block(_, _) = els.node {\n             // matches with blocks that contain statements are prettier as `if let + else`\n             Some(els)\n         } else {\n@@ -220,13 +222,13 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     }\n }\n \n-fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n-    if arms[1].pats[0].node == PatKind::Wild {\n+fn check_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+    if is_wild(&arms[1].pats[0]) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n \n-fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+fn report_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n     let lint = if els.is_some() {\n         SINGLE_MATCH_ELSE\n     } else {\n@@ -250,7 +252,7 @@ fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n     );\n }\n \n-fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty, els: Option<&Expr>) {\n+fn check_single_match_opt_like(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty<'_>, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n     let candidates = &[\n         (&paths::COW, \"Borrowed\"),\n@@ -265,7 +267,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n             // contains any non wildcard patterns? e.g. Err(err)\n-            if inner.iter().any(|pat| pat.node != PatKind::Wild) {\n+            if !inner.iter().all(is_wild) {\n                 return;\n             }\n             print::to_string(print::NO_ANN, |s| s.print_qpath(path, false))\n@@ -282,7 +284,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     }\n }\n \n-fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tables.expr_ty(ex).sty == ty::TyBool {\n         span_lint_and_then(\n@@ -294,7 +296,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                 if arms.len() == 2 && arms[0].pats.len() == 1 {\n                     // no guards\n                     let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n-                        if let ExprLit(ref lit) = arm_bool.node {\n+                        if let ExprKind::Lit(ref lit) = arm_bool.node {\n                             match lit.node {\n                                 LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n                                 LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n@@ -356,16 +358,23 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr,\n     }\n }\n \n-fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n+fn is_wild(pat: &impl std::ops::Deref<Target = Pat>) -> bool {\n+    match pat.node {\n+        PatKind::Wild => true,\n+        _ => false,\n+    }\n+}\n+\n+fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pats[0].node {\n                 let path_str = print::to_string(print::NO_ANN, |s| s.print_qpath(path, false));\n                 if_chain! {\n                     if path_str == \"Err\";\n-                    if inner.iter().any(|pat| pat.node == PatKind::Wild);\n-                    if let ExprBlock(ref block, _) = arm.body.node;\n+                    if inner.iter().any(is_wild);\n+                    if let ExprKind::Block(ref block, _) = arm.body.node;\n                     if is_panic_block(block);\n                     then {\n                         // `Err(_)` arm with `panic!` found\n@@ -396,10 +405,10 @@ fn is_panic_block(block: &Block) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n-        let (title, msg) = if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+        let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n             suggs.push((ex.span, Sugg::hir(cx, inner, \"..\").to_string()));\n             (\n                 \"you don't need to add `&` to both the expression and the patterns\",\n@@ -427,7 +436,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr)\n     }\n }\n \n-fn check_match_as_ref(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n         arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n         arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n@@ -533,8 +542,8 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n \n fn is_unit_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprTup(ref v) if v.is_empty() => true,\n-        ExprBlock(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        ExprKind::Tup(ref v) if v.is_empty() => true,\n+        ExprKind::Block(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n         _ => false,\n     }\n }\n@@ -554,10 +563,10 @@ fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n         if let PatKind::Binding(rb, _, ident, _) = pats[0].node;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprCall(ref e, ref args) = remove_blocks(&arm.body).node;\n-        if let ExprPath(ref some_path) = e.node;\n+        if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).node;\n+        if let ExprKind::Path(ref some_path) = e.node;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n-        if let ExprPath(ref qpath) = args[0].node;\n+        if let ExprKind::Path(ref qpath) = args[0].node;\n         if let &QPath::Resolved(_, ref path2) = qpath;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {"}, {"sha": "88c2445864686c080bbaad9cfe548f1f05c11831", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::*;\n-use rustc::hir::{Expr, ExprCall, ExprPath};\n+use rustc::{declare_lint, lint_array};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n \n /// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n@@ -30,8 +31,8 @@ impl LintPass for MemForget {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(ref qpath) = path_expr.node {\n+        if let ExprKind::Call(ref path_expr, ref args) = e.node {\n+            if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.tables.expr_ty(&args[0]);"}, {"sha": "28ff303fc83eb9023c310898b69c07bf29fe46bd", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 91, "deletions": 86, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,16 +1,19 @@\n+use matches::matches;\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use rustc::hir::def::Def;\n use std::borrow::Cow;\n use std::fmt;\n use std::iter;\n use syntax::ast;\n use syntax::codemap::{Span, BytePos};\n-use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self,\n+use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self,\n             is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n             match_type, method_chain_args, match_var, return_ty, remove_blocks, same_tys, single_segment_path, snippet,\n-            span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n use crate::utils::paths;\n use crate::utils::sugg;\n use crate::consts::{constant, Constant};\n@@ -718,7 +721,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         match expr.node {\n-            hir::ExprMethodCall(ref method_call, ref method_span, ref args) => {\n+            hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args) => {\n                 // Chain calls\n                 // GET_UNWRAP needs to be checked before general `UNWRAP` lints\n                 if let Some(arglists) = method_chain_args(expr, &[\"get\", \"unwrap\"]) {\n@@ -789,12 +792,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     _ => (),\n                 }\n             },\n-            hir::ExprBinary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n                     expr,\n                     chain: lhs,\n                     other: rhs,\n-                    eq: op.node == hir::BiEq,\n+                    eq: op.node == hir::BinOpKind::Eq,\n                 };\n                 lint_binary_expr_with_method_call(cx, &mut info);\n             },\n@@ -803,7 +806,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, implitem: &'tcx hir::ImplItem) {\n-        if in_external_macro(cx, implitem.span) {\n+        if in_external_macro(cx.sess(), implitem.span) {\n             return;\n         }\n         let name = implitem.ident.name;\n@@ -813,15 +816,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n             if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir.body(id)).next();\n-            if let hir::ItemImpl(_, _, _, _, None, ref self_ty, _) = item.node;\n+            if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n             then {\n                 if cx.access_levels.is_exported(implitem.id) {\n                 // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if name == method_name &&\n                         sig.decl.inputs.len() == n_args &&\n-                        out_type.matches(&sig.decl.output) &&\n-                        self_kind.matches(first_arg_ty, first_arg, self_ty, false, &implitem.generics) {\n+                        out_type.matches(cx, &sig.decl.output) &&\n+                        self_kind.matches(cx, first_arg_ty, first_arg, self_ty, false, &implitem.generics) {\n                             span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                                 \"defining a method called `{}` on this type; consider implementing \\\n                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -838,9 +841,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         if conv.check(&name.as_str());\n                         if !self_kinds\n                             .iter()\n-                            .any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics));\n+                            .any(|k| k.matches(cx, first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics));\n                         then {\n-                            let lint = if item.vis == hir::Visibility::Public {\n+                            let lint = if item.vis.node.is_pub() {\n                                 WRONG_PUB_SELF_CONVENTION\n                             } else {\n                                 WRONG_SELF_CONVENTION\n@@ -873,10 +876,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n /// Checks for the `OR_FUN_CALL` lint.\n-fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         fun: &hir::Expr,\n         self_expr: &hir::Expr,\n@@ -889,7 +892,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n         }\n \n         if name == \"unwrap_or\" {\n-            if let hir::ExprPath(ref qpath) = fun.node {\n+            if let hir::ExprKind::Path(ref qpath) = fun.node {\n                 let path = &*last_path_segment(qpath).ident.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n@@ -921,7 +924,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n     /// Check for `*or(foo())`.\n     #[allow(too_many_arguments)]\n     fn check_general_case(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         method_span: Span,\n         fun_span: Span,\n@@ -964,7 +967,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n             return;\n         }\n \n-        let sugg: Cow<_> = match (fn_has_arguments, !or_has_args) {\n+        let sugg: Cow<'_, _> = match (fn_has_arguments, !or_has_args) {\n             (true, _) => format!(\"|_| {}\", snippet(cx, arg.span, \"..\")).into(),\n             (false, false) => format!(\"|| {}\", snippet(cx, arg.span, \"..\")).into(),\n             (false, true) => snippet(cx, fun_span, \"..\"),\n@@ -982,13 +985,13 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n \n     if args.len() == 2 {\n         match args[1].node {\n-            hir::ExprCall(ref fun, ref or_args) => {\n+            hir::ExprKind::Call(ref fun, ref or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n                     check_general_case(cx, name, method_span, fun.span, &args[0], &args[1], or_has_args, expr.span);\n                 }\n             },\n-            hir::ExprMethodCall(_, span, ref or_args) => {\n+            hir::ExprKind::MethodCall(_, span, ref or_args) => {\n                 check_general_case(cx, name, method_span, span, &args[0], &args[1], !or_args.is_empty(), expr.span)\n             },\n             _ => {},\n@@ -997,12 +1000,12 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n }\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n-fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     fn extract_format_args(arg: &hir::Expr) -> Option<&hir::HirVec<hir::Expr>> {\n-        if let hir::ExprAddrOf(_, ref addr_of) = arg.node {\n-            if let hir::ExprCall(ref inner_fun, ref inner_args) = addr_of.node {\n+        if let hir::ExprKind::AddrOf(_, ref addr_of) = arg.node {\n+            if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = addr_of.node {\n                 if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n-                    if let hir::ExprCall(_, ref format_args) = inner_args[0].node {\n+                    if let hir::ExprKind::Call(_, ref format_args) = inner_args[0].node {\n                         return Some(format_args);\n                     }\n                 }\n@@ -1012,10 +1015,10 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n         None\n     }\n \n-    fn generate_format_arg_snippet(cx: &LateContext, a: &hir::Expr) -> String {\n-        if let hir::ExprAddrOf(_, ref format_arg) = a.node {\n-            if let hir::ExprMatch(ref format_arg_expr, _, _) = format_arg.node {\n-                if let hir::ExprTup(ref format_arg_expr_tup) = format_arg_expr.node {\n+    fn generate_format_arg_snippet(cx: &LateContext<'_, '_>, a: &hir::Expr) -> String {\n+        if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n+            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n+                if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n                     return snippet(cx, format_arg_expr_tup[0].span, \"..\").into_owned();\n                 }\n             }\n@@ -1025,7 +1028,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n     }\n \n     fn check_general_case(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         method_span: Span,\n         self_expr: &hir::Expr,\n@@ -1076,7 +1079,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n             return;\n         }\n \n-        let sugg: Cow<_> = snippet(cx, arg.span, \"..\");\n+        let sugg: Cow<'_, _> = snippet(cx, arg.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,\n@@ -1090,14 +1093,14 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n \n     if args.len() == 2 {\n         match args[1].node {\n-            hir::ExprLit(_) => {},\n+            hir::ExprKind::Lit(_) => {},\n             _ => check_general_case(cx, name, method_span, &args[0], &args[1], expr.span),\n         }\n     }\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty) {\n+fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty<'_>) {\n     let ty = cx.tables.expr_ty(expr);\n     if let ty::TyRef(_, inner, _) = arg_ty.sty {\n         if let ty::TyRef(_, innermost, _) = inner.sty {\n@@ -1133,14 +1136,14 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n                 match cx.tcx.hir.get(parent) {\n                     hir::map::NodeExpr(parent) => match parent.node {\n                         // &*x is a nop, &x.clone() is not\n-                        hir::ExprAddrOf(..) |\n+                        hir::ExprKind::AddrOf(..) |\n                         // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                        hir::ExprMethodCall(..) => return,\n+                        hir::ExprKind::MethodCall(..) => return,\n                         _ => {},\n                     }\n                     hir::map::NodeStmt(stmt) => {\n-                        if let hir::StmtDecl(ref decl, _) = stmt.node {\n-                            if let hir::DeclLocal(ref loc) = decl.node {\n+                        if let hir::StmtKind::Decl(ref decl, _) = stmt.node {\n+                            if let hir::DeclKind::Local(ref loc) = decl.node {\n                                 if let hir::PatKind::Ref(..) = loc.pat.node {\n                                     // let ref y = *x borrows x, let ref y = x.clone() does not\n                                     return;\n@@ -1165,7 +1168,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n     }\n }\n \n-fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n+fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n \n     if let ty::TyAdt(_, subst) = obj_ty.sty {\n@@ -1191,7 +1194,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n }\n \n \n-fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n@@ -1220,18 +1223,18 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     }\n }\n \n-fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n     if match_type(cx, obj_ty, &paths::STRING) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n-fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n+fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n     if_chain! {\n-        if let hir::ExprCall(ref fun, ref args) = new.node;\n+        if let hir::ExprKind::Call(ref fun, ref args) = new.node;\n         if args.len() == 1;\n-        if let hir::ExprPath(ref path) = fun.node;\n+        if let hir::ExprKind::Path(ref path) = fun.node;\n         if let Def::Method(did) = cx.tables.qpath_def(path, fun.hir_id);\n         if match_def_path(cx.tcx, did, &paths::CSTRING_NEW);\n         then {\n@@ -1248,7 +1251,7 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     }\n }\n \n-fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n+fn lint_iter_cloned_collect(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n     if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC)\n         && derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n     {\n@@ -1262,7 +1265,7 @@ fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir\n     }\n }\n \n-fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n+fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n     // Check that this is a call to Iterator::fold rather than just some function called fold\n     if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n@@ -1272,20 +1275,20 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n         \"Expected fold_args to have three entries - the receiver, the initial value and the closure\");\n \n     fn check_fold_with_op(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         fold_args: &[hir::Expr],\n-        op: hir::BinOp_,\n+        op: hir::BinOpKind,\n         replacement_method_name: &str,\n         replacement_has_args: bool) {\n \n         if_chain! {\n             // Extract the body of the closure passed to fold\n-            if let hir::ExprClosure(_, _, body_id, _, _) = fold_args[2].node;\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].node;\n             let closure_body = cx.tcx.hir.body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n-            if let hir::ExprBinary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n+            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n             if bin_op.node == op;\n \n             // Extract the names of the two arguments to the closure\n@@ -1329,19 +1332,19 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n \n     // Check if the first argument to .fold is a suitable literal\n     match fold_args[1].node {\n-        hir::ExprLit(ref lit) => {\n+        hir::ExprKind::Lit(ref lit) => {\n             match lit.node {\n                 ast::LitKind::Bool(false) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOp_::BiOr, \"any\", true\n+                    cx, fold_args, hir::BinOpKind::Or, \"any\", true\n                 ),\n                 ast::LitKind::Bool(true) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOp_::BiAnd, \"all\", true\n+                    cx, fold_args, hir::BinOpKind::And, \"all\", true\n                 ),\n                 ast::LitKind::Int(0, _) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOp_::BiAdd, \"sum\", false\n+                    cx, fold_args, hir::BinOpKind::Add, \"sum\", false\n                 ),\n                 ast::LitKind::Int(1, _) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOp_::BiMul, \"product\", false\n+                    cx, fold_args, hir::BinOpKind::Mul, \"product\", false\n                 ),\n                 _ => return\n             }\n@@ -1350,7 +1353,7 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n     };\n }\n \n-fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n+fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n@@ -1374,7 +1377,7 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is\n     );\n }\n \n-fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n+fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n     let expr_ty = cx.tables.expr_ty(&get_args[0]);\n@@ -1413,7 +1416,7 @@ fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], i\n     );\n }\n \n-fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n+fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         span_lint(\n@@ -1425,8 +1428,8 @@ fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::Sugg<'static>> {\n-    fn may_slice(cx: &LateContext, ty: Ty) -> bool {\n+fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Option<sugg::Sugg<'static>> {\n+    fn may_slice(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyAdt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n@@ -1437,7 +1440,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n         }\n     }\n \n-    if let hir::ExprMethodCall(ref path, _, ref args) = expr.node {\n+    if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n         if path.ident.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n@@ -1458,7 +1461,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n }\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n+fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n@@ -1486,7 +1489,7 @@ fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n }\n \n /// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n+fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n     // lint if the caller of `ok()` is a `Result`\n     if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT) {\n         let result_type = cx.tables.expr_ty(&ok_args[0]);\n@@ -1504,7 +1507,7 @@ fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n }\n \n /// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n+fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n         // get snippets for args to map() and unwrap_or()\n@@ -1615,7 +1618,7 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n     if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n-        let map_or_arg_is_none = if let hir::Expr_::ExprPath(ref qpath) = map_or_args[1].node {\n+        let map_or_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].node {\n             match_qpath(qpath, &paths::OPTION_NONE)\n         } else {\n             false\n@@ -1762,7 +1765,7 @@ struct BinaryExprInfo<'a> {\n }\n \n /// Checks for the `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n-fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, info: &mut BinaryExprInfo) {\n+fn lint_binary_expr_with_method_call(cx: &LateContext<'_, '_>, info: &mut BinaryExprInfo<'_>) {\n     macro_rules! lint_with_both_lhs_and_rhs {\n         ($func:ident, $cx:expr, $info:ident) => {\n             if !$func($cx, $info) {\n@@ -1781,18 +1784,18 @@ fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, i\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n-fn lint_chars_cmp<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    info: &BinaryExprInfo,\n+fn lint_chars_cmp(\n+    cx: &LateContext<'_, '_>,\n+    info: &BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,\n     suggest: &str,\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprCall(ref fun, ref arg_char) = info.other.node;\n+        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.node;\n         if arg_char.len() == 1;\n-        if let hir::ExprPath(ref qpath) = fun.node;\n+        if let hir::ExprKind::Path(ref qpath) = fun.node;\n         if let Some(segment) = single_segment_path(qpath);\n         if segment.ident.name == \"Some\";\n         then {\n@@ -1821,12 +1824,12 @@ fn lint_chars_cmp<'a, 'tcx>(\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint.\n-fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_NEXT_CMP, \"ends_with\") {\n         true\n     } else {\n@@ -1837,14 +1840,14 @@ fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    info: &BinaryExprInfo,\n+    info: &BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,\n     suggest: &str,\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprLit(ref lit) = info.other.node;\n+        if let hir::ExprKind::Lit(ref lit) = info.other.node;\n         if let ast::LitKind::Char(c) = lit.node;\n         then {\n             span_lint_and_sugg(\n@@ -1868,12 +1871,12 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n-fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n-fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     if lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {\n@@ -1904,7 +1907,7 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hi\n }\n \n /// Checks for the `USELESS_ASREF` lint.\n-fn lint_asref(cx: &LateContext, expr: &hir::Expr, call_name: &str, as_ref_args: &[hir::Expr]) {\n+fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_ref_args: &[hir::Expr]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n@@ -1928,7 +1931,7 @@ fn lint_asref(cx: &LateContext, expr: &hir::Expr, call_name: &str, as_ref_args:\n }\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n-fn get_error_type<'a>(cx: &LateContext, ty: Ty<'a>) -> Option<Ty<'a>> {\n+fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         if match_type(cx, ty, &paths::RESULT) {\n             substs.types().nth(1)\n@@ -2030,6 +2033,7 @@ enum SelfKind {\n impl SelfKind {\n     fn matches(\n         self,\n+        cx: &LateContext<'_, '_>,\n         ty: &hir::Ty,\n         arg: &hir::Arg,\n         self_ty: &hir::Ty,\n@@ -2047,7 +2051,7 @@ impl SelfKind {\n         // `Self`, `&mut Self`,\n         // and `Box<Self>`, including the equivalent types with `Foo`.\n \n-        let is_actually_self = |ty| is_self_ty(ty) || ty == self_ty;\n+        let is_actually_self = |ty| is_self_ty(ty) || SpanlessEq::new(cx).eq_ty(ty, self_ty);\n         if is_self(arg) {\n             match self {\n                 SelfKind::Value => is_actually_self(ty),\n@@ -2056,7 +2060,7 @@ impl SelfKind {\n                         return true;\n                     }\n                     match ty.node {\n-                        hir::TyRptr(_, ref mt_ty) => {\n+                        hir::TyKind::Rptr(_, ref mt_ty) => {\n                             let mutability_match = if self == SelfKind::Ref {\n                                 mt_ty.mutbl == hir::MutImmutable\n                             } else {\n@@ -2127,8 +2131,8 @@ fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Gener\n fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n     match (&ty.node, &self_ty.node) {\n         (\n-            &hir::TyPath(hir::QPath::Resolved(_, ref ty_path)),\n-            &hir::TyPath(hir::QPath::Resolved(_, ref self_ty_path)),\n+            &hir::TyKind::Path(hir::QPath::Resolved(_, ref ty_path)),\n+            &hir::TyKind::Path(hir::QPath::Resolved(_, ref self_ty_path)),\n         ) => ty_path\n             .segments\n             .iter()\n@@ -2139,7 +2143,7 @@ fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n }\n \n fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n-    if let hir::TyPath(ref path) = ty.node {\n+    if let hir::TyKind::Path(ref path) = ty.node {\n         single_segment_path(path)\n     } else {\n         None\n@@ -2156,7 +2160,7 @@ impl Convention {\n }\n \n impl fmt::Display for Convention {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n             Convention::Eq(this) => this.fmt(f),\n             Convention::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n@@ -2173,20 +2177,21 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(self, ty: &hir::FunctionRetTy) -> bool {\n+    fn matches(self, cx: &LateContext<'_, '_>, ty: &hir::FunctionRetTy) -> bool {\n+        let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyKind::Tup(vec![].into()));\n         match (self, ty) {\n             (OutType::Unit, &hir::DefaultReturn(_)) => true,\n-            (OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n+            (OutType::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n             (OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n-            (OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n-            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyRptr(_, _)),\n+            (OutType::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n+            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n             _ => false,\n         }\n     }\n }\n \n fn is_bool(ty: &hir::Ty) -> bool {\n-    if let hir::TyPath(ref p) = ty.node {\n+    if let hir::TyKind::Path(ref p) = ty.node {\n         match_qpath(p, &[\"bool\"])\n     } else {\n         false"}, {"sha": "bc573841cc80d0651c6a3ff0c670bb56eba1feeb", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,7 @@ use crate::consts::{constant_simple, Constant};\n use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use std::cmp::Ordering;\n \n /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n@@ -65,9 +66,9 @@ enum MinMax {\n     Max,\n }\n \n-fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n-    if let ExprCall(ref path, ref args) = expr.node {\n-        if let ExprPath(ref qpath) = path.node {\n+fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n+    if let ExprKind::Call(ref path, ref args) = expr.node {\n+        if let ExprKind::Path(ref qpath) = path.node {\n             opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)).and_then(|def_id| {\n                 if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n                     fetch_const(cx, args, MinMax::Min)\n@@ -85,7 +86,7 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n     }\n }\n \n-fn fetch_const<'a>(cx: &LateContext, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n+fn fetch_const<'a>(cx: &LateContext<'_, '_>, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n     if args.len() != 2 {\n         return None;\n     }"}, {"sha": "b01d24a1ad33143b26535c5fe2515844e71f18da", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,12 +1,15 @@\n use crate::reexport::*;\n+use matches::matches;\n use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use syntax::codemap::{ExpnFormat, Span};\n use crate::utils::{get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal,\n             iter_input_pats, last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint,\n-            span_lint_and_then, walk_ptrs_ty};\n+            span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use crate::utils::sugg::Sugg;\n use syntax::ast::{LitKind, CRATE_NODE_ID};\n use crate::consts::{constant, Constant};\n@@ -269,8 +272,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx Stmt) {\n         if_chain! {\n-            if let StmtDecl(ref d, _) = s.node;\n-            if let DeclLocal(ref l) = d.node;\n+            if let StmtKind::Decl(ref d, _) = s.node;\n+            if let DeclKind::Local(ref l) = d.node;\n             if let PatKind::Binding(an, _, i, None) = l.pat.node;\n             if let Some(ref init) = l.init;\n             then {\n@@ -303,17 +306,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n         };\n         if_chain! {\n-            if let StmtSemi(ref expr, _) = s.node;\n-            if let Expr_::ExprBinary(ref binop, ref a, ref b) = expr.node;\n-            if binop.node == BiAnd || binop.node == BiOr;\n+            if let StmtKind::Semi(ref expr, _) = s.node;\n+            if let ExprKind::Binary(ref binop, ref a, ref b) = expr.node;\n+            if binop.node == BinOpKind::And || binop.node == BinOpKind::Or;\n             if let Some(sugg) = Sugg::hir_opt(cx, a);\n             then {\n                 span_lint_and_then(cx,\n                     SHORT_CIRCUIT_STATEMENT,\n                     s.span,\n                     \"boolean short circuit operator in statement may be clearer using an explicit test\",\n                     |db| {\n-                        let sugg = if binop.node == BiOr { !sugg } else { sugg };\n+                        let sugg = if binop.node == BinOpKind::Or { !sugg } else { sugg };\n                         db.span_suggestion(s.span, \"replace it with\",\n                                            format!(\"if {} {{ {}; }}\", sugg, &snippet(cx, b.span, \"..\")));\n                     });\n@@ -323,23 +326,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n-            ExprCast(ref e, ref ty) => {\n+            ExprKind::Cast(ref e, ref ty) => {\n                 check_cast(cx, expr.span, e, ty);\n                 return;\n             },\n-            ExprBinary(ref cmp, ref left, ref right) => {\n+            ExprKind::Binary(ref cmp, ref left, ref right) => {\n                 let op = cmp.node;\n                 if op.is_comparison() {\n-                    if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n+                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.node {\n                         check_nan(cx, path, expr);\n                     }\n-                    if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n+                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = right.node {\n                         check_nan(cx, path, expr);\n                     }\n                     check_to_owned(cx, left, right);\n                     check_to_owned(cx, right, left);\n                 }\n-                if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n+                if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n                     if is_allowed(cx, left) || is_allowed(cx, right) {\n                         return;\n                     }\n@@ -367,7 +370,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         );\n                         db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n                     });\n-                } else if op == BiRem && is_integer_literal(right, 1) {\n+                } else if op == BinOpKind::Rem && is_integer_literal(right, 1) {\n                     span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n             },\n@@ -378,7 +381,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         let binding = match expr.node {\n-            ExprPath(ref qpath) => {\n+            ExprKind::Path(ref qpath) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n@@ -392,7 +395,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     None\n                 }\n             },\n-            ExprField(_, ident) => {\n+            ExprKind::Field(_, ident) => {\n                 let name = ident.as_str();\n                 if name.starts_with('_') && !name.starts_with(\"__\") {\n                     Some(name)\n@@ -418,7 +421,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ident, Some(ref right)) = pat.node {\n-            if right.node == PatKind::Wild {\n+            if let PatKind::Wild = right.node {\n                 span_lint(\n                     cx,\n                     REDUNDANT_PATTERN,\n@@ -430,7 +433,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n+fn check_nan(cx: &LateContext<'_, '_>, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n         if let Some(seg) = path.segments.last() {\n             if seg.ident.name == \"NAN\" {\n@@ -461,20 +464,20 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n     }\n }\n \n-fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_float(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n-fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n+fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n     let (arg_ty, snip) = match expr.node {\n-        ExprMethodCall(.., ref args) if args.len() == 1 => {\n+        ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n                 (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n-        ExprCall(ref path, ref v) if v.len() == 1 => if let ExprPath(ref path) = path.node {\n+        ExprKind::Call(ref path, ref v) if v.len() == 1 => if let ExprKind::Path(ref path) = path.node {\n             if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n                 (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n             } else {\n@@ -520,7 +523,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n             let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n             if parent_impl != CRATE_NODE_ID {\n                 if let map::NodeItem(item) = cx.tcx.hir.get(parent_impl) {\n-                    if let ItemImpl(.., Some(ref trait_ref), _, _) = item.node {\n+                    if let ItemKind::Impl(.., Some(ref trait_ref), _, _) = item.node {\n                         if trait_ref.path.def.def_id() == partial_eq_trait_id {\n                             // we are implementing PartialEq, don't suggest not doing `to_owned`, otherwise\n                             // we go into\n@@ -539,10 +542,10 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n /// Heuristic to see if an expression is used. Should be compatible with\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n-fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n-            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n+            ExprKind::Assign(_, ref rhs) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n             _ => is_used(cx, parent),\n         }\n     } else {\n@@ -562,17 +565,17 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n }\n \n /// Test whether `def` is a variable defined outside a macro.\n-fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n+fn non_macro_local(cx: &LateContext<'_, '_>, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(id) | def::Def::Upvar(id, _, _) => !in_macro(cx.tcx.hir.span(id)),\n         _ => false,\n     }\n }\n \n-fn check_cast(cx: &LateContext, span: Span, e: &Expr, ty: &Ty) {\n+fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr, ty: &Ty) {\n     if_chain! {\n-        if let TyPtr(MutTy { mutbl, .. }) = ty.node;\n-        if let ExprLit(ref lit) = e.node;\n+        if let TyKind::Ptr(MutTy { mutbl, .. }) = ty.node;\n+        if let ExprKind::Lit(ref lit) = e.node;\n         if let LitKind::Int(value, ..) = lit.node;\n         if value == 0;\n         if !in_constant(cx, e.id);"}, {"sha": "9b8e0743f39354895428940acabf2673d4ed1e54", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,10 +1,12 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use std::collections::HashMap;\n use std::char;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n-use crate::utils::{constants, in_external_macro, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_then};\n+use crate::utils::{constants, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_then};\n \n /// **What it does:** Checks for structure field patterns bound to wildcards.\n ///\n@@ -187,7 +189,7 @@ impl LintPass for MiscEarly {\n }\n \n impl EarlyLintPass for MiscEarly {\n-    fn check_generics(&mut self, cx: &EarlyContext, gen: &Generics) {\n+    fn check_generics(&mut self, cx: &EarlyContext<'_>, gen: &Generics) {\n         for param in &gen.params {\n             if let GenericParamKind::Type { .. } = param.kind {\n                 let name = param.ident.as_str();\n@@ -203,7 +205,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &EarlyContext, pat: &Pat) {\n+    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n         if let PatKind::Struct(ref npat, ref pfields, _) = pat.node {\n             let mut wilds = 0;\n             let type_name = npat.segments\n@@ -213,7 +215,7 @@ impl EarlyLintPass for MiscEarly {\n                 .name;\n \n             for field in pfields {\n-                if field.node.pat.node == PatKind::Wild {\n+                if let PatKind::Wild = field.node.pat.node {\n                     wilds += 1;\n                 }\n             }\n@@ -231,14 +233,15 @@ impl EarlyLintPass for MiscEarly {\n                 let mut normal = vec![];\n \n                 for field in pfields {\n-                    if field.node.pat.node != PatKind::Wild {\n-                        if let Ok(n) = cx.sess().codemap().span_to_snippet(field.span) {\n+                    match field.node.pat.node {\n+                        PatKind::Wild => {},\n+                        _ => if let Ok(n) = cx.sess().codemap().span_to_snippet(field.span) {\n                             normal.push(n);\n-                        }\n+                        },\n                     }\n                 }\n                 for field in pfields {\n-                    if field.node.pat.node == PatKind::Wild {\n+                    if let PatKind::Wild = field.node.pat.node {\n                         wilds -= 1;\n                         if wilds > 0 {\n                             span_lint(\n@@ -263,7 +266,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, _: Span, _: NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, _: FnKind<'_>, decl: &FnDecl, _: Span, _: NodeId) {\n         let mut registered_names: HashMap<String, Span> = HashMap::new();\n \n         for arg in &decl.inputs {\n@@ -290,8 +293,8 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if in_external_macro(cx, expr.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n         match expr.node {\n@@ -322,7 +325,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_block(&mut self, cx: &EarlyContext, block: &Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n         for w in block.stmts.windows(2) {\n             if_chain! {\n                 if let StmtKind::Local(ref local) = w[0].node;\n@@ -349,7 +352,7 @@ impl EarlyLintPass for MiscEarly {\n }\n \n impl MiscEarly {\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         if_chain! {\n             if let LitKind::Int(value, ..) = lit.node;\n             if let Some(src) = snippet_opt(cx, lit.span);"}, {"sha": "fe2bbbdb9af0b0308fa1bf5e54815cef1ad7aec2", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -20,6 +20,7 @@\n \n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use syntax::ast;\n use syntax::attr;\n@@ -66,7 +67,7 @@ impl MissingDoc {\n             .expect(\"empty doc_hidden_stack\")\n     }\n \n-    fn check_missing_docs_attrs(&self, cx: &LateContext, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+    fn check_missing_docs_attrs(&self, cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -122,9 +123,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n         let desc = match it.node {\n-            hir::ItemConst(..) => \"a constant\",\n-            hir::ItemEnum(..) => \"an enum\",\n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Const(..) => \"a constant\",\n+            hir::ItemKind::Enum(..) => \"an enum\",\n+            hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.name == \"main\" {\n                     let def_id = cx.tcx.hir.local_def_id(it.id);\n@@ -135,19 +136,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 }\n                 \"a function\"\n             },\n-            hir::ItemMod(..) => \"a module\",\n-            hir::ItemStatic(..) => \"a static\",\n-            hir::ItemStruct(..) => \"a struct\",\n-            hir::ItemTrait(..) => \"a trait\",\n-            hir::ItemTraitAlias(..) => \"a trait alias\",\n-            hir::ItemGlobalAsm(..) => \"an assembly blob\",\n-            hir::ItemTy(..) => \"a type alias\",\n-            hir::ItemUnion(..) => \"a union\",\n-            hir::ItemExistential(..) => \"an existential type\",\n-            hir::ItemExternCrate(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemUse(..) => return,\n+            hir::ItemKind::Mod(..) => \"a module\",\n+            hir::ItemKind::Static(..) => \"a static\",\n+            hir::ItemKind::Struct(..) => \"a struct\",\n+            hir::ItemKind::Trait(..) => \"a trait\",\n+            hir::ItemKind::TraitAlias(..) => \"a trait alias\",\n+            hir::ItemKind::GlobalAsm(..) => \"an assembly blob\",\n+            hir::ItemKind::Ty(..) => \"a type alias\",\n+            hir::ItemKind::Union(..) => \"a union\",\n+            hir::ItemKind::Existential(..) => \"an existential type\",\n+            hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::ForeignMod(..) |\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::Use(..) => return,\n         };\n \n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n@@ -177,6 +178,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ImplItemKind::Const(..) => \"an associated constant\",\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::Type(_) => \"an associated type\",\n+            hir::ImplItemKind::Existential(_) => \"an existential type\",\n         };\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }"}, {"sha": "e19ec4da67ed29cd4352924181c908dc96e41b9c", "filename": "clippy_lints/src/missing_inline.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -0,0 +1,191 @@\n+//   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+//   file at the top-level directory of this distribution and at\n+//   http://rust-lang.org/COPYRIGHT.\n+//\n+//   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+//   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+//   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+//   option. This file may not be copied, modified, or distributed\n+//   except according to those terms.\n+//\n+\n+use rustc::hir;\n+use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+/// **What it does:** it lints if an exported function, method, trait method with default impl,\n+/// or trait method impl is not `#[inline]`.\n+///\n+/// **Why is this bad?** In general, it is not. Functions can be inlined across\n+/// crates when that's profitable as long as any form of LTO is used. When LTO is disabled,\n+/// functions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\n+/// might intend for most of the methods in their public API to be able to be inlined across\n+/// crates even when LTO is disabled. For these types of crates, enabling this lint might make sense.\n+/// It allows the crate to require all exported methods to be `#[inline]` by default, and then opt\n+/// out for specific methods where this might not make sense.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// pub fn foo() {} // missing #[inline]\n+/// fn ok() {} // ok\n+/// #[inline] pub fn bar() {} // ok\n+/// #[inline(always)] pub fn baz() {} // ok\n+///\n+/// pub trait Bar {\n+///   fn bar(); // ok\n+///   fn def_bar() {} // missing #[inline]\n+/// }\n+///\n+/// struct Baz;\n+/// impl Baz {\n+///    fn priv() {} // ok\n+/// }\n+///\n+/// impl Bar for Baz {\n+///   fn bar() {} // ok - Baz is not exported\n+/// }\n+///\n+/// pub struct PubBaz;\n+/// impl PubBaz {\n+///    fn priv() {} // ok\n+///    pub not_ptriv() {} // missing #[inline]\n+/// }\n+///\n+/// impl Bar for PubBaz {\n+///    fn bar() {} // missing #[inline]\n+///    fn def_bar() {} // missing #[inline]\n+/// }\n+/// ```\n+declare_clippy_lint! {\n+    pub MISSING_INLINE_IN_PUBLIC_ITEMS,\n+    restriction,\n+    \"detects missing #[inline] attribute for public callables (functions, trait methods, methods...)\"\n+}\n+\n+pub struct MissingInline;\n+\n+fn check_missing_inline_attrs(cx: &LateContext<'_, '_>,\n+                              attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+    let has_inline = attrs\n+        .iter()\n+        .any(|a| a.name() == \"inline\" );\n+    if !has_inline {\n+        cx.span_lint(\n+            MISSING_INLINE_IN_PUBLIC_ITEMS,\n+            sp,\n+            &format!(\"missing `#[inline]` for {}\", desc),\n+        );\n+    }\n+}\n+\n+fn is_executable<'a, 'tcx>(cx: &LateContext<'a, 'tcx>) -> bool {\n+    use rustc::session::config::CrateType;\n+\n+    cx.tcx.sess.crate_types.get().iter().any(|t: &CrateType| {\n+        match t {\n+            CrateType::CrateTypeExecutable => true,\n+            _ => false,\n+        }\n+    })\n+}\n+\n+impl LintPass for MissingInline {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![MISSING_INLINE_IN_PUBLIC_ITEMS]\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+        if is_executable(cx) {\n+            return;\n+        }\n+\n+        if !cx.access_levels.is_exported(it.id) {\n+            return;\n+        }\n+        match it.node {\n+            hir::ItemKind::Fn(..) => {\n+                let desc = \"a function\";\n+                check_missing_inline_attrs(cx, &it.attrs, it.span, desc);\n+            },\n+            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics,\n+                           ref _bounds, ref trait_items)  => {\n+                // note: we need to check if the trait is exported so we can't use\n+                // `LateLintPass::check_trait_item` here.\n+                for tit in trait_items {\n+                    let tit_ = cx.tcx.hir.trait_item(tit.id);\n+                    match tit_.node {\n+                        hir::TraitItemKind::Const(..) |\n+                        hir::TraitItemKind::Type(..) => {},\n+                        hir::TraitItemKind::Method(..) => {\n+                            if tit.defaultness.has_value() {\n+                                // trait method with default body needs inline in case\n+                                // an impl is not provided\n+                                let desc = \"a default trait method\";\n+                                let item = cx.tcx.hir.expect_trait_item(tit.id.node_id);\n+                                check_missing_inline_attrs(cx, &item.attrs,\n+                                                                item.span, desc);\n+                            }\n+                        },\n+                    }\n+                }\n+            }\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Mod(..) |\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::TraitAlias(..) |\n+            hir::ItemKind::GlobalAsm(..) |\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::ForeignMod(..) |\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::Use(..) => {},\n+        };\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n+        use rustc::ty::{TraitContainer, ImplContainer};\n+        if is_executable(cx) {\n+            return;\n+        }\n+\n+        // If the item being implemented is not exported, then we don't need #[inline]\n+        if !cx.access_levels.is_exported(impl_item.id) {\n+            return;\n+        }\n+\n+        let desc = match impl_item.node {\n+            hir::ImplItemKind::Method(..) => \"a method\",\n+            hir::ImplItemKind::Const(..) |\n+            hir::ImplItemKind::Type(_) |\n+            hir::ImplItemKind::Existential(_) => return,\n+        };\n+\n+        let def_id = cx.tcx.hir.local_def_id(impl_item.id);\n+        let trait_def_id = match cx.tcx.associated_item(def_id).container {\n+            TraitContainer(cid) => Some(cid),\n+            ImplContainer(cid) => cx.tcx.impl_trait_ref(cid).map(|t| t.def_id),\n+        };\n+\n+        if let Some(trait_def_id) = trait_def_id {\n+            if let Some(n) = cx.tcx.hir.as_local_node_id(trait_def_id) {\n+                if !cx.access_levels.is_exported(n) {\n+                    // If a trait is being implemented for an item, and the\n+                    // trait is not exported, we don't need #[inline]\n+                    return;\n+                }\n+            }\n+        }\n+\n+        check_missing_inline_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n+    }\n+}"}, {"sha": "d424604550661c57cc5fad9400dd44caf01fce07", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n //! lint on multiple versions of a crate being used\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n \n use cargo_metadata;\n@@ -38,7 +39,7 @@ impl LintPass for Pass {\n }\n \n impl EarlyLintPass for Pass {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &Crate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n         let metadata = match cargo_metadata::metadata_deps(None, true) {\n             Ok(metadata) => metadata,\n             Err(_) => {"}, {"sha": "0413f1ab603ffa2942fdb820d0b5c94a6cbe0d97", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,8 +1,9 @@\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n-use crate::utils::{higher, in_external_macro, span_lint};\n+use crate::utils::{higher, span_lint};\n \n /// **What it does:** Checks for instances of `mut mut` references.\n ///\n@@ -49,7 +50,7 @@ pub struct MutVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if in_external_macro(self.cx, expr.span) {\n+        if in_external_macro(self.cx.sess(), expr.span) {\n             return;\n         }\n \n@@ -62,8 +63,8 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             // Let's ignore the generated code.\n             intravisit::walk_expr(self, arg);\n             intravisit::walk_expr(self, body);\n-        } else if let hir::ExprAddrOf(hir::MutMutable, ref e) = expr.node {\n-            if let hir::ExprAddrOf(hir::MutMutable, _) = e.node {\n+        } else if let hir::ExprKind::AddrOf(hir::MutMutable, ref e) = expr.node {\n+            if let hir::ExprKind::AddrOf(hir::MutMutable, _) = e.node {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,\n@@ -87,15 +88,15 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyRptr(\n+        if let hir::TyKind::Rptr(\n             _,\n             hir::MutTy {\n                 ty: ref pty,\n                 mutbl: hir::MutMutable,\n             },\n         ) = ty.node\n         {\n-            if let hir::TyRptr(\n+            if let hir::TyKind::Rptr(\n                 _,\n                 hir::MutTy {\n                     mutbl: hir::MutMutable,"}, {"sha": "de4c54444400b2c606029c65d7f2ef849e8407ba", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n use rustc::hir::*;\n@@ -36,15 +37,15 @@ impl LintPass for UnnecessaryMutPassed {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         match e.node {\n-            ExprCall(ref fn_expr, ref arguments) => if let ExprPath(ref path) = fn_expr.node {\n+            ExprKind::Call(ref fn_expr, ref arguments) => if let ExprKind::Path(ref path) = fn_expr.node {\n                 check_arguments(\n                     cx,\n                     arguments,\n                     cx.tables.expr_ty(fn_expr),\n                     &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n                 );\n             },\n-            ExprMethodCall(ref path, _, ref arguments) => {\n+            ExprKind::MethodCall(ref path, _, ref arguments) => {\n                 let def_id = cx.tables.type_dependent_defs()[e.hir_id].def_id();\n                 let substs = cx.tables.node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n@@ -69,7 +70,7 @@ fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], typ\n                     ty::TyRawPtr(ty::TypeAndMut {\n                         mutbl: MutImmutable,\n                         ..\n-                    }) => if let ExprAddrOf(MutMutable, _) = argument.node {\n+                    }) => if let ExprKind::AddrOf(MutMutable, _) = argument.node {\n                         span_lint(\n                             cx,\n                             UNNECESSARY_MUT_PASSED,"}, {"sha": "50ef9f268f29ab5b36e09a8a5bbe38821f2afccc", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::ty::{self, Ty};\n use rustc::hir::Expr;\n use syntax::ast;\n@@ -79,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n     }\n }\n \n-fn get_atomic_name(ty: Ty) -> Option<(&'static str)> {\n+fn get_atomic_name(ty: Ty<'_>) -> Option<(&'static str)> {\n     match ty.sty {\n         ty::TyBool => Some(\"AtomicBool\"),\n         ty::TyUint(_) => Some(\"AtomicUsize\"),"}, {"sha": "559aa74f9a22848d61fdfca8afff72107aa3e990", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use syntax::ast::LitKind;\n use syntax::codemap::Spanned;\n@@ -60,7 +61,7 @@ impl LintPass for NeedlessBool {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n-        if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n+        if let ExprKind::If(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n                 let snip = Sugg::hir(cx, pred, \"<predicate>\");\n                 let snip = if not { !snip } else { snip };\n@@ -80,7 +81,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     hint,\n                 );\n             };\n-            if let ExprBlock(ref then_block, _) = then_block.node {\n+            if let ExprKind::Block(ref then_block, _) = then_block.node {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n@@ -105,7 +106,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     _ => (),\n                 }\n             } else {\n-                panic!(\"IfExpr 'then' node is not an ExprBlock\");\n+                panic!(\"IfExpr 'then' node is not an ExprKind::Block\");\n             }\n         }\n     }\n@@ -123,7 +124,7 @@ impl LintPass for BoolComparison {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n-        if let ExprBinary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Eq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n@@ -184,8 +185,8 @@ enum Expression {\n fn fetch_bool_block(block: &Block) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n-        (&[ref e], None) => if let StmtSemi(ref e, _) = e.node {\n-            if let ExprRet(_) = e.node {\n+        (&[ref e], None) => if let StmtKind::Semi(ref e, _) = e.node {\n+            if let ExprKind::Ret(_) = e.node {\n                 fetch_bool_expr(&**e)\n             } else {\n                 Expression::Other\n@@ -199,13 +200,13 @@ fn fetch_bool_block(block: &Block) -> Expression {\n \n fn fetch_bool_expr(expr: &Expr) -> Expression {\n     match expr.node {\n-        ExprBlock(ref block, _) => fetch_bool_block(block),\n-        ExprLit(ref lit_ptr) => if let LitKind::Bool(value) = lit_ptr.node {\n+        ExprKind::Block(ref block, _) => fetch_bool_block(block),\n+        ExprKind::Lit(ref lit_ptr) => if let LitKind::Bool(value) = lit_ptr.node {\n             Expression::Bool(value)\n         } else {\n             Expression::Other\n         },\n-        ExprRet(Some(ref expr)) => match fetch_bool_expr(expr) {\n+        ExprKind::Ret(Some(ref expr)) => match fetch_bool_expr(expr) {\n             Expression::Bool(value) => Expression::RetBool(value),\n             _ => Expression::Other,\n         },"}, {"sha": "7986b43919c80fbf70417cffd962eb95967f5dfc", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,7 +3,9 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n-use rustc::hir::{BindingAnnotation, Expr, ExprAddrOf, MutImmutable, Pat, PatKind};\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n+use rustc::hir::{BindingAnnotation, Expr, ExprKind, MutImmutable, Pat, PatKind};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};\n use crate::utils::{in_macro, snippet_opt, span_lint_and_then};\n@@ -40,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n+        if let ExprKind::AddrOf(MutImmutable, ref inner) = e.node {\n             if let ty::TyRef(..) = cx.tables.expr_ty(inner).sty {\n                 for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n                     if let [Adjustment {"}, {"sha": "1679a9007b462df839d5b22802d60b4081d74699", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,8 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::{BindingAnnotation, MutImmutable, Pat, PatKind};\n use crate::utils::{in_macro, snippet, span_lint_and_then};\n "}, {"sha": "60ab0eaae02415a7c041d869b6e4da90fe1a15ab", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -28,6 +28,7 @@\n //!\n //! This lint is **warn** by default.\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast;\n use syntax::codemap::{original_sp, DUMMY_SP};\n use std::borrow::Cow;\n@@ -109,7 +110,7 @@ impl LintPass for NeedlessContinue {\n }\n \n impl EarlyLintPass for NeedlessContinue {\n-    fn check_expr(&mut self, ctx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, ctx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if !in_macro(expr.span) {\n             check_and_warn(ctx, expr);\n         }\n@@ -264,7 +265,7 @@ const DROP_ELSE_BLOCK_MSG: &str = \"Consider dropping the else clause, and moving\n                                    block, like so:\\n\";\n \n \n-fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: LintType) {\n+fn emit_warning<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str, typ: LintType) {\n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n@@ -283,7 +284,7 @@ fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: L\n     span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n }\n \n-fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n \n     let if_code = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n@@ -300,7 +301,7 @@ fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext, data: &'a L\n     ret\n }\n \n-fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n     let mut if_code = format!(\"if {} {{\\n\", cond_code);\n \n@@ -331,7 +332,7 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext, data: &'a\n     ret\n }\n \n-fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n+fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n     with_loop_block(expr, |loop_block| {\n         for (i, stmt) in loop_block.stmts.iter().enumerate() {\n             with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {"}, {"sha": "82e85f3453a1526d5c1ebaaf74c37a2d3cb4feca", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,7 +1,10 @@\n+use matches::matches;\n use rustc::hir::*;\n use rustc::hir::map::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, RegionKind, TypeFoldable};\n use rustc::traits;\n use rustc::middle::expr_use_visitor as euv;\n@@ -88,8 +91,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n         // Exclude non-inherent impls\n         if let Some(NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(node_id)) {\n-            if matches!(item.node, ItemImpl(_, _, _, _, Some(_), _, _) |\n-                ItemTrait(..))\n+            if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n+                ItemKind::Trait(..))\n             {\n                 return;\n             }\n@@ -201,7 +204,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     }\n \n                     // Dereference suggestion\n-                    let sugg = |db: &mut DiagnosticBuilder| {\n+                    let sugg = |db: &mut DiagnosticBuilder<'_>| {\n                         if let ty::TypeVariants::TyAdt(def, ..) = ty.sty {\n                             if let Some(span) = cx.tcx.hir.span_if_local(def.did) {\n                                 if cx.param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n@@ -215,7 +218,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                             if match_type(cx, ty, &paths::VEC);\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n-                            if let TyPath(QPath::Resolved(_, ref path)) = input.node;\n+                            if let TyKind::Path(QPath::Resolved(_, ref path)) = input.node;\n                             if let Some(elem_ty) = path.segments.iter()\n                                 .find(|seg| seg.ident.name == \"Vec\")\n                                 .and_then(|ps| ps.args.as_ref())\n@@ -339,7 +342,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                     match node {\n                         map::Node::NodeExpr(e) => {\n                             // `match` and `if let`\n-                            if let ExprMatch(ref c, ..) = e.node {\n+                            if let ExprKind::Match(ref c, ..) = e.node {\n                                 self.spans_need_deref\n                                     .entry(vid)\n                                     .or_insert_with(HashSet::new)\n@@ -350,8 +353,8 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                         map::Node::NodeStmt(s) => {\n                             // `let <pat> = x;`\n                             if_chain! {\n-                                if let StmtDecl(ref decl, _) = s.node;\n-                                if let DeclLocal(ref local) = decl.node;\n+                                if let StmtKind::Decl(ref decl, _) = s.node;\n+                                if let DeclKind::Local(ref local) = decl.node;\n                                 then {\n                                     self.spans_need_deref\n                                         .entry(vid)\n@@ -393,7 +396,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn borrow(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: ty::Region, _: ty::BorrowKind, _: euv::LoanCause) {}\n+    fn borrow(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: ty::Region<'_>, _: ty::BorrowKind, _: euv::LoanCause) {}\n \n     fn mutate(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n "}, {"sha": "52c4c6e52371c749424a32b3d21419b456511ca4", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n-use rustc::hir::{Expr, ExprStruct};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::span_lint;\n \n /// **What it does:** Checks for needlessly including a base struct on update\n@@ -32,7 +33,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n+        if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.non_enum_variant().fields.len() {"}, {"sha": "02007e2de43ca8e307c41bbdadaa315016a1d90f", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,7 +1,9 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n \n-use crate::utils::{self, paths, span_lint, in_external_macro};\n+use crate::utils::{self, paths, span_lint};\n \n /// **What it does:**\n /// Checks for the usage of negated comparison operators on types which only implement\n@@ -22,16 +24,16 @@ use crate::utils::{self, paths, span_lint, in_external_macro};\n /// // Bad\n /// let a = 1.0;\n /// let b = std::f64::NAN;\n-/// \n+///\n /// let _not_less_or_equal = !(a <= b);\n ///\n /// // Good\n /// let a = 1.0;\n /// let b = std::f64::NAN;\n-/// \n+///\n /// let _not_less_or_equal = match a.partial_cmp(&b) {\n ///     None | Some(Ordering::Greater) => true,\n-///     _ => false, \n+///     _ => false,\n /// };\n /// ```\n declare_clippy_lint! {\n@@ -53,10 +55,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n \n-            if !in_external_macro(cx, expr.span);\n-            if let Expr_::ExprUnary(UnOp::UnNot, ref inner) = expr.node;\n-            if let Expr_::ExprBinary(ref op, ref left, _) = inner.node;\n-            if let BinOp_::BiLe | BinOp_::BiGe | BinOp_::BiLt | BinOp_::BiGt = op.node;\n+            if !in_external_macro(cx.sess(), expr.span);\n+            if let ExprKind::Unary(UnOp::UnNot, ref inner) = expr.node;\n+            if let ExprKind::Binary(ref op, ref left, _) = inner.node;\n+            if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;\n \n             then {\n "}, {"sha": "c056ff46178b6af646d24fd238426227ba693be4", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::codemap::{Span, Spanned};\n \n use crate::consts::{self, Constant};\n@@ -33,20 +35,20 @@ impl LintPass for NegMultiply {\n #[allow(match_same_arms)]\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(Spanned { node: BiMul, .. }, ref l, ref r) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref l, ref r) = e.node {\n             match (&l.node, &r.node) {\n-                (&ExprUnary(..), &ExprUnary(..)) => (),\n-                (&ExprUnary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),\n-                (_, &ExprUnary(UnNeg, ref lit)) => check_mul(cx, e.span, lit, l),\n+                (&ExprKind::Unary(..), &ExprKind::Unary(..)) => (),\n+                (&ExprKind::Unary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),\n+                (_, &ExprKind::Unary(UnNeg, ref lit)) => check_mul(cx, e.span, lit, l),\n                 _ => (),\n             }\n         }\n     }\n }\n \n-fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n+fn check_mul(cx: &LateContext<'_, '_>, span: Span, lit: &Expr, exp: &Expr) {\n     if_chain! {\n-        if let ExprLit(ref l) = lit.node;\n+        if let ExprKind::Lit(ref l) = lit.node;\n         if let Constant::Int(val) = consts::lit_to_constant(&l.node, cx.tables.expr_ty(lit));\n         if val == 1;\n         if cx.tables.expr_ty(exp).is_integral();"}, {"sha": "eeb131959e9a2fc94bf3ecad96cf054f8d584677", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,10 +1,12 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n use crate::utils::paths;\n-use crate::utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, same_tys, span_lint_and_then};\n+use crate::utils::{get_trait_def_id, implements_trait, return_ty, same_tys, span_lint_and_then};\n use crate::utils::sugg::DiagnosticBuilderExt;\n \n /// **What it does:** Checks for types with a `fn new() -> Self` method and no\n@@ -89,11 +91,11 @@ impl LintPass for NewWithoutDefault {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n-        if let hir::ItemImpl(_, _, _, _, None, _, ref items) = item.node {\n+        if let hir::ItemKind::Impl(_, _, _, _, None, _, ref items) = item.node {\n             for assoc_item in items {\n                 if let hir::AssociatedItemKind::Method { has_self: false } = assoc_item.kind {\n                     let impl_item = cx.tcx.hir.impl_item(assoc_item.id);\n-                    if in_external_macro(cx, impl_item.span) {\n+                    if in_external_macro(cx.sess(), impl_item.span) {\n                         return;\n                     }\n                     if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n@@ -155,7 +157,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     }\n }\n \n-fn create_new_without_default_suggest_msg(ty: Ty) -> String {\n+fn create_new_without_default_suggest_msg(ty: Ty<'_>) -> String {\n     #[cfg_attr(rustfmt, rustfmt_skip)]\n     format!(\n \"impl Default for {} {{"}, {"sha": "cacb5d6a9ffcc31d9749b41a7113c9e24e273ade", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,7 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::def::Def;\n-use rustc::hir::{BiAnd, BiOr, BlockCheckMode, Expr, Expr_, Stmt, StmtSemi, UnsafeSource};\n+use rustc::hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n use crate::utils::{has_drop, in_macro, snippet_opt, span_lint, span_lint_and_sugg};\n use std::ops::Deref;\n \n@@ -40,31 +41,31 @@ declare_clippy_lint! {\n     \"outer expressions with no effect\"\n }\n \n-fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if in_macro(expr.span) {\n         return false;\n     }\n     match expr.node {\n-        Expr_::ExprLit(..) | Expr_::ExprClosure(.., _) => true,\n-        Expr_::ExprPath(..) => !has_drop(cx, expr),\n-        Expr_::ExprIndex(ref a, ref b) | Expr_::ExprBinary(_, ref a, ref b) => {\n+        ExprKind::Lit(..) | ExprKind::Closure(.., _) => true,\n+        ExprKind::Path(..) => !has_drop(cx, expr),\n+        ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n             has_no_effect(cx, a) && has_no_effect(cx, b)\n         },\n-        Expr_::ExprArray(ref v) | Expr_::ExprTup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n-        Expr_::ExprRepeat(ref inner, _) |\n-        Expr_::ExprCast(ref inner, _) |\n-        Expr_::ExprType(ref inner, _) |\n-        Expr_::ExprUnary(_, ref inner) |\n-        Expr_::ExprField(ref inner, _) |\n-        Expr_::ExprAddrOf(_, ref inner) |\n-        Expr_::ExprBox(ref inner) => has_no_effect(cx, inner),\n-        Expr_::ExprStruct(_, ref fields, ref base) => {\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n+        ExprKind::Repeat(ref inner, _) |\n+        ExprKind::Cast(ref inner, _) |\n+        ExprKind::Type(ref inner, _) |\n+        ExprKind::Unary(_, ref inner) |\n+        ExprKind::Field(ref inner, _) |\n+        ExprKind::AddrOf(_, ref inner) |\n+        ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n+        ExprKind::Struct(_, ref fields, ref base) => {\n             !has_drop(cx, expr) && fields.iter().all(|field| has_no_effect(cx, &field.expr)) && match *base {\n                 Some(ref base) => has_no_effect(cx, base),\n                 None => true,\n             }\n         },\n-        Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n+        ExprKind::Call(ref callee, ref args) => if let ExprKind::Path(ref qpath) = callee.node {\n             let def = cx.tables.qpath_def(qpath, callee.hir_id);\n             match def {\n                 Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) => {\n@@ -75,7 +76,7 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         } else {\n             false\n         },\n-        Expr_::ExprBlock(ref block, _) => {\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n                 has_no_effect(cx, expr)\n             } else {\n@@ -97,7 +98,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n-        if let StmtSemi(ref expr, _) = stmt.node {\n+        if let StmtKind::Semi(ref expr, _) = stmt.node {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n@@ -127,24 +128,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n \n-fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n+fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n     if in_macro(expr.span) {\n         return None;\n     }\n     match expr.node {\n-        Expr_::ExprIndex(ref a, ref b) => Some(vec![&**a, &**b]),\n-        Expr_::ExprBinary(ref binop, ref a, ref b) if binop.node != BiAnd && binop.node != BiOr => {\n+        ExprKind::Index(ref a, ref b) => Some(vec![&**a, &**b]),\n+        ExprKind::Binary(ref binop, ref a, ref b) if binop.node != BinOpKind::And && binop.node != BinOpKind::Or => {\n             Some(vec![&**a, &**b])\n         },\n-        Expr_::ExprArray(ref v) | Expr_::ExprTup(ref v) => Some(v.iter().collect()),\n-        Expr_::ExprRepeat(ref inner, _) |\n-        Expr_::ExprCast(ref inner, _) |\n-        Expr_::ExprType(ref inner, _) |\n-        Expr_::ExprUnary(_, ref inner) |\n-        Expr_::ExprField(ref inner, _) |\n-        Expr_::ExprAddrOf(_, ref inner) |\n-        Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        Expr_::ExprStruct(_, ref fields, ref base) => if has_drop(cx, expr) {\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => Some(v.iter().collect()),\n+        ExprKind::Repeat(ref inner, _) |\n+        ExprKind::Cast(ref inner, _) |\n+        ExprKind::Type(ref inner, _) |\n+        ExprKind::Unary(_, ref inner) |\n+        ExprKind::Field(ref inner, _) |\n+        ExprKind::AddrOf(_, ref inner) |\n+        ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n+        ExprKind::Struct(_, ref fields, ref base) => if has_drop(cx, expr) {\n             None\n         } else {\n             Some(\n@@ -156,7 +157,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n                     .collect(),\n             )\n         },\n-        Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n+        ExprKind::Call(ref callee, ref args) => if let ExprKind::Path(ref qpath) = callee.node {\n             let def = cx.tables.qpath_def(qpath, callee.hir_id);\n             match def {\n                 Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..)\n@@ -169,7 +170,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         } else {\n             None\n         },\n-        Expr_::ExprBlock(ref block, _) => {\n+        ExprKind::Block(ref block, _) => {\n             if block.stmts.is_empty() {\n                 block.expr.as_ref().and_then(|e| {\n                     match block.rules {"}, {"sha": "f2c9210aae4e0d42dd53d5c4612c46e8273ac69c", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **deny** by default.\n \n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::ty::{self, TypeFlags};\n@@ -164,7 +165,7 @@ impl LintPass for NonCopyConst {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx Item) {\n-        if let ItemConst(hir_ty, ..) = &it.node {\n+        if let ItemKind::Const(hir_ty, ..) = &it.node {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             verify_ty_bound(cx, ty, Source::Item { item: it.span });\n         }\n@@ -182,15 +183,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n             let item_node_id = cx.tcx.hir.get_parent_node(impl_item.id);\n             let item = cx.tcx.hir.expect_item(item_node_id);\n             // ensure the impl is an inherent impl.\n-            if let ItemImpl(_, _, _, _, None, _, _) = item.node {\n+            if let ItemKind::Impl(_, _, _, _, None, _, _) = item.node {\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                 verify_ty_bound(cx, ty, Source::Assoc { ty: hir_ty.span, item: impl_item.span });\n             }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprPath(qpath) = &expr.node {\n+        if let ExprKind::Path(qpath) = &expr.node {\n             // Only lint if we use the const item inside a function.\n             if in_constant(cx, expr.id) {\n                 return;\n@@ -213,22 +214,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                 }\n                 if let Some(map::NodeExpr(parent_expr)) = cx.tcx.hir.find(parent_id) {\n                     match &parent_expr.node {\n-                        ExprAddrOf(..) => {\n+                        ExprKind::AddrOf(..) => {\n                             // `&e` => `e` must be referenced\n                             needs_check_adjustment = false;\n                         }\n-                        ExprField(..) => {\n+                        ExprKind::Field(..) => {\n                             dereferenced_expr = parent_expr;\n                             needs_check_adjustment = true;\n                         }\n-                        ExprIndex(e, _) if ptr::eq(&**e, cur_expr) => {\n+                        ExprKind::Index(e, _) if ptr::eq(&**e, cur_expr) => {\n                             // `e[i]` => desugared to `*Index::index(&e, i)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now.\n                             needs_check_adjustment = false;\n                             break;\n                         }\n-                        ExprUnary(UnDeref, _) => {\n+                        ExprKind::Unary(UnDeref, _) => {\n                             // `*e` => desugared to `*Deref::deref(&e)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now."}, {"sha": "e9688262c2a76eeb401771d58c3de37cdec41f35", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n use syntax::symbol::LocalInternedString;\n use syntax::ast::*;\n@@ -311,21 +312,21 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n }\n \n impl EarlyLintPass for NonExpressiveNames {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if let ItemKind::Fn(ref decl, _, _, ref blk) = item.node {\n             do_check(self, cx, &item.attrs, decl, blk);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &EarlyContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &EarlyContext<'_>, item: &ImplItem) {\n         if let ImplItemKind::Method(ref sig, ref blk) = item.node {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }\n \n }\n \n-fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n+fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext<'_>, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n     if !attr::contains_name(attrs, \"test\") {\n         let mut visitor = SimilarNamesLocalVisitor {\n             names: Vec::new(),"}, {"sha": "2a7f71c714521cfe721a31057e854c67ebd84e57", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use crate::utils::{match_type, method_chain_args, paths, snippet, span_help_and_lint};\n \n@@ -44,9 +46,9 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! { //begin checking variables\n-            if let ExprMatch(ref op, ref body, ref source) = expr.node; //test if expr is a match\n+            if let ExprKind::Match(ref op, ref body, ref source) = expr.node; //test if expr is a match\n             if let MatchSource::IfLetDesugar { .. } = *source; //test if it is an If Let\n-            if let ExprMethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n+            if let ExprKind::MethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n "}, {"sha": "effeb88d0cf8569d8457067c23846c21d460641f", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,6 @@\n-use rustc::hir::{Expr, ExprLit, ExprMethodCall};\n+use rustc::hir::{Expr, ExprKind};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n use crate::utils::{match_type, paths, span_lint, walk_ptrs_ty};\n@@ -33,7 +34,7 @@ impl LintPass for NonSensical {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprMethodCall(ref path, _, ref arguments) = e.node {\n+        if let ExprKind::MethodCall(ref path, _, ref arguments) = e.node {\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n             if path.ident.name == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n@@ -60,14 +61,14 @@ enum OpenOption {\n     Append,\n }\n \n-fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprMethodCall(ref path, _, ref arguments) = argument.node {\n+fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n+    if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.node {\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n             let argument_option = match arguments[1].node {\n-                ExprLit(ref span) => {\n+                ExprKind::Lit(ref span) => {\n                     if let Spanned {\n                         node: LitKind::Bool(lit),\n                         ..\n@@ -111,7 +112,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n     }\n }\n \n-fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n+fn check_open_options(cx: &LateContext<'_, '_>, options: &[(OpenOption, Argument)], span: Span) {\n     let (mut create, mut append, mut truncate, mut read, mut write) = (false, false, false, false, false);\n     let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) =\n         (false, false, false, false, false);"}, {"sha": "5714bdb521c83f4df32eab7f415e4af32ae2bcdb", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,8 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n-use crate::utils::span_lint;\n+use crate::utils::{span_lint, SpanlessEq};\n \n /// **What it does:** Detects classic underflow/overflow checks.\n ///\n@@ -31,24 +33,25 @@ impl LintPass for OverflowCheckConditional {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n-            if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node;\n-            if path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0];\n+            if let ExprKind::Binary(ref op, ref first, ref second) = expr.node;\n+            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = first.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.node;\n+            if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();\n             then {\n-                if let BinOp_::BiLt = op.node {\n-                    if let BinOp_::BiAdd = op2.node {\n+                if let BinOpKind::Lt = op.node {\n+                    if let BinOpKind::Add = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n                             \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n                     }\n                 }\n-                if let BinOp_::BiGt = op.node {\n-                    if let BinOp_::BiSub = op2.node {\n+                if let BinOpKind::Gt = op.node {\n+                    if let BinOpKind::Sub = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n                             \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n                     }\n@@ -57,23 +60,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n         }\n \n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n-            if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node;\n-            if path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0];\n+            if let ExprKind::Binary(ref op, ref first, ref second) = expr.node;\n+            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = second.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.node;\n+            if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();\n             then {\n-                if let BinOp_::BiGt = op.node {\n-                    if let BinOp_::BiAdd = op2.node {\n+                if let BinOpKind::Gt = op.node {\n+                    if let BinOpKind::Add = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n                             \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n                     }\n                 }\n-                if let BinOp_::BiLt = op.node {\n-                    if let BinOp_::BiSub = op2.node {\n+                if let BinOpKind::Lt = op.node {\n+                    if let BinOpKind::Sub = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n                             \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n                     }"}, {"sha": "e603773f7ba40155529303f9c362c5a24f2351a5", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast::LitKind;\n use syntax::ptr::P;\n use syntax::ext::quote::rt::Span;\n@@ -52,10 +54,10 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprBlock(ref block, _) = expr.node;\n+            if let ExprKind::Block(ref block, _) = expr.node;\n             if let Some(ref ex) = block.expr;\n-            if let ExprCall(ref fun, ref params) = ex.node;\n-            if let ExprPath(ref qpath) = fun.node;\n+            if let ExprKind::Call(ref fun, ref params) = ex.node;\n+            if let ExprKind::Path(ref qpath) = fun.node;\n             if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n             if match_def_path(cx.tcx, fun_def_id, &paths::BEGIN_PANIC);\n             if params.len() == 2;\n@@ -84,9 +86,9 @@ fn get_outer_span(expr: &Expr) -> Span {\n     }\n }\n \n-fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext) {\n+fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext<'_, '_>) {\n     if_chain! {\n-        if let ExprLit(ref lit) = params[0].node;\n+        if let ExprKind::Lit(ref lit) = params[0].node;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();\n         if let LitKind::Str(ref string, _) = lit.node;\n         let string = string.as_str().replace(\"{{\", \"\").replace(\"}}\", \"\");"}, {"sha": "675d014c527a09219b2c1c1ddb89e51207b5ef7d", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use crate::utils::{is_automatically_derived, span_lint};\n \n@@ -38,7 +40,7 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if_chain! {\n-            if let ItemImpl(_, _, _, _, Some(ref trait_ref), _, ref impl_items) = item.node;\n+            if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref impl_items) = item.node;\n             if !is_automatically_derived(&*item.attrs);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.def.def_id() == eq_trait;"}, {"sha": "6a0f4f147b727b496f0d6b47a84a66b2330d685d", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n@@ -36,7 +37,7 @@ impl LintPass for Precedence {\n }\n \n impl EarlyLintPass for Precedence {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if in_macro(expr.span) {\n             return;\n         }"}, {"sha": "ea2d07df45577a655f0c526bb2f956f2f5c7b646", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -5,6 +5,8 @@ use rustc::hir::*;\n use rustc::hir::map::NodeItem;\n use rustc::hir::QPath;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n@@ -103,15 +105,15 @@ impl LintPass for PointerPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, _, body_id) = item.node {\n+        if let ItemKind::Fn(ref decl, _, _, body_id) = item.node {\n             check_fn(cx, decl, item.id, Some(body_id));\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, body_id) = item.node {\n             if let Some(NodeItem(it)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(item.id)) {\n-                if let ItemImpl(_, _, _, _, Some(_), _, _) = it.node {\n+                if let ItemKind::Impl(_, _, _, _, Some(_), _, _) = it.node {\n                     return; // ignore trait impls\n                 }\n             }\n@@ -131,8 +133,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref op, ref l, ref r) = expr.node {\n-            if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n+        if let ExprKind::Binary(ref op, ref l, ref r) = expr.node {\n+            if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(\n                     cx,\n                     CMP_NULL,\n@@ -144,7 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n+fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();\n@@ -159,7 +161,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n             if match_type(cx, ty, &paths::VEC) {\n                 let mut ty_snippet = None;\n                 if_chain! {\n-                    if let TyPath(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n+                    if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n                     if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n                     then {\n                         let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n@@ -219,8 +221,8 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                 }\n             } else if match_type(cx, ty, &paths::COW) {\n                 if_chain! {\n-                    if let TyRptr(_, MutTy { ref ty, ..} ) = arg.node;\n-                    if let TyPath(ref path) = ty.node;\n+                    if let TyKind::Rptr(_, MutTy { ref ty, ..} ) = arg.node;\n+                    if let TyKind::Path(ref path) = ty.node;\n                     if let QPath::Resolved(None, ref pp) = *path;\n                     if let [ref bx] = *pp.segments;\n                     if let Some(ref params) = bx.args;\n@@ -273,17 +275,17 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n }\n \n fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n-    if let Ty_::TyRptr(ref lt, ref m) = ty.node {\n+    if let TyKind::Rptr(ref lt, ref m) = ty.node {\n         Some((lt, m.mutbl, ty.span))\n     } else {\n         None\n     }\n }\n \n fn is_null_path(expr: &Expr) -> bool {\n-    if let ExprCall(ref pathexp, ref args) = expr.node {\n+    if let ExprKind::Call(ref pathexp, ref args) = expr.node {\n         if args.is_empty() {\n-            if let ExprPath(ref path) = pathexp.node {\n+            if let ExprKind::Path(ref path) = pathexp.node {\n                 return match_qpath(path, &paths::PTR_NULL) || match_qpath(path, &paths::PTR_NULL_MUT);\n             }\n         }"}, {"sha": "630dd1b57be1660cb01c858f71efcd1dd494f93e", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use crate::utils::sugg::Sugg;\n@@ -50,10 +52,10 @@ impl QuestionMarkPass {\n     /// ```\n     ///\n     /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_and_early_return_none(cx: &LateContext, expr: &Expr) {\n+    fn check_is_none_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n-            if let ExprIf(ref if_expr, ref body, _) = expr.node;\n-            if let ExprMethodCall(ref segment, _, ref args) = if_expr.node;\n+            if let ExprKind::If(ref if_expr, ref body, _) = expr.node;\n+            if let ExprKind::MethodCall(ref segment, _, ref args) = if_expr.node;\n             if segment.ident.name == \"is_none\";\n             if Self::expression_returns_none(cx, body);\n             if let Some(subject) = args.get(0);\n@@ -79,25 +81,25 @@ impl QuestionMarkPass {\n         }\n     }\n \n-    fn is_option(cx: &LateContext, expression: &Expr) -> bool {\n+    fn is_option(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n         match_type(cx, expr_ty, &OPTION)\n     }\n \n-    fn expression_returns_none(cx: &LateContext, expression: &Expr) -> bool {\n+    fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n         match expression.node {\n-            ExprBlock(ref block, _) => {\n+            ExprKind::Block(ref block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {\n                     return Self::expression_returns_none(cx, &return_expression);\n                 }\n \n                 false\n             },\n-            ExprRet(Some(ref expr)) => {\n+            ExprKind::Ret(Some(ref expr)) => {\n                 Self::expression_returns_none(cx, expr)\n             },\n-            ExprPath(ref qp) => {\n+            ExprKind::Path(ref qp) => {\n                 if let Def::VariantCtor(def_id, _) = cx.tables.qpath_def(qp, expression.hir_id) {\n                     return match_def_path(cx.tcx, def_id,  &OPTION_NONE);\n                 }\n@@ -113,8 +115,8 @@ impl QuestionMarkPass {\n         if_chain! {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n-            if let StmtSemi(ref expr, _) = expr.node;\n-            if let ExprRet(ref ret_expr) = expr.node;\n+            if let StmtKind::Semi(ref expr, _) = expr.node;\n+            if let ExprKind::Ret(ref ret_expr) = expr.node;\n             if let &Some(ref ret_expr) = ret_expr;\n \n             then {"}, {"sha": "fd303bb6ab4f8dd39ebde8de2e3dada1c9b32e5a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,9 +1,11 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use syntax::ast::RangeLimits;\n use syntax::codemap::Spanned;\n use crate::utils::{is_integer_literal, paths, snippet, span_lint, span_lint_and_then};\n-use crate::utils::{get_trait_def_id, higher, implements_trait};\n+use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n use crate::utils::sugg::Sugg;\n \n /// **What it does:** Checks for calling `.step_by(0)` on iterators,\n@@ -88,7 +90,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprMethodCall(ref path, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n             let name = path.ident.as_str();\n \n             // Range with step_by(0).\n@@ -107,18 +109,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let zip_arg = &args[1];\n                 if_chain! {\n                     // .iter() call\n-                    if let ExprMethodCall(ref iter_path, _, ref iter_args ) = *iter;\n+                    if let ExprKind::MethodCall(ref iter_path, _, ref iter_args ) = *iter;\n                     if iter_path.ident.name == \"iter\";\n                     // range expression in .zip() call: 0..x.len()\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_literal(start, 0);\n                     // .len() call\n-                    if let ExprMethodCall(ref len_path, _, ref len_args) = end.node;\n+                    if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.node;\n                     if len_path.ident.name == \"len\" && len_args.len() == 1;\n                     // .iter() and .len() called on same Path\n-                    if let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n-                    if let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n-                    if iter_path.segments == len_path.segments;\n+                    if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n+                    if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n+                    if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n                      then {\n                          span_lint(cx,\n                                    RANGE_ZIP_WITH_LEN,\n@@ -174,7 +176,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_step_by(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n     let ty = cx.tables.expr_ty_adjusted(expr);\n@@ -184,7 +186,7 @@ fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n \n fn y_plus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprBinary(Spanned { node: BiAdd, .. }, ref lhs, ref rhs) => if is_integer_literal(lhs, 1) {\n+        ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref lhs, ref rhs) => if is_integer_literal(lhs, 1) {\n             Some(rhs)\n         } else if is_integer_literal(rhs, 1) {\n             Some(lhs)\n@@ -197,7 +199,7 @@ fn y_plus_one(expr: &Expr) -> Option<&Expr> {\n \n fn y_minus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprBinary(Spanned { node: BiSub, .. }, ref lhs, ref rhs) if is_integer_literal(rhs, 1) => Some(lhs),\n+        ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) if is_integer_literal(rhs, 1) => Some(lhs),\n         _ => None,\n     }\n }"}, {"sha": "4f28d36e2a8f72e66533d11f1ca709be7b937a84", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::{in_macro, is_range_expression, match_var, span_lint_and_sugg};\n \n@@ -43,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantFieldNames {\n             return;\n         }\n \n-        if let ExprStruct(_, ref fields, _) = expr.node {\n+        if let ExprKind::Struct(_, ref fields, _) = expr.node {\n             for field in fields {\n                 let name = field.ident.name;\n "}, {"sha": "f349f46d926e31987f2f8a024c4584e69a1e1424", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use syntax::ast::{Expr, ExprKind, UnOp};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use crate::utils::{snippet, span_lint_and_sugg};\n \n /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n@@ -37,7 +39,7 @@ fn without_parens(mut e: &Expr) -> &Expr {\n }\n \n impl EarlyLintPass for Pass {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n             if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node;\n             if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node;\n@@ -82,7 +84,7 @@ impl LintPass for DerefPass {\n }\n \n impl EarlyLintPass for DerefPass {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n             if let ExprKind::Field(ref object, ref field_name) = e.node;\n             if let ExprKind::Paren(ref parened) = object.node;"}, {"sha": "39b7888dcc609b95dfc844e132d610ceceedbfcd", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,6 +1,8 @@\n use regex_syntax;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use std::collections::HashSet;\n use syntax::ast::{LitKind, NodeId, StrStyle};\n use syntax::codemap::{BytePos, Span};\n@@ -108,8 +110,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref fun, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = fun.node;\n+            if let ExprKind::Call(ref fun, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = fun.node;\n             if args.len() == 1;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, fun.hir_id));\n             then {\n@@ -176,8 +178,8 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n \n fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprArray(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Array(ref exprs) = expr.node;\n         then {\n             for expr in exprs {\n                 check_regex(cx, expr, utf8);\n@@ -192,7 +194,7 @@ fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: boo\n         .allow_invalid_utf8(!utf8)\n         .build();\n \n-    if let ExprLit(ref lit) = expr.node {\n+    if let ExprKind::Lit(ref lit) = expr.node {\n         if let LitKind::Str(ref r, style) = lit.node {\n             let r = &r.as_str();\n             let offset = if let StrStyle::Raw(n) = style { 2 + n } else { 1 };"}, {"sha": "b9a4c6ebb1958d5927bcc4e73920a1b85e920d2b", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::def::Def;\n use crate::utils::{match_def_path, span_lint_and_sugg};\n@@ -37,7 +39,7 @@ impl LintPass for ReplaceConsts {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if_chain! {\n-            if let hir::ExprPath(ref qp) = expr.node;\n+            if let hir::ExprKind::Path(ref qp) = expr.node;\n             if let Def::Const(def_id) = cx.tables.qpath_def(qp, expr.hir_id);\n             then {\n                 for &(const_path, repl_snip) in REPLACEMENTS {"}, {"sha": "0ede1bc972745e7dba3e11b07a31f35d93f4a76c", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,9 +1,11 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n \n-use crate::utils::{in_external_macro, in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n+use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n \n /// **What it does:** Checks for return statements at the end of a block.\n ///\n@@ -47,7 +49,7 @@ pub struct ReturnPass;\n \n impl ReturnPass {\n     // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         if let Some(stmt) = block.stmts.last() {\n             match stmt.node {\n                 ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n@@ -59,7 +61,7 @@ impl ReturnPass {\n     }\n \n     // Check a the final expression in a block if it's a return.\n-    fn check_final_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr, span: Option<Span>) {\n+    fn check_final_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr, span: Option<Span>) {\n         match expr.node {\n             // simple return is always \"bad\"\n             ast::ExprKind::Ret(Some(ref inner)) => {\n@@ -87,8 +89,8 @@ impl ReturnPass {\n         }\n     }\n \n-    fn emit_return_lint(&mut self, cx: &EarlyContext, ret_span: Span, inner_span: Span) {\n-        if in_external_macro(cx, inner_span) || in_macro(inner_span) {\n+    fn emit_return_lint(&mut self, cx: &EarlyContext<'_>, ret_span: Span, inner_span: Span) {\n+        if in_external_macro(cx.sess(), inner_span) || in_macro(inner_span) {\n             return;\n         }\n         span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded return statement\", |db| {\n@@ -99,7 +101,7 @@ impl ReturnPass {\n     }\n \n     // Check for \"let x = EXPR; x\"\n-    fn check_let_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_let_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         let mut it = block.stmts.iter();\n \n         // we need both a let-binding stmt and an expr\n@@ -115,7 +117,7 @@ impl ReturnPass {\n             if let ast::PatKind::Ident(_, ident, _) = local.pat.node;\n             if let ast::ExprKind::Path(_, ref path) = retexpr.node;\n             if match_path_ast(path, &[&ident.as_str()]);\n-            if !in_external_macro(cx, initexpr.span);\n+            if !in_external_macro(cx.sess(), initexpr.span);\n             then {\n                     span_note_and_lint(cx,\n                                        LET_AND_RETURN,\n@@ -136,14 +138,14 @@ impl LintPass for ReturnPass {\n }\n \n impl EarlyLintPass for ReturnPass {\n-    fn check_fn(&mut self, cx: &EarlyContext, kind: FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n         match kind {\n             FnKind::ItemFn(.., block) | FnKind::Method(.., block) => self.check_block_return(cx, block),\n             FnKind::Closure(body) => self.check_final_expr(cx, body, Some(body.span)),\n         }\n     }\n \n-    fn check_block(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         self.check_let_return(cx, block);\n     }\n }"}, {"sha": "ce326ea72ca81619ac01882465453eafa3f4495e", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::{get_trait_def_id, paths, span_lint};\n \n@@ -29,7 +30,7 @@ impl LintPass for Serde {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Serde {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemImpl(_, _, _, _, Some(ref trait_ref), _, ref items) = item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref items) = item.node {\n             let did = trait_ref.path.def.def_id();\n             if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {\n                 if did == visit_did {"}, {"sha": "aab578d634453f62d06d7128dc269ff8533dfee1", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,10 +1,11 @@\n use crate::reexport::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::ty;\n use syntax::codemap::Span;\n-use crate::utils::{contains_name, higher, in_external_macro, iter_input_pats, snippet, span_lint_and_then};\n+use crate::utils::{contains_name, higher, iter_input_pats, snippet, span_lint_and_then};\n \n /// **What it does:** Checks for bindings that shadow other bindings already in\n /// scope, while just changing reference level or mutability.\n@@ -89,7 +90,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: Span,\n         _: NodeId,\n     ) {\n-        if in_external_macro(cx, body.value.span) {\n+        if in_external_macro(cx.sess(), body.value.span) {\n             return;\n         }\n         check_fn(cx, decl, body);\n@@ -110,8 +111,8 @@ fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, binding\n     let len = bindings.len();\n     for stmt in &block.stmts {\n         match stmt.node {\n-            StmtDecl(ref decl, _) => check_decl(cx, decl, bindings),\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n+            StmtKind::Decl(ref decl, _) => check_decl(cx, decl, bindings),\n+            StmtKind::Expr(ref e, _) | StmtKind::Semi(ref e, _) => check_expr(cx, e, bindings),\n         }\n     }\n     if let Some(ref o) = block.expr {\n@@ -121,13 +122,13 @@ fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, binding\n }\n \n fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings: &mut Vec<(Name, Span)>) {\n-    if in_external_macro(cx, decl.span) {\n+    if in_external_macro(cx.sess(), decl.span) {\n         return;\n     }\n     if higher::is_from_for_desugar(decl) {\n         return;\n     }\n-    if let DeclLocal(ref local) = decl.node {\n+    if let DeclKind::Local(ref local) = decl.node {\n         let Local {\n             ref pat,\n             ref ty,\n@@ -147,7 +148,7 @@ fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings:\n     }\n }\n \n-fn is_binding(cx: &LateContext, pat_id: HirId) -> bool {\n+fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables.node_id_to_type(pat_id);\n     match var_ty.sty {\n         ty::TyAdt(..) => false,\n@@ -185,7 +186,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Struct(_, ref pfields, _) => if let Some(init_struct) = init {\n-            if let ExprStruct(_, ref efields, _) = init_struct.node {\n+            if let ExprKind::Struct(_, ref efields, _) = init_struct.node {\n                 for field in pfields {\n                     let name = field.node.ident.name;\n                     let efield = efields\n@@ -205,7 +206,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Tuple(ref inner, _) => if let Some(init_tup) = init {\n-            if let ExprTup(ref tup) = init_tup.node {\n+            if let ExprKind::Tup(ref tup) = init_tup.node {\n                 for (i, p) in inner.iter().enumerate() {\n                     check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                 }\n@@ -220,7 +221,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Box(ref inner) => if let Some(initp) = init {\n-            if let ExprBox(ref inner_init) = initp.node {\n+            if let ExprKind::Box(ref inner_init) = initp.node {\n                 check_pat(cx, inner, Some(&**inner_init), span, bindings);\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n@@ -302,31 +303,31 @@ fn lint_shadow<'a, 'tcx: 'a>(\n }\n \n fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings: &mut Vec<(Name, Span)>) {\n-    if in_external_macro(cx, expr.span) {\n+    if in_external_macro(cx.sess(), expr.span) {\n         return;\n     }\n     match expr.node {\n-        ExprUnary(_, ref e) | ExprField(ref e, _) | ExprAddrOf(_, ref e) | ExprBox(ref e) => {\n+        ExprKind::Unary(_, ref e) | ExprKind::Field(ref e, _) | ExprKind::AddrOf(_, ref e) | ExprKind::Box(ref e) => {\n             check_expr(cx, e, bindings)\n         },\n-        ExprBlock(ref block, _) | ExprLoop(ref block, _, _) => check_block(cx, block, bindings),\n-        // ExprCall\n-        // ExprMethodCall\n-        ExprArray(ref v) | ExprTup(ref v) => for e in v {\n+        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, _, _) => check_block(cx, block, bindings),\n+        // ExprKind::Call\n+        // ExprKind::MethodCall\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => for e in v {\n             check_expr(cx, e, bindings)\n         },\n-        ExprIf(ref cond, ref then, ref otherwise) => {\n+        ExprKind::If(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n             check_expr(cx, &**then, bindings);\n             if let Some(ref o) = *otherwise {\n                 check_expr(cx, o, bindings);\n             }\n         },\n-        ExprWhile(ref cond, ref block, _) => {\n+        ExprKind::While(ref cond, ref block, _) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, block, bindings);\n         },\n-        ExprMatch(ref init, ref arms, _) => {\n+        ExprKind::Match(ref init, ref arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n             for arm in arms {\n@@ -347,32 +348,32 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n \n fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut Vec<(Name, Span)>) {\n     match ty.node {\n-        TySlice(ref sty) => check_ty(cx, sty, bindings),\n-        TyArray(ref fty, ref anon_const) => {\n+        TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n+        TyKind::Array(ref fty, ref anon_const) => {\n             check_ty(cx, fty, bindings);\n             check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings);\n         },\n-        TyPtr(MutTy { ty: ref mty, .. }) | TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n-        TyTup(ref tup) => for t in tup {\n+        TyKind::Ptr(MutTy { ty: ref mty, .. }) | TyKind::Rptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n+        TyKind::Tup(ref tup) => for t in tup {\n             check_ty(cx, t, bindings)\n         },\n-        TyTypeof(ref anon_const) => check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings),\n+        TyKind::Typeof(ref anon_const) => check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings),\n         _ => (),\n     }\n }\n \n fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBox(ref inner) | ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n-        ExprBlock(ref block, _) => {\n+        ExprKind::Box(ref inner) | ExprKind::AddrOf(_, ref inner) => is_self_shadow(name, inner),\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty()\n                 && block\n                     .expr\n                     .as_ref()\n                     .map_or(false, |e| is_self_shadow(name, e))\n         },\n-        ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n-        ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n+        ExprKind::Unary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n+        ExprKind::Path(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n         _ => false,\n     }\n }"}, {"sha": "a13f864c5ce7debea72e0c385d1f92c84de45c9e", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Spanned;\n use crate::utils::SpanlessEq;\n use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n@@ -82,12 +83,12 @@ impl LintPass for StringAdd {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if !is_allowed(cx, STRING_ADD_ASSIGN, e.id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n-                        if let ExprAssign(ref target, _) = p.node {\n+                        if let ExprKind::Assign(ref target, _) = p.node {\n                             // avoid duplicate matches\n                             if SpanlessEq::new(cx).eq_expr(target, left) {\n                                 return;\n@@ -102,7 +103,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n                     \"you added something to a string. Consider using `String::push_str()` instead\",\n                 );\n             }\n-        } else if let ExprAssign(ref target, ref src) = e.node {\n+        } else if let ExprKind::Assign(ref target, ref src) = e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(\n                     cx,\n@@ -116,14 +117,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     }\n }\n \n-fn is_string(cx: &LateContext, e: &Expr) -> bool {\n+fn is_string(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(e)), &paths::STRING)\n }\n \n-fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n+fn is_add(cx: &LateContext<'_, '_>, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n-        ExprBlock(ref block, _) => {\n+        ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty()\n                 && block\n                     .expr\n@@ -148,9 +149,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use syntax::ast::LitKind;\n         use crate::utils::{in_macro, snippet};\n \n-        if let ExprMethodCall(ref path, _, ref args) = e.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = e.node {\n             if path.ident.name == \"as_bytes\" {\n-                if let ExprLit(ref lit) = args[0].node {\n+                if let ExprKind::Lit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {\n                             span_lint_and_sugg("}, {"sha": "b0a8a2d00617cff2a85fab7cf07f85dbbe5c6de6", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use syntax::ast;\n@@ -59,10 +61,15 @@ impl LintPass for SuspiciousImpl {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        use rustc::hir::BinOp_::*;\n-        if let hir::ExprBinary(binop, _, _) = expr.node {\n+        if let hir::ExprKind::Binary(binop, _, _) = expr.node {\n             match binop.node {\n-                BiEq | BiLt | BiLe | BiNe | BiGe | BiGt => return,\n+                | hir::BinOpKind::Eq\n+                | hir::BinOpKind::Lt\n+                | hir::BinOpKind::Le\n+                | hir::BinOpKind::Ne\n+                | hir::BinOpKind::Ge\n+                | hir::BinOpKind::Gt\n+                => return,\n                 _ => {},\n             }\n             // Check if the binary expression is part of another bi/unary expression\n@@ -71,9 +78,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             while parent_expr != ast::CRATE_NODE_ID {\n                 if let hir::map::Node::NodeExpr(e) = cx.tcx.hir.get(parent_expr) {\n                     match e.node {\n-                        hir::ExprBinary(..)\n-                        | hir::ExprUnary(hir::UnOp::UnNot, _)\n-                        | hir::ExprUnary(hir::UnOp::UnNeg, _) => return,\n+                        hir::ExprKind::Binary(..)\n+                        | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n+                        | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => return,\n                         _ => {},\n                     }\n                 }\n@@ -94,7 +101,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                 expr,\n                 binop.node,\n                 &[\"Add\", \"Sub\", \"Mul\", \"Div\"],\n-                &[BiAdd, BiSub, BiMul, BiDiv],\n+                &[\n+                    hir::BinOpKind::Add,\n+                    hir::BinOpKind::Sub,\n+                    hir::BinOpKind::Mul,\n+                    hir::BinOpKind::Div,\n+                ],\n             ) {\n                 span_lint(\n                     cx,\n@@ -124,7 +136,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                     \"ShrAssign\",\n                 ],\n                 &[\n-                    BiAdd, BiSub, BiMul, BiDiv, BiBitAnd, BiBitOr, BiBitXor, BiRem, BiShl, BiShr\n+                    hir::BinOpKind::Add,\n+                    hir::BinOpKind::Sub,\n+                    hir::BinOpKind::Mul,\n+                    hir::BinOpKind::Div,\n+                    hir::BinOpKind::BitAnd,\n+                    hir::BinOpKind::BitOr,\n+                    hir::BinOpKind::BitXor,\n+                    hir::BinOpKind::Rem,\n+                    hir::BinOpKind::Shl,\n+                    hir::BinOpKind::Shr,\n                 ],\n             ) {\n                 span_lint(\n@@ -142,11 +163,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n }\n \n fn check_binop<'a>(\n-    cx: &LateContext,\n+    cx: &LateContext<'_, '_>,\n     expr: &hir::Expr,\n-    binop: hir::BinOp_,\n+    binop: hir::BinOpKind,\n     traits: &[&'a str],\n-    expected_ops: &[hir::BinOp_],\n+    expected_ops: &[hir::BinOpKind],\n ) -> Option<&'a str> {\n     let mut trait_ids = vec![];\n     let [krate, module] = crate::utils::paths::OPS_MODULE;\n@@ -167,7 +188,7 @@ fn check_binop<'a>(\n     if_chain! {\n         if parent_impl != ast::CRATE_NODE_ID;\n         if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n-        if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n+        if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n         if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.def.def_id());\n         if binop != expected_ops[idx];\n         then{\n@@ -185,9 +206,9 @@ struct BinaryExprVisitor {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for BinaryExprVisitor {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBinary(..)\n-            | hir::ExprUnary(hir::UnOp::UnNot, _)\n-            | hir::ExprUnary(hir::UnOp::UnNeg, _) => {\n+            hir::ExprKind::Binary(..)\n+            | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n+            | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => {\n                 self.in_binary_expr = true\n             },\n             _ => {},"}, {"sha": "38369d05676ca4501dda009231ef92dccacbf784", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,8 @@\n+use matches::matches;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use crate::utils::{differing_macro_contexts, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use crate::utils::sugg::Sugg;\n@@ -57,36 +60,36 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Swap {\n }\n \n /// Implementation of the `MANUAL_SWAP` lint.\n-fn check_manual_swap(cx: &LateContext, block: &Block) {\n+fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n-            if let StmtDecl(ref tmp, _) = w[0].node;\n-            if let DeclLocal(ref tmp) = tmp.node;\n+            if let StmtKind::Decl(ref tmp, _) = w[0].node;\n+            if let DeclKind::Local(ref tmp) = tmp.node;\n             if let Some(ref tmp_init) = tmp.init;\n             if let PatKind::Binding(_, _, ident, None) = tmp.pat.node;\n \n             // foo() = bar();\n-            if let StmtSemi(ref first, _) = w[1].node;\n-            if let ExprAssign(ref lhs1, ref rhs1) = first.node;\n+            if let StmtKind::Semi(ref first, _) = w[1].node;\n+            if let ExprKind::Assign(ref lhs1, ref rhs1) = first.node;\n \n             // bar() = t;\n-            if let StmtSemi(ref second, _) = w[2].node;\n-            if let ExprAssign(ref lhs2, ref rhs2) = second.node;\n-            if let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n+            if let StmtKind::Semi(ref second, _) = w[2].node;\n+            if let ExprKind::Assign(ref lhs2, ref rhs2) = second.node;\n+            if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n             if rhs2.segments.len() == 1;\n \n             if ident.as_str() == rhs2.segments[0].ident.as_str();\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1);\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n             then {\n                 fn check_for_slice<'a>(\n-                    cx: &LateContext,\n+                    cx: &LateContext<'_, '_>,\n                     lhs1: &'a Expr,\n                     lhs2: &'a Expr,\n                 ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n-                    if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n-                        if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n+                    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.node {\n+                        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.node {\n                             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n                                 let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n \n@@ -142,14 +145,14 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint.\n-fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n+fn check_suspicious_swap(cx: &LateContext<'_, '_>, block: &Block) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n-            if let StmtSemi(ref first, _) = w[0].node;\n-            if let StmtSemi(ref second, _) = w[1].node;\n+            if let StmtKind::Semi(ref first, _) = w[0].node;\n+            if let StmtKind::Semi(ref second, _) = w[1].node;\n             if !differing_macro_contexts(first.span, second.span);\n-            if let ExprAssign(ref lhs0, ref rhs0) = first.node;\n-            if let ExprAssign(ref lhs1, ref rhs1) = second.node;\n+            if let ExprKind::Assign(ref lhs0, ref rhs0) = first.node;\n+            if let ExprKind::Assign(ref lhs1, ref rhs1) = second.node;\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n             then {"}, {"sha": "56e705ad0a7217143029d42ff29015f1d4a80ceb", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::hir::{Expr, ExprAssign, ExprField, ExprStruct, ExprTup};\n+use rustc::{declare_lint, lint_array};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::is_adjusted;\n use crate::utils::span_lint;\n \n@@ -23,7 +24,7 @@ declare_clippy_lint! {\n \n fn is_temporary(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprStruct(..) | ExprTup(..) => true,\n+        ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n         _ => false,\n     }\n }\n@@ -39,8 +40,8 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprAssign(ref target, _) = expr.node {\n-            if let ExprField(ref base, _) = target.node {\n+        if let ExprKind::Assign(ref target, _) = expr.node {\n+            if let ExprKind::Field(ref base, _) = target.node {\n                 if is_temporary(base) && !is_adjusted(cx, base) {\n                     span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                 }"}, {"sha": "403aeb47402077d143d7f28a1a3009a1d44f8f77", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use std::borrow::Cow;\n@@ -215,8 +217,8 @@ impl LintPass for Transmute {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(ref qpath) = path_expr.node {\n+        if let ExprKind::Call(ref path_expr, ref args) = e.node {\n+            if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n                         let from_ty = cx.tables.expr_ty(&args[0]);\n@@ -452,7 +454,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n /// the type's `ToString` implementation. In weird cases it could lead to types\n /// with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &QPath, to_ref_ty: Ty) -> String {\n+fn get_type_snippet(cx: &LateContext<'_, '_>, path: &QPath, to_ref_ty: Ty<'_>) -> String {\n     let seg = last_path_segment(path);\n     if_chain! {\n         if let Some(ref params) = seg.args;\n@@ -461,7 +463,7 @@ fn get_type_snippet(cx: &LateContext, path: &QPath, to_ref_ty: Ty) -> String {\n             GenericArg::Type(ty) => Some(ty),\n             GenericArg::Lifetime(_) => None,\n         }).nth(1);\n-        if let TyRptr(_, ref to_ty) = to_ty.node;\n+        if let TyKind::Rptr(_, ref to_ty) = to_ty.node;\n         then {\n             return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n         }"}, {"sha": "6a048b1921384b87af6f201cd32d1e132233b2a2", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,9 +1,12 @@\n use std::cmp;\n \n+use matches::matches;\n use rustc::hir::*;\n use rustc::hir::map::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::TypeVariants;\n use rustc::session::config::Config as SessionConfig;\n use rustc_target::spec::abi::Abi;\n@@ -28,6 +31,12 @@ use crate::utils::{in_macro, is_copy, is_self, span_lint_and_sugg, snippet};\n /// The configuration option `trivial_copy_size_limit` can be set to override\n /// this limit for a project.\n ///\n+/// This lint attempts to allow passing arguments by reference if a reference\n+/// to that argument is returned. This is implemented by comparing the lifetime\n+/// of the argument and return value for equality. However, this can cause\n+/// false positives in cases involving multiple lifetimes that are bounded by\n+/// each other.\n+///\n /// **Example:**\n /// ```rust\n /// fn foo(v: &u32) {\n@@ -100,8 +109,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n \n         // Exclude non-inherent impls\n         if let Some(NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(node_id)) {\n-            if matches!(item.node, ItemImpl(_, _, _, _, Some(_), _, _) |\n-                ItemTrait(..))\n+            if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n+                ItemKind::Trait(..))\n             {\n                 return;\n             }\n@@ -112,18 +121,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n+        // Use lifetimes to determine if we're returning a reference to the\n+        // argument. In that case we can't switch to pass-by-value as the\n+        // argument will not live long enough.\n+        let output_lt = if let TypeVariants::TyRef(output_lt, _, _) = fn_sig.output().sty {\n+            Some(output_lt)\n+        } else {\n+            None\n+        };\n+\n         for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n             // All spans generated from a proc-macro invocation are the same...\n             if span == input.span {\n                 return;\n             }\n \n             if_chain! {\n-                if let TypeVariants::TyRef(_, ty, Mutability::MutImmutable) = ty.sty;\n+                if let TypeVariants::TyRef(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n+                if Some(input_lt) != output_lt;\n                 if is_copy(cx, ty);\n                 if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n                 if size <= self.limit;\n-                if let Ty_::TyRptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n+                if let TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n                 then {\n                     let value_type = if is_self(arg) {\n                         \"self\".into()"}, {"sha": "d016afb4908cdcc8d0525119e26205e5b37150e0", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,8 @@ use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty, TyCtxt, TypeckTables};\n use rustc::ty::layout::LayoutOf;\n use rustc_typeck::hir_ty_to_ty;\n@@ -12,7 +14,7 @@ use std::borrow::Cow;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n-use crate::utils::{comparisons, differing_macro_contexts, higher, in_constant, in_external_macro, in_macro, last_path_segment, match_def_path, match_path,\n+use crate::utils::{comparisons, differing_macro_contexts, higher, in_constant, in_macro, last_path_segment, match_def_path, match_path,\n             match_type, multispan_sugg, opt_def_id, same_tys, snippet, snippet_opt, span_help_and_lint, span_lint,\n             span_lint_and_sugg, span_lint_and_then, clip, unsext, sext, int_bits};\n use crate::utils::paths;\n@@ -136,37 +138,37 @@ impl LintPass for TypePass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext<'_, '_>, _: FnKind<'_>, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n         // skip trait implementations, see #605\n         if let Some(map::NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(id)) {\n-            if let ItemImpl(_, _, _, _, Some(..), _, _) = item.node {\n+            if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n                 return;\n             }\n         }\n \n         check_fn_decl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &StructField) {\n         check_ty(cx, &field.ty, false);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &TraitItem) {\n         match item.node {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty, false),\n             TraitItemKind::Method(ref sig, _) => check_fn_decl(cx, &sig.decl),\n             _ => (),\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext, local: &Local) {\n+    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local) {\n         if let Some(ref ty) = local.ty {\n             check_ty(cx, ty, true);\n         }\n     }\n }\n \n-fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n+fn check_fn_decl(cx: &LateContext<'_, '_>, decl: &FnDecl) {\n     for input in &decl.inputs {\n         check_ty(cx, input, false);\n     }\n@@ -177,7 +179,7 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n }\n \n /// Check if `qpath` has last segment with type parameter matching `path`\n-fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool {\n+fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n     if_chain! {\n         if let Some(ref params) = last.args;\n@@ -186,7 +188,7 @@ fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool\n             GenericArg::Type(ty) => Some(ty),\n             GenericArg::Lifetime(_) => None,\n         });\n-        if let TyPath(ref qpath) = ty.node;\n+        if let TyKind::Path(ref qpath) = ty.node;\n         if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(ty.id)));\n         if match_def_path(cx.tcx, did, path);\n         then {\n@@ -201,12 +203,12 @@ fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool\n ///\n /// The parameter `is_local` distinguishes the context of the type; types from\n /// local bindings should only be checked for the `BORROWED_BOX` lint.\n-fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n+fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n     if in_macro(ast_ty.span) {\n         return;\n     }\n     match ast_ty.node {\n-        TyPath(ref qpath) if !is_local => {\n+        TyKind::Path(ref qpath) if !is_local => {\n             let hir_id = cx.tcx.hir.node_to_hir_id(ast_ty.id);\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if let Some(def_id) = opt_def_id(def) {\n@@ -282,19 +284,19 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                 },\n             }\n         },\n-        TyRptr(ref lt, ref mut_ty) => check_ty_rptr(cx, ast_ty, is_local, lt, mut_ty),\n+        TyKind::Rptr(ref lt, ref mut_ty) => check_ty_rptr(cx, ast_ty, is_local, lt, mut_ty),\n         // recurse\n-        TySlice(ref ty) | TyArray(ref ty, _) | TyPtr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n-        TyTup(ref tys) => for ty in tys {\n+        TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n+        TyKind::Tup(ref tys) => for ty in tys {\n             check_ty(cx, ty, is_local);\n         },\n         _ => {},\n     }\n }\n \n-fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n+fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n     match mut_ty.ty.node {\n-        TyPath(ref qpath) => {\n+        TyKind::Path(ref qpath) => {\n             let hir_id = cx.tcx.hir.node_to_hir_id(mut_ty.ty.id);\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if_chain! {\n@@ -343,7 +345,7 @@ fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifeti\n // Returns true if given type is `Any` trait.\n fn is_any_trait(t: &hir::Ty) -> bool {\n     if_chain! {\n-        if let TyTraitObject(ref traits, _) = t.node;\n+        if let TyKind::TraitObject(ref traits, _) = t.node;\n         if traits.len() >= 1;\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n@@ -376,10 +378,10 @@ declare_clippy_lint! {\n     \"creating a let binding to a value of unit type, which usually can't be used afterwards\"\n }\n \n-fn check_let_unit(cx: &LateContext, decl: &Decl) {\n-    if let DeclLocal(ref local) = decl.node {\n+fn check_let_unit(cx: &LateContext<'_, '_>, decl: &Decl) {\n+    if let DeclKind::Local(ref local) = decl.node {\n         if is_unit(cx.tables.pat_ty(&local.pat)) {\n-            if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n+            if in_external_macro(cx.sess(), decl.span) || in_macro(local.pat.span) {\n                 return;\n             }\n             if higher::is_from_for_desugar(decl) {\n@@ -446,11 +448,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         if in_macro(expr.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, _) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() && is_unit(cx.tables.expr_ty(left)) {\n                 let result = match op {\n-                    BiEq | BiLe | BiGe => \"true\",\n+                    BinOpKind::Eq | BinOpKind::Le | BinOpKind::Ge => \"true\",\n                     _ => \"false\",\n                 };\n                 span_lint(\n@@ -501,7 +503,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n             return;\n         }\n         match expr.node {\n-            ExprCall(_, ref args) | ExprMethodCall(_, _, ref args) => {\n+            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n                 for arg in args {\n                     if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n                         let map = &cx.tcx.hir;\n@@ -539,14 +541,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n \n fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n     use syntax_pos::hygiene::CompilerDesugaringKind;\n-    if let ExprCall(ref callee, _) = expr.node {\n+    if let ExprKind::Call(ref callee, _) = expr.node {\n         callee.span.is_compiler_desugaring(CompilerDesugaringKind::QuestionMark)\n     } else {\n         false\n     }\n }\n \n-fn is_unit(ty: Ty) -> bool {\n+fn is_unit(ty: Ty<'_>) -> bool {\n     match ty.sty {\n         ty::TyTuple(slice) if slice.is_empty() => true,\n         _ => false,\n@@ -555,7 +557,7 @@ fn is_unit(ty: Ty) -> bool {\n \n fn is_unit_literal(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprTup(ref slice) if slice.is_empty() => true,\n+        ExprKind::Tup(ref slice) if slice.is_empty() => true,\n         _ => false,\n     }\n }\n@@ -751,7 +753,7 @@ declare_clippy_lint! {\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n-fn int_ty_to_nbits(typ: Ty, tcx: TyCtxt) -> u64 {\n+fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n     match typ.sty {\n         ty::TyInt(i) => match i {\n             IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n@@ -773,14 +775,14 @@ fn int_ty_to_nbits(typ: Ty, tcx: TyCtxt) -> u64 {\n     }\n }\n \n-fn is_isize_or_usize(typ: Ty) -> bool {\n+fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n     match typ.sty {\n         ty::TyInt(IntTy::Isize) | ty::TyUint(UintTy::Usize) => true,\n         _ => false,\n     }\n }\n \n-fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty<'_>, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -812,15 +814,15 @@ fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_t\n }\n \n fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n-    if let ExprBinary(_, _, _) = op.node {\n+    if let ExprKind::Binary(_, _, _) = op.node {\n         if snip.starts_with('(') && snip.ends_with(')') {\n             return true;\n         }\n     }\n     false\n }\n \n-fn span_lossless_lint(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n     if in_constant(cx, expr.id) { return }\n     // The suggestion is to use a function call, so if the original expression\n@@ -852,7 +854,7 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn check_truncation_and_wrapping(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -923,7 +925,7 @@ fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, c\n     }\n }\n \n-fn check_lossless(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn check_lossless(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n     let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n     let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n@@ -951,13 +953,13 @@ impl LintPass for CastPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprCast(ref ex, _) = expr.node {\n+        if let ExprKind::Cast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n-            if let ExprLit(ref lit) = ex.node {\n+            if let ExprKind::Lit(ref lit) = ex.node {\n                 use syntax::ast::{LitIntType, LitKind};\n                 match lit.node {\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::FloatUnsuffixed(_) => {},\n-                    _ => if cast_from.sty == cast_to.sty && !in_external_macro(cx, expr.span) {\n+                    _ => if cast_from.sty == cast_to.sty && !in_external_macro(cx.sess(), expr.span) {\n                         span_lint(\n                             cx,\n                             UNNECESSARY_CAST,\n@@ -967,7 +969,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                     },\n                 }\n             }\n-            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n+            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n@@ -1141,7 +1143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         match item.node {\n-            ItemStatic(ref ty, _, _) | ItemConst(ref ty, _) => self.check_type(cx, ty),\n+            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => self.check_type(cx, ty),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n@@ -1181,7 +1183,7 @@ impl<'a, 'tcx> TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &hir::Ty) {\n+    fn check_type(&self, cx: &LateContext<'_, '_>, ty: &hir::Ty) {\n         if in_macro(ty.span) {\n             return;\n         }\n@@ -1214,15 +1216,15 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n-            TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n+            TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n \n             // the \"normal\" components of a type: named types, arrays/tuples\n-            TyPath(..) | TySlice(..) | TyTup(..) | TyArray(..) => (10 * self.nest, 1),\n+            TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n \n             // function types bring a lot of overhead\n-            TyBareFn(..) => (50 * self.nest, 1),\n+            TyKind::BareFn(..) => (50 * self.nest, 1),\n \n-            TyTraitObject(ref param_bounds, _) => {\n+            TyKind::TraitObject(ref param_bounds, _) => {\n                 let has_lifetime_parameters = param_bounds\n                     .iter()\n                     .any(|bound| bound.bound_generic_params.iter().any(|gen| match gen.kind {\n@@ -1289,8 +1291,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use syntax::ast::{LitKind, UintTy};\n \n-        if let ExprCast(ref e, _) = expr.node {\n-            if let ExprLit(ref l) = e.node {\n+        if let ExprKind::Cast(ref e, _) = expr.node {\n+            if let ExprKind::Lit(ref l) = e.node {\n                 if let LitKind::Char(_) = l.node {\n                     if ty::TyUint(UintTy::U8) == cx.tables.expr_ty(expr).sty && !in_macro(expr.span) {\n                         let msg = \"casting character literal to u8. `char`s \\\n@@ -1362,7 +1364,7 @@ fn is_cast_between_fixed_and_target<'a, 'tcx>(\n     expr: &'tcx Expr\n ) -> bool {\n \n-    if let ExprCast(ref cast_exp, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n         let precast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n \n@@ -1374,7 +1376,7 @@ fn is_cast_between_fixed_and_target<'a, 'tcx>(\n \n fn detect_absurd_comparison<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    op: BinOp_,\n+    op: BinOpKind,\n     lhs: &'tcx Expr,\n     rhs: &'tcx Expr,\n ) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n@@ -1453,7 +1455,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n         use crate::types::ExtremeType::*;\n         use crate::types::AbsurdComparisonResult::*;\n \n-        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n             if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n                 if !in_macro(expr.span) {\n                     let msg = \"this comparison involving the minimum or maximum element for this \\\n@@ -1560,11 +1562,11 @@ impl Ord for FullInt {\n }\n \n \n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n-    if let ExprCast(ref cast_exp, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n         let pre_cast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n         // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n@@ -1626,8 +1628,8 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n     }\n }\n \n-fn err_upcast_comparison(cx: &LateContext, span: Span, expr: &Expr, always: bool) {\n-    if let ExprCast(ref cast_val, _) = expr.node {\n+fn err_upcast_comparison(cx: &LateContext<'_, '_>, span: Span, expr: &Expr, always: bool) {\n+    if let ExprKind::Cast(ref cast_val, _) = expr.node {\n         span_lint(\n             cx,\n             INVALID_UPCAST_COMPARISONS,\n@@ -1693,7 +1695,7 @@ fn upcast_comparison_bounds_err<'a, 'tcx>(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n             let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n                 val\n@@ -1748,11 +1750,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n \n         fn suggestion<'a, 'tcx>(\n             cx: &LateContext<'a, 'tcx>,\n-            db: &mut DiagnosticBuilder,\n+            db: &mut DiagnosticBuilder<'_>,\n             generics_span: Span,\n             generics_suggestion_span: Span,\n-            target: &ImplicitHasherType,\n-            vis: ImplicitHasherConstructorVisitor,\n+            target: &ImplicitHasherType<'_>,\n+            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n         ) {\n             let generics_snip = snippet(cx, generics_span, \"\");\n             // trim `<` `>`\n@@ -1797,7 +1799,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n         }\n \n         match item.node {\n-            ItemImpl(_, _, _, ref generics, _, ref ty, ref items) => {\n+            ItemKind::Impl(_, _, _, ref generics, _, ref ty, ref items) => {\n                 let mut vis = ImplicitHasherTypeVisitor::new(cx);\n                 vis.visit_ty(ty);\n \n@@ -1829,7 +1831,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n                     );\n                 }\n             },\n-            ItemFn(ref decl, .., ref generics, body_id) => {\n+            ItemKind::Fn(ref decl, .., ref generics, body_id) => {\n                 let body = cx.tcx.hir.body(body_id);\n \n                 for ty in &decl.inputs {\n@@ -1878,7 +1880,7 @@ enum ImplicitHasherType<'tcx> {\n impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a BuildHasher.\n     fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n-        if let TyPath(QPath::Resolved(None, ref path)) = hir_ty.node {\n+        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.node {\n             let params: Vec<_> = path.segments.last().as_ref()?.args.as_ref()?\n                 .args.iter().filter_map(|arg| match arg {\n                     GenericArg::Type(ty) => Some(ty),\n@@ -1984,9 +1986,9 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n \n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref fun, ref args) = e.node;\n-            if let ExprPath(QPath::TypeRelative(ref ty, ref method)) = fun.node;\n-            if let TyPath(QPath::Resolved(None, ref ty_path)) = ty.node;\n+            if let ExprKind::Call(ref fun, ref args) = e.node;\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.node;\n+            if let TyKind::Path(QPath::Resolved(None, ref ty_path)) = ty.node;\n             then {\n                 if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n                     return;"}, {"sha": "0549e774fb55debb70f1c4b6b9408b591c9bf808", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::Span;\n@@ -71,7 +72,7 @@ impl LintPass for Unicode {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprLit(ref lit) = expr.node {\n+        if let ExprKind::Lit(ref lit) = expr.node {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span, expr.id)\n             }\n@@ -93,7 +94,7 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n     result\n }\n \n-fn check_str(cx: &LateContext, span: Span, id: NodeId) {\n+fn check_str(cx: &LateContext<'_, '_>, span: Span, id: NodeId) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n         span_help_and_lint("}, {"sha": "2f8b3ab836db99ab2c6348d1675b1f922cd358e6", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::symbol::LocalInternedString;\n@@ -34,14 +35,14 @@ impl LintPass for UnsafeNameRemoval {\n }\n \n impl EarlyLintPass for UnsafeNameRemoval {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if let ItemKind::Use(ref use_tree) = item.node {\n             check_use_tree(use_tree, cx, item.span);\n         }\n     }\n }\n \n-fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: Span) {\n+fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext<'_>, span: Span) {\n     match use_tree.kind {\n         UseTreeKind::Simple(Some(new_name), ..) => {\n             let old_name = use_tree\n@@ -62,7 +63,7 @@ fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: Span) {\n     }\n }\n \n-fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: Span) {\n+fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext<'_>, span: Span) {\n     let old_str = old_name.name.as_str();\n     let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {"}, {"sha": "a9a7e102ab274bf62554142bd40468c8f3c80926", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir;\n use crate::utils::{is_try, match_qpath, match_trait_method, paths, span_lint};\n \n@@ -38,16 +39,16 @@ impl LintPass for UnusedIoAmount {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n         let expr = match s.node {\n-            hir::StmtSemi(ref expr, _) | hir::StmtExpr(ref expr, _) => &**expr,\n+            hir::StmtKind::Semi(ref expr, _) | hir::StmtKind::Expr(ref expr, _) => &**expr,\n             _ => return,\n         };\n \n         match expr.node {\n-            hir::ExprMatch(ref res, _, _) if is_try(expr).is_some() => {\n-                if let hir::ExprCall(ref func, ref args) = res.node {\n-                    if let hir::ExprPath(ref path) = func.node {\n+            hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n+                if let hir::ExprKind::Call(ref func, ref args) = res.node {\n+                    if let hir::ExprKind::Path(ref path) = func.node {\n                         if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n                             check_method_call(cx, &args[0], expr);\n                         }\n@@ -57,7 +58,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprMethodCall(ref path, _, ref args) => match &*path.ident.as_str() {\n+            hir::ExprKind::MethodCall(ref path, _, ref args) => match &*path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_method_call(cx, &args[0], expr);\n                 },\n@@ -69,8 +70,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n     }\n }\n \n-fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n-    if let hir::ExprMethodCall(ref path, _, _) = call.node {\n+fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr, expr: &hir::Expr) {\n+    if let hir::ExprKind::MethodCall(ref path, _, _) = call.node {\n         let symbol = &*path.ident.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {\n             span_lint("}, {"sha": "1681a303fd37b9fd38bf53708e4ea5560e6c1bf5", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n use std::collections::HashMap;\n@@ -69,10 +70,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBreak(destination, _) | hir::ExprContinue(destination) => if let Some(label) = destination.label {\n+            hir::ExprKind::Break(destination, _) | hir::ExprKind::Continue(destination) => if let Some(label) = destination.label {\n                 self.labels.remove(&label.ident.as_str());\n             },\n-            hir::ExprLoop(_, Some(label), _) | hir::ExprWhile(_, _, Some(label)) => {\n+            hir::ExprKind::Loop(_, Some(label), _) | hir::ExprKind::While(_, _, Some(label)) => {\n                 self.labels.insert(label.ident.as_str(), expr.span);\n             },\n             _ => (),"}, {"sha": "6cafcaeffe9749995d046bec79ffaebca4bcc2c5", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n \n use crate::utils::{in_macro, match_type, paths, span_lint_and_then, usage::is_potentially_mutated};\n use rustc::hir::intravisit::*;\n@@ -78,21 +80,21 @@ fn collect_unwrap_info<'a, 'tcx: 'a>(\n     expr: &'tcx Expr,\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n-    if let Expr_::ExprBinary(op, left, right) = &expr.node {\n+    if let ExprKind::Binary(op, left, right) = &expr.node {\n         match (invert, op.node) {\n-            (false, BinOp_::BiAnd) | (false, BinOp_::BiBitAnd) | (true, BinOp_::BiOr) | (true, BinOp_::BiBitOr) => {\n+            (false, BinOpKind::And) | (false, BinOpKind::BitAnd) | (true, BinOpKind::Or) | (true, BinOpKind::BitOr) => {\n                 let mut unwrap_info = collect_unwrap_info(cx, left, invert);\n                 unwrap_info.append(&mut collect_unwrap_info(cx, right, invert));\n                 return unwrap_info;\n             },\n             _ => (),\n         }\n-    } else if let Expr_::ExprUnary(UnNot, expr) = &expr.node {\n+    } else if let ExprKind::Unary(UnNot, expr) = &expr.node {\n         return collect_unwrap_info(cx, expr, !invert);\n     } else {\n         if_chain! {\n-            if let Expr_::ExprMethodCall(method_name, _, args) = &expr.node;\n-            if let Expr_::ExprPath(QPath::Resolved(None, path)) = &args[0].node;\n+            if let ExprKind::MethodCall(method_name, _, args) = &expr.node;\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].node;\n             let ty = cx.tables.expr_ty(&args[0]);\n             if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n             let name = method_name.ident.as_str();\n@@ -131,7 +133,7 @@ impl<'a, 'tcx: 'a> UnwrappableVariablesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let Expr_::ExprIf(cond, then, els) = &expr.node {\n+        if let ExprKind::If(cond, then, els) = &expr.node {\n             walk_expr(self, cond);\n             self.visit_branch(cond, then, false);\n             if let Some(els) = els {\n@@ -140,8 +142,8 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let Expr_::ExprMethodCall(ref method_name, _, ref args) = expr.node;\n-                if let Expr_::ExprPath(QPath::Resolved(None, ref path)) = args[0].node;\n+                if let ExprKind::MethodCall(ref method_name, _, ref args) = expr.node;\n+                if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].node;\n                 if [\"unwrap\", \"unwrap_err\"].contains(&&*method_name.ident.as_str());\n                 let call_to_unwrap = method_name.ident.name == \"unwrap\";\n                 if let Some(unwrappable) = self.unwrappables.iter()"}, {"sha": "2ea4497a0d1b13aa9eb221ba7b1116c3f4fdd793", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n use crate::utils::{in_macro, span_lint_and_then};\n@@ -55,8 +57,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n             return;\n         }\n         if_chain! {\n-            if let ItemImpl(.., ref item_type, ref refs) = item.node;\n-            if let Ty_::TyPath(QPath::Resolved(_, ref item_path)) = item_type.node;\n+            if let ItemKind::Impl(.., ref item_type, ref refs) = item.node;\n+            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = item_type.node;\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                 let should_check = if let Some(ref params) = *parameters {"}, {"sha": "4310325475a3e49ca643b5b5a1083a9920712816", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -4,8 +4,9 @@\n #![allow(print_stdout, use_debug)]\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir;\n-use rustc::hir::{Expr, Expr_, QPath, Ty_, Pat, PatKind, BindingAnnotation, StmtSemi, StmtExpr, StmtDecl, Decl_, Stmt};\n+use rustc::hir::{Expr, ExprKind, QPath, TyKind, Pat, PatKind, BindingAnnotation, StmtKind, DeclKind, Stmt};\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use syntax::ast::{Attribute, LitKind, DUMMY_NODE_ID};\n use std::collections::HashMap;\n@@ -32,10 +33,10 @@ use crate::utils::get_attr;\n /// ```rust\n /// // ./tests/ui/new_lint.stdout\n /// if_chain!{\n-///     if let Expr_::ExprIf(ref cond, ref then, None) = item.node,\n-///     if let Expr_::ExprBinary(BinOp::Eq, ref left, ref right) = cond.node,\n-///     if let Expr_::ExprPath(ref path) = left.node,\n-///     if let Expr_::ExprLit(ref lit) = right.node,\n+///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n+///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n+///     if let ExprKind::Path(ref path) = left.node,\n+///     if let ExprKind::Lit(ref lit) = right.node,\n ///     if let LitKind::Int(42, _) = lit.node,\n ///     then {\n ///         // report your lint here\n@@ -192,16 +193,16 @@ struct PrintVisitor {\n \n impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     fn visit_expr(&mut self, expr: &Expr) {\n-        print!(\"    if let Expr_::Expr\");\n+        print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.node\", self.current);\n         match expr.node {\n-            Expr_::ExprBox(ref inner) => {\n+            ExprKind::Box(ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprArray(ref elements) => {\n+            ExprKind::Array(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Array(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -210,7 +211,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            Expr_::ExprCall(ref func, ref args) => {\n+            ExprKind::Call(ref func, ref args) => {\n                 let func_pat = self.next(\"func\");\n                 let args_pat = self.next(\"args\");\n                 println!(\"Call(ref {}, ref {}) = {};\", func_pat, args_pat, current);\n@@ -222,11 +223,11 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(arg);\n                 }\n             },\n-            Expr_::ExprMethodCall(ref _method_name, ref _generics, ref _args) => {\n+            ExprKind::MethodCall(ref _method_name, ref _generics, ref _args) => {\n                 println!(\"MethodCall(ref method_name, ref generics, ref args) = {};\", current);\n-                println!(\"    // unimplemented: `ExprMethodCall` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment\");\n             },\n-            Expr_::ExprTup(ref elements) => {\n+            ExprKind::Tup(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Tup(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -235,24 +236,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            Expr_::ExprBinary(ref op, ref left, ref right) => {\n+            ExprKind::Binary(ref op, ref left, ref right) => {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n                 println!(\"Binary(ref {}, ref {}, ref {}) = {};\", op_pat, left_pat, right_pat, current);\n-                println!(\"    if BinOp_::{:?} == {}.node;\", op.node, op_pat);\n+                println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = left_pat;\n                 self.visit_expr(left);\n                 self.current = right_pat;\n                 self.visit_expr(right);\n             },\n-            Expr_::ExprUnary(ref op, ref inner) => {\n+            ExprKind::Unary(ref op, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprLit(ref lit) => {\n+            ExprKind::Lit(ref lit) => {\n                 let lit_pat = self.next(\"lit\");\n                 println!(\"Lit(ref {}) = {};\", lit_pat, current);\n                 match lit.node {\n@@ -277,27 +278,27 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     },\n                 }\n             },\n-            Expr_::ExprCast(ref expr, ref ty) => {\n+            ExprKind::Cast(ref expr, ref ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 let cast_ty = self.next(\"cast_ty\");\n                 let qp_label = self.next(\"qp\");\n \n                 println!(\"Cast(ref {}, ref {}) = {};\", cast_pat, cast_ty, current);\n-                if let Ty_::TyPath(ref qp) = ty.node {\n-                    println!(\"    if let Ty_::TyPath(ref {}) = {}.node;\", qp_label, cast_ty);\n+                if let TyKind::Path(ref qp) = ty.node {\n+                    println!(\"    if let TyKind::Path(ref {}) = {}.node;\", qp_label, cast_ty);\n                     self.current = qp_label;\n                     self.print_qpath(qp);\n                 }\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            Expr_::ExprType(ref expr, ref _ty) => {\n+            ExprKind::Type(ref expr, ref _ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            Expr_::ExprIf(ref cond, ref then, ref opt_else) => {\n+            ExprKind::If(ref cond, ref then, ref opt_else) => {\n                 let cond_pat = self.next(\"cond\");\n                 let then_pat = self.next(\"then\");\n                 if let Some(ref else_) = *opt_else {\n@@ -313,7 +314,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = then_pat;\n                 self.visit_expr(then);\n             },\n-            Expr_::ExprWhile(ref cond, ref body, _) => {\n+            ExprKind::While(ref cond, ref body, _) => {\n                 let cond_pat = self.next(\"cond\");\n                 let body_pat = self.next(\"body\");\n                 let label_pat = self.next(\"label\");\n@@ -323,15 +324,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            Expr_::ExprLoop(ref body, _, desugaring) => {\n+            ExprKind::Loop(ref body, _, desugaring) => {\n                 let body_pat = self.next(\"body\");\n                 let des = loop_desugaring_name(desugaring);\n                 let label_pat = self.next(\"label\");\n                 println!(\"Loop(ref {}, ref {}, {}) = {};\", body_pat, label_pat, des, current);\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            Expr_::ExprMatch(ref expr, ref arms, desugaring) => {\n+            ExprKind::Match(ref expr, ref arms, desugaring) => {\n                 let des = desugaring_name(desugaring);\n                 let expr_pat = self.next(\"expr\");\n                 let arms_pat = self.next(\"arms\");\n@@ -355,23 +356,23 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     }\n                 }\n             },\n-            Expr_::ExprClosure(ref _capture_clause, ref _func, _, _, _) => {\n+            ExprKind::Closure(ref _capture_clause, ref _func, _, _, _) => {\n                 println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n-                println!(\"    // unimplemented: `ExprClosure` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::Closure` is not further destructured at the moment\");\n             },\n-            Expr_::ExprYield(ref sub) => {\n+            ExprKind::Yield(ref sub) => {\n                 let sub_pat = self.next(\"sub\");\n                 println!(\"Yield(ref sub) = {};\", current);\n                 self.current = sub_pat;\n                 self.visit_expr(sub);\n             },\n-            Expr_::ExprBlock(ref block, _) => {\n+            ExprKind::Block(ref block, _) => {\n                 let block_pat = self.next(\"block\");\n                 println!(\"Block(ref {}) = {};\", block_pat, current);\n                 self.current = block_pat;\n                 self.visit_block(block);\n             },\n-            Expr_::ExprAssign(ref target, ref value) => {\n+            ExprKind::Assign(ref target, ref value) => {\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n                 println!(\"Assign(ref {}, ref {}) = {};\", target_pat, value_pat, current);\n@@ -380,26 +381,26 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            Expr_::ExprAssignOp(ref op, ref target, ref value) => {\n+            ExprKind::AssignOp(ref op, ref target, ref value) => {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n                 println!(\"AssignOp(ref {}, ref {}, ref {}) = {};\", op_pat, target_pat, value_pat, current);\n-                println!(\"    if BinOp_::{:?} == {}.node;\", op.node, op_pat);\n+                println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = target_pat;\n                 self.visit_expr(target);\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            Expr_::ExprField(ref object, ref field_ident) => {\n+            ExprKind::Field(ref object, ref field_ident) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n                 println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n                 println!(\"    if {}.node.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n-            Expr_::ExprIndex(ref object, ref index) => {\n+            ExprKind::Index(ref object, ref index) => {\n                 let object_pat = self.next(\"object\");\n                 let index_pat = self.next(\"index\");\n                 println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n@@ -408,19 +409,19 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = index_pat;\n                 self.visit_expr(index);\n             },\n-            Expr_::ExprPath(ref path) => {\n+            ExprKind::Path(ref path) => {\n                 let path_pat = self.next(\"path\");\n                 println!(\"Path(ref {}) = {};\", path_pat, current);\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n-            Expr_::ExprAddrOf(mutability, ref inner) => {\n+            ExprKind::AddrOf(mutability, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"AddrOf({:?}, ref {}) = {};\", mutability, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprBreak(ref _destination, ref opt_value) => {\n+            ExprKind::Break(ref _destination, ref opt_value) => {\n                 let destination_pat = self.next(\"destination\");\n                 if let Some(ref value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n@@ -432,24 +433,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 }\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprContinue(ref _destination) => {\n+            ExprKind::Continue(ref _destination) => {\n                 let destination_pat = self.next(\"destination\");\n                 println!(\"Again(ref {}) = {};\", destination_pat, current);\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprRet(ref opt_value) => if let Some(ref value) = *opt_value {\n+            ExprKind::Ret(ref opt_value) => if let Some(ref value) = *opt_value {\n                 let value_pat = self.next(\"value\");\n                 println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             } else {\n                 println!(\"Ret(None) = {};\", current);\n             },\n-            Expr_::ExprInlineAsm(_, ref _input, ref _output) => {\n+            ExprKind::InlineAsm(_, ref _input, ref _output) => {\n                 println!(\"InlineAsm(_, ref input, ref output) = {};\", current);\n-                println!(\"    // unimplemented: `ExprInlineAsm` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::InlineAsm` is not further destructured at the moment\");\n             },\n-            Expr_::ExprStruct(ref path, ref fields, ref opt_base) => {\n+            ExprKind::Struct(ref path, ref fields, ref opt_base) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n                 if let Some(ref base) = *opt_base {\n@@ -472,7 +473,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"    // unimplemented: field checks\");\n             },\n             // FIXME: compute length (needs type info)\n-            Expr_::ExprRepeat(ref value, _) => {\n+            ExprKind::Repeat(ref value, _) => {\n                 let value_pat = self.next(\"value\");\n                 println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n                 println!(\"// unimplemented: repeat count check\");\n@@ -588,20 +589,20 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     }\n \n     fn visit_stmt(&mut self, s: &Stmt) {\n-        print!(\"    if let Stmt_::\");\n+        print!(\"    if let StmtKind::\");\n         let current = format!(\"{}.node\", self.current);\n         match s.node {\n             // Could be an item or a local (let) binding:\n-            StmtDecl(ref decl, _) => {\n+            StmtKind::Decl(ref decl, _) => {\n                 let decl_pat = self.next(\"decl\");\n-                println!(\"StmtDecl(ref {}, _) = {}\", decl_pat, current);\n-                print!(\"    if let Decl_::\");\n+                println!(\"Decl(ref {}, _) = {}\", decl_pat, current);\n+                print!(\"    if let DeclKind::\");\n                 let current = format!(\"{}.node\", decl_pat);\n                 match decl.node {\n                     // A local (let) binding:\n-                    Decl_::DeclLocal(ref local) => {\n+                    DeclKind::Local(ref local) => {\n                         let local_pat = self.next(\"local\");\n-                        println!(\"DeclLocal(ref {}) = {};\", local_pat, current);\n+                        println!(\"Local(ref {}) = {};\", local_pat, current);\n                         if let Some(ref init) = local.init {\n                             let init_pat = self.next(\"init\");\n                             println!(\"    if let Some(ref {}) = {}.init\", init_pat, local_pat);\n@@ -612,24 +613,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                         self.visit_pat(&local.pat);\n                     },\n                     // An item binding:\n-                    Decl_::DeclItem(_) => {\n-                        println!(\"DeclItem(item_id) = {};\", current);\n+                    DeclKind::Item(_) => {\n+                        println!(\"Item(item_id) = {};\", current);\n                     },\n                 }\n             }\n \n             // Expr without trailing semi-colon (must have unit type):\n-            StmtExpr(ref e, _) => {\n+            StmtKind::Expr(ref e, _) => {\n                 let e_pat = self.next(\"e\");\n-                println!(\"StmtExpr(ref {}, _) = {}\", e_pat, current);\n+                println!(\"Expr(ref {}, _) = {}\", e_pat, current);\n                 self.current = e_pat;\n                 self.visit_expr(e);\n             },\n \n             // Expr with trailing semi-colon (may have any type):\n-            StmtSemi(ref e, _) => {\n+            StmtKind::Semi(ref e, _) => {\n                 let e_pat = self.next(\"e\");\n-                println!(\"StmtSemi(ref {}, _) = {}\", e_pat, current);\n+                println!(\"Semi(ref {}, _) = {}\", e_pat, current);\n                 self.current = e_pat;\n                 self.visit_expr(e);\n             },\n@@ -674,7 +675,7 @@ fn print_path(path: &QPath, first: &mut bool) {\n             print!(\"{:?}\", segment.ident.as_str());\n         },\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n-            hir::Ty_::TyPath(ref inner_path) => {\n+            hir::TyKind::Path(ref inner_path) => {\n                 print_path(inner_path, first);\n                 if *first {\n                     *first = false;"}, {"sha": "35f41d400ad8417db4f416f14f3ed81d908c3de4", "filename": "clippy_lints/src/utils/comparisons.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,7 +2,7 @@\n \n #![deny(missing_docs_in_private_items)]\n \n-use rustc::hir::{BinOp_, Expr};\n+use rustc::hir::{BinOpKind, Expr};\n \n #[derive(PartialEq, Eq, Debug, Copy, Clone)]\n /// Represent a normalized comparison operator.\n@@ -19,14 +19,14 @@ pub enum Rel {\n \n /// Put the expression in the form  `lhs < rhs`, `lhs <= rhs`, `lhs == rhs` or\n /// `lhs != rhs`.\n-pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Rel, &'a Expr, &'a Expr)> {\n+pub fn normalize_comparison<'a>(op: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Rel, &'a Expr, &'a Expr)> {\n     match op {\n-        BinOp_::BiLt => Some((Rel::Lt, lhs, rhs)),\n-        BinOp_::BiLe => Some((Rel::Le, lhs, rhs)),\n-        BinOp_::BiGt => Some((Rel::Lt, rhs, lhs)),\n-        BinOp_::BiGe => Some((Rel::Le, rhs, lhs)),\n-        BinOp_::BiEq => Some((Rel::Eq, rhs, lhs)),\n-        BinOp_::BiNe => Some((Rel::Ne, rhs, lhs)),\n+        BinOpKind::Lt => Some((Rel::Lt, lhs, rhs)),\n+        BinOpKind::Le => Some((Rel::Le, lhs, rhs)),\n+        BinOpKind::Gt => Some((Rel::Lt, rhs, lhs)),\n+        BinOpKind::Ge => Some((Rel::Le, rhs, lhs)),\n+        BinOpKind::Eq => Some((Rel::Eq, rhs, lhs)),\n+        BinOpKind::Ne => Some((Rel::Ne, rhs, lhs)),\n         _ => None,\n     }\n }"}, {"sha": "a27013344d8e9586f8eba8a1b1dcd8e34820a0c6", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,6 +2,7 @@\n \n #![deny(missing_docs_in_private_items)]\n \n+use lazy_static::lazy_static;\n use std::{env, fmt, fs, io, path};\n use std::io::Read;\n use syntax::{ast, codemap};\n@@ -51,7 +52,7 @@ pub enum Error {\n }\n \n impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n             Error::Io(ref err) => err.fmt(f),\n             Error::Toml(ref err) => err.fmt(f),\n@@ -86,10 +87,10 @@ macro_rules! define_Conf {\n         //\n         #[allow(rust_2018_idioms)]\n         mod helpers {\n+            use serde_derive::Deserialize;\n             /// Type used to store lint configuration.\n             #[derive(Deserialize)]\n-            #[serde(rename_all=\"kebab-case\")]\n-            #[serde(deny_unknown_fields)]\n+            #[serde(rename_all=\"kebab-case\", deny_unknown_fields)]\n             pub struct Conf {\n                 $(#[$doc] #[serde(default=$rust_name_str)] #[serde(with=$rust_name_str)]\n                           pub $rust_name: define_Conf!(TY $($ty)+),)+"}, {"sha": "3931f6c55f9ed0b9bda60de4be8d1d00602152db", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,32 +3,33 @@\n \n #![deny(missing_docs_in_private_items)]\n \n+use if_chain::if_chain;\n use rustc::{hir, ty};\n use rustc::lint::LateContext;\n use syntax::ast;\n use crate::utils::{is_expn_of, match_def_path, match_qpath, opt_def_id, paths, resolve_node};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n-pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n+pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n     match op {\n-        hir::BiEq => ast::BinOpKind::Eq,\n-        hir::BiGe => ast::BinOpKind::Ge,\n-        hir::BiGt => ast::BinOpKind::Gt,\n-        hir::BiLe => ast::BinOpKind::Le,\n-        hir::BiLt => ast::BinOpKind::Lt,\n-        hir::BiNe => ast::BinOpKind::Ne,\n-        hir::BiOr => ast::BinOpKind::Or,\n-        hir::BiAdd => ast::BinOpKind::Add,\n-        hir::BiAnd => ast::BinOpKind::And,\n-        hir::BiBitAnd => ast::BinOpKind::BitAnd,\n-        hir::BiBitOr => ast::BinOpKind::BitOr,\n-        hir::BiBitXor => ast::BinOpKind::BitXor,\n-        hir::BiDiv => ast::BinOpKind::Div,\n-        hir::BiMul => ast::BinOpKind::Mul,\n-        hir::BiRem => ast::BinOpKind::Rem,\n-        hir::BiShl => ast::BinOpKind::Shl,\n-        hir::BiShr => ast::BinOpKind::Shr,\n-        hir::BiSub => ast::BinOpKind::Sub,\n+        hir::BinOpKind::Eq => ast::BinOpKind::Eq,\n+        hir::BinOpKind::Ge => ast::BinOpKind::Ge,\n+        hir::BinOpKind::Gt => ast::BinOpKind::Gt,\n+        hir::BinOpKind::Le => ast::BinOpKind::Le,\n+        hir::BinOpKind::Lt => ast::BinOpKind::Lt,\n+        hir::BinOpKind::Ne => ast::BinOpKind::Ne,\n+        hir::BinOpKind::Or => ast::BinOpKind::Or,\n+        hir::BinOpKind::Add => ast::BinOpKind::Add,\n+        hir::BinOpKind::And => ast::BinOpKind::And,\n+        hir::BinOpKind::BitAnd => ast::BinOpKind::BitAnd,\n+        hir::BinOpKind::BitOr => ast::BinOpKind::BitOr,\n+        hir::BinOpKind::BitXor => ast::BinOpKind::BitXor,\n+        hir::BinOpKind::Div => ast::BinOpKind::Div,\n+        hir::BinOpKind::Mul => ast::BinOpKind::Mul,\n+        hir::BinOpKind::Rem => ast::BinOpKind::Rem,\n+        hir::BinOpKind::Shl => ast::BinOpKind::Shl,\n+        hir::BinOpKind::Shr => ast::BinOpKind::Shr,\n+        hir::BinOpKind::Sub => ast::BinOpKind::Sub,\n     }\n }\n \n@@ -87,7 +88,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n     // `#[no_std]`. Testing both instead of resolving the paths.\n \n     match expr.node {\n-        hir::ExprPath(ref path) => {\n+        hir::ExprKind::Path(ref path) => {\n             if match_qpath(path, &paths::RANGE_FULL_STD) || match_qpath(path, &paths::RANGE_FULL) {\n                 Some(Range {\n                     start: None,\n@@ -98,7 +99,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n                 None\n             }\n         },\n-        hir::ExprCall(ref path, ref args) => if let hir::ExprPath(ref path) = path.node {\n+        hir::ExprKind::Call(ref path, ref args) => if let hir::ExprKind::Path(ref path) = path.node {\n             if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW) || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW) {\n                 Some(Range {\n                     start: Some(&args[0]),\n@@ -111,7 +112,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n         } else {\n             None\n         },\n-        hir::ExprStruct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD)\n+        hir::ExprKind::Struct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD)\n             || match_qpath(path, &paths::RANGE_FROM)\n         {\n             Some(Range {\n@@ -154,9 +155,9 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     // }\n     // ```\n     if_chain! {\n-        if let hir::DeclLocal(ref loc) = decl.node;\n+        if let hir::DeclKind::Local(ref loc) = decl.node;\n         if let Some(ref expr) = loc.init;\n-        if let hir::ExprMatch(_, _, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.node;\n         then {\n             return true;\n         }\n@@ -171,7 +172,7 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     // }\n     // ```\n     if_chain! {\n-        if let hir::DeclLocal(ref loc) = decl.node;\n+        if let hir::DeclKind::Local(ref loc) = decl.node;\n         if let hir::LocalSource::ForLoopDesugar = loc.source;\n         then {\n             return true;\n@@ -185,15 +186,15 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)> {\n     if_chain! {\n-        if let hir::ExprMatch(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node;\n-        if let hir::ExprCall(_, ref iterargs) = iterexpr.node;\n+        if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.node;\n         if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprLoop(ref block, _, _) = arms[0].body.node;\n+        if let hir::ExprKind::Loop(ref block, _, _) = arms[0].body.node;\n         if block.expr.is_none();\n         if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-        if let hir::StmtDecl(ref decl, _) = let_stmt.node;\n-        if let hir::DeclLocal(ref decl) = decl.node;\n-        if let hir::StmtExpr(ref expr, _) = body.node;\n+        if let hir::StmtKind::Decl(ref decl, _) = let_stmt.node;\n+        if let hir::DeclKind::Local(ref decl) = decl.node;\n+        if let hir::StmtKind::Expr(ref expr, _) = body.node;\n         then {\n             return Some((&*decl.pat, &iterargs[0], expr));\n         }\n@@ -211,10 +212,10 @@ pub enum VecArgs<'a> {\n \n /// Returns the arguments of the `vec!` macro if this expression was expanded\n /// from `vec!`.\n-pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n+pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_chain! {\n-        if let hir::ExprCall(ref fun, ref args) = expr.node;\n-        if let hir::ExprPath(ref path) = fun.node;\n+        if let hir::ExprKind::Call(ref fun, ref args) = expr.node;\n+        if let hir::ExprKind::Path(ref path) = fun.node;\n         if is_expn_of(fun.span, \"vec\").is_some();\n         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, path, fun.hir_id));\n         then {\n@@ -225,8 +226,8 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n             else if match_def_path(cx.tcx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                 // `vec![a, b, c]` case\n                 if_chain! {\n-                    if let hir::ExprBox(ref boxed) = args[0].node;\n-                    if let hir::ExprArray(ref args) = boxed.node;\n+                    if let hir::ExprKind::Box(ref boxed) = args[0].node;\n+                    if let hir::ExprKind::Array(ref args) = boxed.node;\n                     then {\n                         return Some(VecArgs::Vec(&*args));\n                     }"}, {"sha": "2c5995f1327c2b28849119236aac8b0a466e9906", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 142, "deletions": 114, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -43,14 +43,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     /// Check whether two statements are the same.\n     pub fn eq_stmt(&mut self, left: &Stmt, right: &Stmt) -> bool {\n         match (&left.node, &right.node) {\n-            (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n-                if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n+            (&StmtKind::Decl(ref l, _), &StmtKind::Decl(ref r, _)) => {\n+                if let (&DeclKind::Local(ref l), &DeclKind::Local(ref r)) = (&l.node, &r.node) {\n                     both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) && both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                 } else {\n                     false\n                 }\n             },\n-            (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) | (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => {\n+            (&StmtKind::Expr(ref l, _), &StmtKind::Expr(ref r, _)) | (&StmtKind::Semi(ref l, _), &StmtKind::Semi(ref r, _)) => {\n                 self.eq_expr(l, r)\n             },\n             _ => false,\n@@ -75,69 +75,69 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n \n         match (&left.node, &right.node) {\n-            (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprContinue(li), &ExprContinue(ri)) => {\n+            (&ExprKind::AddrOf(l_mut, ref le), &ExprKind::AddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n+            (&ExprKind::Continue(li), &ExprKind::Continue(ri)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n-            (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n-            (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n+            (&ExprKind::Assign(ref ll, ref lr), &ExprKind::Assign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n+            (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n-            (&ExprBlock(ref l, _), &ExprBlock(ref r, _)) => self.eq_block(l, r),\n-            (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n+            (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n+            (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     || swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                         l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     })\n             },\n-            (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) => {\n+            (&ExprKind::Break(li, ref le), &ExprKind::Break(ri, ref re)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n-            (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n+            (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n+            (&ExprKind::Call(ref l_fun, ref l_args), &ExprKind::Call(ref r_fun, ref r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) |\n-            (&ExprType(ref lx, ref lt), &ExprType(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n-            (&ExprField(ref l_f_exp, ref l_f_ident), &ExprField(ref r_f_exp, ref r_f_ident)) => {\n+            (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt)) |\n+            (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n+            (&ExprKind::Field(ref l_f_exp, ref l_f_ident), &ExprKind::Field(ref r_f_exp, ref r_f_ident)) => {\n                 l_f_ident.name == r_f_ident.name && self.eq_expr(l_f_exp, r_f_exp)\n             },\n-            (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n-            (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n+            (&ExprKind::Index(ref la, ref li), &ExprKind::Index(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n+            (&ExprKind::If(ref lc, ref lt, ref le), &ExprKind::If(ref rc, ref rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-            (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n+            (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n+            (&ExprKind::Loop(ref lb, ref ll, ref lls), &ExprKind::Loop(ref rb, ref rl, ref rls)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n-            (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n+            (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) && over(la, ra, |l, r| {\n                     self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r))\n                         && over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             },\n-            (&ExprMethodCall(ref l_path, _, ref l_args), &ExprMethodCall(ref r_path, _, ref r_args)) => {\n-                !self.ignore_fn && l_path == r_path && self.eq_exprs(l_args, r_args)\n+            (&ExprKind::MethodCall(ref l_path, _, ref l_args), &ExprKind::MethodCall(ref r_path, _, ref r_args)) => {\n+                !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprRepeat(ref le, ref ll_id), &ExprRepeat(ref re, ref rl_id)) => {\n+            (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n                 let ll = celcx.expr(&self.cx.tcx.hir.body(ll_id.body).value);\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n                 let rl = celcx.expr(&self.cx.tcx.hir.body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n             },\n-            (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n-            (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n+            (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n+            (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (&ExprKind::Struct(ref l_path, ref lf, ref lo), &ExprKind::Struct(ref r_path, ref rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r))\n                     && over(lf, rf, |l, r| self.eq_field(l, r))\n             },\n-            (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n-            (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n-            (&ExprArray(ref l), &ExprArray(ref r)) => self.eq_exprs(l, r),\n-            (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n+            (&ExprKind::Tup(ref l_tup), &ExprKind::Tup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n+            (&ExprKind::Unary(l_op, ref le), &ExprKind::Unary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n+            (&ExprKind::Array(ref l), &ExprKind::Array(ref r)) => self.eq_exprs(l, r),\n+            (&ExprKind::While(ref lc, ref lb, ref ll), &ExprKind::While(ref rc, ref rb, ref rl)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             _ => false,\n@@ -225,7 +225,11 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n+    pub fn eq_path_segments(&mut self, left: &[PathSegment], right: &[PathSegment]) -> bool {\n+        left.len() == right.len() && left.iter().zip(right).all(|(l, r)| self.eq_path_segment(l, r))\n+    }\n+\n+    pub fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n         if left.ident.as_str() != right.ident.as_str() {\n@@ -238,10 +242,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n-        match (&left.node, &right.node) {\n-            (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyArray(ref lt, ref ll_id), &TyArray(ref rt, ref rl_id)) => {\n+    pub fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n+        self.eq_ty_kind(&left.node, &right.node)\n+    }\n+\n+    pub fn eq_ty_kind(&mut self, left: &TyKind, right: &TyKind) -> bool {\n+        match (left, right) {\n+            (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n+            (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n                 let full_table = self.tables;\n \n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n@@ -256,13 +264,13 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 self.tables = full_table;\n                 eq_ty && ll == rl\n             },\n-            (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n-            (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n+            (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n+            (&TyKind::Rptr(_, ref l_rmut), &TyKind::Rptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             },\n-            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, r),\n-            (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n-            (&TyInfer, &TyInfer) => true,\n+            (&TyKind::Path(ref l), &TyKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (&TyKind::Tup(ref l), &TyKind::Tup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n+            (&TyKind::Infer, &TyKind::Infer) => true,\n             _ => false,\n         }\n     }\n@@ -272,14 +280,26 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n }\n \n-fn swap_binop<'a>(binop: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOp_, &'a Expr, &'a Expr)> {\n+fn swap_binop<'a>(binop: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOpKind, &'a Expr, &'a Expr)> {\n     match binop {\n-        BiAdd | BiMul | BiBitXor | BiBitAnd | BiEq | BiNe | BiBitOr => Some((binop, rhs, lhs)),\n-        BiLt => Some((BiGt, rhs, lhs)),\n-        BiLe => Some((BiGe, rhs, lhs)),\n-        BiGe => Some((BiLe, rhs, lhs)),\n-        BiGt => Some((BiLt, rhs, lhs)),\n-        BiShl | BiShr | BiRem | BiSub | BiDiv | BiAnd | BiOr => None,\n+        BinOpKind::Add |\n+        BinOpKind::Mul |\n+        BinOpKind::Eq |\n+        BinOpKind::Ne |\n+        BinOpKind::BitAnd |\n+        BinOpKind::BitXor |\n+        BinOpKind::BitOr => Some((binop, rhs, lhs)),\n+        BinOpKind::Lt => Some((BinOpKind::Gt, rhs, lhs)),\n+        BinOpKind::Le => Some((BinOpKind::Ge, rhs, lhs)),\n+        BinOpKind::Ge => Some((BinOpKind::Le, rhs, lhs)),\n+        BinOpKind::Gt => Some((BinOpKind::Lt, rhs, lhs)),\n+        BinOpKind::Shl |\n+        BinOpKind::Shr |\n+        BinOpKind::Rem |\n+        BinOpKind::Sub |\n+        BinOpKind::Div |\n+        BinOpKind::And |\n+        BinOpKind::Or => None,\n     }\n }\n \n@@ -336,7 +356,12 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             self.hash_expr(e);\n         }\n \n-        b.rules.hash(&mut self.s);\n+        match b.rules {\n+            BlockCheckMode::DefaultBlock => 0,\n+            BlockCheckMode::UnsafeBlock(_) => 1,\n+            BlockCheckMode::PushUnsafeBlock(_) => 2,\n+            BlockCheckMode::PopUnsafeBlock(_) => 3,\n+        }.hash(&mut self.s);\n     }\n \n     #[allow(many_single_char_names)]\n@@ -346,51 +371,51 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         }\n \n         match e.node {\n-            ExprAddrOf(m, ref e) => {\n-                let c: fn(_, _) -> _ = ExprAddrOf;\n+            ExprKind::AddrOf(m, ref e) => {\n+                let c: fn(_, _) -> _ = ExprKind::AddrOf;\n                 c.hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprContinue(i) => {\n-                let c: fn(_) -> _ = ExprContinue;\n+            ExprKind::Continue(i) => {\n+                let c: fn(_) -> _ = ExprKind::Continue;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprYield(ref e) => {\n-                let c: fn(_) -> _ = ExprYield;\n+            ExprKind::Yield(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Yield;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprAssign(ref l, ref r) => {\n-                let c: fn(_, _) -> _ = ExprAssign;\n+            ExprKind::Assign(ref l, ref r) => {\n+                let c: fn(_, _) -> _ = ExprKind::Assign;\n                 c.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprAssignOp(ref o, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprAssignOp;\n+            ExprKind::AssignOp(ref o, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::AssignOp;\n                 c.hash(&mut self.s);\n                 o.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprBlock(ref b, _) => {\n-                let c: fn(_, _) -> _ = ExprBlock;\n+            ExprKind::Block(ref b, _) => {\n+                let c: fn(_, _) -> _ = ExprKind::Block;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n             },\n-            ExprBinary(op, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprBinary;\n+            ExprKind::Binary(op, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Binary;\n                 c.hash(&mut self.s);\n                 op.node.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprBreak(i, ref j) => {\n-                let c: fn(_, _) -> _ = ExprBreak;\n+            ExprKind::Break(i, ref j) => {\n+                let c: fn(_, _) -> _ = ExprKind::Break;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n@@ -399,69 +424,72 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(&*j);\n                 }\n             },\n-            ExprBox(ref e) => {\n-                let c: fn(_) -> _ = ExprBox;\n+            ExprKind::Box(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Box;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprCall(ref fun, ref args) => {\n-                let c: fn(_, _) -> _ = ExprCall;\n+            ExprKind::Call(ref fun, ref args) => {\n+                let c: fn(_, _) -> _ = ExprKind::Call;\n                 c.hash(&mut self.s);\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n-            ExprCast(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprCast;\n+            ExprKind::Cast(ref e, ref _ty) => {\n+                let c: fn(_, _) -> _ = ExprKind::Cast;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n-            ExprClosure(cap, _, eid, _, _) => {\n-                let c: fn(_, _, _, _, _) -> _ = ExprClosure;\n+            ExprKind::Closure(cap, _, eid, _, _) => {\n+                let c: fn(_, _, _, _, _) -> _ = ExprKind::Closure;\n                 c.hash(&mut self.s);\n-                cap.hash(&mut self.s);\n+                match cap {\n+                    CaptureClause::CaptureByValue => 0,\n+                    CaptureClause::CaptureByRef => 1,\n+                }.hash(&mut self.s);\n                 self.hash_expr(&self.cx.tcx.hir.body(eid).value);\n             },\n-            ExprField(ref e, ref f) => {\n-                let c: fn(_, _) -> _ = ExprField;\n+            ExprKind::Field(ref e, ref f) => {\n+                let c: fn(_, _) -> _ = ExprKind::Field;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_name(f.name);\n             },\n-            ExprIndex(ref a, ref i) => {\n-                let c: fn(_, _) -> _ = ExprIndex;\n+            ExprKind::Index(ref a, ref i) => {\n+                let c: fn(_, _) -> _ = ExprKind::Index;\n                 c.hash(&mut self.s);\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n             },\n-            ExprInlineAsm(..) => {\n-                let c: fn(_, _, _) -> _ = ExprInlineAsm;\n+            ExprKind::InlineAsm(..) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::InlineAsm;\n                 c.hash(&mut self.s);\n             },\n-            ExprIf(ref cond, ref t, ref e) => {\n-                let c: fn(_, _, _) -> _ = ExprIf;\n+            ExprKind::If(ref cond, ref t, ref e) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::If;\n                 c.hash(&mut self.s);\n                 self.hash_expr(cond);\n                 self.hash_expr(&**t);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprLit(ref l) => {\n-                let c: fn(_) -> _ = ExprLit;\n+            ExprKind::Lit(ref l) => {\n+                let c: fn(_) -> _ = ExprKind::Lit;\n                 c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n             },\n-            ExprLoop(ref b, ref i, _) => {\n-                let c: fn(_, _, _) -> _ = ExprLoop;\n+            ExprKind::Loop(ref b, ref i, _) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Loop;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprMatch(ref e, ref arms, ref s) => {\n-                let c: fn(_, _, _) -> _ = ExprMatch;\n+            ExprKind::Match(ref e, ref arms, ref s) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Match;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n \n@@ -475,35 +503,35 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprMethodCall(ref path, ref _tys, ref args) => {\n-                let c: fn(_, _, _) -> _ = ExprMethodCall;\n+            ExprKind::MethodCall(ref path, ref _tys, ref args) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::MethodCall;\n                 c.hash(&mut self.s);\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n-            ExprRepeat(ref e, ref l_id) => {\n-                let c: fn(_, _) -> _ = ExprRepeat;\n+            ExprKind::Repeat(ref e, ref l_id) => {\n+                let c: fn(_, _) -> _ = ExprKind::Repeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 let full_table = self.tables;\n                 self.tables = self.cx.tcx.body_tables(l_id.body);\n                 self.hash_expr(&self.cx.tcx.hir.body(l_id.body).value);\n                 self.tables = full_table;\n             },\n-            ExprRet(ref e) => {\n-                let c: fn(_) -> _ = ExprRet;\n+            ExprKind::Ret(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Ret;\n                 c.hash(&mut self.s);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprPath(ref qpath) => {\n-                let c: fn(_) -> _ = ExprPath;\n+            ExprKind::Path(ref qpath) => {\n+                let c: fn(_) -> _ = ExprKind::Path;\n                 c.hash(&mut self.s);\n                 self.hash_qpath(qpath);\n             },\n-            ExprStruct(ref path, ref fields, ref expr) => {\n-                let c: fn(_, _, _) -> _ = ExprStruct;\n+            ExprKind::Struct(ref path, ref fields, ref expr) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Struct;\n                 c.hash(&mut self.s);\n \n                 self.hash_qpath(path);\n@@ -517,32 +545,32 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprTup(ref tup) => {\n-                let c: fn(_) -> _ = ExprTup;\n+            ExprKind::Tup(ref tup) => {\n+                let c: fn(_) -> _ = ExprKind::Tup;\n                 c.hash(&mut self.s);\n                 self.hash_exprs(tup);\n             },\n-            ExprType(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprType;\n+            ExprKind::Type(ref e, ref _ty) => {\n+                let c: fn(_, _) -> _ = ExprKind::Type;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n-            ExprUnary(lop, ref le) => {\n-                let c: fn(_, _) -> _ = ExprUnary;\n+            ExprKind::Unary(lop, ref le) => {\n+                let c: fn(_, _) -> _ = ExprKind::Unary;\n                 c.hash(&mut self.s);\n \n                 lop.hash(&mut self.s);\n                 self.hash_expr(le);\n             },\n-            ExprArray(ref v) => {\n-                let c: fn(_) -> _ = ExprArray;\n+            ExprKind::Array(ref v) => {\n+                let c: fn(_) -> _ = ExprKind::Array;\n                 c.hash(&mut self.s);\n \n                 self.hash_exprs(v);\n             },\n-            ExprWhile(ref cond, ref b, l) => {\n-                let c: fn(_, _, _) -> _ = ExprWhile;\n+            ExprKind::While(ref cond, ref b, l) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::While;\n                 c.hash(&mut self.s);\n \n                 self.hash_expr(cond);\n@@ -585,23 +613,23 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_stmt(&mut self, b: &Stmt) {\n         match b.node {\n-            StmtDecl(ref decl, _) => {\n-                let c: fn(_, _) -> _ = StmtDecl;\n+            StmtKind::Decl(ref decl, _) => {\n+                let c: fn(_, _) -> _ = StmtKind::Decl;\n                 c.hash(&mut self.s);\n \n-                if let DeclLocal(ref local) = decl.node {\n+                if let DeclKind::Local(ref local) = decl.node {\n                     if let Some(ref init) = local.init {\n                         self.hash_expr(init);\n                     }\n                 }\n             },\n-            StmtExpr(ref expr, _) => {\n-                let c: fn(_, _) -> _ = StmtExpr;\n+            StmtKind::Expr(ref expr, _) => {\n+                let c: fn(_, _) -> _ = StmtKind::Expr;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n             },\n-            StmtSemi(ref expr, _) => {\n-                let c: fn(_, _) -> _ = StmtSemi;\n+            StmtKind::Semi(ref expr, _) => {\n+                let c: fn(_, _) -> _ = StmtKind::Semi;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n             },"}, {"sha": "b6c241a682533d9021cf6d6dbfd5ef73e4db5451", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,7 @@\n //! checks for attributes\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir;\n use rustc::hir::print;\n use syntax::ast::Attribute;\n@@ -51,14 +52,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         println!(\"impl item `{}`\", item.ident.name);\n-        match item.vis {\n-            hir::Visibility::Public => println!(\"public\"),\n-            hir::Visibility::Crate(_) => println!(\"visible crate wide\"),\n-            hir::Visibility::Restricted { ref path, .. } => println!(\n+        match item.vis.node {\n+            hir::VisibilityKind::Public => println!(\"public\"),\n+            hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n+            hir::VisibilityKind::Restricted { ref path, .. } => println!(\n                 \"visible in module `{}`\",\n                 print::to_string(print::NO_ANN, |s| s.print_path(path, false))\n             ),\n-            hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n+            hir::VisibilityKind::Inherited => println!(\"visibility inherited from outer item\"),\n         }\n         if item.defaultness.is_default() {\n             println!(\"default\");\n@@ -70,6 +71,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             },\n             hir::ImplItemKind::Method(..) => println!(\"method\"),\n             hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n+            hir::ImplItemKind::Existential(_) => println!(\"existential type\"),\n         }\n     }\n     // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n@@ -122,8 +124,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => print_decl(cx, decl),\n-            hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n+            hir::StmtKind::Decl(ref decl, _) => print_decl(cx, decl),\n+            hir::StmtKind::Expr(ref e, _) | hir::StmtKind::Semi(ref e, _) => print_expr(cx, e, 0),\n         }\n     }\n     // fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n@@ -139,9 +141,9 @@ fn has_attr(attrs: &[Attribute]) -> bool {\n     get_attr(attrs, \"dump\").count() > 0\n }\n \n-fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n+fn print_decl(cx: &LateContext<'_, '_>, decl: &hir::Decl) {\n     match decl.node {\n-        hir::DeclLocal(ref local) => {\n+        hir::DeclKind::Local(ref local) => {\n             println!(\"local variable of type {}\", cx.tables.node_id_to_type(local.hir_id));\n             println!(\"pattern:\");\n             print_pat(cx, &local.pat, 0);\n@@ -150,27 +152,27 @@ fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n                 print_expr(cx, e, 0);\n             }\n         },\n-        hir::DeclItem(_) => println!(\"item decl\"),\n+        hir::DeclKind::Item(_) => println!(\"item decl\"),\n     }\n }\n \n-fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n+fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n     println!(\"{}adjustments: {:?}\", ind, cx.tables.adjustments().get(expr.hir_id));\n     match expr.node {\n-        hir::ExprBox(ref e) => {\n+        hir::ExprKind::Box(ref e) => {\n             println!(\"{}Box\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprArray(ref v) => {\n+        hir::ExprKind::Array(ref v) => {\n             println!(\"{}Array\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprCall(ref func, ref args) => {\n+        hir::ExprKind::Call(ref func, ref args) => {\n             println!(\"{}Call\", ind);\n             println!(\"{}function:\", ind);\n             print_expr(cx, func, indent + 1);\n@@ -179,47 +181,47 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprMethodCall(ref path, _, ref args) => {\n+        hir::ExprKind::MethodCall(ref path, _, ref args) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprTup(ref v) => {\n+        hir::ExprKind::Tup(ref v) => {\n             println!(\"{}Tup\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             println!(\"{}Binary\", ind);\n             println!(\"{}op: {:?}\", ind, op.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprUnary(op, ref inner) => {\n+        hir::ExprKind::Unary(op, ref inner) => {\n             println!(\"{}Unary\", ind);\n             println!(\"{}op: {:?}\", ind, op);\n             print_expr(cx, inner, indent + 1);\n         },\n-        hir::ExprLit(ref lit) => {\n+        hir::ExprKind::Lit(ref lit) => {\n             println!(\"{}Lit\", ind);\n             println!(\"{}{:?}\", ind, lit);\n         },\n-        hir::ExprCast(ref e, ref target) => {\n+        hir::ExprKind::Cast(ref e, ref target) => {\n             println!(\"{}Cast\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n-        hir::ExprType(ref e, ref target) => {\n+        hir::ExprKind::Type(ref e, ref target) => {\n             println!(\"{}Type\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n-        hir::ExprIf(ref e, _, ref els) => {\n+        hir::ExprKind::If(ref e, _, ref els) => {\n             println!(\"{}If\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, e, indent + 1);\n@@ -228,86 +230,86 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, els, indent + 1);\n             }\n         },\n-        hir::ExprWhile(ref cond, _, _) => {\n+        hir::ExprKind::While(ref cond, _, _) => {\n             println!(\"{}While\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n         },\n-        hir::ExprLoop(..) => {\n+        hir::ExprKind::Loop(..) => {\n             println!(\"{}Loop\", ind);\n         },\n-        hir::ExprMatch(ref cond, _, ref source) => {\n+        hir::ExprKind::Match(ref cond, _, ref source) => {\n             println!(\"{}Match\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n             println!(\"{}source: {:?}\", ind, source);\n         },\n-        hir::ExprClosure(ref clause, _, _, _, _) => {\n+        hir::ExprKind::Closure(ref clause, _, _, _, _) => {\n             println!(\"{}Closure\", ind);\n             println!(\"{}clause: {:?}\", ind, clause);\n         },\n-        hir::ExprYield(ref sub) => {\n+        hir::ExprKind::Yield(ref sub) => {\n             println!(\"{}Yield\", ind);\n             print_expr(cx, sub, indent + 1);\n         },\n-        hir::ExprBlock(_, _) => {\n+        hir::ExprKind::Block(_, _) => {\n             println!(\"{}Block\", ind);\n         },\n-        hir::ExprAssign(ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(ref lhs, ref rhs) => {\n             println!(\"{}Assign\", ind);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprAssignOp(ref binop, ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(ref binop, ref lhs, ref rhs) => {\n             println!(\"{}AssignOp\", ind);\n             println!(\"{}op: {:?}\", ind, binop.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprField(ref e, ident) => {\n+        hir::ExprKind::Field(ref e, ident) => {\n             println!(\"{}Field\", ind);\n             println!(\"{}field name: {}\", ind, ident.name);\n             println!(\"{}struct expr:\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprIndex(ref arr, ref idx) => {\n+        hir::ExprKind::Index(ref arr, ref idx) => {\n             println!(\"{}Index\", ind);\n             println!(\"{}array expr:\", ind);\n             print_expr(cx, arr, indent + 1);\n             println!(\"{}index expr:\", ind);\n             print_expr(cx, idx, indent + 1);\n         },\n-        hir::ExprPath(hir::QPath::Resolved(ref ty, ref path)) => {\n+        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n             println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n-        hir::ExprPath(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+        hir::ExprKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n-        hir::ExprAddrOf(ref muta, ref e) => {\n+        hir::ExprKind::AddrOf(ref muta, ref e) => {\n             println!(\"{}AddrOf\", ind);\n             println!(\"mutability: {:?}\", muta);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprBreak(_, ref e) => {\n+        hir::ExprKind::Break(_, ref e) => {\n             println!(\"{}Break\", ind);\n             if let Some(ref e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprContinue(_) => println!(\"{}Again\", ind),\n-        hir::ExprRet(ref e) => {\n+        hir::ExprKind::Continue(_) => println!(\"{}Again\", ind),\n+        hir::ExprKind::Ret(ref e) => {\n             println!(\"{}Ret\", ind);\n             if let Some(ref e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprInlineAsm(_, ref input, ref output) => {\n+        hir::ExprKind::InlineAsm(_, ref input, ref output) => {\n             println!(\"{}InlineAsm\", ind);\n             println!(\"{}inputs:\", ind);\n             for e in input {\n@@ -318,7 +320,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprStruct(ref path, ref fields, ref base) => {\n+        hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n             println!(\"{}Struct\", ind);\n             println!(\"{}path: {:?}\", ind, path);\n             for field in fields {\n@@ -330,7 +332,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, base, indent + 1);\n             }\n         },\n-        hir::ExprRepeat(ref val, ref anon_const) => {\n+        hir::ExprKind::Repeat(ref val, ref anon_const) => {\n             println!(\"{}Repeat\", ind);\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);\n@@ -340,20 +342,20 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n     }\n }\n \n-fn print_item(cx: &LateContext, item: &hir::Item) {\n+fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n     let did = cx.tcx.hir.local_def_id(item.id);\n     println!(\"item `{}`\", item.name);\n-    match item.vis {\n-        hir::Visibility::Public => println!(\"public\"),\n-        hir::Visibility::Crate(_) => println!(\"visible crate wide\"),\n-        hir::Visibility::Restricted { ref path, .. } => println!(\n+    match item.vis.node {\n+        hir::VisibilityKind::Public => println!(\"public\"),\n+        hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n+        hir::VisibilityKind::Restricted { ref path, .. } => println!(\n             \"visible in module `{}`\",\n             print::to_string(print::NO_ANN, |s| s.print_path(path, false))\n         ),\n-        hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n+        hir::VisibilityKind::Inherited => println!(\"visibility inherited from outer item\"),\n     }\n     match item.node {\n-        hir::ItemExternCrate(ref _renamed_from) => {\n+        hir::ItemKind::ExternCrate(ref _renamed_from) => {\n             let def_id = cx.tcx.hir.local_def_id(item.id);\n             if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n@@ -367,52 +369,52 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n                 println!(\"weird extern crate without a crate id\");\n             }\n         },\n-        hir::ItemUse(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n-        hir::ItemStatic(..) => println!(\"static item of type {:#?}\", cx.tcx.type_of(did)),\n-        hir::ItemConst(..) => println!(\"const item of type {:#?}\", cx.tcx.type_of(did)),\n-        hir::ItemFn(..) => {\n+        hir::ItemKind::Use(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n+        hir::ItemKind::Static(..) => println!(\"static item of type {:#?}\", cx.tcx.type_of(did)),\n+        hir::ItemKind::Const(..) => println!(\"const item of type {:#?}\", cx.tcx.type_of(did)),\n+        hir::ItemKind::Fn(..) => {\n             let item_ty = cx.tcx.type_of(did);\n             println!(\"function of type {:#?}\", item_ty);\n         },\n-        hir::ItemMod(..) => println!(\"module\"),\n-        hir::ItemForeignMod(ref fm) => println!(\"foreign module with abi: {}\", fm.abi),\n-        hir::ItemGlobalAsm(ref asm) => println!(\"global asm: {:?}\", asm),\n-        hir::ItemTy(..) => {\n+        hir::ItemKind::Mod(..) => println!(\"module\"),\n+        hir::ItemKind::ForeignMod(ref fm) => println!(\"foreign module with abi: {}\", fm.abi),\n+        hir::ItemKind::GlobalAsm(ref asm) => println!(\"global asm: {:?}\", asm),\n+        hir::ItemKind::Ty(..) => {\n             println!(\"type alias for {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemExistential(..) => {\n+        hir::ItemKind::Existential(..) => {\n             println!(\"existential type with real type {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemEnum(..) => {\n+        hir::ItemKind::Enum(..) => {\n             println!(\"enum definition of type {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemStruct(..) => {\n+        hir::ItemKind::Struct(..) => {\n             println!(\"struct definition of type {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemUnion(..) => {\n+        hir::ItemKind::Union(..) => {\n             println!(\"union definition of type {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemTrait(..) => {\n+        hir::ItemKind::Trait(..) => {\n             println!(\"trait decl\");\n             if cx.tcx.trait_is_auto(did) {\n                 println!(\"trait is auto\");\n             } else {\n                 println!(\"trait is not auto\");\n             }\n         },\n-        hir::ItemTraitAlias(..) => {\n+        hir::ItemKind::TraitAlias(..) => {\n             println!(\"trait alias\");\n         }\n-        hir::ItemImpl(_, _, _, _, Some(ref _trait_ref), _, _) => {\n+        hir::ItemKind::Impl(_, _, _, _, Some(ref _trait_ref), _, _) => {\n             println!(\"trait impl\");\n         },\n-        hir::ItemImpl(_, _, _, _, None, _, _) => {\n+        hir::ItemKind::Impl(_, _, _, _, None, _, _) => {\n             println!(\"impl\");\n         },\n     }\n }\n \n-fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n+fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     match pat.node {"}, {"sha": "32aee09917717f48df24064b8028b263d03a8cc6", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n+use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::utils::{match_qpath, paths, span_lint};\n use syntax::symbol::LocalInternedString;\n@@ -62,7 +64,7 @@ impl LintPass for Clippy {\n }\n \n impl EarlyLintPass for Clippy {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &AstCrate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &AstCrate) {\n         if let Some(utils) = krate\n             .module\n             .items\n@@ -117,15 +119,17 @@ impl LintPass for LintWithoutLintPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemStatic(ref ty, MutImmutable, body_id) = item.node {\n+        if let hir::ItemKind::Static(ref ty, MutImmutable, body_id) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n-            } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name == \"ARRAY\" {\n-                let mut collector = LintCollector {\n-                    output: &mut self.registered_lints,\n-                    cx,\n-                };\n-                collector.visit_expr(&cx.tcx.hir.body(body_id).value);\n+            } else if is_lint_array_type(ty) && item.name == \"ARRAY\" {\n+                if let VisibilityKind::Inherited = item.vis.node {\n+                    let mut collector = LintCollector {\n+                        output: &mut self.registered_lints,\n+                        cx,\n+                    };\n+                    collector.visit_expr(&cx.tcx.hir.body(body_id).value);\n+                }\n             }\n         }\n     }\n@@ -160,15 +164,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n \n \n fn is_lint_ref_type(ty: &Ty) -> bool {\n-    if let TyRptr(\n+    if let TyKind::Rptr(\n         _,\n         MutTy {\n             ty: ref inner,\n             mutbl: MutImmutable,\n         },\n     ) = ty.node\n     {\n-        if let TyPath(ref path) = inner.node {\n+        if let TyKind::Path(ref path) = inner.node {\n             return match_qpath(path, &paths::LINT);\n         }\n     }\n@@ -177,7 +181,7 @@ fn is_lint_ref_type(ty: &Ty) -> bool {\n \n \n fn is_lint_array_type(ty: &Ty) -> bool {\n-    if let TyPath(ref path) = ty.node {\n+    if let TyKind::Path(ref path) = ty.node {\n         match_qpath(path, &paths::LINT_ARRAY)\n     } else {\n         false"}, {"sha": "0b2103ca7eaa505ab71a1ebe88189fe6252b4c95", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 44, "deletions": 71, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,6 @@\n use crate::reexport::*;\n+use matches::matches;\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n@@ -17,7 +19,7 @@ use std::str::FromStr;\n use std::rc::Rc;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n-use syntax::codemap::{CompilerDesugaringKind, ExpnFormat, ExpnInfo, Span, DUMMY_SP};\n+use syntax::codemap::{CompilerDesugaringKind, ExpnFormat, Span, DUMMY_SP};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n@@ -46,7 +48,7 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.ctxt() != lhs.ctxt()\n }\n \n-pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n+pub fn in_constant(cx: &LateContext<'_, '_>, id: NodeId) -> bool {\n     let parent_id = cx.tcx.hir.get_parent(id);\n     match cx.tcx.hir.body_owner_kind(parent_id) {\n         hir::BodyOwnerKind::Fn => false,\n@@ -75,36 +77,6 @@ pub fn is_range_expression(span: Span) -> bool {\n     })\n }\n \n-/// Returns true if the macro that expanded the crate was outside of the\n-/// current crate or was a\n-/// compiler plugin.\n-pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n-    /// Invokes `in_macro` with the expansion info of the given span slightly\n-    /// heavy, try to use\n-    /// this after other checks have already happened.\n-    fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, info: &ExpnInfo) -> bool {\n-        // no ExpnInfo = no macro\n-        if let ExpnFormat::MacroAttribute(..) = info.format {\n-            // these are all plugins\n-            return true;\n-        }\n-        // no span for the callee = external macro\n-        info.def_site.map_or(true, |span| {\n-            // no snippet = external macro or compiler-builtin expansion\n-            cx.sess()\n-                .codemap()\n-                .span_to_snippet(span)\n-                .ok()\n-                .map_or(true, |code| !code.starts_with(\"macro_rules\"))\n-        })\n-    }\n-\n-    span.ctxt()\n-        .outer()\n-        .expn_info()\n-        .map_or(false, |info| in_macro_ext(cx, &info))\n-}\n-\n /// Check if a `DefId`'s path matches the given absolute type path usage.\n ///\n /// # Examples\n@@ -113,7 +85,7 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n+pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) -> bool {\n     use syntax::symbol;\n \n     struct AbsolutePathBuffer {\n@@ -143,15 +115,15 @@ pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n }\n \n /// Check if type is struct, enum or union type with given def path.\n-pub fn match_type(cx: &LateContext, ty: Ty, path: &[&str]) -> bool {\n+pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n     }\n }\n \n /// Check if the method call given in `expr` belongs to given type.\n-pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n+pub fn match_impl_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.impl_of_method(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n@@ -162,7 +134,7 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n }\n \n /// Check if the method call given in `expr` belongs to given trait.\n-pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n+pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.trait_of_item(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n@@ -174,7 +146,7 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n \n /// Check if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr, var: Name) -> bool {\n-    if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.node {\n         if path.segments.len() == 1 && path.segments[0].ident.name == var {\n             return true;\n         }\n@@ -210,7 +182,7 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n     match *path {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n-            TyPath(ref inner_path) => {\n+            TyKind::Path(ref inner_path) => {\n                 !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n                     && segment.ident.name == segments[segments.len() - 1]\n             },\n@@ -242,7 +214,7 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n }\n \n /// Get the definition associated to a path.\n-pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n+pub fn path_to_def(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Def> {\n     let crates = cx.tcx.crates();\n     let krate = crates\n         .iter()\n@@ -278,7 +250,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n }\n \n /// Convenience function to get the `DefId` of a trait by path.\n-pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n+pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId> {\n     let def = match path_to_def(cx, path) {\n         Some(def) => def,\n         None => return None,\n@@ -306,7 +278,7 @@ pub fn implements_trait<'a, 'tcx>(\n }\n \n /// Check whether this type implements Drop.\n-pub fn has_drop(cx: &LateContext, expr: &Expr) -> bool {\n+pub fn has_drop(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     let struct_ty = cx.tables.expr_ty(expr);\n     match struct_ty.ty_adt_def() {\n         Some(def) => def.has_dtor(cx.tcx),\n@@ -315,7 +287,7 @@ pub fn has_drop(cx: &LateContext, expr: &Expr) -> bool {\n }\n \n /// Resolve the definition of a node from its `HirId`.\n-pub fn resolve_node(cx: &LateContext, qpath: &QPath, id: HirId) -> def::Def {\n+pub fn resolve_node(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> def::Def {\n     cx.tables.qpath_def(qpath, id)\n }\n \n@@ -330,7 +302,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprMethodCall(ref path, _, ref args) = current.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = current.node {\n             if path.ident.name == *method_name {\n                 if args.iter().any(|e| in_macro(e.span)) {\n                     return None;\n@@ -350,7 +322,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n \n \n /// Get the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n+pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.hir.get_parent(expr.id);\n     match cx.tcx.hir.find(parent_id) {\n         Some(Node::NodeItem(&Item { ref name, .. })) => Some(*name),\n@@ -435,7 +407,7 @@ pub fn last_line_of_span<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Span {\n     Span::new(*line_start, span.hi(), span.ctxt())\n }\n \n-/// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n+/// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n     cx: &T,\n@@ -445,7 +417,7 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n ) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n-    if let ExprBlock(_, _) = expr.node {\n+    if let ExprKind::Block(_, _) = expr.node {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n         Cow::Owned(format!(\"{{ {} }}\", code))\n@@ -456,13 +428,13 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n \n /// Trim indentation from a multiline string with possibility of ignoring the\n /// first line.\n-pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n+pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool) -> Cow<'_, str> {\n     let s_space = trim_multiline_inner(s, ignore_first, ' ');\n     let s_tab = trim_multiline_inner(s_space, ignore_first, '\\t');\n     trim_multiline_inner(s_tab, ignore_first, ' ')\n }\n \n-fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n+fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_, str> {\n     let x = s.lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n@@ -500,7 +472,7 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n }\n \n /// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n-pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n+pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.hir;\n     let node_id: NodeId = e.id;\n     let parent_id: NodeId = map.get_parent_node(node_id);\n@@ -524,13 +496,13 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n         match node {\n             Node::NodeBlock(block) => Some(block),\n             Node::NodeItem(&Item {\n-                node: ItemFn(_, _, _, eid),\n+                node: ItemKind::Fn(_, _, _, eid),\n                 ..\n             }) | Node::NodeImplItem(&ImplItem {\n                 node: ImplItemKind::Method(_, eid),\n                 ..\n             }) => match cx.tcx.hir.body(eid).value.node {\n-                ExprBlock(ref block, _) => Some(block),\n+                ExprKind::Block(ref block, _) => Some(block),\n                 _ => None,\n             },\n             _ => None,\n@@ -640,7 +612,7 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n /// appear once per\n /// replacement. In human-readable format though, it only appears once before\n /// the whole suggestion.\n-pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder, help_msg: String, sugg: I)\n+pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder<'_>, help_msg: String, sugg: I)\n where\n     I: IntoIterator<Item = (Span, String)>,\n {\n@@ -667,13 +639,13 @@ where\n /// Return the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n     match ty.node {\n-        TyPtr(ref mut_ty) | TyRptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n+        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n         _ => ty,\n     }\n }\n \n /// Return the base type for references and raw pointers.\n-pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n+pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n     match ty.sty {\n         ty::TyRef(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n@@ -682,8 +654,8 @@ pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n \n /// Return the base type for references and raw pointers, and count reference\n /// depth.\n-pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n-    fn inner(ty: Ty, depth: usize) -> (Ty, usize) {\n+pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n         match ty.sty {\n             ty::TyRef(_, ty, _) => inner(ty, depth + 1),\n             _ => (ty, depth),\n@@ -695,15 +667,15 @@ pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n /// Check whether the given expression is a constant literal of the given value.\n pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     // FIXME: use constant folding\n-    if let ExprLit(ref spanned) = expr.node {\n+    if let ExprKind::Lit(ref spanned) = expr.node {\n         if let LitKind::Int(v, _) = spanned.node {\n             return v == value;\n         }\n     }\n     false\n }\n \n-pub fn is_adjusted(cx: &LateContext, e: &Expr) -> bool {\n+pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     cx.tables.adjustments().get(e.hir_id).is_some()\n }\n \n@@ -896,15 +868,15 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n /// Return whether a pattern is refutable.\n-pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n-    fn is_enum_variant(cx: &LateContext, qpath: &QPath, id: HirId) -> bool {\n+pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n+    fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> bool {\n         matches!(\n             cx.tables.qpath_def(qpath, id),\n             def::Def::Variant(..) | def::Def::VariantCtor(..)\n         )\n     }\n \n-    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext<'_, '_>, mut i: I) -> bool {\n         i.any(|pat| is_refutable(cx, pat))\n     }\n \n@@ -945,7 +917,7 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n /// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n /// themselves.\n pub fn remove_blocks(expr: &Expr) -> &Expr {\n-    if let ExprBlock(ref block, _) = expr.node {\n+    if let ExprKind::Block(ref block, _) = expr.node {\n         if block.stmts.is_empty() {\n             if let Some(ref expr) = block.expr {\n                 remove_blocks(expr)\n@@ -982,6 +954,7 @@ pub fn opt_def_id(def: Def) -> Option<DefId> {\n         Def::AssociatedConst(id) |\n         Def::Macro(id, ..) |\n         Def::Existential(id) |\n+        Def::AssociatedExistential(id) |\n         Def::GlobalAsm(id) => Some(id),\n \n         Def::Upvar(..) | Def::Local(_) | Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n@@ -998,7 +971,7 @@ pub fn is_self(slf: &Arg) -> bool {\n \n pub fn is_self_ty(slf: &hir::Ty) -> bool {\n     if_chain! {\n-        if let TyPath(ref qp) = slf.node;\n+        if let TyKind::Path(ref qp) = slf.node;\n         if let QPath::Resolved(None, ref path) = *qp;\n         if let Def::SelfTy(..) = path.def;\n         then {\n@@ -1020,7 +993,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n             if let PatKind::Binding(_, defid, _, None) = pat[0].node;\n-            if let ExprPath(QPath::Resolved(None, ref path)) = arm.body.node;\n+            if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.node;\n             if let Def::Local(lid) = path.def;\n             if lid == defid;\n             then {\n@@ -1038,7 +1011,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n         }\n     }\n \n-    if let ExprMatch(_, ref arms, ref source) = expr.node {\n+    if let ExprKind::Match(_, ref arms, ref source) = expr.node {\n         // desugared from a `?` operator\n         if let MatchSource::TryDesugar = *source {\n             return Some(expr);\n@@ -1062,7 +1035,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n /// Returns true if the lint is allowed in the current context\n ///\n /// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext, lint: &'static Lint, id: NodeId) -> bool {\n+pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: NodeId) -> bool {\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n@@ -1082,24 +1055,24 @@ pub fn get_arg_ident(pat: &Pat) -> Option<ast::Ident> {\n     }\n }\n \n-pub fn int_bits(tcx: TyCtxt, ity: ast::IntTy) -> u64 {\n+pub fn int_bits(tcx: TyCtxt<'_, '_, '_>, ity: ast::IntTy) -> u64 {\n     layout::Integer::from_attr(tcx, attr::IntType::SignedInt(ity)).size().bits()\n }\n \n /// Turn a constant int byte representation into an i128\n-pub fn sext(tcx: TyCtxt, u: u128, ity: ast::IntTy) -> i128 {\n+pub fn sext(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::IntTy) -> i128 {\n     let amt = 128 - int_bits(tcx, ity);\n     ((u as i128) << amt) >> amt\n }\n \n /// clip unused bytes\n-pub fn unsext(tcx: TyCtxt, u: i128, ity: ast::IntTy) -> u128 {\n+pub fn unsext(tcx: TyCtxt<'_, '_, '_>, u: i128, ity: ast::IntTy) -> u128 {\n     let amt = 128 - int_bits(tcx, ity);\n     ((u as u128) << amt) >> amt\n }\n \n /// clip unused bytes\n-pub fn clip(tcx: TyCtxt, u: u128, ity: ast::UintTy) -> u128 {\n+pub fn clip(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::UintTy) -> u128 {\n     let bits = layout::Integer::from_attr(tcx, attr::IntType::UnsignedInt(ity)).size().bits();\n     let amt = 128 - bits;\n     (u << amt) >> amt\n@@ -1138,7 +1111,7 @@ pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n     without\n }\n \n-pub fn any_parent_is_automatically_derived(tcx: TyCtxt, node: NodeId) -> bool {\n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: NodeId) -> bool {\n     let map = &tcx.hir;\n     let mut prev_enclosing_node = None;\n     let mut enclosing_node = node;"}, {"sha": "4d89f8ddffbbfbe424edea905fdfbeee756b089c", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,18 +2,18 @@\n //! about.\n \n pub const ANY_TRAIT: [&str; 3] = [\"std\", \"any\", \"Any\"];\n-pub const ARC: [&str; 3] = [\"alloc\", \"arc\", \"Arc\"];\n+pub const ARC: [&str; 3] = [\"alloc\", \"sync\", \"Arc\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n pub const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_fmt\"];\n-pub const BINARY_HEAP: [&str; 3] = [\"alloc\", \"binary_heap\", \"BinaryHeap\"];\n+pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BOX: [&str; 3] = [\"std\", \"boxed\", \"Box\"];\n pub const BOX_NEW: [&str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n-pub const BTREEMAP: [&str; 4] = [\"alloc\", \"btree\", \"map\", \"BTreeMap\"];\n-pub const BTREEMAP_ENTRY: [&str; 4] = [\"alloc\", \"btree\", \"map\", \"Entry\"];\n-pub const BTREESET: [&str; 4] = [\"alloc\", \"btree\", \"set\", \"BTreeSet\"];\n+pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const BTREEMAP_ENTRY: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n pub const CLONE: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n@@ -47,7 +47,7 @@ pub const IO_PRINT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"_print\"];\n pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const ITERATOR: [&str; 4] = [\"core\", \"iter\", \"iterator\", \"Iterator\"];\n-pub const LINKED_LIST: [&str; 3] = [\"alloc\", \"linked_list\", \"LinkedList\"];\n+pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n pub const LINT: [&str; 2] = [\"lint\", \"Lint\"];\n pub const LINT_ARRAY: [&str; 2] = [\"lint\", \"LintArray\"];\n pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n@@ -101,7 +101,7 @@ pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const TRY_INTO_RESULT: [&str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n pub const UNINIT: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"uninit\"];\n pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n-pub const VEC_DEQUE: [&str; 3] = [\"alloc\", \"vec_deque\", \"VecDeque\"];\n+pub const VEC_DEQUE: [&str; 4] = [\"alloc\", \"collections\", \"vec_deque\", \"VecDeque\"];\n pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n-pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"arc\", \"Weak\"];\n+pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];"}, {"sha": "1a20eb0101538b17533cd0916a2445b4fb25bdf0", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -7,7 +7,7 @@ use syntax::codemap::Span;\n use crate::utils::{get_pat_name, match_var, snippet};\n \n pub fn get_spans(\n-    cx: &LateContext,\n+    cx: &LateContext<'_, '_>,\n     opt_body_id: Option<BodyId>,\n     idx: usize,\n     replacements: &'static [(&'static str, &'static str)],\n@@ -54,7 +54,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref seg, _, ref args) = expr.node {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n                 if seg.ident.name == \"capacity\" {\n                     self.abort = true;"}, {"sha": "91fd5ec874afda3ffabb3bd402d2ba87f8793aab", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -3,6 +3,7 @@\n // currently ignores lifetimes and generics\n #![allow(use_self)]\n \n+use matches::matches;\n use rustc::hir;\n use rustc::lint::{EarlyContext, LateContext, LintContext};\n use rustc_errors;\n@@ -31,8 +32,8 @@ pub enum Sugg<'a> {\n /// Literal constant `1`, for convenience.\n pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n \n-impl<'a> Display for Sugg<'a> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+impl Display for Sugg<'_> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         match *self {\n             Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => s.fmt(f),\n         }\n@@ -42,51 +43,51 @@ impl<'a> Display for Sugg<'a> {\n #[allow(wrong_self_convention)] // ok, because of the function `as_ty` method\n impl<'a> Sugg<'a> {\n     /// Prepare a suggestion from an expression.\n-    pub fn hir_opt(cx: &LateContext, expr: &hir::Expr) -> Option<Self> {\n+    pub fn hir_opt(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n             match expr.node {\n-                hir::ExprAddrOf(..) |\n-                hir::ExprBox(..) |\n-                hir::ExprClosure(.., _) |\n-                hir::ExprIf(..) |\n-                hir::ExprUnary(..) |\n-                hir::ExprMatch(..) => Sugg::MaybeParen(snippet),\n-                hir::ExprContinue(..) |\n-                hir::ExprYield(..) |\n-                hir::ExprArray(..) |\n-                hir::ExprBlock(..) |\n-                hir::ExprBreak(..) |\n-                hir::ExprCall(..) |\n-                hir::ExprField(..) |\n-                hir::ExprIndex(..) |\n-                hir::ExprInlineAsm(..) |\n-                hir::ExprLit(..) |\n-                hir::ExprLoop(..) |\n-                hir::ExprMethodCall(..) |\n-                hir::ExprPath(..) |\n-                hir::ExprRepeat(..) |\n-                hir::ExprRet(..) |\n-                hir::ExprStruct(..) |\n-                hir::ExprTup(..) |\n-                hir::ExprWhile(..) => Sugg::NonParen(snippet),\n-                hir::ExprAssign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-                hir::ExprAssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n-                hir::ExprBinary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n-                hir::ExprCast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-                hir::ExprType(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+                hir::ExprKind::AddrOf(..) |\n+                hir::ExprKind::Box(..) |\n+                hir::ExprKind::Closure(.., _) |\n+                hir::ExprKind::If(..) |\n+                hir::ExprKind::Unary(..) |\n+                hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+                hir::ExprKind::Continue(..) |\n+                hir::ExprKind::Yield(..) |\n+                hir::ExprKind::Array(..) |\n+                hir::ExprKind::Block(..) |\n+                hir::ExprKind::Break(..) |\n+                hir::ExprKind::Call(..) |\n+                hir::ExprKind::Field(..) |\n+                hir::ExprKind::Index(..) |\n+                hir::ExprKind::InlineAsm(..) |\n+                hir::ExprKind::Lit(..) |\n+                hir::ExprKind::Loop(..) |\n+                hir::ExprKind::MethodCall(..) |\n+                hir::ExprKind::Path(..) |\n+                hir::ExprKind::Repeat(..) |\n+                hir::ExprKind::Ret(..) |\n+                hir::ExprKind::Struct(..) |\n+                hir::ExprKind::Tup(..) |\n+                hir::ExprKind::While(..) => Sugg::NonParen(snippet),\n+                hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+                hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n+                hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n+                hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+                hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n             }\n         })\n     }\n \n     /// Convenience function around `hir_opt` for suggestions with a default\n     /// text.\n-    pub fn hir(cx: &LateContext, expr: &hir::Expr, default: &'a str) -> Self {\n+    pub fn hir(cx: &LateContext<'_, '_>, expr: &hir::Expr, default: &'a str) -> Self {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n     /// Prepare a suggestion from an expression.\n-    pub fn ast(cx: &EarlyContext, expr: &ast::Expr, default: &'a str) -> Self {\n+    pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use syntax::ast::RangeLimits;\n \n         let snippet = snippet(cx, expr.span, default);\n@@ -240,7 +241,7 @@ impl<T> ParenHelper<T> {\n }\n \n impl<T: Display> Display for ParenHelper<T> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         if self.paren {\n             write!(f, \"({})\", self.wrapped)\n         } else {\n@@ -254,7 +255,7 @@ impl<T: Display> Display for ParenHelper<T> {\n /// For convenience, the operator is taken as a string because all unary\n /// operators have the same\n /// precedence.\n-pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n+pub fn make_unop(op: &str, expr: Sugg<'_>) -> Sugg<'static> {\n     Sugg::MaybeParen(format!(\"{}{}\", op, expr.maybe_par()).into())\n }\n \n@@ -263,7 +264,7 @@ pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n /// Precedence of shift operator relative to other arithmetic operation is\n /// often confusing so\n /// parenthesis will always be added for a mix of these.\n-pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n     /// Whether the operator is a shift operator `<<` or `>>`.\n     fn is_shift(op: &AssocOp) -> bool {\n         matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n@@ -334,7 +335,7 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n }\n \n /// Convinience wrapper arround `make_assoc` and `AssocOp::from_ast_binop`.\n-pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n     make_assoc(AssocOp::from_ast_binop(op), lhs, rhs)\n }\n \n@@ -382,21 +383,29 @@ fn associativity(op: &AssocOp) -> Associativity {\n \n /// Convert a `hir::BinOp` to the corresponding assigning binary operator.\n fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n-    use rustc::hir::BinOp_::*;\n     use syntax::parse::token::BinOpToken::*;\n \n     AssocOp::AssignOp(match op.node {\n-        BiAdd => Plus,\n-        BiBitAnd => And,\n-        BiBitOr => Or,\n-        BiBitXor => Caret,\n-        BiDiv => Slash,\n-        BiMul => Star,\n-        BiRem => Percent,\n-        BiShl => Shl,\n-        BiShr => Shr,\n-        BiSub => Minus,\n-        BiAnd | BiEq | BiGe | BiGt | BiLe | BiLt | BiNe | BiOr => panic!(\"This operator does not exist\"),\n+        hir::BinOpKind::Add => Plus,\n+        hir::BinOpKind::BitAnd => And,\n+        hir::BinOpKind::BitOr => Or,\n+        hir::BinOpKind::BitXor => Caret,\n+        hir::BinOpKind::Div => Slash,\n+        hir::BinOpKind::Mul => Star,\n+        hir::BinOpKind::Rem => Percent,\n+        hir::BinOpKind::Shl => Shl,\n+        hir::BinOpKind::Shr => Shr,\n+        hir::BinOpKind::Sub => Minus,\n+\n+        | hir::BinOpKind::And\n+        | hir::BinOpKind::Eq\n+        | hir::BinOpKind::Ge\n+        | hir::BinOpKind::Gt\n+        | hir::BinOpKind::Le\n+        | hir::BinOpKind::Lt\n+        | hir::BinOpKind::Ne\n+        | hir::BinOpKind::Or\n+        => panic!(\"This operator does not exist\"),\n     })\n }\n "}, {"sha": "43e492bfb4e40f70b6fe7a4d1f796deeb6538b70", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -44,7 +44,7 @@ struct MutVarsDelegate {\n }\n \n impl<'tcx> MutVarsDelegate {\n-    fn update(&mut self, cat: &'tcx Categorization) {\n+    fn update(&mut self, cat: &'tcx Categorization<'_>) {\n         match *cat {\n             Categorization::Local(id) => {\n                 self.used_mutably.insert(id);\n@@ -68,7 +68,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt.cat)\n         }"}, {"sha": "cea3307a8273fcc0280da7da664879b64ee3cf88", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n use crate::utils::{higher, is_copy, snippet, span_lint_and_sugg};\n@@ -37,7 +39,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_chain! {\n             if let ty::TyRef(_, ty, _) = cx.tables.expr_ty_adjusted(expr).sty;\n             if let ty::TySlice(..) = ty.sty;\n-            if let ExprAddrOf(_, ref addressee) = expr.node;\n+            if let ExprKind::AddrOf(_, ref addressee) = expr.node;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n                 check_vec_macro(cx, &vec_args, expr.span);\n@@ -92,7 +94,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n }\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n-fn vec_type(ty: Ty) -> Ty {\n+fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         substs.type_at(0)\n     } else {"}, {"sha": "a019e23a3014f34821d4ac6df525515edd99cae6", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 131, "deletions": 303, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,13 +1,9 @@\n-use rustc::hir::map::Node::{NodeImplItem, NodeItem};\n-use rustc::hir::*;\n use rustc::lint::*;\n-use std::ops::Deref;\n-use syntax::ast::LitKind;\n-use syntax::ptr;\n-use syntax::symbol::LocalInternedString;\n-use syntax_pos::Span;\n-use crate::utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint, span_lint_and_sugg};\n-use crate::utils::{opt_def_id, paths, last_path_segment};\n+use rustc::{declare_lint, lint_array};\n+use syntax::ast::*;\n+use syntax::tokenstream::{ThinTokenStream, TokenStream};\n+use syntax::parse::{token, parser};\n+use crate::utils::{span_lint, span_lint_and_sugg};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -171,317 +167,149 @@ impl LintPass for Pass {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        match expr.node {\n-            // print!()\n-            ExprCall(ref fun, ref args) => {\n-                if_chain! {\n-                    if let ExprPath(ref qpath) = fun.node;\n-                    if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n-                    then {\n-                        check_print_variants(cx, expr, fun_id, args);\n-                    }\n-                }\n-            },\n-            // write!()\n-            ExprMethodCall(ref fun, _, ref args) => {\n-                if fun.ident.name == \"write_fmt\" {\n-                    check_write_variants(cx, expr, args);\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn check_write_variants<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, write_args: &ptr::P<[Expr]>) {\n-    // `writeln!` uses `write!`.\n-    if let Some(span) = is_expn_of(expr.span, \"write\") {\n-        let (span, name) = match is_expn_of(span, \"writeln\") {\n-            Some(span) => (span, \"writeln\"),\n-            None => (span, \"write\"),\n-        };\n-\n-        if_chain! {\n-            // ensure we're calling Arguments::new_v1 or Arguments::new_v1_formatted\n-            if write_args.len() == 2;\n-            if let ExprCall(ref args_fun, ref args_args) = write_args[1].node;\n-            if let ExprPath(ref qpath) = args_fun.node;\n-            if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n-            if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1) ||\n-               match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n-            then {\n-                // Check for literals in the write!/writeln! args\n-                check_fmt_args_for_literal(cx, args_args, |span| {\n-                    span_lint(cx, WRITE_LITERAL, span, \"writing a literal with an empty format string\");\n-                });\n-\n-                if_chain! {\n-                    if args_args.len() >= 2;\n-                    if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n-                    if let ExprMatch(ref args, _, _) = match_expr.node;\n-                    if let ExprTup(ref args) = args.node;\n-                    if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n-                    then {\n-                        match name {\n-                            \"write\" => if has_newline_end(args, fmtstr, fmtlen) {\n-                                span_lint(cx, WRITE_WITH_NEWLINE, span,\n-                                        \"using `write!()` with a format string that ends in a \\\n-                                        newline, consider using `writeln!()` instead\");\n-                            },\n-                            \"writeln\" => if let Some(final_span) = has_empty_arg(cx, span, fmtstr, fmtlen) {\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    WRITE_WITH_NEWLINE,\n-                                    final_span,\n-                                    \"using `writeln!(v, \\\"\\\")`\",\n-                                    \"replace it with\",\n-                                    \"writeln!(v)\".to_string(),\n-                                );\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n+impl EarlyLintPass for Pass {\n+    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &Mac) {\n+        if mac.node.path == \"println\" {\n+            span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+                if fmtstr == \"\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        PRINTLN_EMPTY_STRING,\n+                        mac.span,\n+                        \"using `println!(\\\"\\\")`\",\n+                        \"replace it with\",\n+                        \"println!()\".to_string(),\n+                    );\n                 }\n             }\n-        }\n-    }\n-}\n-\n-fn check_print_variants<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n-    fun_id: def_id::DefId,\n-    args: &ptr::P<[Expr]>,\n-) {\n-    // Search for `std::io::_print(..)` which is unique in a\n-    // `print!` expansion.\n-    if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n-        if let Some(span) = is_expn_of(expr.span, \"print\") {\n-            // `println!` uses `print!`.\n-            let (span, name) = match is_expn_of(span, \"println\") {\n-                Some(span) => (span, \"println\"),\n-                None => (span, \"print\"),\n-            };\n-\n-            span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n-            if_chain! {\n-                // ensure we're calling Arguments::new_v1\n-                if args.len() == 1;\n-                if let ExprCall(ref args_fun, ref args_args) = args[0].node;\n-                then {\n-                    // Check for literals in the print!/println! args\n-                    check_fmt_args_for_literal(cx, args_args, |span| {\n-                        span_lint(cx, PRINT_LITERAL, span, \"printing a literal with an empty format string\");\n-                    });\n-\n-                    if_chain! {\n-                        if let ExprPath(ref qpath) = args_fun.node;\n-                        if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n-                        if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                        if args_args.len() == 2;\n-                        if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n-                        if let ExprMatch(ref args, _, _) = match_expr.node;\n-                        if let ExprTup(ref args) = args.node;\n-                        if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n-                        then {\n-                            match name {\n-                                \"print\" =>\n-                                    if has_newline_end(args, fmtstr, fmtlen) {\n-                                        span_lint(cx, PRINT_WITH_NEWLINE, span,\n-                                                \"using `print!()` with a format string that ends in a \\\n-                                                newline, consider using `println!()` instead\");\n-                                    },\n-                                \"println\" =>\n-                                    if let Some(final_span) = has_empty_arg(cx, span, fmtstr, fmtlen) {\n-                                        span_lint_and_sugg(\n-                                            cx,\n-                                            PRINT_WITH_NEWLINE,\n-                                            final_span,\n-                                            \"using `println!(\\\"\\\")`\",\n-                                            \"replace it with\",\n-                                            \"println!()\".to_string(),\n-                                        );\n-                                    },\n-                                _ => (),\n-                            }\n-                        }\n-                    }\n+        } else if mac.node.path == \"print\" {\n+            span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+                if fmtstr.ends_with(\"\\\\n\") {\n+                    span_lint(cx, PRINT_WITH_NEWLINE, mac.span,\n+                            \"using `print!()` with a format string that ends in a \\\n+                            newline, consider using `println!()` instead\");\n                 }\n             }\n-        }\n-    }\n-    // Search for something like\n-    // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-    else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-        if let ExprPath(ref qpath) = args[1].node {\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n-                if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr)\n-                    && is_expn_of(expr.span, \"panic\").is_none()\n-                {\n-                    span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+        } else if mac.node.path == \"write\" {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+                if fmtstr.ends_with(\"\\\\n\") {\n+                    span_lint(cx, WRITE_WITH_NEWLINE, mac.span,\n+                            \"using `write!()` with a format string that ends in a \\\n+                            newline, consider using `writeln!()` instead\");\n                 }\n             }\n-        }\n-    }\n-}\n-\n-// Check for literals in write!/writeln! and print!/println! args\n-// ensuring the format string for the literal is `DISPLAY_FMT_METHOD`\n-// e.g., `writeln!(buf, \"... {} ...\", \"foo\")`\n-//                                    ^ literal in `writeln!`\n-// e.g., `println!(\"... {} ...\", \"foo\")`\n-//                                ^ literal in `println!`\n-fn check_fmt_args_for_literal<'a, 'tcx, F>(cx: &LateContext<'a, 'tcx>, args: &HirVec<Expr>, lint_fn: F)\n-where\n-    F: Fn(Span),\n-{\n-    if_chain! {\n-        if args.len() >= 2;\n-\n-        // the match statement\n-        if let ExprAddrOf(_, ref match_expr) = args[1].node;\n-        if let ExprMatch(ref matchee, ref arms, _) = match_expr.node;\n-        if let ExprTup(ref tup) = matchee.node;\n-        if arms.len() == 1;\n-        if let ExprArray(ref arm_body_exprs) = arms[0].body.node;\n-        then {\n-            // it doesn't matter how many args there are in the `write!`/`writeln!`,\n-            // if there's one literal, we should warn the user\n-            for (idx, tup_arg) in tup.iter().enumerate() {\n-                if_chain! {\n-                    // first, make sure we're dealing with a literal (i.e., an ExprLit)\n-                    if let ExprAddrOf(_, ref tup_val) = tup_arg.node;\n-                    if let ExprLit(_) = tup_val.node;\n-\n-                    // next, check the corresponding match arm body to ensure\n-                    // this is DISPLAY_FMT_METHOD\n-                    if let ExprCall(_, ref body_args) = arm_body_exprs[idx].node;\n-                    if body_args.len() == 2;\n-                    if let ExprPath(ref body_qpath) = body_args[1].node;\n-                    if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n-                    if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n-                    then {\n-                        if args.len() == 2 {\n-                            lint_fn(tup_val.span);\n-                        }\n-\n-                        // ensure the format str has no options (e.g., width, precision, alignment, etc.)\n-                        // and is just \"{}\"\n-                        if_chain! {\n-                            if args.len() == 3;\n-                            if let ExprAddrOf(_, ref format_expr) = args[2].node;\n-                            if let ExprArray(ref format_exprs) = format_expr.node;\n-                            if format_exprs.len() >= 1;\n-                            if let ExprStruct(_, ref fields, _) = format_exprs[idx].node;\n-                            if let Some(format_field) = fields.iter().find(|f| f.ident.name == \"format\");\n-                            if check_unformatted(&format_field.expr);\n-                            then {\n-                                lint_fn(tup_val.span);\n-                            }\n-                        }\n-                    }\n+        } else if mac.node.path == \"writeln\" {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+                if fmtstr == \"\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        WRITELN_EMPTY_STRING,\n+                        mac.span,\n+                        \"using `writeln!(v, \\\"\\\")`\",\n+                        \"replace it with\",\n+                        \"writeln!(v)\".to_string(),\n+                    );\n                 }\n             }\n         }\n     }\n }\n \n-/// Check for fmtstr = \"... \\n\"\n-fn has_newline_end(args: &HirVec<Expr>, fmtstr: LocalInternedString, fmtlen: usize) -> bool {\n-    if_chain! {\n-        // check the final format string part\n-        if let Some('\\n') = fmtstr.chars().last();\n-\n-        // \"foo{}bar\" is made into two strings + one argument,\n-        // if the format string starts with `{}` (eg. \"{}foo\"),\n-        // the string array is prepended an empty string \"\".\n-        // We only want to check the last string after any `{}`:\n-        if args.len() < fmtlen;\n-        then {\n-            return true\n-        }\n+fn check_tts(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> Option<String> {\n+    let tts = TokenStream::from(tts.clone());\n+    let mut parser = parser::Parser::new(\n+        &cx.sess.parse_sess,\n+        tts,\n+        None,\n+        false,\n+        false,\n+    );\n+    if is_write {\n+        // skip the initial write target\n+        parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        // might be `writeln!(foo)`\n+        parser.expect(&token::Comma).map_err(|mut err| err.cancel()).ok()?;\n     }\n-    false\n-}\n-\n-/// Check for writeln!(v, \"\") / println!(\"\")\n-fn has_empty_arg<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, fmtstr: LocalInternedString, fmtlen: usize) -> Option<Span> {\n-    if_chain! {\n-        // check that the string is empty\n-        if fmtlen == 1;\n-        if fmtstr.deref() == \"\\n\";\n-\n-        // check the presence of that string\n-        if let Ok(snippet) = cx.sess().codemap().span_to_snippet(span);\n-        if snippet.contains(\"\\\"\\\"\");\n-        then {\n-            if snippet.ends_with(';') {\n-                return Some(cx.sess().codemap().span_until_char(span, ';'));\n-            }\n-            return Some(span)\n+    let fmtstr = parser.parse_str().map_err(|mut err| err.cancel()).ok()?.0.to_string();\n+    use fmt_macros::*;\n+    let tmp = fmtstr.clone();\n+    let mut args = vec![];\n+    let mut fmt_parser = Parser::new(&tmp, None);\n+    while let Some(piece) = fmt_parser.next() {\n+        if !fmt_parser.errors.is_empty() {\n+            return None;\n         }\n-    }\n-    None\n-}\n-\n-/// Returns the slice of format string parts in an `Arguments::new_v1` call.\n-fn get_argument_fmtstr_parts(expr: &Expr) -> Option<(LocalInternedString, usize)> {\n-    if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n-        if let ExprArray(ref exprs) = expr.node;\n-        if let Some(expr) = exprs.last();\n-        if let ExprLit(ref lit) = expr.node;\n-        if let LitKind::Str(ref lit, _) = lit.node;\n-        then {\n-            return Some((lit.as_str(), exprs.len()));\n-        }\n-    }\n-    None\n-}\n-\n-fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n-    let map = &cx.tcx.hir;\n-\n-    // `fmt` method\n-    if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) {\n-        // `Debug` impl\n-        if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n-            if let ItemImpl(_, _, _, _, Some(ref tr), _, _) = item.node {\n-                return match_path(&tr.path, &[\"Debug\"]);\n+        if let Piece::NextArgument(arg) = piece {\n+            if arg.format.ty == \"?\" {\n+                // FIXME: modify rustc's fmt string parser to give us the current span\n+                span_lint(cx, USE_DEBUG, parser.prev_span, \"use of `Debug`-based formatting\");\n             }\n+            args.push(arg);\n         }\n     }\n-    false\n-}\n-\n-/// Checks if the expression matches\n-/// ```rust,ignore\n-/// &[_ {\n-///    format: _ {\n-///         width: _::Implied,\n-///         ...\n-///    },\n-///    ...,\n-/// }]\n-/// ```\n-pub fn check_unformatted(format_field: &Expr) -> bool {\n-    if_chain! {\n-        if let ExprStruct(_, ref fields, _) = format_field.node;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == \"width\");\n-        if let ExprPath(ref qpath) = width_field.expr.node;\n-        if last_path_segment(qpath).ident.name == \"Implied\";\n-        if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"align\");\n-        if let ExprPath(ref qpath) = align_field.expr.node;\n-        if last_path_segment(qpath).ident.name == \"Unknown\";\n-        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == \"precision\");\n-        if let ExprPath(ref qpath_precision) = precision_field.expr.node;\n-        if last_path_segment(qpath_precision).ident.name == \"Implied\";\n-        then {\n-            return true;\n+    let lint = if is_write {\n+        WRITE_LITERAL\n+    } else {\n+        PRINT_LITERAL\n+    };\n+    let mut idx = 0;\n+    loop {\n+        if !parser.eat(&token::Comma) {\n+            assert!(parser.eat(&token::Eof));\n+            return Some(fmtstr);\n+        }\n+        let expr = parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        const SIMPLE: FormatSpec<'_> = FormatSpec {\n+            fill: None,\n+            align: AlignUnknown,\n+            flags: 0,\n+            precision: CountImplied,\n+            width: CountImplied,\n+            ty: \"\",\n+        };\n+        match &expr.node {\n+            ExprKind::Lit(_) => {\n+                let mut all_simple = true;\n+                let mut seen = false;\n+                for arg in &args {\n+                    match arg.position {\n+                        | ArgumentImplicitlyIs(n)\n+                        | ArgumentIs(n)\n+                        => if n == idx {\n+                            all_simple &= arg.format == SIMPLE;\n+                            seen = true;\n+                        },\n+                        ArgumentNamed(_) => {},\n+                    }\n+                }\n+                if all_simple && seen {\n+                    span_lint(cx, lint, expr.span, \"literal with an empty format string\");\n+                }\n+                idx += 1;\n+            },\n+            ExprKind::Assign(lhs, rhs) => {\n+                if let ExprKind::Path(_, p) = &lhs.node {\n+                    let mut all_simple = true;\n+                    let mut seen = false;\n+                    for arg in &args {\n+                        match arg.position {\n+                            | ArgumentImplicitlyIs(_)\n+                            | ArgumentIs(_)\n+                            => {},\n+                            ArgumentNamed(name) => if *p == name {\n+                                seen = true;\n+                                all_simple &= arg.format == SIMPLE;\n+                            },\n+                        }\n+                    }\n+                    if all_simple && seen {\n+                        span_lint(cx, lint, rhs.span, \"literal with an empty format string\");\n+                    }\n+                }\n+            },\n+            _ => idx += 1,\n         }\n     }\n-\n-    false\n }"}, {"sha": "7c8af7880ba22b7ec5f7cdbfcc118f2ad1f32eb6", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,5 +1,7 @@\n use crate::consts::{constant_simple, Constant};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use crate::utils::span_help_and_lint;\n \n@@ -32,8 +34,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // check for instances of 0.0/0.0\n         if_chain! {\n-            if let ExprBinary(ref op, ref left, ref right) = expr.node;\n-            if let BinOp_::BiDiv = op.node;\n+            if let ExprKind::Binary(ref op, ref left, ref right) = expr.node;\n+            if let BinOpKind::Div = op.node;\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too."}, {"sha": "3417e603c126e574aa2a7a96ca1b775be9f1ed60", "filename": "mini-macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/mini-macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/mini-macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini-macro%2Fsrc%2Flib.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,4 +1,4 @@\n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_quote, proc_macro_non_items)]\n extern crate proc_macro;\n \n use proc_macro::{TokenStream, quote};"}, {"sha": "bf867e0ae5b6c08df1118a2ece970677bc479f1b", "filename": "rust-toolchain", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -0,0 +1 @@\n+nightly"}, {"sha": "e9e81bb88e3de13e90e2446ababa441147e9e4b4", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -118,6 +118,7 @@ pub fn main() {\n             for (name, to) in lint_groups {\n                 ls.register_group(Some(sess), true, name, to);\n             }\n+            clippy_lints::register_pre_expansion_lints(sess, &mut ls);\n \n             sess.plugin_llvm_passes.borrow_mut().extend(llvm_passes);\n             sess.plugin_attributes.borrow_mut().extend(attributes);"}, {"sha": "1123c968006ab82f70d370a5aecd55747f0d23e7", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -10,7 +10,7 @@\n use rustc_plugin::Registry;\n \n #[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n+pub fn plugin_registrar(reg: &mut Registry<'_>) {\n     reg.sess.lint_store.with_read_lock(|lint_store| {\n         for (lint, _, _) in lint_store.get_lint_groups() {\n             reg.sess"}, {"sha": "b06fb1d21e3512ed5749a290dfee9f0dde7df55b", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,11 +1,11 @@\n if_chain! {\n-    if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n-    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let StmtKind::Decl(ref decl, _) = stmt.node\n+    if let DeclKind::Local(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprCast(ref expr, ref cast_ty) = init.node;\n-    if let Ty_::TyPath(ref qp) = cast_ty.node;\n+    if let ExprKind::Cast(ref expr, ref cast_ty) = init.node;\n+    if let TyKind::Path(ref qp) = cast_ty.node;\n     if match_qpath(qp, &[\"char\"]);\n-    if let Expr_::ExprLit(ref lit) = expr.node;\n+    if let ExprKind::Lit(ref lit) = expr.node;\n     if let LitKind::Int(69, _) = lit.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;\n     if name.node.as_str() == \"x\";"}, {"sha": "1c25708fb4849f734f6fc20a2dfec6d75e58bb0c", "filename": "tests/ui/author/call.stdout", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fauthor%2Fcall.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fauthor%2Fcall.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fcall.stdout?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,14 +1,14 @@\n if_chain! {\n-    if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n-    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let StmtKind::Decl(ref decl, _) = stmt.node\n+    if let DeclKind::Local(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprCall(ref func, ref args) = init.node;\n-    if let Expr_::ExprPath(ref path) = func.node;\n+    if let ExprKind::Call(ref func, ref args) = init.node;\n+    if let ExprKind::Path(ref path) = func.node;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"cmp\", \"min\"]);\n     if args.len() == 2;\n-    if let Expr_::ExprLit(ref lit) = args[0].node;\n+    if let ExprKind::Lit(ref lit) = args[0].node;\n     if let LitKind::Int(3, _) = lit.node;\n-    if let Expr_::ExprLit(ref lit1) = args[1].node;\n+    if let ExprKind::Lit(ref lit1) = args[1].node;\n     if let LitKind::Int(4, _) = lit1.node;\n     if let PatKind::Wild = local.pat.node;\n     then {"}, {"sha": "b99e8e0ade5e5cb3247ef082f179e172acc4c6fa", "filename": "tests/ui/author/for_loop.stdout", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,60 +1,60 @@\n if_chain! {\n-    if let Expr_::ExprBlock(ref block) = expr.node;\n-    if let Stmt_::StmtDecl(ref decl, _) = block.node\n-    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let ExprKind::Block(ref block) = expr.node;\n+    if let StmtKind::Decl(ref decl, _) = block.node\n+    if let DeclKind::Local(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::ForLoopDesugar) = init.node;\n-    if let Expr_::ExprCall(ref func, ref args) = expr.node;\n-    if let Expr_::ExprPath(ref path) = func.node;\n+    if let ExprKind::Match(ref expr, ref arms, MatchSource::ForLoopDesugar) = init.node;\n+    if let ExprKind::Call(ref func, ref args) = expr.node;\n+    if let ExprKind::Path(ref path) = func.node;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"iter\", \"IntoIterator\", \"into_iter\"]);\n     if args.len() == 1;\n-    if let Expr_::ExprStruct(ref path1, ref fields, None) = args[0].node;\n+    if let ExprKind::Struct(ref path1, ref fields, None) = args[0].node;\n     if match_qpath(path1, &[\"{{root}}\", \"std\", \"ops\", \"Range\"]);\n     if fields.len() == 2;\n     // unimplemented: field checks\n     if arms.len() == 1;\n-    if let Expr_::ExprLoop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.node;\n-    if let Stmt_::StmtDecl(ref decl1, _) = body.node\n-    if let Decl_::DeclLocal(ref local1) = decl1.node;\n+    if let ExprKind::Loop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.node;\n+    if let StmtKind::Decl(ref decl1, _) = body.node\n+    if let DeclKind::Local(ref local1) = decl1.node;\n     if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local1.pat.node;\n     if name.node.as_str() == \"__next\";\n-    if let Stmt_::StmtExpr(ref e, _) = local1.pat.node\n-    if let Expr_::ExprMatch(ref expr1, ref arms1, MatchSource::ForLoopDesugar) = e.node;\n-    if let Expr_::ExprCall(ref func1, ref args1) = expr1.node;\n-    if let Expr_::ExprPath(ref path2) = func1.node;\n+    if let StmtKind::Expr(ref e, _) = local1.pat.node\n+    if let ExprKind::Match(ref expr1, ref arms1, MatchSource::ForLoopDesugar) = e.node;\n+    if let ExprKind::Call(ref func1, ref args1) = expr1.node;\n+    if let ExprKind::Path(ref path2) = func1.node;\n     if match_qpath(path2, &[\"{{root}}\", \"std\", \"iter\", \"Iterator\", \"next\"]);\n     if args1.len() == 1;\n-    if let Expr_::ExprAddrOf(MutMutable, ref inner) = args1[0].node;\n-    if let Expr_::ExprPath(ref path3) = inner.node;\n+    if let ExprKind::AddrOf(MutMutable, ref inner) = args1[0].node;\n+    if let ExprKind::Path(ref path3) = inner.node;\n     if match_qpath(path3, &[\"iter\"]);\n     if arms1.len() == 2;\n-    if let Expr_::ExprAssign(ref target, ref value) = arms1[0].body.node;\n-    if let Expr_::ExprPath(ref path4) = target.node;\n+    if let ExprKind::Assign(ref target, ref value) = arms1[0].body.node;\n+    if let ExprKind::Path(ref path4) = target.node;\n     if match_qpath(path4, &[\"__next\"]);\n-    if let Expr_::ExprPath(ref path5) = value.node;\n+    if let ExprKind::Path(ref path5) = value.node;\n     if match_qpath(path5, &[\"val\"]);\n     if arms1[0].pats.len() == 1;\n     if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pats[0].node;\n     if match_qpath(path6, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"Some\"]);\n     if fields1.len() == 1;\n     // unimplemented: field checks\n-    if let Expr_::ExprBreak(ref destination, None) = arms1[1].body.node;\n+    if let ExprKind::Break(ref destination, None) = arms1[1].body.node;\n     if arms1[1].pats.len() == 1;\n     if let PatKind::Path(ref path7) = arms1[1].pats[0].node;\n     if match_qpath(path7, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n-    if let Stmt_::StmtDecl(ref decl2, _) = path7.node\n-    if let Decl_::DeclLocal(ref local2) = decl2.node;\n+    if let StmtKind::Decl(ref decl2, _) = path7.node\n+    if let DeclKind::Local(ref local2) = decl2.node;\n     if let Some(ref init1) = local2.init\n-    if let Expr_::ExprPath(ref path8) = init1.node;\n+    if let ExprKind::Path(ref path8) = init1.node;\n     if match_qpath(path8, &[\"__next\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local2.pat.node;\n     if name1.node.as_str() == \"y\";\n-    if let Stmt_::StmtExpr(ref e1, _) = local2.pat.node\n-    if let Expr_::ExprBlock(ref block1) = e1.node;\n-    if let Stmt_::StmtDecl(ref decl3, _) = block1.node\n-    if let Decl_::DeclLocal(ref local3) = decl3.node;\n+    if let StmtKind::Expr(ref e1, _) = local2.pat.node\n+    if let ExprKind::Block(ref block1) = e1.node;\n+    if let StmtKind::Decl(ref decl3, _) = block1.node\n+    if let DeclKind::Local(ref local3) = decl3.node;\n     if let Some(ref init2) = local3.init\n-    if let Expr_::ExprPath(ref path9) = init2.node;\n+    if let ExprKind::Path(ref path9) = init2.node;\n     if match_qpath(path9, &[\"y\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local3.pat.node;\n     if name2.node.as_str() == \"z\";\n@@ -63,7 +63,7 @@ if_chain! {\n     if name3.node.as_str() == \"iter\";\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name4, None) = local.pat.node;\n     if name4.node.as_str() == \"_result\";\n-    if let Expr_::ExprPath(ref path10) = local.pat.node;\n+    if let ExprKind::Path(ref path10) = local.pat.node;\n     if match_qpath(path10, &[\"_result\"]);\n     then {\n         // report your lint here"}, {"sha": "94b25aefabed284196353925164afb34eb70e695", "filename": "tests/ui/author/matches.stout", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fauthor%2Fmatches.stout", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fauthor%2Fmatches.stout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stout?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,32 +1,32 @@\n if_chain! {\n-    if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n-    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let StmtKind::Decl(ref decl, _) = stmt.node\n+    if let DeclKind::Local(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::Normal) = init.node;\n-    if let Expr_::ExprLit(ref lit) = expr.node;\n+    if let ExprKind::Match(ref expr, ref arms, MatchSource::Normal) = init.node;\n+    if let ExprKind::Lit(ref lit) = expr.node;\n     if let LitKind::Int(42, _) = lit.node;\n     if arms.len() == 3;\n-    if let Expr_::ExprLit(ref lit1) = arms[0].body.node;\n+    if let ExprKind::Lit(ref lit1) = arms[0].body.node;\n     if let LitKind::Int(5, _) = lit1.node;\n     if arms[0].pats.len() == 1;\n     if let PatKind::Lit(ref lit_expr) = arms[0].pats[0].node\n-    if let Expr_::ExprLit(ref lit2) = lit_expr.node;\n+    if let ExprKind::Lit(ref lit2) = lit_expr.node;\n     if let LitKind::Int(16, _) = lit2.node;\n-    if let Expr_::ExprBlock(ref block) = arms[1].body.node;\n-    if let Stmt_::StmtDecl(ref decl1, _) = block.node\n-    if let Decl_::DeclLocal(ref local1) = decl1.node;\n+    if let ExprKind::Block(ref block) = arms[1].body.node;\n+    if let StmtKind::Decl(ref decl1, _) = block.node\n+    if let DeclKind::Local(ref local1) = decl1.node;\n     if let Some(ref init1) = local1.init\n-    if let Expr_::ExprLit(ref lit3) = init1.node;\n+    if let ExprKind::Lit(ref lit3) = init1.node;\n     if let LitKind::Int(3, _) = lit3.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.node;\n     if name.node.as_str() == \"x\";\n-    if let Expr_::ExprPath(ref path) = local1.pat.node;\n+    if let ExprKind::Path(ref path) = local1.pat.node;\n     if match_qpath(path, &[\"x\"]);\n     if arms[1].pats.len() == 1;\n     if let PatKind::Lit(ref lit_expr1) = arms[1].pats[0].node\n-    if let Expr_::ExprLit(ref lit4) = lit_expr1.node;\n+    if let ExprKind::Lit(ref lit4) = lit_expr1.node;\n     if let LitKind::Int(17, _) = lit4.node;\n-    if let Expr_::ExprLit(ref lit5) = arms[2].body.node;\n+    if let ExprKind::Lit(ref lit5) = arms[2].body.node;\n     if let LitKind::Int(1, _) = lit5.node;\n     if arms[2].pats.len() == 1;\n     if let PatKind::Wild = arms[2].pats[0].node;"}, {"sha": "6bbc0aebf9c9bd07c860c62a2c23dc2ba0647a01", "filename": "tests/ui/deprecated.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,30 +1,30 @@\n-error: lint str_to_string has been removed: using `str::to_string` is common even today and specialization will likely happen soon\n+error: lint `str_to_string` has been removed: `using `str::to_string` is common even today and specialization will likely happen soon`\n  --> $DIR/deprecated.rs:4:8\n   |\n 4 | #[warn(str_to_string)]\n   |        ^^^^^^^^^^^^^\n   |\n   = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n-error: lint string_to_string has been removed: using `string::to_string` is common even today and specialization will likely happen soon\n+error: lint `string_to_string` has been removed: `using `string::to_string` is common even today and specialization will likely happen soon`\n  --> $DIR/deprecated.rs:6:8\n   |\n 6 | #[warn(string_to_string)]\n   |        ^^^^^^^^^^^^^^^^\n \n-error: lint unstable_as_slice has been removed: `Vec::as_slice` has been stabilized in 1.7\n+error: lint `unstable_as_slice` has been removed: ``Vec::as_slice` has been stabilized in 1.7`\n  --> $DIR/deprecated.rs:8:8\n   |\n 8 | #[warn(unstable_as_slice)]\n   |        ^^^^^^^^^^^^^^^^^\n \n-error: lint unstable_as_mut_slice has been removed: `Vec::as_mut_slice` has been stabilized in 1.7\n+error: lint `unstable_as_mut_slice` has been removed: ``Vec::as_mut_slice` has been stabilized in 1.7`\n   --> $DIR/deprecated.rs:10:8\n    |\n 10 | #[warn(unstable_as_mut_slice)]\n    |        ^^^^^^^^^^^^^^^^^^^^^\n \n-error: lint misaligned_transmute has been removed: this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr\n+error: lint `misaligned_transmute` has been removed: `this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr`\n   --> $DIR/deprecated.rs:12:8\n    |\n 12 | #[warn(misaligned_transmute)]"}, {"sha": "1318ed78717da7d072ba711da6c88d2b59d2c417", "filename": "tests/ui/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdlist.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -6,7 +6,7 @@\n #![allow(dead_code, needless_pass_by_value)]\n \n extern crate alloc;\n-use alloc::linked_list::LinkedList;\n+use alloc::collections::linked_list::LinkedList;\n \n trait Foo {\n     type Baz = LinkedList<u8>;"}, {"sha": "88f24d27dbc4a7d7f1e252009a961aaae2418f7f", "filename": "tests/ui/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -22,7 +22,7 @@ fn main() {\n     const BAD64_3: f64 = 0.100_000_000_000_000_000_1;\n \n     // Literal as param\n-    println!(\"{}\", 8.888_888_888_888_888_888_888);\n+    println!(\"{:?}\", 8.888_888_888_888_888_888_888);\n \n     // // TODO add inferred type tests for f32\n     // Locals"}, {"sha": "295846e9d7e011cdba69b53308e811658afc8acf", "filename": "tests/ui/excessive_precision.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fexcessive_precision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fexcessive_precision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -43,10 +43,10 @@ error: float has excessive precision\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.1`\n \n error: float has excessive precision\n-  --> $DIR/excessive_precision.rs:25:20\n+  --> $DIR/excessive_precision.rs:25:22\n    |\n-25 |     println!(\"{}\", 8.888_888_888_888_888_888_888);\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `8.888_888_888_888_89`\n+25 |     println!(\"{:?}\", 8.888_888_888_888_888_888_888);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `8.888_888_888_888_89`\n \n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:36:22"}, {"sha": "6554b6d344929eb9066914100549fed2c9f9b4db", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -26,6 +26,23 @@ help: instead of prefixing all patterns with `&`, you can dereference the expres\n 32 |             None => println!(\"none\"),\n    |\n \n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/matches.rs:40:5\n+   |\n+40 | /     match tup {\n+41 | |         &(v, 1) => println!(\"{}\", v),\n+42 | |         _ => println!(\"none\"),\n+43 | |     }\n+   | |_____^\n+help: try this\n+   |\n+40 |     if let &(v, 1) = tup {\n+41 | # [ cfg ( not ( stage0 ) ) ] {\n+42 | ( $ crate :: io :: _print ( format_args_nl ! ( $ ( $ arg ) * ) ) ) ; } # [\n+43 | cfg ( stage0 ) ] { print ! ( \"{}/n\" , format_args ! ( $ ( $ arg ) * ) ) } } else {\n+44 | ( $ crate :: io :: _print ( format_args_nl ! ( $ ( $ arg ) * ) ) ) ; }\n+   |\n+\n error: you don't need to add `&` to all patterns\n   --> $DIR/matches.rs:40:5\n    |\n@@ -350,5 +367,5 @@ error: use as_mut() instead\n 221 | |     };\n     | |_____^ help: try this: `mut_owned.as_mut()`\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "38f5903307164967f7ef77b5420fc6dd56e472eb", "filename": "tests/ui/missing_inline.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_inline.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -0,0 +1,72 @@\n+/* This file incorporates work covered by the following copyright and\n+ * permission notice:\n+ *   Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+ *   file at the top-level directory of this distribution and at\n+ *   http://rust-lang.org/COPYRIGHT.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+ *   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+ *   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+ *   option. This file may not be copied, modified, or distributed\n+ *   except according to those terms.\n+ */\n+#![warn(missing_inline_in_public_items)]\n+#![crate_type = \"dylib\"]\n+// When denying at the crate level, be sure to not get random warnings from the\n+// injected intrinsics by the compiler.\n+#![allow(dead_code, non_snake_case)]\n+\n+type Typedef = String;\n+pub type PubTypedef = String;\n+\n+struct Foo {} // ok\n+pub struct PubFoo { } // ok\n+enum FooE {} // ok\n+pub enum PubFooE {} // ok\n+\n+mod module {} // ok\n+pub mod pub_module {} // ok\n+\n+fn foo() {}\n+pub fn pub_foo() {} // missing #[inline]\n+#[inline] pub fn pub_foo_inline() {} // ok\n+#[inline(always)] pub fn pub_foo_inline_always() {} // ok\n+\n+#[allow(missing_inline_in_public_items)]\n+pub fn pub_foo_no_inline() {}\n+\n+trait Bar {\n+    fn Bar_a(); // ok\n+    fn Bar_b() {} // ok\n+}\n+\n+\n+pub trait PubBar {\n+    fn PubBar_a(); // ok\n+    fn PubBar_b() {} // missing #[inline]\n+    #[inline] fn PubBar_c() {} // ok\n+}\n+\n+// none of these need inline because Foo is not exported\n+impl PubBar for Foo {\n+    fn PubBar_a() {} // ok\n+    fn PubBar_b() {} // ok\n+    fn PubBar_c() {} // ok\n+}\n+\n+// all of these need inline because PubFoo is exported\n+impl PubBar for PubFoo {\n+    fn PubBar_a() {} // missing #[inline]\n+    fn PubBar_b() {} // missing #[inline]\n+    fn PubBar_c() {} // missing #[inline]\n+}\n+\n+// do not need inline because Foo is not exported\n+impl Foo {\n+    fn FooImpl() {} // ok\n+}\n+\n+// need inline because PubFoo is exported\n+impl PubFoo {\n+    pub fn PubFooImpl() {} // missing #[inline]\n+}"}, {"sha": "fe343742708d56e0a7368702afd3cf17616b1ff9", "filename": "tests/ui/missing_inline.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fmissing_inline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fmissing_inline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_inline.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -0,0 +1,40 @@\n+error: missing `#[inline]` for a function\n+  --> $DIR/missing_inline.rs:31:1\n+   |\n+31 | pub fn pub_foo() {} // missing #[inline]\n+   | ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D missing-inline-in-public-items` implied by `-D warnings`\n+\n+error: missing `#[inline]` for a default trait method\n+  --> $DIR/missing_inline.rs:46:5\n+   |\n+46 |     fn PubBar_b() {} // missing #[inline]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: missing `#[inline]` for a method\n+  --> $DIR/missing_inline.rs:59:5\n+   |\n+59 |     fn PubBar_a() {} // missing #[inline]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: missing `#[inline]` for a method\n+  --> $DIR/missing_inline.rs:60:5\n+   |\n+60 |     fn PubBar_b() {} // missing #[inline]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: missing `#[inline]` for a method\n+  --> $DIR/missing_inline.rs:61:5\n+   |\n+61 |     fn PubBar_c() {} // missing #[inline]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: missing `#[inline]` for a method\n+  --> $DIR/missing_inline.rs:71:5\n+   |\n+71 |     pub fn PubFooImpl() {} // missing #[inline]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "c63b493db8d2fe57b2863a8337c044e6431fbfbc", "filename": "tests/ui/non_expressive_names.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fnon_expressive_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fnon_expressive_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_expressive_names.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,3 +1,23 @@\n+error: using `println!(\"\")`\n+  --> $DIR/non_expressive_names.rs:60:14\n+   |\n+60 |         _ => println!(\"\"),\n+   |              ^^^^^^^^^^^^ help: replace it with: `println!()`\n+   |\n+   = note: `-D println-empty-string` implied by `-D warnings`\n+\n+error: using `println!(\"\")`\n+   --> $DIR/non_expressive_names.rs:128:18\n+    |\n+128 |             1 => println!(\"\"),\n+    |                  ^^^^^^^^^^^^ help: replace it with: `println!()`\n+\n+error: using `println!(\"\")`\n+   --> $DIR/non_expressive_names.rs:132:18\n+    |\n+132 |             1 => println!(\"\"),\n+    |                  ^^^^^^^^^^^^ help: replace it with: `println!()`\n+\n error: binding's name is too similar to existing binding\n   --> $DIR/non_expressive_names.rs:18:9\n    |\n@@ -167,5 +187,5 @@ error: consider choosing a more descriptive name\n 151 |         let __1___2 = 12;\n     |             ^^^^^^^\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "f2d2afd9bf782d1695e62c94d064c7ac6954ee3f", "filename": "tests/ui/print.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fprint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fprint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,54 +1,60 @@\n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:13:27\n+  --> $DIR/print.rs:13:19\n    |\n 13 |         write!(f, \"{:?}\", 43.1415)\n-   |                           ^^^^^^^\n+   |                   ^^^^^^\n    |\n    = note: `-D use-debug` implied by `-D warnings`\n \n+error: use of `Debug`-based formatting\n+  --> $DIR/print.rs:20:19\n+   |\n+20 |         write!(f, \"{:?}\", 42.718)\n+   |                   ^^^^^^\n+\n error: use of `println!`\n   --> $DIR/print.rs:25:5\n    |\n 25 |     println!(\"Hello\");\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D print-stdout` implied by `-D warnings`\n \n error: use of `print!`\n   --> $DIR/print.rs:26:5\n    |\n 26 |     print!(\"Hello\");\n-   |     ^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:28:5\n    |\n 28 |     print!(\"Hello {}\", \"World\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:30:5\n    |\n 30 |     print!(\"Hello {:?}\", \"World\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:30:26\n+  --> $DIR/print.rs:30:12\n    |\n 30 |     print!(\"Hello {:?}\", \"World\");\n-   |                          ^^^^^^^\n+   |            ^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:32:5\n    |\n 32 |     print!(\"Hello {:#?}\", \"#orld\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:32:27\n+  --> $DIR/print.rs:32:12\n    |\n 32 |     print!(\"Hello {:#?}\", \"#orld\");\n-   |                           ^^^^^^^\n+   |            ^^^^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "39e0387cb5ec3ccc8128d6d428c399e01df09ecf", "filename": "tests/ui/print_literal.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fprint_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fprint_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,84 +1,84 @@\n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:23:71\n    |\n 23 |     println!(\"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n    |                                                                       ^\n    |\n    = note: `-D print-literal` implied by `-D warnings`\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:24:24\n    |\n 24 |     print!(\"Hello {}\", \"world\");\n    |                        ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:25:36\n    |\n 25 |     println!(\"Hello {} {}\", world, \"world\");\n    |                                    ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:26:26\n    |\n 26 |     println!(\"Hello {}\", \"world\");\n    |                          ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:27:30\n    |\n 27 |     println!(\"10 / 4 is {}\", 2.5);\n    |                              ^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:28:28\n    |\n 28 |     println!(\"2 + 1 = {}\", 3);\n    |                            ^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:33:25\n    |\n 33 |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:33:34\n    |\n 33 |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:34:25\n    |\n 34 |     println!(\"{1} {0}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:34:34\n    |\n 34 |     println!(\"{1} {0}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:37:33\n    |\n 37 |     println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                 ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:37:46\n    |\n 37 |     println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                              ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:38:33\n    |\n 38 |     println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n    |                                 ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:38:46\n    |\n 38 |     println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");"}, {"sha": "181f16b5cb71066bb6c80a39181ef0804a850d9a", "filename": "tests/ui/print_with_newline.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,9 +2,27 @@ error: using `print!()` with a format string that ends in a newline, consider us\n  --> $DIR/print_with_newline.rs:7:5\n   |\n 7 |     print!(\"Hello/n\");\n-  |     ^^^^^^^^^^^^^^^^^^\n+  |     ^^^^^^^^^^^^^^^^^\n   |\n   = note: `-D print-with-newline` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+ --> $DIR/print_with_newline.rs:8:5\n+  |\n+8 |     print!(\"Hello {}/n\", \"world\");\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+ --> $DIR/print_with_newline.rs:9:5\n+  |\n+9 |     print!(\"Hello {} {}/n/n\", \"world\", \"#2\");\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+  --> $DIR/print_with_newline.rs:10:5\n+   |\n+10 |     print!(\"{}/n\", 1265);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "cff3f988052a1dd14a6041510d15c7a7bb5b6c21", "filename": "tests/ui/println_empty_string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fprintln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fprintln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -4,7 +4,7 @@ error: using `println!(\"\")`\n 3 |     println!(\"\");\n   |     ^^^^^^^^^^^^ help: replace it with: `println!()`\n   |\n-  = note: `-D print-with-newline` implied by `-D warnings`\n+  = note: `-D println-empty-string` implied by `-D warnings`\n \n error: using `println!(\"\")`\n  --> $DIR/println_empty_string.rs:6:14"}, {"sha": "9f6fce2495a3dfdbfd82e10957744fc8e93341d6", "filename": "tests/ui/suspicious_arithmetic_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fsuspicious_arithmetic_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fsuspicious_arithmetic_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_arithmetic_impl.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -25,23 +25,23 @@ impl Mul for Foo {\n     type Output = Foo;\n \n     fn mul(self, other: Foo) -> Foo {\n-        Foo(self.0 * other.0 % 42) // OK: BiRem part of BiExpr as parent node\n+        Foo(self.0 * other.0 % 42) // OK: BinOpKind::Rem part of BiExpr as parent node\n     }\n }\n \n impl Sub for Foo {\n     type Output = Foo;\n \n     fn sub(self, other: Self) -> Self {\n-        Foo(self.0 * other.0 - 42) // OK: BiMul part of BiExpr as child node\n+        Foo(self.0 * other.0 - 42) // OK: BinOpKind::Mul part of BiExpr as child node\n     }\n }\n \n impl Div for Foo {\n     type Output = Foo;\n \n     fn div(self, other: Self) -> Self {\n-        Foo(do_nothing(self.0 + other.0) / 42) // OK: BiAdd part of BiExpr as child node\n+        Foo(do_nothing(self.0 + other.0) / 42) // OK: BinOpKind::Add part of BiExpr as child node\n     }\n }\n "}, {"sha": "b311604c0c87eafd4bbc4172d4b9b13d92f02da4", "filename": "tests/ui/trailing_zeros.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Ftrailing_zeros.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Ftrailing_zeros.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zeros.stdout?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,13 +1,13 @@\n if_chain! {\n-    if let Expr_::ExprBinary(ref op, ref left, ref right) = expr.node;\n-    if BinOp_::BiEq == op.node;\n-    if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n-    if BinOp_::BiBitAnd == op1.node;\n-    if let Expr_::ExprPath(ref path) = left1.node;\n+    if let ExprKind::Binary(ref op, ref left, ref right) = expr.node;\n+    if BinOpKind::Eq == op.node;\n+    if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.node;\n+    if BinOpKind::BitAnd == op1.node;\n+    if let ExprKind::Path(ref path) = left1.node;\n     if match_qpath(path, &[\"x\"]);\n-    if let Expr_::ExprLit(ref lit) = right1.node;\n+    if let ExprKind::Lit(ref lit) = right1.node;\n     if let LitKind::Int(15, _) = lit.node;\n-    if let Expr_::ExprLit(ref lit1) = right.node;\n+    if let ExprKind::Lit(ref lit1) = right.node;\n     if let LitKind::Int(0, _) = lit1.node;\n     then {\n         // report your lint here"}, {"sha": "c6773add244305186f2b8657174633e260464ffe", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -11,6 +11,15 @@ type Baz = u32;\n fn good(a: &mut u32, b: u32, c: &Bar) {\n }\n \n+fn good_return_implicit_lt_ref(foo: &Foo) -> &u32 {\n+    &foo.0\n+}\n+\n+#[allow(needless_lifetimes)]\n+fn good_return_explicit_lt_ref<'a>(foo: &'a Foo) -> &'a u32 {\n+    &foo.0\n+}\n+\n fn bad(x: &u32, y: &Foo, z: &Baz) {\n }\n \n@@ -46,6 +55,8 @@ fn main() {\n     let (mut foo, bar) = (Foo(0), Bar([0; 24]));\n     let (mut a, b, c, x, y, z) = (0, 0, Bar([0; 24]), 0, Foo(0), 0);\n     good(&mut a, b, &c);\n+    good_return_implicit_lt_ref(&y);\n+    good_return_explicit_lt_ref(&y);\n     bad(&x, &y, &z);\n     foo.good(&mut a, b, &c);\n     foo.good2();"}, {"sha": "db25cc5a02011b2a278ef7e580948c88a9dad3ab", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,81 +1,81 @@\n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:14:11\n+  --> $DIR/trivially_copy_pass_by_ref.rs:23:11\n    |\n-14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+23 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |           ^^^^ help: consider passing by value instead: `u32`\n    |\n    = note: `-D trivially-copy-pass-by-ref` implied by `-D warnings`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:14:20\n+  --> $DIR/trivially_copy_pass_by_ref.rs:23:20\n    |\n-14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+23 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |                    ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:14:29\n+  --> $DIR/trivially_copy_pass_by_ref.rs:23:29\n    |\n-14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+23 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |                             ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:24:12\n+  --> $DIR/trivially_copy_pass_by_ref.rs:33:12\n    |\n-24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+33 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |            ^^^^^ help: consider passing by value instead: `self`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:24:22\n+  --> $DIR/trivially_copy_pass_by_ref.rs:33:22\n    |\n-24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+33 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                      ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:24:31\n+  --> $DIR/trivially_copy_pass_by_ref.rs:33:31\n    |\n-24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+33 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                               ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:24:40\n+  --> $DIR/trivially_copy_pass_by_ref.rs:33:40\n    |\n-24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+33 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                                        ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:27:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:36:16\n    |\n-27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+36 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:27:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:36:25\n    |\n-27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+36 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:27:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:36:34\n    |\n-27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+36 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:41:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:50:16\n    |\n-41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+50 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:41:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:50:25\n    |\n-41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+50 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:41:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:50:34\n    |\n-41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+50 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: aborting due to 13 previous errors"}, {"sha": "68c7d2007a6b65bf258cf716a1e693ef365937d2", "filename": "tests/ui/useless_attribute.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fuseless_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fuseless_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_attribute.rs?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -6,6 +6,8 @@\n #[cfg_attr(feature = \"cargo-clippy\", allow(dead_code, unused_extern_crates))]\n #[cfg_attr(feature = \"cargo-clippy\",\n            allow(dead_code, unused_extern_crates))]\n+#[allow(unused_imports)]\n+#[macro_use]\n extern crate clippy_lints;\n \n // don't lint on unused_import for `use` items"}, {"sha": "70855ef8187068b1716eb56c39f2895030d9ccfa", "filename": "tests/ui/write_literal.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fwrite_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fwrite_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -1,84 +1,84 @@\n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:26:79\n    |\n 26 |     writeln!(&mut v, \"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n    |                                                                               ^\n    |\n    = note: `-D write-literal` implied by `-D warnings`\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:27:32\n    |\n 27 |     write!(&mut v, \"Hello {}\", \"world\");\n    |                                ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:28:44\n    |\n 28 |     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n    |                                            ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:29:34\n    |\n 29 |     writeln!(&mut v, \"Hello {}\", \"world\");\n    |                                  ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:30:38\n    |\n 30 |     writeln!(&mut v, \"10 / 4 is {}\", 2.5);\n    |                                      ^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:31:36\n    |\n 31 |     writeln!(&mut v, \"2 + 1 = {}\", 3);\n    |                                    ^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:36:33\n    |\n 36 |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n    |                                 ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:36:42\n    |\n 36 |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n    |                                          ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:37:33\n    |\n 37 |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n    |                                 ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:37:42\n    |\n 37 |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n    |                                          ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:40:41\n    |\n 40 |     writeln!(&mut v, \"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                         ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:40:54\n    |\n 40 |     writeln!(&mut v, \"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                                      ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:41:41\n    |\n 41 |     writeln!(&mut v, \"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n    |                                         ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:41:54\n    |\n 41 |     writeln!(&mut v, \"{bar} {foo}\", foo=\"hello\", bar=\"world\");"}, {"sha": "7bb9b99731ffb7740a3753ac6c6c73be20174f0f", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -2,27 +2,27 @@ error: using `write!()` with a format string that ends in a newline, consider us\n   --> $DIR/write_with_newline.rs:10:5\n    |\n 10 |     write!(&mut v, \"Hello/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D write-with-newline` implied by `-D warnings`\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:11:5\n    |\n 11 |     write!(&mut v, \"Hello {}/n\", \"world\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:12:5\n    |\n 12 |     write!(&mut v, \"Hello {} {}/n/n\", \"world\", \"#2\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:13:5\n    |\n 13 |     write!(&mut v, \"{}/n\", 1265);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "16a8e0a203d3a3f26cea4c32e025710d79015bc7", "filename": "tests/ui/writeln_empty_string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fwriteln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/tests%2Fui%2Fwriteln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.stderr?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -4,7 +4,7 @@ error: using `writeln!(v, \"\")`\n 9 |     writeln!(&mut v, \"\");\n   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(v)`\n   |\n-  = note: `-D write-with-newline` implied by `-D warnings`\n+  = note: `-D writeln-empty-string` implied by `-D warnings`\n \n error: aborting due to previous error\n "}, {"sha": "0088ecc3d89ddc699c3a94c711a5526eed998568", "filename": "util/gh-pages/index.html", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/util%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/util%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Findex.html?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -14,6 +14,9 @@\n \n         .form-inline .checkbox { margin-right: 0.6em }\n \n+        .panel-heading { pointer: cursor; }\n+        .panel-heading:hover { background-color: #eee; }\n+\n         .panel-title { display: flex; }\n         .panel-title .label { display: inline-block; }\n "}, {"sha": "00826805e1617b5e80db08168b668f8e1f5b087d", "filename": "util/lintlib.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/util%2Flintlib.py", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/util%2Flintlib.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Flintlib.py?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -44,7 +44,7 @@ def parse_lints(lints, filepath):\n                     last_comment.append(line[3:])\n                 elif line.startswith(\"declare_lint!\"):\n                     import sys\n-                    print \"don't use `declare_lint!` in clippy, use `declare_clippy_lint!` instead\"\n+                    print \"don't use `declare_lint!` in Clippy, use `declare_clippy_lint!` instead\"\n                     sys.exit(42)\n                 elif line.startswith(\"declare_clippy_lint!\"):\n                     comment = False"}, {"sha": "70d49f940eebc3516b592957258f4bfd850ec300", "filename": "util/update_lints.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/util%2Fupdate_lints.py", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b33f17b9255224c9e7927dfbf80c6a8547b6/util%2Fupdate_lints.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_lints.py?ref=cfc9b33f17b9255224c9e7927dfbf80c6a8547b6", "patch": "@@ -192,8 +192,8 @@ def main(print_only=False, check=False):\n     # update the links in the CHANGELOG\n     changed |= replace_region(\n         'CHANGELOG.md',\n-        \"<!-- begin autogenerated links to wiki -->\",\n-        \"<!-- end autogenerated links to wiki -->\",\n+        \"<!-- begin autogenerated links to lint list -->\",\n+        \"<!-- end autogenerated links to lint list -->\",\n         lambda: [\"[`{0}`]: {1}#{0}\\n\".format(l[1], docs_link) for l in\n                  sorted(all_lints + deprecated_lints,\n                         key=lambda l: l[1])],"}]}