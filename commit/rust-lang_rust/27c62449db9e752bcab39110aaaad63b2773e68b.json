{"sha": "27c62449db9e752bcab39110aaaad63b2773e68b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YzYyNDQ5ZGI5ZTc1MmJjYWIzOTExMGFhYWFkNjNiMjc3M2U2OGI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-11T20:27:55Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-13T12:21:46Z"}, "message": "Region + borrow checker support and tests for overloaded autoderef.", "tree": {"sha": "e02cec3603d4b52a4a82cef2ec2999b8d9b5e1e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e02cec3603d4b52a4a82cef2ec2999b8d9b5e1e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27c62449db9e752bcab39110aaaad63b2773e68b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27c62449db9e752bcab39110aaaad63b2773e68b", "html_url": "https://github.com/rust-lang/rust/commit/27c62449db9e752bcab39110aaaad63b2773e68b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27c62449db9e752bcab39110aaaad63b2773e68b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feedd37653b32a97e2d10c12f2cf1b14c0058c19", "url": "https://api.github.com/repos/rust-lang/rust/commits/feedd37653b32a97e2d10c12f2cf1b14c0058c19", "html_url": "https://github.com/rust-lang/rust/commit/feedd37653b32a97e2d10c12f2cf1b14c0058c19"}], "stats": {"total": 564, "additions": 540, "deletions": 24}, "files": [{"sha": "f6168feb2b84696ca1b0a8c6faa456074aea45d2", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=27c62449db9e752bcab39110aaaad63b2773e68b", "patch": "@@ -326,6 +326,39 @@ impl<'a> GatherLoanCtxt<'a> {\n         assert_eq!(id, popped);\n     }\n \n+    pub fn guarantee_autoderefs(&mut self,\n+                                expr: &ast::Expr,\n+                                autoderefs: uint) {\n+        let method_map = self.bccx.method_map.borrow();\n+        for i in range(0, autoderefs) {\n+            match method_map.get().find(&MethodCall::autoderef(expr.id, i as u32)) {\n+                Some(method) => {\n+                    // Treat overloaded autoderefs as if an AutoRef adjustment\n+                    // was applied on the base type, as that is always the case.\n+                    let mut mc = self.bccx.mc();\n+                    let cmt = match mc.cat_expr_autoderefd(expr, i) {\n+                        Ok(v) => v,\n+                        Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n+                    };\n+                    let self_ty = *ty::ty_fn_args(method.ty).get(0);\n+                    let (m, r) = match ty::get(self_ty).sty {\n+                        ty::ty_rptr(r, ref m) => (m.mutbl, r),\n+                        _ => self.tcx().sess.span_bug(expr.span,\n+                                format!(\"bad overloaded deref type {}\",\n+                                    method.ty.repr(self.tcx())))\n+                    };\n+                    self.guarantee_valid(expr.id,\n+                                         expr.span,\n+                                         cmt,\n+                                         m,\n+                                         r,\n+                                         AutoRef);\n+                }\n+                None => {}\n+            }\n+        }\n+    }\n+\n     pub fn guarantee_adjustments(&mut self,\n                                  expr: &ast::Expr,\n                                  adjustment: &ty::AutoAdjustment) {\n@@ -341,15 +374,17 @@ impl<'a> GatherLoanCtxt<'a> {\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n-                    autoref: None, .. }) => {\n+                    autoref: None, autoderefs }) => {\n                 debug!(\"no autoref\");\n+                self.guarantee_autoderefs(expr, autoderefs);\n                 return;\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoref: Some(ref autoref),\n-                    autoderefs: autoderefs}) => {\n+                    autoderefs}) => {\n+                self.guarantee_autoderefs(expr, autoderefs);\n                 let mut mc = self.bccx.mc();\n                 let cmt = match mc.cat_expr_autoderefd(expr, autoderefs) {\n                     Ok(v) => v,"}, {"sha": "aef1b20273a28b4218d127147c95f92863c67e31", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 57, "deletions": 22, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=27c62449db9e752bcab39110aaaad63b2773e68b", "patch": "@@ -141,6 +141,19 @@ use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+// If mem categorization results in an error, it's because the type\n+// check failed (or will fail, when the error is uncovered and\n+// reported during writeback). In this case, we just ignore this part\n+// of the code and don't try to add any more region constraints.\n+macro_rules! ignore_err(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => v,\n+            Err(()) => return\n+        }\n+    )\n+)\n+\n pub struct Rcx {\n     fcx: @FnCtxt,\n     errors_reported: uint,\n@@ -395,7 +408,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         match **adjustment {\n             ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n-                constrain_derefs(rcx, expr, autoderefs, expr_ty);\n+                constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n                 for autoref in opt_autoref.iter() {\n                     link_autoref(rcx, expr, autoderefs, autoref);\n \n@@ -494,7 +507,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };\n-            constrain_derefs(rcx, expr, 1, base_ty);\n+            match ty::get(base_ty).sty {\n+                ty::ty_rptr(r_ptr, _) => {\n+                    mk_subregion_due_to_derefence(rcx, expr.span,\n+                                                  ty::ReScope(expr.id), r_ptr);\n+                }\n+                _ => {}\n+            }\n \n             visit::walk_expr(rcx, expr, ());\n         }\n@@ -819,11 +838,10 @@ fn constrain_call(rcx: &mut Rcx,\n         fn_sig.output);\n }\n \n-fn constrain_derefs(rcx: &mut Rcx,\n-                    deref_expr: &ast::Expr,\n-                    derefs: uint,\n-                    mut derefd_ty: ty::t)\n-{\n+fn constrain_autoderefs(rcx: &mut Rcx,\n+                        deref_expr: &ast::Expr,\n+                        derefs: uint,\n+                        mut derefd_ty: ty::t) {\n     /*!\n      * Invoked on any dereference that occurs, whether explicitly\n      * or through an auto-deref.  Checks that if this is a region\n@@ -832,16 +850,46 @@ fn constrain_derefs(rcx: &mut Rcx,\n      */\n     let r_deref_expr = ty::ReScope(deref_expr.id);\n     for i in range(0u, derefs) {\n-        debug!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n+        debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n                i, derefs);\n \n+        let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n+        derefd_ty = match rcx.fcx.inh.method_map.get().find(&method_call) {\n+            Some(method) => {\n+                // Treat overloaded autoderefs as if an AutoRef adjustment\n+                // was applied on the base type, as that is always the case.\n+                let fn_sig = ty::ty_fn_sig(method.ty);\n+                let self_ty = *fn_sig.inputs.get(0);\n+                let (m, r) = match ty::get(self_ty).sty {\n+                    ty::ty_rptr(r, ref m) => (m.mutbl, r),\n+                    _ => rcx.tcx().sess.span_bug(deref_expr.span,\n+                            format!(\"bad overloaded deref type {}\",\n+                                method.ty.repr(rcx.tcx())))\n+                };\n+                {\n+                    let mut mc = mc::MemCategorizationContext { typer: &mut *rcx };\n+                    let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n+                    link_region(mc.typer, deref_expr.span, r, m, self_cmt);\n+                }\n+\n+                // Specialized version of constrain_call.\n+                constrain_regions_in_type(rcx, r_deref_expr,\n+                                          infer::CallRcvr(deref_expr.span),\n+                                          self_ty);\n+                constrain_regions_in_type(rcx, r_deref_expr,\n+                                          infer::CallReturn(deref_expr.span),\n+                                          fn_sig.output);\n+                fn_sig.output\n+            }\n+            None => derefd_ty\n+        };\n+\n         match ty::get(derefd_ty).sty {\n             ty::ty_rptr(r_ptr, _) => {\n                 mk_subregion_due_to_derefence(rcx, deref_expr.span,\n                                               r_deref_expr, r_ptr);\n             }\n-\n             _ => {}\n         }\n \n@@ -965,19 +1013,6 @@ fn constrain_regions_in_type(\n     return e == rcx.errors_reported;\n }\n \n-// If mem categorization results in an error, it's because the type\n-// check failed (or will fail, when the error is uncovered and\n-// reported during writeback). In this case, we just ignore this part\n-// of the code and don't try to add any more region constraints.\n-macro_rules! ignore_err(\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => { v }\n-            Err(()) => { return; }\n-        }\n-    )\n-)\n-\n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n                mutability: ast::Mutability, base: &ast::Expr) {\n     /*!"}, {"sha": "9800fd704ac71f2cb8ba75f229f65547e67f3967", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref-mut.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs?ref=27c62449db9e752bcab39110aaaad63b2773e68b", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test how overloaded deref interacts with borrows when DerefMut\n+// is implemented.\n+\n+use std::ops::{Deref, DerefMut};\n+\n+struct Own<T> {\n+    value: *mut T\n+}\n+\n+impl<T> Deref<T> for Own<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.value }\n+    }\n+}\n+\n+impl<T> DerefMut<T> for Own<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        unsafe { &mut *self.value }\n+    }\n+}\n+\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+impl Point {\n+    fn get(&self) -> (int, int) {\n+        (self.x, self.y)\n+    }\n+\n+    fn set(&mut self, x: int, y: int) {\n+        self.x = x;\n+        self.y = y;\n+    }\n+\n+    fn x_ref<'a>(&'a self) -> &'a int {\n+        &self.x\n+    }\n+\n+    fn y_mut<'a>(&'a mut self) -> &'a mut int {\n+        &mut self.y\n+    }\n+}\n+\n+fn deref_imm_field(x: Own<Point>) {\n+    let _i = &x.y;\n+}\n+\n+fn deref_mut_field1(x: Own<Point>) {\n+    let _i = &mut x.y; //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut_field2(mut x: Own<Point>) {\n+    let _i = &mut x.y;\n+}\n+\n+fn deref_extend_field<'a>(x: &'a Own<Point>) -> &'a int {\n+    &x.y\n+}\n+\n+fn deref_extend_mut_field1<'a>(x: &'a Own<Point>) -> &'a mut int {\n+    &mut x.y //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_field2<'a>(x: &'a mut Own<Point>) -> &'a mut int {\n+    &mut x.y\n+}\n+\n+fn assign_field1<'a>(x: Own<Point>) {\n+    x.y = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_field2<'a>(x: &'a Own<Point>) {\n+    x.y = 3; //~ ERROR cannot assign\n+}\n+\n+fn assign_field3<'a>(x: &'a mut Own<Point>) {\n+    x.y = 3;\n+}\n+\n+// FIXME(eddyb) #12825 This shouldn't attempt to call deref_mut.\n+/*\n+fn deref_imm_method(x: Own<Point>) {\n+    let _i = x.get();\n+}\n+*/\n+\n+fn deref_mut_method1(x: Own<Point>) {\n+    x.set(0, 0); //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut_method2(mut x: Own<Point>) {\n+    x.set(0, 0);\n+}\n+\n+fn deref_extend_method<'a>(x: &'a Own<Point>) -> &'a int {\n+    x.x_ref()\n+}\n+\n+fn deref_extend_mut_method1<'a>(x: &'a Own<Point>) -> &'a mut int {\n+    x.y_mut() //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_method2<'a>(x: &'a mut Own<Point>) -> &'a mut int {\n+    x.y_mut()\n+}\n+\n+fn assign_method1<'a>(x: Own<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_method2<'a>(x: &'a Own<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_method3<'a>(x: &'a mut Own<Point>) {\n+    *x.y_mut() = 3;\n+}\n+\n+pub fn main() {}\n\\ No newline at end of file"}, {"sha": "de68dd311c6578872aefc4a354381aa70393000b", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs?ref=27c62449db9e752bcab39110aaaad63b2773e68b", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test how overloaded deref interacts with borrows when only\n+// Deref and not DerefMut is implemented.\n+\n+use std::ops::Deref;\n+\n+struct Rc<T> {\n+    value: *T\n+}\n+\n+impl<T> Deref<T> for Rc<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.value }\n+    }\n+}\n+\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+impl Point {\n+    fn get(&self) -> (int, int) {\n+        (self.x, self.y)\n+    }\n+\n+    fn set(&mut self, x: int, y: int) {\n+        self.x = x;\n+        self.y = y;\n+    }\n+\n+    fn x_ref<'a>(&'a self) -> &'a int {\n+        &self.x\n+    }\n+\n+    fn y_mut<'a>(&'a mut self) -> &'a mut int {\n+        &mut self.y\n+    }\n+}\n+\n+fn deref_imm_field(x: Rc<Point>) {\n+    let _i = &x.y;\n+}\n+\n+fn deref_mut_field1(x: Rc<Point>) {\n+    let _i = &mut x.y; //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut_field2(mut x: Rc<Point>) {\n+    let _i = &mut x.y; //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_field<'a>(x: &'a Rc<Point>) -> &'a int {\n+    &x.y\n+}\n+\n+fn deref_extend_mut_field1<'a>(x: &'a Rc<Point>) -> &'a mut int {\n+    &mut x.y //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_field2<'a>(x: &'a mut Rc<Point>) -> &'a mut int {\n+    &mut x.y //~ ERROR cannot borrow\n+}\n+\n+fn assign_field1<'a>(x: Rc<Point>) {\n+    x.y = 3; //~ ERROR cannot assign\n+}\n+\n+fn assign_field2<'a>(x: &'a Rc<Point>) {\n+    x.y = 3; //~ ERROR cannot assign\n+}\n+\n+fn assign_field3<'a>(x: &'a mut Rc<Point>) {\n+    x.y = 3; //~ ERROR cannot assign\n+}\n+\n+fn deref_imm_method(x: Rc<Point>) {\n+    let _i = x.get();\n+}\n+\n+fn deref_mut_method1(x: Rc<Point>) {\n+    x.set(0, 0); //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut_method2(mut x: Rc<Point>) {\n+    x.set(0, 0); //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_method<'a>(x: &'a Rc<Point>) -> &'a int {\n+    x.x_ref()\n+}\n+\n+fn deref_extend_mut_method1<'a>(x: &'a Rc<Point>) -> &'a mut int {\n+    x.y_mut() //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut_method2<'a>(x: &'a mut Rc<Point>) -> &'a mut int {\n+    x.y_mut() //~ ERROR cannot borrow\n+}\n+\n+fn assign_method1<'a>(x: Rc<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_method2<'a>(x: &'a Rc<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign_method3<'a>(x: &'a mut Rc<Point>) {\n+    *x.y_mut() = 3; //~ ERROR cannot borrow\n+}\n+\n+pub fn main() {}"}, {"sha": "1a96e5ef4b0ccbf301b5f6b6fea4bac199cb42ad", "filename": "src/test/compile-fail/borrowck-move-out-of-overloaded-auto-deref.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs?ref=27c62449db9e752bcab39110aaaad63b2773e68b", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+pub fn main() {\n+    let _x = Rc::new(vec!(1, 2)).move_iter();\n+    //~^ ERROR cannot move out of dereference of `&`-pointer\n+}"}, {"sha": "10ee06473c80bf8fe73ede7e64aa7daa435aaed1", "filename": "src/test/run-pass/overloaded-autoderef-count.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs?ref=27c62449db9e752bcab39110aaaad63b2773e68b", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+use std::ops::{Deref, DerefMut};\n+use std::vec_ng::Vec;\n+\n+#[deriving(Eq)]\n+struct DerefCounter<T> {\n+    count_imm: Cell<uint>,\n+    count_mut: uint,\n+    value: T\n+}\n+\n+impl<T> DerefCounter<T> {\n+    fn new(value: T) -> DerefCounter<T> {\n+        DerefCounter {\n+            count_imm: Cell::new(0),\n+            count_mut: 0,\n+            value: value\n+        }\n+    }\n+\n+    fn counts(&self) -> (uint, uint) {\n+        (self.count_imm.get(), self.count_mut)\n+    }\n+}\n+\n+impl<T> Deref<T> for DerefCounter<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        self.count_imm.set(self.count_imm.get() + 1);\n+        &self.value\n+    }\n+}\n+\n+impl<T> DerefMut<T> for DerefCounter<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        self.count_mut += 1;\n+        &mut self.value\n+    }\n+}\n+\n+#[deriving(Eq, Show)]\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+impl Point {\n+    fn get(&self) -> (int, int) {\n+        (self.x, self.y)\n+    }\n+}\n+\n+pub fn main() {\n+    let mut p = DerefCounter::new(Point {x: 0, y: 0});\n+\n+    let _ = p.x;\n+    assert_eq!(p.counts(), (1, 0));\n+\n+    let _ = &p.x;\n+    assert_eq!(p.counts(), (2, 0));\n+\n+    let _ = &mut p.y;\n+    assert_eq!(p.counts(), (2, 1));\n+\n+    p.x += 3;\n+    assert_eq!(p.counts(), (2, 2));\n+\n+    p.get();\n+    assert_eq!(p.counts(), (2, 3));\n+\n+    // Check the final state.\n+    assert_eq!(*p, Point {x: 3, y: 0});\n+}"}, {"sha": "c8885a3090c00ea6f0699927203618a882e498f3", "filename": "src/test/run-pass/overloaded-autoderef-indexing.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-indexing.rs?ref=27c62449db9e752bcab39110aaaad63b2773e68b", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct DerefArray<'a, T> {\n+    inner: &'a [T]\n+}\n+\n+impl<'a, T> Deref<&'a [T]> for DerefArray<'a, T> {\n+    fn deref<'b>(&'b self) -> &'b &'a [T] {\n+        &self.inner\n+    }\n+}\n+\n+pub fn main() {\n+    let a = &[1, 2, 3];\n+    assert_eq!(DerefArray {inner: a}[1], 2);\n+}"}, {"sha": "9deeff773642d67a0c38844062c8b65d45c2396a", "filename": "src/test/run-pass/overloaded-autoderef-order.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c62449db9e752bcab39110aaaad63b2773e68b/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs?ref=27c62449db9e752bcab39110aaaad63b2773e68b", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+struct DerefWrapper<X, Y> {\n+    x: X,\n+    y: Y\n+}\n+\n+impl<X, Y> DerefWrapper<X, Y> {\n+    fn get_x(self) -> X {\n+        self.x\n+    }\n+}\n+\n+impl<X, Y> Deref<Y> for DerefWrapper<X, Y> {\n+    fn deref<'a>(&'a self) -> &'a Y {\n+        &self.y\n+    }\n+}\n+\n+mod priv_test {\n+    pub struct DerefWrapperHideX<X, Y> {\n+        priv x: X,\n+        y: Y\n+    }\n+\n+    impl<X, Y> DerefWrapperHideX<X, Y> {\n+        pub fn new(x: X, y: Y) -> DerefWrapperHideX<X, Y> {\n+            DerefWrapperHideX {\n+                x: x,\n+                y: y\n+            }\n+        }\n+    }\n+\n+    impl<X, Y> Deref<Y> for DerefWrapperHideX<X, Y> {\n+        fn deref<'a>(&'a self) -> &'a Y {\n+            &self.y\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    let nested = DerefWrapper {x: true, y: DerefWrapper {x: 0, y: 1}};\n+\n+    // Use the first field that you can find.\n+    assert_eq!(nested.x, true);\n+    assert_eq!((*nested).x, 0);\n+\n+    // Same for methods, even though there are multiple\n+    // candidates (at different nesting levels).\n+    assert_eq!(nested.get_x(), true);\n+    assert_eq!((*nested).get_x(), 0);\n+\n+    // Also go through multiple levels of indirection.\n+    assert_eq!(Rc::new(nested).x, true);\n+\n+    let nested_priv = priv_test::DerefWrapperHideX::new(true, DerefWrapper {x: 0, y: 1});\n+    // FIXME(eddyb) #12808 should skip private fields.\n+    // assert_eq!(nested_priv.x, 0);\n+    assert_eq!((*nested_priv).x, 0);\n+}"}]}