{"sha": "1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "node_id": "C_kwDOAAsO6NoAKDFjZTE4ZDJkNjU4ZWI4YjE2MjU5NjVlNWE1MGQwNDBkNWM4ZjA1YzE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-10T08:24:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-10T08:24:41Z"}, "message": "Rollup merge of #104512 - jyn514:download-ci-llvm-default, r=Mark-Simulacrum\n\nSet `download-ci-llvm = \"if-available\"` by default when `channel = dev`\n\nSee https://github.com/rust-lang/compiler-team/issues/566. The motivation for changing the default is to avoid downloading and building LLVM when someone runs `x build` before running `x setup`. The motivation for only doing it on `channel = \"dev\"` is to avoid breaking distros or users installing from source. It works because `dev` is also the default channel.\n\nThe diff looks larger than it is; most of it is moving the `llvm` branch below the `rust` so `config.channel` is set.\n\nr? `@Mark-Simulacrum` cc `@oli-obk` `@bjorn3` `@cuviper`", "tree": {"sha": "17a9f902150ea7f67f9d940125bf8375be655c45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17a9f902150ea7f67f9d940125bf8375be655c45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjlEJJCRBK7hj4Ov3rIwAAxW4IABwir6/bxahWL/YC7sjz1Msj\nEAkRZRW9PgYGn7dqu9/eVS/WIKedIBphWzUaam/2xbdGziXiWragaZnkAAMAZ3ac\n7a7PSa3EfAI1pIuksQ1dphejizcNdQS5Q3AoYCF+EDVu+ZV7VZLxhZ/K9b6rQPRP\nBJ87/p7fmyNPZCjI0BWGs9byX9WYliuW6mxZ3BauEoqcDNottlLNsg3553gupOk4\nOhe+GyEg7J5L2+k57/Ex/8XYKy26hN8o6ESHX7U4VIE6JhQuNvbO0MClu6wJKksQ\nFmacQwruk6u2c0UK0r7ZVU81VFpUN7u1Ws2joBZ4BA8A5mGNfREBxh2o1tfK0yU=\n=LvLg\n-----END PGP SIGNATURE-----\n", "payload": "tree 17a9f902150ea7f67f9d940125bf8375be655c45\nparent 0f5d3ba30f33116a610e5f9f2bb60f3ce120a167\nparent ac672621c0d9f10c0f5026cadba4b326eb213856\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670660681 +0100\ncommitter GitHub <noreply@github.com> 1670660681 +0100\n\nRollup merge of #104512 - jyn514:download-ci-llvm-default, r=Mark-Simulacrum\n\nSet `download-ci-llvm = \"if-available\"` by default when `channel = dev`\n\nSee https://github.com/rust-lang/compiler-team/issues/566. The motivation for changing the default is to avoid downloading and building LLVM when someone runs `x build` before running `x setup`. The motivation for only doing it on `channel = \"dev\"` is to avoid breaking distros or users installing from source. It works because `dev` is also the default channel.\n\nThe diff looks larger than it is; most of it is moving the `llvm` branch below the `rust` so `config.channel` is set.\n\nr? `@Mark-Simulacrum` cc `@oli-obk` `@bjorn3` `@cuviper`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "html_url": "https://github.com/rust-lang/rust/commit/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "html_url": "https://github.com/rust-lang/rust/commit/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167"}, {"sha": "ac672621c0d9f10c0f5026cadba4b326eb213856", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac672621c0d9f10c0f5026cadba4b326eb213856", "html_url": "https://github.com/rust-lang/rust/commit/ac672621c0d9f10c0f5026cadba4b326eb213856"}], "stats": {"total": 241, "additions": 141, "deletions": 100}, "files": [{"sha": "5e1d2f2e314ff904173d04c224797cd2b017b5f2", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "patch": "@@ -35,17 +35,16 @@ changelog-seen = 2\n # Unless you're developing for a target where Rust CI doesn't build a compiler\n # toolchain or changing LLVM locally, you probably want to set this to true.\n #\n-# This is false by default so that distributions don't unexpectedly download\n-# LLVM from the internet.\n-#\n # All tier 1 targets are currently supported; set this to `\"if-available\"` if\n # you are not sure whether you're on a tier 1 target.\n #\n # We also currently only support this when building LLVM for the build triple.\n #\n # Note that many of the LLVM options are not currently supported for\n # downloading. Currently only the \"assertions\" option can be toggled.\n-#download-ci-llvm = false\n+#\n+# Defaults to \"if-available\" when `channel = \"dev\"` and \"false\" otherwise.\n+#download-ci-llvm = \"if-available\"\n \n # Indicates whether LLVM rebuild should be skipped when running bootstrap. If\n # this is `false` then the compiler's LLVM will be rebuilt whenever the built"}, {"sha": "960fbdf75380448983b1f3650b9fd66b95dc3df8", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 108, "deletions": 94, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "patch": "@@ -3,6 +3,9 @@\n //! This module implements parsing `config.toml` configuration files to tweak\n //! how the build runs.\n \n+#[cfg(test)]\n+mod tests;\n+\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n@@ -696,7 +699,7 @@ define_config! {\n     }\n }\n \n-#[derive(Deserialize)]\n+#[derive(Debug, Deserialize)]\n #[serde(untagged)]\n enum StringOrBool {\n     String(String),\n@@ -822,6 +825,29 @@ impl Config {\n     }\n \n     pub fn parse(args: &[String]) -> Config {\n+        #[cfg(test)]\n+        let get_toml = |_: &_| TomlConfig::default();\n+        #[cfg(not(test))]\n+        let get_toml = |file: &Path| {\n+            let contents =\n+                t!(fs::read_to_string(file), format!(\"config file {} not found\", file.display()));\n+            // Deserialize to Value and then TomlConfig to prevent the Deserialize impl of\n+            // TomlConfig and sub types to be monomorphized 5x by toml.\n+            match toml::from_str(&contents)\n+                .and_then(|table: toml::Value| TomlConfig::deserialize(table))\n+            {\n+                Ok(table) => table,\n+                Err(err) => {\n+                    eprintln!(\"failed to parse TOML configuration '{}': {}\", file.display(), err);\n+                    crate::detail_exit(2);\n+                }\n+            }\n+        };\n+\n+        Self::parse_inner(args, get_toml)\n+    }\n+\n+    fn parse_inner<'a>(args: &[String], get_toml: impl 'a + Fn(&Path) -> TomlConfig) -> Config {\n         let flags = Flags::parse(&args);\n         let mut config = Config::default_opts();\n \n@@ -907,25 +933,6 @@ impl Config {\n \n         config.stage0_metadata = t!(serde_json::from_slice::<Stage0Metadata>(&stage0_json));\n \n-        #[cfg(test)]\n-        let get_toml = |_| TomlConfig::default();\n-        #[cfg(not(test))]\n-        let get_toml = |file: &Path| {\n-            let contents =\n-                t!(fs::read_to_string(file), format!(\"config file {} not found\", file.display()));\n-            // Deserialize to Value and then TomlConfig to prevent the Deserialize impl of\n-            // TomlConfig and sub types to be monomorphized 5x by toml.\n-            match toml::from_str(&contents)\n-                .and_then(|table: toml::Value| TomlConfig::deserialize(table))\n-            {\n-                Ok(table) => table,\n-                Err(err) => {\n-                    eprintln!(\"failed to parse TOML configuration '{}': {}\", file.display(), err);\n-                    crate::detail_exit(2);\n-                }\n-            }\n-        };\n-\n         // Read from `--config`, then `RUST_BOOTSTRAP_CONFIG`, then `./config.toml`, then `config.toml` in the root directory.\n         let toml_path = flags\n             .config\n@@ -1063,6 +1070,79 @@ impl Config {\n         let mut optimize = None;\n         let mut ignore_git = None;\n \n+        if let Some(rust) = toml.rust {\n+            debug = rust.debug;\n+            debug_assertions = rust.debug_assertions;\n+            debug_assertions_std = rust.debug_assertions_std;\n+            overflow_checks = rust.overflow_checks;\n+            overflow_checks_std = rust.overflow_checks_std;\n+            debug_logging = rust.debug_logging;\n+            debuginfo_level = rust.debuginfo_level;\n+            debuginfo_level_rustc = rust.debuginfo_level_rustc;\n+            debuginfo_level_std = rust.debuginfo_level_std;\n+            debuginfo_level_tools = rust.debuginfo_level_tools;\n+            debuginfo_level_tests = rust.debuginfo_level_tests;\n+            config.rust_split_debuginfo = rust\n+                .split_debuginfo\n+                .as_deref()\n+                .map(SplitDebuginfo::from_str)\n+                .map(|v| v.expect(\"invalid value for rust.split_debuginfo\"))\n+                .unwrap_or(SplitDebuginfo::default_for_platform(&config.build.triple));\n+            optimize = rust.optimize;\n+            ignore_git = rust.ignore_git;\n+            config.rust_new_symbol_mangling = rust.new_symbol_mangling;\n+            set(&mut config.rust_optimize_tests, rust.optimize_tests);\n+            set(&mut config.codegen_tests, rust.codegen_tests);\n+            set(&mut config.rust_rpath, rust.rpath);\n+            set(&mut config.jemalloc, rust.jemalloc);\n+            set(&mut config.test_compare_mode, rust.test_compare_mode);\n+            set(&mut config.backtrace, rust.backtrace);\n+            set(&mut config.channel, rust.channel);\n+            config.description = rust.description;\n+            set(&mut config.rust_dist_src, rust.dist_src);\n+            set(&mut config.verbose_tests, rust.verbose_tests);\n+            // in the case \"false\" is set explicitly, do not overwrite the command line args\n+            if let Some(true) = rust.incremental {\n+                config.incremental = true;\n+            }\n+            set(&mut config.use_lld, rust.use_lld);\n+            set(&mut config.lld_enabled, rust.lld);\n+            set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n+            config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n+            config.rustc_default_linker = rust.default_linker;\n+            config.musl_root = rust.musl_root.map(PathBuf::from);\n+            config.save_toolstates = rust.save_toolstates.map(PathBuf::from);\n+            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n+            set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n+            set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n+            config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n+            set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n+            set(&mut config.control_flow_guard, rust.control_flow_guard);\n+            config.llvm_libunwind_default = rust\n+                .llvm_libunwind\n+                .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"));\n+\n+            if let Some(ref backends) = rust.codegen_backends {\n+                config.rust_codegen_backends =\n+                    backends.iter().map(|s| INTERNER.intern_str(s)).collect();\n+            }\n+\n+            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n+            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n+            config.rust_profile_use = flags.rust_profile_use.or(rust.profile_use);\n+            config.rust_profile_generate = flags.rust_profile_generate.or(rust.profile_generate);\n+            config.download_rustc_commit = config.download_ci_rustc_commit(rust.download_rustc);\n+\n+            config.rust_lto = rust\n+                .lto\n+                .as_deref()\n+                .map(|value| RustcLto::from_str(value).unwrap())\n+                .unwrap_or_default();\n+        } else {\n+            config.rust_profile_use = flags.rust_profile_use;\n+            config.rust_profile_generate = flags.rust_profile_generate;\n+        }\n+\n         if let Some(llvm) = toml.llvm {\n             match llvm.ccache {\n                 Some(StringOrBool::String(ref s)) => config.ccache = Some(s.to_string()),\n@@ -1099,13 +1179,17 @@ impl Config {\n             config.llvm_polly = llvm.polly.unwrap_or(false);\n             config.llvm_clang = llvm.clang.unwrap_or(false);\n             config.llvm_build_config = llvm.build_config.clone().unwrap_or(Default::default());\n+\n+            let asserts = llvm_assertions.unwrap_or(false);\n             config.llvm_from_ci = match llvm.download_ci_llvm {\n                 Some(StringOrBool::String(s)) => {\n                     assert!(s == \"if-available\", \"unknown option `{}` for download-ci-llvm\", s);\n-                    crate::native::is_ci_llvm_available(&config, llvm_assertions.unwrap_or(false))\n+                    crate::native::is_ci_llvm_available(&config, asserts)\n                 }\n                 Some(StringOrBool::Bool(b)) => b,\n-                None => false,\n+                None => {\n+                    config.channel == \"dev\" && crate::native::is_ci_llvm_available(&config, asserts)\n+                }\n             };\n \n             if config.llvm_from_ci {\n@@ -1145,79 +1229,9 @@ impl Config {\n                 // the link step) with each stage.\n                 config.llvm_link_shared.set(Some(true));\n             }\n-        }\n-\n-        if let Some(rust) = toml.rust {\n-            debug = rust.debug;\n-            debug_assertions = rust.debug_assertions;\n-            debug_assertions_std = rust.debug_assertions_std;\n-            overflow_checks = rust.overflow_checks;\n-            overflow_checks_std = rust.overflow_checks_std;\n-            debug_logging = rust.debug_logging;\n-            debuginfo_level = rust.debuginfo_level;\n-            debuginfo_level_rustc = rust.debuginfo_level_rustc;\n-            debuginfo_level_std = rust.debuginfo_level_std;\n-            debuginfo_level_tools = rust.debuginfo_level_tools;\n-            debuginfo_level_tests = rust.debuginfo_level_tests;\n-            config.rust_split_debuginfo = rust\n-                .split_debuginfo\n-                .as_deref()\n-                .map(SplitDebuginfo::from_str)\n-                .map(|v| v.expect(\"invalid value for rust.split_debuginfo\"))\n-                .unwrap_or(SplitDebuginfo::default_for_platform(&config.build.triple));\n-            optimize = rust.optimize;\n-            ignore_git = rust.ignore_git;\n-            config.rust_new_symbol_mangling = rust.new_symbol_mangling;\n-            set(&mut config.rust_optimize_tests, rust.optimize_tests);\n-            set(&mut config.codegen_tests, rust.codegen_tests);\n-            set(&mut config.rust_rpath, rust.rpath);\n-            set(&mut config.jemalloc, rust.jemalloc);\n-            set(&mut config.test_compare_mode, rust.test_compare_mode);\n-            set(&mut config.backtrace, rust.backtrace);\n-            set(&mut config.channel, rust.channel);\n-            config.description = rust.description;\n-            set(&mut config.rust_dist_src, rust.dist_src);\n-            set(&mut config.verbose_tests, rust.verbose_tests);\n-            // in the case \"false\" is set explicitly, do not overwrite the command line args\n-            if let Some(true) = rust.incremental {\n-                config.incremental = true;\n-            }\n-            set(&mut config.use_lld, rust.use_lld);\n-            set(&mut config.lld_enabled, rust.lld);\n-            set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n-            config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n-            config.rustc_default_linker = rust.default_linker;\n-            config.musl_root = rust.musl_root.map(PathBuf::from);\n-            config.save_toolstates = rust.save_toolstates.map(PathBuf::from);\n-            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n-            set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n-            set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n-            config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n-            set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n-            set(&mut config.control_flow_guard, rust.control_flow_guard);\n-            config.llvm_libunwind_default = rust\n-                .llvm_libunwind\n-                .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"));\n-\n-            if let Some(ref backends) = rust.codegen_backends {\n-                config.rust_codegen_backends =\n-                    backends.iter().map(|s| INTERNER.intern_str(s)).collect();\n-            }\n-\n-            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n-            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n-            config.rust_profile_use = flags.rust_profile_use.or(rust.profile_use);\n-            config.rust_profile_generate = flags.rust_profile_generate.or(rust.profile_generate);\n-            config.download_rustc_commit = config.download_ci_rustc_commit(rust.download_rustc);\n-\n-            config.rust_lto = rust\n-                .lto\n-                .as_deref()\n-                .map(|value| RustcLto::from_str(value).unwrap())\n-                .unwrap_or_default();\n         } else {\n-            config.rust_profile_use = flags.rust_profile_use;\n-            config.rust_profile_generate = flags.rust_profile_generate;\n+            config.llvm_from_ci =\n+                config.channel == \"dev\" && crate::native::is_ci_llvm_available(&config, false);\n         }\n \n         if let Some(t) = toml.target {"}, {"sha": "c30c9131745c81e2f41cf8277852685ac1df579c", "filename": "src/bootstrap/config/tests.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/src%2Fbootstrap%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/src%2Fbootstrap%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig%2Ftests.rs?ref=1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "patch": "@@ -0,0 +1,24 @@\n+use super::{Config, TomlConfig};\n+use std::path::Path;\n+\n+fn toml(config: &str) -> impl '_ + Fn(&Path) -> TomlConfig {\n+    |&_| toml::from_str(config).unwrap()\n+}\n+\n+fn parse(config: &str) -> Config {\n+    Config::parse_inner(&[\"check\".to_owned(), \"--config=/does/not/exist\".to_owned()], toml(config))\n+}\n+\n+#[test]\n+fn download_ci_llvm() {\n+    let parse_llvm = |s| parse(s).llvm_from_ci;\n+    let if_available = parse_llvm(\"llvm.download-ci-llvm = \\\"if-available\\\"\");\n+\n+    assert!(parse_llvm(\"llvm.download-ci-llvm = true\"));\n+    assert!(!parse_llvm(\"llvm.download-ci-llvm = false\"));\n+    assert_eq!(parse_llvm(\"\"), if_available);\n+    assert_eq!(parse_llvm(\"rust.channel = \\\"dev\\\"\"), if_available);\n+    assert!(!parse_llvm(\"rust.channel = \\\"stable\\\"\"));\n+}\n+\n+// FIXME: add test for detecting `src` and `out`"}, {"sha": "48ae2fe448de2070ddcfd37b57b99434386b5ba4", "filename": "src/bootstrap/defaults/config.user.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml?ref=1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "patch": "@@ -7,3 +7,7 @@ test-stage = 2\n doc-stage = 2\n # When compiling from source, you usually want all tools.\n extended = true\n+\n+[llvm]\n+# Most users installing from source want to build all parts of the project from source, not just rustc itself.\n+download-ci-llvm = false"}, {"sha": "570fe6484e3db32aa436633f4ebde35d369b57a0", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce18d2d658eb8b1625965e5a50d040d5c8f05c1/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=1ce18d2d658eb8b1625965e5a50d040d5c8f05c1", "patch": "@@ -1639,10 +1639,10 @@ fn chmod(_path: &Path, _perms: u32) {}\n /// If the test is running and code is an error code, it will cause a panic.\n fn detail_exit(code: i32) -> ! {\n     // if in test and code is an error code, panic with status code provided\n-    if cfg!(test) && code != 0 {\n+    if cfg!(test) {\n         panic!(\"status code: {}\", code);\n     } else {\n-        //otherwise,exit with provided status code\n+        // otherwise,exit with provided status code\n         std::process::exit(code);\n     }\n }"}]}