{"sha": "e5c9cb2b3df91df4207d63611a1918e461219456", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YzljYjJiM2RmOTFkZjQyMDdkNjM2MTFhMTkxOGU0NjEyMTk0NTY=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-03T00:42:58Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:39Z"}, "message": "Pipes sleep and wake properly.", "tree": {"sha": "2b01aa2534ed3bbfe645093e83b3ac2586acf337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b01aa2534ed3bbfe645093e83b3ac2586acf337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5c9cb2b3df91df4207d63611a1918e461219456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5c9cb2b3df91df4207d63611a1918e461219456", "html_url": "https://github.com/rust-lang/rust/commit/e5c9cb2b3df91df4207d63611a1918e461219456", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5c9cb2b3df91df4207d63611a1918e461219456/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4838c93aadf4dbc32e71ddff19c6ecb6a95a66d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4838c93aadf4dbc32e71ddff19c6ecb6a95a66d", "html_url": "https://github.com/rust-lang/rust/commit/a4838c93aadf4dbc32e71ddff19c6ecb6a95a66d"}], "stats": {"total": 143, "additions": 132, "deletions": 11}, "files": [{"sha": "d6c5b32de59b5fb15c1e466b7d0c8a4793027da6", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=e5c9cb2b3df91df4207d63611a1918e461219456", "patch": "@@ -11,7 +11,7 @@ enum state {\n \n type packet<T: send> = {\n     mut state: state,\n-    mut blocked_task: option<task::task>,\n+    mut blocked_task: option<*rust_task>,\n     mut payload: option<T>\n };\n \n@@ -31,6 +31,19 @@ native mod rusti {\n     fn atomic_xchng_rel(&dst: int, src: int) -> int;\n }\n \n+type rust_task = libc::c_void;\n+\n+native mod rustrt {\n+    #[rust_stack]\n+    fn rust_get_task() -> *rust_task;\n+\n+    #[rust_stack]\n+    fn task_clear_event_reject(task: *rust_task);\n+\n+    fn task_wait_event(this: *rust_task) -> *libc::c_void;\n+    fn task_signal_event(target: *rust_task, event: *libc::c_void);\n+}\n+\n // We should consider moving this to core::unsafe, although I\n // suspect graydon would want us to use void pointers instead.\n unsafe fn uniquify<T>(x: *T) -> ~T {\n@@ -54,8 +67,8 @@ fn swap_state_rel(&dst: state, src: state) -> state {\n }\n \n fn send<T: send>(-p: send_packet<T>, -payload: T) {\n-    let p = p.unwrap();\n-    let p = unsafe { uniquify(p) };\n+    let p_ = p.unwrap();\n+    let p = unsafe { uniquify(p_) };\n     assert (*p).payload == none;\n     (*p).payload <- some(payload);\n     let old_state = swap_state_rel((*p).state, full);\n@@ -68,8 +81,13 @@ fn send<T: send>(-p: send_packet<T>, -payload: T) {\n       }\n       full { fail \"duplicate send\" }\n       blocked {\n-        // TODO: once the target will actually block, tell the\n-        // scheduler to wake it up.\n+        #debug(\"waking up task for %?\", p_);\n+        alt p.blocked_task {\n+          some(task) {\n+            rustrt::task_signal_event(task, p_ as *libc::c_void);\n+          }\n+          none { fail \"blocked packet has no task\" }\n+        }\n \n         // The receiver will eventually clean this up.\n         unsafe { forget(p); }\n@@ -82,16 +100,32 @@ fn send<T: send>(-p: send_packet<T>, -payload: T) {\n }\n \n fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n-    let p = p.unwrap();\n-    let p = unsafe { uniquify(p) };\n+    let p_ = p.unwrap();\n+    let p = unsafe { uniquify(p_) };\n+    let this = rustrt::rust_get_task();\n+    rustrt::task_clear_event_reject(this);\n+    p.blocked_task = some(this);\n     loop {\n         let old_state = swap_state_acq((*p).state,\n                                        blocked);\n+        #debug(\"%?\", old_state);\n         alt old_state {\n-          empty | blocked { task::yield(); }\n+          empty {\n+            #debug(\"no data available on %?, going to sleep.\", p_);\n+            rustrt::task_wait_event(this);\n+            #debug(\"woke up, p.state = %?\", p.state);\n+            if p.state == full {\n+                let mut payload = none;\n+                payload <-> (*p).payload;\n+                p.state = terminated;\n+                ret some(option::unwrap(payload))\n+            }\n+          }\n+          blocked { fail \"blocking on already blocked packet\" }\n           full {\n             let mut payload = none;\n             payload <-> (*p).payload;\n+            p.state = terminated;\n             ret some(option::unwrap(payload))\n           }\n           terminated {"}, {"sha": "7730ef8adfe7ab2f8e5327152b2d3612d13a6e3f", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=e5c9cb2b3df91df4207d63611a1918e461219456", "patch": "@@ -782,6 +782,7 @@ extern mod rustrt {\n     fn rust_new_sched(num_threads: libc::uintptr_t) -> sched_id;\n \n     fn get_task_id() -> task_id;\n+    #[rust_stack]\n     fn rust_get_task() -> *rust_task;\n \n     fn new_task() -> *rust_task;"}, {"sha": "732dbaa329311a09d4bb1e7a14a53dca4c1e2ad0", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=e5c9cb2b3df91df4207d63611a1918e461219456", "patch": "@@ -922,6 +922,26 @@ rust_task_local_data_atexit(rust_task *task, void (*cleanup_fn)(void *data)) {\n     task->task_local_data_cleanup = cleanup_fn;\n }\n \n+extern \"C\" void\n+task_clear_event_reject(rust_task *task) {\n+    task->clear_event_reject();\n+}\n+\n+// Waits on an event, returning the pointer to the event that unblocked this\n+// task.\n+extern \"C\" void *\n+task_wait_event(rust_task *task) {\n+    // TODO: we should assert that the passed in task is the currently running\n+    // task. We wouldn't want to wait some other task.\n+\n+    return task->wait_event();\n+}\n+\n+extern \"C\" void\n+task_signal_event(rust_task *target, void *event) {\n+    target->signal_event(event);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "6a9f5cf50012f2bf42039701147ddc06f5aabc42", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=e5c9cb2b3df91df4207d63611a1918e461219456", "patch": "@@ -36,6 +36,8 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     state(state),\n     cond(NULL),\n     cond_name(\"none\"),\n+    event_reject(false),\n+    event(NULL),\n     killed(false),\n     reentered_rust_stack(false),\n     disallow_kill(0),\n@@ -407,13 +409,20 @@ rust_task::free(void *p)\n void\n rust_task::transition(rust_task_state src, rust_task_state dst,\n                       rust_cond *cond, const char* cond_name) {\n+    scoped_lock with(state_lock);\n+    transition_locked(src, dst, cond, cond_name);\n+}\n+\n+void rust_task::transition_locked(rust_task_state src, rust_task_state dst,\n+                                  rust_cond *cond, const char* cond_name) {\n+    state_lock.must_have_lock();\n     sched_loop->transition(this, src, dst, cond, cond_name);\n }\n \n void\n rust_task::set_state(rust_task_state state,\n                      rust_cond *cond, const char* cond_name) {\n-    scoped_lock with(state_lock);\n+    state_lock.must_have_lock();\n     this->state = state;\n     this->cond = cond;\n     this->cond_name = cond_name;\n@@ -422,7 +431,11 @@ rust_task::set_state(rust_task_state state,\n bool\n rust_task::block(rust_cond *on, const char* name) {\n     scoped_lock with(kill_lock);\n+    return block_locked(on, name);\n+}\n \n+bool\n+rust_task::block_locked(rust_cond *on, const char* name) {\n     if (must_fail_from_being_killed_unlocked()) {\n         // We're already going to die. Don't block. Tell the task to fail\n         return false;\n@@ -433,19 +446,25 @@ rust_task::block(rust_cond *on, const char* name) {\n     assert(cond == NULL && \"Cannot block an already blocked task.\");\n     assert(on != NULL && \"Cannot block on a NULL object.\");\n \n-    transition(task_state_running, task_state_blocked, on, name);\n+    transition_locked(task_state_running, task_state_blocked, on, name);\n \n     return true;\n }\n \n void\n rust_task::wakeup(rust_cond *from) {\n+    scoped_lock with(state_lock);\n+    wakeup_locked(from);\n+}\n+\n+void\n+rust_task::wakeup_locked(rust_cond *from) {\n     assert(cond != NULL && \"Cannot wake up unblocked task.\");\n     LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n     assert(cond == from && \"Cannot wake up blocked task on wrong condition.\");\n \n-    transition(task_state_blocked, task_state_running, NULL, \"none\");\n+    transition_locked(task_state_blocked, task_state_running, NULL, \"none\");\n }\n \n void\n@@ -693,6 +712,34 @@ rust_task::allow_kill() {\n     disallow_kill--;\n }\n \n+void *\n+rust_task::wait_event() {\n+    scoped_lock with(state_lock);\n+\n+    if(!event_reject) {\n+        block_locked(&event_cond, \"waiting on event\");\n+        bool killed = false;\n+        state_lock.unlock();\n+        yield(&killed);\n+        state_lock.lock();\n+        // TODO: what is the right thing to do if we are killed?\n+    }\n+\n+    event_reject = false;\n+    return event;\n+}\n+\n+void\n+rust_task::signal_event(void *event) {\n+    scoped_lock with(state_lock);\n+\n+    this->event = event;\n+    event_reject = true;\n+    if(task_state_blocked == state) {\n+        wakeup_locked(&event_cond);\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "c5bdc50e4308488c08f8d61d014ed844de42cc54", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=e5c9cb2b3df91df4207d63611a1918e461219456", "patch": "@@ -175,6 +175,10 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     rust_cond *cond;\n     const char *cond_name;\n \n+    bool event_reject;\n+    rust_cond event_cond;\n+    void *event;\n+\n     // Protects the killed flag, disallow_kill flag, reentered_rust_stack\n     lock_and_signal kill_lock;\n     // Indicates that the task was killed and needs to unwind\n@@ -205,6 +209,8 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n \n     void transition(rust_task_state src, rust_task_state dst,\n                     rust_cond *cond, const char* cond_name);\n+    void transition_locked(rust_task_state src, rust_task_state dst,\n+                           rust_cond *cond, const char* cond_name);\n \n     bool must_fail_from_being_killed_unlocked();\n     // Called by rust_task_fail to unwind on failure\n@@ -221,6 +227,9 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n                                char const *file,\n                                size_t line);\n \n+    bool block_locked(rust_cond *on, const char* name);\n+    void wakeup_locked(rust_cond *from);\n+\n public:\n \n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n@@ -303,6 +312,13 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     rust_cond *get_cond() { return cond; }\n     const char *get_cond_name() { return cond_name; }\n \n+    void clear_event_reject() {\n+        this->event_reject = false;\n+    }\n+\n+    void *wait_event();\n+    void signal_event(void *event);\n+\n     void cleanup_after_turn();\n \n     void inhibit_kill();"}, {"sha": "e674d6fa19774ea1f6c2f8f2496d6de0366b247d", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/e5c9cb2b3df91df4207d63611a1918e461219456/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=e5c9cb2b3df91df4207d63611a1918e461219456", "patch": "@@ -64,6 +64,9 @@ start_task\n vec_reserve_shared\n str_reserve_shared\n vec_from_buf_shared\n+task_clear_event_reject\n+task_wait_event\n+task_signal_event\n unsupervise\n upcall_cmp_type\n upcall_fail"}]}