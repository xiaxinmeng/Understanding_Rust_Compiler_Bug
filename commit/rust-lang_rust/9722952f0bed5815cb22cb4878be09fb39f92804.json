{"sha": "9722952f0bed5815cb22cb4878be09fb39f92804", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MjI5NTJmMGJlZDU4MTVjYjIyY2I0ODc4YmUwOWZiMzlmOTI4MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-12T15:34:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-12T15:34:09Z"}, "message": "Auto merge of #76256 - tgnottingham:issue-74890, r=nikomatsakis\n\nincr-comp: hash and serialize span end line/column\n\nHash both the length and the end location (line/column) of a span. If we\nhash only the length, for example, then two otherwise equal spans with\ndifferent end locations will have the same hash. This can cause a\nproblem during incremental compilation wherein a previous result for a\nquery that depends on the end location of a span will be incorrectly\nreused when the end location of the span it depends on has changed. A\nsimilar analysis applies if some query depends specifically on the\nlength of the span, but we only hash the end location. So hash both.\n\nFix #46744, fix #59954, fix #63161, fix #73640, fix #73967, fix #74890, fix #75900\n\n---\n\nSee #74890 for a more in-depth analysis.\n\nI haven't thought about what other problems this root cause could be responsible for. Please let me know if anything springs to mind. I believe the issue has existed since the inception of incremental compilation.", "tree": {"sha": "270b703ec4edbb5a4c94f9edaac23b714d7a0512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/270b703ec4edbb5a4c94f9edaac23b714d7a0512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9722952f0bed5815cb22cb4878be09fb39f92804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9722952f0bed5815cb22cb4878be09fb39f92804", "html_url": "https://github.com/rust-lang/rust/commit/9722952f0bed5815cb22cb4878be09fb39f92804", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9722952f0bed5815cb22cb4878be09fb39f92804/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f5a42b073dc2bee2aa625052eb066ee07072048", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5a42b073dc2bee2aa625052eb066ee07072048", "html_url": "https://github.com/rust-lang/rust/commit/7f5a42b073dc2bee2aa625052eb066ee07072048"}, {"sha": "dac57e67d6116bcad81f905b8e92be3e9d8e4d23", "url": "https://api.github.com/repos/rust-lang/rust/commits/dac57e67d6116bcad81f905b8e92be3e9d8e4d23", "html_url": "https://github.com/rust-lang/rust/commit/dac57e67d6116bcad81f905b8e92be3e9d8e4d23"}], "stats": {"total": 79, "additions": 74, "deletions": 5}, "files": [{"sha": "0926561f4c5134038ddd78e9116389934a80a0b0", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9722952f0bed5815cb22cb4878be09fb39f92804/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9722952f0bed5815cb22cb4878be09fb39f92804/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=9722952f0bed5815cb22cb4878be09fb39f92804", "patch": "@@ -1894,16 +1894,37 @@ where\n             return;\n         }\n \n+        let (_, line_hi, col_hi) = match ctx.byte_pos_to_line_and_col(span.hi) {\n+            Some(pos) => pos,\n+            None => {\n+                Hash::hash(&TAG_INVALID_SPAN, hasher);\n+                span.ctxt.hash_stable(ctx, hasher);\n+                return;\n+            }\n+        };\n+\n         Hash::hash(&TAG_VALID_SPAN, hasher);\n         // We truncate the stable ID hash and line and column numbers. The chances\n         // of causing a collision this way should be minimal.\n         Hash::hash(&(file_lo.name_hash as u64), hasher);\n \n-        let col = (col_lo.0 as u64) & 0xFF;\n-        let line = ((line_lo as u64) & 0xFF_FF_FF) << 8;\n-        let len = ((span.hi - span.lo).0 as u64) << 32;\n-        let line_col_len = col | line | len;\n-        Hash::hash(&line_col_len, hasher);\n+        // Hash both the length and the end location (line/column) of a span. If we\n+        // hash only the length, for example, then two otherwise equal spans with\n+        // different end locations will have the same hash. This can cause a problem\n+        // during incremental compilation wherein a previous result for a query that\n+        // depends on the end location of a span will be incorrectly reused when the\n+        // end location of the span it depends on has changed (see issue #74890). A\n+        // similar analysis applies if some query depends specifically on the length\n+        // of the span, but we only hash the end location. So hash both.\n+\n+        let col_lo_trunc = (col_lo.0 as u64) & 0xFF;\n+        let line_lo_trunc = ((line_lo as u64) & 0xFF_FF_FF) << 8;\n+        let col_hi_trunc = (col_hi.0 as u64) & 0xFF << 32;\n+        let line_hi_trunc = ((line_hi as u64) & 0xFF_FF_FF) << 40;\n+        let col_line = col_lo_trunc | line_lo_trunc | col_hi_trunc | line_hi_trunc;\n+        let len = (span.hi - span.lo).0;\n+        Hash::hash(&col_line, hasher);\n+        Hash::hash(&len, hasher);\n         span.ctxt.hash_stable(ctx, hasher);\n     }\n }"}, {"sha": "49a7ee5f900fdc8d98f0e2512d7cd8e354f9ab72", "filename": "src/test/run-make/incr-prev-body-beyond-eof/Makefile", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9722952f0bed5815cb22cb4878be09fb39f92804/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9722952f0bed5815cb22cb4878be09fb39f92804/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2FMakefile?ref=9722952f0bed5815cb22cb4878be09fb39f92804", "patch": "@@ -0,0 +1,19 @@\n+include ../../run-make-fulldeps/tools.mk\n+\n+# FIXME https://github.com/rust-lang/rust/issues/78911\n+# ignore-32bit wrong/no cross compiler and sometimes we pass wrong gcc args (-m64)\n+\n+# Tests that we don't ICE during incremental compilation after modifying a\n+# function span such that its previous end line exceeds the number of lines\n+# in the new file, but its start line/column and length remain the same.\n+\n+SRC=$(TMPDIR)/src\n+INCR=$(TMPDIR)/incr\n+\n+all:\n+\tmkdir $(SRC)\n+\tmkdir $(INCR)\n+\tcp a.rs $(SRC)/main.rs\n+\t$(RUSTC) -C incremental=$(INCR) $(SRC)/main.rs\n+\tcp b.rs $(SRC)/main.rs\n+\t$(RUSTC) -C incremental=$(INCR) $(SRC)/main.rs"}, {"sha": "ca70fb563349ceb810be684fa70ecc8cfc567c8d", "filename": "src/test/run-make/incr-prev-body-beyond-eof/a.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9722952f0bed5815cb22cb4878be09fb39f92804/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9722952f0bed5815cb22cb4878be09fb39f92804/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2Fa.rs?ref=9722952f0bed5815cb22cb4878be09fb39f92804", "patch": "@@ -0,0 +1,16 @@\n+fn main() {\n+    // foo must be used.\n+    foo();\n+}\n+\n+// For this test to operate correctly, foo's body must start on exactly the same\n+// line and column and have the exact same length in bytes in a.rs and b.rs. In\n+// a.rs, the body must end on a line number which does not exist in b.rs.\n+// Basically, avoid modifying this file, including adding or removing whitespace!\n+fn foo() {\n+    assert_eq!(1, 1);\n+\n+\n+\n+\n+}"}, {"sha": "a272e44a6326fb761bbf452556f1cb5592eff840", "filename": "src/test/run-make/incr-prev-body-beyond-eof/b.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9722952f0bed5815cb22cb4878be09fb39f92804/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9722952f0bed5815cb22cb4878be09fb39f92804/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fincr-prev-body-beyond-eof%2Fb.rs?ref=9722952f0bed5815cb22cb4878be09fb39f92804", "patch": "@@ -0,0 +1,12 @@\n+fn main() {\n+    // foo must be used.\n+    foo();\n+}\n+\n+// For this test to operate correctly, foo's body must start on exactly the same\n+// line and column and have the exact same length in bytes in a.rs and b.rs. In\n+// a.rs, the body must end on a line number which does not exist in b.rs.\n+// Basically, avoid modifying this file, including adding or removing whitespace!\n+fn foo() {\n+    assert_eq!(1, 1);////\n+}"}, {"sha": "b0e8451ff5d0174f34628f9de924b8ec6cd22bab", "filename": "src/test/run-make/issue-36710/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9722952f0bed5815cb22cb4878be09fb39f92804/src%2Ftest%2Frun-make%2Fissue-36710%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9722952f0bed5815cb22cb4878be09fb39f92804/src%2Ftest%2Frun-make%2Fissue-36710%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-36710%2FMakefile?ref=9722952f0bed5815cb22cb4878be09fb39f92804", "patch": "@@ -1,5 +1,6 @@\n include ../../run-make-fulldeps/tools.mk\n \n+# FIXME https://github.com/rust-lang/rust/issues/78911\n # ignore-32bit wrong/no cross compiler and sometimes we pass wrong gcc args (-m64)\n \n all: foo"}]}