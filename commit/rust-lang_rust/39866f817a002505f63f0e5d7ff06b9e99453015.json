{"sha": "39866f817a002505f63f0e5d7ff06b9e99453015", "node_id": "C_kwDOAAsO6NoAKDM5ODY2ZjgxN2EwMDI1MDVmNjNmMGU1ZDdmZjA2YjllOTk0NTMwMTU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-17T14:32:03Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-17T14:35:19Z"}, "message": "remove a fastpath that does not seem to actually help", "tree": {"sha": "c7d5497aec0c83ee5830a7cc7d031181100da148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7d5497aec0c83ee5830a7cc7d031181100da148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39866f817a002505f63f0e5d7ff06b9e99453015", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39866f817a002505f63f0e5d7ff06b9e99453015", "html_url": "https://github.com/rust-lang/rust/commit/39866f817a002505f63f0e5d7ff06b9e99453015", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39866f817a002505f63f0e5d7ff06b9e99453015/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68510600a3f8f69fab24bbb256918b4fe46ba639", "url": "https://api.github.com/repos/rust-lang/rust/commits/68510600a3f8f69fab24bbb256918b4fe46ba639", "html_url": "https://github.com/rust-lang/rust/commit/68510600a3f8f69fab24bbb256918b4fe46ba639"}], "stats": {"total": 77, "additions": 31, "deletions": 46}, "files": [{"sha": "9040d03632ed9051f41f7afc996d540f83a945df", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 31, "deletions": 46, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/39866f817a002505f63f0e5d7ff06b9e99453015/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39866f817a002505f63f0e5d7ff06b9e99453015/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=39866f817a002505f63f0e5d7ff06b9e99453015", "patch": "@@ -1021,6 +1021,10 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        let retag_fields = this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields;\n+        let mut visitor = RetagVisitor { ecx: this, kind, retag_fields };\n+        return visitor.visit_value(place);\n+\n         // Determine mutability and whether to add a protector.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n         // making it useless.\n@@ -1043,46 +1047,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n \n-        // For some types we can do the work without starting up the visitor infrastructure.\n-        if let Some((ref_kind, protector)) = qualify(place.layout.ty, kind) {\n-            let val = this.read_immediate(&this.place_to_op(place)?)?;\n-            let val = this.retag_reference(&val, ref_kind, protector)?;\n-            this.write_immediate(*val, place)?;\n-            return Ok(());\n-        }\n-\n-        // If we don't want to recurse, we are already done.\n-        // EXCEPT if this is a `Box`, then we have to recurse because allocators.\n-        // (Yes this means we technically also recursively retag the allocator itself even if field\n-        // retagging is not enabled. *shrug*)\n-        if !this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields\n-            && !place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n-        {\n-            return Ok(());\n-        }\n-\n-        // Skip some types that have no further structure we might care about.\n-        if matches!(\n-            place.layout.ty.kind(),\n-            ty::RawPtr(..)\n-                | ty::Ref(..)\n-                | ty::Int(..)\n-                | ty::Uint(..)\n-                | ty::Float(..)\n-                | ty::Bool\n-                | ty::Char\n-        ) {\n-            return Ok(());\n-        }\n-\n-        // Now go visit this thing.\n-        let mut visitor = RetagVisitor { ecx: this, kind };\n-        return visitor.visit_value(place);\n-\n         // The actual visitor.\n         struct RetagVisitor<'ecx, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriEvalContext<'mir, 'tcx>,\n             kind: RetagKind,\n+            retag_fields: bool,\n+        }\n+        impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n+            #[inline(always)] // yes this helps in our benchmarks\n+            fn retag_place(\n+                &mut self,\n+                place: &PlaceTy<'tcx, Tag>,\n+                ref_kind: RefKind,\n+                protector: bool,\n+            ) -> InterpResult<'tcx> {\n+                let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n+                let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n+                self.ecx.write_immediate(*val, place)?;\n+                Ok(())\n+            }\n         }\n         impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n             for RetagVisitor<'ecx, 'mir, 'tcx>\n@@ -1097,26 +1080,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 // Boxes do not get a protector: protectors reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n-                let (ref_kind, protector) = (RefKind::Unique { two_phase: false }, false);\n-                let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n-                let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n-                self.ecx.write_immediate(*val, place)?;\n-                Ok(())\n+                self.retag_place(\n+                    place,\n+                    RefKind::Unique { two_phase: false },\n+                    /*protector*/ false,\n+                )\n             }\n \n             fn visit_value(&mut self, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n-                    let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n-                    let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n-                    self.ecx.write_immediate(*val, place)?;\n+                    self.retag_place(place, ref_kind, protector)?;\n                 } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n                     // Wide raw pointers *do* have fields and their types are strange.\n                     // vtables have a type like `&[*const (); 3]` or so!\n                     // Do *not* recurse into them.\n                     // (No need to worry about wide references, those always \"qualify\". And Boxes\n                     // are handles specially by the visitor anyway.)\n-                } else {\n-                    // Recurse deeper.\n+                } else if self.retag_fields\n+                    || place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n+                {\n+                    // Recurse deeper. Need to always recurse for `Box` to even hit `visit_box`.\n+                    // (Yes this means we technically also recursively retag the allocator itself\n+                    // even if field retagging is not enabled. *shrug*)\n                     self.walk_value(place)?;\n                 }\n                 Ok(())"}]}