{"sha": "b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YjE3YTU0Y2YxZjZkMjE2ZDgzYzU2NzljZjlkNzk1MTY1NmUzNmM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-26T03:37:20Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-26T03:37:20Z"}, "message": "Rollup merge of #32131 - petrochenkov:prim, r=eddyb\n\nresolve: Minimize hacks in name resolution of primitive types\n\nWhen resolving the first unqualified segment in a path with `n` segments and `n - 1` associated item segments, e.g. (`a` or `a::assoc` or `a::assoc::assoc` etc) try to resolve `a` without considering primitive types first. If the \"normal\" lookup fails or results in a module, then try to resolve `a` as a primitive type as a fallback.\n\nThis way backward compatibility is respected, but the restriction from E0317 can be lifted, i.e. primitive names mostly can be shadowed like any other names.\n\nFurthermore, if names of primitive types are [put into prelude](https://github.com/petrochenkov/rust/tree/prim2) (now it's possible to do), then most of names will be resolved in conventional way and amount of code relying on this fallback will be greatly reduced. Although, it's not entirely convenient to put them into prelude right now due to temporary conflicts like `use prelude::v1::*; use usize;` in libcore/libstd, I'd better wait for proper glob shadowing before doing it.\nI wish the `no_prelude` attribute were unstable as intended :(\n\ncc @jseyfried @arielb1\nr? @eddyb", "tree": {"sha": "dd0b177ccc15012c68f7ecc0945e559c6d0d8f9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd0b177ccc15012c68f7ecc0945e559c6d0d8f9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "html_url": "https://github.com/rust-lang/rust/commit/b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8b17a54cf1f6d216d83c5679cf9d7951656e36c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d2d2be6c61c17da8027a72da91f87a0e2487f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2d2be6c61c17da8027a72da91f87a0e2487f74", "html_url": "https://github.com/rust-lang/rust/commit/8d2d2be6c61c17da8027a72da91f87a0e2487f74"}, {"sha": "b418cd23068b1074e78d8631aec923b865bcc583", "url": "https://api.github.com/repos/rust-lang/rust/commits/b418cd23068b1074e78d8631aec923b865bcc583", "html_url": "https://github.com/rust-lang/rust/commit/b418cd23068b1074e78d8631aec923b865bcc583"}], "stats": {"total": 179, "additions": 66, "deletions": 113}, "files": [{"sha": "8a196768ae5168ea178c4c7f1f511b787474c0c7", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b8b17a54cf1f6d216d83c5679cf9d7951656e36c/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b17a54cf1f6d216d83c5679cf9d7951656e36c/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "patch": "@@ -205,51 +205,6 @@ about what constitutes an Item declaration and what does not:\n https://doc.rust-lang.org/reference.html#statements\n \"##,\n \n-E0317: r##\"\n-User-defined types or type parameters cannot shadow the primitive types.\n-This error indicates you tried to define a type, struct or enum with the same\n-name as an existing primitive type:\n-\n-```compile_fail\n-struct u8 {\n-    // ...\n-}\n-```\n-\n-To fix this, simply name it something else.\n-\n-Such an error may also occur if you define a type parameter which shadows a\n-primitive type. An example would be something like:\n-\n-```compile_fail\n-impl<u8> MyTrait for Option<u8> {\n-    // ...\n-}\n-```\n-\n-In such a case, if you meant for `u8` to be a generic type parameter (i.e. any\n-type can be used in its place), use something like `T` instead:\n-\n-```ignore\n-impl<T> MyTrait for Option<T> {\n-    // ...\n-}\n-```\n-\n-On the other hand, if you wished to refer to the specific type `u8`, remove it\n-from the type parameter list:\n-\n-```ignore\n-impl MyTrait for Option<u8> {\n-    // ...\n-}\n-\n-See the Types section of the reference for more information about the primitive\n-types:\n-\n-https://doc.rust-lang.org/reference.html#types\n-\"##,\n-\n E0364: r##\"\n Private items cannot be publicly re-exported.  This error indicates that you\n attempted to `pub use` a type or value that was not itself public."}, {"sha": "ab1d708f952ef02f57c6956746805575391abe81", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 30, "deletions": 55, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b8b17a54cf1f6d216d83c5679cf9d7951656e36c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b17a54cf1f6d216d83c5679cf9d7951656e36c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "patch": "@@ -1619,15 +1619,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         intravisit::walk_crate(self, krate);\n     }\n \n-    fn check_if_primitive_type_name(&self, name: Name, span: Span) {\n-        if let Some(_) = self.primitive_type_table.primitive_types.get(&name) {\n-            span_err!(self.session,\n-                      span,\n-                      E0317,\n-                      \"user-defined types or type parameters cannot shadow the primitive types\");\n-        }\n-    }\n-\n     fn resolve_item(&mut self, item: &Item) {\n         let name = item.name;\n \n@@ -1637,8 +1628,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemEnum(_, ref generics) |\n             ItemTy(_, ref generics) |\n             ItemStruct(_, ref generics) => {\n-                self.check_if_primitive_type_name(name, item.span);\n-\n                 self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n                                              |this| intravisit::walk_item(this, item));\n             }\n@@ -1659,8 +1648,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n-                self.check_if_primitive_type_name(name, item.span);\n-\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                TypeSpace,\n@@ -1695,8 +1682,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     });\n                                 }\n                                 hir::TypeTraitItem(..) => {\n-                                    this.check_if_primitive_type_name(trait_item.name,\n-                                                                      trait_item.span);\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n                                         intravisit::walk_trait_item(this, trait_item)\n                                     });\n@@ -1720,28 +1705,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             ItemUse(ref view_path) => {\n-                // check for imports shadowing primitive types\n-                let check_rename = |this: &Self, id, name| {\n-                    match this.def_map.borrow().get(&id).map(|d| d.full_def()) {\n-                        Some(Def::Enum(..)) | Some(Def::TyAlias(..)) | Some(Def::Struct(..)) |\n-                        Some(Def::Trait(..)) | None => {\n-                            this.check_if_primitive_type_name(name, item.span);\n-                        }\n-                        _ => {}\n-                    }\n-                };\n-\n                 match view_path.node {\n-                    hir::ViewPathSimple(name, _) => {\n-                        check_rename(self, item.id, name);\n-                    }\n                     hir::ViewPathList(ref prefix, ref items) => {\n-                        for item in items {\n-                            if let Some(name) = item.node.rename() {\n-                                check_rename(self, item.node.id(), name);\n-                            }\n-                        }\n-\n                         // Resolve prefix of an import with empty braces (issue #28388)\n                         if items.is_empty() && !prefix.segments.is_empty() {\n                             match self.resolve_crate_relative_path(prefix.span,\n@@ -1922,9 +1887,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_generics(&mut self, generics: &Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n-            self.check_if_primitive_type_name(type_parameter.name, type_parameter.span);\n-        }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &hir::WherePredicate::BoundPredicate(_) |\n@@ -2658,15 +2620,37 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Try to find a path to an item in a module.\n         let last_ident = segments.last().unwrap().identifier;\n-        if segments.len() <= 1 {\n-            let unqualified_def = self.resolve_identifier(last_ident, namespace, true);\n-            return unqualified_def.and_then(|def| self.adjust_local_def(def, span))\n-                                  .map(|def| {\n-                                      PathResolution::new(def, path_depth)\n-                                  });\n-        }\n+        // Resolve a single identifier with fallback to primitive types\n+        let resolve_identifier_with_fallback = |this: &mut Self, record_used| {\n+            let def = this.resolve_identifier(last_ident, namespace, record_used);\n+            match def {\n+                None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS =>\n+                    this.primitive_type_table\n+                        .primitive_types\n+                        .get(&last_ident.unhygienic_name)\n+                        .map_or(def, |prim_ty| Some(LocalDef::from_def(Def::PrimTy(*prim_ty)))),\n+                _ => def\n+            }\n+        };\n \n-        let unqualified_def = self.resolve_identifier(last_ident, namespace, false);\n+        if segments.len() == 1 {\n+            // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n+            // don't report an error right away, but try to fallback to a primitive type.\n+            // So, we are still able to successfully resolve something like\n+            //\n+            // use std::u8; // bring module u8 in scope\n+            // fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n+            //     u8::max_value() // OK, resolves to associated function <u8>::max_value,\n+            //                     // not to non-existent std::u8::max_value\n+            // }\n+            //\n+            // Such behavior is required for backward compatibility.\n+            // The same fallback is used when `a` resolves to nothing.\n+            let unqualified_def = resolve_identifier_with_fallback(self, true);\n+            return unqualified_def.and_then(|def| self.adjust_local_def(def, span)).map(mk_res);\n+        }\n+\n+        let unqualified_def = resolve_identifier_with_fallback(self, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n             (Some(d), Some(ref ud)) if d == ud.def => {\n@@ -2692,15 +2676,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n-        // First, check to see whether the name is a primitive type.\n-        if namespace == TypeNS {\n-            if let Some(&prim_ty) = self.primitive_type_table\n-                                        .primitive_types\n-                                        .get(&identifier.unhygienic_name) {\n-                return Some(LocalDef::from_def(Def::PrimTy(prim_ty)));\n-            }\n-        }\n-\n         self.resolve_identifier_in_local_ribs(identifier, namespace, record_used)\n     }\n "}, {"sha": "dd3d952224c057edcb1070ba5ca5f0c96bde6867", "filename": "src/test/run-pass/issue-20427.rs", "status": "renamed", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b8b17a54cf1f6d216d83c5679cf9d7951656e36c/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b17a54cf1f6d216d83c5679cf9d7951656e36c/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20427.rs?ref=b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,17 +9,17 @@\n // except according to those terms.\n \n // aux-build:i8.rs\n+// ignore-pretty (#23623)\n+\n extern crate i8;\n use std::string as i16;\n static i32: i32 = 0;\n const i64: i64 = 0;\n fn u8(f32: f32) {}\n fn f<f64>(f64: f64) {}\n-//~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n-type u16 = u16; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-enum u32 {} //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-struct u64; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-trait bool {} //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n+enum u32 {}\n+struct u64;\n+trait bool {}\n \n mod char {\n     extern crate i8;\n@@ -40,29 +40,52 @@ mod char {\n         use super::u8_ as u8;\n         use super::f_ as f64;\n         use super::u16_ as u16;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::u32_ as u32;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::u64_ as u64;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::bool_ as bool;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::{bool_ as str};\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::char_ as char;\n     }\n }\n \n trait isize_ {\n-    type isize; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n+    type isize;\n }\n \n fn usize<'usize>(usize: &'usize usize) -> &'usize usize { usize }\n \n+mod reuse {\n+    use std::mem::size_of;\n+\n+    type u8 = u64;\n+    use std::string::String as i16;\n+\n+    pub fn check<u16>() {\n+        assert_eq!(size_of::<u8>(), 8);\n+        assert_eq!(size_of::<::u64>(), 0);\n+        assert_eq!(size_of::<i16>(), 3 * size_of::<*const ()>());\n+        assert_eq!(size_of::<u16>(), 0);\n+    }\n+}\n+\n+mod guard {\n+    pub fn check() {\n+        use std::u8; // bring module u8 in scope\n+        fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n+            u8::max_value() // OK, resolves to associated function <u8>::max_value,\n+                            // not to non-existent std::u8::max_value\n+        }\n+        assert_eq!(f(), u8::MAX); // OK, resolves to std::u8::MAX\n+    }\n+}\n+\n fn main() {\n     let bool = true;\n-    match bool {\n+    let _ = match bool {\n         str @ true => if str { i32 as i64 } else { i64 },\n         false => i64,\n     };\n+\n+    reuse::check::<u64>();\n+    guard::check();\n }", "previous_filename": "src/test/compile-fail/issue-20427.rs"}]}