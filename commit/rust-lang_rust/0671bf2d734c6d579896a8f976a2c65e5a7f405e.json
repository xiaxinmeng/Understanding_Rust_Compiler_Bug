{"sha": "0671bf2d734c6d579896a8f976a2c65e5a7f405e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NzFiZjJkNzM0YzZkNTc5ODk2YThmOTc2YTJjNjVlNWE3ZjQwNWU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-30T16:11:46Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-30T17:09:17Z"}, "message": "Fix MergingBehaviour::Last not working properly", "tree": {"sha": "5355f982aa2c2386672e21824d38227d74d4dfb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5355f982aa2c2386672e21824d38227d74d4dfb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0671bf2d734c6d579896a8f976a2c65e5a7f405e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0671bf2d734c6d579896a8f976a2c65e5a7f405e", "html_url": "https://github.com/rust-lang/rust/commit/0671bf2d734c6d579896a8f976a2c65e5a7f405e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0671bf2d734c6d579896a8f976a2c65e5a7f405e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c9ae771bca39d511a0ea7395da2b4b91b44ee12", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9ae771bca39d511a0ea7395da2b4b91b44ee12", "html_url": "https://github.com/rust-lang/rust/commit/7c9ae771bca39d511a0ea7395da2b4b91b44ee12"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "8dd4fe607490d708387afc03fc9e2f2a42f57795", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0671bf2d734c6d579896a8f976a2c65e5a7f405e/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0671bf2d734c6d579896a8f976a2c65e5a7f405e/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=0671bf2d734c6d579896a8f976a2c65e5a7f405e", "patch": "@@ -174,28 +174,30 @@ pub(crate) fn try_merge_trees(\n     let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n     let lhs = lhs.split_prefix(&lhs_prefix);\n     let rhs = rhs.split_prefix(&rhs_prefix);\n-    recursive_merge(&lhs, &rhs, merge).map(|(merged, _)| merged)\n+    recursive_merge(&lhs, &rhs, merge)\n }\n \n /// Recursively \"zips\" together lhs and rhs.\n fn recursive_merge(\n     lhs: &ast::UseTree,\n     rhs: &ast::UseTree,\n     merge: MergeBehaviour,\n-) -> Option<(ast::UseTree, bool)> {\n+) -> Option<ast::UseTree> {\n     let mut use_trees = lhs\n         .use_tree_list()\n         .into_iter()\n         .flat_map(|list| list.use_trees())\n-        // check if any of the use trees are nested, if they are and the behaviour is `last` we are not allowed to merge this\n-        // so early exit the iterator by using Option's Intoiterator impl\n-        .map(|tree| match merge == MergeBehaviour::Last && tree.use_tree_list().is_some() {\n-            true => None,\n-            false => Some(tree),\n+        // we use Option here to early return from this function(this is not the same as a `filter` op)\n+        .map(|tree| match merge.is_tree_allowed(&tree) {\n+            true => Some(tree),\n+            false => None,\n         })\n         .collect::<Option<Vec<_>>>()?;\n     use_trees.sort_unstable_by(|a, b| path_cmp_opt(a.path(), b.path()));\n     for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n+        if !merge.is_tree_allowed(&rhs_t) {\n+            return None;\n+        }\n         let rhs_path = rhs_t.path();\n         match use_trees.binary_search_by(|p| path_cmp_opt(p.path(), rhs_path.clone())) {\n             Ok(idx) => {\n@@ -239,17 +241,9 @@ fn recursive_merge(\n                 }\n                 let lhs = lhs_t.split_prefix(&lhs_prefix);\n                 let rhs = rhs_t.split_prefix(&rhs_prefix);\n-                let this_has_children = use_trees.len() > 0;\n                 match recursive_merge(&lhs, &rhs, merge) {\n-                    Some((_, has_multiple_children))\n-                        if merge == MergeBehaviour::Last\n-                            && this_has_children\n-                            && has_multiple_children =>\n-                    {\n-                        return None\n-                    }\n-                    Some((use_tree, _)) => use_trees[idx] = use_tree,\n-                    None => use_trees.insert(idx, rhs_t),\n+                    Some(use_tree) => use_trees[idx] = use_tree,\n+                    None => return None,\n                 }\n             }\n             Err(_)\n@@ -264,8 +258,7 @@ fn recursive_merge(\n             }\n         }\n     }\n-    let has_multiple_children = use_trees.len() > 1;\n-    Some((lhs.with_use_tree_list(make::use_tree_list(use_trees)), has_multiple_children))\n+    Some(lhs.with_use_tree_list(make::use_tree_list(use_trees)))\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both.\n@@ -308,6 +301,10 @@ fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Cl\n     successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n }\n \n+fn path_len(path: ast::Path) -> usize {\n+    segment_iter(&path).count()\n+}\n+\n /// Orders paths in the following way:\n /// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n // FIXME: rustfmt sort lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n@@ -352,6 +349,19 @@ pub enum MergeBehaviour {\n     Last,\n }\n \n+impl MergeBehaviour {\n+    #[inline]\n+    fn is_tree_allowed(&self, tree: &ast::UseTree) -> bool {\n+        match self {\n+            MergeBehaviour::Full => true,\n+            // only simple single segment paths are allowed\n+            MergeBehaviour::Last => {\n+                tree.use_tree_list().is_none() && tree.path().map(path_len) <= Some(1)\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Eq, PartialEq, PartialOrd, Ord)]\n enum ImportGroup {\n     // the order here defines the order of new group inserts\n@@ -675,6 +685,11 @@ use std::io;\",\n         )\n     }\n \n+    #[test]\n+    fn merge_last_into_self() {\n+        check_last(\"foo::bar::baz\", r\"use foo::bar;\", r\"use foo::bar::{self, baz};\");\n+    }\n+\n     #[test]\n     fn merge_groups_full() {\n         check_full(\n@@ -819,8 +834,24 @@ use std::io;\",\n     }\n \n     #[test]\n-    fn merge_last_too_long() {\n-        check_last(\"foo::bar\", r\"use foo::bar::baz::Qux;\", r\"use foo::bar::{self, baz::Qux};\");\n+    fn skip_merge_last_too_long() {\n+        check_last(\n+            \"foo::bar\",\n+            r\"use foo::bar::baz::Qux;\",\n+            r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore] // FIXME: Order changes when switching lhs and rhs\n+    fn skip_merge_last_too_long2() {\n+        check_last(\n+            \"foo::bar::baz::Qux\",\n+            r\"use foo::bar;\",\n+            r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n+        );\n     }\n \n     #[test]"}]}