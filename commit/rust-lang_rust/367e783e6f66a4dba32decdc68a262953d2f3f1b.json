{"sha": "367e783e6f66a4dba32decdc68a262953d2f3f1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2N2U3ODNlNmY2NmE0ZGJhMzJkZWNkYzY4YTI2Mjk1M2QyZjNmMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-06T12:41:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-06T12:41:30Z"}, "message": "Auto merge of #56557 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #56315 (Rustdoc inline macro reexport)\n - #56332 ([rustdoc] Specific crate search)\n - #56362 (Stabilise exhaustive integer patterns)\n - #56426 (libsyntax_pos: A few tweaks)\n - #56441 (rustbuild: Fix issues with compiler docs)\n - #56446 (pass the parameter environment to `traits::find_associated_item`)\n - #56500 (cleanup: remove static lifetimes from consts)\n - #56525 (Avoid extra copy and syscall in std::env::current_exe)\n - #56528 (Remove unused dependency (rustc_lint -> rustc_mir))\n - #56548 (Optimized string FromIterator + Extend impls)\n - #56553 (Don't print the profiling summary to stdout when -Zprofile-json is set)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "cda4764d303feb6c62218550fb619c73a2eebdc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cda4764d303feb6c62218550fb619c73a2eebdc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/367e783e6f66a4dba32decdc68a262953d2f3f1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/367e783e6f66a4dba32decdc68a262953d2f3f1b", "html_url": "https://github.com/rust-lang/rust/commit/367e783e6f66a4dba32decdc68a262953d2f3f1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/367e783e6f66a4dba32decdc68a262953d2f3f1b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "128a1fa4e1f85e04f522653bb9bee83ed6523440", "url": "https://api.github.com/repos/rust-lang/rust/commits/128a1fa4e1f85e04f522653bb9bee83ed6523440", "html_url": "https://github.com/rust-lang/rust/commit/128a1fa4e1f85e04f522653bb9bee83ed6523440"}, {"sha": "cd1ee5edbd080659f1ff353dd828bdf9749cf11d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1ee5edbd080659f1ff353dd828bdf9749cf11d", "html_url": "https://github.com/rust-lang/rust/commit/cd1ee5edbd080659f1ff353dd828bdf9749cf11d"}], "stats": {"total": 1100, "additions": 700, "deletions": 400}, "files": [{"sha": "02c63200a28c3c3ecceb2d55ae722e736bdc1440", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -2352,7 +2352,6 @@ dependencies = [\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n- \"rustc_mir 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "e9c27a3f3cf31f9fec8835fbcc2489ee05ea8efe", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -697,9 +697,6 @@ impl Step for Rustc {\n             return;\n         }\n \n-        // Build libstd docs so that we generate relative links.\n-        builder.ensure(Std { stage, target });\n-\n         // Build rustc.\n         builder.ensure(compile::Rustc { compiler, target });\n \n@@ -718,12 +715,16 @@ impl Step for Rustc {\n \n         // Find dependencies for top level crates.\n         let mut compiler_crates = HashSet::new();\n-        for root_crate in &[\"rustc\", \"rustc_driver\", \"rustc_codegen_llvm\"] {\n+        for root_crate in &[\"rustc_driver\", \"rustc_codegen_llvm\", \"rustc_codegen_ssa\"] {\n             let interned_root_crate = INTERNER.intern_str(root_crate);\n             find_compiler_crates(builder, &interned_root_crate, &mut compiler_crates);\n         }\n \n         for krate in &compiler_crates {\n+            // Create all crate output directories first to make sure rustdoc uses\n+            // relative links.\n+            // FIXME: Cargo should probably do this itself.\n+            t!(fs::create_dir_all(out_dir.join(krate)));\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n@@ -797,8 +798,8 @@ impl Step for Rustdoc {\n             return;\n         }\n \n-        // Build libstd docs so that we generate relative links.\n-        builder.ensure(Std { stage, target });\n+        // Build rustc docs so that we generate relative links.\n+        builder.ensure(Rustc { stage, target });\n \n         // Build rustdoc.\n         builder.ensure(tool::Rustdoc { host: compiler.host });\n@@ -822,6 +823,10 @@ impl Step for Rustdoc {\n             &[]\n         );\n \n+        // Only include compiler crates, no dependencies of those, such as `libc`.\n+        cargo.arg(\"--no-deps\");\n+        cargo.arg(\"-p\").arg(\"rustdoc\");\n+\n         cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n         builder.run(&mut cargo);\n     }"}, {"sha": "8ea1cb26dc0c7f0239dac52fa1f67ef48165042d", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -741,14 +741,14 @@ fn_anon_params\n ;\n \n fn_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n | '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n | '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n | '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n ;\n \n fn_anon_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n | '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n | '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n | '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }"}, {"sha": "006c602649b74675af53e13a407db736bcb0128c", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -577,7 +577,7 @@ impl String {\n             return Cow::Borrowed(\"\");\n         };\n \n-        const REPLACEMENT: &'static str = \"\\u{FFFD}\";\n+        const REPLACEMENT: &str = \"\\u{FFFD}\";\n \n         let mut res = String::with_capacity(v.len());\n         res.push_str(first_valid);\n@@ -1732,18 +1732,37 @@ impl<'a> FromIterator<&'a str> for String {\n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl FromIterator<String> for String {\n     fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> String {\n-        let mut buf = String::new();\n-        buf.extend(iter);\n-        buf\n+        let mut iterator = iter.into_iter();\n+\n+        // Because we're iterating over `String`s, we can avoid at least\n+        // one allocation by getting the first string from the iterator\n+        // and appending to it all the subsequent strings.\n+        match iterator.next() {\n+            None => String::new(),\n+            Some(mut buf) => {\n+                buf.extend(iterator);\n+                buf\n+            }\n+        }\n     }\n }\n \n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> FromIterator<Cow<'a, str>> for String {\n     fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n-        let mut buf = String::new();\n-        buf.extend(iter);\n-        buf\n+        let mut iterator = iter.into_iter();\n+\n+        // Because we're iterating over CoWs, we can (potentially) avoid at least\n+        // one allocation by getting the first item and appending to it all the\n+        // subsequent items.\n+        match iterator.next() {\n+            None => String::new(),\n+            Some(cow) => {\n+                let mut buf = cow.into_owned();\n+                buf.extend(iterator);\n+                buf\n+            }\n+        }\n     }\n }\n \n@@ -1753,9 +1772,7 @@ impl Extend<char> for String {\n         let iterator = iter.into_iter();\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n-        for ch in iterator {\n-            self.push(ch)\n-        }\n+        iterator.for_each(move |c| self.push(c));\n     }\n }\n \n@@ -1769,27 +1786,21 @@ impl<'a> Extend<&'a char> for String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n-        for s in iter {\n-            self.push_str(s)\n-        }\n+        iter.into_iter().for_each(move |s| self.push_str(s));\n     }\n }\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n     fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n-        for s in iter {\n-            self.push_str(&s)\n-        }\n+        iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n }\n \n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> Extend<Cow<'a, str>> for String {\n     fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n-        for s in iter {\n-            self.push_str(&s)\n-        }\n+        iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n }\n "}, {"sha": "0c5256b981e5cc63d1cb9abc9d348b5b9f1c0162", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1381,7 +1381,7 @@ impl<'a> Formatter<'a> {\n         for part in formatted.parts {\n             match *part {\n                 flt2dec::Part::Zero(mut nzeroes) => {\n-                    const ZEROES: &'static str = // 64 zeroes\n+                    const ZEROES: &str = // 64 zeroes\n                         \"0000000000000000000000000000000000000000000000000000000000000000\";\n                     while nzeroes > ZEROES.len() {\n                         self.buf.write_str(ZEROES)?;"}, {"sha": "32e4b6b0fa512e7eb3618c56eeb52ebf06078df8", "filename": "src/libcore/unicode/printable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibcore%2Funicode%2Fprintable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibcore%2Funicode%2Fprintable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -80,7 +80,7 @@ pub(crate) fn is_printable(x: char) -> bool {\n     }\n }\n \n-const SINGLETONS0U: &'static [(u8, u8)] = &[\n+const SINGLETONS0U: &[(u8, u8)] = &[\n     (0x00, 1),\n     (0x03, 5),\n     (0x05, 6),\n@@ -122,7 +122,7 @@ const SINGLETONS0U: &'static [(u8, u8)] = &[\n     (0xfe, 3),\n     (0xff, 9),\n ];\n-const SINGLETONS0L: &'static [u8] = &[\n+const SINGLETONS0L: &[u8] = &[\n     0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n     0x58, 0x8b, 0x8c, 0x90, 0x1c, 0x1d, 0xdd, 0x0e,\n     0x0f, 0x4b, 0x4c, 0xfb, 0xfc, 0x2e, 0x2f, 0x3f,\n@@ -162,7 +162,7 @@ const SINGLETONS0L: &'static [u8] = &[\n     0x91, 0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9,\n     0xd0, 0xd1, 0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n ];\n-const SINGLETONS1U: &'static [(u8, u8)] = &[\n+const SINGLETONS1U: &[(u8, u8)] = &[\n     (0x00, 6),\n     (0x01, 1),\n     (0x03, 1),\n@@ -197,7 +197,7 @@ const SINGLETONS1U: &'static [(u8, u8)] = &[\n     (0xf0, 4),\n     (0xf9, 4),\n ];\n-const SINGLETONS1L: &'static [u8] = &[\n+const SINGLETONS1L: &[u8] = &[\n     0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n     0x9e, 0x9f, 0x06, 0x07, 0x09, 0x36, 0x3d, 0x3e,\n     0x56, 0xf3, 0xd0, 0xd1, 0x04, 0x14, 0x18, 0x36,\n@@ -219,7 +219,7 @@ const SINGLETONS1L: &'static [u8] = &[\n     0x78, 0x7d, 0x7f, 0x8a, 0xa4, 0xaa, 0xaf, 0xb0,\n     0xc0, 0xd0, 0x3f, 0x71, 0x72, 0x7b,\n ];\n-const NORMAL0: &'static [u8] = &[\n+const NORMAL0: &[u8] = &[\n     0x00, 0x20,\n     0x5f, 0x22,\n     0x82, 0xdf, 0x04,\n@@ -363,7 +363,7 @@ const NORMAL0: &'static [u8] = &[\n     0x1b, 0x03,\n     0x0f, 0x0d,\n ];\n-const NORMAL1: &'static [u8] = &[\n+const NORMAL1: &[u8] = &[\n     0x5e, 0x22,\n     0x7b, 0x05,\n     0x03, 0x04,"}, {"sha": "a20d04972fd75e3b6d6ded58ceda05a265ccbedb", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -381,7 +381,7 @@ macro_rules! define_dep_nodes {\n         #[allow(dead_code, non_upper_case_globals)]\n         pub mod label_strs {\n            $(\n-                pub const $variant: &'static str = stringify!($variant);\n+                pub const $variant: &str = stringify!($variant);\n             )*\n         }\n     );"}, {"sha": "a485af0a5eef9fa1a989f0d614660c81b4ba0868", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1201,7 +1201,7 @@ impl<'a> LoweringContext<'a> {\n                 None,\n                 P(hir::Path {\n                     def: self.expect_full_def(t.id),\n-                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfType.ident())],\n+                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfUpper.ident())],\n                     span: t.span,\n                 }),\n             )),\n@@ -2425,7 +2425,7 @@ impl<'a> LoweringContext<'a> {\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n                 // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-                let ident = if param.ident.name == keywords::SelfType.name() {\n+                let ident = if param.ident.name == keywords::SelfUpper.name() {\n                     param.ident.gensym()\n                 } else {\n                     param.ident\n@@ -2981,7 +2981,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // Correctly resolve `self` imports\n                 if path.segments.len() > 1\n-                    && path.segments.last().unwrap().ident.name == keywords::SelfValue.name()\n+                    && path.segments.last().unwrap().ident.name == keywords::SelfLower.name()\n                 {\n                     let _ = path.segments.pop();\n                     if rename.is_none() {"}, {"sha": "4ac07d78a26137f0d4003a639bdfefa5a8ce1d7d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -475,7 +475,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfType.name(),\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfUpper.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }"}, {"sha": "85bf257df237fa3052614cb9431e990ea726adbf", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -311,7 +311,7 @@ pub struct Path {\n \n impl Path {\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n     }\n }\n "}, {"sha": "484722f8c131bb04834367253caffa801b11a964", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -65,7 +65,7 @@ pub trait PpAnn {\n \n pub struct NoAnn;\n impl PpAnn for NoAnn {}\n-pub const NO_ANN: &'static dyn PpAnn = &NoAnn;\n+pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate {\n     fn try_fetch_item(&self, item: ast::NodeId) -> Option<&hir::Item> {\n@@ -1622,7 +1622,7 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n-            if segment.ident.name != keywords::CrateRoot.name() &&\n+            if segment.ident.name != keywords::PathRoot.name() &&\n                segment.ident.name != keywords::DollarCrate.name() {\n                self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n@@ -1636,7 +1636,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_path_segment(&mut self, segment: &hir::PathSegment) -> io::Result<()> {\n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n            segment.ident.name != keywords::DollarCrate.name() {\n            self.print_ident(segment.ident)?;\n            segment.with_generic_args(|generic_args| {\n@@ -1664,7 +1664,7 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         self.s.word(\"::\")?\n                     }\n-                    if segment.ident.name != keywords::CrateRoot.name() &&\n+                    if segment.ident.name != keywords::PathRoot.name() &&\n                        segment.ident.name != keywords::DollarCrate.name() {\n                         self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {"}, {"sha": "db643e4fd726ba5c07bbb7ae0ad9a081c8a03a83", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -134,14 +134,10 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     const_stability\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ::syntax::edition::Edition {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(enum ::syntax::edition::Edition {\n+    Edition2015,\n+    Edition2018,\n+});\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for ::syntax::attr::StabilityLevel {"}, {"sha": "fc2f1ee6ff892d4f241616e1afd05bf29c6fe083", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -24,15 +24,15 @@ mod impls_misc;\n mod impls_ty;\n mod impls_syntax;\n \n-pub const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n-pub const ATTR_CLEAN: &'static str = \"rustc_clean\";\n-pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n-pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n-pub const ATTR_PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n-pub const ATTR_PARTITION_CODEGENED: &'static str = \"rustc_partition_codegened\";\n-pub const ATTR_EXPECTED_CGU_REUSE: &'static str = \"rustc_expected_cgu_reuse\";\n+pub const ATTR_DIRTY: &str = \"rustc_dirty\";\n+pub const ATTR_CLEAN: &str = \"rustc_clean\";\n+pub const ATTR_IF_THIS_CHANGED: &str = \"rustc_if_this_changed\";\n+pub const ATTR_THEN_THIS_WOULD_NEED: &str = \"rustc_then_this_would_need\";\n+pub const ATTR_PARTITION_REUSED: &str = \"rustc_partition_reused\";\n+pub const ATTR_PARTITION_CODEGENED: &str = \"rustc_partition_codegened\";\n+pub const ATTR_EXPECTED_CGU_REUSE: &str = \"rustc_expected_cgu_reuse\";\n \n-pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n+pub const IGNORED_ATTRIBUTES: &[&str] = &[\n     \"cfg\",\n     ATTR_IF_THIS_CHANGED,\n     ATTR_THEN_THIS_WOULD_NEED,"}, {"sha": "b846a1c4930fbf4675537e55f4d7ce6c2db45a48", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1575,7 +1575,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self.\n-                if ident.name != keywords::SelfValue.name() {\n+                if ident.name != keywords::SelfLower.name() {\n                     if !self.warn_about_unused(sp, hir_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(hir_id, sp, var, true);"}, {"sha": "f1ddcda823ee799927825dccf0834ed610732af6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -780,43 +780,42 @@ macro_rules! options {\n     }\n \n     pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n-    pub const $stat: &'static [(&'static str, $setter_name,\n-                                Option<&'static str>, &'static str)] =\n+    pub const $stat: &[(&str, $setter_name, Option<&str>, &str)] =\n         &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n \n     #[allow(non_upper_case_globals, dead_code)]\n     mod $mod_desc {\n-        pub const parse_bool: Option<&'static str> = None;\n-        pub const parse_opt_bool: Option<&'static str> =\n+        pub const parse_bool: Option<&str> = None;\n+        pub const parse_opt_bool: Option<&str> =\n             Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n-        pub const parse_string: Option<&'static str> = Some(\"a string\");\n-        pub const parse_string_push: Option<&'static str> = Some(\"a string\");\n-        pub const parse_pathbuf_push: Option<&'static str> = Some(\"a path\");\n-        pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n-        pub const parse_opt_pathbuf: Option<&'static str> = Some(\"a path\");\n-        pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n-        pub const parse_opt_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n-        pub const parse_uint: Option<&'static str> = Some(\"a number\");\n-        pub const parse_passes: Option<&'static str> =\n+        pub const parse_string: Option<&str> = Some(\"a string\");\n+        pub const parse_string_push: Option<&str> = Some(\"a string\");\n+        pub const parse_pathbuf_push: Option<&str> = Some(\"a path\");\n+        pub const parse_opt_string: Option<&str> = Some(\"a string\");\n+        pub const parse_opt_pathbuf: Option<&str> = Some(\"a path\");\n+        pub const parse_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_uint: Option<&str> = Some(\"a number\");\n+        pub const parse_passes: Option<&str> =\n             Some(\"a space-separated list of passes, or `all`\");\n-        pub const parse_opt_uint: Option<&'static str> =\n+        pub const parse_opt_uint: Option<&str> =\n             Some(\"a number\");\n-        pub const parse_panic_strategy: Option<&'static str> =\n+        pub const parse_panic_strategy: Option<&str> =\n             Some(\"either `unwind` or `abort`\");\n-        pub const parse_relro_level: Option<&'static str> =\n+        pub const parse_relro_level: Option<&str> =\n             Some(\"one of: `full`, `partial`, or `off`\");\n-        pub const parse_sanitizer: Option<&'static str> =\n+        pub const parse_sanitizer: Option<&str> =\n             Some(\"one of: `address`, `leak`, `memory` or `thread`\");\n-        pub const parse_linker_flavor: Option<&'static str> =\n+        pub const parse_linker_flavor: Option<&str> =\n             Some(::rustc_target::spec::LinkerFlavor::one_of());\n-        pub const parse_optimization_fuel: Option<&'static str> =\n+        pub const parse_optimization_fuel: Option<&str> =\n             Some(\"crate=integer\");\n-        pub const parse_unpretty: Option<&'static str> =\n+        pub const parse_unpretty: Option<&str> =\n             Some(\"`string` or `string=string`\");\n-        pub const parse_lto: Option<&'static str> =\n+        pub const parse_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n                   `fat`, or omitted\");\n-        pub const parse_cross_lang_lto: Option<&'static str> =\n+        pub const parse_cross_lang_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n                   or the path to the linker plugin\");\n     }"}, {"sha": "e686a1d1275b61a079508a60fe73826b1b3adaf4", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -179,12 +179,12 @@ fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n     // \"lib\" (i.e. non-default), this value is used (see issue #16552).\n \n     #[cfg(target_pointer_width = \"64\")]\n-    const PRIMARY_LIB_DIR: &'static str = \"lib64\";\n+    const PRIMARY_LIB_DIR: &str = \"lib64\";\n \n     #[cfg(target_pointer_width = \"32\")]\n-    const PRIMARY_LIB_DIR: &'static str = \"lib32\";\n+    const PRIMARY_LIB_DIR: &str = \"lib32\";\n \n-    const SECONDARY_LIB_DIR: &'static str = \"lib\";\n+    const SECONDARY_LIB_DIR: &str = \"lib\";\n \n     match option_env!(\"CFG_LIBDIR_RELATIVE\") {\n         Some(libdir) if libdir != \"lib\" => libdir.into(),\n@@ -198,4 +198,4 @@ fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n \n // The name of rustc's own place to organize libraries.\n // Used to be \"rustc\", now the default is \"rustlib\"\n-const RUST_LIB_DIR: &'static str = \"rustlib\";\n+const RUST_LIB_DIR: &str = \"rustlib\";"}, {"sha": "293cd0c7c546df6df5eda807595ecc76ce26748d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -826,7 +826,7 @@ impl Session {\n     }\n \n     pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n-        if self.opts.debugging_opts.self_profile {\n+        if self.opts.debugging_opts.self_profile || self.opts.debugging_opts.profile_json {\n             let mut profiler = self.self_profiling.borrow_mut();\n             f(&mut profiler);\n         }"}, {"sha": "cb17246b15f11447c13bd41e79c3736dae80b181", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -85,6 +85,8 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                         source_substs: &'tcx Substs<'tcx>,\n                                         target_node: specialization_graph::Node)\n                                         -> &'tcx Substs<'tcx> {\n+    debug!(\"translate_substs({:?}, {:?}, {:?}, {:?})\",\n+           param_env, source_impl, source_substs, target_node);\n     let source_trait_ref = infcx.tcx\n                                 .impl_trait_ref(source_impl)\n                                 .unwrap()\n@@ -119,10 +121,13 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// whichever applies.\n pub fn find_associated_item<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     item: &ty::AssociatedItem,\n     substs: &'tcx Substs<'tcx>,\n     impl_data: &super::VtableImplData<'tcx, ()>,\n ) -> (DefId, &'tcx Substs<'tcx>) {\n+    debug!(\"find_associated_item({:?}, {:?}, {:?}, {:?})\",\n+           param_env, item, substs, impl_data);\n     assert!(!substs.needs_infer());\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n@@ -132,7 +137,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     match ancestors.defs(tcx, item.ident, item.kind, trait_def_id).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = ty::ParamEnv::reveal_all();\n+                let param_env = param_env.with_reveal_all();\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n                                               substs, node_item.node);\n@@ -219,12 +224,17 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        source_trait_ref: ty::TraitRef<'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n+    debug!(\"fulfill_implication({:?}, trait_ref={:?} |- {:?} applies)\",\n+           param_env, source_trait_ref, target_impl);\n+\n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                        param_env,\n                                                                        target_impl,\n                                                                        target_substs);\n+    debug!(\"fulfill_implication: target_trait_ref={:?}, obligations={:?}\",\n+           target_trait_ref, obligations);\n \n     // do the impls unify? If not, no specialization.\n     match infcx.at(&ObligationCause::dummy(), param_env)"}, {"sha": "36e93cc7740894fa522cd1a8cde196cff3f7f324", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -33,8 +33,8 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n         if ty::tls::with(|tcx| tcx.sess.verbose()) {\n             write!(\n                 f,\n-                \"Obligation(predicate={:?},cause={:?},depth={})\",\n-                self.predicate, self.cause, self.recursion_depth\n+                \"Obligation(predicate={:?},cause={:?},param_env={:?},depth={})\",\n+                self.predicate, self.cause, self.param_env, self.recursion_depth\n             )\n         } else {\n             write!("}, {"sha": "f041192413107b38845b019b857ee4390781529e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1493,12 +1493,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             BorrowckMode::Ast => match self.sess.edition() {\n                 Edition::Edition2015 => BorrowckMode::Ast,\n                 Edition::Edition2018 => BorrowckMode::Migrate,\n-\n-                // For now, future editions mean Migrate. (But it\n-                // would make a lot of sense for it to be changed to\n-                // `BorrowckMode::Mir`, depending on how we plan to\n-                // time the forcing of full migration to NLL.)\n-                _ => BorrowckMode::Migrate,\n             },\n         }\n     }\n@@ -2710,7 +2704,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, keywords::SelfType.name().as_interned_str())\n+        self.mk_ty_param(0, keywords::SelfUpper.name().as_interned_str())\n     }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {"}, {"sha": "a24920da158e2772f9b51c40785a2ce660c7fa34", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -347,9 +347,10 @@ fn resolve_associated_item<'a, 'tcx>(\n ) -> Option<Instance<'tcx>> {\n     let def_id = trait_item.def_id;\n     debug!(\"resolve_associated_item(trait_item={:?}, \\\n+            param_env={:?}, \\\n             trait_id={:?}, \\\n             rcvr_substs={:?})\",\n-           def_id, trait_id, rcvr_substs);\n+            def_id, param_env, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n     let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)));\n@@ -359,7 +360,7 @@ fn resolve_associated_item<'a, 'tcx>(\n     match vtbl {\n         traits::VtableImpl(impl_data) => {\n             let (def_id, substs) = traits::find_associated_item(\n-                tcx, trait_item, rcvr_substs, &impl_data);\n+                tcx, param_env, trait_item, rcvr_substs, &impl_data);\n             let substs = tcx.erase_regions(&substs);\n             Some(ty::Instance::new(def_id, substs))\n         }"}, {"sha": "d861fb367813ae51677d9f38b8d1f13d8510bcbc", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1020,7 +1020,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, keywords::SelfType.name().as_interned_str())\n+        ParamTy::new(0, keywords::SelfUpper.name().as_interned_str())\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n@@ -1035,7 +1035,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         // FIXME(#50125): Ignoring `Self` with `idx != 0` might lead to weird behavior elsewhere,\n         // but this should only be possible when using `-Z continue-parse-after-error` like\n         // `compile-fail/issue-36638.rs`.\n-        self.name == keywords::SelfType.name().as_str() && self.idx == 0\n+        self.name == keywords::SelfUpper.name().as_str() && self.idx == 0\n     }\n }\n \n@@ -1787,6 +1787,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn is_pointer_sized(&self) -> bool {\n+        match self.sty {\n+            Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n             Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => false,"}, {"sha": "c6ba20de0d3b900377fbd1fb87e1ba77770c5847", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -28,7 +28,7 @@ use lazy_static;\n use session::Session;\n \n // The name of the associated type for `Fn` return types\n-pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n+pub const FN_OUTPUT_NAME: &str = \"Output\";\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking."}, {"sha": "ecae6197dc7ca398da545b52342fe75ac03cc55f", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -225,7 +225,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // These are weak symbols that point to the profile version and the\n         // profile name, which need to be treated as exported so LTO doesn't nix\n         // them.\n-        const PROFILER_WEAK_SYMBOLS: [&'static str; 2] = [\n+        const PROFILER_WEAK_SYMBOLS: [&str; 2] = [\n             \"__llvm_profile_raw_version\",\n             \"__llvm_profile_filename\",\n         ];"}, {"sha": "611d7b137c6f277915f4c7cb107b390f71b2ebc9", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -389,7 +389,7 @@ impl SymbolPathBuffer {\n \n impl ItemPathBuffer for SymbolPathBuffer {\n     fn root_mode(&self) -> &RootMode {\n-        const ABSOLUTE: &'static RootMode = &RootMode::Absolute;\n+        const ABSOLUTE: &RootMode = &RootMode::Absolute;\n         ABSOLUTE\n     }\n "}, {"sha": "48014a9e1192ce4bf214244116e12c097b323e90", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -356,10 +356,10 @@ pub fn compile_input(\n \n     if sess.opts.debugging_opts.self_profile {\n         sess.print_profiler_results();\n+    }\n \n-        if sess.opts.debugging_opts.profile_json {\n-            sess.save_json_results();\n-        }\n+    if sess.opts.debugging_opts.profile_json {\n+        sess.save_json_results();\n     }\n \n     controller_entry_point!("}, {"sha": "17ac9a6b5397346d8fb8ce57d316e4c7f8799205", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -40,9 +40,9 @@ use syntax::ast;\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n                  ATTR_EXPECTED_CGU_REUSE};\n \n-const MODULE: &'static str = \"module\";\n-const CFG: &'static str = \"cfg\";\n-const KIND: &'static str = \"kind\";\n+const MODULE: &str = \"module\";\n+const CFG: &str = \"cfg\";\n+const KIND: &str = \"kind\";\n \n pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {"}, {"sha": "e5faba61782335f3ba61e084cb58032e91ba8358", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -28,15 +28,15 @@ use rustc::session::config::nightly_options;\n use rustc_serialize::opaque::Encoder;\n \n /// The first few bytes of files generated by incremental compilation\n-const FILE_MAGIC: &'static [u8] = b\"RSIC\";\n+const FILE_MAGIC: &[u8] = b\"RSIC\";\n \n /// Change this if the header format changes\n const HEADER_FORMAT_VERSION: u16 = 0;\n \n /// A version string that hopefully is always different for compiler versions\n /// with different encodings of incremental compilation artifacts. Contains\n /// the git commit hash.\n-const RUSTC_VERSION: Option<&'static str> = option_env!(\"CFG_VERSION\");\n+const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n \n pub fn write_file_header(stream: &mut Encoder) {\n     stream.emit_raw_bytes(FILE_MAGIC);"}, {"sha": "bc98798f77253e7ba37aa9a0694860d15d7b66b4", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -128,10 +128,10 @@ use std::time::{UNIX_EPOCH, SystemTime, Duration};\n \n use rand::{RngCore, thread_rng};\n \n-const LOCK_FILE_EXT: &'static str = \".lock\";\n-const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n-const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n-const QUERY_CACHE_FILENAME: &'static str = \"query-cache.bin\";\n+const LOCK_FILE_EXT: &str = \".lock\";\n+const DEP_GRAPH_FILENAME: &str = \"dep-graph.bin\";\n+const WORK_PRODUCTS_FILENAME: &str = \"work-products.bin\";\n+const QUERY_CACHE_FILENAME: &str = \"query-cache.bin\";\n \n // We encode integers using the following base, so they are shorter than decimal\n // or hexadecimal numbers (we want short file and directory names). Since these"}, {"sha": "7fb7a06ea1ad5fc1d1eee29090469a15c8c90fce", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -12,7 +12,6 @@ test = false\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n-rustc_mir = { path = \"../librustc_mir\"}\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "4d709d574c4f1fa2ab9acac14cff87a5bf2970cc", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -36,7 +36,6 @@ extern crate syntax;\n extern crate rustc;\n #[macro_use]\n extern crate log;\n-extern crate rustc_mir;\n extern crate rustc_target;\n extern crate syntax_pos;\n extern crate rustc_data_structures;"}, {"sha": "c7eb06cbe00535eebc180e7b58d97743a5d5f8ff", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -473,7 +473,7 @@ impl UnusedImportBraces {\n             match items[0].0.kind {\n                 ast::UseTreeKind::Simple(rename, ..) => {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n-                    if orig_ident.name == keywords::SelfValue.name() {\n+                    if orig_ident.name == keywords::SelfLower.name() {\n                         return;\n                     }\n                     node_ident = rename.unwrap_or(orig_ident);"}, {"sha": "fc3af6cf2e7320a248b9cb15211142bddf5f797f", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -52,7 +52,7 @@ pub const METADATA_VERSION: u8 = 4;\n /// This header is followed by the position of the `CrateRoot`,\n /// which is encoded as a 32-bit big-endian unsigned integer,\n /// and further followed by the rustc version string.\n-pub const METADATA_HEADER: &'static [u8; 12] =\n+pub const METADATA_HEADER: &[u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// A value of type T referred to by its absolute position"}, {"sha": "4bcabfef4fd7f41c59e06e26d0d961ec73ff5132", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             // Deliberately fall into this case for all implicit self types,\n                             // so that we don't fall in to the next case with them.\n                             *kind == mir::ImplicitSelfKind::MutRef\n-                        } else if Some(keywords::SelfValue.name()) == local_decl.name {\n+                        } else if Some(keywords::SelfLower.name()) == local_decl.name {\n                             // Otherwise, check if the name is the self kewyord - in which case\n                             // we have an explicit self. Do the same thing in this case and check\n                             // for a `self: &mut Self` to suggest removing the `&mut`."}, {"sha": "f6a9d46b5e2cbe2ace966bc2debde39f5f19a8d2", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -137,8 +137,8 @@ where MWF: MirWithFlowState<'tcx>,\n                                          block: BasicBlock,\n                                          mir: &Mir) -> io::Result<()> {\n         // Header rows\n-        const HDRS: [&'static str; 4] = [\"ENTRY\", \"MIR\", \"BLOCK GENS\", \"BLOCK KILLS\"];\n-        const HDR_FMT: &'static str = \"bgcolor=\\\"grey\\\"\";\n+        const HDRS: [&str; 4] = [\"ENTRY\", \"MIR\", \"BLOCK GENS\", \"BLOCK KILLS\"];\n+        const HDR_FMT: &str = \"bgcolor=\\\"grey\\\"\";\n         write!(w, \"<table><tr><td rowspan=\\\"{}\\\">\", HDRS.len())?;\n         write!(w, \"{:?}\", block.index())?;\n         write!(w, \"</td></tr><tr>\")?;"}, {"sha": "ec5617d705248cb8894ff54b1e3db328eddafe93", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -606,7 +606,7 @@ static X: i32 = 1;\n const C: i32 = 2;\n \n // these three are not allowed:\n-const CR: &'static mut i32 = &mut C;\n+const CR: &mut i32 = &mut C;\n static STATIC_REF: &'static mut i32 = &mut X;\n static CONST_REF: &'static mut i32 = &mut C;\n ```\n@@ -1163,18 +1163,18 @@ You can also have this error while using a cell type:\n use std::cell::Cell;\n \n const A: Cell<usize> = Cell::new(1);\n-const B: &'static Cell<usize> = &A;\n+const B: &Cell<usize> = &A;\n // error: cannot borrow a constant which may contain interior mutability,\n //        create a static instead\n \n // or:\n struct C { a: Cell<usize> }\n \n const D: C = C { a: Cell::new(1) };\n-const E: &'static Cell<usize> = &D.a; // error\n+const E: &Cell<usize> = &D.a; // error\n \n // or:\n-const F: &'static C = &D; // error\n+const F: &C = &D; // error\n ```\n \n This is because cell types do operations that are not thread-safe. Due to this,"}, {"sha": "5db7b6ceb5db56f263f75af4b161fd2131130836", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -584,7 +584,6 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   -> Vec<Constructor<'tcx>>\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n-    let exhaustive_integer_patterns = cx.tcx.features().exhaustive_integer_patterns;\n     let ctors = match pcx.ty.sty {\n         ty::Bool => {\n             [true, false].iter().map(|&b| {\n@@ -614,7 +613,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 .map(|v| Variant(v.did))\n                 .collect()\n         }\n-        ty::Char if exhaustive_integer_patterns => {\n+        ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n                 ConstantRange('\\u{0000}' as u128,\n@@ -629,14 +628,14 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 ),\n             ]\n         }\n-        ty::Int(ity) if exhaustive_integer_patterns => {\n+        ty::Int(ity) => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = (1u128 << (bits - 1)) - 1;\n             vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n         }\n-        ty::Uint(uty) if exhaustive_integer_patterns => {\n+        ty::Uint(uty) => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n             let max = !0u128 >> (128 - bits);\n@@ -775,8 +774,17 @@ impl<'tcx> IntRange<'tcx> {\n     fn from_ctor(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n                  ctor: &Constructor<'tcx>)\n                  -> Option<IntRange<'tcx>> {\n+        // Floating-point ranges are permitted and we don't want\n+        // to consider them when constructing integer ranges.\n+        fn is_integral<'tcx>(ty: Ty<'tcx>) -> bool {\n+            match ty.sty {\n+                ty::Char | ty::Int(_) | ty::Uint(_) => true,\n+                _ => false,\n+            }\n+        }\n+\n         match ctor {\n-            ConstantRange(lo, hi, ty, end) => {\n+            ConstantRange(lo, hi, ty, end) if is_integral(ty) => {\n                 // Perform a shift if the underlying types are signed,\n                 // which makes the interval arithmetic simpler.\n                 let bias = IntRange::signed_bias(tcx, ty);\n@@ -789,7 +797,7 @@ impl<'tcx> IntRange<'tcx> {\n                     Some(IntRange { range: lo..=(hi - offset), ty })\n                 }\n             }\n-            ConstantValue(val) => {\n+            ConstantValue(val) if is_integral(val.ty) => {\n                 let ty = val.ty;\n                 if let Some(val) = val.assert_bits(tcx, ty::ParamEnv::empty().and(ty)) {\n                     let bias = IntRange::signed_bias(tcx, ty);\n@@ -799,9 +807,7 @@ impl<'tcx> IntRange<'tcx> {\n                     None\n                 }\n             }\n-            Single | Variant(_) | Slice(_) => {\n-                None\n-            }\n+            _ => None,\n         }\n     }\n \n@@ -933,12 +939,10 @@ fn compute_missing_ctors<'a, 'tcx: 'a>(\n                 // If a constructor appears in a `match` arm, we can\n                 // eliminate it straight away.\n                 refined_ctors = vec![]\n-            } else if tcx.features().exhaustive_integer_patterns {\n-                if let Some(interval) = IntRange::from_ctor(tcx, used_ctor) {\n-                    // Refine the required constructors for the type by subtracting\n-                    // the range defined by the current constructor pattern.\n-                    refined_ctors = interval.subtract_from(tcx, refined_ctors);\n-                }\n+            } else if let Some(interval) = IntRange::from_ctor(tcx, used_ctor) {\n+                // Refine the required constructors for the type by subtracting\n+                // the range defined by the current constructor pattern.\n+                refined_ctors = interval.subtract_from(tcx, refined_ctors);\n             }\n \n             // If the constructor patterns that have been considered so far\n@@ -1094,7 +1098,8 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n         // `_` constructor for the type, so we can never match over all constructors.\n-        let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive;\n+        let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive ||\n+            (pcx.ty.is_pointer_sized() && !cx.tcx.features().precise_pointer_size_matching);\n \n         if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n             split_grouped_constructors(cx.tcx, all_ctors, matrix, pcx.ty).into_iter().map(|c| {\n@@ -1390,17 +1395,16 @@ fn slice_pat_covered_by_constructor<'tcx>(\n // Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n // constructor is a range or constant with an integer type.\n fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n-    if tcx.features().exhaustive_integer_patterns {\n-        let ty = match ctor {\n-            ConstantValue(value) => value.ty,\n-            ConstantRange(_, _, ty, _) => ty,\n-            _ => return false,\n-        };\n-        if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.sty {\n-            return true;\n-        }\n+    let ty = match ctor {\n+        ConstantValue(value) => value.ty,\n+        ConstantRange(_, _, ty, _) => ty,\n+        _ => return false,\n+    };\n+    if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.sty {\n+        !ty.is_pointer_sized() || tcx.features().precise_pointer_size_matching\n+    } else {\n+        false\n     }\n-    false\n }\n \n /// For exhaustive integer matching, some constructors are grouped within other constructors"}, {"sha": "2d7e7d01274f6ca4d034ef488e1fe164df702193", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -24,7 +24,7 @@ use std::path::{Path, PathBuf};\n use super::graphviz::write_mir_fn_graphviz;\n use transform::MirSource;\n \n-const INDENT: &'static str = \"    \";\n+const INDENT: &str = \"    \";\n /// Alignment for lining up comments following MIR statements\n pub(crate) const ALIGN: usize = 40;\n "}, {"sha": "4e773124c8dab77ce41b455fde140ddc0b548ed4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -145,15 +145,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n             _ => None,\n         }.map(|ctxt| Segment::from_ident(Ident::new(\n-            keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n+            keywords::PathRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n         )));\n \n         let prefix = crate_root.into_iter().chain(prefix_iter).collect::<Vec<_>>();\n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);\n \n         let empty_for_self = |prefix: &[Segment]| {\n             prefix.is_empty() ||\n-            prefix.len() == 1 && prefix[0].ident.name == keywords::CrateRoot.name()\n+            prefix.len() == 1 && prefix[0].ident.name == keywords::PathRoot.name()\n         };\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n@@ -164,7 +164,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 if nested {\n                     // Correctly handle `self`\n-                    if source.ident.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfLower.name() {\n                         type_ns_only = true;\n \n                         if empty_for_self(&module_path) {\n@@ -185,7 +185,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 } else {\n                     // Disallow `self`\n-                    if source.ident.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfLower.name() {\n                         resolve_error(self,\n                                       use_tree.span,\n                                       ResolutionError::SelfImportsOnlyAllowedWithin);\n@@ -205,7 +205,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             // `crate_name` should not be interpreted as relative.\n                             module_path.push(Segment {\n                                 ident: Ident {\n-                                    name: keywords::CrateRoot.name(),\n+                                    name: keywords::PathRoot.name(),\n                                     span: source.ident.span,\n                                 },\n                                 id: Some(self.session.next_node_id()),\n@@ -270,7 +270,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 // Ensure there is at most one `self` in the list\n                 let self_spans = items.iter().filter_map(|&(ref use_tree, _)| {\n                     if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n-                        if use_tree.ident().name == keywords::SelfValue.name() {\n+                        if use_tree.ident().name == keywords::SelfLower.name() {\n                             return Some(use_tree.span);\n                         }\n                     }\n@@ -305,7 +305,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     let new_span = prefix[prefix.len() - 1].ident.span;\n                     let tree = ast::UseTree {\n                         prefix: ast::Path::from_ident(\n-                            Ident::new(keywords::SelfValue.name(), new_span)\n+                            Ident::new(keywords::SelfLower.name(), new_span)\n                         ),\n                         kind: ast::UseTreeKind::Simple(\n                             Some(Ident::new(keywords::Underscore.name().gensymed(), new_span)),\n@@ -344,13 +344,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n \n             ItemKind::ExternCrate(orig_name) => {\n-                let module = if orig_name.is_none() && ident.name == keywords::SelfValue.name() {\n+                let module = if orig_name.is_none() && ident.name == keywords::SelfLower.name() {\n                     self.session\n                         .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                         .span_suggestion(item.span, \"try\", \"extern crate self as name;\".into())\n                         .emit();\n                     return;\n-                } else if orig_name == Some(keywords::SelfValue.name()) {\n+                } else if orig_name == Some(keywords::SelfLower.name()) {\n                     if !self.session.features_untracked().extern_crate_self {\n                         emit_feature_err(&self.session.parse_sess, \"extern_crate_self\", item.span,\n                                          GateIssue::Language, \"`extern crate self` is unstable\");\n@@ -783,7 +783,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.node {\n-                    if orig_name == keywords::SelfValue.name() {\n+                    if orig_name == keywords::SelfLower.name() {\n                         self.session.span_err(attr.span,\n                             \"`macro_use` is not supported on `extern crate self`\");\n                     }"}, {"sha": "23edaf12438121fd682389ae45f9ff7c741ca0f0", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         match (path.get(0), path.get(1)) {\n             // `{{root}}::ident::...` on both editions.\n             // On 2015 `{{root}}` is usually added implicitly.\n-            (Some(fst), Some(snd)) if fst.ident.name == keywords::CrateRoot.name() &&\n+            (Some(fst), Some(snd)) if fst.ident.name == keywords::PathRoot.name() &&\n                                       !snd.ident.is_path_segment_keyword() => {}\n             // `ident::...` on 2018\n             (Some(fst), _) if fst.ident.span.rust_2018() &&\n@@ -61,7 +61,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n-        path[0].ident.name = keywords::SelfValue.name();\n+        path[0].ident.name = keywords::SelfLower.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {"}, {"sha": "9ea39aea86867ea99455a352c1df7192f9492210", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -769,7 +769,7 @@ impl<'a, 'tcx, 'cl> Visitor<'tcx> for Resolver<'a, 'cl> {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }\n             TyKind::ImplicitSelf => {\n-                let self_ty = keywords::SelfType.ident();\n+                let self_ty = keywords::SelfUpper.ident();\n                 let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Def::Err, |d| d.def());\n                 self.record_def(ty.id, PathResolution::new(def));\n@@ -1679,7 +1679,7 @@ impl<'a, 'cl> hir::lowering::Resolver for Resolver<'a, 'cl> {\n         components: &[&str],\n         is_value: bool\n     ) -> hir::Path {\n-        let segments = iter::once(keywords::CrateRoot.ident())\n+        let segments = iter::once(keywords::PathRoot.ident())\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n@@ -1721,7 +1721,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n-                segments: iter::once(keywords::CrateRoot.ident())\n+                segments: iter::once(keywords::PathRoot.ident())\n                     .chain({\n                         path_str.split(\"::\").skip(1).map(Ident::from_str)\n                     })\n@@ -2036,7 +2036,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let record_used = record_used_id.is_some();\n         assert!(ns == TypeNS  || ns == ValueNS);\n         if ns == TypeNS {\n-            ident.span = if ident.name == keywords::SelfType.name() {\n+            ident.span = if ident.name == keywords::SelfUpper.name() {\n                 // FIXME(jseyfried) improve `Self` hygiene\n                 ident.span.with_ctxt(SyntaxContext::empty())\n             } else {\n@@ -2649,7 +2649,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n         self.ribs[TypeNS].pop();\n@@ -2660,7 +2660,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     {\n         let self_def = Def::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[ValueNS].push(self_type_rib);\n         f(self);\n         self.ribs[ValueNS].pop();\n@@ -3146,7 +3146,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 let item_span = path.last().unwrap().ident.span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n-                } else if path.len() == 2 && path[0].ident.name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].ident.name == keywords::PathRoot.name() {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -3515,13 +3515,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(),\n+        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfUpper.ident(),\n                                                           TypeNS, None, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n-        let ident = Ident::new(keywords::SelfValue.name(), self_span);\n+        let ident = Ident::new(keywords::SelfLower.name(), self_span);\n         let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n@@ -3673,7 +3673,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].ident.name != keywords::CrateRoot.name() &&\n+           path[0].ident.name != keywords::PathRoot.name() &&\n            path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path_without_parent_scope(\n@@ -3755,7 +3755,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let name = ident.name;\n \n             allow_super &= ns == TypeNS &&\n-                (name == keywords::SelfValue.name() ||\n+                (name == keywords::SelfLower.name() ||\n                  name == keywords::Super.name());\n \n             if ns == TypeNS {\n@@ -3779,24 +3779,24 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     return PathResult::Failed(ident.span, msg, false);\n                 }\n                 if i == 0 {\n-                    if name == keywords::SelfValue.name() {\n+                    if name == keywords::SelfLower.name() {\n                         let mut ctxt = ident.span.ctxt().modern();\n                         module = Some(ModuleOrUniformRoot::Module(\n                             self.resolve_self(&mut ctxt, self.current_module)));\n                         continue;\n                     }\n                     if name == keywords::Extern.name() ||\n-                       name == keywords::CrateRoot.name() && ident.span.rust_2018() {\n+                       name == keywords::PathRoot.name() && ident.span.rust_2018() {\n                         module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n-                    if name == keywords::CrateRoot.name() &&\n+                    if name == keywords::PathRoot.name() &&\n                        ident.span.rust_2015() && self.session.rust_2018() {\n                         // `::a::b` from 2015 macro on 2018 global edition\n                         module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n                         continue;\n                     }\n-                    if name == keywords::CrateRoot.name() ||\n+                    if name == keywords::PathRoot.name() ||\n                        name == keywords::Crate.name() ||\n                        name == keywords::DollarCrate.name() {\n                         // `::a::b`, `crate::a::b` or `$crate::a::b`\n@@ -3809,12 +3809,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             // Report special messages for path segment keywords in wrong positions.\n             if ident.is_path_segment_keyword() && i != 0 {\n-                let name_str = if name == keywords::CrateRoot.name() {\n+                let name_str = if name == keywords::PathRoot.name() {\n                     \"crate root\".to_string()\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].ident.name == keywords::CrateRoot.name() {\n+                let msg = if i == 1 && path[0].ident.name == keywords::PathRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else {\n                     format!(\"{} in paths can only be used in start position\", name_str)\n@@ -3944,7 +3944,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         // We're only interested in `use` paths which should start with\n         // `{{root}}` or `extern` currently.\n-        if first_name != keywords::Extern.name() && first_name != keywords::CrateRoot.name() {\n+        if first_name != keywords::Extern.name() && first_name != keywords::PathRoot.name() {\n             return\n         }\n \n@@ -3953,7 +3953,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             Some(Segment { ident, .. }) if ident.name == keywords::Crate.name() => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n-            // If the path has length one (and it's `CrateRoot` most likely)\n+            // If the path has length one (and it's `PathRoot` most likely)\n             // then we don't know whether we're gonna be importing a crate or an\n             // item in our crate. Defer this lint to elsewhere\n             None => return,\n@@ -4740,7 +4740,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 } else {\n                     let ctxt = ident.span.ctxt();\n                     Some(Segment::from_ident(Ident::new(\n-                        keywords::CrateRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n+                        keywords::PathRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n                     )))\n                 };\n \n@@ -5090,17 +5090,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n }\n \n fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfType.name()\n+    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfUpper.name()\n }\n \n fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfValue.name()\n+    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfLower.name()\n }\n \n fn names_to_string(idents: &[Ident]) -> String {\n     let mut result = String::new();\n     for (i, ident) in idents.iter()\n-                            .filter(|ident| ident.name != keywords::CrateRoot.name())\n+                            .filter(|ident| ident.name != keywords::PathRoot.name())\n                             .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");"}, {"sha": "65a9652cd237cb0675157f070899b78184b6ba3f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n                 if path.segments[0].ident.name == keywords::DollarCrate.name() {\n                     let module = self.0.resolve_crate_root(path.segments[0].ident);\n-                    path.segments[0].ident.name = keywords::CrateRoot.name();\n+                    path.segments[0].ident.name = keywords::PathRoot.name();\n                     if !module.is_local() {\n                         let span = path.segments[0].ident.span;\n                         path.segments.insert(1, match module.kind {\n@@ -674,7 +674,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     _ => Err(Determinacy::Determined),\n                 }\n                 WhereToResolve::CrateRoot => {\n-                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_ident = Ident::new(keywords::PathRoot.name(), orig_ident.span);\n                     let root_module = self.resolve_crate_root(root_ident);\n                     let binding = self.resolve_ident_in_module_ext(\n                         ModuleOrUniformRoot::Module(root_module),\n@@ -960,7 +960,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     break 'ok;\n                 }\n                 if rust_2015 {\n-                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_ident = Ident::new(keywords::PathRoot.name(), orig_ident.span);\n                     let root_module = self.resolve_crate_root(root_ident);\n                     if self.resolve_ident_in_module_ext(ModuleOrUniformRoot::Module(root_module),\n                                                         orig_ident, ns, None, false, path_span)"}, {"sha": "865aace8aabb51c66c6321c26e4b4439f466dde0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                         .to_name_binding(self.arenas);\n                         return Ok(binding);\n                     } else if ident.name == keywords::Super.name() ||\n-                                ident.name == keywords::SelfValue.name() {\n+                                ident.name == keywords::SelfLower.name() {\n                         // FIXME: Implement these with renaming requirements so that e.g.\n                         // `use super;` doesn't work, but `use super as name;` does.\n                         // Fall through here to get an error from `early_resolve_...`.\n@@ -1263,8 +1263,8 @@ fn import_path_to_string(names: &[Ident],\n                          subclass: &ImportDirectiveSubclass,\n                          span: Span) -> String {\n     let pos = names.iter()\n-        .position(|p| span == p.span && p.name != keywords::CrateRoot.name());\n-    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n+        .position(|p| span == p.span && p.name != keywords::PathRoot.name());\n+    let global = !names.is_empty() && names[0].name == keywords::PathRoot.name();\n     if let Some(pos) = pos {\n         let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n         names_to_string(names)"}, {"sha": "5830fa00be8cb2d8f0cd3b73572d541eca895a2b", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -234,7 +234,7 @@ macro_rules! supported_targets {\n         $(mod $module;)*\n \n         /// List of supported targets\n-        const TARGETS: &'static [&'static str] = &[$($triple),*];\n+        const TARGETS: &[&str] = &[$($triple),*];\n \n         fn load_specific(target: &str) -> TargetResult {\n             match target {"}, {"sha": "5682a73bed573ffd51f06bf3192a8a6921eac47b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -938,7 +938,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n-                        name: keywords::SelfType.name().as_interned_str(),\n+                        name: keywords::SelfUpper.name().as_interned_str(),\n                         def_id: tcx.hir.local_def_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n@@ -1007,7 +1007,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                     synthetic,\n                     ..\n                 } => {\n-                    if param.name.ident().name == keywords::SelfType.name() {\n+                    if param.name.ident().name == keywords::SelfUpper.name() {\n                         span_bug!(\n                             param.span,\n                             \"`Self` should not be the name of a regular parameter\""}, {"sha": "310c369a4d092656586c03aae49e2fb3b898b9d9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1575,7 +1575,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n             ty::GenericParamDefKind::Lifetime => None,\n             ty::GenericParamDefKind::Type { .. } => {\n-                if param.name == keywords::SelfType.name().as_str() {\n+                if param.name == keywords::SelfUpper.name().as_str() {\n                     assert_eq!(param.index, 0);\n                     return None;\n                 }\n@@ -3174,7 +3174,7 @@ fn qpath_to_string(p: &hir::QPath) -> String {\n         if i > 0 {\n             s.push_str(\"::\");\n         }\n-        if seg.ident.name != keywords::CrateRoot.name() {\n+        if seg.ident.name != keywords::PathRoot.name() {\n             s.push_str(&*seg.ident.as_str());\n         }\n     }\n@@ -3726,7 +3726,7 @@ fn resolve_type(cx: &DocContext,\n             hir::Float(float_ty) => return Primitive(float_ty.into()),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(keywords::SelfType.name().to_string());\n+            return Generic(keywords::SelfUpper.name().to_string());\n         }\n         Def::TyParam(..) if path.segments.len() == 1 => {\n             return Generic(format!(\"{:#}\", path));"}, {"sha": "fa5d015e5b72dc494ea7469d0c36567a64013b1e", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -57,6 +57,9 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     {css_extension}\\\n     {favicon}\\\n     {in_header}\\\n+    <style type=\\\"text/css\\\">\\\n+    #crate-search{{background-image:url(\\\"{root_path}down-arrow{suffix}.svg\\\");}}\\\n+    </style>\\\n </head>\\\n <body class=\\\"rustdoc {css_class}\\\">\\\n     <!--[if lte IE 8]>\\\n@@ -81,11 +84,16 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     <nav class=\\\"sub\\\">\\\n         <form class=\\\"search-form js-only\\\">\\\n             <div class=\\\"search-container\\\">\\\n-                <input class=\\\"search-input\\\" name=\\\"search\\\" \\\n-                       autocomplete=\\\"off\\\" \\\n-                       spellcheck=\\\"false\\\" \\\n-                       placeholder=\\\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\\\" \\\n-                       type=\\\"search\\\">\\\n+                <div>\\\n+                    <select id=\\\"crate-search\\\">\\\n+                        <option value=\\\"All crates\\\">All crates</option>\\\n+                    </select>\\\n+                    <input class=\\\"search-input\\\" name=\\\"search\\\" \\\n+                           autocomplete=\\\"off\\\" \\\n+                           spellcheck=\\\"false\\\" \\\n+                           placeholder=\\\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\\\" \\\n+                           type=\\\"search\\\">\\\n+                </div>\\\n                 <a id=\\\"settings-menu\\\" href=\\\"{root_path}settings.html\\\">\\\n                     <img src=\\\"{root_path}wheel{suffix}.svg\\\" width=\\\"18\\\" alt=\\\"Change settings\\\">\\\n                 </a>\\"}, {"sha": "6158815fb9a51ec533785f8f1b03f235d2826335", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -793,6 +793,8 @@ fn write_shared(\n           static_files::BRUSH_SVG)?;\n     write(cx.dst.join(&format!(\"wheel{}.svg\", cx.shared.resource_suffix)),\n           static_files::WHEEL_SVG)?;\n+    write(cx.dst.join(&format!(\"down-arrow{}.svg\", cx.shared.resource_suffix)),\n+          static_files::DOWN_ARROW_SVG)?;\n     write_minify(cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n                  static_files::themes::LIGHT,\n                  options.enable_minification)?;\n@@ -1066,7 +1068,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                        &[(minifier::js::Keyword::Null, \"N\")]),\n                  &dst);\n     }\n-    try_err!(writeln!(&mut w, \"initSearch(searchIndex);\"), &dst);\n+    try_err!(writeln!(&mut w, \"initSearch(searchIndex);addSearchOptions(searchIndex);\"), &dst);\n \n     if options.enable_index_page {\n         if let Some(index_page) = options.index_page.clone() {"}, {"sha": "a2d9a37dde09129757b25280f9ca887ecfbe47cb", "filename": "src/librustdoc/html/static/down-arrow.svg", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fdown-arrow.svg", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fdown-arrow.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fdown-arrow.svg?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1 @@\n+<?xml version=\"1.0\" ?><!DOCTYPE svg  PUBLIC '-//W3C//DTD SVG 1.1//EN'  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'><svg height=\"128px\" id=\"Layer_1\" style=\"enable-background:new 0 0 128 128;\" version=\"1.1\" viewBox=\"0 0 128 128\" width=\"128px\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g><line style=\"fill:none;stroke:#2F3435;stroke-width:12;stroke-linecap:square;stroke-miterlimit:10;\" x1=\"111\" x2=\"64\" y1=\"40.5\" y2=\"87.499\"/><line style=\"fill:none;stroke:#2F3435;stroke-width:12;stroke-linecap:square;stroke-miterlimit:10;\" x1=\"64\" x2=\"17\" y1=\"87.499\" y2=\"40.5\"/></g></svg>\n\\ No newline at end of file"}, {"sha": "1869969a5306956171b4026989941a5782b92913", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 83, "deletions": 16, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -218,12 +218,14 @@ if (!String.prototype.endsWith) {\n     //\n     // So I guess you could say things are getting pretty interoperable.\n     function getVirtualKey(ev) {\n-        if (\"key\" in ev && typeof ev.key != \"undefined\")\n+        if (\"key\" in ev && typeof ev.key != \"undefined\") {\n             return ev.key;\n+        }\n \n         var c = ev.charCode || ev.keyCode;\n-        if (c == 27)\n+        if (c == 27) {\n             return \"Escape\";\n+        }\n         return String.fromCharCode(c);\n     }\n \n@@ -431,12 +433,13 @@ if (!String.prototype.endsWith) {\n \n         /**\n          * Executes the query and builds an index of results\n-         * @param  {[Object]} query     [The user query]\n-         * @param  {[type]} searchWords [The list of search words to query\n-         *                               against]\n-         * @return {[type]}             [A search index of results]\n+         * @param  {[Object]} query      [The user query]\n+         * @param  {[type]} searchWords  [The list of search words to query\n+         *                                against]\n+         * @param  {[type]} filterCrates [Crate to search in if defined]\n+         * @return {[type]}              [A search index of results]\n          */\n-        function execQuery(query, searchWords) {\n+        function execQuery(query, searchWords, filterCrates) {\n             function itemTypeFromName(typename) {\n                 for (var i = 0; i < itemTypes.length; ++i) {\n                     if (itemTypes[i] === typename) {\n@@ -812,6 +815,9 @@ if (!String.prototype.endsWith) {\n             {\n                 val = extractGenerics(val.substr(1, val.length - 2));\n                 for (var i = 0; i < nSearchWords; ++i) {\n+                    if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n+                        continue;\n+                    }\n                     var in_args = findArg(searchIndex[i], val, true);\n                     var returned = checkReturned(searchIndex[i], val, true);\n                     var ty = searchIndex[i];\n@@ -866,6 +872,9 @@ if (!String.prototype.endsWith) {\n                 var output = extractGenerics(parts[1]);\n \n                 for (var i = 0; i < nSearchWords; ++i) {\n+                    if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n+                        continue;\n+                    }\n                     var type = searchIndex[i].type;\n                     var ty = searchIndex[i];\n                     if (!type) {\n@@ -937,11 +946,11 @@ if (!String.prototype.endsWith) {\n                 var contains = paths.slice(0, paths.length > 1 ? paths.length - 1 : 1);\n \n                 for (j = 0; j < nSearchWords; ++j) {\n-                    var lev_distance;\n                     var ty = searchIndex[j];\n-                    if (!ty) {\n+                    if (!ty || (filterCrates !== undefined && ty.crate !== filterCrates)) {\n                         continue;\n                     }\n+                    var lev_distance;\n                     var lev_add = 0;\n                     if (paths.length > 1) {\n                         var lev = checkPath(contains, paths[paths.length - 1], ty);\n@@ -1326,7 +1335,7 @@ if (!String.prototype.endsWith) {\n             return '<div>' + text + ' <div class=\"count\">(' + nbElems + ')</div></div>';\n         }\n \n-        function showResults(results) {\n+        function showResults(results, filterCrates) {\n             if (results['others'].length === 1 &&\n                 getCurrentValue('rustdoc-go-to-only-result') === \"true\") {\n                 var elem = document.createElement('a');\n@@ -1344,8 +1353,13 @@ if (!String.prototype.endsWith) {\n             var ret_in_args = addTab(results['in_args'], query, false);\n             var ret_returned = addTab(results['returned'], query, false);\n \n+            var filter = \"\";\n+            if (filterCrates !== undefined) {\n+                filter = \" (in <b>\" + filterCrates + \"</b> crate)\";\n+            }\n+\n             var output = '<h1>Results for ' + escape(query.query) +\n-                (query.type ? ' (type: ' + escape(query.type) + ')' : '') + '</h1>' +\n+                (query.type ? ' (type: ' + escape(query.type) + ')' : '') + filter + '</h1>' +\n                 '<div id=\"titles\">' +\n                 makeTabHeader(0, \"In Names\", ret_others[1]) +\n                 makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n@@ -1374,7 +1388,7 @@ if (!String.prototype.endsWith) {\n             printTab(currentTab);\n         }\n \n-        function execSearch(query, searchWords) {\n+        function execSearch(query, searchWords, filterCrates) {\n             var queries = query.raw.split(\",\");\n             var results = {\n                 'in_args': [],\n@@ -1385,7 +1399,7 @@ if (!String.prototype.endsWith) {\n             for (var i = 0; i < queries.length; ++i) {\n                 var query = queries[i].trim();\n                 if (query.length !== 0) {\n-                    var tmp = execQuery(getQuery(query), searchWords);\n+                    var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n \n                     results['in_args'].push(tmp['in_args']);\n                     results['returned'].push(tmp['returned']);\n@@ -1447,15 +1461,27 @@ if (!String.prototype.endsWith) {\n             }\n         }\n \n-        function search(e) {\n+        function getFilterCrates() {\n+            var elem = document.getElementById(\"crate-search\");\n+\n+            if (elem && elem.value !== \"All crates\" && rawSearchIndex.hasOwnProperty(elem.value)) {\n+                return elem.value;\n+            }\n+            return undefined;\n+        }\n+\n+        function search(e, forced) {\n             var params = getQueryStringParams();\n             var query = getQuery(search_input.value.trim());\n \n             if (e) {\n                 e.preventDefault();\n             }\n \n-            if (query.query.length === 0 || query.id === currentResults) {\n+            if (query.query.length === 0) {\n+                return;\n+            }\n+            if (forced !== true && query.id === currentResults) {\n                 if (query.query.length > 0) {\n                     putBackSearch(search_input);\n                 }\n@@ -1475,7 +1501,8 @@ if (!String.prototype.endsWith) {\n                 }\n             }\n \n-            showResults(execSearch(query, index));\n+            var filterCrates = getFilterCrates();\n+            showResults(execSearch(query, index, filterCrates), filterCrates);\n         }\n \n         function buildIndex(rawSearchIndex) {\n@@ -1575,6 +1602,13 @@ if (!String.prototype.endsWith) {\n             };\n             search_input.onpaste = search_input.onchange;\n \n+            var selectCrate = document.getElementById('crate-search');\n+            if (selectCrate) {\n+                selectCrate.onchange = function() {\n+                    search(undefined, true);\n+                };\n+            }\n+\n             // Push and pop states are used to add search results to the browser\n             // history.\n             if (browserSupportsHistoryApi()) {\n@@ -2323,6 +2357,39 @@ if (!String.prototype.endsWith) {\n     if (window.location.hash && window.location.hash.length > 0) {\n         expandSection(window.location.hash.replace(/^#/, ''));\n     }\n+\n+    function addSearchOptions(crates) {\n+        var elem = document.getElementById('crate-search');\n+\n+        if (!elem) {\n+            return;\n+        }\n+        var crates_text = [];\n+        for (var crate in crates) {\n+            if (crates.hasOwnProperty(crate)) {\n+                crates_text.push(crate);\n+            }\n+        }\n+        crates_text.sort(function(a, b) {\n+            var lower_a = a.toLowerCase();\n+            var lower_b = b.toLowerCase();\n+\n+            if (lower_a < lower_b) {\n+                return -1;\n+            } else if (lower_a > lower_b) {\n+                return 1;\n+            }\n+            return 0;\n+        });\n+        for (var i = 0; i < crates_text.length; ++i) {\n+            var option = document.createElement(\"option\");\n+            option.value = crates_text[i];\n+            option.innerText = crates_text[i];\n+            elem.appendChild(option);\n+        }\n+    }\n+\n+    window.addSearchOptions = addSearchOptions;\n }());\n \n // Sets the focus on the search bar at the top of the page"}, {"sha": "37d26a4cadc572b8d2b35c8721deb35078424a9c", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -620,27 +620,51 @@ a {\n .search-container {\n \tposition: relative;\n }\n+.search-container > div {\n+\tdisplay: inline-flex;\n+\twidth: calc(100% - 34px);\n+}\n+#crate-search {\n+\tmargin-top: 5px;\n+\tpadding: 6px;\n+\tpadding-right: 19px;\n+\tborder: 0;\n+\tborder-right: 0;\n+\tborder-radius: 4px 0 0 4px;\n+\toutline: none;\n+\tcursor: pointer;\n+\tborder-right: 1px solid;\n+\t-moz-appearance: none;\n+\t-webkit-appearance: none;\n+\t/* Removes default arrow from firefox */\n+\ttext-indent: 0.01px;\n+\ttext-overflow: \"\";\n+\tbackground-repeat: no-repeat;\n+\tbackground-color: transparent;\n+\tbackground-size: 16%;\n+\tbackground-position: calc(100% - 1px) 56%;\n+}\n .search-container > .top-button {\n \tposition: absolute;\n \tright: 0;\n \ttop: 10px;\n }\n .search-input {\n-\twidth: calc(100% - 34px);\n \t/* Override Normalize.css: we have margins and do\n \t not want to overflow - the `moz` attribute is necessary\n \t until Firefox 29, too early to drop at this point */\n \t-moz-box-sizing: border-box !important;\n \tbox-sizing: border-box !important;\n \toutline: none;\n \tborder: none;\n-\tborder-radius: 1px;\n+\tborder-radius: 0 1px 1px 0;\n \tmargin-top: 5px;\n \tpadding: 10px 16px;\n \tfont-size: 17px;\n \ttransition: border-color 300ms ease;\n \ttransition: border-radius 300ms ease-in-out;\n \ttransition: box-shadow 300ms ease-in-out;\n+\twidth: 100%;\n }\n \n .search-input:focus {"}, {"sha": "2cd1a8580890c44320934c700e905799097790a4", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -182,9 +182,15 @@ a.test-arrow {\n \tcolor: #999;\n }\n \n+#crate-search {\n+\tcolor: #111;\n+\tbackground-color: #f0f0f0;\n+\tborder-color: #000;\n+}\n+\n .search-input {\n \tcolor: #111;\n-\tbox-shadow: 0 0 0 1px #000, 0 0 0 2px transparent;\n+\tbox-shadow: 1px 0 0 1px #000, 0 0 0 2px transparent;\n \tbackground-color: #f0f0f0;\n }\n "}, {"sha": "4cf35f64d19a4463cb4d1cc071baf19fffd6d79f", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -182,9 +182,16 @@ a.test-arrow {\n \tcolor: #999;\n }\n \n+#crate-search {\n+\tcolor: #555;\n+\tbackground-color: white;\n+\tborder-color: #e0e0e0;\n+\tbox-shadow: 0px 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n+}\n+\n .search-input {\n \tcolor: #555;\n-\tbox-shadow: 0 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n+\tbox-shadow: 1px 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n \tbackground-color: white;\n }\n "}, {"sha": "a485facfac2dcb1fb30084aabfd4e44fda6d24ba", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -45,6 +45,9 @@ pub static BRUSH_SVG: &'static [u8] = include_bytes!(\"static/brush.svg\");\n /// The file contents of `wheel.svg`, the icon used for the settings button.\n pub static WHEEL_SVG: &'static [u8] = include_bytes!(\"static/wheel.svg\");\n \n+/// The file contents of `down-arrow.svg`, the icon used for the crate choice combobox.\n+pub static DOWN_ARROW_SVG: &'static [u8] = include_bytes!(\"static/down-arrow.svg\");\n+\n /// The contents of `COPYRIGHT.txt`, the license listing for files distributed with documentation\n /// output.\n pub static COPYRIGHT: &'static [u8] = include_bytes!(\"static/COPYRIGHT.txt\");"}, {"sha": "31adb2e0369c9f539c72465dd5ec8957649c803f", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                                               None);\n         // attach the crate's exported macros to the top-level module:\n         let macro_exports: Vec<_> =\n-            krate.exported_macros.iter().map(|def| self.visit_local_macro(def)).collect();\n+            krate.exported_macros.iter().map(|def| self.visit_local_macro(def, None)).collect();\n         self.module.macros.extend(macro_exports);\n         self.module.is_crate = true;\n \n@@ -376,6 +376,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 });\n                 true\n             }\n+            Node::MacroDef(def) if !glob => {\n+                om.macros.push(self.visit_local_macro(def, renamed));\n+                true\n+            }\n             _ => false,\n         };\n         self.view_item_stack.remove(&def_node_id);\n@@ -593,7 +597,11 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n     }\n \n     // convert each exported_macro into a doc item\n-    fn visit_local_macro(&self, def: &hir::MacroDef) -> Macro {\n+    fn visit_local_macro(\n+        &self,\n+        def: &hir::MacroDef,\n+        renamed: Option<ast::Name>\n+    ) -> Macro {\n         debug!(\"visit_local_macro: {}\", def.name);\n         let tts = def.body.trees().collect::<Vec<_>>();\n         // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n@@ -602,7 +610,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         Macro {\n             def_id: self.cx.tcx.hir.local_def_id(def.id),\n             attrs: def.attrs.clone(),\n-            name: def.name,\n+            name: renamed.unwrap_or(def.name),\n             whence: def.span,\n             matchers,\n             stab: self.stability(def.id),"}, {"sha": "03e81a720dc640ececa2e08bb32e631a30547b67", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -283,11 +283,14 @@ pub fn current_exe() -> io::Result<PathBuf> {\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"emscripten\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n-    let selfexe = PathBuf::from(\"/proc/self/exe\");\n-    if selfexe.exists() {\n-        ::fs::read_link(selfexe)\n-    } else {\n-        Err(io::Error::new(io::ErrorKind::Other, \"no /proc/self/exe available. Is /proc mounted?\"))\n+    match ::fs::read_link(\"/proc/self/exe\") {\n+        Err(ref e) if e.kind() == io::ErrorKind::NotFound => {\n+            Err(io::Error::new(\n+                io::ErrorKind::Other,\n+                \"no /proc/self/exe available. Is /proc mounted?\"\n+            ))\n+        },\n+        other => other,\n     }\n }\n "}, {"sha": "872257118714e55930bd45ad21bb76319a7cd006", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -73,7 +73,7 @@ impl fmt::Debug for Lifetime {\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n-    /// Global paths begin with `keywords::CrateRoot`.\n+    /// Global paths begin with `keywords::PathRoot`.\n     pub segments: Vec<PathSegment>,\n }\n \n@@ -105,19 +105,8 @@ impl Path {\n         }\n     }\n \n-    // Make a \"crate root\" segment for this path unless it already has it\n-    // or starts with something like `self`/`super`/`$crate`/etc.\n-    pub fn make_root(&self) -> Option<PathSegment> {\n-        if let Some(ident) = self.segments.get(0).map(|seg| seg.ident) {\n-            if ident.is_path_segment_keyword() {\n-                return None;\n-            }\n-        }\n-        Some(PathSegment::crate_root(self.span.shrink_to_lo()))\n-    }\n-\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n     }\n }\n \n@@ -144,8 +133,8 @@ impl PathSegment {\n     pub fn from_ident(ident: Ident) -> Self {\n         PathSegment { ident, id: DUMMY_NODE_ID, args: None }\n     }\n-    pub fn crate_root(span: Span) -> Self {\n-        PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span))\n+    pub fn path_root(span: Span) -> Self {\n+        PathSegment::from_ident(Ident::new(keywords::PathRoot.name(), span))\n     }\n }\n \n@@ -1688,7 +1677,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n-            if ident.name == keywords::SelfValue.name() {\n+            if ident.name == keywords::SelfLower.name() {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                     TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.node.is_implicit_self() => {\n@@ -1706,7 +1695,7 @@ impl Arg {\n \n     pub fn is_self(&self) -> bool {\n         if let PatKind::Ident(_, ident, _) = self.pat.node {\n-            ident.name == keywords::SelfValue.name()\n+            ident.name == keywords::SelfLower.name()\n         } else {\n             false\n         }"}, {"sha": "5770f6bb8a28c442f10fd76f8065f65d1696742c", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -318,9 +318,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 args: Vec<ast::GenericArg>,\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n+        assert!(!idents.is_empty());\n+        let add_root = global && !idents[0].is_path_segment_keyword();\n+        let mut segments = Vec::with_capacity(idents.len() + add_root as usize);\n+        if add_root {\n+            segments.push(ast::PathSegment::path_root(span));\n+        }\n         let last_ident = idents.pop().unwrap();\n-        let mut segments: Vec<ast::PathSegment> = vec![];\n-\n         segments.extend(idents.into_iter().map(|ident| {\n             ast::PathSegment::from_ident(ident.with_span_pos(span))\n         }));\n@@ -334,13 +338,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             args,\n         });\n-        let mut path = ast::Path { span, segments };\n-        if global {\n-            if let Some(seg) = path.make_root() {\n-                path.segments.insert(0, seg);\n-            }\n-        }\n-        path\n+        ast::Path { span, segments }\n     }\n \n     /// Constructs a qualified path.\n@@ -625,7 +623,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, keywords::SelfValue.ident())\n+        self.expr_ident(span, keywords::SelfLower.ident())\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOpKind,"}, {"sha": "67f3dc1bb527226ed2dd4e3f0227f6b8025d8152", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -204,7 +204,7 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n             path_str.push_str(\"::\");\n         }\n \n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n             segment.ident.name != keywords::DollarCrate.name()\n         {\n             path_str.push_str(&segment.ident.as_str())"}, {"sha": "a7415e845cae398b45aad0311139c9ab678b8b2b", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -444,7 +444,6 @@ where\n             macro_node_id,\n         ),\n         Edition::Edition2018 => parse_sep_and_kleene_op_2018(input, span, sess, features, attrs),\n-        _ => unimplemented!(),\n     }\n }\n "}, {"sha": "5e0176df3115b6e4a8b81c717b20c6a1928e5305", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -53,8 +53,7 @@ macro_rules! declare_features {\n         /// Represents active features that are currently being implemented or\n         /// currently being considered for addition/removal.\n         const ACTIVE_FEATURES:\n-                &'static [(&'static str, &'static str, Option<u32>,\n-                           Option<Edition>, fn(&mut Features, Span))] =\n+            &[(&str, &str, Option<u32>, Option<Edition>, fn(&mut Features, Span))] =\n             &[$((stringify!($feature), $ver, $issue, $edition, set!($feature))),+];\n \n         /// A set of features to be used by later passes.\n@@ -439,8 +438,8 @@ declare_features! (\n     // 'a: { break 'a; }\n     (active, label_break_value, \"1.28.0\", Some(48594), None),\n \n-    // Integer match exhaustiveness checking\n-    (active, exhaustive_integer_patterns, \"1.30.0\", Some(50907), None),\n+    // Exhaustive pattern matching on `usize` and `isize`.\n+    (active, precise_pointer_size_matching, \"1.32.0\", Some(56354), None),\n \n     // #[doc(keyword = \"...\")]\n     (active, doc_keyword, \"1.28.0\", Some(51315), None),\n@@ -686,6 +685,8 @@ declare_features! (\n     (accepted, extern_crate_item_prelude, \"1.31.0\", Some(55599), None),\n     // Allows use of the :literal macro fragment specifier (RFC 1576)\n     (accepted, macro_literal_matcher, \"1.31.0\", Some(35625), None),\n+    // Integer match exhaustiveness checking (RFC 2591)\n+    (accepted, exhaustive_integer_patterns, \"1.32.0\", Some(50907), None),\n     // Use `?` as the Kleene \"at most one\" operator\n     (accepted, macro_at_most_once_rep, \"1.32.0\", Some(48075), None),\n     // `Self` struct constructor (RFC 2302)\n@@ -772,7 +773,7 @@ pub fn is_builtin_attr(attr: &ast::Attribute) -> bool {\n }\n \n // Attributes that have a special meaning to rustc or rustdoc\n-pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGate)] = &[\n+pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeGate)] = &[\n     // Normal attributes\n \n     (\"warn\", Normal, Ungated),\n@@ -1386,48 +1387,48 @@ fn leveled_feature_err<'a>(sess: &'a ParseSess, feature: &str, span: Span, issue\n \n }\n \n-const EXPLAIN_BOX_SYNTAX: &'static str =\n+const EXPLAIN_BOX_SYNTAX: &str =\n     \"box expression syntax is experimental; you can call `Box::new` instead.\";\n \n-pub const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n+pub const EXPLAIN_STMT_ATTR_SYNTAX: &str =\n     \"attributes on expressions are experimental.\";\n \n-pub const EXPLAIN_ASM: &'static str =\n+pub const EXPLAIN_ASM: &str =\n     \"inline assembly is not stable enough for use and is subject to change\";\n \n-pub const EXPLAIN_GLOBAL_ASM: &'static str =\n+pub const EXPLAIN_GLOBAL_ASM: &str =\n     \"`global_asm!` is not stable enough for use and is subject to change\";\n \n-pub const EXPLAIN_CUSTOM_TEST_FRAMEWORKS: &'static str =\n+pub const EXPLAIN_CUSTOM_TEST_FRAMEWORKS: &str =\n     \"custom test frameworks are an unstable feature\";\n \n-pub const EXPLAIN_LOG_SYNTAX: &'static str =\n+pub const EXPLAIN_LOG_SYNTAX: &str =\n     \"`log_syntax!` is not stable enough for use and is subject to change\";\n \n-pub const EXPLAIN_CONCAT_IDENTS: &'static str =\n+pub const EXPLAIN_CONCAT_IDENTS: &str =\n     \"`concat_idents` is not stable enough for use and is subject to change\";\n \n-pub const EXPLAIN_FORMAT_ARGS_NL: &'static str =\n+pub const EXPLAIN_FORMAT_ARGS_NL: &str =\n     \"`format_args_nl` is only for internal language use and is subject to change\";\n \n-pub const EXPLAIN_TRACE_MACROS: &'static str =\n+pub const EXPLAIN_TRACE_MACROS: &str =\n     \"`trace_macros` is not stable enough for use and is subject to change\";\n-pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &'static str =\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &str =\n     \"allow_internal_unstable side-steps feature gating and stability checks\";\n-pub const EXPLAIN_ALLOW_INTERNAL_UNSAFE: &'static str =\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSAFE: &str =\n     \"allow_internal_unsafe side-steps the unsafe_code lint\";\n \n-pub const EXPLAIN_CUSTOM_DERIVE: &'static str =\n+pub const EXPLAIN_CUSTOM_DERIVE: &str =\n     \"`#[derive]` for custom traits is deprecated and will be removed in the future.\";\n \n-pub const EXPLAIN_DEPR_CUSTOM_DERIVE: &'static str =\n+pub const EXPLAIN_DEPR_CUSTOM_DERIVE: &str =\n     \"`#[derive]` for custom traits is deprecated and will be removed in the future. \\\n     Prefer using procedural macro custom derive.\";\n \n-pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n+pub const EXPLAIN_DERIVE_UNDERSCORE: &str =\n     \"attributes of the form `#[derive_*]` are reserved for the compiler\";\n \n-pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n+pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &str =\n     \"unsized tuple coercion is not stable enough for use and is subject to change\";\n \n struct PostExpansionVisitor<'a> {"}, {"sha": "4ff6048e821787693269ef053f496fe4ad50ef44", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -22,8 +22,8 @@ enum InnerAttributeParsePolicy<'a> {\n     NotPermitted { reason: &'a str },\n }\n \n-const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &'static str = \"an inner attribute is not \\\n-                                                             permitted in this context\";\n+const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &str = \"an inner attribute is not \\\n+                                                     permitted in this context\";\n \n impl<'a> Parser<'a> {\n     /// Parse attributes that appear before an item"}, {"sha": "8a620c8067d3c2900f8bf311e1c2e1fb8071ec8e", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -306,7 +306,7 @@ const UNICODE_ARRAY: &[(char, &str, char)] = &[\n     ('\uff1e', \"Fullwidth Greater-Than Sign\", '>'), ];\n \n \n-const ASCII_ARRAY: &'static [(char, &'static str)] = &[\n+const ASCII_ARRAY: &[(char, &str)] = &[\n     (' ', \"Space\"),\n     ('_', \"Underscore\"),\n     ('-', \"Minus/Hyphen\"),"}, {"sha": "8165c0e44c413a3469fe8f2de6c8fc706857902c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -2082,7 +2082,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         let mod_sep_ctxt = self.span.ctxt();\n         if self.eat(&token::ModSep) {\n-            segments.push(PathSegment::crate_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n+            segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n         self.parse_path_segments(&mut segments, style, enable_warning)?;\n \n@@ -5508,7 +5508,7 @@ impl<'a> Parser<'a> {\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n-            this.look_ahead(n, |t| t.is_keyword(keywords::SelfValue)) &&\n+            this.look_ahead(n, |t| t.is_keyword(keywords::SelfLower)) &&\n             this.look_ahead(n + 1, |t| t != &token::ModSep)\n         };\n \n@@ -6330,7 +6330,7 @@ impl<'a> Parser<'a> {\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n                       self.look_ahead(1, |t| t.is_keyword(keywords::Super) ||\n-                                             t.is_keyword(keywords::SelfValue))\n+                                             t.is_keyword(keywords::SelfLower))\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n@@ -6782,7 +6782,7 @@ impl<'a> Parser<'a> {\n         let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n         let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n                               in the code\";\n-        let mut ident = if self.token.is_keyword(keywords::SelfValue) {\n+        let mut ident = if self.token.is_keyword(keywords::SelfLower) {\n             self.parse_path_segment_ident()\n         } else {\n             self.parse_ident()\n@@ -7685,7 +7685,7 @@ impl<'a> Parser<'a> {\n             let mod_sep_ctxt = self.span.ctxt();\n             if self.eat(&token::ModSep) {\n                 prefix.segments.push(\n-                    PathSegment::crate_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n+                    PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n                 );\n             }\n "}, {"sha": "e50f28897dd1287db983f5918bf184191bf17317", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -724,7 +724,7 @@ pub trait PrintState<'a> {\n             if i > 0 {\n                 self.writer().word(\"::\")?\n             }\n-            if segment.ident.name != keywords::CrateRoot.name() &&\n+            if segment.ident.name != keywords::PathRoot.name() &&\n                segment.ident.name != keywords::DollarCrate.name()\n             {\n                 self.writer().word(segment.ident.as_str().get())?;\n@@ -2463,7 +2463,7 @@ impl<'a> State<'a> {\n                           colons_before_params: bool)\n                           -> io::Result<()>\n     {\n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n            segment.ident.name != keywords::DollarCrate.name() {\n             self.print_ident(segment.ident)?;\n             if let Some(ref args) = segment.args {"}, {"sha": "5c994558ab06feb3aafc0f72df4634bc04b683f6", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -112,7 +112,7 @@ pub fn maybe_inject_crates_ref(\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: iter::once(keywords::CrateRoot.ident())\n+                segments: iter::once(keywords::PathRoot.ident())\n                     .chain(\n                         [name, \"prelude\", \"v1\"].iter().cloned()\n                             .map(ast::Ident::from_str)"}, {"sha": "2ff9fb487c4f225f228157844fc6b629a1909a32", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -47,7 +47,7 @@ impl State {\n     }\n }\n \n-const OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n+const OPTIONS: &[&str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                        sp: Span,"}, {"sha": "b9e0933331cb87814deb4a4177d9d454249eea14", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -140,7 +140,7 @@ fn cs_clone_shallow(name: &str,\n     let mut stmts = Vec::new();\n     if is_union {\n         // let _: AssertParamIsCopy<Self>;\n-        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfType.ident()));\n+        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfUpper.ident()));\n         assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n     } else {\n         match *substr.fields {"}, {"sha": "c0c11f64bc3b88b722e65f96846e96fa15ed63c1", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -938,7 +938,7 @@ impl<'a> MethodDef<'a> {\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 ast::Arg::from_self(explicit_self,\n-                                    keywords::SelfValue.ident().with_span_pos(trait_.span))\n+                                    keywords::SelfLower.ident().with_span_pos(trait_.span))\n             });\n             let nonself_args = arg_types.into_iter()\n                 .map(|(name, ty)| cx.arg(trait_.span, name, ty));"}, {"sha": "000bede7348a51d31a97a6a45fd000983dac45a7", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -28,7 +28,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream;\n \n-pub const MACRO: &'static str = \"global_asm\";\n+pub const MACRO: &str = \"global_asm\";\n \n pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,"}, {"sha": "f4ff0989b5d863b5318f75b36159c450111c32cb", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -30,8 +30,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use deriving;\n \n-const PROC_MACRO_KINDS: [&'static str; 3] =\n-    [\"proc_macro_derive\", \"proc_macro_attribute\", \"proc_macro\"];\n+const PROC_MACRO_KINDS: [&str; 3] = [\"proc_macro_derive\", \"proc_macro_attribute\", \"proc_macro\"];\n \n struct ProcMacroDerive {\n     trait_name: ast::Name,"}, {"sha": "127dc43fdabe7ee372608f4d703174cebaa7da01", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -13,7 +13,6 @@ use std::str::FromStr;\n \n /// The edition of the compiler (RFC 2052)\n #[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable, Eq)]\n-#[non_exhaustive]\n pub enum Edition {\n     // editions must be kept in order, oldest to newest\n \n@@ -33,7 +32,7 @@ pub enum Edition {\n // must be in order from oldest to newest\n pub const ALL_EDITIONS: &[Edition] = &[Edition::Edition2015, Edition::Edition2018];\n \n-pub const EDITION_NAME_LIST: &'static str = \"2015|2018\";\n+pub const EDITION_NAME_LIST: &str = \"2015|2018\";\n \n pub const DEFAULT_EDITION: Edition = Edition::Edition2015;\n "}, {"sha": "074687fc726e8fd209d4e5c69df09d15a8d128e0", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -17,7 +17,7 @@\n \n use GLOBALS;\n use Span;\n-use edition::Edition;\n+use edition::{Edition, DEFAULT_EDITION};\n use symbol::Symbol;\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -217,7 +217,7 @@ impl HygieneData {\n                 opaque_and_semitransparent: SyntaxContext(0),\n             }],\n             markings: FxHashMap::default(),\n-            default_edition: Edition::Edition2015,\n+            default_edition: DEFAULT_EDITION,\n         }\n     }\n "}, {"sha": "4f2eb74c0722766a3181ff9559fd8e205636e9b0", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -349,11 +349,11 @@ declare_keywords! {\n     // Special reserved identifiers used internally for elided lifetimes,\n     // unnamed method parameters, crate root module, error recovery etc.\n     (0,  Invalid,            \"\")\n-    (1,  CrateRoot,          \"{{root}}\")\n+    (1,  PathRoot,           \"{{root}}\")\n     (2,  DollarCrate,        \"$crate\")\n     (3,  Underscore,         \"_\")\n \n-    // Keywords used in the language.\n+    // Keywords that are used in stable Rust.\n     (4,  As,                 \"as\")\n     (5,  Box,                \"box\")\n     (6,  Break,              \"break\")\n@@ -378,8 +378,8 @@ declare_keywords! {\n     (25, Pub,                \"pub\")\n     (26, Ref,                \"ref\")\n     (27, Return,             \"return\")\n-    (28, SelfValue,          \"self\")\n-    (29, SelfType,           \"Self\")\n+    (28, SelfLower,          \"self\")\n+    (29, SelfUpper,          \"Self\")\n     (30, Static,             \"static\")\n     (31, Struct,             \"struct\")\n     (32, Super,              \"super\")\n@@ -391,7 +391,7 @@ declare_keywords! {\n     (38, Where,              \"where\")\n     (39, While,              \"while\")\n \n-    // Keywords reserved for future use.\n+    // Keywords that are used in unstable Rust or reserved for future use.\n     (40, Abstract,           \"abstract\")\n     (41, Become,             \"become\")\n     (42, Do,                 \"do\")\n@@ -404,9 +404,11 @@ declare_keywords! {\n     (49, Virtual,            \"virtual\")\n     (50, Yield,              \"yield\")\n \n-    // Edition-specific keywords reserved for future use.\n-    (51, Async,              \"async\") // >= 2018 Edition only\n-    (52, Dyn,                \"dyn\") // >= 2018 Edition only\n+    // Edition-specific keywords that are used in stable Rust.\n+    (51, Dyn,                \"dyn\") // >= 2018 Edition only\n+\n+    // Edition-specific keywords that are used in unstable Rust or reserved for future use.\n+    (52, Async,              \"async\") // >= 2018 Edition only\n     (53, Try,                \"try\") // >= 2018 Edition only\n \n     // Special lifetime names\n@@ -417,11 +419,15 @@ declare_keywords! {\n     (56, Auto,               \"auto\")\n     (57, Catch,              \"catch\")\n     (58, Default,            \"default\")\n-    (59, Union,              \"union\")\n-    (60, Existential,        \"existential\")\n+    (59, Existential,        \"existential\")\n+    (60, Union,              \"union\")\n }\n \n impl Symbol {\n+    fn is_used_keyword_2018(self) -> bool {\n+        self == keywords::Dyn.name()\n+    }\n+\n     fn is_unused_keyword_2018(self) -> bool {\n         self >= keywords::Async.name() && self <= keywords::Try.name()\n     }\n@@ -436,7 +442,9 @@ impl Ident {\n \n     /// Returns `true` if the token is a keyword used in the language.\n     pub fn is_used_keyword(self) -> bool {\n-        self.name >= keywords::As.name() && self.name <= keywords::While.name()\n+        // Note: `span.edition()` is relatively expensive, don't call it unless necessary.\n+        self.name >= keywords::As.name() && self.name <= keywords::While.name() ||\n+        self.name.is_used_keyword_2018() && self.span.rust_2018()\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n@@ -454,11 +462,11 @@ impl Ident {\n     /// A keyword or reserved identifier that can be used as a path segment.\n     pub fn is_path_segment_keyword(self) -> bool {\n         self.name == keywords::Super.name() ||\n-        self.name == keywords::SelfValue.name() ||\n-        self.name == keywords::SelfType.name() ||\n+        self.name == keywords::SelfLower.name() ||\n+        self.name == keywords::SelfUpper.name() ||\n         self.name == keywords::Extern.name() ||\n         self.name == keywords::Crate.name() ||\n-        self.name == keywords::CrateRoot.name() ||\n+        self.name == keywords::PathRoot.name() ||\n         self.name == keywords::DollarCrate.name()\n     }\n "}, {"sha": "29392fba8b47577f4dd2b51f341329ac177c5abc", "filename": "src/test/run-pass/issue-55380.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Frun-pass%2Fissue-55380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Frun-pass%2Fissue-55380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-55380.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+\n+#![feature(specialization)]\n+\n+pub trait Foo {\n+    fn abc() -> u32;\n+    fn def() -> u32;\n+}\n+\n+pub trait Marker {}\n+\n+impl Marker for () {}\n+\n+impl<T> Foo for T {\n+    default fn abc() -> u32 { 16 }\n+    default fn def() -> u32 { 42 }\n+}\n+\n+impl<T: Marker> Foo for T {\n+    fn def() -> u32 {\n+        Self::abc()\n+    }\n+}\n+\n+fn main() {\n+   assert_eq!(<()>::def(), 16);\n+   assert_eq!(<i32>::def(), 42);\n+}"}, {"sha": "97ecc607f476419371a0150eaeaba284ab33ab69", "filename": "src/test/rustdoc-js/filter-crate.js", "status": "renamed", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Frustdoc-js%2Ffilter-crate.js", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Frustdoc-js%2Ffilter-crate.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Ffilter-crate.js?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() {\n-    let x: u8 = 0;\n-    match x { //~ ERROR non-exhaustive patterns: `_` not covered\n-        0 ..= 255 => {}\n-    }\n-}\n+// exact-check\n+\n+const QUERY = 'hashmap';\n+const FILTER_CRATE = 'core';\n+\n+const EXPECTED = {\n+    'others': [\n+    ],\n+};", "previous_filename": "src/test/ui/feature-gate-exhaustive_integer_patterns.rs"}, {"sha": "93d55ec0798ac97d2e982dede823b98895247563", "filename": "src/test/rustdoc/inline_local/macro_by_example.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Frustdoc%2Finline_local%2Fmacro_by_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Frustdoc%2Finline_local%2Fmacro_by_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_local%2Fmacro_by_example.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+/// docs for foo\n+#[deprecated(since = \"1.2.3\", note = \"text\")]\n+#[macro_export]\n+macro_rules! foo {\n+    ($($tt:tt)*) => {}\n+}\n+\n+// @has macro_by_example/macros/index.html\n+pub mod macros {\n+    // @!has - 'pub use foo as bar;'\n+    // @has macro_by_example/macros/macro.bar.html\n+    // @has - '//*[@class=\"docblock\"]' 'docs for foo'\n+    // @has - '//*[@class=\"stab deprecated\"]' 'Deprecated since 1.2.3: text'\n+    // @has - '//a/@href' 'macro_by_example.rs.html#15-17'\n+    #[doc(inline)]\n+    pub use foo as bar;\n+}"}, {"sha": "703453e6bdd93a865b1494edcfa119749ff42a57", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `-2147483648i32..=-1i32` not covered\n   --> $DIR/const-match-check.rs:35:15\n    |\n LL |     A = { let 0 = 0; 0 },\n-   |               ^ pattern `_` not covered\n+   |               ^ pattern `-2147483648i32..=-1i32` not covered\n \n error: aborting due to previous error\n "}, {"sha": "6caff93e642963aa160008aaf751c2b6cd710d0e", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `-2147483648i32..=-1i32` not covered\n   --> $DIR/const-match-check.rs:41:24\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n-   |                        ^ pattern `_` not covered\n+   |                        ^ pattern `-2147483648i32..=-1i32` not covered\n \n error: aborting due to previous error\n "}, {"sha": "9e45045d27e8d6424646b8137bdbbd70be51f477", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,26 +1,26 @@\n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `-2147483648i32..=-1i32` not covered\n   --> $DIR/const-match-check.rs:14:22\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n-   |                      ^ pattern `_` not covered\n+   |                      ^ pattern `-2147483648i32..=-1i32` not covered\n \n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `-2147483648i32..=-1i32` not covered\n   --> $DIR/const-match-check.rs:18:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n-   |                       ^ pattern `_` not covered\n+   |                       ^ pattern `-2147483648i32..=-1i32` not covered\n \n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `-2147483648i32..=-1i32` not covered\n   --> $DIR/const-match-check.rs:23:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ pattern `_` not covered\n+   |                          ^ pattern `-2147483648i32..=-1i32` not covered\n \n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `-2147483648i32..=-1i32` not covered\n   --> $DIR/const-match-check.rs:29:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ pattern `_` not covered\n+   |                          ^ pattern `-2147483648i32..=-1i32` not covered\n \n error: aborting due to 4 previous errors\n "}, {"sha": "278864d6de9ec292fe336a7f5a1c619c70f91578", "filename": "src/test/ui/consts/const-pattern-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -19,8 +19,8 @@ use foo::d;\n const a: u8 = 2;\n \n fn main() {\n-    let a = 4; //~ ERROR refutable pattern in local binding: `_` not covered\n-    let c = 4; //~ ERROR refutable pattern in local binding: `_` not covered\n-    let d = 4; //~ ERROR refutable pattern in local binding: `_` not covered\n+    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n+    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n+    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n     fn f() {} // Check that the `NOTE`s still work with an item here (c.f. issue #35115).\n }"}, {"sha": "d9ad16cd0e8da91d96f1afe0220bec7841f9cbf6", "filename": "src/test/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,19 +1,19 @@\n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n   --> $DIR/const-pattern-irrefutable.rs:22:9\n    |\n-LL |     let a = 4; //~ ERROR refutable pattern in local binding: `_` not covered\n+LL |     let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n    |         ^ interpreted as a constant pattern, not new variable\n \n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n   --> $DIR/const-pattern-irrefutable.rs:23:9\n    |\n-LL |     let c = 4; //~ ERROR refutable pattern in local binding: `_` not covered\n+LL |     let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n    |         ^ interpreted as a constant pattern, not new variable\n \n-error[E0005]: refutable pattern in local binding: `_` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n   --> $DIR/const-pattern-irrefutable.rs:24:9\n    |\n-LL |     let d = 4; //~ ERROR refutable pattern in local binding: `_` not covered\n+LL |     let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n    |         ^ interpreted as a constant pattern, not new variable\n \n error: aborting due to 3 previous errors"}, {"sha": "020382d9fe17deb6f18c679662be91e6877bfc2f", "filename": "src/test/ui/exhaustive_integer_patterns.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(exhaustive_integer_patterns)]\n+#![feature(precise_pointer_size_matching)]\n #![feature(exclusive_range_pattern)]\n+\n #![deny(unreachable_patterns)]\n \n-use std::{char, usize, u8, u16, u32, u64, u128, isize, i8, i16, i32, i64, i128};\n+use std::{char, u8, u16, u32, u64, u128, i8, i16, i32, i64, i128};\n \n fn main() {\n     let x: u8 = 0;\n@@ -68,10 +69,6 @@ fn main() {\n         '\\u{E000}' ..= '\\u{10_FFFF}' => {}\n     }\n \n-    match 0usize {\n-        0 ..= usize::MAX => {} // ok\n-    }\n-\n     match 0u16 {\n         0 ..= u16::MAX => {} // ok\n     }\n@@ -88,10 +85,6 @@ fn main() {\n         0 ..= u128::MAX => {} // ok\n     }\n \n-    match 0isize {\n-        isize::MIN ..= isize::MAX => {} // ok\n-    }\n-\n     match 0i8 {\n         -128 ..= 127 => {} // ok\n     }"}, {"sha": "011e93683fb6e4bb7ebf0f12920d86442b6c34f5", "filename": "src/test/ui/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,83 +1,83 @@\n error: unreachable pattern\n-  --> $DIR/exhaustive_integer_patterns.rs:32:9\n+  --> $DIR/exhaustive_integer_patterns.rs:33:9\n    |\n LL |         200 => {} //~ ERROR unreachable pattern\n    |         ^^^\n    |\n note: lint level defined here\n-  --> $DIR/exhaustive_integer_patterns.rs:13:9\n+  --> $DIR/exhaustive_integer_patterns.rs:14:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error[E0004]: non-exhaustive patterns: `128u8..=255u8` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:37:11\n+  --> $DIR/exhaustive_integer_patterns.rs:38:11\n    |\n LL |     match x { //~ ERROR non-exhaustive patterns\n    |           ^ pattern `128u8..=255u8` not covered\n \n error[E0004]: non-exhaustive patterns: `11u8..=19u8`, `31u8..=34u8`, `36u8..=69u8` and 1 more not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:42:11\n+  --> $DIR/exhaustive_integer_patterns.rs:43:11\n    |\n LL |     match x { //~ ERROR non-exhaustive patterns\n    |           ^ patterns `11u8..=19u8`, `31u8..=34u8`, `36u8..=69u8` and 1 more not covered\n \n error: unreachable pattern\n-  --> $DIR/exhaustive_integer_patterns.rs:53:9\n+  --> $DIR/exhaustive_integer_patterns.rs:54:9\n    |\n LL |         -2..=20 => {} //~ ERROR unreachable pattern\n    |         ^^^^^^^\n \n error[E0004]: non-exhaustive patterns: `-128i8..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:50:11\n+  --> $DIR/exhaustive_integer_patterns.rs:51:11\n    |\n LL |     match x { //~ ERROR non-exhaustive patterns\n    |           ^ patterns `-128i8..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n \n error[E0004]: non-exhaustive patterns: `-128i8` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:99:11\n+  --> $DIR/exhaustive_integer_patterns.rs:92:11\n    |\n LL |     match 0i8 { //~ ERROR non-exhaustive patterns\n    |           ^^^ pattern `-128i8` not covered\n \n error[E0004]: non-exhaustive patterns: `0i16` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:107:11\n+  --> $DIR/exhaustive_integer_patterns.rs:100:11\n    |\n LL |     match 0i16 { //~ ERROR non-exhaustive patterns\n    |           ^^^^ pattern `0i16` not covered\n \n error[E0004]: non-exhaustive patterns: `128u8..=255u8` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:125:11\n+  --> $DIR/exhaustive_integer_patterns.rs:118:11\n    |\n LL |     match 0u8 { //~ ERROR non-exhaustive patterns\n    |           ^^^ pattern `128u8..=255u8` not covered\n \n error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=255u8, Some(_))` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:137:11\n+  --> $DIR/exhaustive_integer_patterns.rs:130:11\n    |\n LL |     match (0u8, Some(())) { //~ ERROR non-exhaustive patterns\n    |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=255u8, Some(_))` not covered\n \n error[E0004]: non-exhaustive patterns: `(126u8..=127u8, false)` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:142:11\n+  --> $DIR/exhaustive_integer_patterns.rs:135:11\n    |\n LL |     match (0u8, true) { //~ ERROR non-exhaustive patterns\n    |           ^^^^^^^^^^^ pattern `(126u8..=127u8, false)` not covered\n \n error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211455u128` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:162:11\n+  --> $DIR/exhaustive_integer_patterns.rs:155:11\n    |\n LL |     match 0u128 { //~ ERROR non-exhaustive patterns\n    |           ^^^^^ pattern `340282366920938463463374607431768211455u128` not covered\n \n error[E0004]: non-exhaustive patterns: `5u128..=340282366920938463463374607431768211455u128` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:166:11\n+  --> $DIR/exhaustive_integer_patterns.rs:159:11\n    |\n LL |     match 0u128 { //~ ERROR non-exhaustive patterns\n    |           ^^^^^ pattern `5u128..=340282366920938463463374607431768211455u128` not covered\n \n error[E0004]: non-exhaustive patterns: `0u128..=3u128` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:170:11\n+  --> $DIR/exhaustive_integer_patterns.rs:163:11\n    |\n LL |     match 0u128 { //~ ERROR non-exhaustive patterns\n    |           ^^^^^ pattern `0u128..=3u128` not covered"}, {"sha": "63d98f6b5eb64bab2500d544f851a365f9a6be64", "filename": "src/test/ui/feature-gate-exhaustive_integer_patterns.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -1,9 +0,0 @@\n-error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/feature-gate-exhaustive_integer_patterns.rs:13:11\n-   |\n-LL |     match x { //~ ERROR non-exhaustive patterns: `_` not covered\n-   |           ^ pattern `_` not covered\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0004`."}, {"sha": "1208552d256376b26926cc98dc462502dd81619e", "filename": "src/test/ui/feature-gates/feature-gate-precise_pointer_size_matching.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1,14 @@\n+#![feature(exclusive_range_pattern)]\n+\n+use std::usize::MAX;\n+\n+fn main() {\n+    match 0usize { //~ERROR non-exhaustive patterns: `_` not covered\n+        0..=MAX => {}\n+    }\n+\n+    match 0isize { //~ERROR non-exhaustive patterns: `_` not covered\n+        1..=20 => {}\n+        -5..3 => {}\n+    }\n+}"}, {"sha": "5806f6f039157cbeaf91ee0b5f82208af7aa8054", "filename": "src/test/ui/feature-gates/feature-gate-precise_pointer_size_matching.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1,15 @@\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/feature-gate-precise_pointer_size_matching.rs:6:11\n+   |\n+LL |     match 0usize { //~ERROR non-exhaustive patterns: `_` not covered\n+   |           ^^^^^^ pattern `_` not covered\n+\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/feature-gate-precise_pointer_size_matching.rs:10:11\n+   |\n+LL |     match 0isize { //~ERROR non-exhaustive patterns: `_` not covered\n+   |           ^^^^^^ pattern `_` not covered\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "9b19fc80e2bd67ce7db2f633a9c5a9c0b1bcf805", "filename": "src/test/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&_` not covered\n+error[E0005]: refutable pattern in `for` loop binding: `&-2147483648i32..=0i32` not covered\n   --> $DIR/for-loop-refutable-pattern-error-message.rs:12:9\n    |\n LL |     for &1 in [1].iter() {} //~ ERROR refutable pattern in `for` loop binding\n-   |         ^^ pattern `&_` not covered\n+   |         ^^ pattern `&-2147483648i32..=0i32` not covered\n \n error: aborting due to previous error\n "}, {"sha": "ad895b448dd2015ff720aea2e1051cbc5813f79a", "filename": "src/test/ui/match/match-non-exhaustive.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fmatch%2Fmatch-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fmatch%2Fmatch-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-non-exhaustive.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `_` not covered\n+error[E0004]: non-exhaustive patterns: `-2147483648i32..=0i32` and `2i32..=2147483647i32` not covered\n   --> $DIR/match-non-exhaustive.rs:12:11\n    |\n LL |     match 0 { 1 => () } //~ ERROR non-exhaustive patterns\n-   |           ^ pattern `_` not covered\n+   |           ^ patterns `-2147483648i32..=0i32` and `2i32..=2147483647i32` not covered\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/match-non-exhaustive.rs:13:11"}, {"sha": "588fecbf10dd50ff7cdb36a205247358804d0c21", "filename": "src/test/ui/non-exhaustive/non-exhaustive-float-range-match.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-float-range-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-float-range-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-float-range-match.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1,13 @@\n+#![allow(illegal_floating_point_literal_pattern)]\n+#![deny(unreachable_patterns)]\n+\n+fn main() {\n+    match 0.0 {\n+      0.0..=1.0 => {}\n+      _ => {} // ok\n+    }\n+\n+    match 0.0 { //~ ERROR non-exhaustive patterns\n+      0.0..=1.0 => {}\n+    }\n+}"}, {"sha": "2e285afb3804e614b2d3ca24c9a4b0ae0193d0bc", "filename": "src/test/ui/non-exhaustive/non-exhaustive-float-range-match.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-float-range-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-float-range-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-float-range-match.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1,9 @@\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/non-exhaustive-float-range-match.rs:10:11\n+   |\n+LL |     match 0.0 { //~ ERROR non-exhaustive patterns\n+   |           ^^^ pattern `_` not covered\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "99a0c5d66266030aa5189b859a6bbc545e4df5ed", "filename": "src/test/ui/non-exhaustive/non-exhaustive-match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -22,7 +22,8 @@ fn main() {\n     match Some(10) { //~ ERROR non-exhaustive patterns: `Some(_)` not covered\n       None => {}\n     }\n-    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, _)` not covered\n+    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, -2147483648i32..=3i32)`\n+                      //  and `(_, _, 5i32..=2147483647i32)` not covered\n       (_, _, 4) => {}\n     }\n     match (t::a, t::a) { //~ ERROR non-exhaustive patterns: `(a, a)` not covered"}, {"sha": "d3703a4445499358bb566d55ade6adb38d6566ce", "filename": "src/test/ui/non-exhaustive/non-exhaustive-match.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -16,32 +16,32 @@ error[E0004]: non-exhaustive patterns: `Some(_)` not covered\n LL |     match Some(10) { //~ ERROR non-exhaustive patterns: `Some(_)` not covered\n    |           ^^^^^^^^ pattern `Some(_)` not covered\n \n-error[E0004]: non-exhaustive patterns: `(_, _, _)` not covered\n+error[E0004]: non-exhaustive patterns: `(_, _, -2147483648i32..=3i32)` and `(_, _, 5i32..=2147483647i32)` not covered\n   --> $DIR/non-exhaustive-match.rs:25:11\n    |\n-LL |     match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, _)` not covered\n-   |           ^^^^^^^^^ pattern `(_, _, _)` not covered\n+LL |     match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, -2147483648i32..=3i32)`\n+   |           ^^^^^^^^^ patterns `(_, _, -2147483648i32..=3i32)` and `(_, _, 5i32..=2147483647i32)` not covered\n \n error[E0004]: non-exhaustive patterns: `(a, a)` not covered\n-  --> $DIR/non-exhaustive-match.rs:28:11\n+  --> $DIR/non-exhaustive-match.rs:29:11\n    |\n LL |     match (t::a, t::a) { //~ ERROR non-exhaustive patterns: `(a, a)` not covered\n    |           ^^^^^^^^^^^^ pattern `(a, a)` not covered\n \n error[E0004]: non-exhaustive patterns: `b` not covered\n-  --> $DIR/non-exhaustive-match.rs:32:11\n+  --> $DIR/non-exhaustive-match.rs:33:11\n    |\n LL |     match t::a { //~ ERROR non-exhaustive patterns: `b` not covered\n    |           ^^^^ pattern `b` not covered\n \n error[E0004]: non-exhaustive patterns: `[]` not covered\n-  --> $DIR/non-exhaustive-match.rs:43:11\n+  --> $DIR/non-exhaustive-match.rs:44:11\n    |\n LL |     match *vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n    |           ^^^^ pattern `[]` not covered\n \n error[E0004]: non-exhaustive patterns: `[_, _, _, _]` not covered\n-  --> $DIR/non-exhaustive-match.rs:56:11\n+  --> $DIR/non-exhaustive-match.rs:57:11\n    |\n LL |     match *vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n    |           ^^^^ pattern `[_, _, _, _]` not covered"}, {"sha": "759b63b188b35d379dcbfb392de88da61a12fae5", "filename": "src/test/ui/precise_pointer_size_matching.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1,33 @@\n+// normalize-stderr-32bit: \"-2147483648isize\" -> \"$$ISIZE_MIN\"\n+// normalize-stderr-64bit: \"-9223372036854775808isize\" -> \"$$ISIZE_MIN\"\n+// normalize-stderr-32bit: \"2147483647isize\" -> \"$$ISIZE_MAX\"\n+// normalize-stderr-64bit: \"9223372036854775807isize\" -> \"$$ISIZE_MAX\"\n+// normalize-stderr-32bit: \"4294967295usize\" -> \"$$USIZE_MAX\"\n+// normalize-stderr-64bit: \"18446744073709551615usize\" -> \"$$USIZE_MAX\"\n+\n+#![feature(precise_pointer_size_matching)]\n+#![feature(exclusive_range_pattern)]\n+\n+#![deny(unreachable_patterns)]\n+\n+use std::{usize, isize};\n+\n+fn main() {\n+    match 0isize {\n+        isize::MIN ..= isize::MAX => {} // ok\n+    }\n+\n+    match 0usize {\n+        0 ..= usize::MAX => {} // ok\n+    }\n+\n+    match 0isize { //~ ERROR non-exhaustive patterns\n+        1 ..= 8 => {}\n+        -5 ..= 20 => {}\n+    }\n+\n+    match 0usize { //~ ERROR non-exhaustive patterns\n+        1 ..= 8 => {}\n+        5 ..= 20 => {}\n+    }\n+}"}, {"sha": "4acbec6c7ff1a4aaacd55e5bd04583534592a7df", "filename": "src/test/ui/precise_pointer_size_matching.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -0,0 +1,15 @@\n+error[E0004]: non-exhaustive patterns: `$ISIZE_MIN..=-6isize` and `21isize..=$ISIZE_MAX` not covered\n+  --> $DIR/precise_pointer_size_matching.rs:24:11\n+   |\n+LL |     match 0isize { //~ ERROR non-exhaustive patterns\n+   |           ^^^^^^ patterns `$ISIZE_MIN..=-6isize` and `21isize..=$ISIZE_MAX` not covered\n+\n+error[E0004]: non-exhaustive patterns: `0usize` and `21usize..=$USIZE_MAX` not covered\n+  --> $DIR/precise_pointer_size_matching.rs:29:11\n+   |\n+LL |     match 0usize { //~ ERROR non-exhaustive patterns\n+   |           ^^^^^^ patterns `0usize` and `21usize..=$USIZE_MAX` not covered\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "a140e421a5706e811d8760724db4afae47bef5dd", "filename": "src/test/ui/refutable-pattern-errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -14,5 +14,5 @@ fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n \n fn main() {\n     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: `(_, _)` not covered\n+    //~^ ERROR refutable pattern in local binding: `(-2147483648i32..=0i32, _)` not covered\n }"}, {"sha": "42aa572789522c86b631f6556c620684e7b331de", "filename": "src/test/ui/refutable-pattern-errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -4,11 +4,11 @@ error[E0005]: refutable pattern in function argument: `(_, _)` not covered\n LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n \n-error[E0005]: refutable pattern in local binding: `(_, _)` not covered\n+error[E0005]: refutable pattern in local binding: `(-2147483648i32..=0i32, _)` not covered\n   --> $DIR/refutable-pattern-errors.rs:16:9\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-   |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n+   |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(-2147483648i32..=0i32, _)` not covered\n \n error: aborting due to 2 previous errors\n "}, {"sha": "377c85fef490a7d34a8b0077e87dee85d54208c8", "filename": "src/test/ui/rust-2018/dyn-trait-compatibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n \n type A0 = dyn;\n-type A1 = dyn::dyn; //~ERROR expected identifier, found reserved keyword\n+type A1 = dyn::dyn; //~ERROR expected identifier, found keyword `dyn`\n type A2 = dyn<dyn, dyn>; //~ERROR expected identifier, found `<`\n type A3 = dyn<<dyn as dyn>::dyn>;\n "}, {"sha": "bd72f9c6786b2a8ca2d80dc1e7f94360a8bc825b", "filename": "src/test/ui/rust-2018/dyn-trait-compatibility.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -1,8 +1,8 @@\n-error: expected identifier, found reserved keyword `dyn`\n+error: expected identifier, found keyword `dyn`\n   --> $DIR/dyn-trait-compatibility.rs:4:16\n    |\n-LL | type A1 = dyn::dyn; //~ERROR expected identifier, found reserved keyword\n-   |                ^^^ expected identifier, found reserved keyword\n+LL | type A1 = dyn::dyn; //~ERROR expected identifier, found keyword `dyn`\n+   |                ^^^ expected identifier, found keyword\n \n error: expected identifier, found `<`\n   --> $DIR/dyn-trait-compatibility.rs:5:14"}, {"sha": "f7c30df9f3ebb86d85c329188421abaed6422b5d", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/367e783e6f66a4dba32decdc68a262953d2f3f1b/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=367e783e6f66a4dba32decdc68a262953d2f3f1b", "patch": "@@ -259,6 +259,7 @@ function main(argv) {\n                                'exports.QUERY = QUERY;exports.EXPECTED = EXPECTED;');\n         const expected = loadedFile.EXPECTED;\n         const query = loadedFile.QUERY;\n+        const filter_crate = loadedFile.FILTER_CRATE;\n         const ignore_order = loadedFile.ignore_order;\n         const exact_check = loadedFile.exact_check;\n         const should_fail = loadedFile.should_fail;"}]}