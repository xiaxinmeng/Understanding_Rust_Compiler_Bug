{"sha": "03609e5a5e8bdca9452327d44e25407ce888d0bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNjA5ZTVhNWU4YmRjYTk0NTIzMjdkNDRlMjU0MDdjZTg4OGQwYmI=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-04-21T04:59:12Z"}, "committer": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-04-28T21:45:36Z"}, "message": "Deprecate the rev_iter pattern in all places where a DoubleEndedIterator is provided (everywhere but treemap)\n\nThis commit deprecates rev_iter, mut_rev_iter, move_rev_iter everywhere (except treemap) and also\ndeprecates related functions like rsplit, rev_components, and rev_str_components. In every case,\nthese functions can be replaced with the non-reversed form followed by a call to .rev(). To make this\nmore concrete, a translation table for all functional changes necessary follows:\n\n* container.rev_iter() -> container.iter().rev()\n* container.mut_rev_iter() -> container.mut_iter().rev()\n* container.move_rev_iter() -> container.move_iter().rev()\n* sliceorstr.rsplit(sep) -> sliceorstr.split(sep).rev()\n* path.rev_components() -> path.components().rev()\n* path.rev_str_components() -> path.str_components().rev()\n\nIn terms of the type system, this change also deprecates any specialized reversed iterator types (except\nin treemap), opting instead to use Rev directly if any type annotations are needed. However, since\nmethods directly returning reversed iterators are now discouraged, the need for such annotations should\nbe small. However, in those cases, the general pattern for conversion is to take whatever follows Rev in\nthe original reversed name and surround it with Rev<>:\n\n* RevComponents<'a> -> Rev<Components<'a>>\n* RevStrComponents<'a> -> Rev<StrComponents<'a>>\n* RevItems<'a, T> -> Rev<Items<'a, T>>\n* etc.\n\nThe reasoning behind this change is that it makes the standard API much simpler without reducing readability,\nperformance, or power. The presence of functions such as rev_iter adds more boilerplate code to libraries\n(all of which simply call .iter().rev()), clutters up the documentation, and only helps code by saving two\ncharacters. Additionally, the numerous type synonyms that were used to make the type signatures look nice\nlike RevItems add even more boilerplate and clutter up the docs even more. With this change, all that cruft\ngoes away.\n\n[breaking-change]", "tree": {"sha": "ffef048a962111a82bdc86f7b060a8d2fa2c96f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffef048a962111a82bdc86f7b060a8d2fa2c96f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03609e5a5e8bdca9452327d44e25407ce888d0bb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03609e5a5e8bdca9452327d44e25407ce888d0bb", "html_url": "https://github.com/rust-lang/rust/commit/03609e5a5e8bdca9452327d44e25407ce888d0bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03609e5a5e8bdca9452327d44e25407ce888d0bb/comments", "author": null, "committer": null, "parents": [{"sha": "f58a8c9d760aead49e138fa8045e229a47217644", "url": "https://api.github.com/repos/rust-lang/rust/commits/f58a8c9d760aead49e138fa8045e229a47217644", "html_url": "https://github.com/rust-lang/rust/commit/f58a8c9d760aead49e138fa8045e229a47217644"}], "stats": {"total": 283, "additions": 148, "deletions": 135}, "files": [{"sha": "4fb75111f3b47e057aff68fced570abb7992c8ba", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -120,12 +120,13 @@ differently.\n Containers implement iteration over the contained elements by returning an\n iterator object. For example, vector slices several iterators available:\n \n-* `iter()` and `rev_iter()`, for immutable references to the elements\n-* `mut_iter()` and `mut_rev_iter()`, for mutable references to the elements\n-* `move_iter()` and `move_rev_iter()`, to move the elements out by-value\n+* `iter()` for immutable references to the elements\n+* `mut_iter()` for mutable references to the elements\n+* `move_iter()` to move the elements out by-value\n \n A typical mutable container will implement at least `iter()`, `mut_iter()` and\n-`move_iter()` along with the reverse variants if it maintains an order.\n+`move_iter()`. If it maintains an order, the returned iterators will be\n+`DoubleEndedIterator`s, which are described below.\n \n ### Freezing\n \n@@ -265,7 +266,7 @@ Iterators offer generic conversion to containers with the `collect` adaptor:\n \n ~~~\n let xs = [0, 1, 1, 2, 3, 5, 8];\n-let ys = xs.rev_iter().skip(1).map(|&x| x * 2).collect::<~[int]>();\n+let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<~[int]>();\n assert_eq!(ys, ~[10, 6, 4, 2, 2, 0]);\n ~~~\n \n@@ -358,9 +359,6 @@ for &x in it.rev() {\n }\n ~~~\n \n-The `rev_iter` and `mut_rev_iter` methods on vectors just return an inverted\n-version of the standard immutable and mutable vector iterators.\n-\n The `chain`, `map`, `filter`, `filter_map` and `inspect` adaptors are\n `DoubleEndedIterator` implementations if the underlying iterators are.\n "}, {"sha": "424eb54d8da36633ed7d10a00f5ef2a2c076dc54", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -425,6 +425,7 @@ impl Bitv {\n     }\n \n     #[inline]\n+    #[deprecated = \"replaced by .iter().rev()\"]\n     pub fn rev_iter<'a>(&'a self) -> Rev<Bits<'a>> {\n         self.iter().rev()\n     }"}, {"sha": "df1bc28508c15a445b5514a3ce00d05f4bd8978d", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -370,8 +370,8 @@ impl<T> DList<T> {\n         Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n-    /// Provide a reverse iterator\n     #[inline]\n+    #[deprecated = \"replaced by .iter().rev()\"]\n     pub fn rev_iter<'a>(&'a self) -> Rev<Items<'a, T>> {\n         self.iter().rev()\n     }\n@@ -390,8 +390,9 @@ impl<T> DList<T> {\n             list: self\n         }\n     }\n-    /// Provide a reverse iterator with mutable references\n+\n     #[inline]\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n     pub fn mut_rev_iter<'a>(&'a mut self) -> Rev<MutItems<'a, T>> {\n         self.mut_iter().rev()\n     }\n@@ -403,8 +404,8 @@ impl<T> DList<T> {\n         MoveItems{list: self}\n     }\n \n-    /// Consume the list into an iterator yielding elements by value, in reverse\n     #[inline]\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n     pub fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n         self.move_iter().rev()\n     }\n@@ -849,13 +850,13 @@ mod tests {\n     #[test]\n     fn test_rev_iter() {\n         let m = generate_test();\n-        for (i, elt) in m.rev_iter().enumerate() {\n+        for (i, elt) in m.iter().rev().enumerate() {\n             assert_eq!((6 - i) as int, *elt);\n         }\n         let mut n = DList::new();\n-        assert_eq!(n.rev_iter().next(), None);\n+        assert_eq!(n.iter().rev().next(), None);\n         n.push_front(4);\n-        let mut it = n.rev_iter();\n+        let mut it = n.iter().rev();\n         assert_eq!(it.size_hint(), (1, Some(1)));\n         assert_eq!(it.next().unwrap(), &4);\n         assert_eq!(it.size_hint(), (0, Some(0)));\n@@ -958,13 +959,13 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iter() {\n         let mut m = generate_test();\n-        for (i, elt) in m.mut_rev_iter().enumerate() {\n+        for (i, elt) in m.mut_iter().rev().enumerate() {\n             assert_eq!((6-i) as int, *elt);\n         }\n         let mut n = DList::new();\n-        assert!(n.mut_rev_iter().next().is_none());\n+        assert!(n.mut_iter().rev().next().is_none());\n         n.push_front(4);\n-        let mut it = n.mut_rev_iter();\n+        let mut it = n.mut_iter().rev();\n         assert!(it.next().is_some());\n         assert!(it.next().is_none());\n     }\n@@ -1164,15 +1165,15 @@ mod tests {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n-            assert!(m.rev_iter().len() == 128);\n+            assert!(m.iter().rev().len() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n-            assert!(m.mut_rev_iter().len() == 128);\n+            assert!(m.mut_iter().rev().len() == 128);\n         })\n     }\n }"}, {"sha": "dd1db85fc20c430f149deca18bfc5c7568807409", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -382,7 +382,7 @@ mod tests {\n     fn test_from_iter() {\n         let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n \n-        let mut q: PriorityQueue<uint> = xs.as_slice().rev_iter().map(|&x| x).collect();\n+        let mut q: PriorityQueue<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop(), x);"}, {"sha": "12e4fa8b51f24ed1d508be8a277fb6293b1afcb6", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -190,7 +190,7 @@ impl<T> RingBuf<T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n \n-    /// Back-to-front iterator.\n+    #[deprecated = \"replaced by .iter().rev()\"]\n     pub fn rev_iter<'a>(&'a self) -> Rev<Items<'a, T>> {\n         self.iter().rev()\n     }\n@@ -221,7 +221,7 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Back-to-front iterator which returns mutable values.\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n     pub fn mut_rev_iter<'a>(&'a mut self) -> Rev<MutItems<'a, T>> {\n         self.mut_iter().rev()\n     }\n@@ -702,31 +702,31 @@ mod tests {\n     #[test]\n     fn test_rev_iter() {\n         let mut d = RingBuf::new();\n-        assert_eq!(d.rev_iter().next(), None);\n+        assert_eq!(d.iter().rev().next(), None);\n \n         for i in range(0, 5) {\n             d.push_back(i);\n         }\n-        assert_eq!(d.rev_iter().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0]);\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0]);\n \n         for i in range(6, 9) {\n             d.push_front(i);\n         }\n-        assert_eq!(d.rev_iter().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0,&6,&7,&8]);\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n \n     #[test]\n     fn test_mut_rev_iter_wrap() {\n         let mut d = RingBuf::with_capacity(3);\n-        assert!(d.mut_rev_iter().next().is_none());\n+        assert!(d.mut_iter().rev().next().is_none());\n \n         d.push_back(1);\n         d.push_back(2);\n         d.push_back(3);\n         assert_eq!(d.pop_front(), Some(1));\n         d.push_back(4);\n \n-        assert_eq!(d.mut_rev_iter().map(|x| *x).collect::<Vec<int>>(),\n+        assert_eq!(d.mut_iter().rev().map(|x| *x).collect::<Vec<int>>(),\n                    vec!(4, 3, 2));\n     }\n \n@@ -756,19 +756,19 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iter() {\n         let mut d = RingBuf::new();\n-        assert!(d.mut_rev_iter().next().is_none());\n+        assert!(d.mut_iter().rev().next().is_none());\n \n         for i in range(0u, 3) {\n             d.push_front(i);\n         }\n \n-        for (i, elt) in d.mut_rev_iter().enumerate() {\n+        for (i, elt) in d.mut_iter().rev().enumerate() {\n             assert_eq!(*elt, i);\n             *elt = i;\n         }\n \n         {\n-            let mut it = d.mut_rev_iter();\n+            let mut it = d.mut_iter().rev();\n             assert_eq!(*it.next().unwrap(), 0);\n             assert_eq!(*it.next().unwrap(), 1);\n             assert_eq!(*it.next().unwrap(), 2);"}, {"sha": "5bfe04c7e512ccaa4f9c7b1f15ee8af6cde2f7c6", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -142,16 +142,13 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// An iterator visiting all key-value pairs in descending order by the keys.\n-    /// Iterator element type is (uint, &'r V)\n-    pub fn rev_iter<'r>(&'r self) -> RevEntries<'r, V> {\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    pub fn rev_iter<'r>(&'r self) -> Rev<Entries<'r, V>> {\n         self.iter().rev()\n     }\n \n-    /// An iterator visiting all key-value pairs in descending order by the keys,\n-    /// with mutable references to the values\n-    /// Iterator element type is (uint, &'r mut V)\n-    pub fn mut_rev_iter<'r>(&'r mut self) -> RevMutEntries <'r, V> {\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    pub fn mut_rev_iter<'r>(&'r mut self) -> Rev<MutEntries<'r, V>> {\n         self.mut_iter().rev()\n     }\n \n@@ -246,6 +243,7 @@ pub struct Entries<'a, T> {\n \n iterator!(impl Entries -> (uint, &'a T), get_ref)\n double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n+#[deprecated = \"replaced by Rev<Entries<'a, T>>\"]\n pub type RevEntries<'a, T> = Rev<Entries<'a, T>>;\n \n pub struct MutEntries<'a, T> {\n@@ -256,6 +254,7 @@ pub struct MutEntries<'a, T> {\n \n iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n double_ended_iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n+#[deprecated = \"replaced by Rev<MutEntries<'a, T>\"]\n pub type RevMutEntries<'a, T> = Rev<MutEntries<'a, T>>;\n \n #[cfg(test)]\n@@ -387,9 +386,9 @@ mod test_map {\n         assert!(m.insert(10, 11));\n \n         assert_eq!(m.iter().size_hint(), (0, Some(11)));\n-        assert_eq!(m.rev_iter().size_hint(), (0, Some(11)));\n+        assert_eq!(m.iter().rev().size_hint(), (0, Some(11)));\n         assert_eq!(m.mut_iter().size_hint(), (0, Some(11)));\n-        assert_eq!(m.mut_rev_iter().size_hint(), (0, Some(11)));\n+        assert_eq!(m.mut_iter().rev().size_hint(), (0, Some(11)));\n     }\n \n     #[test]\n@@ -425,7 +424,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        let mut it = m.rev_iter();\n+        let mut it = m.iter().rev();\n         assert_eq!(it.next().unwrap(), (10, &11));\n         assert_eq!(it.next().unwrap(), (6, &10));\n         assert_eq!(it.next().unwrap(), (3, &5));\n@@ -444,7 +443,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        for (k, v) in m.mut_rev_iter() {\n+        for (k, v) in m.mut_iter().rev() {\n             *v += k as int;\n         }\n "}, {"sha": "3a0d81070fef0741016d89ddf9f534398ecbf46c", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -395,7 +395,7 @@ impl<T> TrieNode<T> {\n \n impl<T> TrieNode<T> {\n     fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n-        for elt in self.children.rev_iter() {\n+        for elt in self.children.iter().rev() {\n             match *elt {\n                 Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },"}, {"sha": "083fb1e794b6c09d27b96418c2ab088a4c738d79", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -439,7 +439,7 @@ impl Integer for BigUint {\n             let bn = *b.data.last().unwrap();\n             let mut d = Vec::with_capacity(an.len());\n             let mut carry = 0;\n-            for elt in an.rev_iter() {\n+            for elt in an.iter().rev() {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 assert!(di < BigDigit::base);\n@@ -668,7 +668,7 @@ impl ToStrRadix for BigUint {\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return \"0\".to_owned() }\n             let mut s = StrBuf::with_capacity(v.len() * l);\n-            for n in v.rev_iter() {\n+            for n in v.iter().rev() {\n                 let ss = (*n as uint).to_str_radix(radix);\n                 s.push_str(\"0\".repeat(l - ss.len()));\n                 s.push_str(ss);\n@@ -2187,7 +2187,7 @@ mod bigint_tests {\n     fn test_cmp() {\n         let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n         let mut nums = Vec::new();\n-        for s in vs.rev_iter() {\n+        for s in vs.iter().rev() {\n             nums.push(BigInt::from_slice(Minus, *s));\n         }\n         nums.push(Zero::zero());"}, {"sha": "070e45d92c4de161e92bb963a330dacad9415829", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -927,7 +927,7 @@ impl<'a> Liveness<'a> {\n \n     fn propagate_through_exprs(&mut self, exprs: &[@Expr], succ: LiveNode)\n                                -> LiveNode {\n-        exprs.rev_iter().fold(succ, |succ, expr| {\n+        exprs.iter().rev().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         })\n     }"}, {"sha": "8b3794aff723cd87ddaa46b9f8a8790eee60f187", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -94,7 +94,7 @@ fn lookup_vtables(vcx: &VtableContext,\n     let mut result: Vec<vtable_param_res> =\n         substs.tps.iter()\n         .rev()\n-        .zip(type_param_defs.rev_iter())\n+        .zip(type_param_defs.iter().rev())\n         .map(|(ty, def)|\n             lookup_vtables_for_param(vcx, span, Some(substs),\n                                      &*def.bounds, *ty, is_early))"}, {"sha": "f4c21519169327a872ae3ebf65d3dfb4d1a3e32d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -304,7 +304,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n         None => {}\n     }\n     if default_passes {\n-        for name in DEFAULT_PASSES.rev_iter() {\n+        for name in DEFAULT_PASSES.iter().rev() {\n             passes.unshift(name.to_owned());\n         }\n     }"}, {"sha": "2d23bebb21be721a9c374f8d19bbd4d2055738be", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -1446,7 +1446,7 @@ impl ::Decoder<Error> for Decoder {\n                 };\n                 match o.pop(&\"fields\".to_owned()) {\n                     Some(List(l)) => {\n-                        for field in l.move_rev_iter() {\n+                        for field in l.move_iter().rev() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n@@ -1557,7 +1557,7 @@ impl ::Decoder<Error> for Decoder {\n         debug!(\"read_seq()\");\n         let list = try!(expect!(self.pop(), List));\n         let len = list.len();\n-        for v in list.move_rev_iter() {\n+        for v in list.move_iter().rev() {\n             self.stack.push(v);\n         }\n         f(self, len)"}, {"sha": "d69e9b448beb9a9e3258efd423bdb95b9ab75dcb", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -29,12 +29,14 @@ use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> = Splits<'a, u8>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n+#[deprecated = \"replaced by Rev<Components<'a>>\"]\n pub type RevComponents<'a> = Rev<Components<'a>>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n pub type StrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n                                        Components<'a>>;\n /// Iterator that yields components of a Path in reverse as Option<&str>\n+#[deprecated = \"replaced by Rev<StrComponents<'a>>\"]\n pub type RevStrComponents<'a> = Rev<StrComponents<'a>>;\n \n /// Represents a POSIX file path\n@@ -307,8 +309,8 @@ impl GenericPath for Path {\n \n     fn ends_with_path(&self, child: &Path) -> bool {\n         if !child.is_relative() { return false; }\n-        let mut selfit = self.rev_components();\n-        let mut childit = child.rev_components();\n+        let mut selfit = self.components().rev();\n+        let mut childit = child.components().rev();\n         loop {\n             match (selfit.next(), childit.next()) {\n                 (Some(a), Some(b)) => if a != b { return false; },\n@@ -395,7 +397,8 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse.\n     /// See components() for details.\n-    pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n+    #[deprecated = \"replaced by .components().rev()\"]\n+    pub fn rev_components<'a>(&'a self) -> Rev<Components<'a>> {\n         self.components().rev()\n     }\n \n@@ -407,7 +410,8 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse as Option<&str>.\n     /// See components() for details.\n-    pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n+    #[deprecated = \"replaced by .str_components().rev()\"]\n+    pub fn rev_str_components<'a>(&'a self) -> Rev<StrComponents<'a>> {\n         self.str_components().rev()\n     }\n }\n@@ -1183,7 +1187,7 @@ mod tests {\n                     let exps = exp.iter().map(|x| x.as_bytes()).collect::<Vec<&[u8]>>();\n                     assert!(comps == exps, \"components: Expected {:?}, found {:?}\",\n                             comps, exps);\n-                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n+                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exps = exps.move_iter().rev().collect::<Vec<&[u8]>>();\n                     assert!(comps == exps, \"rev_components: Expected {:?}, found {:?}\",\n                             comps, exps);\n@@ -1195,8 +1199,8 @@ mod tests {\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&[u8]>>();\n+                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n                     assert_eq!(comps, exp)\n                 }\n             )\n@@ -1227,8 +1231,8 @@ mod tests {\n                     let comps = path.str_components().collect::<Vec<Option<&str>>>();\n                     let exp: &[Option<&str>] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_str_components().collect::<Vec<Option<&str>>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<Option<&str>>>();\n+                    let comps = path.str_components().rev().collect::<Vec<Option<&str>>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<Option<&str>>>();\n                     assert_eq!(comps, exp);\n                 }\n             )"}, {"sha": "758a76167cdef961367ed20d43c43aef06b9cd8b", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -37,12 +37,14 @@ pub type StrComponents<'a> = Map<'a, &'a str, Option<&'a str>,\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n+#[deprecated = \"replaced by Rev<StrComponents<'a>>\"]\n pub type RevStrComponents<'a> = Rev<StrComponents<'a>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> = Map<'a, Option<&'a str>, &'a [u8],\n                                     StrComponents<'a>>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n+#[deprecated = \"replaced by Rev<Components<'a>>\"]\n pub type RevComponents<'a> = Rev<Components<'a>>;\n \n /// Represents a Windows path\n@@ -631,7 +633,8 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse as an Option<&str>\n     /// See str_components() for details.\n-    pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n+    #[deprecated = \"replaced by .str_components().rev()\"]\n+    pub fn rev_str_components<'a>(&'a self) -> Rev<StrComponents<'a>> {\n         self.str_components().rev()\n     }\n \n@@ -647,7 +650,8 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse as a &[u8].\n     /// See str_components() for details.\n-    pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n+    #[deprecated = \"replaced by .components().rev()\"]\n+    pub fn rev_components<'a>(&'a self) -> Rev<Components<'a>> {\n         self.components().rev()\n     }\n \n@@ -2233,9 +2237,9 @@ mod tests {\n                                 .collect::<Vec<&str>>();\n                     let exp: &[&str] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_str_components().map(|x|x.unwrap())\n+                    let comps = path.str_components().rev().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&str>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&str>>();\n                     assert_eq!(comps, exp);\n                 }\n             );\n@@ -2245,9 +2249,9 @@ mod tests {\n                     let comps = path.str_components().map(|x|x.unwrap()).collect::<Vec<&str>>();\n                     let exp: &[&str] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_str_components().map(|x|x.unwrap())\n+                    let comps = path.str_components().rev().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&str>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&str>>();\n                     assert_eq!(comps, exp);\n                 }\n             )\n@@ -2302,8 +2306,8 @@ mod tests {\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&[u8]>>();\n+                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n                     assert_eq!(comps, exp);\n                 }\n             )"}, {"sha": "64f6b59be24d267ba7a1997ef92321b1fe9ebf4e", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -81,8 +81,6 @@ for &x in numbers.iter() {\n }\n  ```\n \n-* `.rev_iter()` returns an iterator with the same values as `.iter()`,\n-  but going in the reverse order, starting with the back element.\n * `.mut_iter()` returns an iterator that allows modifying each value.\n * `.move_iter()` converts an owned vector into an iterator that\n   moves out a value from the vector each iteration.\n@@ -731,7 +729,8 @@ pub trait ImmutableVector<'a, T> {\n     /// Returns an iterator over the vector\n     fn iter(self) -> Items<'a, T>;\n     /// Returns a reversed iterator over a vector\n-    fn rev_iter(self) -> RevItems<'a, T>;\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    fn rev_iter(self) -> Rev<Items<'a, T>>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.  The matched element\n     /// is not contained in the subslices.\n@@ -745,6 +744,7 @@ pub trait ImmutableVector<'a, T> {\n     /// separated by elements that match `pred`. This starts at the\n     /// end of the vector and works backwards.  The matched element is\n     /// not contained in the subslices.\n+    #[deprecated = \"replaced by .split(pred).rev()\"]\n     fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n@@ -923,7 +923,8 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn rev_iter(self) -> RevItems<'a, T> {\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    fn rev_iter(self) -> Rev<Items<'a, T>> {\n         self.iter().rev()\n     }\n \n@@ -946,6 +947,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n+    #[deprecated = \"replaced by .split(pred).rev()\"]\n     fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>> {\n         self.split(pred).rev()\n     }\n@@ -1167,7 +1169,8 @@ pub trait OwnedVector<T> {\n     fn move_iter(self) -> MoveItems<T>;\n     /// Creates a consuming iterator that moves out of the vector in\n     /// reverse order.\n-    fn move_rev_iter(self) -> RevMoveItems<T>;\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n+    fn move_rev_iter(self) -> Rev<MoveItems<T>>;\n \n     /**\n      * Partitions the vector into two vectors `(A,B)`, where all\n@@ -1187,7 +1190,8 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn move_rev_iter(self) -> RevMoveItems<T> {\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n+    fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n         self.move_iter().rev()\n     }\n \n@@ -1442,7 +1446,8 @@ pub trait MutableVector<'a, T> {\n     fn mut_last(self) -> Option<&'a mut T>;\n \n     /// Returns a reversed iterator that allows modifying each value\n-    fn mut_rev_iter(self) -> RevMutItems<'a, T>;\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>>;\n \n     /// Returns an iterator over the mutable subslices of the vector\n     /// which are separated by elements that match `pred`.  The\n@@ -1714,7 +1719,8 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn mut_rev_iter(self) -> RevMutItems<'a, T> {\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>> {\n         self.mut_iter().rev()\n     }\n \n@@ -2129,6 +2135,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n }\n \n iterator!{struct Items -> *T, &'a T}\n+#[deprecated = \"replaced by Rev<Items<'a, T>>\"]\n pub type RevItems<'a, T> = Rev<Items<'a, T>>;\n \n impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n@@ -2139,6 +2146,7 @@ impl<'a, T> Clone for Items<'a, T> {\n }\n \n iterator!{struct MutItems -> *mut T, &'a mut T}\n+#[deprecated = \"replaced by Rev<MutItems<'a, T>>\"]\n pub type RevMutItems<'a, T> = Rev<MutItems<'a, T>>;\n \n /// An iterator over the subslices of the vector which are separated\n@@ -2299,6 +2307,7 @@ impl<T> Drop for MoveItems<T> {\n }\n \n /// An iterator that moves out of a vector in reverse order.\n+#[deprecated = \"replaced by Rev<MoveItems<'a, T>>\"]\n pub type RevMoveItems<T> = Rev<MoveItems<T>>;\n \n impl<A> FromIterator<A> for ~[A] {\n@@ -3228,9 +3237,7 @@ mod tests {\n         use iter::*;\n         let mut xs = [1, 2, 5, 10, 11];\n         assert_eq!(xs.iter().size_hint(), (5, Some(5)));\n-        assert_eq!(xs.rev_iter().size_hint(), (5, Some(5)));\n         assert_eq!(xs.mut_iter().size_hint(), (5, Some(5)));\n-        assert_eq!(xs.mut_rev_iter().size_hint(), (5, Some(5)));\n     }\n \n     #[test]\n@@ -3261,7 +3268,7 @@ mod tests {\n         let xs = [1, 2, 5, 10, 11];\n         let ys = [11, 10, 5, 2, 1];\n         let mut i = 0;\n-        for &x in xs.rev_iter() {\n+        for &x in xs.iter().rev() {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -3272,7 +3279,7 @@ mod tests {\n     fn test_mut_rev_iterator() {\n         use iter::*;\n         let mut xs = [1u, 2, 3, 4, 5];\n-        for (i,x) in xs.mut_rev_iter().enumerate() {\n+        for (i,x) in xs.mut_iter().rev().enumerate() {\n             *x += i;\n         }\n         assert!(xs == [5, 5, 5, 5, 5])\n@@ -3289,7 +3296,7 @@ mod tests {\n     fn test_move_rev_iterator() {\n         use iter::*;\n         let xs = ~[1u,2,3,4,5];\n-        assert_eq!(xs.move_rev_iter().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n+        assert_eq!(xs.move_iter().rev().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n     }\n \n     #[test]\n@@ -3330,17 +3337,17 @@ mod tests {\n     fn test_rsplitator() {\n         let xs = &[1i,2,3,4,5];\n \n-        assert_eq!(xs.rsplit(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<~[&[int]]>(),\n                    ~[&[5], &[3], &[1]]);\n-        assert_eq!(xs.rsplit(|x| *x == 1).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 1).rev().collect::<~[&[int]]>(),\n                    ~[&[2,3,4,5], &[]]);\n-        assert_eq!(xs.rsplit(|x| *x == 5).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(),\n                    ~[&[], &[1,2,3,4]]);\n-        assert_eq!(xs.rsplit(|x| *x == 10).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 10).rev().collect::<~[&[int]]>(),\n                    ~[&[1,2,3,4,5]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.rsplit(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(), ~[&[]]);\n     }\n \n     #[test]"}, {"sha": "bc7943dd777cabbcde30cf2fab1b24f609cd86c4", "filename": "src/libstd/str.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -343,21 +343,18 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n     }\n }\n \n-/// External iterator for a string's characters in reverse order.\n-/// Use with the `std::iter` module.\n+#[deprecated = \"replaced by Rev<Chars<'a>>\"]\n pub type RevChars<'a> = Rev<Chars<'a>>;\n \n-/// External iterator for a string's characters and their byte offsets in reverse order.\n-/// Use with the `std::iter` module.\n+#[deprecated = \"replaced by Rev<CharOffsets<'a>>\"]\n pub type RevCharOffsets<'a> = Rev<CharOffsets<'a>>;\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n pub type Bytes<'a> =\n     Map<'a, &'a u8, u8, slice::Items<'a, u8>>;\n \n-/// External iterator for a string's bytes in reverse order.\n-/// Use with the `std::iter` module.\n+#[deprecated = \"replaced by Rev<Bytes<'a>>\"]\n pub type RevBytes<'a> = Rev<Bytes<'a>>;\n \n /// An iterator over the substrings of a string, separated by `sep`.\n@@ -372,8 +369,7 @@ pub struct CharSplits<'a, Sep> {\n     finished: bool,\n }\n \n-/// An iterator over the substrings of a string, separated by `sep`,\n-/// starting from the back of the string.\n+#[deprecated = \"replaced by Rev<CharSplits<'a, Sep>>\"]\n pub type RevCharSplits<'a, Sep> = Rev<CharSplits<'a, Sep>>;\n \n /// An iterator over the substrings of a string, separated by `sep`,\n@@ -462,7 +458,7 @@ for CharSplits<'a, Sep> {\n                 }\n             }\n         } else {\n-            for (idx, ch) in self.string.char_indices_rev() {\n+            for (idx, ch) in self.string.char_indices().rev() {\n                 if self.sep.matches(ch) {\n                     next_split = Some((idx, self.string.char_range_at(idx).next));\n                     break;\n@@ -1626,21 +1622,23 @@ pub trait StrSlice<'a> {\n     /// ```\n     fn chars(&self) -> Chars<'a>;\n \n-    /// An iterator over the characters of `self`, in reverse order.\n-    fn chars_rev(&self) -> RevChars<'a>;\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .chars().rev()\"]\n+    fn chars_rev(&self) -> Rev<Chars<'a>>;\n \n     /// An iterator over the bytes of `self`\n     fn bytes(&self) -> Bytes<'a>;\n \n-    /// An iterator over the bytes of `self`, in reverse order\n-    fn bytes_rev(&self) -> RevBytes<'a>;\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .bytes().rev()\"]\n+    fn bytes_rev(&self) -> Rev<Bytes<'a>>;\n \n     /// An iterator over the characters of `self` and their byte offsets.\n     fn char_indices(&self) -> CharOffsets<'a>;\n \n-    /// An iterator over the characters of `self` and their byte offsets,\n-    /// in reverse order.\n-    fn char_indices_rev(&self) -> RevCharOffsets<'a>;\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .char_indices().rev()\"]\n+    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1691,25 +1689,21 @@ pub trait StrSlice<'a> {\n     ///\n     /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n     /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n-    /// ```\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, in reverse order.\n-    ///\n-    /// # Example\n     ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').rev().collect();\n     /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".rsplit(|c: char| c.is_digit()).collect();\n+    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n     /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep>;\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .split(sep).rev()\"]\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, starting from the end of the string.\n@@ -2281,7 +2275,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn chars_rev(&self) -> RevChars<'a> {\n+    #[deprecated = \"replaced by .chars().rev()\"]\n+    fn chars_rev(&self) -> Rev<Chars<'a>> {\n         self.chars().rev()\n     }\n \n@@ -2291,7 +2286,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn bytes_rev(&self) -> RevBytes<'a> {\n+    #[deprecated = \"replaced by .bytes().rev()\"]\n+    fn bytes_rev(&self) -> Rev<Bytes<'a>> {\n         self.bytes().rev()\n     }\n \n@@ -2301,7 +2297,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn char_indices_rev(&self) -> RevCharOffsets<'a> {\n+    #[deprecated = \"replaced by .char_indices().rev()\"]\n+    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>> {\n         self.char_indices().rev()\n     }\n \n@@ -2336,7 +2333,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep> {\n+    #[deprecated = \"replaced by .split(sep).rev()\"]\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>> {\n         self.split(sep).rev()\n     }\n \n@@ -2656,7 +2654,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         if search.only_ascii() {\n             self.bytes().rposition(|b| search.matches(b as char))\n         } else {\n-            for (index, c) in self.char_indices_rev() {\n+            for (index, c) in self.char_indices().rev() {\n                 if search.matches(c) { return Some(index); }\n             }\n             None\n@@ -3573,7 +3571,7 @@ mod tests {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n-        for ch in v.rev_iter() {\n+        for ch in v.iter().rev() {\n             assert!(s.char_at_reverse(pos) == *ch);\n             pos -= from_char(*ch).len();\n         }\n@@ -3673,7 +3671,7 @@ mod tests {\n         let v = ~['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.chars_rev();\n+        let mut it = s.chars().rev();\n \n         for c in it {\n             assert_eq!(c, v[pos]);\n@@ -3716,7 +3714,7 @@ mod tests {\n         ];\n         let mut pos = v.len();\n \n-        for b in s.bytes_rev() {\n+        for b in s.bytes().rev() {\n             pos -= 1;\n             assert_eq!(b, v[pos]);\n         }\n@@ -3748,7 +3746,7 @@ mod tests {\n         let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.char_indices_rev();\n+        let mut it = s.char_indices().rev();\n \n         for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n@@ -3765,29 +3763,29 @@ mod tests {\n         let split: ~[&str] = data.split(' ').collect();\n         assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit(' ').collect();\n+        let mut rsplit: ~[&str] = data.split(' ').rev().collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         let split: ~[&str] = data.split(|c: char| c == ' ').collect();\n         assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit(|c: char| c == ' ').collect();\n+        let mut rsplit: ~[&str] = data.split(|c: char| c == ' ').rev().collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: ~[&str] = data.split('\u00e4').collect();\n         assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit('\u00e4').collect();\n+        let mut rsplit: ~[&str] = data.split('\u00e4').rev().collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n         let split: ~[&str] = data.split(|c: char| c == '\u00e4').collect();\n         assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit(|c: char| c == '\u00e4').collect();\n+        let mut rsplit: ~[&str] = data.split(|c: char| c == '\u00e4').rev().collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n@@ -4103,7 +4101,7 @@ mod bench {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        b.iter(|| assert_eq!(s.chars_rev().len(), len));\n+        b.iter(|| assert_eq!(s.chars().rev().len(), len));\n     }\n \n     #[bench]\n@@ -4119,7 +4117,7 @@ mod bench {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        b.iter(|| assert_eq!(s.char_indices_rev().len(), len));\n+        b.iter(|| assert_eq!(s.char_indices().rev().len(), len));\n     }\n \n     #[bench]"}, {"sha": "38cdf23b7b305ee4173593b4d4d5a698874faed5", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03609e5a5e8bdca9452327d44e25407ce888d0bb/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=03609e5a5e8bdca9452327d44e25407ce888d0bb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -205,7 +205,8 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<InternedString> {\n-    items.rev_iter()\n+    items.iter()\n+         .rev()\n          .find(|mi| mi.name().equiv(&name))\n          .and_then(|i| i.value_str())\n }"}]}