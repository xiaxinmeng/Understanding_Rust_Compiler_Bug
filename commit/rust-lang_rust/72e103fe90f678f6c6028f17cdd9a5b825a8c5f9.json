{"sha": "72e103fe90f678f6c6028f17cdd9a5b825a8c5f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyZTEwM2ZlOTBmNjc4ZjZjNjAyOGYxN2NkZDlhNWI4MjVhOGM1Zjk=", "commit": {"author": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2016-09-09T03:04:05Z"}, "committer": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2016-09-10T17:48:01Z"}, "message": "Tweak std::mem docs\n\nFixes #29362.", "tree": {"sha": "b9b328ae5eb3c88d48433c406688b55197be85cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9b328ae5eb3c88d48433c406688b55197be85cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72e103fe90f678f6c6028f17cdd9a5b825a8c5f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72e103fe90f678f6c6028f17cdd9a5b825a8c5f9", "html_url": "https://github.com/rust-lang/rust/commit/72e103fe90f678f6c6028f17cdd9a5b825a8c5f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72e103fe90f678f6c6028f17cdd9a5b825a8c5f9/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f40f850e2546c2c187514e3d61d17544ba433f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f40f850e2546c2c187514e3d61d17544ba433f", "html_url": "https://github.com/rust-lang/rust/commit/f1f40f850e2546c2c187514e3d61d17544ba433f"}], "stats": {"total": 341, "additions": 231, "deletions": 110}, "files": [{"sha": "06b506ab014b4e77b1c09643fb17a204c486f5da", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/72e103fe90f678f6c6028f17cdd9a5b825a8c5f9/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72e103fe90f678f6c6028f17cdd9a5b825a8c5f9/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=72e103fe90f678f6c6028f17cdd9a5b825a8c5f9", "patch": "@@ -262,22 +262,25 @@ extern \"rust-intrinsic\" {\n     /// Moves a value out of scope without running drop glue.\n     pub fn forget<T>(_: T) -> ();\n \n-    /// Reinterprets the bits of a value of one type as another type; both types\n-    /// must have the same size. Neither the original, nor the result, may be an\n-    /// [invalid value] (../../nomicon/meet-safe-and-unsafe.html).\n+    /// Reinterprets the bits of a value of one type as another type.\n+    ///\n+    /// Both types must have the same size. Neither the original, nor the result,\n+    /// may be an [invalid value](../../nomicon/meet-safe-and-unsafe.html).\n     ///\n     /// `transmute` is semantically equivalent to a bitwise move of one type\n-    /// into another. It copies the bits from the destination type into the\n-    /// source type, then forgets the original. It's equivalent to C's `memcpy`\n-    /// under the hood, just like `transmute_copy`.\n+    /// into another. It copies the bits from the source value into the\n+    /// destination value, then forgets the original. It's equivalent to C's\n+    /// `memcpy` under the hood, just like `transmute_copy`.\n     ///\n-    /// `transmute` is incredibly unsafe. There are a vast number of ways to\n-    /// cause undefined behavior with this function. `transmute` should be\n+    /// `transmute` is **incredibly** unsafe. There are a vast number of ways to\n+    /// cause [undefined behavior][ub] with this function. `transmute` should be\n     /// the absolute last resort.\n     ///\n     /// The [nomicon](../../nomicon/transmutes.html) has additional\n     /// documentation.\n     ///\n+    /// [ub]: ../../reference.html#behavior-considered-undefined\n+    ///\n     /// # Examples\n     ///\n     /// There are a few things that `transmute` is really useful for.\n@@ -292,7 +295,8 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(bitpattern, 0x3F800000);\n     /// ```\n     ///\n-    /// Turning a pointer into a function pointer:\n+    /// Turning a pointer into a function pointer. This is *not* portable to\n+    /// machines where function pointers and data pointers have different sizes.\n     ///\n     /// ```\n     /// fn foo() -> i32 {\n@@ -305,8 +309,8 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(function(), 0);\n     /// ```\n     ///\n-    /// Extending a lifetime, or shortening an invariant lifetime; this is\n-    /// advanced, very unsafe rust:\n+    /// Extending a lifetime, or shortening an invariant lifetime. This is\n+    /// advanced, very unsafe Rust!\n     ///\n     /// ```\n     /// struct R<'a>(&'a i32);\n@@ -322,11 +326,9 @@ extern \"rust-intrinsic\" {\n     ///\n     /// # Alternatives\n     ///\n-    /// However, many uses of `transmute` can be achieved through other means.\n-    /// `transmute` can transform any type into any other, with just the caveat\n-    /// that they're the same size, and often interesting results occur. Below\n-    /// are common applications of `transmute` which can be replaced with safe\n-    /// applications of `as`:\n+    /// Don't despair: many uses of `transmute` can be achieved through other means.\n+    /// Below are common applications of `transmute` which can be replaced with safer\n+    /// constructs.\n     ///\n     /// Turning a pointer into a `usize`:\n     ///\n@@ -335,6 +337,7 @@ extern \"rust-intrinsic\" {\n     /// let ptr_num_transmute = unsafe {\n     ///     std::mem::transmute::<&i32, usize>(ptr)\n     /// };\n+    ///\n     /// // Use an `as` cast instead\n     /// let ptr_num_cast = ptr as *const i32 as usize;\n     /// ```\n@@ -346,6 +349,7 @@ extern \"rust-intrinsic\" {\n     /// let ref_transmuted = unsafe {\n     ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n     /// };\n+    ///\n     /// // Use a reborrow instead\n     /// let ref_casted = unsafe { &mut *ptr };\n     /// ```\n@@ -357,6 +361,7 @@ extern \"rust-intrinsic\" {\n     /// let val_transmuted = unsafe {\n     ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n     /// };\n+    ///\n     /// // Now, put together `as` and reborrowing - note the chaining of `as`\n     /// // `as` is not transitive\n     /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n@@ -368,9 +373,11 @@ extern \"rust-intrinsic\" {\n     /// // this is not a good way to do this.\n     /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n     /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    ///\n     /// // You could use `str::as_bytes`\n     /// let slice = \"Rust\".as_bytes();\n     /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    ///\n     /// // Or, just use a byte string, if you have control over the string\n     /// // literal\n     /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n@@ -381,18 +388,21 @@ extern \"rust-intrinsic\" {\n     /// ```\n     /// let store = [0, 1, 2, 3];\n     /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    ///\n     /// // Using transmute: this is Undefined Behavior, and a bad idea.\n     /// // However, it is no-copy.\n     /// let v_transmuted = unsafe {\n     ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n     ///         v_orig.clone())\n     /// };\n+    ///\n     /// // This is the suggested, safe way.\n-    /// // It does copy the entire Vector, though, into a new array.\n+    /// // It does copy the entire vector, though, into a new array.\n     /// let v_collected = v_orig.clone()\n     ///                         .into_iter()\n     ///                         .map(|r| Some(r))\n     ///                         .collect::<Vec<Option<&i32>>>();\n+    ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n     /// // same Vec internals. Therefore the new inner type must have the\n@@ -412,6 +422,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// ```\n     /// use std::{slice, mem};\n+    ///\n     /// // There are multiple ways to do this; and there are multiple problems\n     /// // with the following, transmute, way.\n     /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n@@ -426,6 +437,7 @@ extern \"rust-intrinsic\" {\n     ///         (&mut slice[0..mid], &mut slice2[mid..len])\n     ///     }\n     /// }\n+    ///\n     /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n     /// // you an `&mut T` from an `&mut T` or `*mut T`.\n     /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n@@ -439,6 +451,7 @@ extern \"rust-intrinsic\" {\n     ///         (&mut slice[0..mid], &mut slice2[mid..len])\n     ///     }\n     /// }\n+    ///\n     /// // This is how the standard library does it. This is the best method, if\n     /// // you need to do something like this\n     /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)"}, {"sha": "d3b8a60b79776c3f00a304e3430f006b1a4abc59", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 201, "deletions": 93, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/72e103fe90f678f6c6028f17cdd9a5b825a8c5f9/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72e103fe90f678f6c6028f17cdd9a5b825a8c5f9/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=72e103fe90f678f6c6028f17cdd9a5b825a8c5f9", "patch": "@@ -21,54 +21,39 @@ use ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n \n-/// Leaks a value into the void, consuming ownership and never running its\n-/// destructor.\n+/// Leaks a value: takes ownership and \"forgets\" about the value **without running\n+/// its destructor**.\n ///\n-/// This function will take ownership of its argument, but is distinct from the\n-/// `mem::drop` function in that it **does not run the destructor**, leaking the\n-/// value and any resources that it owns.\n+/// Any resources the value manages, such as heap memory or a file handle, will linger\n+/// forever in an unreachable state.\n ///\n-/// There's only a few reasons to use this function. They mainly come\n-/// up in unsafe code or FFI code.\n-///\n-/// * You have an uninitialized value, perhaps for performance reasons, and\n-///   need to prevent the destructor from running on it.\n-/// * You have two copies of a value (like when writing something like\n-///   [`mem::swap`][swap]), but need the destructor to only run once to\n-///   prevent a double `free`.\n-/// * Transferring resources across [FFI][ffi] boundaries.\n-///\n-/// [swap]: fn.swap.html\n-/// [ffi]: ../../book/ffi.html\n+/// If you want to dispose of a value properly, running its destructor, see\n+/// [`mem::drop`][drop].\n ///\n /// # Safety\n ///\n-/// This function is not marked as `unsafe` as Rust does not guarantee that the\n-/// `Drop` implementation for a value will always run. Note, however, that\n-/// leaking resources such as memory or I/O objects is likely not desired, so\n-/// this function is only recommended for specialized use cases.\n-///\n-/// The safety of this function implies that when writing `unsafe` code\n-/// yourself care must be taken when leveraging a destructor that is required to\n-/// run to preserve memory safety. There are known situations where the\n-/// destructor may not run (such as if ownership of the object with the\n-/// destructor is returned) which must be taken into account.\n+/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n+/// do not include a guarantee that destructors will always run. For example,\n+/// a program can create a reference cycle using [`Rc`][rc], or call\n+/// [`process:exit`][exit] to exit without running destructors. Thus, allowing\n+/// `mem::forget` from safe code does not fundamentally change Rust's safety\n+/// guarantees.\n ///\n-/// # Other forms of Leakage\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n+/// so `forget` is only recommended for specialized use cases like those shown below.\n ///\n-/// It's important to point out that this function is not the only method by\n-/// which a value can be leaked in safe Rust code. Other known sources of\n-/// leakage are:\n+/// Because forgetting a value is allowed, any `unsafe` code you write must\n+/// allow for this possibility. You cannot return a value and expect that the\n+/// caller will necessarily run the value's destructor.\n ///\n-/// * `Rc` and `Arc` cycles\n-/// * `mpsc::{Sender, Receiver}` cycles (they use `Arc` internally)\n-/// * Panicking destructors are likely to leak local resources\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [exit]: ../../std/process/fn.exit.html\n ///\n-/// # Example\n+/// # Examples\n ///\n /// Leak some heap memory by never deallocating it:\n ///\n-/// ```rust\n+/// ```\n /// use std::mem;\n ///\n /// let heap_memory = Box::new(3);\n@@ -77,17 +62,51 @@ pub use intrinsics::transmute;\n ///\n /// Leak an I/O object, never closing the file:\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::mem;\n /// use std::fs::File;\n ///\n /// let file = File::open(\"foo.txt\").unwrap();\n /// mem::forget(file);\n /// ```\n ///\n-/// The `mem::swap` function uses `mem::forget` to good effect:\n+/// The practical use cases for `forget` are rather specialized and mainly come\n+/// up in unsafe or FFI code.\n+///\n+/// ## Use case 1\n+///\n+/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n+/// You must either initialize or `forget` it on every computation path before\n+/// Rust drops it automatically, like at the end of a scope or after a panic.\n+/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::ptr;\n+///\n+/// # let some_condition = false;\n+/// unsafe {\n+///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n+///\n+///     if some_condition {\n+///         // Initialize the variable.\n+///         ptr::write(&mut uninit_vec, Vec::new());\n+///     } else {\n+///         // Forget the uninitialized value so its destructor doesn't run.\n+///         mem::forget(uninit_vec);\n+///     }\n+/// }\n+/// ```\n+///\n+/// ## Use case 2\n+///\n+/// You have duplicated the bytes making up a value, without doing a proper\n+/// [`Clone`][clone]. You need the value's destructor to run only once,\n+/// because a double `free` is undefined behavior.\n ///\n-/// ```rust\n+/// An example is the definition of [`mem::swap`][swap] in this module:\n+///\n+/// ```\n /// use std::mem;\n /// use std::ptr;\n ///\n@@ -109,6 +128,41 @@ pub use intrinsics::transmute;\n ///     }\n /// }\n /// ```\n+///\n+/// ## Use case 3\n+///\n+/// You are transferring ownership across a [FFI] boundary to code written in\n+/// another language. You need to `forget` the value on the Rust side because Rust\n+/// code is no longer responsible for it.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// extern \"C\" {\n+///     fn my_c_function(x: *const u32);\n+/// }\n+///\n+/// let x: Box<u32> = Box::new(3);\n+///\n+/// // Transfer ownership into C code.\n+/// unsafe {\n+///     my_c_function(&*x);\n+/// }\n+/// mem::forget(x);\n+/// ```\n+///\n+/// In this case, C code must call back into Rust to free the object. Calling C's `free`\n+/// function on a [`Box`][box] is *not* safe! Also, `Box` provides an [`into_raw`][into_raw]\n+/// method which is the preferred way to do this in practice.\n+///\n+/// [drop]: fn.drop.html\n+/// [uninit]: fn.uninitialized.html\n+/// [clone]: ../clone/trait.Clone.html\n+/// [swap]: fn.swap.html\n+/// [FFI]: ../../book/ffi.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n@@ -133,25 +187,40 @@ pub fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n-/// Returns the size of the given value in bytes.\n+/// Returns the size of the pointed-to value in bytes.\n+///\n+/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n+/// statically known size, e.g. a slice [`[T]`][slice] or a [trait object],\n+/// then `size_of_val` can be used to get the dynamically-known size.\n+///\n+/// [slice]: ../../std/primitive.slice.html\n+/// [trait object]: ../../book/trait-objects.html\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n /// assert_eq!(4, mem::size_of_val(&5i32));\n+///\n+/// let x: [u8; 13] = [0; 13];\n+/// let y: &[u8] = &x;\n+/// assert_eq!(13, mem::size_of_val(y));\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::size_of_val(val) }\n }\n \n-/// Returns the ABI-required minimum alignment of a type\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n /// # Examples\n ///\n /// ```\n@@ -167,7 +236,11 @@ pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n ///\n /// # Examples\n ///\n@@ -184,10 +257,14 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns the alignment in memory for a type.\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n /// # Examples\n ///\n /// ```\n@@ -201,7 +278,11 @@ pub fn align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n ///\n /// # Examples\n ///\n@@ -216,23 +297,31 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Creates a value initialized to zero.\n+/// Creates a value whose bytes are all zero.\n+///\n+/// This has the same effect as allocating space with\n+/// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n+/// [FFI] sometimes, but should generally be avoided.\n ///\n-/// This function is similar to allocating space for a local variable and zeroing it out (an unsafe\n-/// operation).\n+/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n+/// some type `T`. If `T` has a destructor and the value is destroyed (due to\n+/// a panic or the end of a scope) before being initialized, then the destructor\n+/// will run on zeroed data, likely leading to [undefined behavior][ub].\n ///\n-/// Care must be taken when using this function, if the type `T` has a destructor and the value\n-/// falls out of scope (due to unwinding or returning) before being initialized, then the\n-/// destructor will run on zeroed data, likely leading to crashes.\n+/// See also the documentation for [`mem::uninitialized`][uninit], which has\n+/// many of the same caveats.\n ///\n-/// This is useful for FFI functions sometimes, but should generally be avoided.\n+/// [uninit]: fn.uninitialized.html\n+/// [FFI]: ../../book/ffi.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n /// let x: i32 = unsafe { mem::zeroed() };\n+/// assert_eq!(0, x);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -241,32 +330,38 @@ pub unsafe fn zeroed<T>() -> T {\n }\n \n /// Bypasses Rust's normal memory-initialization checks by pretending to\n-/// produce a value of type T, while doing nothing at all.\n+/// produce a value of type `T`, while doing nothing at all.\n ///\n /// **This is incredibly dangerous, and should not be done lightly. Deeply\n /// consider initializing your memory with a default value instead.**\n ///\n-/// This is useful for FFI functions and initializing arrays sometimes,\n+/// This is useful for [FFI] functions and initializing arrays sometimes,\n /// but should generally be avoided.\n ///\n-/// # Undefined Behavior\n+/// [FFI]: ../../book/ffi.html\n ///\n-/// It is Undefined Behavior to read uninitialized memory. Even just an\n+/// # Undefined behavior\n+///\n+/// It is [undefined behavior][ub] to read uninitialized memory, even just an\n /// uninitialized boolean. For instance, if you branch on the value of such\n-/// a boolean your program may take one, both, or neither of the branches.\n+/// a boolean, your program may take one, both, or neither of the branches.\n ///\n-/// Note that this often also includes *writing* to the uninitialized value.\n-/// Rust believes the value is initialized, and will therefore try to Drop\n-/// the uninitialized value and its fields if you try to overwrite the memory\n-/// in a normal manner. The only way to safely initialize an arbitrary\n-/// uninitialized value is with one of the `ptr` functions: `write`, `copy`, or\n-/// `copy_nonoverlapping`. This isn't necessary if `T` is a primitive\n-/// or otherwise only contains types that don't implement Drop.\n+/// Writing to the uninitialized value is similarly dangerous. Rust believes the\n+/// value is initialized, and will therefore try to [`Drop`][drop] the uninitialized\n+/// value and its fields if you try to overwrite it in a normal manner. The only way\n+/// to safely initialize an uninitialized value is with [`ptr::write`][write],\n+/// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n ///\n-/// If this value *does* need some kind of Drop, it must be initialized before\n+/// If the value does implement `Drop`, it must be initialized before\n /// it goes out of scope (and therefore would be dropped). Note that this\n /// includes a `panic` occurring and unwinding the stack suddenly.\n ///\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [write]: ../ptr/fn.write.html\n+/// [copy]: ../intrinsics/fn.copy.html\n+/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n+/// [drop]: ../ops/trait.Drop.html\n+///\n /// # Examples\n ///\n /// Here's how to safely initialize an array of `Vec`s.\n@@ -309,8 +404,8 @@ pub unsafe fn zeroed<T>() -> T {\n /// println!(\"{:?}\", &data[0]);\n /// ```\n ///\n-/// This example emphasizes exactly how delicate and dangerous doing this is.\n-/// Note that the `vec!` macro *does* let you initialize every element with a\n+/// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n+/// can be. Note that the `vec!` macro *does* let you initialize every element with a\n /// value that is only `Clone`, so the following is semantically equivalent and\n /// vastly less dangerous, as long as you can live with an extra heap\n /// allocation:\n@@ -325,21 +420,20 @@ pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Swap the values at two mutable locations of the same type, without deinitializing or copying\n-/// either one.\n+/// Swaps the values at two mutable locations, without deinitializing either one.\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n-/// let x = &mut 5;\n-/// let y = &mut 42;\n+/// let mut x = 5;\n+/// let mut y = 42;\n ///\n-/// mem::swap(x, y);\n+/// mem::swap(&mut x, &mut y);\n ///\n-/// assert_eq!(42, *x);\n-/// assert_eq!(5, *y);\n+/// assert_eq!(42, x);\n+/// assert_eq!(5, y);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -361,10 +455,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n }\n \n /// Replaces the value at a mutable location with a new one, returning the old value, without\n-/// deinitializing or copying either one.\n-///\n-/// This is primarily used for transferring and swapping ownership of a value in a mutable\n-/// location.\n+/// deinitializing either one.\n ///\n /// # Examples\n ///\n@@ -373,15 +464,17 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// ```\n /// use std::mem;\n ///\n-/// let mut v: Vec<i32> = Vec::new();\n+/// let mut v: Vec<i32> = vec![1, 2];\n ///\n-/// mem::replace(&mut v, Vec::new());\n+/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n+/// assert_eq!(2, old_v.len());\n+/// assert_eq!(3, v.len());\n /// ```\n ///\n-/// This function allows consumption of one field of a struct by replacing it with another value.\n-/// The normal approach doesn't always work:\n+/// `replace` allows consumption of a struct field by replacing it with another value.\n+/// Without `replace` you can run into issues like these:\n ///\n-/// ```rust,ignore\n+/// ```ignore\n /// struct Buffer<T> { buf: Vec<T> }\n ///\n /// impl<T> Buffer<T> {\n@@ -401,6 +494,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// ```\n /// # #![allow(dead_code)]\n /// use std::mem;\n+///\n /// # struct Buffer<T> { buf: Vec<T> }\n /// impl<T> Buffer<T> {\n ///     fn get_and_reset(&mut self) -> Vec<T> {\n@@ -417,14 +511,25 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n \n /// Disposes of a value.\n ///\n-/// While this does call the argument's implementation of `Drop`, it will not\n-/// release any borrows, as borrows are based on lexical scope.\n+/// While this does call the argument's implementation of [`Drop`][drop],\n+/// it will not release any borrows, as borrows are based on lexical scope.\n ///\n /// This effectively does nothing for\n /// [types which implement `Copy`](../../book/ownership.html#copy-types),\n /// e.g. integers. Such values are copied and _then_ moved into the function,\n /// so the value persists after this function call.\n ///\n+/// This function is not magic; it is literally defined as\n+///\n+/// ```\n+/// pub fn drop<T>(_x: T) { }\n+/// ```\n+///\n+/// Because `_x` is moved into the function, it is automatically dropped before\n+/// the function returns.\n+///\n+/// [drop]: ../ops/trait.Drop.html\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -461,8 +566,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// v.push(4); // no problems\n /// ```\n ///\n-/// Since `RefCell` enforces the borrow rules at runtime, `drop()` can\n-/// seemingly release a borrow of one:\n+/// Since `RefCell` enforces the borrow rules at runtime, `drop` can\n+/// release a `RefCell` borrow:\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -478,7 +583,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n ///\n-/// Integers and other types implementing `Copy` are unaffected by `drop()`\n+/// Integers and other types implementing `Copy` are unaffected by `drop`.\n ///\n /// ```\n /// #[derive(Copy, Clone)]\n@@ -496,19 +601,22 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n-/// Interprets `src` as `&U`, and then reads `src` without moving the contained\n-/// value.\n+/// Interprets `src` as having type `&U`, and then reads `src` without moving\n+/// the contained value.\n ///\n /// This function will unsafely assume the pointer `src` is valid for\n-/// `sizeof(U)` bytes by transmuting `&T` to `&U` and then reading the `&U`. It\n-/// will also unsafely create a copy of the contained value instead of moving\n-/// out of `src`.\n+/// [`size_of::<U>()`][size_of] bytes by transmuting `&T` to `&U` and then reading\n+/// the `&U`. It will also unsafely create a copy of the contained value instead of\n+/// moving out of `src`.\n ///\n /// It is not a compile-time error if `T` and `U` have different sizes, but it\n /// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers undefined behavior if `U` is larger than\n+/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n /// `T`.\n ///\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [size_of]: fn.size_of.html\n+///\n /// # Examples\n ///\n /// ```"}]}