{"sha": "3de0106789468b211bcc3a25c09c0cf07119186d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZTAxMDY3ODk0NjhiMjExYmNjM2EyNWMwOWMwY2YwNzExOTE4NmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-11T15:44:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-11T15:44:22Z"}, "message": "Auto merge of #59780 - RalfJung:miri-unsized, r=oli-obk\n\nMiri: unsized locals and by-value dyn traits\n\nr? @oli-obk\nCc @eddyb\n\nFixes https://github.com/rust-lang/miri/issues/449", "tree": {"sha": "980a17d96ee4ae5e1bf32da897295ea8a43b8e42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/980a17d96ee4ae5e1bf32da897295ea8a43b8e42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3de0106789468b211bcc3a25c09c0cf07119186d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3de0106789468b211bcc3a25c09c0cf07119186d", "html_url": "https://github.com/rust-lang/rust/commit/3de0106789468b211bcc3a25c09c0cf07119186d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3de0106789468b211bcc3a25c09c0cf07119186d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "850912704e7bdf3eb8fc7d9ac9b99f913633bb8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/850912704e7bdf3eb8fc7d9ac9b99f913633bb8d", "html_url": "https://github.com/rust-lang/rust/commit/850912704e7bdf3eb8fc7d9ac9b99f913633bb8d"}, {"sha": "4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "html_url": "https://github.com/rust-lang/rust/commit/4d79d391b0aa1175f493e3544d8f66e6600fbfc6"}], "stats": {"total": 345, "additions": 192, "deletions": 153}, "files": [{"sha": "32f7ecd97b2ef13caa44d56d680c400233d4f2ce", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 54, "deletions": 56, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=3de0106789468b211bcc3a25c09c0cf07119186d", "patch": "@@ -108,34 +108,51 @@ pub enum StackPopCleanup {\n /// State of a local variable including a memoized layout\n #[derive(Clone, PartialEq, Eq)]\n pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n-    pub state: LocalValue<Tag, Id>,\n+    pub value: LocalValue<Tag, Id>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     pub layout: Cell<Option<TyLayout<'tcx>>>,\n }\n \n-/// State of a local variable\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+/// Current value of a local variable\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum LocalValue<Tag=(), Id=AllocId> {\n+    /// This local is not currently alive, and cannot be used at all.\n     Dead,\n-    // Mostly for convenience, we re-use the `Operand` type here.\n-    // This is an optimization over just always having a pointer here;\n-    // we can thus avoid doing an allocation when the local just stores\n-    // immediate values *and* never has its address taken.\n+    /// This local is alive but not yet initialized. It can be written to\n+    /// but not read from or its address taken. Locals get initialized on\n+    /// first write because for unsized locals, we do not know their size\n+    /// before that.\n+    Uninitialized,\n+    /// A normal, live local.\n+    /// Mostly for convenience, we re-use the `Operand` type here.\n+    /// This is an optimization over just always having a pointer here;\n+    /// we can thus avoid doing an allocation when the local just stores\n+    /// immediate values *and* never has its address taken.\n     Live(Operand<Tag, Id>),\n }\n \n-impl<'tcx, Tag> LocalState<'tcx, Tag> {\n-    pub fn access(&self) -> EvalResult<'tcx, &Operand<Tag>> {\n-        match self.state {\n+impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n+    pub fn access(&self) -> EvalResult<'tcx, Operand<Tag>> {\n+        match self.value {\n             LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(ref val) => Ok(val),\n+            LocalValue::Uninitialized =>\n+                bug!(\"The type checker should prevent reading from a never-written local\"),\n+            LocalValue::Live(val) => Ok(val),\n         }\n     }\n \n-    pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand<Tag>> {\n-        match self.state {\n+    /// Overwrite the local.  If the local can be overwritten in place, return a reference\n+    /// to do so; otherwise return the `MemPlace` to consult instead.\n+    pub fn access_mut(\n+        &mut self,\n+    ) -> EvalResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n+        match self.value {\n             LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(ref mut val) => Ok(val),\n+            LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n+            ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n+            ref mut local @ LocalValue::Uninitialized => {\n+                Ok(Ok(local))\n+            }\n         }\n     }\n }\n@@ -327,6 +344,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                     let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n                     self.layout_of(local_ty)\n                 })?;\n+                // Layouts of locals are requested a lot, so we cache them.\n                 frame.locals[local].layout.set(Some(layout));\n                 Ok(layout)\n             }\n@@ -473,19 +491,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n \n         // don't allocate at all for trivial constants\n         if mir.local_decls.len() > 1 {\n-            // We put some marker immediate into the locals that we later want to initialize.\n-            // This can be anything except for LocalValue::Dead -- because *that* is the\n-            // value we use for things that we know are initially dead.\n+            // Locals are initially uninitialized.\n             let dummy = LocalState {\n-                state: LocalValue::Live(Operand::Immediate(Immediate::Scalar(\n-                    ScalarMaybeUndef::Undef,\n-                ))),\n+                value: LocalValue::Uninitialized,\n                 layout: Cell::new(None),\n             };\n             let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n             // Return place is handled specially by the `eval_place` functions, and the\n             // entry in `locals` should never be used. Make it dead, to be sure.\n-            locals[mir::RETURN_PLACE].state = LocalValue::Dead;\n+            locals[mir::RETURN_PLACE].value = LocalValue::Dead;\n             // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n@@ -498,29 +512,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                             match stmt.kind {\n                                 StorageLive(local) |\n                                 StorageDead(local) => {\n-                                    locals[local].state = LocalValue::Dead;\n+                                    locals[local].value = LocalValue::Dead;\n                                 }\n                                 _ => {}\n                             }\n                         }\n                     }\n                 },\n             }\n-            // Finally, properly initialize all those that still have the dummy value\n-            for (idx, local) in locals.iter_enumerated_mut() {\n-                match local.state {\n-                    LocalValue::Live(_) => {\n-                        // This needs to be properly initialized.\n-                        let ty = self.monomorphize(mir.local_decls[idx].ty)?;\n-                        let layout = self.layout_of(ty)?;\n-                        local.state = LocalValue::Live(self.uninit_operand(layout)?);\n-                        local.layout = Cell::new(Some(layout));\n-                    }\n-                    LocalValue::Dead => {\n-                        // Nothing to do\n-                    }\n-                }\n-            }\n             // done\n             self.frame_mut().locals = locals;\n         }\n@@ -555,7 +554,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         }\n         // Deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n-            self.deallocate_local(local.state)?;\n+            self.deallocate_local(local.value)?;\n         }\n         // Validate the return value. Do this after deallocating so that we catch dangling\n         // references.\n@@ -603,10 +602,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n-        let layout = self.layout_of_local(self.frame(), local, None)?;\n-        let init = LocalValue::Live(self.uninit_operand(layout)?);\n+        let local_val = LocalValue::Uninitialized;\n         // StorageLive *always* kills the value that's currently stored\n-        Ok(mem::replace(&mut self.frame_mut().locals[local].state, init))\n+        Ok(mem::replace(&mut self.frame_mut().locals[local].value, local_val))\n     }\n \n     /// Returns the old value of the local.\n@@ -615,7 +613,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n-        mem::replace(&mut self.frame_mut().locals[local].state, LocalValue::Dead)\n+        mem::replace(&mut self.frame_mut().locals[local].value, LocalValue::Dead)\n     }\n \n     pub(super) fn deallocate_local(\n@@ -668,31 +666,31 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                 }\n                 write!(msg, \":\").unwrap();\n \n-                match self.stack[frame].locals[local].access() {\n-                    Err(err) => {\n-                        if let InterpError::DeadLocal = err.kind {\n-                            write!(msg, \" is dead\").unwrap();\n-                        } else {\n-                            panic!(\"Failed to access local: {:?}\", err);\n-                        }\n-                    }\n-                    Ok(Operand::Indirect(mplace)) => {\n-                        let (ptr, align) = mplace.to_scalar_ptr_align();\n-                        match ptr {\n+                match self.stack[frame].locals[local].value {\n+                    LocalValue::Dead => write!(msg, \" is dead\").unwrap(),\n+                    LocalValue::Uninitialized => write!(msg, \" is uninitialized\").unwrap(),\n+                    LocalValue::Live(Operand::Indirect(mplace)) => {\n+                        match mplace.ptr {\n                             Scalar::Ptr(ptr) => {\n-                                write!(msg, \" by align({}) ref:\", align.bytes()).unwrap();\n+                                write!(msg, \" by align({}){} ref:\",\n+                                    mplace.align.bytes(),\n+                                    match mplace.meta {\n+                                        Some(meta) => format!(\" meta({:?})\", meta),\n+                                        None => String::new()\n+                                    }\n+                                ).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n                             ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),\n                         }\n                     }\n-                    Ok(Operand::Immediate(Immediate::Scalar(val))) => {\n+                    LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n                         if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n-                    Ok(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n+                    LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n                         if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);"}, {"sha": "65cd7be8fd4b28cf753205347da7a115a1680bd0", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=3de0106789468b211bcc3a25c09c0cf07119186d", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::interpret::{\n };\n use super::{\n     InterpretCx, Machine,\n-    MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n+    MemPlace, MPlaceTy, PlaceTy, Place,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n \n@@ -373,33 +373,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         Ok(str)\n     }\n \n-    pub fn uninit_operand(\n-        &mut self,\n-        layout: TyLayout<'tcx>\n-    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n-        // This decides which types we will use the Immediate optimization for, and hence should\n-        // match what `try_read_immediate` and `eval_place_to_op` support.\n-        if layout.is_zst() {\n-            return Ok(Operand::Immediate(Immediate::Scalar(Scalar::zst().into())));\n-        }\n-\n-        Ok(match layout.abi {\n-            layout::Abi::Scalar(..) =>\n-                Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Undef)),\n-            layout::Abi::ScalarPair(..) =>\n-                Operand::Immediate(Immediate::ScalarPair(\n-                    ScalarMaybeUndef::Undef,\n-                    ScalarMaybeUndef::Undef,\n-                )),\n-            _ => {\n-                trace!(\"Forcing allocation for local of type {:?}\", layout.ty);\n-                Operand::Indirect(\n-                    *self.allocate(layout, MemoryKind::Stack)\n-                )\n-            }\n-        })\n-    }\n-\n     /// Projection functions\n     pub fn operand_field(\n         &self,\n@@ -486,8 +459,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         assert_ne!(local, mir::RETURN_PLACE);\n-        let op = *frame.locals[local].access()?;\n         let layout = self.layout_of_local(frame, local, layout)?;\n+        let op = if layout.is_zst() {\n+            // Do not read from ZST, they might not be initialized\n+            Operand::Immediate(Immediate::Scalar(Scalar::zst().into()))\n+        } else {\n+            frame.locals[local].access()?\n+        };\n         Ok(OpTy { op, layout })\n     }\n \n@@ -502,7 +480,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 Operand::Indirect(mplace)\n             }\n             Place::Local { frame, local } =>\n-                *self.stack[frame].locals[local].access()?\n+                *self.access_local(&self.stack[frame], local, None)?\n         };\n         Ok(OpTy { op, layout: place.layout })\n     }"}, {"sha": "048d51acaf2a22c193be99587b76bd1f7333c14b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 81, "deletions": 45, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=3de0106789468b211bcc3a25c09c0cf07119186d", "patch": "@@ -15,7 +15,7 @@ use rustc::ty::TypeFoldable;\n use super::{\n     GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n     InterpretCx, Machine, AllocMap, AllocationExtra,\n-    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n+    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -639,6 +639,7 @@ where\n                 None => return err!(InvalidNullPointerUsage),\n             },\n             Base(PlaceBase::Local(local)) => PlaceTy {\n+                // This works even for dead/uninitialized locals; we check further when writing\n                 place: Place::Local {\n                     frame: self.cur_frame(),\n                     local,\n@@ -714,16 +715,19 @@ where\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n-                match *self.stack[frame].locals[local].access_mut()? {\n-                    Operand::Immediate(ref mut dest_val) => {\n-                        // Yay, we can just change the local directly.\n-                        *dest_val = src;\n+                match self.stack[frame].locals[local].access_mut()? {\n+                    Ok(local) => {\n+                        // Local can be updated in-place.\n+                        *local = LocalValue::Live(Operand::Immediate(src));\n                         return Ok(());\n-                    },\n-                    Operand::Indirect(mplace) => mplace, // already in memory\n+                    }\n+                    Err(mplace) => {\n+                        // The local is in memory, go on below.\n+                        mplace\n+                    }\n                 }\n             },\n-            Place::Ptr(mplace) => mplace, // already in memory\n+            Place::Ptr(mplace) => mplace, // already referring to memory\n         };\n         let dest = MPlaceTy { mplace, layout: dest.layout };\n \n@@ -822,8 +826,6 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        debug_assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n-            \"Cannot copy unsized data\");\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n         assert!(src.layout.details == dest.layout.details,\n@@ -832,6 +834,7 @@ where\n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n         let src = match self.try_read_immediate(src)? {\n             Ok(src_val) => {\n+                assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n                 // Yay, we got a value that we can write directly.\n                 // FIXME: Add a check to make sure that if `src` is indirect,\n                 // it does not overlap with `dest`.\n@@ -842,13 +845,19 @@ where\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n-        let dest = self.force_allocation(dest)?;\n-        let (src_ptr, src_align) = src.to_scalar_ptr_align();\n-        let (dest_ptr, dest_align) = dest.to_scalar_ptr_align();\n+        // This interprets `src.meta` with the `dest` local's layout, if an unsized local\n+        // is being initialized!\n+        let (dest, size) = self.force_allocation_maybe_sized(dest, src.meta)?;\n+        let size = size.unwrap_or_else(|| {\n+            assert!(!dest.layout.is_unsized(),\n+                \"Cannot copy into already initialized unsized place\");\n+            dest.layout.size\n+        });\n+        assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n         self.memory.copy(\n-            src_ptr, src_align,\n-            dest_ptr, dest_align,\n-            dest.layout.size,\n+            src.ptr, src.align,\n+            dest.ptr, dest.align,\n+            size,\n             /*nonoverlapping*/ true,\n         )?;\n \n@@ -866,11 +875,13 @@ where\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }\n-        // We still require the sizes to match\n-        debug_assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n-            \"Cannot copy unsized data\");\n+        // We still require the sizes to match.\n         assert!(src.layout.size == dest.layout.size,\n             \"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+        // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n+        // to avoid that here.\n+        assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n+            \"Cannot transmute unsized data\");\n \n         // The hard case is `ScalarPair`.  `src` is already read from memory in this case,\n         // using `src.layout` to figure out which bytes to use for the 1st and 2nd field.\n@@ -898,55 +909,80 @@ where\n     /// If the place currently refers to a local that doesn't yet have a matching allocation,\n     /// create such an allocation.\n     /// This is essentially `force_to_memplace`.\n-    pub fn force_allocation(\n+    ///\n+    /// This supports unsized types and returns the computed size to avoid some\n+    /// redundant computation when copying; use `force_allocation` for a simpler, sized-only\n+    /// version.\n+    pub fn force_allocation_maybe_sized(\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let mplace = match place.place {\n+        meta: Option<Scalar<M::PointerTag>>,\n+    ) -> EvalResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n+        let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n-                match *self.stack[frame].locals[local].access()? {\n-                    Operand::Indirect(mplace) => mplace,\n-                    Operand::Immediate(value) => {\n+                match self.stack[frame].locals[local].access_mut()? {\n+                    Ok(local_val) => {\n                         // We need to make an allocation.\n                         // FIXME: Consider not doing anything for a ZST, and just returning\n                         // a fake pointer?  Are we even called for ZST?\n \n+                        // We cannot hold on to the reference `local_val` while allocating,\n+                        // but we can hold on to the value in there.\n+                        let old_val =\n+                            if let LocalValue::Live(Operand::Immediate(value)) = *local_val {\n+                                Some(value)\n+                            } else {\n+                                None\n+                            };\n+\n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n+                        // We also need to support unsized types, and hence cannot use `allocate`.\n                         let local_layout = self.layout_of_local(&self.stack[frame], local, None)?;\n-                        let ptr = self.allocate(local_layout, MemoryKind::Stack);\n-                        // We don't have to validate as we can assume the local\n-                        // was already valid for its type.\n-                        self.write_immediate_to_mplace_no_validate(value, ptr)?;\n-                        let mplace = ptr.mplace;\n-                        // Update the local\n-                        *self.stack[frame].locals[local].access_mut()? =\n-                            Operand::Indirect(mplace);\n-                        mplace\n+                        let (size, align) = self.size_and_align_of(meta, local_layout)?\n+                            .expect(\"Cannot allocate for non-dyn-sized type\");\n+                        let ptr = self.memory.allocate(size, align, MemoryKind::Stack);\n+                        let ptr = M::tag_new_allocation(self, ptr, MemoryKind::Stack);\n+                        let mplace = MemPlace { ptr: ptr.into(), align, meta };\n+                        if let Some(value) = old_val {\n+                            // Preserve old value.\n+                            // We don't have to validate as we can assume the local\n+                            // was already valid for its type.\n+                            let mplace = MPlaceTy { mplace, layout: local_layout };\n+                            self.write_immediate_to_mplace_no_validate(value, mplace)?;\n+                        }\n+                        // Now we can call `access_mut` again, asserting it goes well,\n+                        // and actually overwrite things.\n+                        *self.stack[frame].locals[local].access_mut().unwrap().unwrap() =\n+                            LocalValue::Live(Operand::Indirect(mplace));\n+                        (mplace, Some(size))\n                     }\n+                    Err(mplace) => (mplace, None), // this already was an indirect local\n                 }\n             }\n-            Place::Ptr(mplace) => mplace\n+            Place::Ptr(mplace) => (mplace, None)\n         };\n         // Return with the original layout, so that the caller can go on\n-        Ok(MPlaceTy { mplace, layout: place.layout })\n+        Ok((MPlaceTy { mplace, layout: place.layout }, size))\n+    }\n+\n+    #[inline(always)]\n+    pub fn force_allocation(\n+        &mut self,\n+        place: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        Ok(self.force_allocation_maybe_sized(place, None)?.0)\n     }\n \n     pub fn allocate(\n         &mut self,\n         layout: TyLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n-        if layout.is_unsized() {\n-            assert!(self.tcx.features().unsized_locals, \"cannot alloc memory for unsized type\");\n-            // FIXME: What should we do here? We should definitely also tag!\n-            MPlaceTy::dangling(layout, self)\n-        } else {\n-            let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n-            let ptr = M::tag_new_allocation(self, ptr, kind);\n-            MPlaceTy::from_aligned_ptr(ptr, layout)\n-        }\n+        let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n+        let ptr = M::tag_new_allocation(self, ptr, kind);\n+        MPlaceTy::from_aligned_ptr(ptr, layout)\n     }\n \n     pub fn write_discriminant_index("}, {"sha": "0bb8b1d9d02ca343c62ae817f28d8ebe808e8faa", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=3de0106789468b211bcc3a25c09c0cf07119186d", "patch": "@@ -114,10 +114,11 @@ macro_rules! impl_snapshot_for {\n             fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n                 match *self {\n                     $(\n-                        $enum_name::$variant $( ( $(ref $field),* ) )? =>\n+                        $enum_name::$variant $( ( $(ref $field),* ) )? => {\n                             $enum_name::$variant $(\n-                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),* ),\n+                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),* )\n                             )?\n+                        }\n                     )*\n                 }\n             }\n@@ -250,11 +251,13 @@ impl_snapshot_for!(enum Operand {\n \n impl_stable_hash_for!(enum crate::interpret::LocalValue {\n     Dead,\n+    Uninitialized,\n     Live(x),\n });\n impl_snapshot_for!(enum LocalValue {\n-    Live(v),\n     Dead,\n+    Uninitialized,\n+    Live(v),\n });\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n@@ -360,13 +363,13 @@ impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n     type Item = LocalValue<(), AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let LocalState { state, layout: _ } = self;\n-        state.snapshot(ctx)\n+        let LocalState { value, layout: _ } = self;\n+        value.snapshot(ctx)\n     }\n }\n \n impl_stable_hash_for!(struct LocalState<'tcx> {\n-    state,\n+    value,\n     layout -> _,\n });\n "}, {"sha": "ba48a28fc83159d2b6b58243ca4202ab9a1c55c3", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=3de0106789468b211bcc3a25c09c0cf07119186d", "patch": "@@ -315,12 +315,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     );\n \n                     // Figure out how to pass which arguments.\n-                    // We have two iterators: Where the arguments come from,\n-                    // and where they go to.\n+                    // The Rust ABI is special: ZST get skipped.\n                     let rust_abi = match caller_abi {\n                         Abi::Rust | Abi::RustCall => true,\n                         _ => false\n                     };\n+                    // We have two iterators: Where the arguments come from,\n+                    // and where they go to.\n \n                     // For where they come from: If the ABI is RustCall, we untuple the\n                     // last incoming argument.  These two iterators do not have the same type,\n@@ -368,7 +369,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     }\n                     // Now we should have no more caller args\n                     if caller_iter.next().is_some() {\n-                        trace!(\"Caller has too many args over\");\n+                        trace!(\"Caller has passed too many args\");\n                         return err!(FunctionArgCountMismatch);\n                     }\n                     // Don't forget to check the return type!\n@@ -406,25 +407,41 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n+                let mut args = args.to_vec();\n                 let ptr_size = self.pointer_size();\n-                let ptr = self.deref_operand(args[0])?;\n-                let vtable = ptr.vtable()?;\n+                // We have to implement all \"object safe receivers\".  Currently we\n+                // support built-in pointers (&, &mut, Box) as well as unsized-self.  We do\n+                // not yet support custom self types.\n+                // Also see librustc_codegen_llvm/abi.rs and librustc_codegen_llvm/mir/block.rs.\n+                let receiver_place = match args[0].layout.ty.builtin_deref(true) {\n+                    Some(_) => {\n+                        // Built-in pointer.\n+                        self.deref_operand(args[0])?\n+                    }\n+                    None => {\n+                        // Unsized self.\n+                        args[0].to_mem_place()\n+                    }\n+                };\n+                // Find and consult vtable\n+                let vtable = receiver_place.vtable()?;\n                 self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n                 let fn_ptr = self.memory.get(vtable.alloc_id)?.read_ptr_sized(\n                     self,\n                     vtable.offset(ptr_size * (idx as u64 + 3), self)?,\n                 )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n \n-                // We have to patch the self argument, in particular get the layout\n-                // expected by the actual function. Cannot just use \"field 0\" due to\n-                // Box<self>.\n-                let mut args = args.to_vec();\n-                let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n-                let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n-                args[0] = OpTy::from(ImmTy { // strip vtable\n-                    layout: self.layout_of(fake_fat_ptr_ty)?.field(self, 0)?,\n-                    imm: Immediate::Scalar(ptr.ptr.into())\n+                // `*mut receiver_place.layout.ty` is almost the layout that we\n+                // want for args[0]: We have to project to field 0 because we want\n+                // a thin pointer.\n+                assert!(receiver_place.layout.is_unsized());\n+                let receiver_ptr_ty = self.tcx.mk_mut_ptr(receiver_place.layout.ty);\n+                let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0)?;\n+                // Adjust receiver argument.\n+                args[0] = OpTy::from(ImmTy {\n+                    layout: this_receiver_ptr,\n+                    imm: Immediate::Scalar(receiver_place.ptr.into())\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function"}, {"sha": "d76d3a3301620a61f52fa8dbf05dd5d81bcde04b", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de0106789468b211bcc3a25c09c0cf07119186d/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=3de0106789468b211bcc3a25c09c0cf07119186d", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n \n-use super::{InterpretCx, Machine, MemoryKind};\n+use super::{InterpretCx, InterpError, Machine, MemoryKind};\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -76,7 +76,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n-                let instance = self.resolve(def_id, substs)?;\n+                // resolve for vtable: insert shims where needed\n+                let substs = self.subst_and_normalize_erasing_regions(substs)?;\n+                let instance = ty::Instance::resolve_for_vtable(\n+                    *self.tcx,\n+                    self.param_env,\n+                    def_id,\n+                    substs,\n+                ).ok_or_else(|| InterpError::TooGeneric)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory"}]}