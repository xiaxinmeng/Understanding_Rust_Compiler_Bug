{"sha": "07f1c163a189f0474d011ba266007bffd6882b54", "node_id": "C_kwDOAAsO6NoAKDA3ZjFjMTYzYTE4OWYwNDc0ZDAxMWJhMjY2MDA3YmZmZDY4ODJiNTQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-08T16:15:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-08T16:15:01Z"}, "message": "Rollup merge of #97507 - jyn514:download-rustfmt, r=Mark-Simulacrum\n\nMove rustfmt downloads from bootstrap.py to rustbuild\n\n- Allow verifying CI downloads using src/stage0.json\n- Change download functions not to hard-code `ci-artifacts.rust-lang.org`\n- Change `format::format` to take a `Builder` so it has access to `download_component`. I think we may want to reconsider the distinction between Build and Builder at some point; I don't think it's particularly useful.\n- Move rustfmt downloads out of bootstrap.py\n\nFixes https://github.com/rust-lang/rust/issues/95136. Helps with https://github.com/rust-lang/rust/issues/94829. This is based on https://github.com/rust-lang/rust/pull/96687 for simplicity.", "tree": {"sha": "c3599a063672a6f710b8225ea39b48f8c1212127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3599a063672a6f710b8225ea39b48f8c1212127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07f1c163a189f0474d011ba266007bffd6882b54", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJioMsGCRBK7hj4Ov3rIwAABZkIAAK3VVZzQlBlePmC3V21sqF9\nd2Y6yBFTpyjj9TSBoflv3KoW4bG3HKxC/EdkhVIhFq+Eh4IPKBgnp+kCAGlKxu0T\nOrmt2rUL4Gt8TPRk/D6tdr4pm0YcR0UCm8u2bbPsctylWOhReG3llLau0XLjgwTa\n0723yu6SiALQOiKPLdlKu2MEc2shXHvIPuQqFfhGN/TVTBuvwQljhwRtuo4IbGTD\n/3+8lhiKx1fzXNLFfrBUZcftN41yDJkhmG82tZacQfuEi34kBgU2d1DkD3HViaEA\n3ml+0OqsCQt7xD6aZ1WKsENvgFCH6Jx+LNJuJf/TiC+9eLo04I8MPSoevOroeTE=\n=yOYr\n-----END PGP SIGNATURE-----\n", "payload": "tree c3599a063672a6f710b8225ea39b48f8c1212127\nparent 09d52bc5d4260bac8b9a2ea8ac7a07c5c72906f1\nparent 6115f4eba458e763370119b2a10a73ef595583bc\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1654704901 +0200\ncommitter GitHub <noreply@github.com> 1654704901 +0200\n\nRollup merge of #97507 - jyn514:download-rustfmt, r=Mark-Simulacrum\n\nMove rustfmt downloads from bootstrap.py to rustbuild\n\n- Allow verifying CI downloads using src/stage0.json\n- Change download functions not to hard-code `ci-artifacts.rust-lang.org`\n- Change `format::format` to take a `Builder` so it has access to `download_component`. I think we may want to reconsider the distinction between Build and Builder at some point; I don't think it's particularly useful.\n- Move rustfmt downloads out of bootstrap.py\n\nFixes https://github.com/rust-lang/rust/issues/95136. Helps with https://github.com/rust-lang/rust/issues/94829. This is based on https://github.com/rust-lang/rust/pull/96687 for simplicity.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07f1c163a189f0474d011ba266007bffd6882b54", "html_url": "https://github.com/rust-lang/rust/commit/07f1c163a189f0474d011ba266007bffd6882b54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07f1c163a189f0474d011ba266007bffd6882b54/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09d52bc5d4260bac8b9a2ea8ac7a07c5c72906f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/09d52bc5d4260bac8b9a2ea8ac7a07c5c72906f1", "html_url": "https://github.com/rust-lang/rust/commit/09d52bc5d4260bac8b9a2ea8ac7a07c5c72906f1"}, {"sha": "6115f4eba458e763370119b2a10a73ef595583bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6115f4eba458e763370119b2a10a73ef595583bc", "html_url": "https://github.com/rust-lang/rust/commit/6115f4eba458e763370119b2a10a73ef595583bc"}], "stats": {"total": 342, "additions": 233, "deletions": 109}, "files": [{"sha": "b6077574ee6002bbb3ba4300ff1005e75ab6143b", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07f1c163a189f0474d011ba266007bffd6882b54/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/07f1c163a189f0474d011ba266007bffd6882b54/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=07f1c163a189f0474d011ba266007bffd6882b54", "patch": "@@ -216,13 +216,15 @@ dependencies = [\n  \"cmake\",\n  \"filetime\",\n  \"getopts\",\n+ \"hex 0.4.2\",\n  \"ignore\",\n  \"libc\",\n  \"once_cell\",\n  \"opener\",\n  \"pretty_assertions 0.7.2\",\n  \"serde\",\n  \"serde_json\",\n+ \"sha2\",\n  \"sysinfo\",\n  \"tar\",\n  \"toml\","}, {"sha": "0e54837610a4b363d6f7452998801e8cc19b3fcd", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=07f1c163a189f0474d011ba266007bffd6882b54", "patch": "@@ -40,8 +40,10 @@ filetime = \"0.2\"\n getopts = \"0.2.19\"\n cc = \"1.0.69\"\n libc = \"0.2\"\n+hex = \"0.4\"\n serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n+sha2 = \"0.10\"\n tar = \"0.4\"\n toml = \"0.5\"\n ignore = \"0.4.10\""}, {"sha": "635e4f3703b1c52b761b31783efab4b4e1f189f2", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 21, "deletions": 63, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=07f1c163a189f0474d011ba266007bffd6882b54", "patch": "@@ -63,31 +63,30 @@ def support_xz():\n     except tarfile.CompressionError:\n         return False\n \n-def get(base, url, path, checksums, verbose=False, do_verify=True):\n+def get(base, url, path, checksums, verbose=False):\n     with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n         temp_path = temp_file.name\n \n     try:\n-        if do_verify:\n-            if url not in checksums:\n-                raise RuntimeError((\"src/stage0.json doesn't contain a checksum for {}. \"\n-                                    \"Pre-built artifacts might not available for this \"\n-                                    \"target at this time, see https://doc.rust-lang.org/nightly\"\n-                                    \"/rustc/platform-support.html for more information.\")\n-                                   .format(url))\n-            sha256 = checksums[url]\n-            if os.path.exists(path):\n-                if verify(path, sha256, False):\n-                    if verbose:\n-                        print(\"using already-download file\", path)\n-                    return\n-                else:\n-                    if verbose:\n-                        print(\"ignoring already-download file\",\n-                            path, \"due to failed verification\")\n-                    os.unlink(path)\n+        if url not in checksums:\n+            raise RuntimeError((\"src/stage0.json doesn't contain a checksum for {}. \"\n+                                \"Pre-built artifacts might not be available for this \"\n+                                \"target at this time, see https://doc.rust-lang.org/nightly\"\n+                                \"/rustc/platform-support.html for more information.\")\n+                                .format(url))\n+        sha256 = checksums[url]\n+        if os.path.exists(path):\n+            if verify(path, sha256, False):\n+                if verbose:\n+                    print(\"using already-download file\", path)\n+                return\n+            else:\n+                if verbose:\n+                    print(\"ignoring already-download file\",\n+                        path, \"due to failed verification\")\n+                os.unlink(path)\n         download(temp_path, \"{}/{}\".format(base, url), True, verbose)\n-        if do_verify and not verify(temp_path, sha256, verbose):\n+        if not verify(temp_path, sha256, verbose):\n             raise RuntimeError(\"failed verification\")\n         if verbose:\n             print(\"moving {} to {}\".format(temp_path, path))\n@@ -430,7 +429,6 @@ class RustBuild(object):\n     def __init__(self):\n         self.checksums_sha256 = {}\n         self.stage0_compiler = None\n-        self.stage0_rustfmt = None\n         self._download_url = ''\n         self.build = ''\n         self.build_dir = ''\n@@ -484,31 +482,10 @@ def download_toolchain(self):\n             with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(key)\n \n-        if self.rustfmt() and self.rustfmt().startswith(bin_root) and (\n-            not os.path.exists(self.rustfmt())\n-            or self.program_out_of_date(\n-                self.rustfmt_stamp(),\n-                \"\" if self.stage0_rustfmt is None else self.stage0_rustfmt.channel()\n-            )\n-        ):\n-            if self.stage0_rustfmt is not None:\n-                tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n-                filename = \"rustfmt-{}-{}{}\".format(\n-                    self.stage0_rustfmt.version, self.build, tarball_suffix,\n-                )\n-                self._download_component_helper(\n-                    filename, \"rustfmt-preview\", tarball_suffix, key=self.stage0_rustfmt.date\n-                )\n-                self.fix_bin_or_dylib(\"{}/bin/rustfmt\".format(bin_root))\n-                self.fix_bin_or_dylib(\"{}/bin/cargo-fmt\".format(bin_root))\n-                with output(self.rustfmt_stamp()) as rustfmt_stamp:\n-                    rustfmt_stamp.write(self.stage0_rustfmt.channel())\n-\n     def _download_component_helper(\n-        self, filename, pattern, tarball_suffix, key=None\n+        self, filename, pattern, tarball_suffix,\n     ):\n-        if key is None:\n-            key = self.stage0_compiler.date\n+        key = self.stage0_compiler.date\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n         rustc_cache = os.path.join(cache_dst, key)\n         if not os.path.exists(rustc_cache):\n@@ -524,7 +501,6 @@ def _download_component_helper(\n                 tarball,\n                 self.checksums_sha256,\n                 verbose=self.verbose,\n-                do_verify=True,\n             )\n         unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n \n@@ -634,16 +610,6 @@ def rustc_stamp(self):\n         \"\"\"\n         return os.path.join(self.bin_root(), '.rustc-stamp')\n \n-    def rustfmt_stamp(self):\n-        \"\"\"Return the path for .rustfmt-stamp\n-\n-        >>> rb = RustBuild()\n-        >>> rb.build_dir = \"build\"\n-        >>> rb.rustfmt_stamp() == os.path.join(\"build\", \"stage0\", \".rustfmt-stamp\")\n-        True\n-        \"\"\"\n-        return os.path.join(self.bin_root(), '.rustfmt-stamp')\n-\n     def program_out_of_date(self, stamp_path, key):\n         \"\"\"Check if the given program stamp is out of date\"\"\"\n         if not os.path.exists(stamp_path) or self.clean:\n@@ -717,12 +683,6 @@ def rustc(self):\n         \"\"\"Return config path for rustc\"\"\"\n         return self.program_config('rustc')\n \n-    def rustfmt(self):\n-        \"\"\"Return config path for rustfmt\"\"\"\n-        if self.stage0_rustfmt is None:\n-            return None\n-        return self.program_config('rustfmt')\n-\n     def program_config(self, program):\n         \"\"\"Return config path for the given program at the given stage\n \n@@ -1082,8 +1042,6 @@ def bootstrap(help_triggered):\n         data = json.load(f)\n     build.checksums_sha256 = data[\"checksums_sha256\"]\n     build.stage0_compiler = Stage0Toolchain(data[\"compiler\"])\n-    if data.get(\"rustfmt\") is not None:\n-        build.stage0_rustfmt = Stage0Toolchain(data[\"rustfmt\"])\n \n     build.set_dist_environment(data[\"dist_server\"])\n "}, {"sha": "38d4f15d3c8589393a68f25ab0ef78bc8cc56028", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=07f1c163a189f0474d011ba266007bffd6882b54", "patch": "@@ -728,7 +728,8 @@ impl<'a> Builder<'a> {\n             Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n             Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n             Subcommand::Run { ref paths } => (Kind::Run, &paths[..]),\n-            Subcommand::Format { .. } | Subcommand::Clean { .. } | Subcommand::Setup { .. } => {\n+            Subcommand::Format { .. } => (Kind::Format, &[][..]),\n+            Subcommand::Clean { .. } | Subcommand::Setup { .. } => {\n                 panic!()\n             }\n         };\n@@ -878,7 +879,6 @@ impl<'a> Builder<'a> {\n     ) {\n         // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n         let tempfile = self.tempdir().join(dest_path.file_name().unwrap());\n-        // FIXME: support `do_verify` (only really needed for nightly rustfmt)\n         self.download_with_retries(&tempfile, &format!(\"{}/{}\", base, url), help_on_error);\n         t!(std::fs::rename(&tempfile, dest_path));\n     }\n@@ -970,6 +970,28 @@ impl<'a> Builder<'a> {\n         t!(fs::remove_dir_all(dst.join(directory_prefix)));\n     }\n \n+    /// Returns whether the SHA256 checksum of `path` matches `expected`.\n+    pub(crate) fn verify(&self, path: &Path, expected: &str) -> bool {\n+        use sha2::Digest;\n+\n+        self.verbose(&format!(\"verifying {}\", path.display()));\n+        let mut hasher = sha2::Sha256::new();\n+        // FIXME: this is ok for rustfmt (4.1 MB large at time of writing), but it seems memory-intensive for rustc and larger components.\n+        // Consider using streaming IO instead?\n+        let contents = if self.config.dry_run { vec![] } else { t!(fs::read(path)) };\n+        hasher.update(&contents);\n+        let found = hex::encode(hasher.finalize().as_slice());\n+        let verified = found == expected;\n+        if !verified && !self.config.dry_run {\n+            println!(\n+                \"invalid checksum: \\n\\\n+                found:    {found}\\n\\\n+                expected: {expected}\",\n+            );\n+        }\n+        return verified;\n+    }\n+\n     /// Obtain a compiler at a given stage and for a given host. Explicitly does\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid\n@@ -1192,6 +1214,10 @@ impl<'a> Builder<'a> {\n         Config::download_rustc(self)\n     }\n \n+    pub(crate) fn initial_rustfmt(&self) -> Option<PathBuf> {\n+        Config::initial_rustfmt(self)\n+    }\n+\n     /// Prepares an invocation of `cargo` to be run.\n     ///\n     /// This will create a `Command` that represents a pending execution of"}, {"sha": "99b69ee9a4fd18e521be31e32e9d0252fdf27b17", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 152, "deletions": 30, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=07f1c163a189f0474d011ba266007bffd6882b54", "patch": "@@ -3,7 +3,7 @@\n //! This module implements parsing `config.toml` configuration files to tweak\n //! how the build runs.\n \n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::env;\n@@ -20,6 +20,7 @@ use crate::channel::GitInfo;\n pub use crate::flags::Subcommand;\n use crate::flags::{Color, Flags};\n use crate::util::{exe, output, program_out_of_date, t};\n+use crate::RustfmtMetadata;\n use once_cell::sync::OnceCell;\n use serde::{Deserialize, Deserializer};\n \n@@ -204,10 +205,27 @@ pub struct Config {\n     // These are either the stage0 downloaded binaries or the locally installed ones.\n     pub initial_cargo: PathBuf,\n     pub initial_rustc: PathBuf,\n-    pub initial_rustfmt: Option<PathBuf>,\n+    #[cfg(not(test))]\n+    initial_rustfmt: RefCell<RustfmtState>,\n+    #[cfg(test)]\n+    pub initial_rustfmt: RefCell<RustfmtState>,\n     pub out: PathBuf,\n }\n \n+#[derive(Clone, Debug)]\n+pub enum RustfmtState {\n+    SystemToolchain(PathBuf),\n+    Downloaded(PathBuf),\n+    Unavailable,\n+    LazyEvaluated,\n+}\n+\n+impl Default for RustfmtState {\n+    fn default() -> Self {\n+        RustfmtState::LazyEvaluated\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq)]\n pub enum LlvmLibunwind {\n     No,\n@@ -859,9 +877,6 @@ impl Config {\n         set(&mut config.full_bootstrap, build.full_bootstrap);\n         set(&mut config.extended, build.extended);\n         config.tools = build.tools;\n-        if build.rustfmt.is_some() {\n-            config.initial_rustfmt = build.rustfmt;\n-        }\n         set(&mut config.verbose, build.verbose);\n         set(&mut config.sanitizers, build.sanitizers);\n         set(&mut config.profiler, build.profiler);\n@@ -1154,18 +1169,22 @@ impl Config {\n             set(&mut config.missing_tools, t.missing_tools);\n         }\n \n-        config.initial_rustfmt = config.initial_rustfmt.or_else({\n-            let build = config.build;\n-            let initial_rustc = &config.initial_rustc;\n-\n-            move || {\n-                // Cargo does not provide a RUSTFMT environment variable, so we\n-                // synthesize it manually.\n-                let rustfmt = initial_rustc.with_file_name(exe(\"rustfmt\", build));\n-\n-                if rustfmt.exists() { Some(rustfmt) } else { None }\n+        if let Some(r) = build.rustfmt {\n+            *config.initial_rustfmt.borrow_mut() = if r.exists() {\n+                RustfmtState::SystemToolchain(r)\n+            } else {\n+                RustfmtState::Unavailable\n+            };\n+        } else {\n+            // If using a system toolchain for bootstrapping, see if that has rustfmt available.\n+            let host = config.build;\n+            let rustfmt_path = config.initial_rustc.with_file_name(exe(\"rustfmt\", host));\n+            let bin_root = config.out.join(host.triple).join(\"stage0\");\n+            if !rustfmt_path.starts_with(&bin_root) {\n+                // Using a system-provided toolchain; we shouldn't download rustfmt.\n+                *config.initial_rustfmt.borrow_mut() = RustfmtState::SystemToolchain(rustfmt_path);\n             }\n-        });\n+        }\n \n         // Now that we've reached the end of our configuration, infer the\n         // default values for all options that we haven't otherwise stored yet.\n@@ -1335,6 +1354,25 @@ impl Config {\n         })\n     }\n \n+    pub(crate) fn initial_rustfmt(builder: &Builder<'_>) -> Option<PathBuf> {\n+        match &mut *builder.config.initial_rustfmt.borrow_mut() {\n+            RustfmtState::SystemToolchain(p) | RustfmtState::Downloaded(p) => Some(p.clone()),\n+            RustfmtState::Unavailable => None,\n+            r @ RustfmtState::LazyEvaluated => {\n+                if builder.config.dry_run {\n+                    return Some(PathBuf::new());\n+                }\n+                let path = maybe_download_rustfmt(builder);\n+                *r = if let Some(p) = &path {\n+                    RustfmtState::Downloaded(p.clone())\n+                } else {\n+                    RustfmtState::Unavailable\n+                };\n+                path\n+            }\n+        }\n+    }\n+\n     pub fn verbose(&self) -> bool {\n         self.verbose > 0\n     }\n@@ -1445,6 +1483,28 @@ fn download_ci_rustc_commit(download_rustc: Option<StringOrBool>, verbose: bool)\n     Some(commit.to_string())\n }\n \n+fn maybe_download_rustfmt(builder: &Builder<'_>) -> Option<PathBuf> {\n+    let RustfmtMetadata { date, version } = builder.stage0_metadata.rustfmt.as_ref()?;\n+    let channel = format!(\"{version}-{date}\");\n+\n+    let host = builder.config.build;\n+    let rustfmt_path = builder.config.initial_rustc.with_file_name(exe(\"rustfmt\", host));\n+    let bin_root = builder.config.out.join(host.triple).join(\"stage0\");\n+    let rustfmt_stamp = bin_root.join(\".rustfmt-stamp\");\n+    if rustfmt_path.exists() && !program_out_of_date(&rustfmt_stamp, &channel) {\n+        return Some(rustfmt_path);\n+    }\n+\n+    let filename = format!(\"rustfmt-{version}-{build}.tar.xz\", build = host.triple);\n+    download_component(builder, DownloadSource::Dist, filename, \"rustfmt-preview\", &date, \"stage0\");\n+\n+    builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustfmt\"));\n+    builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"cargo-fmt\"));\n+\n+    builder.create(&rustfmt_stamp, &channel);\n+    Some(rustfmt_path)\n+}\n+\n fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n     builder.verbose(&format!(\"using downloaded stage2 artifacts from CI (commit {commit})\"));\n     // FIXME: support downloading artifacts from the beta channel\n@@ -1459,12 +1519,12 @@ fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n         }\n         let filename = format!(\"rust-std-{CHANNEL}-{host}.tar.xz\");\n         let pattern = format!(\"rust-std-{host}\");\n-        download_component(builder, filename, &pattern, commit);\n+        download_ci_component(builder, filename, &pattern, commit);\n         let filename = format!(\"rustc-{CHANNEL}-{host}.tar.xz\");\n-        download_component(builder, filename, \"rustc\", commit);\n+        download_ci_component(builder, filename, \"rustc\", commit);\n         // download-rustc doesn't need its own cargo, it can just use beta's.\n         let filename = format!(\"rustc-dev-{CHANNEL}-{host}.tar.xz\");\n-        download_component(builder, filename, \"rustc-dev\", commit);\n+        download_ci_component(builder, filename, \"rustc-dev\", commit);\n \n         builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n         builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n@@ -1479,21 +1539,83 @@ fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n     }\n }\n \n+pub(crate) enum DownloadSource {\n+    CI,\n+    Dist,\n+}\n+\n /// Download a single component of a CI-built toolchain (not necessarily a published nightly).\n // NOTE: intentionally takes an owned string to avoid downloading multiple times by accident\n-fn download_component(builder: &Builder<'_>, filename: String, prefix: &str, commit: &str) {\n+fn download_ci_component(builder: &Builder<'_>, filename: String, prefix: &str, commit: &str) {\n+    download_component(builder, DownloadSource::CI, filename, prefix, commit, \"ci-rustc\")\n+}\n+\n+fn download_component(\n+    builder: &Builder<'_>,\n+    mode: DownloadSource,\n+    filename: String,\n+    prefix: &str,\n+    key: &str,\n+    destination: &str,\n+) {\n     let cache_dst = builder.out.join(\"cache\");\n-    let rustc_cache = cache_dst.join(commit);\n-    if !rustc_cache.exists() {\n-        t!(fs::create_dir_all(&rustc_cache));\n+    let cache_dir = cache_dst.join(key);\n+    if !cache_dir.exists() {\n+        t!(fs::create_dir_all(&cache_dir));\n     }\n \n-    let base = \"https://ci-artifacts.rust-lang.org\";\n-    let url = format!(\"rustc-builds/{commit}\");\n-    let tarball = rustc_cache.join(&filename);\n-    if !tarball.exists() {\n-        builder.download_component(base, &format!(\"{url}/{filename}\"), &tarball, \"\");\n+    let bin_root = builder.out.join(builder.config.build.triple).join(destination);\n+    let tarball = cache_dir.join(&filename);\n+    let (base_url, url, should_verify) = match mode {\n+        DownloadSource::CI => (\n+            \"https://ci-artifacts.rust-lang.org/rustc-builds\".to_string(),\n+            format!(\"{key}/{filename}\"),\n+            false,\n+        ),\n+        DownloadSource::Dist => {\n+            let dist_server = env::var(\"RUSTUP_DIST_SERVER\")\n+                .unwrap_or(builder.stage0_metadata.dist_server.to_string());\n+            // NOTE: make `dist` part of the URL because that's how it's stored in src/stage0.json\n+            (dist_server, format!(\"dist/{key}/{filename}\"), true)\n+        }\n+    };\n+\n+    // For the beta compiler, put special effort into ensuring the checksums are valid.\n+    // FIXME: maybe we should do this for download-rustc as well? but it would be a pain to update\n+    // this on each and every nightly ...\n+    let checksum = if should_verify {\n+        let error = format!(\n+            \"src/stage0.json doesn't contain a checksum for {url}. \\\n+            Pre-built artifacts might not be available for this \\\n+            target at this time, see https://doc.rust-lang.org/nightly\\\n+            /rustc/platform-support.html for more information.\"\n+        );\n+        let sha256 = builder.stage0_metadata.checksums_sha256.get(&url).expect(&error);\n+        if tarball.exists() {\n+            if builder.verify(&tarball, sha256) {\n+                builder.unpack(&tarball, &bin_root, prefix);\n+                return;\n+            } else {\n+                builder.verbose(&format!(\n+                    \"ignoring cached file {} due to failed verification\",\n+                    tarball.display()\n+                ));\n+                builder.remove(&tarball);\n+            }\n+        }\n+        Some(sha256)\n+    } else if tarball.exists() {\n+        return;\n+    } else {\n+        None\n+    };\n+\n+    builder.download_component(&base_url, &url, &tarball, \"\");\n+    if let Some(sha256) = checksum {\n+        if !builder.verify(&tarball, sha256) {\n+            panic!(\"failed to verify {}\", tarball.display());\n+        }\n     }\n-    let bin_root = builder.out.join(builder.config.build.triple).join(\"ci-rustc\");\n-    builder.unpack(&tarball, &bin_root, prefix)\n+\n+    builder.unpack(&tarball, &bin_root, prefix);\n }"}, {"sha": "60a53c28686b0b06cc2eb16646d6dc94b449965f", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=07f1c163a189f0474d011ba266007bffd6882b54", "patch": "@@ -1,7 +1,7 @@\n //! Runs rustfmt on the repository.\n \n+use crate::builder::Builder;\n use crate::util::{output, t};\n-use crate::Build;\n use ignore::WalkBuilder;\n use std::collections::VecDeque;\n use std::path::{Path, PathBuf};\n@@ -42,7 +42,7 @@ struct RustfmtConfig {\n     ignore: Vec<String>,\n }\n \n-pub fn format(build: &Build, check: bool, paths: &[PathBuf]) {\n+pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n     if build.config.dry_run {\n         return;\n     }\n@@ -112,15 +112,11 @@ pub fn format(build: &Build, check: bool, paths: &[PathBuf]) {\n     }\n     let ignore_fmt = ignore_fmt.build().unwrap();\n \n-    let rustfmt_path = build\n-        .config\n-        .initial_rustfmt\n-        .as_ref()\n-        .unwrap_or_else(|| {\n-            eprintln!(\"./x.py fmt is not supported on this channel\");\n-            std::process::exit(1);\n-        })\n-        .to_path_buf();\n+    let rustfmt_path = build.initial_rustfmt().unwrap_or_else(|| {\n+        eprintln!(\"./x.py fmt is not supported on this channel\");\n+        std::process::exit(1);\n+    });\n+    assert!(rustfmt_path.exists(), \"{}\", rustfmt_path.display());\n     let src = build.src.clone();\n     let (tx, rx): (SyncSender<PathBuf>, _) = std::sync::mpsc::sync_channel(128);\n     let walker = match paths.get(0) {"}, {"sha": "022f2e0fc13874c3514608c32fd47086ca26763c", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=07f1c163a189f0474d011ba266007bffd6882b54", "patch": "@@ -118,6 +118,7 @@ use std::os::windows::fs::symlink_file;\n \n use filetime::FileTime;\n use once_cell::sync::OnceCell;\n+use serde::Deserialize;\n \n use crate::builder::Kind;\n use crate::config::{LlvmLibunwind, TargetSelection};\n@@ -294,6 +295,7 @@ pub struct Build {\n     targets: Vec<TargetSelection>,\n \n     // Stage 0 (downloaded) compiler, lld and cargo or their local rust equivalents\n+    stage0_metadata: Stage0Metadata,\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n     initial_lld: PathBuf,\n@@ -320,6 +322,18 @@ pub struct Build {\n     metrics: metrics::BuildMetrics,\n }\n \n+#[derive(Deserialize)]\n+struct Stage0Metadata {\n+    dist_server: String,\n+    checksums_sha256: HashMap<String, String>,\n+    rustfmt: Option<RustfmtMetadata>,\n+}\n+#[derive(Deserialize)]\n+struct RustfmtMetadata {\n+    date: String,\n+    version: String,\n+}\n+\n #[derive(Debug)]\n struct Crate {\n     name: Interned<String>,\n@@ -468,7 +482,11 @@ impl Build {\n             bootstrap_out\n         };\n \n+        let stage0_json = t!(std::fs::read_to_string(&src.join(\"src\").join(\"stage0.json\")));\n+        let stage0_metadata = t!(serde_json::from_str::<Stage0Metadata>(&stage0_json));\n+\n         let mut build = Build {\n+            stage0_metadata,\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             initial_lld,\n@@ -661,7 +679,7 @@ impl Build {\n         self.maybe_update_submodules();\n \n         if let Subcommand::Format { check, paths } = &self.config.cmd {\n-            return format::format(self, *check, &paths);\n+            return format::format(&builder::Builder::new(&self), *check, &paths);\n         }\n \n         if let Subcommand::Clean { all } = self.config.cmd {"}, {"sha": "fdce078bbedf5cd6741fa6bc31d9e5f668fb168e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f1c163a189f0474d011ba266007bffd6882b54/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=07f1c163a189f0474d011ba266007bffd6882b54", "patch": "@@ -1010,7 +1010,7 @@ impl Step for Tidy {\n \n         if builder.config.channel == \"dev\" || builder.config.channel == \"nightly\" {\n             builder.info(\"fmt check\");\n-            if builder.config.initial_rustfmt.is_none() {\n+            if builder.initial_rustfmt().is_none() {\n                 let inferred_rustfmt_dir = builder.config.initial_rustc.parent().unwrap();\n                 eprintln!(\n                     \"\\\n@@ -1023,7 +1023,7 @@ help: to skip test's attempt to check tidiness, pass `--exclude src/tools/tidy`\n                 );\n                 std::process::exit(1);\n             }\n-            crate::format::format(&builder.build, !builder.config.cmd.bless(), &[]);\n+            crate::format::format(&builder, !builder.config.cmd.bless(), &[]);\n         }\n     }\n "}]}