{"sha": "46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2YjY3YWE3NGQ4ZWU3ZDljNDE5ODNlMTVmOGNkMGYxN2VlMjdhZTc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-02-22T16:06:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-04T22:33:43Z"}, "message": "expand: Some more consistent naming in module loading", "tree": {"sha": "e7ed5a0129fb03a3f9c257d68d44a60b44ea444a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7ed5a0129fb03a3f9c257d68d44a60b44ea444a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7", "html_url": "https://github.com/rust-lang/rust/commit/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d0b622ab7ae3f803d757f73f2a9a7c857d771bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb", "html_url": "https://github.com/rust-lang/rust/commit/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb"}], "stats": {"total": 116, "additions": 59, "deletions": 57}, "files": [{"sha": "4aafcb2fb6dfea067783c635dacaad92d0d9f67e", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n-use rustc_expand::module::DirectoryOwnership;\n+use rustc_expand::module::DirOwnership;\n use rustc_parse::parser::{ForceCollect, Parser};\n use rustc_parse::{self, new_parser_from_file};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n@@ -116,7 +116,7 @@ pub fn expand_include<'cx>(\n     // `MacroExpander::fully_expand_fragment` later restores, so \"stack discipline\" is maintained.\n     let dir_path = file.parent().unwrap_or(&file).to_owned();\n     cx.current_expansion.module = Rc::new(cx.current_expansion.module.with_dir_path(dir_path));\n-    cx.current_expansion.directory_ownership = DirectoryOwnership::Owned { relative: None };\n+    cx.current_expansion.dir_ownership = DirOwnership::Owned { relative: None };\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,"}, {"sha": "f88110cf106a733925fb5f21e76f5583f183fbc8", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7", "patch": "@@ -1,5 +1,5 @@\n use crate::expand::{self, AstFragment, Invocation};\n-use crate::module::DirectoryOwnership;\n+use crate::module::DirOwnership;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n@@ -921,7 +921,7 @@ pub struct ExpansionData {\n     pub id: ExpnId,\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n-    pub directory_ownership: DirectoryOwnership,\n+    pub dir_ownership: DirOwnership,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n@@ -963,7 +963,7 @@ impl<'a> ExtCtxt<'a> {\n                 id: ExpnId::root(),\n                 depth: 0,\n                 module: Default::default(),\n-                directory_ownership: DirectoryOwnership::Owned { relative: None },\n+                dir_ownership: DirOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n             },\n             force_mode: false,"}, {"sha": "eee2c6ff80869b7b91f7c52c9c899b1b637270ba", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7", "patch": "@@ -3,7 +3,7 @@ use crate::config::StripUnconfigured;\n use crate::configure;\n use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n-use crate::module::{parse_external_mod, push_directory, DirectoryOwnership, ParsedExternalMod};\n+use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n \n use rustc_ast as ast;\n@@ -1246,10 +1246,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn visit_block(&mut self, block: &mut P<Block>) {\n-        let old_directory_ownership = self.cx.current_expansion.directory_ownership;\n-        self.cx.current_expansion.directory_ownership = DirectoryOwnership::UnownedViaBlock;\n+        let orig_dir_ownership = mem::replace(\n+            &mut self.cx.current_expansion.dir_ownership,\n+            DirOwnership::UnownedViaBlock,\n+        );\n         noop_visit_block(block, self);\n-        self.cx.current_expansion.directory_ownership = old_directory_ownership;\n+        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n     }\n \n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -1280,12 +1282,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 let (file_path, dir_path, dir_ownership) = match mod_kind {\n                     ModKind::Loaded(_, Inline::Yes, _) => {\n                         // Inline `mod foo { ... }`, but we still need to push directories.\n-                        let (dir_path, dir_ownership) = push_directory(\n+                        let (dir_path, dir_ownership) = mod_dir_path(\n                             &self.cx.sess,\n                             ident,\n                             &attrs,\n                             &self.cx.current_expansion.module,\n-                            self.cx.current_expansion.directory_ownership,\n+                            self.cx.current_expansion.dir_ownership,\n                         );\n                         item.attrs = attrs;\n                         (None, dir_path, dir_ownership)\n@@ -1306,7 +1308,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                             ident,\n                             span,\n                             &self.cx.current_expansion.module,\n-                            self.cx.current_expansion.directory_ownership,\n+                            self.cx.current_expansion.dir_ownership,\n                             &mut attrs,\n                         );\n \n@@ -1334,12 +1336,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let orig_dir_ownership =\n-                    mem::replace(&mut self.cx.current_expansion.directory_ownership, dir_ownership);\n+                    mem::replace(&mut self.cx.current_expansion.dir_ownership, dir_ownership);\n \n                 let result = noop_flat_map_item(item, self);\n \n                 // Restore the module info.\n-                self.cx.current_expansion.directory_ownership = orig_dir_ownership;\n+                self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n                 self.cx.current_expansion.module = orig_module;\n \n                 result"}, {"sha": "607c68f82dfa91ed42bc720e31428d39c334cd9e", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=46b67aa74d8ee7d9c41983e15f8cd0f17ee27ae7", "patch": "@@ -11,7 +11,7 @@ use rustc_span::Span;\n use std::path::{self, Path, PathBuf};\n \n #[derive(Copy, Clone)]\n-pub enum DirectoryOwnership {\n+pub enum DirOwnership {\n     Owned {\n         // None if `mod.rs`, `Some(\"foo\")` if we're in `foo.rs`.\n         relative: Option<Ident>,\n@@ -29,40 +29,40 @@ pub struct ModulePath<'a> {\n \n // Public for rustfmt usage.\n pub struct ModulePathSuccess {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n+    pub file_path: PathBuf,\n+    pub dir_ownership: DirOwnership,\n }\n \n crate struct ParsedExternalMod {\n     pub items: Vec<P<Item>>,\n     pub inner_span: Span,\n     pub file_path: PathBuf,\n     pub dir_path: PathBuf,\n-    pub dir_ownership: DirectoryOwnership,\n+    pub dir_ownership: DirOwnership,\n }\n \n crate fn parse_external_mod(\n     sess: &Session,\n-    id: Ident,\n+    ident: Ident,\n     span: Span, // The span to blame on errors.\n     module: &ModuleData,\n-    mut dir_ownership: DirectoryOwnership,\n+    mut dir_ownership: DirOwnership,\n     attrs: &mut Vec<Attribute>,\n ) -> ParsedExternalMod {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n     let result: PResult<'_, _> = try {\n         // Extract the file path and the new ownership.\n-        let mp = submod_path(sess, id, span, &attrs, dir_ownership, &module.dir_path)?;\n-        dir_ownership = mp.ownership;\n+        let mp = mod_file_path(sess, ident, span, &attrs, &module.dir_path, dir_ownership)?;\n+        dir_ownership = mp.dir_ownership;\n \n         // Ensure file paths are acyclic.\n-        error_on_circular_module(&sess.parse_sess, span, &mp.path, &module.file_path_stack)?;\n+        error_on_circular_module(&sess.parse_sess, span, &mp.file_path, &module.file_path_stack)?;\n \n         // Actually parse the external file as a module.\n-        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n+        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.file_path, Some(span));\n         let (mut inner_attrs, items, inner_span) = parser.parse_mod(&token::Eof)?;\n         attrs.append(&mut inner_attrs);\n-        (items, inner_span, mp.path)\n+        (items, inner_span, mp.file_path)\n     };\n     // (1) ...instead, we return a dummy module.\n     let (items, inner_span, file_path) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n@@ -76,80 +76,80 @@ crate fn parse_external_mod(\n fn error_on_circular_module<'a>(\n     sess: &'a ParseSess,\n     span: Span,\n-    path: &Path,\n+    file_path: &Path,\n     file_path_stack: &[PathBuf],\n ) -> PResult<'a, ()> {\n-    if let Some(i) = file_path_stack.iter().position(|p| *p == path) {\n+    if let Some(i) = file_path_stack.iter().position(|p| *p == file_path) {\n         let mut err = String::from(\"circular modules: \");\n         for p in &file_path_stack[i..] {\n             err.push_str(&p.to_string_lossy());\n             err.push_str(\" -> \");\n         }\n-        err.push_str(&path.to_string_lossy());\n+        err.push_str(&file_path.to_string_lossy());\n         return Err(sess.span_diagnostic.struct_span_err(span, &err[..]));\n     }\n     Ok(())\n }\n \n-crate fn push_directory(\n+crate fn mod_dir_path(\n     sess: &Session,\n-    id: Ident,\n+    ident: Ident,\n     attrs: &[Attribute],\n     module: &ModuleData,\n-    mut dir_ownership: DirectoryOwnership,\n-) -> (PathBuf, DirectoryOwnership) {\n+    mut dir_ownership: DirOwnership,\n+) -> (PathBuf, DirOwnership) {\n     let mut dir_path = module.dir_path.clone();\n     if let Some(file_path) = sess.first_attr_value_str_by_name(attrs, sym::path) {\n         dir_path.push(&*file_path.as_str());\n-        dir_ownership = DirectoryOwnership::Owned { relative: None };\n+        dir_ownership = DirOwnership::Owned { relative: None };\n     } else {\n         // We have to push on the current module name in the case of relative\n         // paths in order to ensure that any additional module paths from inline\n         // `mod x { ... }` come after the relative extension.\n         //\n         // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n         // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n-        if let DirectoryOwnership::Owned { relative } = &mut dir_ownership {\n+        if let DirOwnership::Owned { relative } = &mut dir_ownership {\n             if let Some(ident) = relative.take() {\n                 // Remove the relative offset.\n                 dir_path.push(&*ident.as_str());\n             }\n         }\n-        dir_path.push(&*id.as_str());\n+        dir_path.push(&*ident.as_str());\n     }\n \n     (dir_path, dir_ownership)\n }\n \n-fn submod_path<'a>(\n+fn mod_file_path<'a>(\n     sess: &'a Session,\n-    id: Ident,\n+    ident: Ident,\n     span: Span,\n     attrs: &[Attribute],\n-    ownership: DirectoryOwnership,\n     dir_path: &Path,\n+    dir_ownership: DirOwnership,\n ) -> PResult<'a, ModulePathSuccess> {\n-    if let Some(path) = submod_path_from_attr(sess, attrs, dir_path) {\n+    if let Some(file_path) = mod_file_path_from_attr(sess, attrs, dir_path) {\n         // All `#[path]` files are treated as though they are a `mod.rs` file.\n         // This means that `mod foo;` declarations inside `#[path]`-included\n         // files are siblings,\n         //\n         // Note that this will produce weirdness when a file named `foo.rs` is\n         // `#[path]` included and contains a `mod foo;` declaration.\n         // If you encounter this, it's your own darn fault :P\n-        let ownership = DirectoryOwnership::Owned { relative: None };\n-        return Ok(ModulePathSuccess { ownership, path });\n+        let dir_ownership = DirOwnership::Owned { relative: None };\n+        return Ok(ModulePathSuccess { file_path, dir_ownership });\n     }\n \n-    let relative = match ownership {\n-        DirectoryOwnership::Owned { relative } => relative,\n-        DirectoryOwnership::UnownedViaBlock => None,\n+    let relative = match dir_ownership {\n+        DirOwnership::Owned { relative } => relative,\n+        DirOwnership::UnownedViaBlock => None,\n     };\n     let ModulePath { path_exists, name, result } =\n-        default_submod_path(&sess.parse_sess, id, span, relative, dir_path);\n-    match ownership {\n-        DirectoryOwnership::Owned { .. } => Ok(result?),\n-        DirectoryOwnership::UnownedViaBlock => {\n+        default_submod_path(&sess.parse_sess, ident, span, relative, dir_path);\n+    match dir_ownership {\n+        DirOwnership::Owned { .. } => Ok(result?),\n+        DirOwnership::UnownedViaBlock => {\n             let _ = result.map_err(|mut err| err.cancel());\n             error_decl_mod_in_block(&sess.parse_sess, span, path_exists, &name)\n         }\n@@ -173,7 +173,7 @@ fn error_decl_mod_in_block<'a, T>(\n \n /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n /// The provided `dir_path` is joined with the `path_string`.\n-pub(super) fn submod_path_from_attr(\n+fn mod_file_path_from_attr(\n     sess: &Session,\n     attrs: &[Attribute],\n     dir_path: &Path,\n@@ -196,15 +196,15 @@ pub(super) fn submod_path_from_attr(\n // Public for rustfmt usage.\n pub fn default_submod_path<'a>(\n     sess: &'a ParseSess,\n-    id: Ident,\n+    ident: Ident,\n     span: Span,\n     relative: Option<Ident>,\n     dir_path: &Path,\n ) -> ModulePath<'a> {\n     // If we're in a foo.rs file instead of a mod.rs file,\n     // we need to look for submodules in\n-    // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n-    // `./<id>.rs` and `./<id>/mod.rs`.\n+    // `./foo/<ident>.rs` and `./foo/<ident>/mod.rs` rather than\n+    // `./<ident>.rs` and `./<ident>/mod.rs`.\n     let relative_prefix_string;\n     let relative_prefix = if let Some(ident) = relative {\n         relative_prefix_string = format!(\"{}{}\", ident.name, path::MAIN_SEPARATOR);\n@@ -213,7 +213,7 @@ pub fn default_submod_path<'a>(\n         \"\"\n     };\n \n-    let mod_name = id.name.to_string();\n+    let mod_name = ident.name.to_string();\n     let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n     let secondary_path_str =\n         format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n@@ -224,12 +224,12 @@ pub fn default_submod_path<'a>(\n \n     let result = match (default_exists, secondary_exists) {\n         (true, false) => Ok(ModulePathSuccess {\n-            path: default_path,\n-            ownership: DirectoryOwnership::Owned { relative: Some(id) },\n+            file_path: default_path,\n+            dir_ownership: DirOwnership::Owned { relative: Some(ident) },\n         }),\n         (false, true) => Ok(ModulePathSuccess {\n-            path: secondary_path,\n-            ownership: DirectoryOwnership::Owned { relative: None },\n+            file_path: secondary_path,\n+            dir_ownership: DirOwnership::Owned { relative: None },\n         }),\n         (false, false) => {\n             let mut err = struct_span_err!("}]}