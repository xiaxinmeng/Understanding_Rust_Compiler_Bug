{"sha": "34407dcdbb489a38b15fac0167a88cb94c3d12ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NDA3ZGNkYmI0ODlhMzhiMTVmYWMwMTY3YTg4Y2I5NGMzZDEyYWM=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-07T12:17:01Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-20T15:08:57Z"}, "message": "Provide a witness pattern for non-exhaustive patterns\n\nFixed #4321", "tree": {"sha": "28b710dc420e2f8e4d56d14fc780c7f493876a7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28b710dc420e2f8e4d56d14fc780c7f493876a7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34407dcdbb489a38b15fac0167a88cb94c3d12ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34407dcdbb489a38b15fac0167a88cb94c3d12ac", "html_url": "https://github.com/rust-lang/rust/commit/34407dcdbb489a38b15fac0167a88cb94c3d12ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34407dcdbb489a38b15fac0167a88cb94c3d12ac/comments", "author": null, "committer": null, "parents": [{"sha": "f5e513b2b2dd173f16b84f0531fc3628d62beb4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e513b2b2dd173f16b84f0531fc3628d62beb4d", "html_url": "https://github.com/rust-lang/rust/commit/f5e513b2b2dd173f16b84f0531fc3628d62beb4d"}], "stats": {"total": 1022, "additions": 486, "deletions": 536}, "files": [{"sha": "44657147d050cf3ffd2c2299467023ae5bc0d8d1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 453, "deletions": 521, "changes": 974, "blob_url": "https://github.com/rust-lang/rust/blob/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=34407dcdbb489a38b15fac0167a88cb94c3d12ac", "patch": "@@ -10,23 +10,57 @@\n \n #![allow(non_camel_case_types)]\n \n-use middle::const_eval::{compare_const_vals, lookup_const_by_id};\n-use middle::const_eval::{eval_const_expr, const_val, const_bool, const_float};\n+use middle::const_eval::{compare_const_vals, const_bool, const_float, const_val};\n+use middle::const_eval::{eval_const_expr, lookup_const_by_id};\n use middle::def::*;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n-use util::ppaux::ty_to_str;\n \n-use std::cmp;\n use std::gc::{Gc, GC};\n use std::iter;\n use syntax::ast::*;\n use syntax::ast_util::{is_unguarded, walk_pat};\n-use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::parse::token;\n+use syntax::codemap::{Span, Spanned, DUMMY_SP};\n+use syntax::owned_slice::OwnedSlice;\n+use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n+use util::ppaux::ty_to_str;\n+\n+type Matrix = Vec<Vec<Gc<Pat>>>;\n+\n+#[deriving(Clone)]\n+enum Usefulness {\n+    Useful(Vec<Gc<Pat>>),\n+    NotUseful\n+}\n+\n+enum WitnessPreference {\n+    ConstructWitness,\n+    LeaveOutWitness\n+}\n+\n+impl Usefulness {\n+    fn useful(self) -> Option<Vec<Gc<Pat>>> {\n+        match self {\n+            Useful(pats) => Some(pats),\n+            _ => None\n+        }\n+    }\n+}\n+\n+fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n+    ty::with_path(tcx, id, |path| Path {\n+        global: false,\n+        segments: path.map(|elem| PathSegment {\n+            identifier: Ident::new(elem.name()),\n+            lifetimes: vec!(),\n+            types: OwnedSlice::empty()\n+        }).collect(),\n+        span: DUMMY_SP,\n+    })\n+}\n \n struct MatchCheckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n@@ -58,38 +92,38 @@ pub fn check_crate(tcx: &ty::ctxt,\n fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n     visit::walk_expr(cx, ex, ());\n     match ex.node {\n-      ExprMatch(scrut, ref arms) => {\n-        // First, check legality of move bindings.\n-        for arm in arms.iter() {\n-            check_legality_of_move_bindings(cx,\n-                                            arm.guard.is_some(),\n-                                            arm.pats.as_slice());\n-        }\n+        ExprMatch(scrut, ref arms) => {\n+            // First, check legality of move bindings.\n+            for arm in arms.iter() {\n+                check_legality_of_move_bindings(cx,\n+                                                arm.guard.is_some(),\n+                                                arm.pats.as_slice());\n+            }\n \n-        check_arms(cx, arms.as_slice());\n-        /* Check for exhaustiveness */\n-         // Check for empty enum, because is_useful only works on inhabited\n-         // types.\n-       let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n-       if (*arms).is_empty() {\n-           if !type_is_empty(cx.tcx, pat_ty) {\n-               // We know the type is inhabited, so this must be wrong\n-               cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n-                            type {} is non-empty\",\n-                            ty_to_str(cx.tcx, pat_ty)).as_slice());\n-           }\n-           // If the type *is* empty, it's vacuously exhaustive\n-           return;\n-       }\n-       let m: matrix = arms\n-          .iter()\n-          .filter(|&arm| is_unguarded(arm))\n-          .flat_map(|arm| arm.pats.iter())\n-          .map(|pat| vec!(pat.clone()))\n-          .collect();\n-       check_exhaustive(cx, ex.span, &m);\n-     }\n-     _ => ()\n+            check_arms(cx, arms.as_slice());\n+            /* Check for exhaustiveness */\n+             // Check for empty enum, because is_useful only works on inhabited\n+             // types.\n+            let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n+            if (*arms).is_empty() {\n+               if !type_is_empty(cx.tcx, pat_ty) {\n+                   // We know the type is inhabited, so this must be wrong\n+                   cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n+                                type {} is non-empty\",\n+                                ty_to_str(cx.tcx, pat_ty)).as_slice());\n+               }\n+               // If the type *is* empty, it's vacuously exhaustive\n+               return;\n+            }\n+            let m: Matrix = arms\n+                .iter()\n+                .filter(|&arm| is_unguarded(arm))\n+                .flat_map(|arm| arm.pats.iter())\n+                .map(|pat| vec!(pat.clone()))\n+                .collect();\n+            check_exhaustive(cx, ex.span, &m);\n+        },\n+        _ => ()\n     }\n }\n \n@@ -98,7 +132,6 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     let mut seen = Vec::new();\n     for arm in arms.iter() {\n         for pat in arm.pats.iter() {\n-\n             // Check that we do not match against a static NaN (#6804)\n             let pat_matches_nan: |&Pat| -> bool = |p| {\n                 let opt_def = cx.tcx.def_map.borrow().find_copy(&p.id);\n@@ -123,11 +156,9 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n             });\n \n             let v = vec!(*pat);\n-            match is_useful(cx, &seen, v.as_slice()) {\n-              not_useful => {\n-                cx.tcx.sess.span_err(pat.span, \"unreachable pattern\");\n-              }\n-              _ => ()\n+            match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n+                NotUseful => cx.tcx.sess.span_err(pat.span, \"unreachable pattern\"),\n+                _ => ()\n             }\n             if arm.guard.is_none() { seen.push(v); }\n         }\n@@ -136,71 +167,27 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n \n fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n     match p.node {\n-      PatIdent(_, _, Some(s)) => { raw_pat(s) }\n-      _ => { p }\n+        PatIdent(_, _, Some(s)) => { raw_pat(s) }\n+        _ => { p }\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &matrix) {\n-    let ext = match is_useful(cx, m, [wild()]) {\n-        not_useful => {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n+    match is_useful(cx, m, [wild()], ConstructWitness) {\n+        NotUseful => {\n             // This is good, wildcard pattern isn't reachable\n             return;\n         }\n-        useful_ => None,\n-        useful(ty, ref ctor) => {\n-            match ty::get(ty).sty {\n-                ty::ty_bool => {\n-                    match *ctor {\n-                        val(const_bool(true)) => Some(\"true\".to_string()),\n-                        val(const_bool(false)) => Some(\"false\".to_string()),\n-                        _ => None\n-                    }\n-                }\n-                ty::ty_enum(id, _) => {\n-                    let vid = match *ctor {\n-                        variant(id) => id,\n-                        _ => fail!(\"check_exhaustive: non-variant ctor\"),\n-                    };\n-                    let variants = ty::enum_variants(cx.tcx, id);\n-\n-                    match variants.iter().find(|v| v.id == vid) {\n-                        Some(v) => {\n-                            Some(token::get_ident(v.name).get()\n-                                                         .to_str()\n-                                                         .into_string())\n-                        }\n-                        None => {\n-                            fail!(\"check_exhaustive: bad variant in ctor\")\n-                        }\n-                    }\n-                }\n-                ty::ty_vec(..) | ty::ty_rptr(..) => {\n-                    match *ctor {\n-                        vec(n) => {\n-                            Some(format!(\"vectors of length {}\", n))\n-                        }\n-                        _ => None\n-                    }\n-                }\n-                _ => None\n-            }\n+        Useful(pats) => {\n+            let witness = match pats.as_slice() {\n+                [ref witness] => witness.clone(),\n+                [] => wild(),\n+                _ => unreachable!()\n+            };\n+            let msg = format!(\"non-exhaustive patterns: {0} not covered\", pat_to_str(&*witness));\n+            cx.tcx.sess.span_err(sp, msg.as_slice());\n         }\n-    };\n-    let msg = format!(\"non-exhaustive patterns{}\", match ext {\n-        Some(ref s) => format!(\": {} not covered\", *s),\n-        None => \"\".to_string()\n-    });\n-    cx.tcx.sess.span_err(sp, msg.as_slice());\n-}\n-\n-type matrix = Vec<Vec<Gc<Pat>>>;\n-\n-#[deriving(Clone)]\n-enum useful {\n-    useful(ty::t, ctor),\n-    useful_,\n-    not_useful,\n+    }\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -212,6 +199,129 @@ enum ctor {\n     vec(uint)\n }\n \n+fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n+    let node = match value {\n+        &const_bool(b) => LitBool(b),\n+        _ => unreachable!()\n+    };\n+    box(GC) Expr {\n+        id: 0,\n+        node: ExprLit(box(GC) Spanned { node: node, span: DUMMY_SP }),\n+        span: DUMMY_SP\n+    }\n+}\n+\n+fn construct_witness(cx: &MatchCheckCtxt, ctor: &ctor, pats: Vec<Gc<Pat>>, lty: ty::t) -> Gc<Pat> {\n+    let pat = match ty::get(lty).sty {\n+        ty::ty_tup(_) => PatTup(pats),\n+\n+        ty::ty_enum(_, _) => {\n+            let vid = match ctor {\n+                &variant(vid) => vid,\n+                _ => unreachable!()\n+            };\n+            PatEnum(def_to_path(cx.tcx, vid), Some(pats))\n+        },\n+\n+        ty::ty_struct(cid, _) => {\n+            let fields = ty::lookup_struct_fields(cx.tcx, cid);\n+            let field_pats = fields.move_iter()\n+                .zip(pats.iter())\n+                .map(|(field, pat)| FieldPat {\n+                    ident: Ident::new(field.name),\n+                    pat: pat.clone()\n+                }).collect();\n+            PatStruct(def_to_path(cx.tcx, cid), field_pats, false)\n+        },\n+\n+        ty::ty_rptr(_, ty::mt { ty: ty, .. }) => {\n+            match ty::get(ty).sty {\n+                ty::ty_vec(_, None) => match ctor {\n+                    &vec(_) => PatVec(pats, None, vec!()),\n+                    _ => unreachable!()\n+                },\n+                _ => {\n+                    assert_eq!(pats.len(), 1);\n+                    PatRegion(pats.get(0).clone())\n+                }\n+            }\n+        },\n+\n+        ty::ty_box(_) => {\n+            assert_eq!(pats.len(), 1);\n+            PatBox(pats.get(0).clone())\n+        },\n+\n+        _ => {\n+            match ctor {\n+                &vec(_) => PatVec(pats, None, vec!()),\n+                &val(ref v) => PatLit(const_val_to_expr(v)),\n+                _ => PatWild\n+            }\n+        }\n+    };\n+\n+    box(GC) Pat {\n+        id: 0,\n+        node: pat,\n+        span: DUMMY_SP\n+    }\n+}\n+\n+fn missing_constructor(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Option<ctor> {\n+    let used_constructors: Vec<ctor> = m.iter()\n+        .filter_map(|r| pat_ctor_id(cx, left_ty, *r.get(0)))\n+        .collect();\n+\n+    all_constructors(cx, m, left_ty)\n+        .move_iter()\n+        .find(|c| !used_constructors.contains(c))\n+}\n+\n+fn all_constructors(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Vec<ctor> {\n+    fn vec_constructors(m: &Matrix) -> Vec<ctor> {\n+        let max_vec_len = m.iter().map(|r| match r.get(0).node {\n+            PatVec(ref before, _, ref after) => before.len() + after.len(),\n+            _ => 0u\n+        }).max().unwrap_or(0u);\n+        let contains_slice = m.iter().any(|r| match r.get(0).node {\n+            PatVec(_, ref slice, _) => slice.is_some(),\n+            _ => false\n+        });\n+        let lengths = iter::range_inclusive(0u, if contains_slice {\n+            max_vec_len\n+        } else {\n+            max_vec_len + 1\n+        });\n+        lengths.map(|len| vec(len)).collect()\n+    }\n+\n+    match ty::get(left_ty).sty {\n+        ty::ty_bool =>\n+            [true, false].iter().map(|b| val(const_bool(*b))).collect(),\n+\n+        ty::ty_rptr(_, ty::mt { ty: ty, .. }) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) => vec_constructors(m),\n+            _ => vec!(single)\n+        },\n+\n+        ty::ty_enum(eid, _) =>\n+            ty::enum_variants(cx.tcx, eid).iter().map(|va| variant(va.id)).collect(),\n+\n+        ty::ty_vec(_, None) =>\n+            vec_constructors(m),\n+\n+        ty::ty_vec(_, Some(n)) =>\n+            vec!(vec(n)),\n+\n+        ty::ty_nil if !m.iter().all(|r| is_wild(cx, *r.get(0))) =>\n+            vec!(),\n+\n+        _ =>\n+            vec!(single)\n+    }\n+}\n+\n // Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n //\n // Whether a vector `v` of patterns is 'useful' in relation to a set of such\n@@ -225,12 +335,13 @@ enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[Gc<Pat>]) -> useful {\n+fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n+             witness: WitnessPreference) -> Usefulness {\n     if m.len() == 0u {\n-        return useful_;\n+        return Useful(vec!());\n     }\n     if m.get(0).len() == 0u {\n-        return not_useful\n+        return NotUseful;\n     }\n     let real_pat = match m.iter().find(|r| r.get(0).id != 0) {\n         Some(r) => {\n@@ -241,310 +352,146 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[Gc<Pat>]) -> useful {\n                 _ => *r.get(0)\n             }\n         }\n-        None if v.len() == 0 => return not_useful,\n+        None if v.len() == 0 => return NotUseful,\n         None => v[0]\n     };\n-    let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n-                  else { ty::node_id_to_type(cx.tcx, real_pat.id) };\n-\n-    match pat_ctor_id(cx, v[0]) {\n-      None => {\n-        match missing_ctor(cx, m, left_ty) {\n-          None => {\n-            match ty::get(left_ty).sty {\n-              ty::ty_bool => {\n-                  match is_useful_specialized(cx, m, v,\n-                                              val(const_bool(true)),\n-                                              0u, left_ty){\n-                      not_useful => {\n-                          is_useful_specialized(cx, m, v,\n-                                                val(const_bool(false)),\n-                                                0u, left_ty)\n-                      }\n-                      u => u,\n-                  }\n-              }\n-              ty::ty_enum(eid, _) => {\n-                  for va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n-                      match is_useful_specialized(cx, m, v, variant(va.id),\n-                                                  va.args.len(), left_ty) {\n-                        not_useful => (),\n-                        u => return u,\n-                      }\n-                  }\n-                  not_useful\n-              }\n-              ty::ty_vec(_, Some(n)) => {\n-                  is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n-              }\n-              ty::ty_vec(..) => fail!(\"impossible case\"),\n-              ty::ty_rptr(_, ty::mt{ty: ty, ..}) | ty::ty_uniq(ty) => match ty::get(ty).sty {\n-                  ty::ty_vec(_, None) => {\n-                      let max_len = m.iter().rev().fold(0, |max_len, r| {\n-                          match r.get(0).node {\n-                              PatVec(ref before, _, ref after) => {\n-                                  cmp::max(before.len() + after.len(), max_len)\n-                              }\n-                              _ => max_len\n-                          }\n-                      });\n-                      for n in iter::range(0u, max_len + 1) {\n-                          match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n-                              not_useful => (),\n-                              u => return u,\n-                          }\n-                      }\n-                      not_useful\n-                  }\n-                  _ => {\n-                      let arity = ctor_arity(cx, &single, left_ty);\n-                      is_useful_specialized(cx, m, v, single, arity, left_ty)\n-                  }\n-              },\n-              _ => {\n-                  let arity = ctor_arity(cx, &single, left_ty);\n-                  is_useful_specialized(cx, m, v, single, arity, left_ty)\n-              }\n-            }\n-          }\n-          Some(ctor) => {\n-            match is_useful(cx,\n-                            &m.iter().filter_map(|r| {\n-                                default(cx, r.as_slice())\n-                            }).collect::<matrix>(),\n-                            v.tail()) {\n-              useful_ => useful(left_ty, ctor),\n-              u => u,\n+    let left_ty = if real_pat.id == 0 {\n+        ty::mk_nil()\n+    } else {\n+        ty::pat_ty(cx.tcx, &*real_pat)\n+    };\n+\n+    match pat_ctor_id(cx, left_ty, v[0]) {\n+        None => match missing_constructor(cx, m, left_ty) {\n+            None => {\n+                all_constructors(cx, m, left_ty).move_iter().filter_map(|c| {\n+                    is_useful_specialized(cx, m, v, c.clone(),\n+                                          left_ty, witness).useful().map(|pats| {\n+                        Useful(match witness {\n+                            ConstructWitness => {\n+                                let arity = constructor_arity(cx, &c, left_ty);\n+                                let subpats = {\n+                                    let pat_slice = pats.as_slice();\n+                                    Vec::from_fn(arity, |i| {\n+                                        pat_slice.get(i).map(|p| p.clone())\n+                                            .unwrap_or_else(|| wild())\n+                                    })\n+                                };\n+                                let mut result = vec!(construct_witness(cx, &c, subpats, left_ty));\n+                                result.extend(pats.move_iter().skip(arity));\n+                                result\n+                            }\n+                            LeaveOutWitness => vec!()\n+                        })\n+                    })\n+                }).nth(0).unwrap_or(NotUseful)\n+            },\n+\n+            Some(ctor) => {\n+                let matrix = &m.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n+                match is_useful(cx, matrix, v.tail(), witness) {\n+                    Useful(pats) => Useful(match witness {\n+                        ConstructWitness => {\n+                            let arity = constructor_arity(cx, &ctor, left_ty);\n+                            let wild_pats = Vec::from_elem(arity, wild());\n+                            let enum_pat = construct_witness(cx, &ctor, wild_pats, left_ty);\n+                            (vec!(enum_pat)).append(pats.as_slice())\n+                        }\n+                        LeaveOutWitness => vec!()\n+                    }),\n+                    result => result\n+                }\n             }\n-          }\n-        }\n-      }\n-      Some(v0_ctor) => {\n-        let arity = ctor_arity(cx, &v0_ctor, left_ty);\n-        is_useful_specialized(cx, m, v, v0_ctor, arity, left_ty)\n-      }\n+        },\n+\n+        Some(v0_ctor) => is_useful_specialized(cx, m, v, v0_ctor, left_ty, witness)\n     }\n }\n \n-fn is_useful_specialized(cx: &MatchCheckCtxt,\n-                             m: &matrix,\n-                             v: &[Gc<Pat>],\n-                             ctor: ctor,\n-                             arity: uint,\n-                             lty: ty::t)\n-                             -> useful {\n-    let ms = m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &ctor, arity, lty)\n-    }).collect::<matrix>();\n-    let could_be_useful = match specialize(cx, v, &ctor, arity, lty) {\n-        Some(v) => is_useful(cx, &ms, v.as_slice()),\n-        None => return not_useful,\n-    };\n-    match could_be_useful {\n-      useful_ => useful(lty, ctor),\n-      u => u,\n+fn is_useful_specialized(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n+                         ctor: ctor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n+    let arity = constructor_arity(cx, &ctor, lty);\n+    let matrix = m.iter().filter_map(|r| {\n+        specialize(cx, r.as_slice(), &ctor, arity)\n+    }).collect();\n+    match specialize(cx, v, &ctor, arity) {\n+        Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n+        None => NotUseful\n     }\n }\n \n-fn pat_ctor_id(cx: &MatchCheckCtxt, p: Gc<Pat>) -> Option<ctor> {\n+fn pat_ctor_id(cx: &MatchCheckCtxt, left_ty: ty::t, p: Gc<Pat>) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-      PatWild | PatWildMulti => { None }\n-      PatIdent(_, _, _) | PatEnum(_, _) => {\n-        let opt_def = cx.tcx.def_map.borrow().find_copy(&pat.id);\n-        match opt_def {\n-          Some(DefVariant(_, id, _)) => Some(variant(id)),\n-          Some(DefStatic(did, false)) => {\n-            let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-            Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n-          }\n-          _ => None\n-        }\n-      }\n-      PatLit(ref expr) => { Some(val(eval_const_expr(cx.tcx, &**expr))) }\n-      PatRange(ref lo, ref hi) => {\n-        Some(range(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi)))\n-      }\n-      PatStruct(..) => {\n-        match cx.tcx.def_map.borrow().find(&pat.id) {\n-          Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-          _ => Some(single)\n-        }\n-      }\n-      PatBox(_) | PatTup(_) | PatRegion(..) => {\n-        Some(single)\n-      }\n-      PatVec(ref before, slice, ref after) => {\n-        match slice {\n-          Some(_) => None,\n-          None => Some(vec(before.len() + after.len()))\n-        }\n-      }\n-      PatMac(_) => cx.tcx.sess.bug(\"unexpanded macro\"),\n+        PatIdent(..) | PatEnum(..) | PatStruct(..) =>\n+            match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefStatic(did, false)) => {\n+                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n+                    Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n+                },\n+                Some(&DefVariant(_, id, _)) =>\n+                    Some(variant(id)),\n+                _ => match pat.node {\n+                    PatEnum(..) | PatStruct(..) => Some(single),\n+                    PatIdent(..) => None,\n+                    _ => unreachable!()\n+                }\n+            },\n+        PatLit(expr) =>\n+            Some(val(eval_const_expr(cx.tcx, &*expr))),\n+        PatRange(lo, hi) =>\n+            Some(range(eval_const_expr(cx.tcx, &*lo), eval_const_expr(cx.tcx, &*hi))),\n+        PatVec(ref before, _, ref after) => match ty::get(left_ty).sty {\n+            ty::ty_vec(_, Some(n)) =>\n+                Some(vec(n)),\n+            _ =>\n+                Some(vec(before.len() + after.len()))\n+        },\n+        PatBox(_) | PatTup(_) | PatRegion(..) =>\n+            Some(single),\n+        PatWild | PatWildMulti =>\n+            None,\n+        PatMac(_) =>\n+            cx.tcx.sess.bug(\"unexpanded macro\")\n     }\n }\n \n fn is_wild(cx: &MatchCheckCtxt, p: Gc<Pat>) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n-      PatWild | PatWildMulti => { true }\n-      PatIdent(_, _, _) => {\n-        match cx.tcx.def_map.borrow().find(&pat.id) {\n-          Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => { false }\n-          _ => { true }\n-        }\n-      }\n-      _ => { false }\n-    }\n-}\n-\n-fn missing_ctor(cx: &MatchCheckCtxt,\n-                m: &matrix,\n-                left_ty: ty::t)\n-                -> Option<ctor> {\n-    return match ty::get(left_ty).sty {\n-      ty::ty_box(_) | ty::ty_tup(_) |\n-      ty::ty_struct(..) => check_matrix_for_wild(cx, m),\n-      ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty: ty, ..}) => match ty::get(ty).sty {\n-          ty::ty_vec(_, None) => ctor_for_slice(m),\n-          ty::ty_str => Some(single),\n-          _ => check_matrix_for_wild(cx, m),\n-      },\n-      ty::ty_enum(eid, _) => {\n-        let pat_ctors: Vec<ctor> = m\n-          .iter()\n-          .filter_map(|r| pat_ctor_id(cx, *r.get(0)))\n-          .collect();\n-        let variants = ty::enum_variants(cx.tcx, eid);\n-        variants.iter().map(|v| variant(v.id)).find(|c| !pat_ctors.contains(c))\n-      }\n-      ty::ty_nil => None,\n-      ty::ty_bool => {\n-        let mut true_found = false;\n-        let mut false_found = false;\n-        for r in m.iter() {\n-            match pat_ctor_id(cx, *r.get(0)) {\n-              None => (),\n-              Some(val(const_bool(true))) => true_found = true,\n-              Some(val(const_bool(false))) => false_found = true,\n-              _ => fail!(\"impossible case\")\n-            }\n-        }\n-        if true_found && false_found { None }\n-        else if true_found { Some(val(const_bool(false))) }\n-        else { Some(val(const_bool(true))) }\n-      }\n-      ty::ty_vec(_, Some(n)) => {\n-        let mut missing = true;\n-        let mut wrong = false;\n-        for r in m.iter() {\n-          match r.get(0).node {\n-            PatVec(ref before, ref slice, ref after) => {\n-              let count = before.len() + after.len();\n-              if (count < n && slice.is_none()) || count > n {\n-                wrong = true;\n-              }\n-              if count == n || (count < n && slice.is_some()) {\n-                missing = false;\n-              }\n+        PatWild | PatWildMulti => true,\n+        PatIdent(_, _, _) => {\n+            match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => false,\n+                _ => true\n             }\n-            _ => {}\n-          }\n-        }\n-        match (wrong, missing) {\n-          (true, _) => Some(vec(n)), // should be compile-time error\n-          (_, true) => Some(vec(n)),\n-          _         => None\n-        }\n-      }\n-      ty::ty_vec(..) => fail!(\"impossible case\"),\n-      _ => Some(single)\n-    };\n-\n-    fn check_matrix_for_wild(cx: &MatchCheckCtxt, m: &matrix) -> Option<ctor> {\n-        for r in m.iter() {\n-            if !is_wild(cx, *r.get(0)) { return None; }\n-        }\n-        return Some(single);\n-    }\n-\n-    // For slice and ~[T].\n-    fn ctor_for_slice(m: &matrix) -> Option<ctor> {\n-        // Find the lengths and slices of all vector patterns.\n-        let mut vec_pat_lens = m.iter().filter_map(|r| {\n-            match r.get(0).node {\n-                PatVec(ref before, ref slice, ref after) => {\n-                    Some((before.len() + after.len(), slice.is_some()))\n-                }\n-                _ => None\n-            }\n-        }).collect::<Vec<(uint, bool)> >();\n-\n-        // Sort them by length such that for patterns of the same length,\n-        // those with a destructured slice come first.\n-        vec_pat_lens.sort_by(|&(len1, slice1), &(len2, slice2)| {\n-                    if len1 == len2 {\n-                        slice2.cmp(&slice1)\n-                    } else {\n-                        len1.cmp(&len2)\n-                    }\n-                });\n-        vec_pat_lens.dedup();\n-\n-        let mut found_slice = false;\n-        let mut next = 0;\n-        let mut missing = None;\n-        for &(length, slice) in vec_pat_lens.iter() {\n-            if length != next {\n-                missing = Some(next);\n-                break;\n-            }\n-            if slice {\n-                found_slice = true;\n-                break;\n-            }\n-            next += 1;\n-        }\n-\n-        // We found patterns of all lengths within <0, next), yet there was no\n-        // pattern with a slice - therefore, we report vec(next) as missing.\n-        if !found_slice {\n-            missing = Some(next);\n-        }\n-        match missing {\n-          Some(k) => Some(vec(k)),\n-          None => None\n         }\n+        _ => false\n     }\n }\n \n-fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n-    fn vec_ctor_arity(ctor: &ctor) -> uint {\n-        match *ctor {\n-            vec(n) => n,\n-            _ => 0u\n-        }\n-    }\n-\n+fn constructor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n         ty::ty_tup(ref fs) => fs.len(),\n-        ty::ty_box(_) => 1u,\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty: ty, ..}) => match ty::get(ty).sty {\n-            ty::ty_vec(_, None) => vec_ctor_arity(ctor),\n-            _ => 1u,\n+        ty::ty_box(_) | ty::ty_uniq(_) => 1u,\n+        ty::ty_rptr(_, ty::mt { ty: ty, .. }) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) => match *ctor {\n+                vec(n) => n,\n+                _ => 0u\n+            },\n+            _ => 1u\n         },\n         ty::ty_enum(eid, _) => {\n-            let id = match *ctor {\n-                variant(id) => id,\n-                _ => fail!(\"impossible case\")\n-            };\n-            match ty::enum_variants(cx.tcx, eid).iter().find(|v| v.id == id ) {\n-                Some(v) => v.args.len(),\n-                None => fail!(\"impossible case\")\n+            match *ctor {\n+                variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                _ => unreachable!()\n             }\n         }\n         ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-        ty::ty_vec(_, Some(_)) => vec_ctor_arity(ctor),\n+        ty::ty_vec(_, _) => match *ctor {\n+            vec(n) => n,\n+            _ => 0u\n+        },\n         _ => 0u\n     }\n }\n@@ -553,10 +500,6 @@ fn wild() -> Gc<Pat> {\n     box(GC) Pat {id: 0, node: PatWild, span: DUMMY_SP}\n }\n \n-fn wild_multi() -> Gc<Pat> {\n-    box(GC) Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n-}\n-\n fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val) -> Option<bool> {\n     let (c_from, c_to) = match *ctor_id {\n         val(ref value)          => (value, value),\n@@ -572,164 +515,153 @@ fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val\n     }\n }\n \n-fn specialize(cx: &MatchCheckCtxt,\n-                  r: &[Gc<Pat>],\n-                  ctor_id: &ctor,\n-                  arity: uint,\n-                  left_ty: ty::t)\n-               -> Option<Vec<Gc<Pat>>> {\n-    let &Pat{id: ref pat_id, node: ref n, span: ref pat_span} = &(*raw_pat(r[0]));\n+fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n+              ctor_id: &ctor, arity: uint) -> Option<Vec<Gc<Pat>>> {\n+    let &Pat {\n+        id: ref pat_id, node: ref n, span: ref pat_span\n+    } = &(*raw_pat(r[0]));\n     let head: Option<Vec<Gc<Pat>>> = match n {\n-            &PatWild => {\n-                Some(Vec::from_elem(arity, wild()))\n-            }\n-            &PatWildMulti => {\n-                Some(Vec::from_elem(arity, wild_multi()))\n-            }\n-            &PatIdent(_, _, _) => {\n-                let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n-                match opt_def {\n-                    Some(DefVariant(_, id, _)) => {\n-                        if variant(id) == *ctor_id {\n-                            Some(vec!())\n-                        } else {\n-                            None\n-                        }\n+        &PatWild => {\n+            Some(Vec::from_elem(arity, wild()))\n+        }\n+        &PatWildMulti => {\n+            Some(Vec::from_elem(arity, wild()))\n+        }\n+        &PatIdent(_, _, _) => {\n+            let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n+            match opt_def {\n+                Some(DefVariant(_, id, _)) => {\n+                    if variant(id) == *ctor_id {\n+                        Some(vec!())\n+                    } else {\n+                        None\n                     }\n-                    Some(DefStatic(did, _)) => {\n-                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                        match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n-                           Some(true) => Some(vec!()),\n-                           Some(false) => None,\n-                           None => {\n-                              cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n-                              None\n-                           }\n+                }\n+                Some(DefStatic(did, _)) => {\n+                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n+                    let e_v = eval_const_expr(cx.tcx, &*const_expr);\n+                    match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                        Some(true) => Some(vec!()),\n+                        Some(false) => None,\n+                        None => {\n+                            cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                            None\n                         }\n                     }\n-                    _ => {\n-                        Some(Vec::from_elem(arity, wild()))\n-                    }\n+                }\n+                _ => {\n+                    Some(Vec::from_elem(arity, wild()))\n                 }\n             }\n-            &PatEnum(_, ref args) => {\n-                let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n-                match def {\n-                    DefStatic(did, _) => {\n-                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                        match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n-                           Some(true) => Some(vec!()),\n-                           Some(false) => None,\n-                           None => {\n-                              cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n-                              None\n-                           }\n+        }\n+        &PatEnum(_, ref args) => {\n+            let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+            match def {\n+                DefStatic(did, _) => {\n+                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n+                    let e_v = eval_const_expr(cx.tcx, &*const_expr);\n+                    match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                        Some(true) => Some(vec!()),\n+                        Some(false) => None,\n+                        None => {\n+                            cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                            None\n                         }\n                     }\n-                    DefVariant(_, id, _) if variant(id) != *ctor_id => None,\n-                    DefVariant(..) | DefFn(..) | DefStruct(..) => {\n-                        Some(match args {\n-                            &Some(ref args) => args.clone(),\n-                            &None => Vec::from_elem(arity, wild())\n-                        })\n-                    }\n-                    _ => None\n                 }\n+                DefVariant(_, id, _) if variant(id) != *ctor_id => None,\n+                DefVariant(..) | DefFn(..) | DefStruct(..) => {\n+                    Some(match args {\n+                        &Some(ref args) => args.clone(),\n+                        &None => Vec::from_elem(arity, wild())\n+                    })\n+                }\n+                _ => None\n             }\n-            &PatStruct(_, ref pattern_fields, _) => {\n-                // Is this a struct or an enum variant?\n-                let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n-                let class_id = match def {\n-                    DefVariant(_, variant_id, _) => {\n-                      if variant(variant_id) == *ctor_id {\n-                        Some(variant_id)\n-                      } else {\n-                        None\n-                      }\n-                    }\n-                    _ => {\n-                        match ty::get(left_ty).sty {\n-                            ty::ty_struct(cid, _) => Some(cid),\n-                            _ => {\n-                                cx.tcx.sess.span_bug(\n-                                    *pat_span,\n-                                    format!(\"struct pattern resolved to {}, \\\n-                                          not a struct\",\n-                                         ty_to_str(cx.tcx,\n-                                                   left_ty)).as_slice());\n-                            }\n-                        }\n+        }\n+\n+        &PatStruct(_, ref pattern_fields, _) => {\n+            // Is this a struct or an enum variant?\n+            let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+            let class_id = match def {\n+                DefVariant(_, variant_id, _) => if variant(variant_id) == *ctor_id {\n+                    Some(variant_id)\n+                } else {\n+                    None\n+                },\n+                DefStruct(struct_id) => Some(struct_id),\n+                _ => None\n+            };\n+            class_id.map(|variant_id| {\n+                let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n+                let args = struct_fields.iter().map(|sf| {\n+                    match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n+                        Some(f) => f.pat,\n+                        _ => wild()\n                     }\n-                };\n-                class_id.map(|variant_id| {\n-                  let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n-                  let args = struct_fields.iter().map(|sf| {\n-                      match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n-                          Some(f) => f.pat,\n-                          _ => wild()\n-                      }\n-                  }).collect();\n-                  args\n-                })\n+                }).collect();\n+                args\n+            })\n+        }\n \n-            }\n-            &PatTup(ref args) => {\n-                Some(args.clone())\n-            }\n-            &PatBox(ref inner) | &PatRegion(ref inner) => {\n-                Some(vec!(inner.clone()))\n-            }\n-            &PatLit(ref expr) => {\n-              let expr_value = eval_const_expr(cx.tcx, &**expr);\n-              match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n-                 Some(true) => Some(vec!()),\n-                 Some(false) => None,\n-                 None => {\n+        &PatTup(ref args) =>\n+            Some(args.clone()),\n+\n+        &PatBox(ref inner) | &PatRegion(ref inner) =>\n+            Some(vec!(inner.clone())),\n+\n+        &PatLit(ref expr) => {\n+            let expr_value = eval_const_expr(cx.tcx, &**expr);\n+            match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n+                Some(true) => Some(vec!()),\n+                Some(false) => None,\n+                None => {\n                     cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n                     None\n-                 }\n-              }\n+                }\n             }\n-            &PatRange(ref from, ref to) => {\n-              let from_value = eval_const_expr(cx.tcx, &**from);\n-              let to_value = eval_const_expr(cx.tcx, &**to);\n-              match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n-                 Some(true) => Some(vec!()),\n-                 Some(false) => None,\n-                 None => {\n+        }\n+\n+        &PatRange(ref from, ref to) => {\n+            let from_value = eval_const_expr(cx.tcx, &**from);\n+            let to_value = eval_const_expr(cx.tcx, &**to);\n+            match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n+                Some(true) => Some(vec!()),\n+                Some(false) => None,\n+                None => {\n                     cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n                     None\n-                 }\n-              }\n+                }\n             }\n-            &PatVec(ref before, ref slice, ref after) => {\n-                match *ctor_id {\n-                    vec(_) => {\n-                        let num_elements = before.len() + after.len();\n-                        if num_elements < arity && slice.is_some() {\n-                            let mut result = Vec::new();\n-                            result.push_all(before.as_slice());\n-                            result.grow_fn(arity - num_elements, |_| wild());\n-                            result.push_all(after.as_slice());\n-                            Some(result)\n-                        } else if num_elements == arity {\n-                            let mut result = Vec::new();\n-                            result.push_all(before.as_slice());\n-                            result.push_all(after.as_slice());\n-                            Some(result)\n-                        } else {\n-                            None\n-                        }\n+        }\n+\n+        &PatVec(ref before, ref slice, ref after) => {\n+            match *ctor_id {\n+                vec(_) => {\n+                    let num_elements = before.len() + after.len();\n+                    if num_elements < arity && slice.is_some() {\n+                        let mut result = Vec::new();\n+                        result.push_all(before.as_slice());\n+                        result.grow_fn(arity - num_elements, |_| wild());\n+                        result.push_all(after.as_slice());\n+                        Some(result)\n+                    } else if num_elements == arity {\n+                        let mut result = Vec::new();\n+                        result.push_all(before.as_slice());\n+                        result.push_all(after.as_slice());\n+                        Some(result)\n+                    } else {\n+                        None\n                     }\n-                    _ => None\n                 }\n+                _ => None\n             }\n-            &PatMac(_) => {\n-                cx.tcx.sess.span_err(*pat_span, \"unexpanded macro\");\n-                None\n-            }\n+        }\n+\n+        &PatMac(_) => {\n+            cx.tcx.sess.span_err(*pat_span, \"unexpanded macro\");\n+            None\n+        }\n     };\n     head.map(|head| head.append(r.tail()))\n }\n@@ -787,7 +719,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n \n fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n     let pats = vec!(vec!(pat));\n-    is_useful(cx, &pats, [wild()])\n+    is_useful(cx, &pats, [wild()], ConstructWitness)\n         .useful()\n         .map(|pats| {\n             assert_eq!(pats.len(), 1);"}, {"sha": "98eb62fe392bbeb9192a7f278bbc79384304215c", "filename": "src/test/compile-fail/issue-2111.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs?ref=34407dcdbb489a38b15fac0167a88cb94c3d12ac", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n fn foo(a: Option<uint>, b: Option<uint>) {\n-  match (a,b) { //~ ERROR: non-exhaustive patterns: None not covered\n+  match (a,b) {\n+  //~^ ERROR: non-exhaustive patterns: (core::option::None, core::option::None) not covered\n     (Some(a), Some(b)) if a == b => { }\n     (Some(_), None) |\n     (None, Some(_)) => { }"}, {"sha": "660183366e8b10b244fc00348bfb74e3b03b90f8", "filename": "src/test/compile-fail/issue-4321.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs?ref=34407dcdbb489a38b15fac0167a88cb94c3d12ac", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let tup = (true, true);\n+    println!(\"foo {:}\", match tup { //~ ERROR non-exhaustive patterns: (true, false) not covered\n+        (false, false) => \"foo\",\n+        (false, true) => \"bar\",\n+        (true, true) => \"baz\"\n+    });\n+}"}, {"sha": "bb5b2e750d5025a523364a13a356d70162a9aa14", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=34407dcdbb489a38b15fac0167a88cb94c3d12ac", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: non-exhaustive patterns\n enum t { a(u), b }\n enum u { c, d }\n \n fn main() {\n   let x = a(c);\n-  match x {\n+  match x { //~ ERROR non-exhaustive patterns: a(c) not covered\n       a(d) => { fail!(\"hello\"); }\n       b => { fail!(\"goodbye\"); }\n     }"}, {"sha": "97b65a305e06a25f6717b408ee97e459f1befada", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=34407dcdbb489a38b15fac0167a88cb94c3d12ac", "patch": "@@ -12,21 +12,21 @@ enum t { a, b, }\n \n fn main() {\n     let x = a;\n-    match x { b => { } } //~ ERROR non-exhaustive patterns\n-    match true { //~ ERROR non-exhaustive patterns\n+    match x { b => { } } //~ ERROR non-exhaustive patterns: a not covered\n+    match true { //~ ERROR non-exhaustive patterns: false not covered\n       true => {}\n     }\n-    match Some(10) { //~ ERROR non-exhaustive patterns\n+    match Some(10) { //~ ERROR non-exhaustive patterns: core::option::Some(_) not covered\n       None => {}\n     }\n-    match (2, 3, 4) { //~ ERROR non-exhaustive patterns\n+    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: (_, _, _) not covered\n       (_, _, 4) => {}\n     }\n-    match (a, a) { //~ ERROR non-exhaustive patterns\n+    match (a, a) { //~ ERROR non-exhaustive patterns: (a, a) not covered\n       (a, b) => {}\n       (b, a) => {}\n     }\n-    match a { //~ ERROR b not covered\n+    match a { //~ ERROR non-exhaustive patterns: b not covered\n       a => {}\n     }\n     // This is exhaustive, though the algorithm got it wrong at one point\n@@ -37,8 +37,7 @@ fn main() {\n     }\n     let vec = vec!(Some(42), None, Some(21));\n     let vec: &[Option<int>] = vec.as_slice();\n-    match vec {\n-        //~^ ERROR non-exhaustive patterns: vectors of length 0 not covered\n+    match vec { //~ ERROR non-exhaustive patterns: [] not covered\n         [Some(..), None, ..tail] => {}\n         [Some(..), Some(..), ..tail] => {}\n         [None] => {}\n@@ -51,7 +50,7 @@ fn main() {\n     }\n     let vec = vec!(0.5);\n     let vec: &[f32] = vec.as_slice();\n-    match vec { //~ ERROR non-exhaustive patterns: vectors of length 4 not covered\n+    match vec { //~ ERROR non-exhaustive patterns: [_, _, _, _] not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),"}, {"sha": "d664ea10b98c476040218235581956e8a9733eeb", "filename": "src/test/compile-fail/refutable-pattern-errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs?ref=34407dcdbb489a38b15fac0167a88cb94c3d12ac", "patch": "@@ -10,9 +10,9 @@\n \n \n fn func((1, (Some(1), 2..3)): (int, (Option<int>, int))) { }\n-//~^ ERROR refutable pattern in function argument\n+//~^ ERROR refutable pattern in function argument: (_, _) not covered\n \n fn main() {\n     let (1, (Some(1), 2..3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding\n+    //~^ ERROR refutable pattern in local binding: (_, _) not covered\n }"}, {"sha": "064957979f7f99a8a9e47bfe5471b7f1e240b23e", "filename": "src/test/compile-fail/refutable-pattern-in-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34407dcdbb489a38b15fac0167a88cb94c3d12ac/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs?ref=34407dcdbb489a38b15fac0167a88cb94c3d12ac", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let f = |3: int| println!(\"hello\");  //~ ERROR refutable pattern\n+    let f = |3: int| println!(\"hello\");\n+    //~^ ERROR refutable pattern in function argument: _ not covered\n     f(4);\n }"}]}