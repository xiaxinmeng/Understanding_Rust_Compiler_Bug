{"sha": "788ddedb0d88e40db9cd62b6163d5a471813044b", "node_id": "C_kwDOAAsO6NoAKDc4OGRkZWRiMGQ4OGU0MGRiOWNkNjJiNjE2M2Q1YTQ3MTgxMzA0NGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-26T15:00:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-26T15:00:04Z"}, "message": "Auto merge of #98190 - nnethercote:optimize-derive-Debug-code, r=scottmcm\n\nImprove `derive(Debug)`\n\nr? `@ghost`", "tree": {"sha": "310955235be307f322a6a0592ac8b08efde8afb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/310955235be307f322a6a0592ac8b08efde8afb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/788ddedb0d88e40db9cd62b6163d5a471813044b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/788ddedb0d88e40db9cd62b6163d5a471813044b", "html_url": "https://github.com/rust-lang/rust/commit/788ddedb0d88e40db9cd62b6163d5a471813044b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/788ddedb0d88e40db9cd62b6163d5a471813044b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7125846d17a549866aa1ed0ea28778537378fca8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7125846d17a549866aa1ed0ea28778537378fca8", "html_url": "https://github.com/rust-lang/rust/commit/7125846d17a549866aa1ed0ea28778537378fca8"}, {"sha": "20f0cdaa6356c6a6562ad735adccb51d9e25aae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/20f0cdaa6356c6a6562ad735adccb51d9e25aae8", "html_url": "https://github.com/rust-lang/rust/commit/20f0cdaa6356c6a6562ad735adccb51d9e25aae8"}], "stats": {"total": 646, "additions": 413, "deletions": 233}, "files": [{"sha": "1fffd6f9727d7de0c07c08c434cbb1539bf53ef2", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 117, "deletions": 88, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -3,14 +3,10 @@ use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, LocalKind, MetaItem};\n+use rustc_ast::{self as ast, Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Ident};\n-use rustc_span::{Span, DUMMY_SP};\n-\n-fn make_mut_borrow(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<Expr>) -> P<Expr> {\n-    cx.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Mut, expr))\n-}\n+use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::Span;\n \n pub fn expand_deriving_debug(\n     cx: &mut ExtCtxt<'_>,\n@@ -49,11 +45,7 @@ pub fn expand_deriving_debug(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-/// We use the debug builders to do the heavy lifting here\n fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n-    // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n-    // based on the \"shape\".\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n@@ -67,93 +59,130 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n     let fmt = substr.nonself_args[0].clone();\n \n-    // Special fast path for unit variants. In the common case of an enum that is entirely unit\n-    // variants (i.e. a C-like enum), this fast path allows LLVM to eliminate the entire switch in\n-    // favor of a lookup table.\n-    if let ast::VariantData::Unit(..) = vdata {\n-        let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-        let expr = cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n-        let stmts = vec![cx.stmt_expr(expr)];\n-        let block = cx.block(span, stmts);\n-        return cx.expr_block(block);\n-    }\n-\n-    let builder = Ident::new(sym::debug_trait_builder, span);\n-    let builder_expr = cx.expr_ident(span, builder);\n-\n-    let mut stmts = Vec::with_capacity(fields.len() + 2);\n-    let fn_path_finish;\n-    match vdata {\n+    // Struct and tuples are similar enough that we use the same code for both,\n+    // with some extra pieces for structs due to the field names.\n+    let (is_struct, args_per_field) = match vdata {\n         ast::VariantData::Unit(..) => {\n-            cx.span_bug(span, \"unit variants should have been handled above\");\n+            // Special fast path for unit variants.\n+            //let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n+            //return cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n+            assert!(fields.is_empty());\n+            (false, 0)\n         }\n-        ast::VariantData::Tuple(..) => {\n-            // tuple struct/\"normal\" variant\n-            let fn_path_debug_tuple = cx.std_path(&[sym::fmt, sym::Formatter, sym::debug_tuple]);\n-            let expr = cx.expr_call_global(span, fn_path_debug_tuple, vec![fmt, name]);\n-            let expr = make_mut_borrow(cx, span, expr);\n-            stmts.push(cx.stmt_let(span, false, builder, expr));\n-\n-            for field in fields {\n-                // Use double indirection to make sure this works for unsized types\n-                let field = cx.expr_addr_of(field.span, field.self_.clone());\n-                let field = cx.expr_addr_of(field.span, field);\n-\n-                let fn_path_field = cx.std_path(&[sym::fmt, sym::DebugTuple, sym::field]);\n-                let expr =\n-                    cx.expr_call_global(span, fn_path_field, vec![builder_expr.clone(), field]);\n-\n-                // Use `let _ = expr;` to avoid triggering the\n-                // unused_results lint.\n-                stmts.push(stmt_let_underscore(cx, span, expr));\n-            }\n+        ast::VariantData::Tuple(..) => (false, 1),\n+        ast::VariantData::Struct(..) => (true, 2),\n+    };\n \n-            fn_path_finish = cx.std_path(&[sym::fmt, sym::DebugTuple, sym::finish]);\n-        }\n-        ast::VariantData::Struct(..) => {\n-            // normal struct/struct variant\n-            let fn_path_debug_struct = cx.std_path(&[sym::fmt, sym::Formatter, sym::debug_struct]);\n-            let expr = cx.expr_call_global(span, fn_path_debug_struct, vec![fmt, name]);\n-            let expr = make_mut_borrow(cx, span, expr);\n-            stmts.push(cx.stmt_let(DUMMY_SP, false, builder, expr));\n-\n-            for field in fields {\n+    // The number of fields that can be handled without an array.\n+    const CUTOFF: usize = 5;\n+\n+    if fields.is_empty() {\n+        // Special case for no fields.\n+        let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n+        cx.expr_call_global(span, fn_path_write_str, vec![fmt, name])\n+    } else if fields.len() <= CUTOFF {\n+        // Few enough fields that we can use a specific-length method.\n+        let debug = if is_struct {\n+            format!(\"debug_struct_field{}_finish\", fields.len())\n+        } else {\n+            format!(\"debug_tuple_field{}_finish\", fields.len())\n+        };\n+        let fn_path_debug = cx.std_path(&[sym::fmt, sym::Formatter, Symbol::intern(&debug)]);\n+\n+        let mut args = Vec::with_capacity(2 + fields.len() * args_per_field);\n+        args.extend([fmt, name]);\n+        for i in 0..fields.len() {\n+            let field = &fields[i];\n+            if is_struct {\n                 let name = cx.expr_lit(\n                     field.span,\n                     ast::LitKind::Str(field.name.unwrap().name, ast::StrStyle::Cooked),\n                 );\n-\n-                // Use double indirection to make sure this works for unsized types\n-                let fn_path_field = cx.std_path(&[sym::fmt, sym::DebugStruct, sym::field]);\n-                let field = cx.expr_addr_of(field.span, field.self_.clone());\n-                let field = cx.expr_addr_of(field.span, field);\n-                let expr = cx.expr_call_global(\n-                    span,\n-                    fn_path_field,\n-                    vec![builder_expr.clone(), name, field],\n-                );\n-                stmts.push(stmt_let_underscore(cx, span, expr));\n+                args.push(name);\n             }\n-            fn_path_finish = cx.std_path(&[sym::fmt, sym::DebugStruct, sym::finish]);\n+            // Use double indirection to make sure this works for unsized types\n+            let field = cx.expr_addr_of(field.span, field.self_.clone());\n+            let field = cx.expr_addr_of(field.span, field);\n+            args.push(field);\n         }\n-    }\n+        cx.expr_call_global(span, fn_path_debug, args)\n+    } else {\n+        // Enough fields that we must use the any-length method.\n+        let mut name_exprs = Vec::with_capacity(fields.len());\n+        let mut value_exprs = Vec::with_capacity(fields.len());\n+\n+        for field in fields {\n+            if is_struct {\n+                name_exprs.push(cx.expr_lit(\n+                    field.span,\n+                    ast::LitKind::Str(field.name.unwrap().name, ast::StrStyle::Cooked),\n+                ));\n+            }\n \n-    let expr = cx.expr_call_global(span, fn_path_finish, vec![builder_expr]);\n+            // Use double indirection to make sure this works for unsized types\n+            let value_ref = cx.expr_addr_of(field.span, field.self_.clone());\n+            value_exprs.push(cx.expr_addr_of(field.span, value_ref));\n+        }\n \n-    stmts.push(cx.stmt_expr(expr));\n-    let block = cx.block(span, stmts);\n-    cx.expr_block(block)\n-}\n+        // `let names: &'static _ = &[\"field1\", \"field2\"];`\n+        let names_let = if is_struct {\n+            let lt_static = Some(cx.lifetime_static(span));\n+            let ty_static_ref =\n+                cx.ty_rptr(span, cx.ty_infer(span), lt_static, ast::Mutability::Not);\n+            Some(cx.stmt_let_ty(\n+                span,\n+                false,\n+                Ident::new(sym::names, span),\n+                Some(ty_static_ref),\n+                cx.expr_array_ref(span, name_exprs),\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        // `let values: &[&dyn Debug] = &[&&self.field1, &&self.field2];`\n+        let path_debug = cx.path_global(span, cx.std_path(&[sym::fmt, sym::Debug]));\n+        let ty_dyn_debug = cx.ty(\n+            span,\n+            ast::TyKind::TraitObject(vec![cx.trait_bound(path_debug)], ast::TraitObjectSyntax::Dyn),\n+        );\n+        let ty_slice = cx.ty(\n+            span,\n+            ast::TyKind::Slice(cx.ty_rptr(span, ty_dyn_debug, None, ast::Mutability::Not)),\n+        );\n+        let values_let = cx.stmt_let_ty(\n+            span,\n+            false,\n+            Ident::new(sym::values, span),\n+            Some(cx.ty_rptr(span, ty_slice, None, ast::Mutability::Not)),\n+            cx.expr_array_ref(span, value_exprs),\n+        );\n+\n+        // `fmt::Formatter::debug_struct_fields_finish(fmt, name, names, values)` or\n+        // `fmt::Formatter::debug_tuple_fields_finish(fmt, name, values)`\n+        let sym_debug = if is_struct {\n+            sym::debug_struct_fields_finish\n+        } else {\n+            sym::debug_tuple_fields_finish\n+        };\n+        let fn_path_debug_internal = cx.std_path(&[sym::fmt, sym::Formatter, sym_debug]);\n+\n+        let mut args = Vec::with_capacity(4);\n+        args.push(fmt);\n+        args.push(name);\n+        if is_struct {\n+            args.push(cx.expr_ident(span, Ident::new(sym::names, span)));\n+        }\n+        args.push(cx.expr_ident(span, Ident::new(sym::values, span)));\n+        let expr = cx.expr_call_global(span, fn_path_debug_internal, args);\n \n-fn stmt_let_underscore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast::Stmt {\n-    let local = P(ast::Local {\n-        pat: cx.pat_wild(sp),\n-        ty: None,\n-        id: ast::DUMMY_NODE_ID,\n-        kind: LocalKind::Init(expr),\n-        span: sp,\n-        attrs: ast::AttrVec::new(),\n-        tokens: None,\n-    });\n-    ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span: sp }\n+        let mut stmts = Vec::with_capacity(3);\n+        if is_struct {\n+            stmts.push(names_let.unwrap());\n+        }\n+        stmts.push(values_let);\n+        stmts.push(cx.stmt_expr(expr));\n+\n+        cx.expr_block(cx.block(span, stmts))\n+    }\n }"}, {"sha": "b39f35a9d4056cd147996d99637b401d18b7cf27", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -162,14 +162,13 @@ fn decodable_substructure(\n                 cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms),\n             );\n             let lambda = cx.lambda(trait_span, vec![blkarg, variant], result);\n-            let variant_vec = cx.expr_vec(trait_span, variants);\n-            let variant_vec = cx.expr_addr_of(trait_span, variant_vec);\n+            let variant_array_ref = cx.expr_array_ref(trait_span, variants);\n             let fn_read_enum_variant_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum_variant]);\n             let result = cx.expr_call_global(\n                 trait_span,\n                 fn_read_enum_variant_path,\n-                vec![blkdecoder, variant_vec, lambda],\n+                vec![blkdecoder, variant_array_ref, lambda],\n             );\n             let fn_read_enum_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum]);"}, {"sha": "6c2ac3435444104b869d285f26056f9a8c014c15", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -776,7 +776,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n-        let pieces = self.ecx.expr_vec_slice(self.fmtsp, self.str_pieces);\n+        let pieces = self.ecx.expr_array_ref(self.fmtsp, self.str_pieces);\n \n         // We need to construct a &[ArgumentV1] to pass into the fmt::Arguments\n         // constructor. In general the expressions in this slice might be\n@@ -849,7 +849,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             fmt_args.push(Context::format_arg(self.ecx, self.macsp, span, arg_ty, arg));\n         }\n \n-        let args_array = self.ecx.expr_vec(self.macsp, fmt_args);\n+        let args_array = self.ecx.expr_array(self.macsp, fmt_args);\n         let args_slice = self.ecx.expr_addr_of(\n             self.macsp,\n             if no_need_for_match {\n@@ -879,7 +879,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         } else {\n             // Build up the static array which will store our precompiled\n             // nonstandard placeholders, if there are any.\n-            let fmt = self.ecx.expr_vec_slice(self.macsp, self.pieces);\n+            let fmt = self.ecx.expr_array_ref(self.macsp, self.pieces);\n \n             let path = self.ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]);\n             let unsafe_arg = self.ecx.expr_call_global(self.macsp, path, Vec::new());"}, {"sha": "5cfda33491d5b7d6392cdbc0fce93d0f4d4b52af", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -317,7 +317,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                         proc_macro_ty_method_path(cx, custom_derive),\n                         vec![\n                             cx.expr_str(span, cd.trait_name),\n-                            cx.expr_vec_slice(\n+                            cx.expr_array_ref(\n                                 span,\n                                 cd.attrs.iter().map(|&s| cx.expr_str(span, s)).collect::<Vec<_>>(),\n                             ),\n@@ -362,7 +362,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                 ast::Mutability::Not,\n             ),\n             ast::Mutability::Not,\n-            cx.expr_vec_slice(span, decls),\n+            cx.expr_array_ref(span, decls),\n         )\n         .map(|mut i| {\n             let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);"}, {"sha": "e2a6e77ab445bfcd015be08ab010fcce8fe8e5f9", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -352,7 +352,7 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.test_cases.len());\n     let ecx = &cx.ext_cx;\n \n-    ecx.expr_vec_slice(\n+    ecx.expr_array_ref(\n         sp,\n         cx.test_cases\n             .iter()"}, {"sha": "1694a8865dde2d98ead7d6079d136a586a3324d0", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -57,6 +57,10 @@ impl<'a> ExtCtxt<'a> {\n         P(ast::Ty { id: ast::DUMMY_NODE_ID, span, kind, tokens: None })\n     }\n \n+    pub fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n+        self.ty(span, ast::TyKind::Infer)\n+    }\n+\n     pub fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n         self.ty(path.span, ast::TyKind::Path(None, path))\n     }\n@@ -140,11 +144,26 @@ impl<'a> ExtCtxt<'a> {\n         ast::Lifetime { id: ast::DUMMY_NODE_ID, ident: ident.with_span_pos(span) }\n     }\n \n+    pub fn lifetime_static(&self, span: Span) -> ast::Lifetime {\n+        self.lifetime(span, Ident::new(kw::StaticLifetime, span))\n+    }\n+\n     pub fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n         ast::Stmt { id: ast::DUMMY_NODE_ID, span: expr.span, kind: ast::StmtKind::Expr(expr) }\n     }\n \n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: Ident, ex: P<ast::Expr>) -> ast::Stmt {\n+        self.stmt_let_ty(sp, mutbl, ident, None, ex)\n+    }\n+\n+    pub fn stmt_let_ty(\n+        &self,\n+        sp: Span,\n+        mutbl: bool,\n+        ident: Ident,\n+        ty: Option<P<ast::Ty>>,\n+        ex: P<ast::Expr>,\n+    ) -> ast::Stmt {\n         let pat = if mutbl {\n             let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mut);\n             self.pat_ident_binding_mode(sp, ident, binding_mode)\n@@ -153,7 +172,7 @@ impl<'a> ExtCtxt<'a> {\n         };\n         let local = P(ast::Local {\n             pat,\n-            ty: None,\n+            ty,\n             id: ast::DUMMY_NODE_ID,\n             kind: LocalKind::Init(ex),\n             span: sp,\n@@ -315,12 +334,16 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_lit(sp, ast::LitKind::Bool(value))\n     }\n \n-    pub fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    /// `[expr1, expr2, ...]`\n+    pub fn expr_array(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n-    pub fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n+\n+    /// `&[expr1, expr2, ...]`\n+    pub fn expr_array_ref(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+        self.expr_addr_of(sp, self.expr_array(sp, exprs))\n     }\n+\n     pub fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n     }"}, {"sha": "48766c6791096b543fd51b87bbe061dd31dbe777", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -567,8 +567,10 @@ symbols! {\n         debug_assert_ne_macro,\n         debug_assertions,\n         debug_struct,\n+        debug_struct_fields_finish,\n         debug_trait_builder,\n         debug_tuple,\n+        debug_tuple_fields_finish,\n         debugger_visualizer,\n         decl_macro,\n         declare_lint_pass,"}, {"sha": "f9708d6d9195fcf695e2d03b9c9ea72a4c017a90", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -1,3 +1,4 @@\n+#![feature(fmt_helpers_for_derive)]\n #![feature(min_specialization)]\n #![feature(rustc_attrs)]\n "}, {"sha": "74737e30bb4d35a78c3adb1214276ba0bc2fb2eb", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 31, "deletions": 131, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -554,137 +554,37 @@ impl<I: Interner> hash::Hash for TyKind<I> {\n // This is manually implemented because a derive would require `I: Debug`\n impl<I: Interner> fmt::Debug for TyKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match (&*self,) {\n-            (&Bool,) => fmt::Formatter::write_str(f, \"Bool\"),\n-            (&Char,) => fmt::Formatter::write_str(f, \"Char\"),\n-            (&Int(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Int\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Uint(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Uint\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Float(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Float\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Adt(ref __self_0, ref __self_1),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Adt\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Foreign(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Foreign\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Str,) => fmt::Formatter::write_str(f, \"Str\"),\n-            (&Array(ref __self_0, ref __self_1),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Array\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Slice(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Slice\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&RawPtr(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"RawPtr\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Ref\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_2);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&FnDef(ref __self_0, ref __self_1),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"FnDef\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&FnPtr(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"FnPtr\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Dynamic(ref __self_0, ref __self_1),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Dynamic\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Closure(ref __self_0, ref __self_1),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Closure\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Generator\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_2);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&GeneratorWitness(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"GeneratorWitness\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Never,) => fmt::Formatter::write_str(f, \"Never\"),\n-            (&Tuple(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Tuple\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Projection(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Projection\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Opaque(ref __self_0, ref __self_1),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Opaque\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Param(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Param\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Bound(ref __self_0, ref __self_1),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Bound\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Placeholder(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Placeholder\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Infer(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Infer\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n-            (&Error(ref __self_0),) => {\n-                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Error\");\n-                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n-                fmt::DebugTuple::finish(debug_trait_builder)\n-            }\n+        use std::fmt::*;\n+        match self {\n+            Bool => Formatter::write_str(f, \"Bool\"),\n+            Char => Formatter::write_str(f, \"Char\"),\n+            Int(f0) => Formatter::debug_tuple_field1_finish(f, \"Int\", f0),\n+            Uint(f0) => Formatter::debug_tuple_field1_finish(f, \"Uint\", f0),\n+            Float(f0) => Formatter::debug_tuple_field1_finish(f, \"Float\", f0),\n+            Adt(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Adt\", f0, f1),\n+            Foreign(f0) => Formatter::debug_tuple_field1_finish(f, \"Foreign\", f0),\n+            Str => Formatter::write_str(f, \"Str\"),\n+            Array(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Array\", f0, f1),\n+            Slice(f0) => Formatter::debug_tuple_field1_finish(f, \"Slice\", f0),\n+            RawPtr(f0) => Formatter::debug_tuple_field1_finish(f, \"RawPtr\", f0),\n+            Ref(f0, f1, f2) => Formatter::debug_tuple_field3_finish(f, \"Ref\", f0, f1, f2),\n+            FnDef(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"FnDef\", f0, f1),\n+            FnPtr(f0) => Formatter::debug_tuple_field1_finish(f, \"FnPtr\", f0),\n+            Dynamic(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Dynamic\", f0, f1),\n+            Closure(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Closure\", f0, f1),\n+            Generator(f0, f1, f2) => {\n+                Formatter::debug_tuple_field3_finish(f, \"Generator\", f0, f1, f2)\n+            }\n+            GeneratorWitness(f0) => Formatter::debug_tuple_field1_finish(f, \"GeneratorWitness\", f0),\n+            Never => Formatter::write_str(f, \"Never\"),\n+            Tuple(f0) => Formatter::debug_tuple_field1_finish(f, \"Tuple\", f0),\n+            Projection(f0) => Formatter::debug_tuple_field1_finish(f, \"Projection\", f0),\n+            Opaque(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Opaque\", f0, f1),\n+            Param(f0) => Formatter::debug_tuple_field1_finish(f, \"Param\", f0),\n+            Bound(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Bound\", f0, f1),\n+            Placeholder(f0) => Formatter::debug_tuple_field1_finish(f, \"Placeholder\", f0),\n+            Infer(f0) => Formatter::debug_tuple_field1_finish(f, \"Infer\", f0),\n+            TyKind::Error(f0) => Formatter::debug_tuple_field1_finish(f, \"Error\", f0),\n         }\n     }\n }"}, {"sha": "1d4be42b4a213d2692a92dfa673b8d4c1d62bff0", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 227, "deletions": 1, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/788ddedb0d88e40db9cd62b6163d5a471813044b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788ddedb0d88e40db9cd62b6163d5a471813044b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=788ddedb0d88e40db9cd62b6163d5a471813044b", "patch": "@@ -4,6 +4,7 @@\n \n use crate::cell::{Cell, Ref, RefCell, RefMut, SyncUnsafeCell, UnsafeCell};\n use crate::char::EscapeDebugExtArgs;\n+use crate::iter;\n use crate::marker::PhantomData;\n use crate::mem;\n use crate::num::fmt as numfmt;\n@@ -693,7 +694,7 @@ pub(crate) mod macros {\n     /// Derive macro generating an impl of the trait `Debug`.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-    #[allow_internal_unstable(core_intrinsics)]\n+    #[allow_internal_unstable(core_intrinsics, fmt_helpers_for_derive)]\n     pub macro Debug($item:item) {\n         /* compiler built-in */\n     }\n@@ -1964,6 +1965,129 @@ impl<'a> Formatter<'a> {\n         builders::debug_struct_new(self, name)\n     }\n \n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 1 field.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field1_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 2 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field2_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+        name2: &str,\n+        value2: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.field(name2, value2);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 3 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field3_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+        name2: &str,\n+        value2: &dyn Debug,\n+        name3: &str,\n+        value3: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.field(name2, value2);\n+        builder.field(name3, value3);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 4 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field4_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+        name2: &str,\n+        value2: &dyn Debug,\n+        name3: &str,\n+        value3: &dyn Debug,\n+        name4: &str,\n+        value4: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.field(name2, value2);\n+        builder.field(name3, value3);\n+        builder.field(name4, value4);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 5 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field5_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+        name2: &str,\n+        value2: &dyn Debug,\n+        name3: &str,\n+        value3: &dyn Debug,\n+        name4: &str,\n+        value4: &dyn Debug,\n+        name5: &str,\n+        value5: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.field(name2, value2);\n+        builder.field(name3, value3);\n+        builder.field(name4, value4);\n+        builder.field(name5, value5);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// For the cases not covered by `debug_struct_field[12345]_finish`.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_fields_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        names: &[&str],\n+        values: &[&dyn Debug],\n+    ) -> Result {\n+        assert_eq!(names.len(), values.len());\n+        let mut builder = builders::debug_struct_new(self, name);\n+        for (name, value) in iter::zip(names, values) {\n+            builder.field(name, value);\n+        }\n+        builder.finish()\n+    }\n+\n     /// Creates a `DebugTuple` builder designed to assist with creation of\n     /// `fmt::Debug` implementations for tuple structs.\n     ///\n@@ -1995,6 +2119,108 @@ impl<'a> Formatter<'a> {\n         builders::debug_tuple_new(self, name)\n     }\n \n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 1 field.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field1_finish<'b>(&'b mut self, name: &str, value1: &dyn Debug) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 2 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field2_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        value1: &dyn Debug,\n+        value2: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.field(value2);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 3 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field3_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        value1: &dyn Debug,\n+        value2: &dyn Debug,\n+        value3: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.field(value2);\n+        builder.field(value3);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 4 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field4_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        value1: &dyn Debug,\n+        value2: &dyn Debug,\n+        value3: &dyn Debug,\n+        value4: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.field(value2);\n+        builder.field(value3);\n+        builder.field(value4);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 5 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field5_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        value1: &dyn Debug,\n+        value2: &dyn Debug,\n+        value3: &dyn Debug,\n+        value4: &dyn Debug,\n+        value5: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.field(value2);\n+        builder.field(value3);\n+        builder.field(value4);\n+        builder.field(value5);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// For the cases not covered by `debug_tuple_field[12345]_finish`.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_fields_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        values: &[&dyn Debug],\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        for value in values {\n+            builder.field(value);\n+        }\n+        builder.finish()\n+    }\n+\n     /// Creates a `DebugList` builder designed to assist with creation of\n     /// `fmt::Debug` implementations for list-like structures.\n     ///"}]}