{"sha": "e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMmIxYjFlYzg2OTY3MTVjMDhmYzk3MGI2N2Q5ZWFhNmM5MWIxNWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-04T01:01:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-04T01:03:19Z"}, "message": "rustc: Parse and typecheck repeating vector expressions; e.g. [ 0, ..512 ]", "tree": {"sha": "d5618206e5de96ed1e547f4201fdb662e49f56e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5618206e5de96ed1e547f4201fdb662e49f56e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "html_url": "https://github.com/rust-lang/rust/commit/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4174de8bb941c3edbeb14f42ab4ebbfff5fb176d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4174de8bb941c3edbeb14f42ab4ebbfff5fb176d", "html_url": "https://github.com/rust-lang/rust/commit/4174de8bb941c3edbeb14f42ab4ebbfff5fb176d"}], "stats": {"total": 182, "additions": 142, "deletions": 40}, "files": [{"sha": "cc06049bd454d17e6b32594f97613201b26dabec", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -350,7 +350,10 @@ enum expr_ {\n     // A struct literal expression.\n     //\n     // XXX: Add functional record update.\n-    expr_struct(@path, ~[field])\n+    expr_struct(@path, ~[field]),\n+\n+    // A vector literal constructed from one repeated element.\n+    expr_repeat(@expr /* element */, @expr /* count */, mutability)\n }\n \n #[auto_serialize]"}, {"sha": "521d9ab946a844e5d72dc4f129dd45e12f19e8eb", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -402,6 +402,8 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_vec(exprs, mutt) {\n             expr_vec(fld.map_exprs(|x| fld.fold_expr(x), exprs), mutt)\n           }\n+          expr_repeat(expr, count, mutt) =>\n+            expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt),\n           expr_rec(fields, maybe_expr) {\n             expr_rec(vec::map(fields, fold_field),\n                      option::map(maybe_expr, |x| fld.fold_expr(x)))"}, {"sha": "74dbea41d82d1364728226c80a7cfafd0618ca6f", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -483,6 +483,10 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n       ',' { bump(rdr); return token::COMMA; }\n       '.' {\n         bump(rdr);\n+        if rdr.curr == '.' && nextch(rdr) != '.' {\n+            bump(rdr);\n+            return token::DOTDOT;\n+        }\n         if rdr.curr == '.' && nextch(rdr) == '.' {\n             bump(rdr);\n             bump(rdr);"}, {"sha": "c76a82a5c9bf7ee2374b6bbbcbc0736a6e34aff4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -27,33 +27,34 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              expr_call, expr_cast, expr_copy, expr_do_body,\n              expr_fail, expr_field, expr_fn, expr_fn_block, expr_if,\n              expr_index, expr_lit, expr_log, expr_loop,\n-             expr_loop_body, expr_mac, expr_move, expr_path,\n-             expr_rec, expr_ret, expr_swap, expr_struct, expr_tup, expr_unary,\n-             expr_unary_move, expr_vec, expr_vstore, expr_while, extern_fn,\n-             field, fn_decl, foreign_item, foreign_item_fn, foreign_mod,\n-             ident, impure_fn, infer, inherited, init_assign, init_move,\n-             initializer, instance_var, item, item_, item_class, item_const,\n-             item_enum, item_fn, item_foreign_mod, item_impl, item_mac,\n-             item_mod, item_trait, item_ty, lit, lit_, lit_bool, lit_float,\n-             lit_int, lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local,\n-             m_const, m_imm, m_mutbl, mac_, mac_aq, mac_ellipsis, mac_invoc,\n-             mac_invoc_tt, mac_var, matcher, match_nonterminal, match_seq,\n-             match_tok, method, mode, mt, mul, mutability, neg, noreturn, not,\n-             pat, pat_box, pat_enum, pat_ident, pat_lit, pat_range, pat_rec,\n-             pat_tup, pat_uniq, pat_wild, path, private, proto, proto_any,\n-             proto_bare, proto_block, proto_box, proto_uniq, provided, public,\n-             pure_fn, purity, re_anon, re_named, region, rem, required,\n-             ret_style, return_val, self_ty, shl, shr, stmt, stmt_decl,\n-             stmt_expr, stmt_semi, subtract, sty_box, sty_by_ref, sty_region,\n-             sty_uniq, sty_value, token_tree, trait_method, trait_ref,\n-             tt_delim, tt_seq, tt_tok, tt_nonterminal, ty, ty_, ty_bot,\n-             ty_box, ty_field, ty_fn, ty_infer, ty_mac, ty_method, ty_nil,\n-             ty_param, ty_path, ty_ptr, ty_rec, ty_rptr, ty_tup, ty_u32,\n-             ty_uniq, ty_vec, ty_fixed_length, unchecked_blk, uniq,\n-             unsafe_blk, unsafe_fn, variant, view_item, view_item_,\n-             view_item_export, view_item_import, view_item_use, view_path,\n-             view_path_glob, view_path_list, view_path_simple, visibility,\n-             vstore, vstore_box, vstore_fixed, vstore_slice, vstore_uniq};\n+             expr_loop_body, expr_mac, expr_move, expr_path, expr_rec,\n+             expr_repeat, expr_ret, expr_swap, expr_struct, expr_tup,\n+             expr_unary, expr_unary_move, expr_vec, expr_vstore, expr_while,\n+             extern_fn, field, fn_decl, foreign_item, foreign_item_fn,\n+             foreign_mod, ident, impure_fn, infer, inherited, init_assign,\n+             init_move, initializer, instance_var, item, item_, item_class,\n+             item_const, item_enum, item_fn, item_foreign_mod, item_impl,\n+             item_mac, item_mod, item_trait, item_ty, lit, lit_, lit_bool,\n+             lit_float, lit_int, lit_int_unsuffixed, lit_nil, lit_str,\n+             lit_uint, local, m_const, m_imm, m_mutbl, mac_, mac_aq,\n+             mac_ellipsis, mac_invoc, mac_invoc_tt, mac_var, matcher,\n+             match_nonterminal, match_seq, match_tok, method, mode, mt, mul,\n+             mutability, neg, noreturn, not, pat, pat_box, pat_enum,\n+             pat_ident, pat_lit, pat_range, pat_rec, pat_tup, pat_uniq,\n+             pat_wild, path, private, proto, proto_any, proto_bare,\n+             proto_block, proto_box, proto_uniq, provided, public, pure_fn,\n+             purity, re_anon, re_named, region, rem, required, ret_style,\n+             return_val, self_ty, shl, shr, stmt, stmt_decl, stmt_expr,\n+             stmt_semi, subtract, sty_box, sty_by_ref, sty_region, sty_uniq,\n+             sty_value, token_tree, trait_method, trait_ref, tt_delim, tt_seq,\n+             tt_tok, tt_nonterminal, ty, ty_, ty_bot, ty_box, ty_field, ty_fn,\n+             ty_infer, ty_mac, ty_method, ty_nil, ty_param, ty_path, ty_ptr,\n+             ty_rec, ty_rptr, ty_tup, ty_u32, ty_uniq, ty_vec,\n+             ty_fixed_length, unchecked_blk, uniq, unsafe_blk, unsafe_fn,\n+             variant, view_item, view_item_, view_item_export,\n+             view_item_import, view_item_use, view_path, view_path_glob,\n+             view_path_list, view_path_simple, visibility, vstore, vstore_box,\n+             vstore_fixed, vstore_slice, vstore_uniq};\n \n export file_type;\n export parser;\n@@ -365,6 +366,7 @@ class parser {\n     // Parses something like \"&x\"\n     fn parse_region() -> @region {\n         self.expect(token::BINOP(token::AND));\n+\n         alt copy self.token {\n           token::IDENT(sid, _) {\n             self.bump();\n@@ -812,11 +814,36 @@ class parser {\n         } else if self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n-            let es = self.parse_seq_to_end(\n-                token::RBRACKET, seq_sep_trailing_allowed(token::COMMA),\n-                |p| p.parse_expr());\n+            if self.token == token::RBRACKET {\n+                // Empty vector.\n+                self.bump();\n+                ex = expr_vec(~[], mutbl);\n+            } else {\n+                // Nonempty vector.\n+                let first_expr = self.parse_expr();\n+                if self.token == token::COMMA &&\n+                        self.look_ahead(1) == token::DOTDOT {\n+                    // Repeating vector syntax: [ 0, ..512 ]\n+                    self.bump();\n+                    self.bump();\n+                    let count = self.parse_expr();\n+                    self.expect(token::RBRACKET);\n+                    ex = expr_repeat(first_expr, count, mutbl);\n+                } else if self.token == token::COMMA {\n+                    // Vector with two or more elements.\n+                    self.bump();\n+                    let remaining_exprs =\n+                        self.parse_seq_to_end(token::RBRACKET,\n+                            seq_sep_trailing_allowed(token::COMMA),\n+                            |p| p.parse_expr());\n+                    ex = expr_vec(~[first_expr] + remaining_exprs, mutbl);\n+                } else {\n+                    // Vector with one element.\n+                    self.expect(token::RBRACKET);\n+                    ex = expr_vec(~[first_expr], mutbl);\n+                }\n+            }\n             hi = self.span.hi;\n-            ex = expr_vec(es, mutbl);\n         } else if self.token == token::ELLIPSIS {\n             self.bump();\n             return pexpr(self.mk_mac_expr(lo, self.span.hi, mac_ellipsis));"}, {"sha": "1228926e6e48bdc342f25e99afa1d4ffd2fe8b43", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -49,6 +49,7 @@ enum token {\n     /* Structural symbols */\n     AT,\n     DOT,\n+    DOTDOT,\n     ELLIPSIS,\n     COMMA,\n     SEMI,\n@@ -134,6 +135,7 @@ fn to_str(in: interner<@~str>, t: token) -> ~str {\n       /* Structural symbols */\n       AT { ~\"@\" }\n       DOT { ~\".\" }\n+      DOTDOT { ~\"..\" }\n       ELLIPSIS { ~\"...\" }\n       COMMA { ~\",\" }\n       SEMI { ~\";\" }"}, {"sha": "9eccf6882336834f2effe1c38f0b56ec30989470", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -948,6 +948,22 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         word(s.s, ~\"]\");\n         end(s);\n       }\n+\n+      ast::expr_repeat(element, count, mutbl) => {\n+        ibox(s, indent_unit);\n+        word(s.s, ~\"[\");\n+        if mutbl == ast::m_mutbl {\n+            word(s.s, ~\"mut\");\n+            nbsp(s);\n+        }\n+        print_expr(s, element);\n+        word(s.s, ~\",\");\n+        word(s.s, ~\"..\");\n+        print_expr(s, count);\n+        word(s.s, ~\"]\");\n+        end(s);\n+      }\n+\n       ast::expr_rec(fields, wth) {\n         word(s.s, ~\"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);"}, {"sha": "6eb468efd820709c4bf5372179e1f6580f497917", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -364,6 +364,10 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     alt ex.node {\n       expr_vstore(x, _) { v.visit_expr(x, e, v); }\n       expr_vec(es, _) { visit_exprs(es, e, v); }\n+      expr_repeat(element, count, _) => {\n+        v.visit_expr(element, e, v);\n+        v.visit_expr(count, e, v);\n+      }\n       expr_rec(flds, base) {\n         for flds.each |f| { v.visit_expr(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);"}, {"sha": "ea362e1dfac43a1d9ba6714afc035da476ff1a26", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -182,7 +182,7 @@ impl public_methods for borrowck_ctxt {\n           ast::expr_block(*) | ast::expr_loop(*) | ast::expr_alt(*) |\n           ast::expr_lit(*) | ast::expr_break | ast::expr_mac(*) |\n           ast::expr_again | ast::expr_rec(*) | ast::expr_struct(*) |\n-          ast::expr_unary_move(*) {\n+          ast::expr_unary_move(*) | ast::expr_repeat(*) {\n             return self.cat_rvalue(expr, expr_ty);\n           }\n         }"}, {"sha": "b6be4663a943fd7fc10e84e5de9e79b9e62a4259", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -471,7 +471,8 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n       expr_unary(*) | expr_fail(*) |\n       expr_break | expr_again | expr_lit(_) | expr_ret(*) |\n       expr_block(*) | expr_move(*) | expr_unary_move(*) | expr_assign(*) |\n-      expr_swap(*) | expr_assign_op(*) | expr_mac(*) | expr_struct(*) => {\n+      expr_swap(*) | expr_assign_op(*) | expr_mac(*) | expr_struct(*) |\n+      expr_repeat(*) => {\n           visit::visit_expr(expr, self, vt);\n       }\n     }\n@@ -1057,6 +1058,11 @@ class liveness {\n             self.propagate_through_exprs(exprs, succ)\n           }\n \n+          expr_repeat(element, count, _) => {\n+            let succ = self.propagate_through_expr(count, succ);\n+            self.propagate_through_expr(element, succ)\n+          }\n+\n           expr_rec(fields, with_expr) {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n             do fields.foldr(succ) |field, succ| {\n@@ -1468,7 +1474,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_cast(*) | expr_unary(*) | expr_fail(*) |\n       expr_ret(*) | expr_break | expr_again | expr_lit(_) |\n       expr_block(*) | expr_swap(*) | expr_mac(*) | expr_addr_of(*) |\n-      expr_struct(*) {\n+      expr_struct(*) | expr_repeat(*) {\n         visit::visit_expr(expr, self, vt);\n       }\n     }"}, {"sha": "0f9393831ac8dbd269dc2c0fb85202cf2029a3f2", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -158,7 +158,8 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       expr_rec(_, _) | expr_struct(*) | expr_tup(_) |\n       expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n       expr_binary(add, _, _) |\n-      expr_copy(_) | expr_move(_, _) | expr_unary_move(_) {\n+      expr_copy(_) | expr_move(_, _) | expr_unary_move(_) |\n+      expr_repeat(*) => {\n         node_type_needs(cx, use_repr, e.id);\n       }\n       expr_cast(base, _) {"}, {"sha": "dd557f93b9ff5c0823c7af94aeea7e1a73f0854a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b1b1ec8696715c08fc970b67d9eaa6c91b15e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=e02b1b1ec8696715c08fc970b67d9eaa6c91b15e", "patch": "@@ -1150,6 +1150,27 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                  is_loop_body, some(fcx));\n     }\n \n+    fn eval_repeat_count(fcx: @fn_ctxt, count_expr: @ast::expr, span: span)\n+                      -> uint {\n+        let tcx = fcx.ccx.tcx;\n+        match const_eval::eval_const_expr(tcx, count_expr) {\n+            const_eval::const_int(count) => return count as uint,\n+            const_eval::const_uint(count) => return count as uint,\n+            const_eval::const_float(count) => {\n+                tcx.sess.span_err(span,\n+                                  ~\"expected signed or unsigned integer for \\\n+                                    repeat count but found float\");\n+                return count as uint;\n+            }\n+            const_eval::const_str(_) => {\n+                tcx.sess.span_err(span,\n+                                  ~\"expected signed or unsigned integer for \\\n+                                    repeat count but found string\");\n+                return 0;\n+            }\n+        }\n+    }\n+\n     // Check field access expressions\n     fn check_field(fcx: @fn_ctxt, expr: @ast::expr, is_callee: bool,\n                    base: @ast::expr, field: ast::ident, tys: ~[@ast::ty])\n@@ -1252,19 +1273,26 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     alt expr.node {\n       ast::expr_vstore(ev, vst) {\n         let typ = alt ev.node {\n-          ast::expr_lit(@{node: ast::lit_str(s), span:_}) {\n+          ast::expr_lit(@{node: ast::lit_str(s), span:_}) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n             ty::mk_estr(tcx, tt)\n           }\n-          ast::expr_vec(args, mutbl) {\n+          ast::expr_vec(args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vec::len(args), vst);\n             let t: ty::t = fcx.infcx.next_ty_var();\n             for args.each |e| { bot |= check_expr_with(fcx, e, t); }\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n-          _ {\n-            tcx.sess.span_bug(expr.span, ~\"vstore modifier on non-sequence\")\n+          ast::expr_repeat(element, count_expr, mutbl) => {\n+            let count = eval_repeat_count(fcx, count_expr, expr.span);\n+            fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n+            let t: ty::t = fcx.infcx.next_ty_var();\n+            bot |= check_expr_with(fcx, element, t);\n+            ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n+          _ =>\n+            tcx.sess.span_bug(expr.span, ~\"vstore modifier on non-sequence\")\n         };\n         fcx.write_ty(ev.id, typ);\n         fcx.write_ty(id, typ);\n@@ -1613,6 +1641,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                               ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n       }\n+      ast::expr_repeat(element, count_expr, mutbl) {\n+        let count = eval_repeat_count(fcx, count_expr, expr.span);\n+        fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n+        let t: ty::t = fcx.infcx.next_ty_var();\n+        bot |= check_expr_with(fcx, element, t);\n+        let t = ty::mk_evec(tcx, {ty: t, mutbl: mutbl},\n+                            ty::vstore_fixed(count));\n+        fcx.write_ty(id, t);\n+      }\n       ast::expr_tup(elts) {\n         let mut elt_ts = ~[];\n         vec::reserve(elt_ts, vec::len(elts));"}]}