{"sha": "e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253", "node_id": "C_kwDOAAsO6NoAKGUwZTliMjFjNzhlNGU2YTdhNTUxNTk0NGFjZTRjYjBjMWYyZjkyNTM", "commit": {"author": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-08-30T15:28:50Z"}, "committer": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-09-06T15:41:08Z"}, "message": "Mugrate mismatched_static_lifetime.rs", "tree": {"sha": "b5c48ad2c67b6c4ee0078a6985190b0a3be17892", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5c48ad2c67b6c4ee0078a6985190b0a3be17892"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEAWou4Gq79HasRseDspeR1Nh440UFAmMXahQACgkQspeR1Nh4\n40U3GQ//UWpdoZFoKPwSiGWy1xEgFBPhaHBeeu9xYVDrMSt/ELJYn9N4D58m5akt\nleY2/tgy0b1u0nvii6LYBDVJb02N5uqaYV6+sPj8EoJl10idVuC8kjURAoxWyRTS\noe/M5KHg95H7UNXuHL6VuyIltikE0K/SW2nwXqvez9gRMg6oIPt0s/5TMsjMSZyX\nPQWrdaZDM3zxMVp+MwF2bMijE6Cix1R3LuWZrmjx1RFhoG5vY+GhFlCrpmu8zlFE\n9GAsiTl6DTt2K2OrCLrAsYV5Tawke4aQ+z2vqNhSX4gocyht4jQ5bnwehp+iWKar\nP7nWXchQEksfWyX59H28Pm1bLWj8BXjEfc5bhdtC8J6JD7IUvCS2lUJyuU22r3Ak\n9RZtxh39p/OCCZdaXZzldjaGank2nbHdMzN7CuD8aI9QqKfbwYH+S0Wo3fF4XDcd\nwcy7ja36ib84UJdz1x0xTyHGh+MyTZt1dHMhE1JCawq2MwvcC/GU6eJqUfd8LmaJ\noU9QEHHwM3woQyW27fRsLaOd1x/4aw3OEtcJIyrcZT+S7hhznduoNvcZJG82ikYf\nVj0WJylJ7FaRpUjRerF4GLp10IMs4vwZKjptqR67OCcmN72ohxMOt4lIsolBpv4H\nfypbN6zMB1DV8lxmTF7bvSrj/ZbJQJpJo+OaCgN4gIsnBy/crKU=\n=h8q9\n-----END PGP SIGNATURE-----", "payload": "tree b5c48ad2c67b6c4ee0078a6985190b0a3be17892\nparent af3343ae299c81a019d9d62d15c10cb99d7ceb89\nauthor Nikita Tomashevich <quant3234@gmail.com> 1661873330 +0300\ncommitter Nikita Tomashevich <quant3234@gmail.com> 1662478868 +0300\n\nMugrate mismatched_static_lifetime.rs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253", "html_url": "https://github.com/rust-lang/rust/commit/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af3343ae299c81a019d9d62d15c10cb99d7ceb89", "url": "https://api.github.com/repos/rust-lang/rust/commits/af3343ae299c81a019d9d62d15c10cb99d7ceb89", "html_url": "https://github.com/rust-lang/rust/commit/af3343ae299c81a019d9d62d15c10cb99d7ceb89"}], "stats": {"total": 323, "additions": 303, "deletions": 20}, "files": [{"sha": "2899b8304bc14884338564a480a2ffc54cdaec05", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253", "patch": "@@ -137,3 +137,34 @@ infer_lifetime_param_suggestion = consider introducing a named lifetime paramete\n     *[false] {\"\"}\n }\n infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime\n+\n+infer_region_explanation = {$pref_kind ->\n+    *[should_not_happen] [{$pref_kind}]\n+    [empty] {\"\"}\n+}{$pref_kind ->\n+    [empty] {\"\"}\n+    *[other] {\" \"}\n+}{$desc_kind ->\n+    *[should_not_happen] [{$desc_kind}]\n+    [restatic] the static lifetime\n+    [reempty] the empty lifetime\n+    [reemptyuni] the empty lifetime in universe {$desc_arg}\n+    [revar] lifetime {$desc_arg}\n+\n+    [as_defined] the lifetime `{$desc_arg}` as defined here\n+    [as_defined_anon] the anonymous lifetime as defined here\n+    [defined_here] the anonymous lifetime defined here\n+    [anon_num_here] the anonymous lifetime #{$desc_num_arg} defined here\n+    [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n+}{$suff_kind ->\n+    *[should_not_happen] [{$suff_kind}]\n+    [empty]{\"\"}\n+    [continues] ...\n+}\n+\n+infer_mismatched_static_lifetime = incompatible lifetime on type\n+infer_msl_impl_note = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+infer_msl_introduces_static = introduces a `'static` lifetime requirement\n+infer_msl_unmet_req = because this has an unmet lifetime requirement\n+infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n+infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement"}, {"sha": "ad8eb2945fa990acc76b4cadcf02a9f5c7763693", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "renamed", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253", "patch": "@@ -14,6 +14,8 @@ use crate::infer::error_reporting::{\n     ObligationCauseAsDiagArg,\n };\n \n+pub mod note_and_explain;\n+\n #[derive(SessionDiagnostic)]\n #[diag(infer::opaque_hidden_type)]\n pub struct OpaqueHiddenTypeDiag {\n@@ -419,3 +421,69 @@ pub struct LifetimeMismatch<'a> {\n     #[subdiagnostic]\n     pub suggestion: AddLifetimeParamsSuggestion<'a>,\n }\n+\n+pub mod mismatched_static_lifetime {\n+    use rustc_errors::{self, fluent, AddSubdiagnostic, MultiSpan};\n+    use rustc_span::Span;\n+\n+    use super::note_and_explain;\n+\n+    pub struct LabeledMultiSpan {\n+        pub multi_span: MultiSpan,\n+        pub binding_span: Span,\n+    }\n+\n+    impl AddSubdiagnostic for LabeledMultiSpan {\n+        fn add_to_diagnostic(mut self, diag: &mut rustc_errors::Diagnostic) {\n+            self.multi_span\n+                .push_span_label(self.binding_span, fluent::infer::msl_introduces_static);\n+            diag.span_note(self.multi_span, fluent::infer::msl_unmet_req);\n+        }\n+    }\n+\n+    pub struct ImplNote {\n+        pub impl_span: Option<Span>,\n+    }\n+\n+    impl AddSubdiagnostic for ImplNote {\n+        fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+            match self.impl_span {\n+                Some(span) => diag.span_note(span, fluent::infer::msl_impl_note),\n+                None => diag.note(fluent::infer::msl_impl_note),\n+            };\n+        }\n+    }\n+\n+    #[derive(SessionSubdiagnostic)]\n+    pub enum TraitSubdiag {\n+        #[note(infer::msl_trait_note)]\n+        Note {\n+            #[primary_span]\n+            span: Span,\n+        },\n+        #[suggestion_verbose(\n+            infer::msl_trait_sugg,\n+            code = \" + '_\",\n+            applicability = \"maybe-incorrect\"\n+        )]\n+        Sugg {\n+            #[primary_span]\n+            span: Span,\n+        },\n+    }\n+\n+    #[derive(SessionDiagnostic)]\n+    #[diag(infer::mismatched_static_lifetime)]\n+    pub struct MismatchedStaticLifetime<'a> {\n+        #[primary_span]\n+        pub cause_span: Span,\n+        #[subdiagnostic]\n+        pub multispan_subdiag: LabeledMultiSpan,\n+        #[subdiagnostic]\n+        pub expl: Option<note_and_explain::RegionExplanation<'a>>,\n+        #[subdiagnostic]\n+        pub impl_note: ImplNote,\n+        #[subdiagnostic]\n+        pub trait_subdiags: Vec<TraitSubdiag>,\n+    }\n+}", "previous_filename": "compiler/rustc_infer/src/errors.rs"}, {"sha": "92bf3ecd131da0a659758aa5e0e92876e6dd78fa", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253", "patch": "@@ -0,0 +1,176 @@\n+use crate::infer::error_reporting::nice_region_error::find_anon_type;\n+use rustc_errors::{self, fluent, AddSubdiagnostic};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::{symbol::kw, Span};\n+\n+#[derive(Default)]\n+struct DescriptionCtx<'a> {\n+    span: Option<Span>,\n+    kind: &'a str,\n+    arg: String,\n+    num_arg: u32,\n+}\n+\n+impl<'a> DescriptionCtx<'a> {\n+    fn new<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+        alt_span: Option<Span>,\n+    ) -> Option<Self> {\n+        let mut me = DescriptionCtx::default();\n+        me.span = alt_span;\n+        match *region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                return Self::from_early_bound_and_free_regions(tcx, region);\n+            }\n+            ty::ReStatic => {\n+                me.kind = \"restatic\";\n+            }\n+\n+            ty::ReEmpty(ty::UniverseIndex::ROOT) => me.kind = \"reempty\",\n+\n+            // uh oh, hope no user ever sees THIS\n+            ty::ReEmpty(ui) => {\n+                me.kind = \"reemptyuni\";\n+                me.arg = format!(\"{:?}\", ui);\n+            }\n+\n+            ty::RePlaceholder(_) => return None,\n+\n+            // FIXME(#13998) RePlaceholder should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+                me.kind = \"revar\";\n+                me.arg = format!(\"{:?}\", region);\n+            }\n+        };\n+        Some(me)\n+    }\n+\n+    fn from_early_bound_and_free_regions<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) -> Option<Self> {\n+        let mut me = DescriptionCtx::default();\n+        let scope = region.free_region_binding_scope(tcx).expect_local();\n+        match *region {\n+            ty::ReEarlyBound(ref br) => {\n+                let mut sp = tcx.def_span(scope);\n+                if let Some(param) =\n+                    tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n+                {\n+                    sp = param.span;\n+                }\n+                if br.has_name() {\n+                    me.kind = \"as_defined\";\n+                    me.arg = br.name.to_string();\n+                } else {\n+                    me.kind = \"as_defined_anon\";\n+                };\n+                me.span = Some(sp)\n+            }\n+            ty::ReFree(ref fr) => {\n+                if !fr.bound_region.is_named()\n+                    && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n+                {\n+                    me.kind = \"defined_here\";\n+                    me.span = Some(ty.span);\n+                } else {\n+                    match fr.bound_region {\n+                        ty::BoundRegionKind::BrNamed(_, name) => {\n+                            let mut sp = tcx.def_span(scope);\n+                            if let Some(param) =\n+                                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                            {\n+                                sp = param.span;\n+                            }\n+                            if name == kw::UnderscoreLifetime {\n+                                me.kind = \"as_defined_anon\";\n+                            } else {\n+                                me.kind = \"as_defined\";\n+                    me.arg = name.to_string();\n+                            };\n+                            me.span = Some(sp);\n+                        }\n+                        ty::BrAnon(idx) => {\n+                            me.kind = \"anon_num_here\";\n+                            me.num_arg = idx+1;\n+                            me.span = Some(tcx.def_span(scope));\n+                        },\n+                        _ => {\n+                            me.kind = \"defined_here_reg\";\n+                            me.arg = region.to_string();\n+                            me.span = Some(tcx.def_span(scope));\n+                        },\n+                    }\n+                }\n+            }\n+            _ => bug!(),\n+        }\n+        Some(me)\n+    }\n+\n+    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n+        diag.set_arg(\"desc_kind\", self.kind);\n+        diag.set_arg(\"desc_arg\", self.arg);\n+        diag.set_arg(\"desc_num_arg\", self.num_arg);\n+    }\n+}\n+\n+pub enum PrefixKind {\n+    Empty,\n+}\n+\n+pub enum SuffixKind {\n+    Continues,\n+}\n+\n+impl PrefixKind {\n+    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            Self::Empty => diag.set_arg(\"pref_kind\", \"empty\"),\n+        };\n+    }\n+}\n+\n+impl SuffixKind {\n+    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            Self::Continues => diag.set_arg(\"suff_kind\", \"continues\"),\n+        };\n+    }\n+}\n+\n+pub struct RegionExplanation<'a> {\n+    desc: DescriptionCtx<'a>,\n+    prefix: PrefixKind,\n+    suffix: SuffixKind,\n+}\n+\n+impl RegionExplanation<'_> {\n+    pub fn new<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+        alt_span: Option<Span>,\n+        prefix: PrefixKind,\n+        suffix: SuffixKind,\n+    ) -> Option<Self> {\n+        Some(Self { desc: DescriptionCtx::new(tcx, region, alt_span)?, prefix, suffix })\n+    }\n+}\n+\n+impl AddSubdiagnostic for RegionExplanation<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        if let Some(span) = self.desc.span {\n+            diag.span_note(span, fluent::infer::region_explanation);\n+        } else {\n+            diag.note(fluent::infer::region_explanation);\n+        }\n+        self.desc.add_to(diag);\n+        self.prefix.add_to(diag);\n+        self.suffix.add_to(diag);\n+    }\n+}"}, {"sha": "832a0eaba3b8e912854eecee2c7d32a051b60333", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=e0e9b21c78e4e6a7a5515944ace4cb0c1f2f9253", "patch": "@@ -1,13 +1,14 @@\n //! Error Reporting for when the lifetime for a type doesn't match the `impl` selected for a predicate\n //! to hold.\n \n+use crate::errors::mismatched_static_lifetime::{ImplNote, MismatchedStaticLifetime, TraitSubdiag};\n+use crate::errors::{mismatched_static_lifetime::LabeledMultiSpan, note_and_explain};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::ObligationCauseCode;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::ty::TypeVisitor;\n@@ -39,12 +40,20 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             = *parent.code() else {\n             return None;\n         };\n-        let mut err = self.tcx().sess.struct_span_err(cause.span, \"incompatible lifetime on type\");\n+\n         // FIXME: we should point at the lifetime\n-        let mut multi_span: MultiSpan = vec![binding_span].into();\n-        multi_span.push_span_label(binding_span, \"introduces a `'static` lifetime requirement\");\n-        err.span_note(multi_span, \"because this has an unmet lifetime requirement\");\n-        note_and_explain_region(self.tcx(), &mut err, \"\", sup, \"...\", Some(binding_span));\n+        let multi_span: MultiSpan = vec![binding_span].into();\n+        let multispan_subdiag = LabeledMultiSpan { multi_span, binding_span };\n+\n+        let expl = note_and_explain::RegionExplanation::new(\n+            self.tcx(),\n+            sup,\n+            Some(binding_span),\n+            note_and_explain::PrefixKind::Empty,\n+            note_and_explain::SuffixKind::Continues,\n+        );\n+        let mut impl_span = None;\n+        let mut trait_subdiags = Vec::new();\n         if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {\n             // If an impl is local, then maybe this isn't what they want. Try to\n             // be as helpful as possible with implicit lifetimes.\n@@ -73,31 +82,30 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 // there aren't trait objects or because none are implicit, then just\n                 // write a single note on the impl itself.\n \n-                let impl_span = self.tcx().def_span(*impl_def_id);\n-                err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+                impl_span = Some(self.tcx().def_span(*impl_def_id));\n             } else {\n                 // Otherwise, point at all implicit static lifetimes\n \n-                err.note(\"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n                 for span in &traits {\n-                    err.span_note(*span, \"this has an implicit `'static` lifetime requirement\");\n+                    trait_subdiags.push(TraitSubdiag::Note { span: *span });\n                     // It would be nice to put this immediately under the above note, but they get\n                     // pushed to the end.\n-                    err.span_suggestion_verbose(\n-                        span.shrink_to_hi(),\n-                        \"consider relaxing the implicit `'static` requirement\",\n-                        \" + '_\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    trait_subdiags.push(TraitSubdiag::Sugg { span: span.shrink_to_hi() });\n                 }\n             }\n         } else {\n             // Otherwise just point out the impl.\n \n-            let impl_span = self.tcx().def_span(*impl_def_id);\n-            err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+            impl_span = Some(self.tcx().def_span(*impl_def_id));\n         }\n-        let reported = err.emit();\n+        let err = MismatchedStaticLifetime {\n+            cause_span: cause.span,\n+            multispan_subdiag,\n+            expl,\n+            impl_note: ImplNote { impl_span },\n+            trait_subdiags,\n+        };\n+        let reported = self.tcx().sess.emit_err(err);\n         Some(reported)\n     }\n }"}]}