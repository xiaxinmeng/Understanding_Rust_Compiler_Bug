{"sha": "6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjN2Q3YTZiZjRiOGEzYTY1M2Q4Y2JhMGFjZjViMjBiMDg4YWZmMmU=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-02-14T06:23:05Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-04T18:01:22Z"}, "message": "Moved `print_item` and helpers to a separate file", "tree": {"sha": "2ab63bb47be151211b6a95d1a475e1c0552b2fbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ab63bb47be151211b6a95d1a475e1c0552b2fbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e", "html_url": "https://github.com/rust-lang/rust/commit/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd", "html_url": "https://github.com/rust-lang/rust/commit/48167c499aa8ad8d7b641f79e6ab9cc163ebc7dd"}], "stats": {"total": 2834, "additions": 1430, "deletions": 1404}, "files": [{"sha": "4322e2448341c341f66d60df90a6b813a48aa383", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e", "patch": "@@ -15,9 +15,10 @@ use rustc_span::source_map::FileName;\n use rustc_span::symbol::sym;\n \n use super::cache::{build_index, ExternalLocation};\n+use super::print_item::{full_path, item_path, print_item};\n use super::{\n-    full_path, item_path, make_item_keywords, print_item, print_sidebar, settings, write_shared,\n-    AllTypes, NameDoc, SharedContext, StylePath, BASIC_KEYWORDS, CURRENT_DEPTH, INITIAL_IDS,\n+    make_item_keywords, print_sidebar, settings, write_shared, AllTypes, NameDoc, SharedContext,\n+    StylePath, BASIC_KEYWORDS, CURRENT_DEPTH, INITIAL_IDS,\n };\n \n use crate::clean::{self, AttributesExt};"}, {"sha": "2a13d190318f5be4197146b341a7e2a570ae91b8", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 7, "deletions": 1402, "changes": 1409, "blob_url": "https://github.com/rust-lang/rust/blob/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e", "patch": "@@ -33,8 +33,9 @@ mod tests;\n mod context;\n crate use context::*;\n \n+mod print_item;\n+\n use std::cell::{Cell, RefCell};\n-use std::cmp::Ordering;\n use std::collections::VecDeque;\n use std::default::Default;\n use std::ffi::OsStr;\n@@ -58,7 +59,6 @@ use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n-use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n@@ -71,11 +71,12 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n use crate::html::escape::Escape;\n-use crate::html::format::Function;\n-use crate::html::format::{href, print_default_space, print_generic_bounds, WhereClause};\n-use crate::html::format::{print_abi_with_space, Buffer, PrintWithSpace};\n+use crate::html::format::{\n+    href, print_abi_with_space, print_default_space, print_generic_bounds, Buffer, Function,\n+    PrintWithSpace, WhereClause,\n+};\n use crate::html::markdown::{self, ErrorCodes, Markdown, MarkdownHtml, MarkdownSummaryLine};\n-use crate::html::{highlight, layout, static_files};\n+use crate::html::{layout, static_files};\n \n /// A pair of name and its optional document.\n crate type NameDoc = (String, Option<String>);\n@@ -1147,136 +1148,6 @@ fn settings(root_path: &str, suffix: &str, themes: &[StylePath]) -> Result<Strin\n     ))\n }\n \n-fn wrap_into_docblock<F>(w: &mut Buffer, f: F)\n-where\n-    F: FnOnce(&mut Buffer),\n-{\n-    w.write_str(\"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\");\n-    f(w);\n-    w.write_str(\"</div>\")\n-}\n-\n-fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n-    debug_assert!(!item.is_stripped());\n-    // Write the breadcrumb trail header for the top\n-    buf.write_str(\"<h1 class=\\\"fqn\\\"><span class=\\\"in-band\\\">\");\n-    let name = match *item.kind {\n-        clean::ModuleItem(ref m) => {\n-            if m.is_crate {\n-                \"Crate \"\n-            } else {\n-                \"Module \"\n-            }\n-        }\n-        clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => \"Function \",\n-        clean::TraitItem(..) => \"Trait \",\n-        clean::StructItem(..) => \"Struct \",\n-        clean::UnionItem(..) => \"Union \",\n-        clean::EnumItem(..) => \"Enum \",\n-        clean::TypedefItem(..) => \"Type Definition \",\n-        clean::MacroItem(..) => \"Macro \",\n-        clean::ProcMacroItem(ref mac) => match mac.kind {\n-            MacroKind::Bang => \"Macro \",\n-            MacroKind::Attr => \"Attribute Macro \",\n-            MacroKind::Derive => \"Derive Macro \",\n-        },\n-        clean::PrimitiveItem(..) => \"Primitive Type \",\n-        clean::StaticItem(..) | clean::ForeignStaticItem(..) => \"Static \",\n-        clean::ConstantItem(..) => \"Constant \",\n-        clean::ForeignTypeItem => \"Foreign Type \",\n-        clean::KeywordItem(..) => \"Keyword \",\n-        clean::OpaqueTyItem(..) => \"Opaque Type \",\n-        clean::TraitAliasItem(..) => \"Trait Alias \",\n-        _ => {\n-            // We don't generate pages for any other type.\n-            unreachable!();\n-        }\n-    };\n-    buf.write_str(name);\n-    if !item.is_primitive() && !item.is_keyword() {\n-        let cur = &cx.current;\n-        let amt = if item.is_mod() { cur.len() - 1 } else { cur.len() };\n-        for (i, component) in cur.iter().enumerate().take(amt) {\n-            write!(\n-                buf,\n-                \"<a href=\\\"{}index.html\\\">{}</a>::<wbr>\",\n-                \"../\".repeat(cur.len() - i - 1),\n-                component\n-            );\n-        }\n-    }\n-    write!(buf, \"<a class=\\\"{}\\\" href=\\\"\\\">{}</a>\", item.type_(), item.name.as_ref().unwrap());\n-\n-    buf.write_str(\"</span>\"); // in-band\n-    buf.write_str(\"<span class=\\\"out-of-band\\\">\");\n-    render_stability_since_raw(\n-        buf,\n-        item.stable_since(cx.tcx()).as_deref(),\n-        item.const_stable_since(cx.tcx()).as_deref(),\n-        None,\n-        None,\n-    );\n-    buf.write_str(\n-        \"<span id=\\\"render-detail\\\">\\\n-                <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n-                    title=\\\"collapse all docs\\\">\\\n-                    [<span class=\\\"inner\\\">&#x2212;</span>]\\\n-                </a>\\\n-            </span>\",\n-    );\n-\n-    // Write `src` tag\n-    //\n-    // When this item is part of a `crate use` in a downstream crate, the\n-    // [src] link in the downstream documentation will actually come back to\n-    // this page, and this link will be auto-clicked. The `id` attribute is\n-    // used to find the link to auto-click.\n-    if cx.shared.include_sources && !item.is_primitive() {\n-        write_srclink(cx, item, buf);\n-    }\n-\n-    buf.write_str(\"</span></h1>\"); // out-of-band\n-\n-    match *item.kind {\n-        clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n-        clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n-            item_function(buf, cx, item, f)\n-        }\n-        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n-        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n-        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n-        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n-        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n-        clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n-        clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n-        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n-        clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n-        clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n-        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n-        clean::KeywordItem(_) => item_keyword(buf, cx, item),\n-        clean::OpaqueTyItem(ref e) => item_opaque_ty(buf, cx, item, e),\n-        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n-        _ => {\n-            // We don't generate pages for any other type.\n-            unreachable!();\n-        }\n-    }\n-}\n-\n-fn item_path(ty: ItemType, name: &str) -> String {\n-    match ty {\n-        ItemType::Module => format!(\"{}index.html\", ensure_trailing_slash(name)),\n-        _ => format!(\"{}.{}.html\", ty, name),\n-    }\n-}\n-\n-fn full_path(cx: &Context<'_>, item: &clean::Item) -> String {\n-    let mut s = cx.current.join(\"::\");\n-    s.push_str(\"::\");\n-    s.push_str(&item.name.unwrap().as_str());\n-    s\n-}\n-\n fn document(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, parent: Option<&clean::Item>) {\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n@@ -1406,324 +1277,6 @@ fn document_item_info(\n     }\n }\n \n-fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n-    if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n-}\n-\n-fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n-    if item.is_non_exhaustive() {\n-        write!(w, \"<div class=\\\"docblock non-exhaustive non-exhaustive-{}\\\">\", {\n-            if item.is_struct() {\n-                \"struct\"\n-            } else if item.is_enum() {\n-                \"enum\"\n-            } else if item.is_variant() {\n-                \"variant\"\n-            } else {\n-                \"type\"\n-            }\n-        });\n-\n-        if item.is_struct() {\n-            w.write_str(\n-                \"Non-exhaustive structs could have additional fields added in future. \\\n-                 Therefore, non-exhaustive structs cannot be constructed in external crates \\\n-                 using the traditional <code>Struct {{ .. }}</code> syntax; cannot be \\\n-                 matched against without a wildcard <code>..</code>; and \\\n-                 struct update syntax will not work.\",\n-            );\n-        } else if item.is_enum() {\n-            w.write_str(\n-                \"Non-exhaustive enums could have additional variants added in future. \\\n-                 Therefore, when matching against variants of non-exhaustive enums, an \\\n-                 extra wildcard arm must be added to account for any future variants.\",\n-            );\n-        } else if item.is_variant() {\n-            w.write_str(\n-                \"Non-exhaustive enum variants could have additional fields added in future. \\\n-                 Therefore, non-exhaustive enum variants cannot be constructed in external \\\n-                 crates and cannot be matched against.\",\n-            );\n-        } else {\n-            w.write_str(\n-                \"This type will require a wildcard arm in any match statements or constructors.\",\n-            );\n-        }\n-\n-        w.write_str(\"</div>\");\n-    }\n-}\n-\n-/// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n-crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n-    /// Takes a non-numeric and a numeric part from the given &str.\n-    fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n-        let i = s.find(|c: char| c.is_ascii_digit());\n-        let (a, b) = s.split_at(i.unwrap_or(s.len()));\n-        let i = b.find(|c: char| !c.is_ascii_digit());\n-        let (b, c) = b.split_at(i.unwrap_or(b.len()));\n-        *s = c;\n-        (a, b)\n-    }\n-\n-    while !lhs.is_empty() || !rhs.is_empty() {\n-        let (la, lb) = take_parts(&mut lhs);\n-        let (ra, rb) = take_parts(&mut rhs);\n-        // First process the non-numeric part.\n-        match la.cmp(ra) {\n-            Ordering::Equal => (),\n-            x => return x,\n-        }\n-        // Then process the numeric part, if both sides have one (and they fit in a u64).\n-        if let (Ok(ln), Ok(rn)) = (lb.parse::<u64>(), rb.parse::<u64>()) {\n-            match ln.cmp(&rn) {\n-                Ordering::Equal => (),\n-                x => return x,\n-            }\n-        }\n-        // Then process the numeric part again, but this time as strings.\n-        match lb.cmp(rb) {\n-            Ordering::Equal => (),\n-            x => return x,\n-        }\n-    }\n-\n-    Ordering::Equal\n-}\n-\n-fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n-    document(w, cx, item, None);\n-\n-    let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n-\n-    // the order of item types in the listing\n-    fn reorder(ty: ItemType) -> u8 {\n-        match ty {\n-            ItemType::ExternCrate => 0,\n-            ItemType::Import => 1,\n-            ItemType::Primitive => 2,\n-            ItemType::Module => 3,\n-            ItemType::Macro => 4,\n-            ItemType::Struct => 5,\n-            ItemType::Enum => 6,\n-            ItemType::Constant => 7,\n-            ItemType::Static => 8,\n-            ItemType::Trait => 9,\n-            ItemType::Function => 10,\n-            ItemType::Typedef => 12,\n-            ItemType::Union => 13,\n-            _ => 14 + ty as u8,\n-        }\n-    }\n-\n-    fn cmp(\n-        i1: &clean::Item,\n-        i2: &clean::Item,\n-        idx1: usize,\n-        idx2: usize,\n-        tcx: TyCtxt<'_>,\n-    ) -> Ordering {\n-        let ty1 = i1.type_();\n-        let ty2 = i2.type_();\n-        if ty1 != ty2 {\n-            return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2));\n-        }\n-        let s1 = i1.stability(tcx).as_ref().map(|s| s.level);\n-        let s2 = i2.stability(tcx).as_ref().map(|s| s.level);\n-        if let (Some(a), Some(b)) = (s1, s2) {\n-            match (a.is_stable(), b.is_stable()) {\n-                (true, true) | (false, false) => {}\n-                (false, true) => return Ordering::Less,\n-                (true, false) => return Ordering::Greater,\n-            }\n-        }\n-        let lhs = i1.name.unwrap_or(kw::Empty).as_str();\n-        let rhs = i2.name.unwrap_or(kw::Empty).as_str();\n-        compare_names(&lhs, &rhs)\n-    }\n-\n-    if cx.shared.sort_modules_alphabetically {\n-        indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2, cx.tcx()));\n-    }\n-    // This call is to remove re-export duplicates in cases such as:\n-    //\n-    // ```\n-    // crate mod foo {\n-    //     crate mod bar {\n-    //         crate trait Double { fn foo(); }\n-    //     }\n-    // }\n-    //\n-    // crate use foo::bar::*;\n-    // crate use foo::*;\n-    // ```\n-    //\n-    // `Double` will appear twice in the generated docs.\n-    //\n-    // FIXME: This code is quite ugly and could be improved. Small issue: DefId\n-    // can be identical even if the elements are different (mostly in imports).\n-    // So in case this is an import, we keep everything by adding a \"unique id\"\n-    // (which is the position in the vector).\n-    indices.dedup_by_key(|i| {\n-        (\n-            items[*i].def_id,\n-            if items[*i].name.as_ref().is_some() { Some(full_path(cx, &items[*i])) } else { None },\n-            items[*i].type_(),\n-            if items[*i].is_import() { *i } else { 0 },\n-        )\n-    });\n-\n-    debug!(\"{:?}\", indices);\n-    let mut curty = None;\n-    for &idx in &indices {\n-        let myitem = &items[idx];\n-        if myitem.is_stripped() {\n-            continue;\n-        }\n-\n-        let myty = Some(myitem.type_());\n-        if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n-            // Put `extern crate` and `use` re-exports in the same section.\n-            curty = myty;\n-        } else if myty != curty {\n-            if curty.is_some() {\n-                w.write_str(\"</table>\");\n-            }\n-            curty = myty;\n-            let (short, name) = item_ty_to_strs(&myty.unwrap());\n-            write!(\n-                w,\n-                \"<h2 id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n-                       <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n-                id = cx.derive_id(short.to_owned()),\n-                name = name\n-            );\n-        }\n-\n-        match *myitem.kind {\n-            clean::ExternCrateItem(ref name, ref src) => {\n-                use crate::html::format::anchor;\n-\n-                match *src {\n-                    Some(ref src) => write!(\n-                        w,\n-                        \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                        anchor(myitem.def_id, &*src.as_str(), cx.cache()),\n-                        name\n-                    ),\n-                    None => write!(\n-                        w,\n-                        \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                        anchor(myitem.def_id, &*name.as_str(), cx.cache())\n-                    ),\n-                }\n-                w.write_str(\"</code></td></tr>\");\n-            }\n-\n-            clean::ImportItem(ref import) => {\n-                write!(\n-                    w,\n-                    \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                    import.print(cx.cache())\n-                );\n-            }\n-\n-            _ => {\n-                if myitem.name.is_none() {\n-                    continue;\n-                }\n-\n-                let unsafety_flag = match *myitem.kind {\n-                    clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n-                        if func.header.unsafety == hir::Unsafety::Unsafe =>\n-                    {\n-                        \"<a title=\\\"unsafe function\\\" href=\\\"#\\\"><sup>\u26a0</sup></a>\"\n-                    }\n-                    _ => \"\",\n-                };\n-\n-                let stab = myitem.stability_class(cx.tcx());\n-                let add = if stab.is_some() { \" \" } else { \"\" };\n-\n-                let doc_value = myitem.doc_value().unwrap_or_default();\n-                write!(\n-                    w,\n-                    \"<tr class=\\\"{stab}{add}module-item\\\">\\\n-                         <td><a class=\\\"{class}\\\" href=\\\"{href}\\\" \\\n-                             title=\\\"{title}\\\">{name}</a>{unsafety_flag}</td>\\\n-                         <td class=\\\"docblock-short\\\">{stab_tags}{docs}</td>\\\n-                     </tr>\",\n-                    name = *myitem.name.as_ref().unwrap(),\n-                    stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n-                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(&cx.cache)).into_string(),\n-                    class = myitem.type_(),\n-                    add = add,\n-                    stab = stab.unwrap_or_else(String::new),\n-                    unsafety_flag = unsafety_flag,\n-                    href = item_path(myitem.type_(), &myitem.name.unwrap().as_str()),\n-                    title = [full_path(cx, myitem), myitem.type_().to_string()]\n-                        .iter()\n-                        .filter_map(|s| if !s.is_empty() { Some(s.as_str()) } else { None })\n-                        .collect::<Vec<_>>()\n-                        .join(\" \"),\n-                );\n-            }\n-        }\n-    }\n-\n-    if curty.is_some() {\n-        w.write_str(\"</table>\");\n-    }\n-}\n-\n-/// Render the stability, deprecation and portability tags that are displayed in the item's summary\n-/// at the module level.\n-fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) -> String {\n-    let mut tags = String::new();\n-\n-    fn tag_html(class: &str, title: &str, contents: &str) -> String {\n-        format!(r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#, class, Escape(title), contents)\n-    }\n-\n-    // The trailing space after each tag is to space it properly against the rest of the docs.\n-    if let Some(depr) = &item.deprecation(tcx) {\n-        let mut message = \"Deprecated\";\n-        if !stability::deprecation_in_effect(\n-            depr.is_since_rustc_version,\n-            depr.since.map(|s| s.as_str()).as_deref(),\n-        ) {\n-            message = \"Deprecation planned\";\n-        }\n-        tags += &tag_html(\"deprecated\", \"\", message);\n-    }\n-\n-    // The \"rustc_private\" crates are permanently unstable so it makes no sense\n-    // to render \"unstable\" everywhere.\n-    if item\n-        .stability(tcx)\n-        .as_ref()\n-        .map(|s| s.level.is_unstable() && s.feature != sym::rustc_private)\n-        == Some(true)\n-    {\n-        tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n-    }\n-\n-    let cfg = match (&item.attrs.cfg, parent.attrs.cfg.as_ref()) {\n-        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n-        (cfg, _) => cfg.as_deref().cloned(),\n-    };\n-\n-    debug!(\"Portability {:?} - {:?} = {:?}\", item.attrs.cfg, parent.attrs.cfg, cfg);\n-    if let Some(ref cfg) = cfg {\n-        tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n-    }\n-\n-    tags\n-}\n-\n fn portability(item: &clean::Item, parent: Option<&clean::Item>) -> Option<String> {\n     let cfg = match (&item.attrs.cfg, parent.and_then(|p| p.attrs.cfg.as_ref())) {\n         (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n@@ -1836,124 +1389,6 @@ fn short_item_info(\n     extra_info\n }\n \n-fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n-    w.write_str(\"<pre class=\\\"rust const\\\">\");\n-    render_attributes(w, it, false);\n-\n-    write!(\n-        w,\n-        \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-        name = it.name.as_ref().unwrap(),\n-        typ = c.type_.print(cx.cache()),\n-    );\n-\n-    if c.value.is_some() || c.is_literal {\n-        write!(w, \" = {expr};\", expr = Escape(&c.expr));\n-    } else {\n-        w.write_str(\";\");\n-    }\n-\n-    if let Some(value) = &c.value {\n-        if !c.is_literal {\n-            let value_lowercase = value.to_lowercase();\n-            let expr_lowercase = c.expr.to_lowercase();\n-\n-            if value_lowercase != expr_lowercase\n-                && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n-            {\n-                write!(w, \" // {value}\", value = Escape(value));\n-            }\n-        }\n-    }\n-\n-    w.write_str(\"</pre>\");\n-    document(w, cx, it, None)\n-}\n-\n-fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n-    w.write_str(\"<pre class=\\\"rust static\\\">\");\n-    render_attributes(w, it, false);\n-    write!(\n-        w,\n-        \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-        mutability = s.mutability.print_with_space(),\n-        name = it.name.as_ref().unwrap(),\n-        typ = s.type_.print(cx.cache())\n-    );\n-    document(w, cx, it, None)\n-}\n-\n-fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n-    let header_len = format!(\n-        \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-        f.header.constness.print_with_space(),\n-        f.header.asyncness.print_with_space(),\n-        f.header.unsafety.print_with_space(),\n-        print_abi_with_space(f.header.abi),\n-        it.name.as_ref().unwrap(),\n-        f.generics.print(cx.cache())\n-    )\n-    .len();\n-    w.write_str(\"<pre class=\\\"rust fn\\\">\");\n-    render_attributes(w, it, false);\n-    write!(\n-        w,\n-        \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n-         {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-        constness = f.header.constness.print_with_space(),\n-        asyncness = f.header.asyncness.print_with_space(),\n-        unsafety = f.header.unsafety.print_with_space(),\n-        abi = print_abi_with_space(f.header.abi),\n-        name = it.name.as_ref().unwrap(),\n-        generics = f.generics.print(cx.cache()),\n-        where_clause =\n-            WhereClause { gens: &f.generics, indent: 0, end_newline: true }.print(cx.cache()),\n-        decl = Function { decl: &f.decl, header_len, indent: 0, asyncness: f.header.asyncness }\n-            .print(cx.cache()),\n-        spotlight = spotlight_decl(&f.decl, cx.cache()),\n-    );\n-    document(w, cx, it, None)\n-}\n-\n-fn render_implementor(\n-    cx: &Context<'_>,\n-    implementor: &Impl,\n-    trait_: &clean::Item,\n-    w: &mut Buffer,\n-    implementor_dups: &FxHashMap<Symbol, (DefId, bool)>,\n-    aliases: &[String],\n-) {\n-    // If there's already another implementor that has the same abbridged name, use the\n-    // full path, for example in `std::iter::ExactSizeIterator`\n-    let use_absolute = match implementor.inner_impl().for_ {\n-        clean::ResolvedPath { ref path, is_generic: false, .. }\n-        | clean::BorrowedRef {\n-            type_: box clean::ResolvedPath { ref path, is_generic: false, .. },\n-            ..\n-        } => implementor_dups[&path.last()].1,\n-        _ => false,\n-    };\n-    render_impl(\n-        w,\n-        cx,\n-        implementor,\n-        trait_,\n-        AssocItemLink::Anchor(None),\n-        RenderMode::Normal,\n-        trait_.stable_since(cx.tcx()).as_deref(),\n-        trait_.const_stable_since(cx.tcx()).as_deref(),\n-        false,\n-        Some(use_absolute),\n-        false,\n-        false,\n-        aliases,\n-    );\n-}\n-\n fn render_impls(\n     cx: &Context<'_>,\n     w: &mut Buffer,\n@@ -1988,326 +1423,6 @@ fn render_impls(\n     w.write_str(&impls.join(\"\"));\n }\n \n-fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cache: &Cache) -> String {\n-    let mut bounds = String::new();\n-    if !t_bounds.is_empty() {\n-        if !trait_alias {\n-            bounds.push_str(\": \");\n-        }\n-        for (i, p) in t_bounds.iter().enumerate() {\n-            if i > 0 {\n-                bounds.push_str(\" + \");\n-            }\n-            bounds.push_str(&p.print(cache).to_string());\n-        }\n-    }\n-    bounds\n-}\n-\n-fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cache: &Cache) -> Ordering {\n-    let lhs = format!(\"{}\", lhs.inner_impl().print(cache, false));\n-    let rhs = format!(\"{}\", rhs.inner_impl().print(cache, false));\n-\n-    // lhs and rhs are formatted as HTML, which may be unnecessary\n-    compare_names(&lhs, &rhs)\n-}\n-\n-fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n-    let bounds = bounds(&t.bounds, false, cx.cache());\n-    let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n-    let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n-    let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n-    let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n-\n-    // Output the trait definition\n-    wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust trait\\\">\");\n-        render_attributes(w, it, true);\n-        write!(\n-            w,\n-            \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-            t.unsafety.print_with_space(),\n-            if t.is_auto { \"auto \" } else { \"\" },\n-            it.name.as_ref().unwrap(),\n-            t.generics.print(cx.cache()),\n-            bounds\n-        );\n-\n-        if !t.generics.where_predicates.is_empty() {\n-            let where_ = WhereClause { gens: &t.generics, indent: 0, end_newline: true };\n-            write!(w, \"{}\", where_.print(cx.cache()));\n-        } else {\n-            w.write_str(\" \");\n-        }\n-\n-        if t.items.is_empty() {\n-            w.write_str(\"{ }\");\n-        } else {\n-            // FIXME: we should be using a derived_id for the Anchors here\n-            w.write_str(\"{\\n\");\n-            for t in &types {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n-            }\n-            if !types.is_empty() && !consts.is_empty() {\n-                w.write_str(\"\\n\");\n-            }\n-            for t in &consts {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n-            }\n-            if !consts.is_empty() && !required.is_empty() {\n-                w.write_str(\"\\n\");\n-            }\n-            for (pos, m) in required.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n-\n-                if pos < required.len() - 1 {\n-                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n-                }\n-            }\n-            if !required.is_empty() && !provided.is_empty() {\n-                w.write_str(\"\\n\");\n-            }\n-            for (pos, m) in provided.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                match *m.kind {\n-                    clean::MethodItem(ref inner, _)\n-                        if !inner.generics.where_predicates.is_empty() =>\n-                    {\n-                        w.write_str(\",\\n    { ... }\\n\");\n-                    }\n-                    _ => {\n-                        w.write_str(\" { ... }\\n\");\n-                    }\n-                }\n-                if pos < provided.len() - 1 {\n-                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n-                }\n-            }\n-            w.write_str(\"}\");\n-        }\n-        w.write_str(\"</pre>\")\n-    });\n-\n-    // Trait documentation\n-    document(w, cx, it, None);\n-\n-    fn write_small_section_header(w: &mut Buffer, id: &str, title: &str, extra_content: &str) {\n-        write!(\n-            w,\n-            \"<h2 id=\\\"{0}\\\" class=\\\"small-section-header\\\">\\\n-                {1}<a href=\\\"#{0}\\\" class=\\\"anchor\\\"></a>\\\n-             </h2>{2}\",\n-            id, title, extra_content\n-        )\n-    }\n-\n-    fn write_loading_content(w: &mut Buffer, extra_content: &str) {\n-        write!(w, \"{}<span class=\\\"loading-content\\\">Loading content...</span>\", extra_content)\n-    }\n-\n-    fn trait_item(w: &mut Buffer, cx: &Context<'_>, m: &clean::Item, t: &clean::Item) {\n-        let name = m.name.as_ref().unwrap();\n-        info!(\"Documenting {} on {:?}\", name, t.name);\n-        let item_type = m.type_();\n-        let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n-        write!(w, \"<h3 id=\\\"{id}\\\" class=\\\"method\\\"><code>\", id = id,);\n-        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n-        w.write_str(\"</code>\");\n-        render_stability_since(w, m, t, cx.tcx());\n-        write_srclink(cx, m, w);\n-        w.write_str(\"</h3>\");\n-        document(w, cx, m, Some(t));\n-    }\n-\n-    if !types.is_empty() {\n-        write_small_section_header(\n-            w,\n-            \"associated-types\",\n-            \"Associated Types\",\n-            \"<div class=\\\"methods\\\">\",\n-        );\n-        for t in types {\n-            trait_item(w, cx, t, it);\n-        }\n-        write_loading_content(w, \"</div>\");\n-    }\n-\n-    if !consts.is_empty() {\n-        write_small_section_header(\n-            w,\n-            \"associated-const\",\n-            \"Associated Constants\",\n-            \"<div class=\\\"methods\\\">\",\n-        );\n-        for t in consts {\n-            trait_item(w, cx, t, it);\n-        }\n-        write_loading_content(w, \"</div>\");\n-    }\n-\n-    // Output the documentation for each function individually\n-    if !required.is_empty() {\n-        write_small_section_header(\n-            w,\n-            \"required-methods\",\n-            \"Required methods\",\n-            \"<div class=\\\"methods\\\">\",\n-        );\n-        for m in required {\n-            trait_item(w, cx, m, it);\n-        }\n-        write_loading_content(w, \"</div>\");\n-    }\n-    if !provided.is_empty() {\n-        write_small_section_header(\n-            w,\n-            \"provided-methods\",\n-            \"Provided methods\",\n-            \"<div class=\\\"methods\\\">\",\n-        );\n-        for m in provided {\n-            trait_item(w, cx, m, it);\n-        }\n-        write_loading_content(w, \"</div>\");\n-    }\n-\n-    // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n-\n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n-        // The DefId is for the first Type found with that name. The bool is\n-        // if any Types with the same name but different DefId have been found.\n-        let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n-        for implementor in implementors {\n-            match implementor.inner_impl().for_ {\n-                clean::ResolvedPath { ref path, did, is_generic: false, .. }\n-                | clean::BorrowedRef {\n-                    type_: box clean::ResolvedPath { ref path, did, is_generic: false, .. },\n-                    ..\n-                } => {\n-                    let &mut (prev_did, ref mut has_duplicates) =\n-                        implementor_dups.entry(path.last()).or_insert((did, false));\n-                    if prev_did != did {\n-                        *has_duplicates = true;\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl()\n-                .for_\n-                .def_id_full(cx.cache())\n-                .map_or(true, |d| cx.cache.paths.contains_key(&d))\n-        });\n-\n-        let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n-            local.iter().partition(|i| i.inner_impl().synthetic);\n-\n-        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n-        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n-\n-        if !foreign.is_empty() {\n-            write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n-\n-            for implementor in foreign {\n-                let assoc_link = AssocItemLink::GotoSource(\n-                    implementor.impl_item.def_id,\n-                    &implementor.inner_impl().provided_trait_methods,\n-                );\n-                render_impl(\n-                    w,\n-                    cx,\n-                    &implementor,\n-                    it,\n-                    assoc_link,\n-                    RenderMode::Normal,\n-                    implementor.impl_item.stable_since(cx.tcx()).as_deref(),\n-                    implementor.impl_item.const_stable_since(cx.tcx()).as_deref(),\n-                    false,\n-                    None,\n-                    true,\n-                    false,\n-                    &[],\n-                );\n-            }\n-            write_loading_content(w, \"\");\n-        }\n-\n-        write_small_section_header(\n-            w,\n-            \"implementors\",\n-            \"Implementors\",\n-            \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n-        );\n-        for implementor in concrete {\n-            render_implementor(cx, implementor, it, w, &implementor_dups, &[]);\n-        }\n-        write_loading_content(w, \"</div>\");\n-\n-        if t.is_auto {\n-            write_small_section_header(\n-                w,\n-                \"synthetic-implementors\",\n-                \"Auto implementors\",\n-                \"<div class=\\\"item-list\\\" id=\\\"synthetic-implementors-list\\\">\",\n-            );\n-            for implementor in synthetic {\n-                render_implementor(\n-                    cx,\n-                    implementor,\n-                    it,\n-                    w,\n-                    &implementor_dups,\n-                    &collect_paths_for_type(implementor.inner_impl().for_.clone(), &cx.cache),\n-                );\n-            }\n-            write_loading_content(w, \"</div>\");\n-        }\n-    } else {\n-        // even without any implementations to write in, we still want the heading and list, so the\n-        // implementors javascript file pulled in below has somewhere to write the impls into\n-        write_small_section_header(\n-            w,\n-            \"implementors\",\n-            \"Implementors\",\n-            \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n-        );\n-        write_loading_content(w, \"</div>\");\n-\n-        if t.is_auto {\n-            write_small_section_header(\n-                w,\n-                \"synthetic-implementors\",\n-                \"Auto implementors\",\n-                \"<div class=\\\"item-list\\\" id=\\\"synthetic-implementors-list\\\">\",\n-            );\n-            write_loading_content(w, \"</div>\");\n-        }\n-    }\n-\n-    write!(\n-        w,\n-        \"<script type=\\\"text/javascript\\\" \\\n-                 src=\\\"{root_path}/implementors/{path}/{ty}.{name}.js\\\" async>\\\n-         </script>\",\n-        root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n-        path = if it.def_id.is_local() {\n-            cx.current.join(\"/\")\n-        } else {\n-            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n-            path[..path.len() - 1].join(\"/\")\n-        },\n-        ty = it.type_(),\n-        name = *it.name.as_ref().unwrap()\n-    );\n-}\n-\n fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cache: &Cache) -> String {\n     use crate::formats::item_type::ItemType::*;\n \n@@ -2400,21 +1515,6 @@ fn render_stability_since_raw(\n     }\n }\n \n-fn render_stability_since(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    containing_item: &clean::Item,\n-    tcx: TyCtxt<'_>,\n-) {\n-    render_stability_since_raw(\n-        w,\n-        item.stable_since(tcx).as_deref(),\n-        item.const_stable_since(tcx).as_deref(),\n-        containing_item.stable_since(tcx).as_deref(),\n-        containing_item.const_stable_since(tcx).as_deref(),\n-    )\n-}\n-\n fn render_assoc_item(\n     w: &mut Buffer,\n     item: &clean::Item,\n@@ -2518,227 +1618,6 @@ fn render_assoc_item(\n     }\n }\n \n-fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n-    wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust struct\\\">\");\n-        render_attributes(w, it, true);\n-        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n-        w.write_str(\"</pre>\")\n-    });\n-\n-    document(w, cx, it, None);\n-    let mut fields = s\n-        .fields\n-        .iter()\n-        .filter_map(|f| match *f.kind {\n-            clean::StructFieldItem(ref ty) => Some((f, ty)),\n-            _ => None,\n-        })\n-        .peekable();\n-    if let CtorKind::Fictive = s.struct_type {\n-        if fields.peek().is_some() {\n-            write!(\n-                w,\n-                \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\n-                       Fields{}<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\",\n-                document_non_exhaustive_header(it)\n-            );\n-            document_non_exhaustive(w, it);\n-            for (field, ty) in fields {\n-                let id = cx.derive_id(format!(\n-                    \"{}.{}\",\n-                    ItemType::StructField,\n-                    field.name.as_ref().unwrap()\n-                ));\n-                write!(\n-                    w,\n-                    \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\\\n-                         <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n-                         <code>{name}: {ty}</code>\\\n-                     </span>\",\n-                    item_type = ItemType::StructField,\n-                    id = id,\n-                    name = field.name.as_ref().unwrap(),\n-                    ty = ty.print(cx.cache())\n-                );\n-                document(w, cx, field, Some(it));\n-            }\n-        }\n-    }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n-}\n-\n-fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n-    wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust union\\\">\");\n-        render_attributes(w, it, true);\n-        render_union(w, it, Some(&s.generics), &s.fields, \"\", true, cx);\n-        w.write_str(\"</pre>\")\n-    });\n-\n-    document(w, cx, it, None);\n-    let mut fields = s\n-        .fields\n-        .iter()\n-        .filter_map(|f| match *f.kind {\n-            clean::StructFieldItem(ref ty) => Some((f, ty)),\n-            _ => None,\n-        })\n-        .peekable();\n-    if fields.peek().is_some() {\n-        write!(\n-            w,\n-            \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\n-                   Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\"\n-        );\n-        for (field, ty) in fields {\n-            let name = field.name.as_ref().expect(\"union field name\");\n-            let id = format!(\"{}.{}\", ItemType::StructField, name);\n-            write!(\n-                w,\n-                \"<span id=\\\"{id}\\\" class=\\\"{shortty} small-section-header\\\">\\\n-                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n-                     <code>{name}: {ty}</code>\\\n-                 </span>\",\n-                id = id,\n-                name = name,\n-                shortty = ItemType::StructField,\n-                ty = ty.print(cx.cache())\n-            );\n-            if let Some(stability_class) = field.stability_class(cx.tcx()) {\n-                write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n-            }\n-            document(w, cx, field, Some(it));\n-        }\n-    }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n-}\n-\n-fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n-    wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust enum\\\">\");\n-        render_attributes(w, it, true);\n-        write!(\n-            w,\n-            \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-            it.name.as_ref().unwrap(),\n-            e.generics.print(cx.cache()),\n-            WhereClause { gens: &e.generics, indent: 0, end_newline: true }.print(cx.cache())\n-        );\n-        if e.variants.is_empty() && !e.variants_stripped {\n-            w.write_str(\" {}\");\n-        } else {\n-            w.write_str(\" {\\n\");\n-            for v in &e.variants {\n-                w.write_str(\"    \");\n-                let name = v.name.as_ref().unwrap();\n-                match *v.kind {\n-                    clean::VariantItem(ref var) => match var {\n-                        clean::Variant::CLike => write!(w, \"{}\", name),\n-                        clean::Variant::Tuple(ref tys) => {\n-                            write!(w, \"{}(\", name);\n-                            for (i, ty) in tys.iter().enumerate() {\n-                                if i > 0 {\n-                                    w.write_str(\",&nbsp;\")\n-                                }\n-                                write!(w, \"{}\", ty.print(cx.cache()));\n-                            }\n-                            w.write_str(\")\");\n-                        }\n-                        clean::Variant::Struct(ref s) => {\n-                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n-                        }\n-                    },\n-                    _ => unreachable!(),\n-                }\n-                w.write_str(\",\\n\");\n-            }\n-\n-            if e.variants_stripped {\n-                w.write_str(\"    // some variants omitted\\n\");\n-            }\n-            w.write_str(\"}\");\n-        }\n-        w.write_str(\"</pre>\")\n-    });\n-\n-    document(w, cx, it, None);\n-    if !e.variants.is_empty() {\n-        write!(\n-            w,\n-            \"<h2 id=\\\"variants\\\" class=\\\"variants small-section-header\\\">\n-                   Variants{}<a href=\\\"#variants\\\" class=\\\"anchor\\\"></a></h2>\\n\",\n-            document_non_exhaustive_header(it)\n-        );\n-        document_non_exhaustive(w, it);\n-        for variant in &e.variants {\n-            let id =\n-                cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.as_ref().unwrap()));\n-            write!(\n-                w,\n-                \"<div id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n-                    <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n-                    <code>{name}\",\n-                id = id,\n-                name = variant.name.as_ref().unwrap()\n-            );\n-            if let clean::VariantItem(clean::Variant::Tuple(ref tys)) = *variant.kind {\n-                w.write_str(\"(\");\n-                for (i, ty) in tys.iter().enumerate() {\n-                    if i > 0 {\n-                        w.write_str(\",&nbsp;\");\n-                    }\n-                    write!(w, \"{}\", ty.print(cx.cache()));\n-                }\n-                w.write_str(\")\");\n-            }\n-            w.write_str(\"</code></div>\");\n-            document(w, cx, variant, Some(it));\n-            document_non_exhaustive(w, variant);\n-\n-            use crate::clean::Variant;\n-            if let clean::VariantItem(Variant::Struct(ref s)) = *variant.kind {\n-                let variant_id = cx.derive_id(format!(\n-                    \"{}.{}.fields\",\n-                    ItemType::Variant,\n-                    variant.name.as_ref().unwrap()\n-                ));\n-                write!(w, \"<div class=\\\"autohide sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n-                write!(\n-                    w,\n-                    \"<h3>Fields of <b>{name}</b></h3><div>\",\n-                    name = variant.name.as_ref().unwrap()\n-                );\n-                for field in &s.fields {\n-                    use crate::clean::StructFieldItem;\n-                    if let StructFieldItem(ref ty) = *field.kind {\n-                        let id = cx.derive_id(format!(\n-                            \"variant.{}.field.{}\",\n-                            variant.name.as_ref().unwrap(),\n-                            field.name.as_ref().unwrap()\n-                        ));\n-                        write!(\n-                            w,\n-                            \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n-                                 <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n-                                 <code>{f}:&nbsp;{t}</code>\\\n-                             </span>\",\n-                            id = id,\n-                            f = field.name.as_ref().unwrap(),\n-                            t = ty.print(cx.cache())\n-                        );\n-                        document(w, cx, field, Some(variant));\n-                    }\n-                }\n-                w.write_str(\"</div></div>\");\n-            }\n-            render_stability_since(w, variant, it, cx.tcx());\n-        }\n-    }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n-}\n-\n const ALLOWED_ATTRIBUTES: &[Symbol] = &[\n     sym::export_name,\n     sym::lang,\n@@ -2781,147 +1660,6 @@ fn render_attributes(w: &mut Buffer, it: &clean::Item, top: bool) {\n     }\n }\n \n-fn render_struct(\n-    w: &mut Buffer,\n-    it: &clean::Item,\n-    g: Option<&clean::Generics>,\n-    ty: CtorKind,\n-    fields: &[clean::Item],\n-    tab: &str,\n-    structhead: bool,\n-    cx: &Context<'_>,\n-) {\n-    write!(\n-        w,\n-        \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-        if structhead { \"struct \" } else { \"\" },\n-        it.name.as_ref().unwrap()\n-    );\n-    if let Some(g) = g {\n-        write!(w, \"{}\", g.print(cx.cache()))\n-    }\n-    match ty {\n-        CtorKind::Fictive => {\n-            if let Some(g) = g {\n-                write!(\n-                    w,\n-                    \"{}\",\n-                    WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache())\n-                )\n-            }\n-            let mut has_visible_fields = false;\n-            w.write_str(\" {\");\n-            for field in fields {\n-                if let clean::StructFieldItem(ref ty) = *field.kind {\n-                    write!(\n-                        w,\n-                        \"\\n{}    {}{}: {},\",\n-                        tab,\n-                        field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n-                        field.name.as_ref().unwrap(),\n-                        ty.print(cx.cache())\n-                    );\n-                    has_visible_fields = true;\n-                }\n-            }\n-\n-            if has_visible_fields {\n-                if it.has_stripped_fields().unwrap() {\n-                    write!(w, \"\\n{}    // some fields omitted\", tab);\n-                }\n-                write!(w, \"\\n{}\", tab);\n-            } else if it.has_stripped_fields().unwrap() {\n-                // If there are no visible fields we can just display\n-                // `{ /* fields omitted */ }` to save space.\n-                write!(w, \" /* fields omitted */ \");\n-            }\n-            w.write_str(\"}\");\n-        }\n-        CtorKind::Fn => {\n-            w.write_str(\"(\");\n-            for (i, field) in fields.iter().enumerate() {\n-                if i > 0 {\n-                    w.write_str(\", \");\n-                }\n-                match *field.kind {\n-                    clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n-                    clean::StructFieldItem(ref ty) => {\n-                        write!(\n-                            w,\n-                            \"{}{}\",\n-                            field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n-                            ty.print(cx.cache())\n-                        )\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            w.write_str(\")\");\n-            if let Some(g) = g {\n-                write!(\n-                    w,\n-                    \"{}\",\n-                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n-                )\n-            }\n-            w.write_str(\";\");\n-        }\n-        CtorKind::Const => {\n-            // Needed for PhantomData.\n-            if let Some(g) = g {\n-                write!(\n-                    w,\n-                    \"{}\",\n-                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n-                )\n-            }\n-            w.write_str(\";\");\n-        }\n-    }\n-}\n-\n-fn render_union(\n-    w: &mut Buffer,\n-    it: &clean::Item,\n-    g: Option<&clean::Generics>,\n-    fields: &[clean::Item],\n-    tab: &str,\n-    structhead: bool,\n-    cx: &Context<'_>,\n-) {\n-    write!(\n-        w,\n-        \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-        if structhead { \"union \" } else { \"\" },\n-        it.name.as_ref().unwrap()\n-    );\n-    if let Some(g) = g {\n-        write!(w, \"{}\", g.print(cx.cache()));\n-        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache()));\n-    }\n-\n-    write!(w, \" {{\\n{}\", tab);\n-    for field in fields {\n-        if let clean::StructFieldItem(ref ty) = *field.kind {\n-            write!(\n-                w,\n-                \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n-                field.name.as_ref().unwrap(),\n-                ty.print(cx.cache()),\n-                tab\n-            );\n-        }\n-    }\n-\n-    if it.has_stripped_fields().unwrap() {\n-        write!(w, \"    // some fields omitted\\n{}\", tab);\n-    }\n-    w.write_str(\"}\");\n-}\n-\n #[derive(Copy, Clone)]\n enum AssocItemLink<'a> {\n     Anchor(Option<&'a str>),\n@@ -3492,86 +2230,6 @@ fn render_impl(\n     w.write_str(\"</div>\");\n }\n \n-fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n-    w.write_str(\"<pre class=\\\"rust opaque\\\">\");\n-    render_attributes(w, it, false);\n-    write!(\n-        w,\n-        \"type {}{}{where_clause} = impl {bounds};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache()),\n-        where_clause =\n-            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n-        bounds = bounds(&t.bounds, false, cx.cache())\n-    );\n-\n-    document(w, cx, it, None);\n-\n-    // Render any items associated directly to this alias, as otherwise they\n-    // won't be visible anywhere in the docs. It would be nice to also show\n-    // associated items from the aliased type (see discussion in #32077), but\n-    // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n-}\n-\n-fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n-    w.write_str(\"<pre class=\\\"rust trait-alias\\\">\");\n-    render_attributes(w, it, false);\n-    write!(\n-        w,\n-        \"trait {}{}{} = {};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache()),\n-        WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n-        bounds(&t.bounds, true, cx.cache())\n-    );\n-\n-    document(w, cx, it, None);\n-\n-    // Render any items associated directly to this alias, as otherwise they\n-    // won't be visible anywhere in the docs. It would be nice to also show\n-    // associated items from the aliased type (see discussion in #32077), but\n-    // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n-}\n-\n-fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n-    w.write_str(\"<pre class=\\\"rust typedef\\\">\");\n-    render_attributes(w, it, false);\n-    write!(\n-        w,\n-        \"type {}{}{where_clause} = {type_};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache()),\n-        where_clause =\n-            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n-        type_ = t.type_.print(cx.cache())\n-    );\n-\n-    document(w, cx, it, None);\n-\n-    // Render any items associated directly to this alias, as otherwise they\n-    // won't be visible anywhere in the docs. It would be nice to also show\n-    // associated items from the aliased type (see discussion in #32077), but\n-    // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n-}\n-\n-fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n-    w.write_str(\"<pre class=\\\"rust foreigntype\\\">extern {\\n\");\n-    render_attributes(w, it, false);\n-    write!(\n-        w,\n-        \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-        it.name.as_ref().unwrap(),\n-    );\n-\n-    document(w, cx, it, None);\n-\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n-}\n-\n fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n     let parentlen = cx.current.len() - if it.is_mod() { 1 } else { 0 };\n \n@@ -4264,59 +2922,6 @@ fn sidebar_foreign_type(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Macro) {\n-    wrap_into_docblock(w, |w| {\n-        highlight::render_with_highlighting(\n-            &t.source,\n-            w,\n-            Some(\"macro\"),\n-            None,\n-            None,\n-            it.source.span().edition(),\n-        );\n-    });\n-    document(w, cx, it, None)\n-}\n-\n-fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n-    let name = it.name.as_ref().expect(\"proc-macros always have names\");\n-    match m.kind {\n-        MacroKind::Bang => {\n-            w.push_str(\"<pre class=\\\"rust macro\\\">\");\n-            write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n-            w.push_str(\"</pre>\");\n-        }\n-        MacroKind::Attr => {\n-            w.push_str(\"<pre class=\\\"rust attr\\\">\");\n-            write!(w, \"#[{}]\", name);\n-            w.push_str(\"</pre>\");\n-        }\n-        MacroKind::Derive => {\n-            w.push_str(\"<pre class=\\\"rust derive\\\">\");\n-            write!(w, \"#[derive({})]\", name);\n-            if !m.helpers.is_empty() {\n-                w.push_str(\"\\n{\\n\");\n-                w.push_str(\"    // Attributes available to this derive:\\n\");\n-                for attr in &m.helpers {\n-                    writeln!(w, \"    #[{}]\", attr);\n-                }\n-                w.push_str(\"}\\n\");\n-            }\n-            w.push_str(\"</pre>\");\n-        }\n-    }\n-    document(w, cx, it, None)\n-}\n-\n-fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n-    document(w, cx, it, None);\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n-}\n-\n-fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n-    document(w, cx, it, None)\n-}\n-\n crate const BASIC_KEYWORDS: &str = \"rust, rustlang, rust-lang\";\n \n fn make_item_keywords(it: &clean::Item) -> String {"}, {"sha": "6d61248f28ef0936bacfbfa656edb9d1fe84f942", "filename": "src/librustdoc/html/render/print_item.rs", "status": "added", "additions": 1420, "deletions": 0, "changes": 1420, "blob_url": "https://github.com/rust-lang/rust/blob/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=6c7d7a6bf4b8a3a653d8cba0acf5b20b088aff2e", "patch": "@@ -0,0 +1,1420 @@\n+use std::cmp::Ordering;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_hir::def::CtorKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::middle::stability;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::hygiene::MacroKind;\n+use rustc_span::symbol::{kw, sym, Symbol};\n+\n+use super::{\n+    collect_paths_for_type, document, ensure_trailing_slash, item_ty_to_strs, render_assoc_item,\n+    render_assoc_items, render_attributes, render_impl, render_stability_since_raw, spotlight_decl,\n+    write_srclink, AssocItemLink, Context,\n+};\n+use crate::clean::{self, GetDefId};\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n+use crate::html::escape::Escape;\n+use crate::html::format::{print_abi_with_space, Buffer, Function, PrintWithSpace, WhereClause};\n+use crate::html::highlight;\n+use crate::html::markdown::MarkdownSummaryLine;\n+\n+pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n+    debug_assert!(!item.is_stripped());\n+    // Write the breadcrumb trail header for the top\n+    buf.write_str(\"<h1 class=\\\"fqn\\\"><span class=\\\"in-band\\\">\");\n+    let name = match *item.kind {\n+        clean::ModuleItem(ref m) => {\n+            if m.is_crate {\n+                \"Crate \"\n+            } else {\n+                \"Module \"\n+            }\n+        }\n+        clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => \"Function \",\n+        clean::TraitItem(..) => \"Trait \",\n+        clean::StructItem(..) => \"Struct \",\n+        clean::UnionItem(..) => \"Union \",\n+        clean::EnumItem(..) => \"Enum \",\n+        clean::TypedefItem(..) => \"Type Definition \",\n+        clean::MacroItem(..) => \"Macro \",\n+        clean::ProcMacroItem(ref mac) => match mac.kind {\n+            MacroKind::Bang => \"Macro \",\n+            MacroKind::Attr => \"Attribute Macro \",\n+            MacroKind::Derive => \"Derive Macro \",\n+        },\n+        clean::PrimitiveItem(..) => \"Primitive Type \",\n+        clean::StaticItem(..) | clean::ForeignStaticItem(..) => \"Static \",\n+        clean::ConstantItem(..) => \"Constant \",\n+        clean::ForeignTypeItem => \"Foreign Type \",\n+        clean::KeywordItem(..) => \"Keyword \",\n+        clean::OpaqueTyItem(..) => \"Opaque Type \",\n+        clean::TraitAliasItem(..) => \"Trait Alias \",\n+        _ => {\n+            // We don't generate pages for any other type.\n+            unreachable!();\n+        }\n+    };\n+    buf.write_str(name);\n+    if !item.is_primitive() && !item.is_keyword() {\n+        let cur = &cx.current;\n+        let amt = if item.is_mod() { cur.len() - 1 } else { cur.len() };\n+        for (i, component) in cur.iter().enumerate().take(amt) {\n+            write!(\n+                buf,\n+                \"<a href=\\\"{}index.html\\\">{}</a>::<wbr>\",\n+                \"../\".repeat(cur.len() - i - 1),\n+                component\n+            );\n+        }\n+    }\n+    write!(buf, \"<a class=\\\"{}\\\" href=\\\"\\\">{}</a>\", item.type_(), item.name.as_ref().unwrap());\n+\n+    buf.write_str(\"</span>\"); // in-band\n+    buf.write_str(\"<span class=\\\"out-of-band\\\">\");\n+    render_stability_since_raw(\n+        buf,\n+        item.stable_since(cx.tcx()).as_deref(),\n+        item.const_stable_since(cx.tcx()).as_deref(),\n+        None,\n+        None,\n+    );\n+    buf.write_str(\n+        \"<span id=\\\"render-detail\\\">\\\n+                <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n+                    title=\\\"collapse all docs\\\">\\\n+                    [<span class=\\\"inner\\\">&#x2212;</span>]\\\n+                </a>\\\n+            </span>\",\n+    );\n+\n+    // Write `src` tag\n+    //\n+    // When this item is part of a `crate use` in a downstream crate, the\n+    // [src] link in the downstream documentation will actually come back to\n+    // this page, and this link will be auto-clicked. The `id` attribute is\n+    // used to find the link to auto-click.\n+    if cx.shared.include_sources && !item.is_primitive() {\n+        write_srclink(cx, item, buf);\n+    }\n+\n+    buf.write_str(\"</span></h1>\"); // out-of-band\n+\n+    match *item.kind {\n+        clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n+        clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n+            item_function(buf, cx, item, f)\n+        }\n+        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n+        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n+        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n+        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n+        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n+        clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n+        clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n+        clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n+        clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n+        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n+        clean::KeywordItem(_) => item_keyword(buf, cx, item),\n+        clean::OpaqueTyItem(ref e) => item_opaque_ty(buf, cx, item, e),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n+        _ => {\n+            // We don't generate pages for any other type.\n+            unreachable!();\n+        }\n+    }\n+}\n+\n+fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n+    document(w, cx, item, None);\n+\n+    let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n+\n+    // the order of item types in the listing\n+    fn reorder(ty: ItemType) -> u8 {\n+        match ty {\n+            ItemType::ExternCrate => 0,\n+            ItemType::Import => 1,\n+            ItemType::Primitive => 2,\n+            ItemType::Module => 3,\n+            ItemType::Macro => 4,\n+            ItemType::Struct => 5,\n+            ItemType::Enum => 6,\n+            ItemType::Constant => 7,\n+            ItemType::Static => 8,\n+            ItemType::Trait => 9,\n+            ItemType::Function => 10,\n+            ItemType::Typedef => 12,\n+            ItemType::Union => 13,\n+            _ => 14 + ty as u8,\n+        }\n+    }\n+\n+    fn cmp(\n+        i1: &clean::Item,\n+        i2: &clean::Item,\n+        idx1: usize,\n+        idx2: usize,\n+        tcx: TyCtxt<'_>,\n+    ) -> Ordering {\n+        let ty1 = i1.type_();\n+        let ty2 = i2.type_();\n+        if ty1 != ty2 {\n+            return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2));\n+        }\n+        let s1 = i1.stability(tcx).as_ref().map(|s| s.level);\n+        let s2 = i2.stability(tcx).as_ref().map(|s| s.level);\n+        if let (Some(a), Some(b)) = (s1, s2) {\n+            match (a.is_stable(), b.is_stable()) {\n+                (true, true) | (false, false) => {}\n+                (false, true) => return Ordering::Less,\n+                (true, false) => return Ordering::Greater,\n+            }\n+        }\n+        let lhs = i1.name.unwrap_or(kw::Empty).as_str();\n+        let rhs = i2.name.unwrap_or(kw::Empty).as_str();\n+        compare_names(&lhs, &rhs)\n+    }\n+\n+    if cx.shared.sort_modules_alphabetically {\n+        indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2, cx.tcx()));\n+    }\n+    // This call is to remove re-export duplicates in cases such as:\n+    //\n+    // ```\n+    // crate mod foo {\n+    //     crate mod bar {\n+    //         crate trait Double { fn foo(); }\n+    //     }\n+    // }\n+    //\n+    // crate use foo::bar::*;\n+    // crate use foo::*;\n+    // ```\n+    //\n+    // `Double` will appear twice in the generated docs.\n+    //\n+    // FIXME: This code is quite ugly and could be improved. Small issue: DefId\n+    // can be identical even if the elements are different (mostly in imports).\n+    // So in case this is an import, we keep everything by adding a \"unique id\"\n+    // (which is the position in the vector).\n+    indices.dedup_by_key(|i| {\n+        (\n+            items[*i].def_id,\n+            if items[*i].name.as_ref().is_some() { Some(full_path(cx, &items[*i])) } else { None },\n+            items[*i].type_(),\n+            if items[*i].is_import() { *i } else { 0 },\n+        )\n+    });\n+\n+    debug!(\"{:?}\", indices);\n+    let mut curty = None;\n+    for &idx in &indices {\n+        let myitem = &items[idx];\n+        if myitem.is_stripped() {\n+            continue;\n+        }\n+\n+        let myty = Some(myitem.type_());\n+        if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n+            // Put `extern crate` and `use` re-exports in the same section.\n+            curty = myty;\n+        } else if myty != curty {\n+            if curty.is_some() {\n+                w.write_str(\"</table>\");\n+            }\n+            curty = myty;\n+            let (short, name) = item_ty_to_strs(&myty.unwrap());\n+            write!(\n+                w,\n+                \"<h2 id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n+                       <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n+                id = cx.derive_id(short.to_owned()),\n+                name = name\n+            );\n+        }\n+\n+        match *myitem.kind {\n+            clean::ExternCrateItem(ref name, ref src) => {\n+                use crate::html::format::anchor;\n+\n+                match *src {\n+                    Some(ref src) => write!(\n+                        w,\n+                        \"<tr><td><code>{}extern crate {} as {};\",\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                        anchor(myitem.def_id, &*src.as_str(), cx.cache()),\n+                        name\n+                    ),\n+                    None => write!(\n+                        w,\n+                        \"<tr><td><code>{}extern crate {};\",\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                        anchor(myitem.def_id, &*name.as_str(), cx.cache())\n+                    ),\n+                }\n+                w.write_str(\"</code></td></tr>\");\n+            }\n+\n+            clean::ImportItem(ref import) => {\n+                write!(\n+                    w,\n+                    \"<tr><td><code>{}{}</code></td></tr>\",\n+                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                    import.print(cx.cache())\n+                );\n+            }\n+\n+            _ => {\n+                if myitem.name.is_none() {\n+                    continue;\n+                }\n+\n+                let unsafety_flag = match *myitem.kind {\n+                    clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n+                        if func.header.unsafety == hir::Unsafety::Unsafe =>\n+                    {\n+                        \"<a title=\\\"unsafe function\\\" href=\\\"#\\\"><sup>\u26a0</sup></a>\"\n+                    }\n+                    _ => \"\",\n+                };\n+\n+                let stab = myitem.stability_class(cx.tcx());\n+                let add = if stab.is_some() { \" \" } else { \"\" };\n+\n+                let doc_value = myitem.doc_value().unwrap_or_default();\n+                write!(\n+                    w,\n+                    \"<tr class=\\\"{stab}{add}module-item\\\">\\\n+                         <td><a class=\\\"{class}\\\" href=\\\"{href}\\\" \\\n+                             title=\\\"{title}\\\">{name}</a>{unsafety_flag}</td>\\\n+                         <td class=\\\"docblock-short\\\">{stab_tags}{docs}</td>\\\n+                     </tr>\",\n+                    name = *myitem.name.as_ref().unwrap(),\n+                    stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n+                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(&cx.cache)).into_string(),\n+                    class = myitem.type_(),\n+                    add = add,\n+                    stab = stab.unwrap_or_else(String::new),\n+                    unsafety_flag = unsafety_flag,\n+                    href = item_path(myitem.type_(), &myitem.name.unwrap().as_str()),\n+                    title = [full_path(cx, myitem), myitem.type_().to_string()]\n+                        .iter()\n+                        .filter_map(|s| if !s.is_empty() { Some(s.as_str()) } else { None })\n+                        .collect::<Vec<_>>()\n+                        .join(\" \"),\n+                );\n+            }\n+        }\n+    }\n+\n+    if curty.is_some() {\n+        w.write_str(\"</table>\");\n+    }\n+}\n+\n+/// Render the stability, deprecation and portability tags that are displayed in the item's summary\n+/// at the module level.\n+fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) -> String {\n+    let mut tags = String::new();\n+\n+    fn tag_html(class: &str, title: &str, contents: &str) -> String {\n+        format!(r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#, class, Escape(title), contents)\n+    }\n+\n+    // The trailing space after each tag is to space it properly against the rest of the docs.\n+    if let Some(depr) = &item.deprecation(tcx) {\n+        let mut message = \"Deprecated\";\n+        if !stability::deprecation_in_effect(\n+            depr.is_since_rustc_version,\n+            depr.since.map(|s| s.as_str()).as_deref(),\n+        ) {\n+            message = \"Deprecation planned\";\n+        }\n+        tags += &tag_html(\"deprecated\", \"\", message);\n+    }\n+\n+    // The \"rustc_private\" crates are permanently unstable so it makes no sense\n+    // to render \"unstable\" everywhere.\n+    if item\n+        .stability(tcx)\n+        .as_ref()\n+        .map(|s| s.level.is_unstable() && s.feature != sym::rustc_private)\n+        == Some(true)\n+    {\n+        tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n+    }\n+\n+    let cfg = match (&item.attrs.cfg, parent.attrs.cfg.as_ref()) {\n+        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n+        (cfg, _) => cfg.as_deref().cloned(),\n+    };\n+\n+    debug!(\"Portability {:?} - {:?} = {:?}\", item.attrs.cfg, parent.attrs.cfg, cfg);\n+    if let Some(ref cfg) = cfg {\n+        tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n+    }\n+\n+    tags\n+}\n+\n+fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n+    let header_len = format!(\n+        \"{}{}{}{}{:#}fn {}{:#}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        f.header.constness.print_with_space(),\n+        f.header.asyncness.print_with_space(),\n+        f.header.unsafety.print_with_space(),\n+        print_abi_with_space(f.header.abi),\n+        it.name.as_ref().unwrap(),\n+        f.generics.print(cx.cache())\n+    )\n+    .len();\n+    w.write_str(\"<pre class=\\\"rust fn\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n+         {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        constness = f.header.constness.print_with_space(),\n+        asyncness = f.header.asyncness.print_with_space(),\n+        unsafety = f.header.unsafety.print_with_space(),\n+        abi = print_abi_with_space(f.header.abi),\n+        name = it.name.as_ref().unwrap(),\n+        generics = f.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &f.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        decl = Function { decl: &f.decl, header_len, indent: 0, asyncness: f.header.asyncness }\n+            .print(cx.cache()),\n+        spotlight = spotlight_decl(&f.decl, cx.cache()),\n+    );\n+    document(w, cx, it, None)\n+}\n+\n+fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n+    let bounds = bounds(&t.bounds, false, cx.cache());\n+    let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n+    let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n+    let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n+    let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n+\n+    // Output the trait definition\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust trait\\\">\");\n+        render_attributes(w, it, true);\n+        write!(\n+            w,\n+            \"{}{}{}trait {}{}{}\",\n+            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            t.unsafety.print_with_space(),\n+            if t.is_auto { \"auto \" } else { \"\" },\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx.cache()),\n+            bounds\n+        );\n+\n+        if !t.generics.where_predicates.is_empty() {\n+            let where_ = WhereClause { gens: &t.generics, indent: 0, end_newline: true };\n+            write!(w, \"{}\", where_.print(cx.cache()));\n+        } else {\n+            w.write_str(\" \");\n+        }\n+\n+        if t.items.is_empty() {\n+            w.write_str(\"{ }\");\n+        } else {\n+            // FIXME: we should be using a derived_id for the Anchors here\n+            w.write_str(\"{\\n\");\n+            for t in &types {\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+            }\n+            if !types.is_empty() && !consts.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for t in &consts {\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+            }\n+            if !consts.is_empty() && !required.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for (pos, m) in required.iter().enumerate() {\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+\n+                if pos < required.len() - 1 {\n+                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+                }\n+            }\n+            if !required.is_empty() && !provided.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for (pos, m) in provided.iter().enumerate() {\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                match *m.kind {\n+                    clean::MethodItem(ref inner, _)\n+                        if !inner.generics.where_predicates.is_empty() =>\n+                    {\n+                        w.write_str(\",\\n    { ... }\\n\");\n+                    }\n+                    _ => {\n+                        w.write_str(\" { ... }\\n\");\n+                    }\n+                }\n+                if pos < provided.len() - 1 {\n+                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+                }\n+            }\n+            w.write_str(\"}\");\n+        }\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    // Trait documentation\n+    document(w, cx, it, None);\n+\n+    fn write_small_section_header(w: &mut Buffer, id: &str, title: &str, extra_content: &str) {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"{0}\\\" class=\\\"small-section-header\\\">\\\n+                {1}<a href=\\\"#{0}\\\" class=\\\"anchor\\\"></a>\\\n+             </h2>{2}\",\n+            id, title, extra_content\n+        )\n+    }\n+\n+    fn write_loading_content(w: &mut Buffer, extra_content: &str) {\n+        write!(w, \"{}<span class=\\\"loading-content\\\">Loading content...</span>\", extra_content)\n+    }\n+\n+    fn trait_item(w: &mut Buffer, cx: &Context<'_>, m: &clean::Item, t: &clean::Item) {\n+        let name = m.name.as_ref().unwrap();\n+        info!(\"Documenting {} on {:?}\", name, t.name);\n+        let item_type = m.type_();\n+        let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+        write!(w, \"<h3 id=\\\"{id}\\\" class=\\\"method\\\"><code>\", id = id,);\n+        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n+        w.write_str(\"</code>\");\n+        render_stability_since(w, m, t, cx.tcx());\n+        write_srclink(cx, m, w);\n+        w.write_str(\"</h3>\");\n+        document(w, cx, m, Some(t));\n+    }\n+\n+    if !types.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"associated-types\",\n+            \"Associated Types\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in types {\n+            trait_item(w, cx, t, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    if !consts.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"associated-const\",\n+            \"Associated Constants\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in consts {\n+            trait_item(w, cx, t, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    // Output the documentation for each function individually\n+    if !required.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"required-methods\",\n+            \"Required methods\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for m in required {\n+            trait_item(w, cx, m, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+    if !provided.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"provided-methods\",\n+            \"Provided methods\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for m in provided {\n+            trait_item(w, cx, m, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    // If there are methods directly on this trait object, render them here.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n+\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+        // The DefId is for the first Type found with that name. The bool is\n+        // if any Types with the same name but different DefId have been found.\n+        let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n+        for implementor in implementors {\n+            match implementor.inner_impl().for_ {\n+                clean::ResolvedPath { ref path, did, is_generic: false, .. }\n+                | clean::BorrowedRef {\n+                    type_: box clean::ResolvedPath { ref path, did, is_generic: false, .. },\n+                    ..\n+                } => {\n+                    let &mut (prev_did, ref mut has_duplicates) =\n+                        implementor_dups.entry(path.last()).or_insert((did, false));\n+                    if prev_did != did {\n+                        *has_duplicates = true;\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n+            i.inner_impl()\n+                .for_\n+                .def_id_full(cx.cache())\n+                .map_or(true, |d| cx.cache.paths.contains_key(&d))\n+        });\n+\n+        let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n+            local.iter().partition(|i| i.inner_impl().synthetic);\n+\n+        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n+        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n+\n+        if !foreign.is_empty() {\n+            write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n+\n+            for implementor in foreign {\n+                let assoc_link = AssocItemLink::GotoSource(\n+                    implementor.impl_item.def_id,\n+                    &implementor.inner_impl().provided_trait_methods,\n+                );\n+                render_impl(\n+                    w,\n+                    cx,\n+                    &implementor,\n+                    it,\n+                    assoc_link,\n+                    RenderMode::Normal,\n+                    implementor.impl_item.stable_since(cx.tcx()).as_deref(),\n+                    implementor.impl_item.const_stable_since(cx.tcx()).as_deref(),\n+                    false,\n+                    None,\n+                    true,\n+                    false,\n+                    &[],\n+                );\n+            }\n+            write_loading_content(w, \"\");\n+        }\n+\n+        write_small_section_header(\n+            w,\n+            \"implementors\",\n+            \"Implementors\",\n+            \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n+        );\n+        for implementor in concrete {\n+            render_implementor(cx, implementor, it, w, &implementor_dups, &[]);\n+        }\n+        write_loading_content(w, \"</div>\");\n+\n+        if t.is_auto {\n+            write_small_section_header(\n+                w,\n+                \"synthetic-implementors\",\n+                \"Auto implementors\",\n+                \"<div class=\\\"item-list\\\" id=\\\"synthetic-implementors-list\\\">\",\n+            );\n+            for implementor in synthetic {\n+                render_implementor(\n+                    cx,\n+                    implementor,\n+                    it,\n+                    w,\n+                    &implementor_dups,\n+                    &collect_paths_for_type(implementor.inner_impl().for_.clone(), &cx.cache),\n+                );\n+            }\n+            write_loading_content(w, \"</div>\");\n+        }\n+    } else {\n+        // even without any implementations to write in, we still want the heading and list, so the\n+        // implementors javascript file pulled in below has somewhere to write the impls into\n+        write_small_section_header(\n+            w,\n+            \"implementors\",\n+            \"Implementors\",\n+            \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n+        );\n+        write_loading_content(w, \"</div>\");\n+\n+        if t.is_auto {\n+            write_small_section_header(\n+                w,\n+                \"synthetic-implementors\",\n+                \"Auto implementors\",\n+                \"<div class=\\\"item-list\\\" id=\\\"synthetic-implementors-list\\\">\",\n+            );\n+            write_loading_content(w, \"</div>\");\n+        }\n+    }\n+\n+    write!(\n+        w,\n+        \"<script type=\\\"text/javascript\\\" \\\n+                 src=\\\"{root_path}/implementors/{path}/{ty}.{name}.js\\\" async>\\\n+         </script>\",\n+        root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n+        path = if it.def_id.is_local() {\n+            cx.current.join(\"/\")\n+        } else {\n+            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n+            path[..path.len() - 1].join(\"/\")\n+        },\n+        ty = it.type_(),\n+        name = *it.name.as_ref().unwrap()\n+    );\n+}\n+\n+fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n+    w.write_str(\"<pre class=\\\"rust trait-alias\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"trait {}{}{} = {};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        bounds(&t.bounds, true, cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n+    w.write_str(\"<pre class=\\\"rust opaque\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"type {}{}{where_clause} = impl {bounds};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        bounds = bounds(&t.bounds, false, cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n+    w.write_str(\"<pre class=\\\"rust typedef\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"type {}{}{where_clause} = {type_};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        type_ = t.type_.print(cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust union\\\">\");\n+        render_attributes(w, it, true);\n+        render_union(w, it, Some(&s.generics), &s.fields, \"\", true, cx);\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    let mut fields = s\n+        .fields\n+        .iter()\n+        .filter_map(|f| match *f.kind {\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n+        })\n+        .peekable();\n+    if fields.peek().is_some() {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\n+                   Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\"\n+        );\n+        for (field, ty) in fields {\n+            let name = field.name.as_ref().expect(\"union field name\");\n+            let id = format!(\"{}.{}\", ItemType::StructField, name);\n+            write!(\n+                w,\n+                \"<span id=\\\"{id}\\\" class=\\\"{shortty} small-section-header\\\">\\\n+                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                     <code>{name}: {ty}</code>\\\n+                 </span>\",\n+                id = id,\n+                name = name,\n+                shortty = ItemType::StructField,\n+                ty = ty.print(cx.cache())\n+            );\n+            if let Some(stability_class) = field.stability_class(cx.tcx()) {\n+                write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n+            }\n+            document(w, cx, field, Some(it));\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust enum\\\">\");\n+        render_attributes(w, it, true);\n+        write!(\n+            w,\n+            \"{}enum {}{}{}\",\n+            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            it.name.as_ref().unwrap(),\n+            e.generics.print(cx.cache()),\n+            WhereClause { gens: &e.generics, indent: 0, end_newline: true }.print(cx.cache())\n+        );\n+        if e.variants.is_empty() && !e.variants_stripped {\n+            w.write_str(\" {}\");\n+        } else {\n+            w.write_str(\" {\\n\");\n+            for v in &e.variants {\n+                w.write_str(\"    \");\n+                let name = v.name.as_ref().unwrap();\n+                match *v.kind {\n+                    clean::VariantItem(ref var) => match var {\n+                        clean::Variant::CLike => write!(w, \"{}\", name),\n+                        clean::Variant::Tuple(ref tys) => {\n+                            write!(w, \"{}(\", name);\n+                            for (i, ty) in tys.iter().enumerate() {\n+                                if i > 0 {\n+                                    w.write_str(\",&nbsp;\")\n+                                }\n+                                write!(w, \"{}\", ty.print(cx.cache()));\n+                            }\n+                            w.write_str(\")\");\n+                        }\n+                        clean::Variant::Struct(ref s) => {\n+                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n+                        }\n+                    },\n+                    _ => unreachable!(),\n+                }\n+                w.write_str(\",\\n\");\n+            }\n+\n+            if e.variants_stripped {\n+                w.write_str(\"    // some variants omitted\\n\");\n+            }\n+            w.write_str(\"}\");\n+        }\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    if !e.variants.is_empty() {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"variants\\\" class=\\\"variants small-section-header\\\">\n+                   Variants{}<a href=\\\"#variants\\\" class=\\\"anchor\\\"></a></h2>\\n\",\n+            document_non_exhaustive_header(it)\n+        );\n+        document_non_exhaustive(w, it);\n+        for variant in &e.variants {\n+            let id =\n+                cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.as_ref().unwrap()));\n+            write!(\n+                w,\n+                \"<div id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                    <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                    <code>{name}\",\n+                id = id,\n+                name = variant.name.as_ref().unwrap()\n+            );\n+            if let clean::VariantItem(clean::Variant::Tuple(ref tys)) = *variant.kind {\n+                w.write_str(\"(\");\n+                for (i, ty) in tys.iter().enumerate() {\n+                    if i > 0 {\n+                        w.write_str(\",&nbsp;\");\n+                    }\n+                    write!(w, \"{}\", ty.print(cx.cache()));\n+                }\n+                w.write_str(\")\");\n+            }\n+            w.write_str(\"</code></div>\");\n+            document(w, cx, variant, Some(it));\n+            document_non_exhaustive(w, variant);\n+\n+            use crate::clean::Variant;\n+            if let clean::VariantItem(Variant::Struct(ref s)) = *variant.kind {\n+                let variant_id = cx.derive_id(format!(\n+                    \"{}.{}.fields\",\n+                    ItemType::Variant,\n+                    variant.name.as_ref().unwrap()\n+                ));\n+                write!(w, \"<div class=\\\"autohide sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n+                write!(\n+                    w,\n+                    \"<h3>Fields of <b>{name}</b></h3><div>\",\n+                    name = variant.name.as_ref().unwrap()\n+                );\n+                for field in &s.fields {\n+                    use crate::clean::StructFieldItem;\n+                    if let StructFieldItem(ref ty) = *field.kind {\n+                        let id = cx.derive_id(format!(\n+                            \"variant.{}.field.{}\",\n+                            variant.name.as_ref().unwrap(),\n+                            field.name.as_ref().unwrap()\n+                        ));\n+                        write!(\n+                            w,\n+                            \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                                 <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                                 <code>{f}:&nbsp;{t}</code>\\\n+                             </span>\",\n+                            id = id,\n+                            f = field.name.as_ref().unwrap(),\n+                            t = ty.print(cx.cache())\n+                        );\n+                        document(w, cx, field, Some(variant));\n+                    }\n+                }\n+                w.write_str(\"</div></div>\");\n+            }\n+            render_stability_since(w, variant, it, cx.tcx());\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Macro) {\n+    wrap_into_docblock(w, |w| {\n+        highlight::render_with_highlighting(\n+            &t.source,\n+            w,\n+            Some(\"macro\"),\n+            None,\n+            None,\n+            it.source.span().edition(),\n+        );\n+    });\n+    document(w, cx, it, None)\n+}\n+\n+fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n+    let name = it.name.as_ref().expect(\"proc-macros always have names\");\n+    match m.kind {\n+        MacroKind::Bang => {\n+            w.push_str(\"<pre class=\\\"rust macro\\\">\");\n+            write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n+            w.push_str(\"</pre>\");\n+        }\n+        MacroKind::Attr => {\n+            w.push_str(\"<pre class=\\\"rust attr\\\">\");\n+            write!(w, \"#[{}]\", name);\n+            w.push_str(\"</pre>\");\n+        }\n+        MacroKind::Derive => {\n+            w.push_str(\"<pre class=\\\"rust derive\\\">\");\n+            write!(w, \"#[derive({})]\", name);\n+            if !m.helpers.is_empty() {\n+                w.push_str(\"\\n{\\n\");\n+                w.push_str(\"    // Attributes available to this derive:\\n\");\n+                for attr in &m.helpers {\n+                    writeln!(w, \"    #[{}]\", attr);\n+                }\n+                w.push_str(\"}\\n\");\n+            }\n+            w.push_str(\"</pre>\");\n+        }\n+    }\n+    document(w, cx, it, None)\n+}\n+\n+fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    document(w, cx, it, None);\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n+    w.write_str(\"<pre class=\\\"rust const\\\">\");\n+    render_attributes(w, it, false);\n+\n+    write!(\n+        w,\n+        \"{vis}const {name}: {typ}\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        name = it.name.as_ref().unwrap(),\n+        typ = c.type_.print(cx.cache()),\n+    );\n+\n+    if c.value.is_some() || c.is_literal {\n+        write!(w, \" = {expr};\", expr = Escape(&c.expr));\n+    } else {\n+        w.write_str(\";\");\n+    }\n+\n+    if let Some(value) = &c.value {\n+        if !c.is_literal {\n+            let value_lowercase = value.to_lowercase();\n+            let expr_lowercase = c.expr.to_lowercase();\n+\n+            if value_lowercase != expr_lowercase\n+                && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n+            {\n+                write!(w, \" // {value}\", value = Escape(value));\n+            }\n+        }\n+    }\n+\n+    w.write_str(\"</pre>\");\n+    document(w, cx, it, None)\n+}\n+\n+fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust struct\\\">\");\n+        render_attributes(w, it, true);\n+        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    let mut fields = s\n+        .fields\n+        .iter()\n+        .filter_map(|f| match *f.kind {\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n+        })\n+        .peekable();\n+    if let CtorKind::Fictive = s.struct_type {\n+        if fields.peek().is_some() {\n+            write!(\n+                w,\n+                \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\n+                       Fields{}<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\",\n+                document_non_exhaustive_header(it)\n+            );\n+            document_non_exhaustive(w, it);\n+            for (field, ty) in fields {\n+                let id = cx.derive_id(format!(\n+                    \"{}.{}\",\n+                    ItemType::StructField,\n+                    field.name.as_ref().unwrap()\n+                ));\n+                write!(\n+                    w,\n+                    \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\\\n+                         <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                         <code>{name}: {ty}</code>\\\n+                     </span>\",\n+                    item_type = ItemType::StructField,\n+                    id = id,\n+                    name = field.name.as_ref().unwrap(),\n+                    ty = ty.print(cx.cache())\n+                );\n+                document(w, cx, field, Some(it));\n+            }\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n+    w.write_str(\"<pre class=\\\"rust static\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"{vis}static {mutability}{name}: {typ}</pre>\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        mutability = s.mutability.print_with_space(),\n+        name = it.name.as_ref().unwrap(),\n+        typ = s.type_.print(cx.cache())\n+    );\n+    document(w, cx, it, None)\n+}\n+\n+fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    w.write_str(\"<pre class=\\\"rust foreigntype\\\">extern {\\n\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"    {}type {};\\n}}</pre>\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.name.as_ref().unwrap(),\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    document(w, cx, it, None)\n+}\n+\n+/// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n+crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+    /// Takes a non-numeric and a numeric part from the given &str.\n+    fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n+        let i = s.find(|c: char| c.is_ascii_digit());\n+        let (a, b) = s.split_at(i.unwrap_or(s.len()));\n+        let i = b.find(|c: char| !c.is_ascii_digit());\n+        let (b, c) = b.split_at(i.unwrap_or(b.len()));\n+        *s = c;\n+        (a, b)\n+    }\n+\n+    while !lhs.is_empty() || !rhs.is_empty() {\n+        let (la, lb) = take_parts(&mut lhs);\n+        let (ra, rb) = take_parts(&mut rhs);\n+        // First process the non-numeric part.\n+        match la.cmp(ra) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+        // Then process the numeric part, if both sides have one (and they fit in a u64).\n+        if let (Ok(ln), Ok(rn)) = (lb.parse::<u64>(), rb.parse::<u64>()) {\n+            match ln.cmp(&rn) {\n+                Ordering::Equal => (),\n+                x => return x,\n+            }\n+        }\n+        // Then process the numeric part again, but this time as strings.\n+        match lb.cmp(rb) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+    }\n+\n+    Ordering::Equal\n+}\n+\n+pub(super) fn full_path(cx: &Context<'_>, item: &clean::Item) -> String {\n+    let mut s = cx.current.join(\"::\");\n+    s.push_str(\"::\");\n+    s.push_str(&item.name.unwrap().as_str());\n+    s\n+}\n+\n+pub(super) fn item_path(ty: ItemType, name: &str) -> String {\n+    match ty {\n+        ItemType::Module => format!(\"{}index.html\", ensure_trailing_slash(name)),\n+        _ => format!(\"{}.{}.html\", ty, name),\n+    }\n+}\n+\n+fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cache: &Cache) -> String {\n+    let mut bounds = String::new();\n+    if !t_bounds.is_empty() {\n+        if !trait_alias {\n+            bounds.push_str(\": \");\n+        }\n+        for (i, p) in t_bounds.iter().enumerate() {\n+            if i > 0 {\n+                bounds.push_str(\" + \");\n+            }\n+            bounds.push_str(&p.print(cache).to_string());\n+        }\n+    }\n+    bounds\n+}\n+\n+fn wrap_into_docblock<F>(w: &mut Buffer, f: F)\n+where\n+    F: FnOnce(&mut Buffer),\n+{\n+    w.write_str(\"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\");\n+    f(w);\n+    w.write_str(\"</div>\")\n+}\n+\n+fn render_stability_since(\n+    w: &mut Buffer,\n+    item: &clean::Item,\n+    containing_item: &clean::Item,\n+    tcx: TyCtxt<'_>,\n+) {\n+    render_stability_since_raw(\n+        w,\n+        item.stable_since(tcx).as_deref(),\n+        item.const_stable_since(tcx).as_deref(),\n+        containing_item.stable_since(tcx).as_deref(),\n+        containing_item.const_stable_since(tcx).as_deref(),\n+    )\n+}\n+\n+fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cache: &Cache) -> Ordering {\n+    let lhs = format!(\"{}\", lhs.inner_impl().print(cache, false));\n+    let rhs = format!(\"{}\", rhs.inner_impl().print(cache, false));\n+\n+    // lhs and rhs are formatted as HTML, which may be unnecessary\n+    compare_names(&lhs, &rhs)\n+}\n+\n+fn render_implementor(\n+    cx: &Context<'_>,\n+    implementor: &Impl,\n+    trait_: &clean::Item,\n+    w: &mut Buffer,\n+    implementor_dups: &FxHashMap<Symbol, (DefId, bool)>,\n+    aliases: &[String],\n+) {\n+    // If there's already another implementor that has the same abbridged name, use the\n+    // full path, for example in `std::iter::ExactSizeIterator`\n+    let use_absolute = match implementor.inner_impl().for_ {\n+        clean::ResolvedPath { ref path, is_generic: false, .. }\n+        | clean::BorrowedRef {\n+            type_: box clean::ResolvedPath { ref path, is_generic: false, .. },\n+            ..\n+        } => implementor_dups[&path.last()].1,\n+        _ => false,\n+    };\n+    render_impl(\n+        w,\n+        cx,\n+        implementor,\n+        trait_,\n+        AssocItemLink::Anchor(None),\n+        RenderMode::Normal,\n+        trait_.stable_since(cx.tcx()).as_deref(),\n+        trait_.const_stable_since(cx.tcx()).as_deref(),\n+        false,\n+        Some(use_absolute),\n+        false,\n+        false,\n+        aliases,\n+    );\n+}\n+\n+fn render_union(\n+    w: &mut Buffer,\n+    it: &clean::Item,\n+    g: Option<&clean::Generics>,\n+    fields: &[clean::Item],\n+    tab: &str,\n+    structhead: bool,\n+    cx: &Context<'_>,\n+) {\n+    write!(\n+        w,\n+        \"{}{}{}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        if structhead { \"union \" } else { \"\" },\n+        it.name.as_ref().unwrap()\n+    );\n+    if let Some(g) = g {\n+        write!(w, \"{}\", g.print(cx.cache()));\n+        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache()));\n+    }\n+\n+    write!(w, \" {{\\n{}\", tab);\n+    for field in fields {\n+        if let clean::StructFieldItem(ref ty) = *field.kind {\n+            write!(\n+                w,\n+                \"    {}{}: {},\\n{}\",\n+                field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                field.name.as_ref().unwrap(),\n+                ty.print(cx.cache()),\n+                tab\n+            );\n+        }\n+    }\n+\n+    if it.has_stripped_fields().unwrap() {\n+        write!(w, \"    // some fields omitted\\n{}\", tab);\n+    }\n+    w.write_str(\"}\");\n+}\n+\n+fn render_struct(\n+    w: &mut Buffer,\n+    it: &clean::Item,\n+    g: Option<&clean::Generics>,\n+    ty: CtorKind,\n+    fields: &[clean::Item],\n+    tab: &str,\n+    structhead: bool,\n+    cx: &Context<'_>,\n+) {\n+    write!(\n+        w,\n+        \"{}{}{}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        if structhead { \"struct \" } else { \"\" },\n+        it.name.as_ref().unwrap()\n+    );\n+    if let Some(g) = g {\n+        write!(w, \"{}\", g.print(cx.cache()))\n+    }\n+    match ty {\n+        CtorKind::Fictive => {\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache())\n+                )\n+            }\n+            let mut has_visible_fields = false;\n+            w.write_str(\" {\");\n+            for field in fields {\n+                if let clean::StructFieldItem(ref ty) = *field.kind {\n+                    write!(\n+                        w,\n+                        \"\\n{}    {}{}: {},\",\n+                        tab,\n+                        field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                        field.name.as_ref().unwrap(),\n+                        ty.print(cx.cache())\n+                    );\n+                    has_visible_fields = true;\n+                }\n+            }\n+\n+            if has_visible_fields {\n+                if it.has_stripped_fields().unwrap() {\n+                    write!(w, \"\\n{}    // some fields omitted\", tab);\n+                }\n+                write!(w, \"\\n{}\", tab);\n+            } else if it.has_stripped_fields().unwrap() {\n+                // If there are no visible fields we can just display\n+                // `{ /* fields omitted */ }` to save space.\n+                write!(w, \" /* fields omitted */ \");\n+            }\n+            w.write_str(\"}\");\n+        }\n+        CtorKind::Fn => {\n+            w.write_str(\"(\");\n+            for (i, field) in fields.iter().enumerate() {\n+                if i > 0 {\n+                    w.write_str(\", \");\n+                }\n+                match *field.kind {\n+                    clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n+                    clean::StructFieldItem(ref ty) => {\n+                        write!(\n+                            w,\n+                            \"{}{}\",\n+                            field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                            ty.print(cx.cache())\n+                        )\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+            w.write_str(\")\");\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n+                )\n+            }\n+            w.write_str(\";\");\n+        }\n+        CtorKind::Const => {\n+            // Needed for PhantomData.\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n+                )\n+            }\n+            w.write_str(\";\");\n+        }\n+    }\n+}\n+\n+fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n+    if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n+}\n+\n+fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n+    if item.is_non_exhaustive() {\n+        write!(w, \"<div class=\\\"docblock non-exhaustive non-exhaustive-{}\\\">\", {\n+            if item.is_struct() {\n+                \"struct\"\n+            } else if item.is_enum() {\n+                \"enum\"\n+            } else if item.is_variant() {\n+                \"variant\"\n+            } else {\n+                \"type\"\n+            }\n+        });\n+\n+        if item.is_struct() {\n+            w.write_str(\n+                \"Non-exhaustive structs could have additional fields added in future. \\\n+                 Therefore, non-exhaustive structs cannot be constructed in external crates \\\n+                 using the traditional <code>Struct {{ .. }}</code> syntax; cannot be \\\n+                 matched against without a wildcard <code>..</code>; and \\\n+                 struct update syntax will not work.\",\n+            );\n+        } else if item.is_enum() {\n+            w.write_str(\n+                \"Non-exhaustive enums could have additional variants added in future. \\\n+                 Therefore, when matching against variants of non-exhaustive enums, an \\\n+                 extra wildcard arm must be added to account for any future variants.\",\n+            );\n+        } else if item.is_variant() {\n+            w.write_str(\n+                \"Non-exhaustive enum variants could have additional fields added in future. \\\n+                 Therefore, non-exhaustive enum variants cannot be constructed in external \\\n+                 crates and cannot be matched against.\",\n+            );\n+        } else {\n+            w.write_str(\n+                \"This type will require a wildcard arm in any match statements or constructors.\",\n+            );\n+        }\n+\n+        w.write_str(\"</div>\");\n+    }\n+}"}]}