{"sha": "e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "node_id": "C_kwDOAAsO6NoAKGU4ZWUwYjdiMmI5ZjAwNGM1MWY3YTEwZWVmZjBmYmZlNzlhZjI4ZDg", "commit": {"author": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2022-08-20T16:49:20Z"}, "committer": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2022-08-20T16:49:20Z"}, "message": "Expose `Utf8Lossy` as `Utf8Chunks`", "tree": {"sha": "4ef797f37187cda4f605124c1d085854ccc7729c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ef797f37187cda4f605124c1d085854ccc7729c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "html_url": "https://github.com/rust-lang/rust/commit/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/comments", "author": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be9cfb307e6928600a9769695e02d6296e8e1174", "url": "https://api.github.com/repos/rust-lang/rust/commits/be9cfb307e6928600a9769695e02d6296e8e1174", "html_url": "https://github.com/rust-lang/rust/commit/be9cfb307e6928600a9769695e02d6296e8e1174"}], "stats": {"total": 457, "additions": 273, "deletions": 184}, "files": [{"sha": "dfff2fb691ba7bca4ca6dd4bb23ddcc3d9ead090", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -141,6 +141,7 @@\n #![feature(unchecked_math)]\n #![feature(unicode_internals)]\n #![feature(unsize)]\n+#![feature(utf8_chunks)]\n #![feature(std_internals)]\n //\n // Language features:"}, {"sha": "b94b1b1ce216a0630d402bfc97c65816fb5cca46", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -71,6 +71,8 @@ pub use core::str::{RSplit, Split};\n pub use core::str::{RSplitN, SplitN};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{RSplitTerminator, SplitTerminator};\n+#[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+pub use core::str::{Utf8Chunk, Utf8Chunks};\n \n /// Note: `str` in `Concat<str>` is not meaningful here.\n /// This type parameter of the trait only exists to enable another impl."}, {"sha": "8eb030369a1973beacc1e35156bab45a5b53e64a", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -58,9 +58,9 @@ use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n use core::ptr;\n use core::slice;\n-#[cfg(not(no_global_oom_handling))]\n-use core::str::lossy;\n use core::str::pattern::Pattern;\n+#[cfg(not(no_global_oom_handling))]\n+use core::str::Utf8Chunks;\n \n #[cfg(not(no_global_oom_handling))]\n use crate::borrow::{Cow, ToOwned};\n@@ -628,11 +628,11 @@ impl String {\n     #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy(v: &[u8]) -> Cow<'_, str> {\n-        let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n+        let mut iter = Utf8Chunks::new(v);\n \n         let first_valid = if let Some(chunk) = iter.next() {\n-            let lossy::Utf8LossyChunk { valid, broken } = chunk;\n-            if broken.is_empty() {\n+            let valid = chunk.valid();\n+            if chunk.invalid().is_empty() {\n                 debug_assert_eq!(valid.len(), v.len());\n                 return Cow::Borrowed(valid);\n             }\n@@ -647,9 +647,9 @@ impl String {\n         res.push_str(first_valid);\n         res.push_str(REPLACEMENT);\n \n-        for lossy::Utf8LossyChunk { valid, broken } in iter {\n-            res.push_str(valid);\n-            if !broken.is_empty() {\n+        for chunk in iter {\n+            res.push_str(chunk.valid());\n+            if !chunk.invalid().is_empty() {\n                 res.push_str(REPLACEMENT);\n             }\n         }"}, {"sha": "59f873d1268ce0cb1defb4de89a773c9062b0aeb", "filename": "library/core/src/str/lossy.rs", "status": "modified", "additions": 157, "deletions": 87, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -1,51 +1,170 @@\n-use crate::char;\n-use crate::fmt::{self, Write};\n-use crate::mem;\n+use crate::fmt;\n+use crate::fmt::Formatter;\n+use crate::fmt::Write;\n+use crate::iter::FusedIterator;\n \n use super::from_utf8_unchecked;\n use super::validations::utf8_char_width;\n \n-/// Lossy UTF-8 string.\n-#[unstable(feature = \"str_internals\", issue = \"none\")]\n-pub struct Utf8Lossy {\n-    bytes: [u8],\n+/// An item returned by the [`Utf8Chunks`] iterator.\n+///\n+/// A `Utf8Chunk` stores a sequence of [`u8`] up to the first broken character\n+/// when decoding a UTF-8 string.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(utf8_chunks)]\n+///\n+/// use std::str::Utf8Chunks;\n+///\n+/// // An invalid UTF-8 string\n+/// let bytes = b\"foo\\xF1\\x80bar\";\n+///\n+/// // Decode the first `Utf8Chunk`\n+/// let chunk = Utf8Chunks::new(bytes).next().unwrap();\n+///\n+/// // The first three characters are valid UTF-8\n+/// assert_eq!(\"foo\", chunk.valid());\n+///\n+/// // The fourth character is broken\n+/// assert_eq!(b\"\\xF1\\x80\", chunk.invalid());\n+/// ```\n+#[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct Utf8Chunk<'a> {\n+    valid: &'a str,\n+    invalid: &'a [u8],\n }\n \n-impl Utf8Lossy {\n+impl<'a> Utf8Chunk<'a> {\n+    /// Returns the next validated UTF-8 substring.\n+    ///\n+    /// This substring can be empty at the start of the string or between\n+    /// broken UTF-8 characters.\n     #[must_use]\n-    pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n-        // SAFETY: Both use the same memory layout, and UTF-8 correctness isn't required.\n-        unsafe { mem::transmute(bytes) }\n+    #[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+    pub fn valid(&self) -> &'a str {\n+        self.valid\n     }\n \n-    pub fn chunks(&self) -> Utf8LossyChunksIter<'_> {\n-        Utf8LossyChunksIter { source: &self.bytes }\n+    /// Returns the invalid sequence that caused a failure.\n+    ///\n+    /// The returned slice will have a maximum length of 3 and starts after the\n+    /// substring given by [`valid`]. Decoding will resume after this sequence.\n+    ///\n+    /// If empty, this is the last chunk in the string. If non-empty, an\n+    /// unexpected byte was encountered or the end of the input was reached\n+    /// unexpectedly.\n+    ///\n+    /// Lossy decoding would replace this sequence with [`U+FFFD REPLACEMENT\n+    /// CHARACTER`].\n+    ///\n+    /// [`valid`]: Self::valid\n+    /// [`U+FFFD REPLACEMENT CHARACTER`]: crate::char::REPLACEMENT_CHARACTER\n+    #[must_use]\n+    #[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+    pub fn invalid(&self) -> &'a [u8] {\n+        self.invalid\n     }\n }\n \n-/// Iterator over lossy UTF-8 string\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[must_use]\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+pub struct Debug<'a>(&'a [u8]);\n+\n #[unstable(feature = \"str_internals\", issue = \"none\")]\n-#[allow(missing_debug_implementations)]\n-pub struct Utf8LossyChunksIter<'a> {\n+impl fmt::Debug for Debug<'_> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        f.write_char('\"')?;\n+\n+        for chunk in Utf8Chunks::new(self.0) {\n+            // Valid part.\n+            // Here we partially parse UTF-8 again which is suboptimal.\n+            {\n+                let valid = chunk.valid();\n+                let mut from = 0;\n+                for (i, c) in valid.char_indices() {\n+                    let esc = c.escape_debug();\n+                    // If char needs escaping, flush backlog so far and write, else skip\n+                    if esc.len() != 1 {\n+                        f.write_str(&valid[from..i])?;\n+                        for c in esc {\n+                            f.write_char(c)?;\n+                        }\n+                        from = i + c.len_utf8();\n+                    }\n+                }\n+                f.write_str(&valid[from..])?;\n+            }\n+\n+            // Broken parts of string as hex escape.\n+            for &b in chunk.invalid() {\n+                write!(f, \"\\\\x{:02X}\", b)?;\n+            }\n+        }\n+\n+        f.write_char('\"')\n+    }\n+}\n+\n+/// An iterator used to decode a slice of mostly UTF-8 bytes to string slices\n+/// ([`&str`]) and byte slices ([`&[u8]`][byteslice]).\n+///\n+/// If you want a simple conversion from UTF-8 byte slices to string slices,\n+/// [`from_utf8`] is easier to use.\n+///\n+/// [byteslice]: slice\n+/// [`from_utf8`]: super::from_utf8\n+///\n+/// # Examples\n+///\n+/// This can be used to create functionality similar to\n+/// [`String::from_utf8_lossy`] without allocating heap memory:\n+///\n+/// ```\n+/// #![feature(utf8_chunks)]\n+///\n+/// use std::str::Utf8Chunks;\n+///\n+/// fn from_utf8_lossy<F>(input: &[u8], mut push: F) where F: FnMut(&str) {\n+///     for chunk in Utf8Chunks::new(input) {\n+///         push(chunk.valid());\n+///\n+///         if !chunk.invalid().is_empty() {\n+///             push(\"\\u{FFFD}\");\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`String::from_utf8_lossy`]: ../../std/string/struct.String.html#method.from_utf8_lossy\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+#[derive(Clone)]\n+pub struct Utf8Chunks<'a> {\n     source: &'a [u8],\n }\n \n-#[unstable(feature = \"str_internals\", issue = \"none\")]\n-#[derive(PartialEq, Eq, Debug)]\n-pub struct Utf8LossyChunk<'a> {\n-    /// Sequence of valid chars.\n-    /// Can be empty between broken UTF-8 chars.\n-    pub valid: &'a str,\n-    /// Single broken char, empty if none.\n-    /// Empty iff iterator item is last.\n-    pub broken: &'a [u8],\n+impl<'a> Utf8Chunks<'a> {\n+    /// Creates a new iterator to decode the bytes.\n+    #[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+    pub fn new(bytes: &'a [u8]) -> Self {\n+        Self { source: bytes }\n+    }\n+\n+    #[doc(hidden)]\n+    #[unstable(feature = \"str_internals\", issue = \"none\")]\n+    pub fn debug(&self) -> Debug<'_> {\n+        Debug(self.source)\n+    }\n }\n \n-impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n-    type Item = Utf8LossyChunk<'a>;\n+#[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+impl<'a> Iterator for Utf8Chunks<'a> {\n+    type Item = Utf8Chunk<'a>;\n \n-    fn next(&mut self) -> Option<Utf8LossyChunk<'a>> {\n+    fn next(&mut self) -> Option<Utf8Chunk<'a>> {\n         if self.source.is_empty() {\n             return None;\n         }\n@@ -130,71 +249,22 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n         // SAFETY: `valid_up_to <= i` because it is only ever assigned via\n         // `valid_up_to = i` and `i` only increases.\n-        let (valid, broken) = unsafe { inspected.split_at_unchecked(valid_up_to) };\n+        let (valid, invalid) = unsafe { inspected.split_at_unchecked(valid_up_to) };\n \n-        Some(Utf8LossyChunk {\n+        Some(Utf8Chunk {\n             // SAFETY: All bytes up to `valid_up_to` are valid UTF-8.\n             valid: unsafe { from_utf8_unchecked(valid) },\n-            broken,\n+            invalid,\n         })\n     }\n }\n \n-impl fmt::Display for Utf8Lossy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If we're the empty string then our iterator won't actually yield\n-        // anything, so perform the formatting manually\n-        if self.bytes.is_empty() {\n-            return \"\".fmt(f);\n-        }\n-\n-        for Utf8LossyChunk { valid, broken } in self.chunks() {\n-            // If we successfully decoded the whole chunk as a valid string then\n-            // we can return a direct formatting of the string which will also\n-            // respect various formatting flags if possible.\n-            if valid.len() == self.bytes.len() {\n-                assert!(broken.is_empty());\n-                return valid.fmt(f);\n-            }\n-\n-            f.write_str(valid)?;\n-            if !broken.is_empty() {\n-                f.write_char(char::REPLACEMENT_CHARACTER)?;\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl fmt::Debug for Utf8Lossy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_char('\"')?;\n+#[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+impl FusedIterator for Utf8Chunks<'_> {}\n \n-        for Utf8LossyChunk { valid, broken } in self.chunks() {\n-            // Valid part.\n-            // Here we partially parse UTF-8 again which is suboptimal.\n-            {\n-                let mut from = 0;\n-                for (i, c) in valid.char_indices() {\n-                    let esc = c.escape_debug();\n-                    // If char needs escaping, flush backlog so far and write, else skip\n-                    if esc.len() != 1 {\n-                        f.write_str(&valid[from..i])?;\n-                        for c in esc {\n-                            f.write_char(c)?;\n-                        }\n-                        from = i + c.len_utf8();\n-                    }\n-                }\n-                f.write_str(&valid[from..])?;\n-            }\n-\n-            // Broken parts of string as hex escape.\n-            for &b in broken {\n-                write!(f, \"\\\\x{:02x}\", b)?;\n-            }\n-        }\n-\n-        f.write_char('\"')\n+#[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+impl fmt::Debug for Utf8Chunks<'_> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Utf8Chunks\").field(\"source\", &self.debug()).finish()\n     }\n }"}, {"sha": "5723188db69a1bdeaafd15ff29f72585a5598638", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -22,9 +22,9 @@ use crate::slice::{self, SliceIndex};\n \n pub mod pattern;\n \n-#[unstable(feature = \"str_internals\", issue = \"none\")]\n-#[allow(missing_docs)]\n-pub mod lossy;\n+mod lossy;\n+#[unstable(feature = \"utf8_chunks\", issue = \"99543\")]\n+pub use lossy::{Utf8Chunk, Utf8Chunks};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use converts::{from_utf8, from_utf8_unchecked};"}, {"sha": "68dc8a87c7673e51aa16a10d9fc98d6571e9435e", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -96,6 +96,7 @@\n #![feature(waker_getters)]\n #![feature(slice_flatten)]\n #![feature(provide_any)]\n+#![feature(utf8_chunks)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}, {"sha": "9d3f0b65fdb942749795781a30b9c991a61b79f6", "filename": "library/core/tests/str_lossy.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fcore%2Ftests%2Fstr_lossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fcore%2Ftests%2Fstr_lossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fstr_lossy.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -1,85 +1,85 @@\n-use core::str::lossy::*;\n+use core::str::Utf8Chunks;\n \n #[test]\n fn chunks() {\n-    let mut iter = Utf8Lossy::from_bytes(b\"hello\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"hello\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n+    macro_rules! assert_chunks {\n+        ( $string:expr, $(($valid:expr, $invalid:expr)),* $(,)? ) => {{\n+            let mut iter = Utf8Chunks::new($string);\n+            $(\n+                let chunk = iter.next().expect(\"missing chunk\");\n+                assert_eq!($valid, chunk.valid());\n+                assert_eq!($invalid, chunk.invalid());\n+            )*\n+            assert_eq!(None, iter.next());\n+        }};\n+    }\n \n-    let mut iter = Utf8Lossy::from_bytes(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes()).chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n-\n-    let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC2 There\\xFF Goodbye\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC2\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xFF\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n-\n-    let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC0\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xE6\\x83\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n-\n-    let mut iter = Utf8Lossy::from_bytes(b\"\\xF5foo\\xF5\\x80bar\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF5\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF5\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n-\n-    let mut iter = Utf8Lossy::from_bytes(b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF1\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF1\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF1\\x80\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n-\n-    let mut iter = Utf8Lossy::from_bytes(b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF4\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF4\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF4\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n-\n-    let mut iter = Utf8Lossy::from_bytes(b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF0\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\\u{10000}bar\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n+    assert_chunks!(b\"hello\", (\"hello\", b\"\"));\n+    assert_chunks!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), (\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", b\"\"));\n+    assert_chunks!(\n+        b\"Hello\\xC2 There\\xFF Goodbye\",\n+        (\"Hello\", b\"\\xC2\"),\n+        (\" There\", b\"\\xFF\"),\n+        (\" Goodbye\", b\"\"),\n+    );\n+    assert_chunks!(\n+        b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\",\n+        (\"Hello\", b\"\\xC0\"),\n+        (\"\", b\"\\x80\"),\n+        (\" There\", b\"\\xE6\\x83\"),\n+        (\" Goodbye\", b\"\"),\n+    );\n+    assert_chunks!(\n+        b\"\\xF5foo\\xF5\\x80bar\",\n+        (\"\", b\"\\xF5\"),\n+        (\"foo\", b\"\\xF5\"),\n+        (\"\", b\"\\x80\"),\n+        (\"bar\", b\"\"),\n+    );\n+    assert_chunks!(\n+        b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\",\n+        (\"\", b\"\\xF1\"),\n+        (\"foo\", b\"\\xF1\\x80\"),\n+        (\"bar\", b\"\\xF1\\x80\\x80\"),\n+        (\"baz\", b\"\"),\n+    );\n+    assert_chunks!(\n+        b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\",\n+        (\"\", b\"\\xF4\"),\n+        (\"foo\", b\"\\xF4\\x80\"),\n+        (\"bar\", b\"\\xF4\"),\n+        (\"\", b\"\\xBF\"),\n+        (\"baz\", b\"\"),\n+    );\n+    assert_chunks!(\n+        b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\",\n+        (\"\", b\"\\xF0\"),\n+        (\"\", b\"\\x80\"),\n+        (\"\", b\"\\x80\"),\n+        (\"\", b\"\\x80\"),\n+        (\"foo\\u{10000}bar\", b\"\"),\n+    );\n \n     // surrogates\n-    let mut iter = Utf8Lossy::from_bytes(b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\").chunks();\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xED\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xA0\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xED\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n-    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\" }), iter.next());\n-    assert_eq!(None, iter.next());\n-}\n-\n-#[test]\n-fn display() {\n-    assert_eq!(\n-        \"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\",\n-        &Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string()\n+    assert_chunks!(\n+        b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\",\n+        (\"\", b\"\\xED\"),\n+        (\"\", b\"\\xA0\"),\n+        (\"\", b\"\\x80\"),\n+        (\"foo\", b\"\\xED\"),\n+        (\"\", b\"\\xBF\"),\n+        (\"\", b\"\\xBF\"),\n+        (\"bar\", b\"\"),\n     );\n }\n \n #[test]\n fn debug() {\n     assert_eq!(\n-        \"\\\"Hello\\\\xc0\\\\x80 There\\\\xe6\\\\x83 Goodbye\\\\u{10d4ea}\\\"\",\n+        \"\\\"Hello\\\\xC0\\\\x80 There\\\\xE6\\\\x83 Goodbye\\\\u{10d4ea}\\\"\",\n         &format!(\n             \"{:?}\",\n-            Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\\xf4\\x8d\\x93\\xaa\")\n-        )\n+            Utf8Chunks::new(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\\xf4\\x8d\\x93\\xaa\").debug(),\n+        ),\n     );\n }"}, {"sha": "773fbf125823d031332abbc7fc1a949e730485c1", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -258,6 +258,7 @@\n #![feature(staged_api)]\n #![feature(thread_local)]\n #![feature(try_blocks)]\n+#![feature(utf8_chunks)]\n //\n // Library features (core):\n #![feature(array_error_internals)]"}, {"sha": "017e2af29d4f4c0936801876706dc54373925610", "filename": "library/std/src/sys/unix/os_str.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -11,7 +11,7 @@ use crate::str;\n use crate::sync::Arc;\n use crate::sys_common::{AsInner, IntoInner};\n \n-use core::str::lossy::{Utf8Lossy, Utf8LossyChunk};\n+use core::str::Utf8Chunks;\n \n #[cfg(test)]\n #[path = \"../unix/os_str/tests.rs\"]\n@@ -29,26 +29,32 @@ pub struct Slice {\n }\n \n impl fmt::Debug for Slice {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Writes out a valid unicode string with the correct escape sequences\n-\n-        formatter.write_str(\"\\\"\")?;\n-        for Utf8LossyChunk { valid, broken } in Utf8Lossy::from_bytes(&self.inner).chunks() {\n-            for c in valid.chars().flat_map(|c| c.escape_debug()) {\n-                formatter.write_char(c)?\n-            }\n-\n-            for b in broken {\n-                write!(formatter, \"\\\\x{:02X}\", b)?;\n-            }\n-        }\n-        formatter.write_str(\"\\\"\")\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&Utf8Chunks::new(&self.inner).debug(), f)\n     }\n }\n \n impl fmt::Display for Slice {\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If we're the empty string then our iterator won't actually yield\n+        // anything, so perform the formatting manually\n+        if self.inner.is_empty() {\n+            return \"\".fmt(f);\n+        }\n+\n+        for chunk in Utf8Chunks::new(&self.inner) {\n+            let valid = chunk.valid();\n+            // If we successfully decoded the whole chunk as a valid string then\n+            // we can return a direct formatting of the string which will also\n+            // respect various formatting flags if possible.\n+            if chunk.invalid().is_empty() {\n+                return valid.fmt(f);\n+            }\n+\n+            f.write_str(valid)?;\n+            f.write_char(char::REPLACEMENT_CHARACTER)?;\n+        }\n+        Ok(())\n     }\n }\n "}, {"sha": "22ba0c9235041fad2281af728d872f1eb184136d", "filename": "library/std/src/sys/unix/os_str/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs?ref=e8ee0b7b2b9f004c51f7a10eeff0fbfe79af28d8", "patch": "@@ -8,3 +8,11 @@ fn slice_debug_output() {\n \n     assert_eq!(output, expected);\n }\n+\n+#[test]\n+fn display() {\n+    assert_eq!(\n+        \"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\",\n+        Slice::from_u8_slice(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string(),\n+    );\n+}"}]}