{"sha": "6bba4158cb8938af6e9b128c2c01b15415d502ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYmE0MTU4Y2I4OTM4YWY2ZTliMTI4YzJjMDFiMTU0MTVkNTAyYWQ=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-15T02:47:33Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-30T08:10:23Z"}, "message": "Switch to pulldown-cmark, tidy imports", "tree": {"sha": "cf8fc40c791e3f7259e4a6b7cafacb433b56552f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf8fc40c791e3f7259e4a6b7cafacb433b56552f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bba4158cb8938af6e9b128c2c01b15415d502ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bba4158cb8938af6e9b128c2c01b15415d502ad", "html_url": "https://github.com/rust-lang/rust/commit/6bba4158cb8938af6e9b128c2c01b15415d502ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bba4158cb8938af6e9b128c2c01b15415d502ad/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d6f291335c58aac95c1124f55d7fb0834baff2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6f291335c58aac95c1124f55d7fb0834baff2a", "html_url": "https://github.com/rust-lang/rust/commit/1d6f291335c58aac95c1124f55d7fb0834baff2a"}], "stats": {"total": 592, "additions": 285, "deletions": 307}, "files": [{"sha": "c0a9494e5147c0d1f56a6130441ed2ef019378a3", "filename": "Cargo.lock", "status": "modified", "additions": 35, "deletions": 211, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/6bba4158cb8938af6e9b128c2c01b15415d502ad/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6bba4158cb8938af6e9b128c2c01b15415d502ad/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6bba4158cb8938af6e9b128c2c01b15415d502ad", "patch": "@@ -51,17 +51,6 @@ version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n \n-[[package]]\n-name = \"atty\"\n-version = \"0.2.14\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n-dependencies = [\n- \"hermit-abi\",\n- \"libc\",\n- \"winapi 0.3.9\",\n-]\n-\n [[package]]\n name = \"autocfg\"\n version = \"1.0.0\"\n@@ -94,27 +83,6 @@ version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n \n-[[package]]\n-name = \"block-buffer\"\n-version = \"0.7.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c0940dc441f31689269e10ac70eb1002a3a1d3ad1390e030043662eb7fe4688b\"\n-dependencies = [\n- \"block-padding\",\n- \"byte-tools\",\n- \"byteorder\",\n- \"generic-array\",\n-]\n-\n-[[package]]\n-name = \"block-padding\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fa79dedbb091f449f1f39e53edf88d5dbe95f895dae6135a8d7b881fb5af73f5\"\n-dependencies = [\n- \"byte-tools\",\n-]\n-\n [[package]]\n name = \"bstr\"\n version = \"0.2.13\"\n@@ -124,12 +92,6 @@ dependencies = [\n  \"memchr\",\n ]\n \n-[[package]]\n-name = \"byte-tools\"\n-version = \"0.3.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e3b5ca7a04898ad4bcd41c90c5285445ff5b791899bb1b0abdd2a2aa791211d7\"\n-\n [[package]]\n name = \"byteorder\"\n version = \"1.3.4\"\n@@ -222,21 +184,6 @@ dependencies = [\n  \"time\",\n ]\n \n-[[package]]\n-name = \"clap\"\n-version = \"2.33.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bdfa80d47f954d53a35a64987ca1422f495b8d6483c0fe9f7117b36c2a792129\"\n-dependencies = [\n- \"ansi_term\",\n- \"atty\",\n- \"bitflags\",\n- \"strsim\",\n- \"textwrap\",\n- \"unicode-width\",\n- \"vec_map\",\n-]\n-\n [[package]]\n name = \"cloudabi\"\n version = \"0.1.0\"\n@@ -246,23 +193,6 @@ dependencies = [\n  \"bitflags\",\n ]\n \n-[[package]]\n-name = \"comrak\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e17058cc536cf290563e88787d7b9e6030ce4742943017cc2ffb71f88034021c\"\n-dependencies = [\n- \"clap\",\n- \"entities\",\n- \"lazy_static\",\n- \"pest\",\n- \"pest_derive\",\n- \"regex\",\n- \"twoway\",\n- \"typed-arena\",\n- \"unicode_categories\",\n-]\n-\n [[package]]\n name = \"console\"\n version = \"0.11.3\"\n@@ -355,15 +285,6 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \n-[[package]]\n-name = \"digest\"\n-version = \"0.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5\"\n-dependencies = [\n- \"generic-array\",\n-]\n-\n [[package]]\n name = \"drop_bomb\"\n version = \"0.1.4\"\n@@ -397,12 +318,6 @@ version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f\"\n \n-[[package]]\n-name = \"entities\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b5320ae4c3782150d900b79807611a59a99fc9a1d61d686faafc24b93fc8d7ca\"\n-\n [[package]]\n name = \"env_logger\"\n version = \"0.7.1\"\n@@ -412,12 +327,6 @@ dependencies = [\n  \"log\",\n ]\n \n-[[package]]\n-name = \"fake-simd\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n-\n [[package]]\n name = \"filetime\"\n version = \"0.2.10\"\n@@ -502,12 +411,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n \n [[package]]\n-name = \"generic-array\"\n-version = \"0.12.3\"\n+name = \"getopts\"\n+version = \"0.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c68f0274ae0e023facc3c97b2e00f076be70e254bc851d972503b328db79b2ec\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n dependencies = [\n- \"typenum\",\n+ \"unicode-width\",\n ]\n \n [[package]]\n@@ -963,12 +872,6 @@ version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0b631f7e854af39a1739f401cf34a8a013dfe09eac4fa4dba91e9768bd28168d\"\n \n-[[package]]\n-name = \"opaque-debug\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2839e79665f131bdb5782e51f2c6c9599c133c6098982a54c794358bf432529c\"\n-\n [[package]]\n name = \"parking_lot\"\n version = \"0.11.0\"\n@@ -1024,49 +927,6 @@ version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n \n-[[package]]\n-name = \"pest\"\n-version = \"2.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"10f4872ae94d7b90ae48754df22fd42ad52ce740b8f370b03da4835417403e53\"\n-dependencies = [\n- \"ucd-trie\",\n-]\n-\n-[[package]]\n-name = \"pest_derive\"\n-version = \"2.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"833d1ae558dc601e9a60366421196a8d94bc0ac980476d0b67e1d0988d72b2d0\"\n-dependencies = [\n- \"pest\",\n- \"pest_generator\",\n-]\n-\n-[[package]]\n-name = \"pest_generator\"\n-version = \"2.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55\"\n-dependencies = [\n- \"pest\",\n- \"pest_meta\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"pest_meta\"\n-version = \"2.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"54be6e404f5317079812fc8f9f5279de376d8856929e21c184ecf6bbd692a11d\"\n-dependencies = [\n- \"maplit\",\n- \"pest\",\n- \"sha-1\",\n-]\n-\n [[package]]\n name = \"petgraph\"\n version = \"0.5.1\"\n@@ -1110,6 +970,27 @@ dependencies = [\n  \"unicode-xid\",\n ]\n \n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.7.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3e142c3b8f49d2200605ee6ba0b1d757310e9e7a72afe78c36ee2ef67300ee00\"\n+dependencies = [\n+ \"bitflags\",\n+ \"getopts\",\n+ \"memchr\",\n+ \"unicase\",\n+]\n+\n+[[package]]\n+name = \"pulldown-cmark-to-cmark\"\n+version = \"4.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cffb594e453d29e238ac190362a4a291daec00396717a8d1670863121ac56958\"\n+dependencies = [\n+ \"pulldown-cmark\",\n+]\n+\n [[package]]\n name = \"quote\"\n version = \"1.0.7\"\n@@ -1264,20 +1145,21 @@ dependencies = [\n name = \"ra_ide\"\n version = \"0.1.0\"\n dependencies = [\n- \"comrak\",\n  \"either\",\n  \"indexmap\",\n  \"insta\",\n  \"itertools\",\n+ \"lazy_static\",\n  \"log\",\n  \"maplit\",\n+ \"pulldown-cmark\",\n+ \"pulldown-cmark-to-cmark\",\n  \"ra_assists\",\n  \"ra_cfg\",\n  \"ra_db\",\n  \"ra_fmt\",\n  \"ra_hir\",\n  \"ra_hir_def\",\n- \"ra_hir_expand\",\n  \"ra_ide_db\",\n  \"ra_parser\",\n  \"ra_prof\",\n@@ -1793,18 +1675,6 @@ dependencies = [\n  \"yaml-rust\",\n ]\n \n-[[package]]\n-name = \"sha-1\"\n-version = \"0.8.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f7d94d0bede923b3cea61f3f1ff57ff8cdfd77b400fb8f9998949e0cf04163df\"\n-dependencies = [\n- \"block-buffer\",\n- \"digest\",\n- \"fake-simd\",\n- \"opaque-debug\",\n-]\n-\n [[package]]\n name = \"sharded-slab\"\n version = \"0.0.9\"\n@@ -1839,12 +1709,6 @@ dependencies = [\n name = \"stdx\"\n version = \"0.1.0\"\n \n-[[package]]\n-name = \"strsim\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n-\n [[package]]\n name = \"superslice\"\n version = \"1.0.0\"\n@@ -1924,15 +1788,6 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f03e7efdedc3bc78cb2337f1e2785c39e45f5ef762d9e4ebb137fff7380a6d8a\"\n \n-[[package]]\n-name = \"textwrap\"\n-version = \"0.11.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\n-dependencies = [\n- \"unicode-width\",\n-]\n-\n [[package]]\n name = \"thin-dst\"\n version = \"1.1.0\"\n@@ -2046,39 +1901,14 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"twoway\"\n-version = \"0.2.1\"\n+name = \"unicase\"\n+version = \"2.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6b40075910de3a912adbd80b5d8bad6ad10a23eeb1f5bf9d4006839e899ba5bc\"\n+checksum = \"50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6\"\n dependencies = [\n- \"memchr\",\n- \"unchecked-index\",\n+ \"version_check\",\n ]\n \n-[[package]]\n-name = \"typed-arena\"\n-version = \"1.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a9b2228007eba4120145f785df0f6c92ea538f5a3635a612ecf4e334c8c1446d\"\n-\n-[[package]]\n-name = \"typenum\"\n-version = \"1.12.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"373c8a200f9e67a0c95e62a4f52fbf80c23b4381c05a17845531982fa99e6b33\"\n-\n-[[package]]\n-name = \"ucd-trie\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"56dee185309b50d1f11bfedef0fe6d036842e3fb77413abef29f8f8d1c5d4c1c\"\n-\n-[[package]]\n-name = \"unchecked-index\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eeba86d422ce181a719445e51872fa30f1f7413b62becb52e95ec91aa262d85c\"\n-\n [[package]]\n name = \"unicode-bidi\"\n version = \"0.3.4\"\n@@ -2115,12 +1945,6 @@ version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f7fe0bb3479651439c9112f72b6c505038574c9fbb575ed1bf3b797fa39dd564\"\n \n-[[package]]\n-name = \"unicode_categories\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39ec24b3121d976906ece63c9daad25b85969647682eee313cb5779fdd69e14e\"\n-\n [[package]]\n name = \"url\"\n version = \"2.1.1\"\n@@ -2134,10 +1958,10 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"vec_map\"\n-version = \"0.8.2\"\n+name = \"version_check\"\n+version = \"0.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191\"\n+checksum = \"b5a972e5669d67ba988ce3dc826706fb0a8b01471c088cb0b6110b805cc36aed\"\n \n [[package]]\n name = \"vfs\""}, {"sha": "fe34b30bc80aa9d4b6338a423f9370f1edf75f59", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bba4158cb8938af6e9b128c2c01b15415d502ad/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bba4158cb8938af6e9b128c2c01b15415d502ad/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=6bba4158cb8938af6e9b128c2c01b15415d502ad", "patch": "@@ -66,12 +66,14 @@ pub use hir_def::{\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     docs::Documentation,\n+    item_scope::ItemInNs,\n     nameres::ModuleSource,\n     path::{ModPath, Path, PathKind},\n     type_ref::Mutability,\n };\n pub use hir_expand::{\n-    hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId,\n-    MacroFile, Origin,\n+    hygiene::Hygiene,\n+    name::{AsName, Name},\n+    HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Origin,\n };\n pub use hir_ty::{display::HirDisplay, CallableDef};"}, {"sha": "642b71937af8143de49b0b25e51ab027fdf7ffa6", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bba4158cb8938af6e9b128c2c01b15415d502ad/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bba4158cb8938af6e9b128c2c01b15415d502ad/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=6bba4158cb8938af6e9b128c2c01b15415d502ad", "patch": "@@ -17,9 +17,11 @@ itertools = \"0.9.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n rand = { version = \"0.7.3\", features = [\"small_rng\"] }\n-comrak = \"0.7.0\"\n url = \"*\"\n maplit = \"*\"\n+lazy_static = \"*\"\n+pulldown-cmark-to-cmark = \"4.0.2\"\n+pulldown-cmark = \"0.7.0\"\n \n stdx = { path = \"../stdx\" }\n \n@@ -36,7 +38,6 @@ ra_ssr = { path = \"../ra_ssr\" }\n ra_project_model = { path = \"../ra_project_model\" }\n ra_hir_def = { path = \"../ra_hir_def\" }\n ra_tt = { path = \"../ra_tt\" }\n-ra_hir_expand = { path = \"../ra_hir_expand\" }\n ra_parser = { path = \"../ra_parser\" }\n \n # ra_ide should depend only on the top-level `hir` package. if you need"}, {"sha": "82aa24f4f4f3a0d623b3c4d3a58c0dfd12c2c5f0", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 242, "deletions": 91, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/6bba4158cb8938af6e9b128c2c01b15415d502ad/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bba4158cb8938af6e9b128c2c01b15415d502ad/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=6bba4158cb8938af6e9b128c2c01b15415d502ad", "patch": "@@ -1,23 +1,25 @@\n+use std::collections::{HashMap, HashSet};\n use std::iter::once;\n \n use hir::{\n-    Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n-    ModuleSource, Semantics, Documentation, AttrDef, Crate, ModPath, Hygiene\n+    db::DefDatabase, Adt, AsAssocItem, AsName, AssocItemContainer, AttrDef, Crate, Documentation,\n+    FieldSource, HasSource, HirDisplay, Hygiene, ItemInNs, ModPath, ModuleDef, ModuleSource,\n+    Semantics, Module\n };\n use itertools::Itertools;\n+use lazy_static::lazy_static;\n+use maplit::{hashmap, hashset};\n+use pulldown_cmark::{CowStr, Event, Options, Parser, Tag};\n+use pulldown_cmark_to_cmark::cmark;\n use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     RootDatabase,\n };\n-use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, SyntaxNode, TokenAtOffset, ast::Path};\n-use ra_hir_def::{item_scope::ItemInNs, db::DefDatabase, resolver::HasResolver};\n-use ra_tt::{Literal, Ident, Punct, TokenTree, Leaf};\n-use ra_hir_expand::name::AsName;\n-use maplit::{hashset, hashmap};\n-\n-use comrak::{parse_document,format_commonmark, ComrakOptions, Arena};\n-use comrak::nodes::NodeValue;\n+use ra_syntax::{\n+    ast, ast::Path, match_ast, AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, TokenAtOffset,\n+};\n+use ra_tt::{Ident, Leaf, Literal, Punct, TokenTree};\n use url::Url;\n \n use crate::{\n@@ -389,80 +391,143 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     }\n }\n \n+// Rewrites a markdown document, resolving links using `callback` and additionally striping prefixes/suffixes on link titles.\n+fn map_links<'e>(\n+    events: impl Iterator<Item = Event<'e>>,\n+    callback: impl Fn(&str, &str) -> String,\n+) -> impl Iterator<Item = Event<'e>> {\n+    let mut in_link = false;\n+    let mut link_text = CowStr::Borrowed(\"\");\n+    events.map(move |evt| match evt {\n+        Event::Start(Tag::Link(..)) => {\n+            in_link = true;\n+            evt\n+        }\n+        Event::End(Tag::Link(link_type, target, _)) => {\n+            in_link = false;\n+            let target = callback(&target, &link_text);\n+            Event::End(Tag::Link(link_type, CowStr::Boxed(target.into()), CowStr::Borrowed(\"\")))\n+        }\n+        Event::Text(s) if in_link => {\n+            link_text = s.clone();\n+            Event::Text(CowStr::Boxed(strip_prefixes_suffixes(&s).into()))\n+        }\n+        Event::Code(s) if in_link => {\n+            link_text = s.clone();\n+            Event::Code(CowStr::Boxed(strip_prefixes_suffixes(&s).into()))\n+        }\n+        _ => evt,\n+    })\n+}\n+\n /// Rewrite documentation links in markdown to point to local documentation/docs.rs\n fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> Option<String> {\n-    let arena = Arena::new();\n-    let doc = parse_document(&arena, markdown, &ComrakOptions::default());\n-\n-    iter_nodes(doc, &|node| {\n-        match &mut node.data.borrow_mut().value {\n-            &mut NodeValue::Link(ref mut link) => {\n-                match Url::parse(&String::from_utf8(link.url.clone()).unwrap()) {\n-                    // If this is a valid absolute URL don't touch it\n-                    Ok(_) => (),\n-                    // Otherwise there are two main possibilities\n-                    // path-based links: `../../module/struct.MyStruct.html`\n-                    // module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n-                    Err(_) => {\n-                        let link_str = String::from_utf8(link.url.clone()).unwrap();\n-                        let link_text = String::from_utf8(link.title.clone()).unwrap();\n-                        let resolved = try_resolve_intra(db, definition, &link_text, &link_str)\n-                            .or_else(|| try_resolve_path(db, definition, &link_str));\n-\n-                        if let Some(resolved) = resolved {\n-                            link.url = resolved.as_bytes().to_vec();\n-                        }\n-\n-                    }\n+    let doc = Parser::new_with_broken_link_callback(\n+        markdown,\n+        Options::empty(),\n+        Some(&|label, _| Some((/*url*/ label.to_string(), /*title*/ label.to_string()))),\n+    );\n+\n+    let doc = map_links(doc, |target, title: &str| {\n+        match Url::parse(target) {\n+            // If this is a valid absolute URL don't touch it\n+            Ok(_) => target.to_string(),\n+            // Otherwise there are two main possibilities\n+            // path-based links: `../../module/struct.MyStruct.html`\n+            // module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n+            Err(_) => {\n+                let resolved = try_resolve_intra(db, definition, title, &target)\n+                    .or_else(|| try_resolve_path(db, definition, &target));\n+\n+                if let Some(resolved) = resolved {\n+                    resolved\n+                } else {\n+                    target.to_string()\n                 }\n-            },\n-            _ => ()\n+            }\n         }\n     });\n-    let mut out = Vec::new();\n-    format_commonmark(doc, &ComrakOptions::default(), &mut out).ok()?;\n-    Some(String::from_utf8(out).unwrap().trim().to_string())\n+    let mut out = String::new();\n+    cmark(doc, &mut out, None).ok();\n+    Some(out)\n }\n \n #[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n enum Namespace {\n     Types,\n     Values,\n-    Macros\n+    Macros,\n }\n \n+lazy_static!(\n+    /// Map of namespaces to identifying prefixes and suffixes as defined by RFC1946.\n+    static ref NS_MAP: HashMap<Namespace, (HashSet<&'static str>, HashSet<&'static str>)> = hashmap!{\n+        Namespace::Types => (hashset!{\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"}, hashset!{}),\n+        Namespace::Values => (hashset!{\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"}, hashset!{\"()\"}),\n+        Namespace::Macros => (hashset!{\"macro\"}, hashset!{\"!\"})\n+    };\n+);\n+\n impl Namespace {\n     /// Extract the specified namespace from an intra-doc-link if one exists.\n     fn from_intra_spec(s: &str) -> Option<Self> {\n-        let ns_map = hashmap!{\n-            Self::Types => (hashset!{\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"}, hashset!{}),\n-            Self::Values => (hashset!{\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"}, hashset!{\"()\"}),\n-            Self::Macros => (hashset!{\"macro\"}, hashset!{\"!\"})\n-        };\n-\n-        ns_map\n+        NS_MAP\n             .iter()\n             .filter(|(_ns, (prefixes, suffixes))| {\n-                prefixes.iter().map(|prefix| s.starts_with(prefix) && s.chars().nth(prefix.len()+1).map(|c| c == '@' || c == ' ').unwrap_or(false)).any(|cond| cond) ||\n-                suffixes.iter().map(|suffix| s.starts_with(suffix) && s.chars().nth(suffix.len()+1).map(|c| c == '@' || c == ' ').unwrap_or(false)).any(|cond| cond)\n+                prefixes\n+                    .iter()\n+                    .map(|prefix| {\n+                        s.starts_with(prefix)\n+                            && s.chars()\n+                                .nth(prefix.len() + 1)\n+                                .map(|c| c == '@' || c == ' ')\n+                                .unwrap_or(false)\n+                    })\n+                    .any(|cond| cond)\n+                    || suffixes\n+                        .iter()\n+                        .map(|suffix| {\n+                            s.starts_with(suffix)\n+                                && s.chars()\n+                                    .nth(suffix.len() + 1)\n+                                    .map(|c| c == '@' || c == ' ')\n+                                    .unwrap_or(false)\n+                        })\n+                        .any(|cond| cond)\n             })\n             .map(|(ns, (_, _))| *ns)\n             .next()\n     }\n }\n \n+// Strip prefixes, suffixes, and inline code marks from the given string.\n+fn strip_prefixes_suffixes(mut s: &str) -> &str {\n+    s = s.trim_matches('`');\n+    NS_MAP.iter().for_each(|(_, (prefixes, suffixes))| {\n+        prefixes.iter().for_each(|prefix| s = s.trim_start_matches(prefix));\n+        suffixes.iter().for_each(|suffix| s = s.trim_end_matches(suffix));\n+    });\n+    s.trim_start_matches(\"@\").trim()\n+}\n+\n /// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n ///\n /// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n-fn try_resolve_intra(db: &RootDatabase, definition: &Definition, link_text: &str, link_target: &str) -> Option<String> {\n-    eprintln!(\"try_resolve_intra\");\n-\n+fn try_resolve_intra(\n+    db: &RootDatabase,\n+    definition: &Definition,\n+    link_text: &str,\n+    link_target: &str,\n+) -> Option<String> {\n     // Set link_target for implied shortlinks\n-    let link_target = if link_target.is_empty() {\n-        link_text.trim_matches('`')\n-    } else {\n-        link_target\n-    };\n+    let link_target =\n+        if link_target.is_empty() { link_text.trim_matches('`') } else { link_target };\n+\n+    // Namespace disambiguation\n+    let namespace = Namespace::from_intra_spec(link_target);\n+\n+    // Strip prefixes/suffixes\n+    let link_target = strip_prefixes_suffixes(link_target);\n \n     // Parse link as a module path\n     // This expects a full document, which a single path isn't, but we can just ignore the errors.\n@@ -473,17 +538,17 @@ fn try_resolve_intra(db: &RootDatabase, definition: &Definition, link_text: &str\n     // Resolve it relative to symbol's location (according to the RFC this should consider small scopes\n     let resolver = definition.resolver(db)?;\n \n-    // Namespace disambiguation\n-    let namespace = Namespace::from_intra_spec(link_target);\n-\n     let resolved = resolver.resolve_module_path_in_items(db, &modpath);\n     let (defid, namespace) = match namespace {\n         // TODO: .or(resolved.macros)\n-        None => resolved.types.map(|t| (t.0, Namespace::Types)).or(resolved.values.map(|t| (t.0, Namespace::Values)))?,\n+        None => resolved\n+            .types\n+            .map(|t| (t.0, Namespace::Types))\n+            .or(resolved.values.map(|t| (t.0, Namespace::Values)))?,\n         Some(ns @ Namespace::Types) => (resolved.types?.0, ns),\n         Some(ns @ Namespace::Values) => (resolved.values?.0, ns),\n         // TODO:\n-        Some(Namespace::Macros) => None?\n+        Some(Namespace::Macros) => None?,\n     };\n \n     // Get the filepath of the final symbol\n@@ -494,23 +559,28 @@ fn try_resolve_intra(db: &RootDatabase, definition: &Definition, link_text: &str\n         Namespace::Types => ItemInNs::Types(defid),\n         Namespace::Values => ItemInNs::Values(defid),\n         // TODO:\n-        Namespace::Macros => None?\n+        Namespace::Macros => None?,\n     };\n     let import_map = db.import_map(krate.into());\n     let path = import_map.path_of(ns)?;\n \n     Some(\n         get_doc_url(db, &krate)?\n-            .join(&format!(\"{}/\", krate.display_name(db)?)).ok()?\n-            .join(&path.segments.iter().map(|name| format!(\"{}\", name)).join(\"/\")).ok()?\n-            .join(&get_symbol_filename(db, &Definition::ModuleDef(def))?).ok()?\n-            .into_string()\n+            .join(&format!(\"{}/\", krate.display_name(db)?))\n+            .ok()?\n+            .join(&path.segments.iter().map(|name| format!(\"{}\", name)).join(\"/\"))\n+            .ok()?\n+            .join(&get_symbol_filename(db, &Definition::ModuleDef(def))?)\n+            .ok()?\n+            .into_string(),\n     )\n }\n \n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n fn try_resolve_path(db: &RootDatabase, definition: &Definition, link: &str) -> Option<String> {\n-    eprintln!(\"try_resolve_path\");\n+    if !link.contains(\"#\") && !link.contains(\".html\") {\n+        return None;\n+    }\n     let ns = if let Definition::ModuleDef(moddef) = definition {\n         ItemInNs::Types(moddef.clone().into())\n     } else {\n@@ -522,11 +592,15 @@ fn try_resolve_path(db: &RootDatabase, definition: &Definition, link: &str) -> O\n     // TODO: It should be possible to fall back to not-necessarilly-public paths if we can't find a public one,\n     // then hope rustdoc was run locally with `--document-private-items`\n     let base = import_map.path_of(ns)?;\n-    let base = once(format!(\"{}\", krate.display_name(db)?)).chain(base.segments.iter().map(|name| format!(\"{}\", name))).join(\"/\");\n+    let base = once(format!(\"{}\", krate.display_name(db)?))\n+        .chain(base.segments.iter().map(|name| format!(\"{}\", name)))\n+        .join(\"/\");\n \n     get_doc_url(db, &krate)\n         .and_then(|url| url.join(&base).ok())\n-        .and_then(|url| get_symbol_filename(db, definition).as_deref().map(|f| url.join(f).ok()).flatten())\n+        .and_then(|url| {\n+            get_symbol_filename(db, definition).as_deref().map(|f| url.join(f).ok()).flatten()\n+        })\n         .and_then(|url| url.join(link).ok())\n         .map(|url| url.into_string())\n }\n@@ -566,31 +640,25 @@ fn get_symbol_filename(db: &RootDatabase, definition: &Definition) -> Option<Str\n             ModuleDef::Adt(adt) => match adt {\n                 Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n                 Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n-                Adt::Union(u) => format!(\"union.{}.html\", u.name(db))\n+                Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n             },\n             ModuleDef::Module(_) => \"index.html\".to_string(),\n             ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n             ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n             ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.as_name()),\n             ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n-            ModuleDef::EnumVariant(ev) => format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db)),\n+            ModuleDef::EnumVariant(ev) => {\n+                format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n+            }\n             ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n             // TODO: Check this is the right prefix\n-            ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?)\n+            ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?),\n         },\n         Definition::Macro(m) => format!(\"macro.{}.html\", m.name(db)?),\n-        _ => None?\n+        _ => None?,\n     })\n }\n \n-fn iter_nodes<'a, F>(node: &'a comrak::nodes::AstNode<'a>, f: &F)\n-    where F : Fn(&'a comrak::nodes::AstNode<'a>) {\n-    f(node);\n-    for c in node.children() {\n-        iter_nodes(c, f);\n-    }\n-}\n-\n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {\n@@ -614,12 +682,11 @@ mod tests {\n     use crate::mock_analysis::analysis_and_position;\n \n     fn trim_markup(s: &str) -> String {\n-        s\n-            .replace(\"``` rust\", \"```rust\")\n-            .replace(\"-----\", \"___\")\n-            .replace(\"\\n\\n___\\n\\n\", \"\\n___\\n\\n\")\n+        s.trim()\n+            .replace(\"````\", \"```\")\n+            .replace(\"---\", \"___\")\n             .replace(\"\\\\<-\", \"<-\")\n-            .trim_start_matches(\"test\\n```\\n\\n\")\n+            .replace(\"```\\n\\n___\", \"```\\n___\")\n             .trim_start_matches(\"```rust\\n\")\n             .trim_start_matches(\"test\\n```\\n\\n```rust\\n\")\n             .trim_end_matches(\"\\n```\")\n@@ -873,7 +940,10 @@ fn main() {\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()).as_deref(), Some(\"test::Option\\n```\\n\\n```rust\\nSome\"));\n+        assert_eq!(\n+            trim_markup_opt(hover.info.first()).as_deref(),\n+            Some(\"test::Option\\n```\\n\\n```rust\\nSome\")\n+        );\n \n         let (analysis, position) = analysis_and_position(\n             \"\n@@ -1408,7 +1478,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             /// [Foo](struct.Foo.html)\n             pub struct B<|>ar\n             \",\n-            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"]\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"],\n         );\n     }\n \n@@ -1421,7 +1491,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             /// [Foo](Foo)\n             pub struct B<|>ar\n             \",\n-            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"]\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"],\n         );\n     }\n \n@@ -1434,7 +1504,20 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             /// [Foo]\n             pub struct B<|>ar\n             \",\n-            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"]\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_intra_link_shortlink_code() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [`Foo`]\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\"],\n         );\n     }\n \n@@ -1448,7 +1531,75 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             /// [Foo()]\n             pub struct B<|>ar\n             \",\n-            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"]\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_intra_link_shortlink_namspaced_code() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [`struct Foo`]\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_intra_link_shortlink_namspaced_code_with_at() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [`struct@Foo`]\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_intra_link_reference() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [my Foo][foo]\n+            ///\n+            /// [foo]: Foo\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[my Foo](https://docs.rs/test/*/test/struct.Foo.html)\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_external_url() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [external](https://www.google.com)\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[external](https://www.google.com)\"],\n+        );\n+    }\n+\n+    // Check that we don't rewrite links which we can't identify\n+    #[test]\n+    fn test_hover_unknown_target() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub struct Foo;\n+            /// [baz](Baz)\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[baz](Baz)\"],\n         );\n     }\n "}, {"sha": "c8c8b886d7dae71223cc2aab94f5ebe6d8270098", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bba4158cb8938af6e9b128c2c01b15415d502ad/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bba4158cb8938af6e9b128c2c01b15415d502ad/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=6bba4158cb8938af6e9b128c2c01b15415d502ad", "patch": "@@ -547,7 +547,7 @@ pub(crate) fn handle_hover(\n ) -> Result<Option<lsp_ext::Hover>> {\n     let _p = profile(\"handle_hover\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let info = match snap.analysis().hover(position)? {\n+    let info = match snap.analysis.hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };"}]}