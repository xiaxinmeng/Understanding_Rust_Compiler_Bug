{"sha": "9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZDNjNTRhMmM3ODdjNzkwMzdmNWM3NzJiMTJjN2QyZDJmODdiMTg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-03-29T20:14:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-04-12T15:17:42Z"}, "message": "rustbuild: Migrate tidy checks to Rust\n\nThis commit rewrites all of the tidy checks we have, namely:\n\n* featureck\n* errorck\n* tidy\n* binaries\n\ninto Rust under a new `tidy` tool inside of the `src/tools` directory. This at\nthe same time deletes all the corresponding Python tidy checks so we can be sure\nto only have one source of truth for all the tidy checks.\n\ncc #31590", "tree": {"sha": "4c2f32edacc12823aa53e0a75660f925f78893a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c2f32edacc12823aa53e0a75660f925f78893a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "html_url": "https://github.com/rust-lang/rust/commit/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bed32d83fcd1337e962a58fd04fae6b8503e3283", "url": "https://api.github.com/repos/rust-lang/rust/commits/bed32d83fcd1337e962a58fd04fae6b8503e3283", "html_url": "https://github.com/rust-lang/rust/commit/bed32d83fcd1337e962a58fd04fae6b8503e3283"}], "stats": {"total": 1289, "additions": 547, "deletions": 742}, "files": [{"sha": "87cfed2426e9c2f9770009cf65c81284db448f7e", "filename": "mk/tests.mk", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -240,52 +240,16 @@ cleantestlibs:\n # Tidy\n ######################################################################\n \n-ifdef CFG_NOTIDY\n .PHONY: tidy\n-tidy:\n-else\n-\n-# Run the tidy script in multiple parts to avoid huge 'echo' commands\n-.PHONY: tidy\n-tidy: tidy-basic tidy-binaries tidy-errors tidy-features\n-\n-endif\n-\n-.PHONY: tidy-basic\n-tidy-basic:\n-\t\t@$(call E, check: formatting)\n-\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/tidy.py $(S)src/\n-\n-.PHONY: tidy-binaries\n-tidy-binaries:\n-\t\t@$(call E, check: binaries)\n-\t\t$(Q)find $(S)src -type f \\\n-\t\t    \\( -perm -u+x -or -perm -g+x -or -perm -o+x \\) \\\n-\t\t    -not -name '*.rs' -and -not -name '*.py' \\\n-\t\t    -and -not -name '*.sh' -and -not -name '*.pp' \\\n-\t\t| grep '^$(S)src/jemalloc' -v \\\n-\t\t| grep '^$(S)src/libuv' -v \\\n-\t\t| grep '^$(S)src/llvm' -v \\\n-\t\t| grep '^$(S)src/rt/hoedown' -v \\\n-\t\t| grep '^$(S)src/gyp' -v \\\n-\t\t| grep '^$(S)src/etc' -v \\\n-\t\t| grep '^$(S)src/doc' -v \\\n-\t\t| grep '^$(S)src/compiler-rt' -v \\\n-\t\t| grep '^$(S)src/libbacktrace' -v \\\n-\t\t| grep '^$(S)src/rust-installer' -v \\\n-\t\t| grep '^$(S)src/liblibc' -v \\\n-\t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n-\n-.PHONY: tidy-errors\n-tidy-errors:\n-\t\t@$(call E, check: extended errors)\n-\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/errorck.py $(S)src/\n-\n-.PHONY: tidy-features\n-tidy-features:\n-\t\t@$(call E, check: feature sanity)\n-\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/featureck.py $(S)src/\n-\n+tidy: $(HBIN0_H_$(CFG_BUILD))/tidy$(X_$(CFG_BUILD))\n+\t$< $(S)src\n+\n+$(HBIN0_H_$(CFG_BUILD))/tidy$(X_$(CFG_BUILD)): \\\n+\t\t$(TSREQ0_T_$(CFG_BUILD)_H_$(CFG_BUILD)) \\\n+\t\t$(TLIB0_T_$(CFG_BUILD)_H_$(CFG_BUILD))/stamp.std \\\n+\t\t$(call rwildcard,$(S)src/tools/tidy/src,*.rs)\n+\t$(STAGE0_T_$(CFG_BUILD)_H_$(CFG_BUILD)) src/tools/tidy/src/main.rs \\\n+\t\t--out-dir $(@D) --crate-name tidy\n \n ######################################################################\n # Sets of tests"}, {"sha": "d4e344fc48247fb69c816610dd9c8304791b162d", "filename": "src/bootstrap/build/check.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcheck.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -33,3 +33,10 @@ pub fn cargotest(build: &Build, stage: u32, host: &str) {\n               .env(\"PATH\", newpath)\n               .arg(&build.cargo));\n }\n+\n+pub fn tidy(build: &Build, stage: u32, host: &str) {\n+    println!(\"tidy check stage{} ({})\", stage, host);\n+    let compiler = Compiler::new(stage, host);\n+    build.run(build.tool_cmd(&compiler, \"tidy\")\n+                   .arg(build.src.join(\"src\")));\n+}"}, {"sha": "4f0bfb84344e742da1dc3756277d435a0f76080f", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -197,6 +197,9 @@ impl Build {\n                 ToolCargoTest { stage } => {\n                     compile::tool(self, stage, target.target, \"cargotest\");\n                 }\n+                ToolTidy { stage } => {\n+                    compile::tool(self, stage, target.target, \"tidy\");\n+                }\n                 DocBook { stage } => {\n                     doc::rustbook(self, stage, target.target, \"book\", &doc_out);\n                 }\n@@ -230,6 +233,9 @@ impl Build {\n                 CheckCargoTest { stage } => {\n                     check::cargotest(self, stage, target.target);\n                 }\n+                CheckTidy { stage } => {\n+                    check::tidy(self, stage, target.target);\n+                }\n \n                 DistDocs { stage } => dist::docs(self, stage, target.target),\n                 DistMingw { _dummy } => dist::mingw(self, target.target),"}, {"sha": "626cf7586317f4b6805394ad4fe9836b83683248", "filename": "src/bootstrap/build/step.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -51,6 +51,7 @@ macro_rules! targets {\n             (tool_rustbook, ToolRustbook { stage: u32 }),\n             (tool_error_index, ToolErrorIndex { stage: u32 }),\n             (tool_cargotest, ToolCargoTest { stage: u32 }),\n+            (tool_tidy, ToolTidy { stage: u32 }),\n \n             // Steps for long-running native builds. Ideally these wouldn't\n             // actually exist and would be part of build scripts, but for now\n@@ -79,6 +80,7 @@ macro_rules! targets {\n             (check, Check { stage: u32, compiler: Compiler<'a> }),\n             (check_linkcheck, CheckLinkcheck { stage: u32 }),\n             (check_cargotest, CheckCargoTest { stage: u32 }),\n+            (check_tidy, CheckTidy { stage: u32 }),\n \n             // Distribution targets, creating tarballs\n             (dist, Dist { stage: u32 }),\n@@ -316,8 +318,13 @@ impl<'a> Step<'a> {\n             Source::CheckCargoTest { stage } => {\n                 vec![self.tool_cargotest(stage)]\n             }\n+            Source::CheckTidy { stage } => {\n+                vec![self.tool_tidy(stage)]\n+            }\n \n-            Source::ToolLinkchecker { stage } => {\n+            Source::ToolLinkchecker { stage } |\n+            Source::ToolTidy { stage } |\n+            Source::ToolCargoTest { stage } => {\n                 vec![self.libstd(self.compiler(stage))]\n             }\n             Source::ToolErrorIndex { stage } |"}, {"sha": "1f3ea8f19bb020ae84d99c0c0ed95f29d9207742", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -42,5 +42,7 @@ check-cargotest:\n \t$(Q)$(BOOTSTRAP) --step check-cargotest\n dist:\n \t$(Q)$(BOOTSTRAP) --step dist\n+tidy:\n+\t$(Q)$(BOOTSTRAP) --step check-tidy --stage 0\n \n .PHONY: dist"}, {"sha": "91c01b178075d6fee9f452b80a8751dc0ba94fb6", "filename": "src/etc/check-binaries.py", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Fcheck-binaries.py", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Fcheck-binaries.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck-binaries.py?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1,20 +0,0 @@\n-#!/usr/bin/env python\n-#\n-# Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-import sys\n-\n-offenders = sys.argv[1:]\n-if len(offenders) > 0:\n-    print(\"Binaries checked into src:\")\n-    for offender in offenders:\n-        print(offender)\n-    sys.exit(1)"}, {"sha": "1f5f3784ac61d0c3c92d2f75c83a6349c17187fc", "filename": "src/etc/errorck.py", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1,136 +0,0 @@\n-# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-# Digs error codes out of files named 'diagnostics.rs' across\n-# the tree, and ensures thare are no duplicates.\n-\n-import sys\n-import os\n-import re\n-\n-if len(sys.argv) < 2:\n-    print(\"usage: errorck.py <src-dir>\")\n-    sys.exit(1)\n-\n-src_dir = sys.argv[1]\n-errcode_map = {}\n-errcode_checked = []\n-errcode_not_found = []\n-error_re = re.compile(\"(E\\d\\d\\d\\d)\")\n-\n-def check_unused_error_codes(error_codes, check_error_codes, filenames, dirnames, dirpath):\n-    for filename in filenames:\n-        if filename == \"diagnostics.rs\" or not filename.endswith(\".rs\"):\n-            continue\n-        path = os.path.join(dirpath, filename)\n-\n-        with open(path, 'r') as f:\n-            for line in f:\n-                match = error_re.search(line)\n-                if match:\n-                    errcode = match.group(1)\n-                    if errcode in error_codes:\n-                        error_codes.remove(errcode)\n-                    if errcode not in check_error_codes:\n-                        check_error_codes.append(errcode)\n-    for dirname in dirnames:\n-        path = os.path.join(dirpath, dirname)\n-        for (dirpath, dnames, fnames) in os.walk(path):\n-            check_unused_error_codes(error_codes, check_error_codes, fnames, dnames, dirpath)\n-\n-\n-# In the register_long_diagnostics! macro, entries look like this:\n-#\n-# EXXXX: r##\"\n-# <Long diagnostic message>\n-# \"##,\n-#\n-# These two variables are for detecting the beginning and end of diagnostic\n-# messages so that duplicate error codes are not reported when a code occurs\n-# inside a diagnostic message\n-long_diag_begin = \"r##\\\"\"\n-long_diag_end = \"\\\"##\"\n-\n-errors = False\n-all_errors = []\n-\n-for (dirpath, dirnames, filenames) in os.walk(src_dir):\n-    if \"src/test\" in dirpath or \"src/llvm\" in dirpath:\n-        # Short circuit for fast\n-        continue\n-\n-    errcode_to_check = []\n-    for filename in filenames:\n-        if filename != \"diagnostics.rs\":\n-            continue\n-        path = os.path.join(dirpath, filename)\n-\n-        with open(path, 'r') as f:\n-            inside_long_diag = False\n-            errcode_to_check = []\n-            for line_num, line in enumerate(f, start=1):\n-                if inside_long_diag:\n-                    # Skip duplicate error code checking for this line\n-                    if long_diag_end in line:\n-                        inside_long_diag = False\n-                    continue\n-\n-                match = error_re.search(line)\n-                if match:\n-                    errcode = match.group(1)\n-                    new_record = [(errcode, path, line_num, line)]\n-                    existing = errcode_map.get(errcode)\n-                    if existing is not None:\n-                        # This is a dupe\n-                        errcode_map[errcode] = existing + new_record\n-                    else:\n-                        errcode_map[errcode] = new_record\n-                        # we don't check if this is a long error explanation\n-                        if (long_diag_begin not in line and not line.strip().startswith(\"//\")\n-                            and errcode not in errcode_to_check and errcode not in errcode_checked\n-                            and errcode not in errcode_not_found):\n-                            errcode_to_check.append(errcode)\n-\n-                if long_diag_begin in line:\n-                    inside_long_diag = True\n-        break\n-    check_unused_error_codes(errcode_to_check, errcode_checked, filenames, dirnames, dirpath)\n-    if len(errcode_to_check) > 0:\n-        for errcode in errcode_to_check:\n-            if errcode in errcode_checked:\n-                continue\n-            errcode_not_found.append(errcode)\n-\n-if len(errcode_not_found) > 0:\n-    errcode_not_found.sort()\n-    for errcode in errcode_not_found:\n-        if errcode in errcode_checked:\n-            continue\n-        all_errors.append(errcode)\n-        print(\"error: unused error code: {0} ({1}:{2})\".format(*errcode_map[errcode][0]))\n-        errors = True\n-\n-\n-for errcode, entries in errcode_map.items():\n-    all_errors.append(entries[0][0])\n-    if len(entries) > 1:\n-        entries.sort()\n-        print(\"error: duplicate error code \" + errcode)\n-        for entry in entries:\n-            print(\"{1}: {2}\\n{3}\".format(*entry))\n-        errors = True\n-\n-print\n-print(\"* {0} error codes\".format(len(errcode_map)))\n-print(\"* highest error code: \" + max(all_errors))\n-print\n-\n-if errors:\n-    sys.exit(1)"}, {"sha": "d6cc25177e4ae63797a58ca7c8564a95076a7ce0", "filename": "src/etc/featureck.py", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Ffeatureck.py", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Ffeatureck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ffeatureck.py?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1,251 +0,0 @@\n-# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-# This script does a tree-wide sanity checks against stability\n-# attributes, currently:\n-#   * For all feature_name/level pairs the 'since' field is the same\n-#   * That no features are both stable and unstable.\n-#   * That lib features don't have the same name as lang features\n-#     unless they are on the 'joint_features' whitelist\n-#   * That features that exist in both lang and lib and are stable\n-#     since the same version\n-#   * Prints information about features\n-\n-import sys\n-import os\n-import re\n-import codecs\n-\n-if len(sys.argv) < 2:\n-    print(\"usage: featureck.py <src-dir>\")\n-    sys.exit(1)\n-\n-src_dir = sys.argv[1]\n-\n-# Features that are allowed to exist in both the language and the library\n-joint_features = [ ]\n-\n-# Grab the list of language features from the compiler\n-language_gate_statuses = [ \"Active\", \"Deprecated\", \"Removed\", \"Accepted\" ]\n-feature_gate_source = os.path.join(src_dir, \"libsyntax\", \"feature_gate.rs\")\n-language_features = []\n-language_feature_names = []\n-with open(feature_gate_source, 'r') as f:\n-    for line in f:\n-        original_line = line\n-        line = line.strip()\n-        is_feature_line = False\n-        for status in language_gate_statuses:\n-            if status in line and line.startswith(\"(\"):\n-                is_feature_line = True\n-\n-        if is_feature_line:\n-            # turn `    (\"foo\", \"1.0.0\", Some(10), Active)` into\n-            # `\"foo\", \"1.0.0\", Some(10), Active`\n-            line = line.strip(' ,()')\n-            parts = line.split(\",\")\n-            if len(parts) != 4:\n-                print(\"error: unexpected number of components in line: \" + original_line)\n-                sys.exit(1)\n-            feature_name = parts[0].strip().replace('\"', \"\")\n-            since = parts[1].strip().replace('\"', \"\")\n-            issue = parts[2].strip()\n-            status = parts[3].strip()\n-            assert len(feature_name) > 0\n-            assert len(since) > 0\n-            assert len(issue) > 0\n-            assert len(status) > 0\n-\n-            language_feature_names += [feature_name]\n-            language_features += [(feature_name, since, issue, status)]\n-\n-assert len(language_features) > 0\n-\n-errors = False\n-\n-lib_features = { }\n-lib_features_and_level = { }\n-for (dirpath, dirnames, filenames) in os.walk(src_dir):\n-    # Don't look for feature names in tests\n-    if \"src/test\" in dirpath:\n-        continue\n-\n-    # Takes a long time to traverse LLVM\n-    if \"src/llvm\" in dirpath:\n-        continue\n-\n-    for filename in filenames:\n-        if not filename.endswith(\".rs\"):\n-            continue\n-\n-        path = os.path.join(dirpath, filename)\n-        with codecs.open(filename=path, mode='r', encoding=\"utf-8\") as f:\n-            line_num = 0\n-            for line in f:\n-                line_num += 1\n-                level = None\n-                if \"[unstable(\" in line:\n-                    level = \"unstable\"\n-                elif \"[stable(\" in line:\n-                    level = \"stable\"\n-                else:\n-                    continue\n-\n-                # This is a stability attribute. For the purposes of this\n-                # script we expect both the 'feature' and 'since' attributes on\n-                # the same line, e.g.\n-                # `#[unstable(feature = \"foo\", since = \"1.0.0\")]`\n-\n-                p = re.compile('(unstable|stable).*feature *= *\"(\\w*)\"')\n-                m = p.search(line)\n-                if not m is None:\n-                    feature_name = m.group(2)\n-                    since = None\n-                    if re.compile(\"\\[ *stable\").search(line) is not None:\n-                        pp = re.compile('since *= *\"([\\w\\.]*)\"')\n-                        mm = pp.search(line)\n-                        if not mm is None:\n-                            since = mm.group(1)\n-                        else:\n-                            print(\"error: misformed stability attribute\")\n-                            print(\"line %d of %:\" % (line_num, path))\n-                            print(line)\n-                            errors = True\n-\n-                    lib_features[feature_name] = feature_name\n-                    if lib_features_and_level.get((feature_name, level)) is None:\n-                        # Add it to the observed features\n-                        lib_features_and_level[(feature_name, level)] = \\\n-                            (since, path, line_num, line)\n-                    else:\n-                        # Verify that for this combination of feature_name and level the 'since'\n-                        # attribute matches.\n-                        (expected_since, source_path, source_line_num, source_line) = \\\n-                            lib_features_and_level.get((feature_name, level))\n-                        if since != expected_since:\n-                            print(\"error: mismatch in %s feature '%s'\" % (level, feature_name))\n-                            print(\"line %d of %s:\" % (source_line_num, source_path))\n-                            print(source_line)\n-                            print(\"line %d of %s:\" % (line_num, path))\n-                            print(line)\n-                            errors = True\n-\n-                    # Verify that this lib feature doesn't duplicate a lang feature\n-                    if feature_name in language_feature_names:\n-                        print(\"error: lib feature '%s' duplicates a lang feature\" % (feature_name))\n-                        print(\"line %d of %s:\" % (line_num, path))\n-                        print(line)\n-                        errors = True\n-\n-                else:\n-                    print(\"error: misformed stability attribute\")\n-                    print(\"line %d of %s:\" % (line_num, path))\n-                    print(line)\n-                    errors = True\n-\n-# Merge data about both lists\n-# name, lang, lib, status, stable since\n-\n-language_feature_stats = {}\n-\n-for f in language_features:\n-    name = f[0]\n-    lang = True\n-    lib = False\n-    status = \"unstable\"\n-    stable_since = None\n-\n-    if f[3] == \"Accepted\":\n-        status = \"stable\"\n-    if status == \"stable\":\n-        stable_since = f[1]\n-\n-    language_feature_stats[name] = (name, lang, lib, status, stable_since)\n-\n-lib_feature_stats = {}\n-\n-for f in lib_features:\n-    name = f\n-    lang = False\n-    lib = True\n-    status = \"unstable\"\n-    stable_since = None\n-\n-    is_stable = lib_features_and_level.get((name, \"stable\")) is not None\n-    is_unstable = lib_features_and_level.get((name, \"unstable\")) is not None\n-\n-    if is_stable and is_unstable:\n-        print(\"error: feature '%s' is both stable and unstable\" % (name))\n-        errors = True\n-\n-    if is_stable:\n-        status = \"stable\"\n-        stable_since = lib_features_and_level[(name, \"stable\")][0]\n-    elif is_unstable:\n-        status = \"unstable\"\n-\n-    lib_feature_stats[name] = (name, lang, lib, status, stable_since)\n-\n-# Check for overlap in two sets\n-merged_stats = { }\n-\n-for name in lib_feature_stats:\n-    if language_feature_stats.get(name) is not None:\n-        if not name in joint_features:\n-            print(\"error: feature '%s' is both a lang and lib feature but not whitelisted\" % (name))\n-            errors = True\n-        lang_status = language_feature_stats[name][3]\n-        lib_status = lib_feature_stats[name][3]\n-        lang_stable_since = language_feature_stats[name][4]\n-        lib_stable_since = lib_feature_stats[name][4]\n-\n-        if lang_status != lib_status and lib_status != \"rustc_deprecated\":\n-            print(\"error: feature '%s' has lang status %s \" +\n-                  \"but lib status %s\" % (name, lang_status, lib_status))\n-            errors = True\n-\n-        if lang_stable_since != lib_stable_since:\n-            print(\"error: feature '%s' has lang stable since %s \" +\n-                  \"but lib stable since %s\" % (name, lang_stable_since, lib_stable_since))\n-            errors = True\n-\n-        merged_stats[name] = (name, True, True, lang_status, lang_stable_since)\n-\n-        del language_feature_stats[name]\n-        del lib_feature_stats[name]\n-\n-if errors:\n-    sys.exit(1)\n-\n-# Finally, display the stats\n-stats = {}\n-stats.update(language_feature_stats)\n-stats.update(lib_feature_stats)\n-stats.update(merged_stats)\n-lines = []\n-for s in stats:\n-    s = stats[s]\n-    type_ = \"lang\"\n-    if s[1] and s[2]:\n-        type_ = \"lang/lib\"\n-    elif s[2]:\n-        type_ = \"lib\"\n-    line = \"{: <32}\".format(s[0]) + \\\n-           \"{: <8}\".format(type_) + \\\n-           \"{: <12}\".format(s[3]) + \\\n-           \"{: <8}\".format(str(s[4]))\n-    lines += [line]\n-\n-lines.sort()\n-\n-print\n-for line in lines:\n-    print(\"* \" + line)\n-print"}, {"sha": "aa2a00beae58365c2b1ad0c13ee0836e5abdb36b", "filename": "src/etc/licenseck.py", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1,56 +0,0 @@\n-# Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-import re\n-import os\n-\n-license_re = re.compile(\n-u\"\"\"(#|//) Copyright .* The Rust Project Developers. See the COPYRIGHT\n-\\\\1 file at the top-level directory of this distribution and at\n-\\\\1 http://rust-lang.org/COPYRIGHT.\n-\\\\1\n-\\\\1 Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-\\\\1 http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-\\\\1 <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-\\\\1 option. This file may not be copied, modified, or distributed\n-\\\\1 except according to those terms.\"\"\")\n-\n-exceptions = [\n-    \"libstd/sync/mpsc/mpsc_queue.rs\", # BSD\n-    \"libstd/sync/mpsc/spsc_queue.rs\", # BSD\n-    \"test/bench/shootout-binarytrees.rs\", # BSD\n-    \"test/bench/shootout-chameneos-redux.rs\", # BSD\n-    \"test/bench/shootout-fannkuch-redux.rs\", # BSD\n-    \"test/bench/shootout-fasta.rs\", # BSD\n-    \"test/bench/shootout-fasta-redux.rs\", # BSD\n-    \"test/bench/shootout-k-nucleotide.rs\", # BSD\n-    \"test/bench/shootout-mandelbrot.rs\", # BSD\n-    \"test/bench/shootout-meteor.rs\", # BSD\n-    \"test/bench/shootout-nbody.rs\", # BSD\n-    \"test/bench/shootout-regex-dna.rs\", # BSD\n-    \"test/bench/shootout-reverse-complement.rs\", # BSD\n-    \"test/bench/shootout-spectralnorm.rs\", # BSD\n-    \"test/bench/shootout-threadring.rs\", # BSD\n-]\n-\n-def check_license(name, contents):\n-    name = os.path.normpath(name)\n-    # Whitelist check\n-    if any(name.endswith(os.path.normpath(e)) for e in exceptions):\n-        return True\n-\n-    # Xfail check\n-    firstlineish = contents[:100]\n-    if \"ignore-license\" in firstlineish:\n-        return True\n-\n-    # License check\n-    boilerplate = contents[:500]\n-    return bool(license_re.search(boilerplate))"}, {"sha": "9264646673b5b4b4bc74b7c7a4abaa7e24349477", "filename": "src/etc/tidy.py", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1,230 +0,0 @@\n-# Copyright 2010-2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-import sys\n-import fileinput\n-import subprocess\n-import re\n-import os\n-from licenseck import check_license\n-import snapshot\n-\n-err = 0\n-cols = 100\n-cr_flag = \"ignore-tidy-cr\"\n-tab_flag = \"ignore-tidy-tab\"\n-linelength_flag = \"ignore-tidy-linelength\"\n-\n-interesting_files = ['.rs', '.py', '.js', '.sh', '.c', '.h']\n-uninteresting_files = ['miniz.c', 'jquery', 'rust_android_dummy']\n-stable_whitelist = {\n-    'src/bootstrap',\n-    'src/build_helper',\n-    'src/libcollectionstest',\n-    'src/libcore',\n-    'src/libstd',\n-    'src/rustc/std_shim',\n-    'src/rustc/test_shim',\n-    'src/test'\n-}\n-\n-\n-def report_error_name_no(name, no, s):\n-    global err\n-    print(\"%s:%d: %s\" % (name, no, s))\n-    err = 1\n-\n-\n-def report_err(s):\n-    report_error_name_no(fileinput.filename(), fileinput.filelineno(), s)\n-\n-\n-def report_warn(s):\n-    print(\"%s:%d: %s\" % (fileinput.filename(),\n-                         fileinput.filelineno(),\n-                         s))\n-\n-\n-def do_license_check(name, contents):\n-    if not check_license(name, contents):\n-        report_error_name_no(name, 1, \"incorrect license\")\n-\n-\n-def update_counts(current_name):\n-    global file_counts\n-    global count_other_linted_files\n-\n-    _, ext = os.path.splitext(current_name)\n-\n-    if ext in interesting_files:\n-        file_counts[ext] += 1\n-    else:\n-        count_other_linted_files += 1\n-\n-\n-def interesting_file(f):\n-    if any(x in f for x in uninteresting_files):\n-        return False\n-\n-    return any(os.path.splitext(f)[1] == ext for ext in interesting_files)\n-\n-\n-# Be careful to support Python 2.4, 2.6, and 3.x here!\n-config_proc = subprocess.Popen([\"git\", \"config\", \"core.autocrlf\"],\n-                               stdout=subprocess.PIPE)\n-result = config_proc.communicate()[0]\n-\n-true = \"true\".encode('utf8')\n-autocrlf = result.strip() == true if result is not None else False\n-\n-current_name = \"\"\n-current_contents = \"\"\n-check_tab = True\n-check_cr = True\n-check_linelength = True\n-\n-if len(sys.argv) < 2:\n-    print(\"usage: tidy.py <src-dir>\")\n-    sys.exit(1)\n-\n-src_dir = sys.argv[1]\n-\n-count_lines = 0\n-count_non_blank_lines = 0\n-count_other_linted_files = 0\n-\n-file_counts = {ext: 0 for ext in interesting_files}\n-\n-all_paths = set()\n-needs_unstable_attr = set()\n-\n-try:\n-    for (dirpath, dirnames, filenames) in os.walk(src_dir):\n-        # Skip some third-party directories\n-        skippable_dirs = {\n-            'src/jemalloc',\n-            'src/llvm',\n-            'src/gyp',\n-            'src/libbacktrace',\n-            'src/libuv',\n-            'src/compiler-rt',\n-            'src/rt/hoedown',\n-            'src/rustllvm',\n-            'src/rt/valgrind',\n-            'src/rt/msvc',\n-            'src/rust-installer',\n-            'src/liblibc',\n-        }\n-\n-        dirpath = os.path.normpath(dirpath)\n-        if any(os.path.normpath(d) in dirpath for d in skippable_dirs):\n-            continue\n-\n-        file_names = [os.path.join(dirpath, f) for f in filenames\n-                      if interesting_file(f)\n-                      and not f.endswith(\"_gen.rs\")\n-                      and not \".#\" is f]\n-\n-        if not file_names:\n-            continue\n-\n-        for line in fileinput.input(file_names,\n-                                openhook=fileinput.hook_encoded(\"utf-8\")):\n-\n-            filename = fileinput.filename()\n-\n-            if \"tidy.py\" not in filename:\n-                if \"TODO\" in line:\n-                    report_err(\"TODO is deprecated; use FIXME\")\n-                match = re.match(r'^.*/(\\*|/!?)\\s*XXX', line)\n-                if match:\n-                    report_err(\"XXX is no longer necessary, use FIXME\")\n-                match = re.match(r'^.*//\\s*(NOTE.*)$', line)\n-                if match and \"TRAVIS\" not in os.environ:\n-                    m = match.group(1)\n-                    if \"snap\" in m.lower():\n-                        report_warn(match.group(1))\n-                match = re.match(r'^.*//\\s*SNAP\\s+(\\w+)', line)\n-                if match:\n-                    hsh = match.group(1)\n-                    date, rev = snapshot.curr_snapshot_rev()\n-                    if not hsh.startswith(rev):\n-                        report_err(\"snapshot out of date (\" + date\n-                            + \"): \" + line)\n-                else:\n-                    if \"SNAP \" in line:\n-                        report_warn(\"unmatched SNAP line: \" + line)\n-                search = re.search(r'^#!\\[unstable', line)\n-                if search:\n-                    needs_unstable_attr.discard(filename)\n-\n-            if cr_flag in line:\n-                check_cr = False\n-            if tab_flag in line:\n-                check_tab = False\n-            if linelength_flag in line:\n-                check_linelength = False\n-\n-            if check_tab and ('\\t' in line and\n-                              \"Makefile\" not in filename):\n-                report_err(\"tab character\")\n-            if check_cr and not autocrlf and '\\r' in line:\n-                report_err(\"CR character\")\n-            if line.endswith(\" \\n\") or line.endswith(\"\\t\\n\"):\n-                report_err(\"trailing whitespace\")\n-            line_len = len(line)-2 if autocrlf else len(line)-1\n-\n-            if check_linelength and line_len > cols:\n-                report_err(\"line longer than %d chars\" % cols)\n-\n-            if fileinput.isfirstline():\n-                # This happens at the end of each file except the last.\n-                if current_name != \"\":\n-                    update_counts(current_name)\n-                    assert len(current_contents) > 0\n-                    do_license_check(current_name, current_contents)\n-\n-                current_name = filename\n-                current_contents = \"\"\n-                check_cr = True\n-                check_tab = True\n-                check_linelength = True\n-                if all(f not in filename for f in stable_whitelist) and \\\n-                   re.search(r'src/.*/lib\\.rs', filename):\n-                    needs_unstable_attr.add(filename)\n-\n-            # Put a reasonable limit on the amount of header data we use for\n-            # the licenseck\n-            if len(current_contents) < 1000:\n-                current_contents += line\n-\n-            count_lines += 1\n-            if line.strip():\n-                count_non_blank_lines += 1\n-\n-    if current_name != \"\":\n-        update_counts(current_name)\n-        assert len(current_contents) > 0\n-        do_license_check(current_name, current_contents)\n-    for f in needs_unstable_attr:\n-        report_error_name_no(f, 1, \"requires unstable attribute\")\n-\n-except UnicodeDecodeError as e:\n-    report_err(\"UTF-8 decoding error \" + str(e))\n-\n-print\n-for ext in sorted(file_counts, key=file_counts.get, reverse=True):\n-    print(\"* linted {} {} files\".format(file_counts[ext], ext))\n-print(\"* linted {} other files\".format(count_other_linted_files))\n-print(\"* total lines of code: {}\".format(count_lines))\n-print(\"* total non-blank lines of code: {}\".format(count_non_blank_lines))\n-print()\n-\n-sys.exit(err)"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/librustc_incremental/persist/serialize.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283"}, {"sha": null, "filename": "src/test/auxiliary/specialization_cross_crate_defaults.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate_defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate_defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate_defaults.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18"}, {"sha": "39b8482cfa30edd289f392bb7539c5585c47da06", "filename": "src/test/compile-fail/regions-wf-trait-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -6,7 +6,7 @@\n // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n-// except according to those terms.t\n+// except according to those terms.\n \n // Check that the explicit lifetime bound (`'b`, in this example) must\n // outlive all the superbound from the trait (`'a`, in this example)."}, {"sha": null, "filename": "src/test/compile-fail/specialization/specialization-polarity.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-polarity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-polarity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-polarity.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18"}, {"sha": "3066947052294caa54c41630fb3b7fed44de07ea", "filename": "src/test/run-make/compiler-lookup-paths/native.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2Fnative.c", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2Fnative.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2Fnative.c?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms."}, {"sha": "a64fbb6afd61d84320a6e12b36522c65aebdbc09", "filename": "src/test/run-pass/issue-11577.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Frun-pass%2Fissue-11577.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Frun-pass%2Fissue-11577.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11577.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -1,4 +1,4 @@\n- // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}, {"sha": "fb7ffdcd515bb4a7370e1191cefbe2e700cea4ca", "filename": "src/test/run-pass/issue-9382.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9382.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -1,6 +1,6 @@\n // pretty-expanded FIXME #23616\n \n- // Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}, {"sha": "acaf9e5550fd388c6338c63632d2dd950f094895", "filename": "src/tools/tidy/Cargo.lock", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.lock?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -0,0 +1,4 @@\n+[root]\n+name = \"tidy\"\n+version = \"0.1.0\"\n+"}, {"sha": "e900bd47fb7bdd3828af775bed2c52b87f267396", "filename": "src/tools/tidy/Cargo.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -0,0 +1,6 @@\n+[package]\n+name = \"tidy\"\n+version = \"0.1.0\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+\n+[dependencies]"}, {"sha": "84d3ff2b238bbceeb88f11ebc3bc34d63045d6d3", "filename": "src/tools/tidy/src/bins.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tidy check to ensure that there are no binaries checked into the source tree\n+//! by accident.\n+//!\n+//! In the past we've accidentally checked in test binaries and such which add a\n+//! huge amount of bloat to the git history, so it's good to just ensure we\n+//! don't do that again :)\n+\n+use std::path::Path;\n+\n+// All files are executable on Windows, so just check on Unix\n+#[cfg(windows)]\n+pub fn check(_path: &Path, _bad: &mut bool) {}\n+\n+#[cfg(unix)]\n+pub fn check(path: &Path, bad: &mut bool) {\n+    use std::fs;\n+    use std::os::unix::prelude::*;\n+\n+    super::walk(path,\n+                &mut |path| super::filter_dirs(path) || path.ends_with(\"src/etc\"),\n+                &mut |file| {\n+        let filename = file.file_name().unwrap().to_string_lossy();\n+        let extensions = [\".py\", \".sh\"];\n+        if extensions.iter().any(|e| filename.ends_with(e)) {\n+            return\n+        }\n+\n+        let metadata = t!(fs::metadata(&file));\n+        if metadata.mode() & 0o111 != 0 {\n+            println!(\"binary checked into source: {}\", file.display());\n+            *bad = true;\n+        }\n+    })\n+}\n+"}, {"sha": "21ec9270429e9a29e7b624799a77a4fd96e1b06f", "filename": "src/tools/tidy/src/errors.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tidy check to verify the validity of long error diagnostic codes.\n+//!\n+//! This ensures that error codes are used at most once and also prints out some\n+//! statistics about the error codes.\n+\n+use std::collections::HashMap;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    let mut contents = String::new();\n+    let mut map = HashMap::new();\n+    super::walk(path,\n+                &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n+                &mut |file| {\n+        let filename = file.file_name().unwrap().to_string_lossy();\n+        if filename != \"diagnostics.rs\" {\n+            return\n+        }\n+\n+        contents.truncate(0);\n+        t!(t!(File::open(file)).read_to_string(&mut contents));\n+\n+        // In the register_long_diagnostics! macro, entries look like this:\n+        //\n+        // EXXXX: r##\"\n+        // <Long diagnostic message>\n+        // \"##,\n+        //\n+        // and these long messages often have error codes themselves inside\n+        // them, but we don't want to report duplicates in these cases. This\n+        // variable keeps track of whether we're currently inside one of these\n+        // long diagnostic messages.\n+        let mut inside_long_diag = false;\n+        for (num, line) in contents.lines().enumerate() {\n+            if inside_long_diag {\n+                inside_long_diag = !line.contains(\"\\\"##\");\n+                continue\n+            }\n+\n+            let mut search = line;\n+            while let Some(i) = search.find(\"E\") {\n+                search = &search[i + 1..];\n+                let code = if search.len() > 4 {\n+                    search[..4].parse::<u32>()\n+                } else {\n+                    continue\n+                };\n+                let code = match code {\n+                    Ok(n) => n,\n+                    Err(..) => continue,\n+                };\n+                map.entry(code).or_insert(Vec::new())\n+                   .push((file.to_owned(), num + 1, line.to_owned()));\n+                break\n+            }\n+\n+            inside_long_diag = line.contains(\"r##\\\"\");\n+        }\n+    });\n+\n+    let mut max = 0;\n+    println!(\"* {} error codes\", map.len());\n+    for (code, entries) in map {\n+        if code > max {\n+            max = code;\n+        }\n+        if entries.len() == 1 {\n+            continue\n+        }\n+\n+        println!(\"duplicate error code: {}\", code);\n+        for (file, line_num, line) in entries {\n+            println!(\"{}:{}: {}\", file.display(), line_num, line);\n+        }\n+        *bad = true;\n+    }\n+    println!(\"* highest error code: E{:04}\", max);\n+}"}, {"sha": "c665b6e662f0fa1fc439e37d61e8ffbd99528c68", "filename": "src/tools/tidy/src/features.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tidy check to ensure that unstable features are all in order\n+//!\n+//! This check will ensure properties like:\n+//!\n+//! * All stability attributes look reasonably well formed\n+//! * The set of library features is disjoint from the set of language features\n+//! * Library features have at most one stability level\n+//! * Library features have at most one `since` value\n+\n+use std::collections::HashMap;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+const STATUSES: &'static [&'static str] = &[\n+    \"Active\", \"Deprecated\", \"Removed\", \"Accepted\",\n+];\n+\n+struct Feature {\n+    name: String,\n+    since: String,\n+    status: String,\n+}\n+\n+struct LibFeature {\n+    level: String,\n+    since: String,\n+}\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    let features = collect_lang_features(&path.join(\"libsyntax/feature_gate.rs\"));\n+    let mut lib_features = HashMap::<String, LibFeature>::new();\n+\n+    let mut contents = String::new();\n+    super::walk(path,\n+                &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n+                &mut |file| {\n+        let filename = file.file_name().unwrap().to_string_lossy();\n+        if !filename.ends_with(\".rs\") || filename == \"features.rs\" {\n+            return\n+        }\n+\n+        contents.truncate(0);\n+        t!(t!(File::open(file)).read_to_string(&mut contents));\n+\n+        for (i, line) in contents.lines().enumerate() {\n+            let mut err = |msg: &str| {\n+                println!(\"{}:{}: {}\", file.display(), i + 1, msg);\n+                *bad = true;\n+            };\n+            let level = if line.contains(\"[unstable(\") {\n+                \"unstable\"\n+            } else if line.contains(\"[stable(\") {\n+                \"stable\"\n+            } else {\n+                continue\n+            };\n+            let feature_name = match find_attr_val(line, \"feature\") {\n+                Some(name) => name,\n+                None => {\n+                    err(\"malformed stability attribute\");\n+                    continue\n+                }\n+            };\n+            let since = match find_attr_val(line, \"since\") {\n+                Some(name) => name,\n+                None if level == \"stable\" => {\n+                    err(\"malformed stability attribute\");\n+                    continue\n+                }\n+                None => \"None\",\n+            };\n+\n+            if features.iter().any(|f| f.name == feature_name) {\n+                err(\"duplicating a lang feature\");\n+            }\n+            if let Some(ref s) = lib_features.get(feature_name) {\n+                if s.level != level {\n+                    err(\"different stability level than before\");\n+                }\n+                if s.since != since {\n+                    err(\"different `since` than before\");\n+                }\n+                continue\n+            }\n+            lib_features.insert(feature_name.to_owned(), LibFeature {\n+                level: level.to_owned(),\n+                since: since.to_owned(),\n+            });\n+        }\n+    });\n+\n+    let mut lines = Vec::new();\n+    for feature in features {\n+        lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n+                           feature.name, \"lang\", feature.status, feature.since));\n+    }\n+    for (name, feature) in lib_features {\n+        lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n+                           name, \"lib\", feature.level, feature.since));\n+    }\n+\n+    lines.sort();\n+    for line in lines {\n+        println!(\"* {}\", line);\n+    }\n+}\n+\n+fn find_attr_val<'a>(line: &'a str, attr: &str) -> Option<&'a str> {\n+    line.find(attr).and_then(|i| {\n+        line[i..].find(\"\\\"\").map(|j| i + j + 1)\n+    }).and_then(|i| {\n+        line[i..].find(\"\\\"\").map(|j| (i, i + j))\n+    }).map(|(i, j)| {\n+        &line[i..j]\n+    })\n+}\n+\n+fn collect_lang_features(path: &Path) -> Vec<Feature> {\n+    let mut contents = String::new();\n+    t!(t!(File::open(path)).read_to_string(&mut contents));\n+\n+    let mut features = Vec::new();\n+    for line in contents.lines().map(|l| l.trim()) {\n+        if !STATUSES.iter().any(|s| line.contains(s) && line.starts_with(\"(\")) {\n+            continue\n+        }\n+        let mut parts = line.split(\",\");\n+        let name = parts.next().unwrap().replace(\"\\\"\", \"\").replace(\"(\", \"\");\n+        let since = parts.next().unwrap().trim().replace(\"\\\"\", \"\");\n+        let status = match parts.skip(1).next().unwrap() {\n+            s if s.contains(\"Active\") => \"unstable\",\n+            s if s.contains(\"Removed\") => \"unstable\",\n+            s if s.contains(\"Accepted\") => \"stable\",\n+            s => panic!(\"unknown status: {}\", s),\n+        };\n+\n+        features.push(Feature {\n+            name: name,\n+            since: since,\n+            status: status.to_owned(),\n+        });\n+    }\n+    return features\n+}"}, {"sha": "d8acf3250dff92e7acc9dbf645daa59775082141", "filename": "src/tools/tidy/src/main.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tidy checks for source code in this repository\n+//!\n+//! This program runs all of the various tidy checks for style, cleanliness,\n+//! etc. This is run by default on `make check` and as part of the auto\n+//! builders.\n+\n+use std::fs;\n+use std::path::{PathBuf, Path};\n+use std::env;\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+mod bins;\n+mod style;\n+mod errors;\n+mod features;\n+\n+fn main() {\n+    let path = env::args_os().skip(1).next().expect(\"need an argument\");\n+    let path = PathBuf::from(path);\n+\n+    let mut bad = false;\n+    bins::check(&path, &mut bad);\n+    style::check(&path, &mut bad);\n+    errors::check(&path, &mut bad);\n+    features::check(&path, &mut bad);\n+\n+    if bad {\n+        panic!(\"some tidy checks failed\");\n+    }\n+}\n+\n+fn filter_dirs(path: &Path) -> bool {\n+    let skip = [\n+        \"src/jemalloc\",\n+        \"src/llvm\",\n+        \"src/libbacktrace\",\n+        \"src/compiler-rt\",\n+        \"src/rt/hoedown\",\n+        \"src/rustllvm\",\n+        \"src/rust-installer\",\n+        \"src/liblibc\",\n+    ];\n+    skip.iter().any(|p| path.ends_with(p))\n+}\n+\n+\n+fn walk(path: &Path, skip: &mut FnMut(&Path) -> bool, f: &mut FnMut(&Path)) {\n+    for entry in t!(fs::read_dir(path)) {\n+        let entry = t!(entry);\n+        let kind = t!(entry.file_type());\n+        let path = entry.path();\n+        if kind.is_dir() {\n+            if !skip(&path) {\n+                walk(&path, skip, f);\n+            }\n+        } else {\n+            f(&path);\n+        }\n+    }\n+}"}, {"sha": "4c5f72c1e7960d3b4085a5e9edcab7470bd80aad", "filename": "src/tools/tidy/src/style.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd3c54a2c787c79037f5c772b12c7d2d2f87b18/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=9dd3c54a2c787c79037f5c772b12c7d2d2f87b18", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tidy check to enforce various stylistic guidelines on the Rust codebase.\n+//!\n+//! Example checks are:\n+//!\n+//! * No lines over 100 characters\n+//! * No tabs\n+//! * No trailing whitespace\n+//! * No CR characters\n+//! * No `TODO` or `XXX` directives\n+//! * A valid license header is at the top\n+//!\n+//! A number of these checks can be opted-out of with various directives like\n+//! `// ignore-tidy-linelength`.\n+\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+const COLS: usize = 100;\n+const LICENSE: &'static str = \"\\\n+Copyright <year> The Rust Project Developers. See the COPYRIGHT\n+file at the top-level directory of this distribution and at\n+http://rust-lang.org/COPYRIGHT.\n+\n+Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+<LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+option. This file may not be copied, modified, or distributed\n+except according to those terms.\";\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    let mut contents = String::new();\n+    super::walk(path, &mut super::filter_dirs, &mut |file| {\n+        let filename = file.file_name().unwrap().to_string_lossy();\n+        let extensions = [\".rs\", \".py\", \".js\", \".sh\", \".c\", \".h\"];\n+        if extensions.iter().all(|e| !filename.ends_with(e)) ||\n+           filename.starts_with(\".#\") {\n+            return\n+        }\n+        if filename == \"miniz.c\" || filename.contains(\"jquery\") {\n+            return\n+        }\n+\n+        contents.truncate(0);\n+        t!(t!(File::open(file)).read_to_string(&mut contents));\n+        let skip_cr = contents.contains(\"ignore-tidy-cr\");\n+        let skip_tab = contents.contains(\"ignore-tidy-tab\");\n+        let skip_length = contents.contains(\"ignore-tidy-linelength\");\n+        for (i, line) in contents.split(\"\\n\").enumerate() {\n+            let mut err = |msg: &str| {\n+                println!(\"{}:{}: {}\", file.display(), i + 1, msg);\n+                *bad = true;\n+            };\n+            if line.chars().count() > COLS && !skip_length {\n+                err(&format!(\"line longer than {} chars\", COLS));\n+            }\n+            if line.contains(\"\\t\") && !skip_tab {\n+                err(\"tab character\");\n+            }\n+            if line.ends_with(\" \") || line.ends_with(\"\\t\") {\n+                err(\"trailing whitespace\");\n+            }\n+            if line.contains(\"\\r\") && !skip_cr {\n+                err(\"CR character\");\n+            }\n+            if filename != \"style.rs\" && filename != \"tidy.py\" {\n+                if line.contains(\"TODO\") {\n+                    err(\"TODO is deprecated; use FIXME\")\n+                }\n+                if line.contains(\"//\") && line.contains(\" XXX\") {\n+                    err(\"XXX is deprecated; use FIXME\")\n+                }\n+            }\n+        }\n+        if !licenseck(file, &contents) {\n+            println!(\"{}: incorrect license\", file.display());\n+            *bad = true;\n+        }\n+    })\n+}\n+\n+fn licenseck(file: &Path, contents: &str) -> bool {\n+    if contents.contains(\"ignore-license\") {\n+        return true\n+    }\n+    let exceptions = [\n+        \"libstd/sync/mpsc/mpsc_queue.rs\",\n+        \"libstd/sync/mpsc/spsc_queue.rs\",\n+    ];\n+    if exceptions.iter().any(|f| file.ends_with(f)) {\n+        return true\n+    }\n+\n+    // Skip the BOM if it's there\n+    let bom = \"\\u{feff}\";\n+    let contents = if contents.starts_with(bom) {&contents[3..]} else {contents};\n+\n+    // See if the license shows up in the first 100 lines\n+    let lines = contents.lines().take(100).collect::<Vec<_>>();\n+    lines.windows(LICENSE.lines().count()).any(|window| {\n+        let offset = if window.iter().all(|w| w.starts_with(\"//\")) {\n+            2\n+        } else if window.iter().all(|w| w.starts_with(\"#\")) {\n+            1\n+        } else {\n+            return false\n+        };\n+        window.iter().map(|a| a[offset..].trim())\n+              .zip(LICENSE.lines()).all(|(a, b)| {\n+            a == b || match b.find(\"<year>\") {\n+                Some(i) => a.starts_with(&b[..i]) && a.ends_with(&b[i+6..]),\n+                None => false,\n+            }\n+        })\n+    })\n+\n+}"}]}