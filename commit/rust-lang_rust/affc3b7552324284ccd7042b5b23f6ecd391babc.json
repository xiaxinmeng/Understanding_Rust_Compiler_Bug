{"sha": "affc3b7552324284ccd7042b5b23f6ecd391babc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZmMzYjc1NTIzMjQyODRjY2Q3MDQyYjViMjNmNmVjZDM5MWJhYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-25T06:15:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-25T06:15:59Z"}, "message": "Auto merge of #37292 - jseyfried:import_macros_in_resolve, r=nrc\n\nProcess `#[macro_use]` imports in `resolve` and clean up macro loading\n\nGroundwork macro modularization (cc #35896).\nr? @nrc", "tree": {"sha": "8651a915b3151a8c74996cfc2133effc2a6a133f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8651a915b3151a8c74996cfc2133effc2a6a133f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/affc3b7552324284ccd7042b5b23f6ecd391babc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/affc3b7552324284ccd7042b5b23f6ecd391babc", "html_url": "https://github.com/rust-lang/rust/commit/affc3b7552324284ccd7042b5b23f6ecd391babc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/affc3b7552324284ccd7042b5b23f6ecd391babc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a208648daa5ed2697527e0c6b79c0697f3950d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a208648daa5ed2697527e0c6b79c0697f3950d8", "html_url": "https://github.com/rust-lang/rust/commit/7a208648daa5ed2697527e0c6b79c0697f3950d8"}, {"sha": "5e8951d331b4c1baef83b5b051eb4927c964c02c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8951d331b4c1baef83b5b051eb4927c964c02c", "html_url": "https://github.com/rust-lang/rust/commit/5e8951d331b4c1baef83b5b051eb4927c964c02c"}], "stats": {"total": 1132, "additions": 490, "deletions": 642}, "files": [{"sha": "562156e70bd99263c2e5853fbbd109a178570677", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -716,8 +716,6 @@ impl<'a> LoweringContext<'a> {\n             id: m.id,\n             span: m.span,\n             imported_from: m.imported_from.map(|x| x.name),\n-            export: m.export,\n-            use_locally: m.use_locally,\n             allow_internal_unstable: m.allow_internal_unstable,\n             body: m.body.clone().into(),\n         }"}, {"sha": "1de4355ccdfd483fc81791f72c1a763a8b25f757", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -458,8 +458,6 @@ pub struct MacroDef {\n     pub id: NodeId,\n     pub span: Span,\n     pub imported_from: Option<Name>,\n-    pub export: bool,\n-    pub use_locally: bool,\n     pub allow_internal_unstable: bool,\n     pub body: HirVec<TokenTree>,\n }"}, {"sha": "a3a84f51780fb0850a19cdf51cde1a67f528c0a3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -37,7 +37,7 @@ use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::MultiItemModifier;\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n@@ -417,18 +417,22 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub struct LoadedMacro {\n-    pub import_site: Span,\n-    pub kind: LoadedMacroKind,\n+pub enum LoadedMacros {\n+    MacroRules(Vec<ast::MacroDef>),\n+    ProcMacros(Vec<(ast::Name, SyntaxExtension)>),\n }\n \n-pub enum LoadedMacroKind {\n-    Def(ast::MacroDef),\n-    CustomDerive(String, Box<MultiItemModifier>),\n+impl LoadedMacros {\n+    pub fn is_proc_macros(&self) -> bool {\n+        match *self {\n+            LoadedMacros::ProcMacros(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n pub trait CrateLoader {\n-    fn load_macros(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n-    fn process_item(&mut self, item: &ast::Item, defs: &Definitions);\n+    fn process_item(&mut self, item: &ast::Item, defs: &Definitions, load_macros: bool)\n+                    -> Option<LoadedMacros>;\n     fn postprocess(&mut self, krate: &ast::Crate);\n }"}, {"sha": "51c894e1b78f04a99ad322bc5a7dd68432580b4d", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -675,13 +675,11 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_macro_def(&mut self, macro_def: &'tcx MacroDef) {\n         debug!(\"visit_macro_def: st={:?}\", self.st);\n-        if macro_def.export {\n-            SawMacroDef.hash(self.st);\n-            hash_attrs!(self, &macro_def.attrs);\n-            visit::walk_macro_def(self, macro_def)\n-            // FIXME(mw): We should hash the body of the macro too but we don't\n-            //            have a stable way of doing so yet.\n-        }\n+        SawMacroDef.hash(self.st);\n+        hash_attrs!(self, &macro_def.attrs);\n+        visit::walk_macro_def(self, macro_def)\n+        // FIXME(mw): We should hash the body of the macro too but we don't\n+        //            have a stable way of doing so yet.\n     }\n }\n "}, {"sha": "d160d29af7da38c28b4118f6d68eee79a74cc7e6", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -12,19 +12,18 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n-use macro_import;\n use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::LoadedMacro;\n+use rustc::middle::cstore::LoadedMacros;\n use rustc::session::{config, Session};\n use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::Definitions;\n \n use std::cell::{RefCell, Cell};\n use std::ops::Deref;\n@@ -36,7 +35,8 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax::parse;\n use syntax::attr;\n-use syntax::parse::token::InternedString;\n+use syntax::ext::base::SyntaxExtension;\n+use syntax::parse::token::{InternedString, intern};\n use syntax_pos::{self, Span, mk_sp};\n use log;\n \n@@ -120,11 +120,6 @@ struct ExtensionCrate {\n     metadata: PMDSource,\n     dylib: Option<PathBuf>,\n     target_only: bool,\n-\n-    ident: String,\n-    name: String,\n-    span: Span,\n-    should_link: bool,\n }\n \n enum PMDSource {\n@@ -148,17 +143,6 @@ enum LoadResult {\n     Loaded(Library),\n }\n \n-pub struct Macros {\n-    pub macro_rules: Vec<ast::MacroDef>,\n-\n-    /// An array of pairs where the first element is the name of the custom\n-    /// derive (e.g. the trait being derived) and the second element is the\n-    /// index of the definition.\n-    pub custom_derive_registrar: Option<DefIndex>,\n-    pub svh: Svh,\n-    pub dylib: Option<PathBuf>,\n-}\n-\n impl<'a> CrateLoader<'a> {\n     pub fn new(sess: &'a Session,\n                cstore: &'a CStore,\n@@ -490,7 +474,6 @@ impl<'a> CrateLoader<'a> {\n               info.id, info.name, info.ident, info.should_link);\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n-        let mut should_link = info.should_link && !is_cross;\n         let mut target_only = false;\n         let ident = info.ident.clone();\n         let name = info.name.clone();\n@@ -517,7 +500,6 @@ impl<'a> CrateLoader<'a> {\n             // Try loading from target crates. This will abort later if we\n             // try to load a plugin registrar function,\n             target_only = true;\n-            should_link = info.should_link;\n \n             locate_ctxt.target = &self.sess.target.target;\n             locate_ctxt.triple = target_triple;\n@@ -547,25 +529,14 @@ impl<'a> CrateLoader<'a> {\n             metadata: metadata,\n             dylib: dylib.map(|p| p.0),\n             target_only: target_only,\n-            name: info.name.to_string(),\n-            ident: info.ident.to_string(),\n-            span: span,\n-            should_link: should_link,\n         }\n     }\n \n-    pub fn read_macros(&mut self, item: &ast::Item) -> Macros {\n-        let ci = self.extract_crate_info(item).unwrap();\n-        let ekrate = self.read_extension_crate(item.span, &ci);\n-\n+    fn read_macros(&mut self, item: &ast::Item, ekrate: &ExtensionCrate) -> LoadedMacros {\n         let root = ekrate.metadata.get_root();\n         let source_name = format!(\"<{} macros>\", item.ident);\n-        let mut ret = Macros {\n-            macro_rules: Vec::new(),\n-            custom_derive_registrar: None,\n-            svh: root.hash,\n-            dylib: None,\n-        };\n+        let mut macro_rules = Vec::new();\n+\n         for def in root.macro_defs.decode(&*ekrate.metadata) {\n             // NB: Don't use parse::parse_tts_from_source_str because it parses with\n             // quote_depth > 0.\n@@ -589,54 +560,90 @@ impl<'a> CrateLoader<'a> {\n                 attr::mark_used(attr);\n             }\n \n-            ret.macro_rules.push(ast::MacroDef {\n+            macro_rules.push(ast::MacroDef {\n                 ident: ast::Ident::with_empty_ctxt(def.name),\n-                attrs: def.attrs,\n                 id: ast::DUMMY_NODE_ID,\n                 span: local_span,\n                 imported_from: Some(item.ident),\n-                // overridden in plugin/load.rs\n-                export: false,\n-                use_locally: false,\n-                allow_internal_unstable: false,\n-\n+                allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n+                attrs: def.attrs,\n                 body: body,\n             });\n             self.sess.imported_macro_spans.borrow_mut()\n                 .insert(local_span, (def.name.as_str().to_string(), def.span));\n         }\n \n-        match root.macro_derive_registrar {\n-            Some(id) => ret.custom_derive_registrar = Some(id),\n-\n-            // If this crate is not a proc-macro crate then we might be able to\n-            // register it with the local crate store to prevent loading the\n-            // metadata twice.\n-            //\n-            // If it's a proc-macro crate, though, then we definitely don't\n-            // want to register it with the local crate store as we're just\n-            // going to use it as we would a plugin.\n-            None => {\n-                ekrate.register(self);\n-                return ret\n+        if let Some(id) = root.macro_derive_registrar {\n+            let dylib = match ekrate.dylib.clone() {\n+                Some(dylib) => dylib,\n+                None => span_bug!(item.span, \"proc-macro crate not dylib\"),\n+            };\n+            if ekrate.target_only {\n+                let message = format!(\"proc-macro crate is not available for \\\n+                                       triple `{}` (only found {})\",\n+                                      config::host_triple(),\n+                                      self.sess.opts.target_triple);\n+                self.sess.span_fatal(item.span, &message);\n             }\n-        }\n \n-        self.cstore.add_used_for_derive_macros(item);\n-        ret.dylib = ekrate.dylib.clone();\n-        if ret.dylib.is_none() {\n-            span_bug!(item.span, \"proc-macro crate not dylib\");\n+            // custom derive crates currently should not have any macro_rules!\n+            // exported macros, enforced elsewhere\n+            assert_eq!(macro_rules.len(), 0);\n+            LoadedMacros::ProcMacros(self.load_derive_macros(item, id, root.hash, dylib))\n+        } else {\n+            LoadedMacros::MacroRules(macro_rules)\n         }\n+    }\n \n-        if ekrate.target_only {\n-            let message = format!(\"proc-macro crate is not available for \\\n-                                   triple `{}` (only found {})\",\n-                                  config::host_triple(),\n-                                  self.sess.opts.target_triple);\n-            self.sess.span_fatal(item.span, &message);\n+    /// Load custom derive macros.\n+    ///\n+    /// Note that this is intentionally similar to how we load plugins today,\n+    /// but also intentionally separate. Plugins are likely always going to be\n+    /// implemented as dynamic libraries, but we have a possible future where\n+    /// custom derive (and other macro-1.1 style features) are implemented via\n+    /// executables and custom IPC.\n+    fn load_derive_macros(&mut self, item: &ast::Item, index: DefIndex, svh: Svh, path: PathBuf)\n+                          -> Vec<(ast::Name, SyntaxExtension)> {\n+        use std::{env, mem};\n+        use proc_macro::TokenStream;\n+        use proc_macro::__internal::Registry;\n+        use rustc_back::dynamic_lib::DynamicLibrary;\n+        use syntax_ext::deriving::custom::CustomDerive;\n+\n+        // Make sure the path contains a / or the linker will search for it.\n+        let path = env::current_dir().unwrap().join(path);\n+        let lib = match DynamicLibrary::open(Some(&path)) {\n+            Ok(lib) => lib,\n+            Err(err) => self.sess.span_fatal(item.span, &err),\n+        };\n+\n+        let sym = self.sess.generate_derive_registrar_symbol(&svh, index);\n+        let registrar = unsafe {\n+            let sym = match lib.symbol(&sym) {\n+                Ok(f) => f,\n+                Err(err) => self.sess.span_fatal(item.span, &err),\n+            };\n+            mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n+        };\n+\n+        struct MyRegistrar(Vec<(ast::Name, SyntaxExtension)>);\n+\n+        impl Registry for MyRegistrar {\n+            fn register_custom_derive(&mut self,\n+                                      trait_name: &str,\n+                                      expand: fn(TokenStream) -> TokenStream) {\n+                let derive = SyntaxExtension::CustomDerive(Box::new(CustomDerive::new(expand)));\n+                self.0.push((intern(trait_name), derive));\n+            }\n         }\n \n-        return ret\n+        let mut my_registrar = MyRegistrar(Vec::new());\n+        registrar(&mut my_registrar);\n+\n+        // Intentionally leak the dynamic library. We can't ever unload it\n+        // since the library can make things that will live arbitrarily long.\n+        mem::forget(lib);\n+        my_registrar.0\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate\n@@ -889,22 +896,6 @@ impl<'a> CrateLoader<'a> {\n     }\n }\n \n-impl ExtensionCrate {\n-    fn register(self, loader: &mut CrateLoader) {\n-        if !self.should_link {\n-            return\n-        }\n-\n-        let library = match self.metadata {\n-            PMDSource::Owned(lib) => lib,\n-            PMDSource::Registered(_) => return,\n-        };\n-\n-        // Register crate now to avoid double-reading metadata\n-        loader.register_crate(&None, &self.ident, &self.name, self.span, library, true);\n-    }\n-}\n-\n impl<'a> CrateLoader<'a> {\n     pub fn preprocess(&mut self, krate: &ast::Crate) {\n         for attr in krate.attrs.iter().filter(|m| m.name() == \"link_args\") {\n@@ -990,47 +981,56 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         self.register_statically_included_foreign_items();\n     }\n \n-    fn process_item(&mut self, item: &ast::Item, definitions: &hir_map::Definitions) {\n+    fn process_item(&mut self, item: &ast::Item, definitions: &Definitions, load_macros: bool)\n+                    -> Option<LoadedMacros> {\n         match item.node {\n             ast::ItemKind::ExternCrate(_) => {}\n-            ast::ItemKind::ForeignMod(ref fm) => return self.process_foreign_mod(item, fm),\n-            _ => return,\n+            ast::ItemKind::ForeignMod(ref fm) => {\n+                self.process_foreign_mod(item, fm);\n+                return None;\n+            }\n+            _ => return None,\n         }\n \n-        // If this `extern crate` item has `#[macro_use]` then we can safely skip it.\n-        // These annotations were processed during macro expansion and are already loaded\n-        // (if necessary) into our crate store.\n-        //\n-        // Note that it's important we *don't* fall through below as some `#[macro_use]`\n-        // crates are explicitly not linked (e.g. macro crates) so we want to ensure\n-        // we avoid `resolve_crate` with those.\n-        if attr::contains_name(&item.attrs, \"macro_use\") {\n-            if self.cstore.was_used_for_derive_macros(item) {\n-                return\n+        let info = self.extract_crate_info(item).unwrap();\n+        let loaded_macros = if load_macros {\n+            let ekrate = self.read_extension_crate(item.span, &info);\n+            let loaded_macros = self.read_macros(item, &ekrate);\n+\n+            // If this is a proc-macro crate or `#[no_link]` crate, it is only used at compile time,\n+            // so we return here to avoid registering the crate.\n+            if loaded_macros.is_proc_macros() || !info.should_link {\n+                return Some(loaded_macros);\n             }\n-        }\n \n-        if let Some(info) = self.extract_crate_info(item) {\n-            if !info.should_link {\n-                return;\n+            // Register crate now to avoid double-reading metadata\n+            if let PMDSource::Owned(lib) = ekrate.metadata {\n+                if ekrate.target_only || config::host_triple() == self.sess.opts.target_triple {\n+                    let ExternCrateInfo { ref ident, ref name, .. } = info;\n+                    self.register_crate(&None, ident, name, item.span, lib, true);\n+                }\n             }\n \n-            let (cnum, ..) = self.resolve_crate(\n-                &None, &info.ident, &info.name, None, item.span, PathKind::Crate, true,\n-            );\n+            Some(loaded_macros)\n+        } else {\n+            if !info.should_link {\n+                return None;\n+            }\n+            None\n+        };\n \n-            let def_id = definitions.opt_local_def_id(item.id).unwrap();\n-            let len = definitions.def_path(def_id.index).data.len();\n+        let (cnum, ..) = self.resolve_crate(\n+            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, true,\n+        );\n \n-            let extern_crate =\n-                ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n-            self.update_extern_crate(cnum, extern_crate, &mut FnvHashSet());\n+        let def_id = definitions.opt_local_def_id(item.id).unwrap();\n+        let len = definitions.def_path(def_id.index).data.len();\n \n-            self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-        }\n-    }\n+        let extern_crate =\n+            ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n+        self.update_extern_crate(cnum, extern_crate, &mut FnvHashSet());\n+        self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n \n-    fn load_macros(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n-        macro_import::load_macros(self, extern_crate, allows_macros)\n+        loaded_macros\n     }\n }"}, {"sha": "58c70f959b7cc35d058c25549bc75a2382367066", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -21,14 +21,13 @@ use rustc::hir::svh::Svh;\n use rustc::middle::cstore::ExternCrate;\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap, FnvHashSet};\n+use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n-use syntax::ast::{self, Ident};\n-use syntax::attr;\n+use syntax::{ast, attr};\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibraryKind, LinkagePreference};\n@@ -105,7 +104,6 @@ pub struct CStore {\n     pub inlined_item_cache: RefCell<DefIdMap<Option<CachedInlinedItem>>>,\n     pub defid_for_inlined_node: RefCell<NodeMap<DefId>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n-    pub used_for_derive_macro: RefCell<FnvHashSet<Ident>>,\n }\n \n impl CStore {\n@@ -121,7 +119,6 @@ impl CStore {\n             visible_parent_map: RefCell::new(FnvHashMap()),\n             inlined_item_cache: RefCell::new(FnvHashMap()),\n             defid_for_inlined_node: RefCell::new(FnvHashMap()),\n-            used_for_derive_macro: RefCell::new(FnvHashSet()),\n         }\n     }\n \n@@ -279,14 +276,6 @@ impl CStore {\n     pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n-\n-    pub fn was_used_for_derive_macros(&self, i: &ast::Item) -> bool {\n-        self.used_for_derive_macro.borrow().contains(&i.ident)\n-    }\n-\n-    pub fn add_used_for_derive_macros(&self, i: &ast::Item) {\n-        self.used_for_derive_macro.borrow_mut().insert(i.ident);\n-    }\n }\n \n impl CrateMetadata {"}, {"sha": "b2f4760727ae106f2e1e7313db3ad41c59d0a136", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -91,185 +91,6 @@ You need to link your code to the relevant crate in order to be able to use it\n well, and you link to them the same way.\n \"##,\n \n-E0466: r##\"\n-Macro import declarations were malformed.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0466\n-#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n-extern crate core as some_crate;\n-\n-#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n-extern crate core as another_crate;\n-```\n-\n-This is a syntax error at the level of attribute declarations. The proper\n-syntax for macro imports is the following:\n-\n-```ignore\n-// In some_crate:\n-#[macro_export]\n-macro_rules! get_tacos {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! get_pimientos {\n-    ...\n-}\n-\n-// In your crate:\n-#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n-extern crate some_crate;               // `get_pimientos` macros from some_crate\n-```\n-\n-If you would like to import all exported macros, write `macro_use` with no\n-arguments.\n-\"##,\n-\n-E0467: r##\"\n-Macro reexport declarations were empty or malformed.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0467\n-#[macro_reexport]                    // error: no macros listed for export\n-extern crate core as macros_for_good;\n-\n-#[macro_reexport(fun_macro = \"foo\")] // error: not a macro identifier\n-extern crate core as other_macros_for_good;\n-```\n-\n-This is a syntax error at the level of attribute declarations.\n-\n-Currently, `macro_reexport` requires at least one macro name to be listed.\n-Unlike `macro_use`, listing no names does not reexport all macros from the\n-given crate.\n-\n-Decide which macros you would like to export and list them properly.\n-\n-These are proper reexport declarations:\n-\n-```ignore\n-#[macro_reexport(some_macro, another_macro)]\n-extern crate macros_for_good;\n-```\n-\"##,\n-\n-E0468: r##\"\n-A non-root module attempts to import macros from another crate.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0468\n-mod foo {\n-    #[macro_use(helpful_macro)] // error: must be at crate root to import\n-    extern crate core;          //        macros from another crate\n-    helpful_macro!(...);\n-}\n-```\n-\n-Only `extern crate` imports at the crate root level are allowed to import\n-macros.\n-\n-Either move the macro import to crate root or do without the foreign macros.\n-This will work:\n-\n-```ignore\n-#[macro_use(helpful_macro)]\n-extern crate some_crate;\n-\n-mod foo {\n-    helpful_macro!(...)\n-}\n-```\n-\"##,\n-\n-E0469: r##\"\n-A macro listed for import was not found.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0469\n-#[macro_use(drink, be_merry)] // error: imported macro not found\n-extern crate collections;\n-\n-fn main() {\n-    // ...\n-}\n-```\n-\n-Either the listed macro is not contained in the imported crate, or it is not\n-exported from the given crate.\n-\n-This could be caused by a typo. Did you misspell the macro's name?\n-\n-Double-check the names of the macros listed for import, and that the crate\n-in question exports them.\n-\n-A working version would be:\n-\n-```ignore\n-// In some_crate crate:\n-#[macro_export]\n-macro_rules! eat {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! drink {\n-    ...\n-}\n-\n-// In your crate:\n-#[macro_use(eat, drink)]\n-extern crate some_crate; //ok!\n-```\n-\"##,\n-\n-E0470: r##\"\n-A macro listed for reexport was not found.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0470\n-#[macro_reexport(drink, be_merry)]\n-extern crate collections;\n-\n-fn main() {\n-    // ...\n-}\n-```\n-\n-Either the listed macro is not contained in the imported crate, or it is not\n-exported from the given crate.\n-\n-This could be caused by a typo. Did you misspell the macro's name?\n-\n-Double-check the names of the macros listed for reexport, and that the crate\n-in question exports them.\n-\n-A working version:\n-\n-```ignore\n-// In some_crate crate:\n-#[macro_export]\n-macro_rules! eat {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! drink {\n-    ...\n-}\n-\n-// In your_crate:\n-#[macro_reexport(eat, drink)]\n-extern crate some_crate;\n-```\n-\"##,\n-\n }\n \n register_diagnostics! {"}, {"sha": "300c5f0dec71d3f226625b4078683e26033180c5", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -59,6 +59,5 @@ mod schema;\n pub mod creader;\n pub mod cstore;\n pub mod locator;\n-pub mod macro_import;\n \n __build_diagnostic_array! { librustc_metadata, DIAGNOSTICS }"}, {"sha": "ddc254a16d9f496a0a7e7b3fc5e07ee974eec468", "filename": "src/librustc_metadata/macro_import.rs", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -1,235 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Used by `rustc` when loading a crate with exported macros.\n-\n-use std::collections::HashSet;\n-use std::env;\n-use std::mem;\n-\n-use creader::{CrateLoader, Macros};\n-\n-use proc_macro::TokenStream;\n-use proc_macro::__internal::Registry;\n-use rustc::hir::def_id::DefIndex;\n-use rustc::middle::cstore::{LoadedMacro, LoadedMacroKind};\n-use rustc::session::Session;\n-use rustc::util::nodemap::FnvHashMap;\n-use rustc_back::dynamic_lib::DynamicLibrary;\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::parse::token;\n-use syntax_ext::deriving::custom::CustomDerive;\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n-    span_err!(a, b, E0467, \"bad macro reexport\");\n-}\n-\n-pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n-\n-enum ImportSelection {\n-    All(Span),\n-    Some(MacroSelection),\n-}\n-\n-pub fn load_macros(loader: &mut CrateLoader, extern_crate: &ast::Item, allows_macros: bool)\n-                   -> Vec<LoadedMacro> {\n-    loader.load_crate(extern_crate, allows_macros)\n-}\n-\n-impl<'a> CrateLoader<'a> {\n-    fn load_crate(&mut self,\n-                  extern_crate: &ast::Item,\n-                  allows_macros: bool) -> Vec<LoadedMacro> {\n-        // Parse the attributes relating to macros.\n-        let mut import = ImportSelection::Some(FnvHashMap());\n-        let mut reexport = FnvHashMap();\n-        let mut no_link = false;\n-\n-        for attr in &extern_crate.attrs {\n-            let mut used = true;\n-            match &attr.name()[..] {\n-                \"macro_use\" => {\n-                    let names = attr.meta_item_list();\n-                    if names.is_none() {\n-                        import = ImportSelection::All(attr.span);\n-                    } else if let ImportSelection::Some(ref mut sel) = import {\n-                        for attr in names.unwrap() {\n-                            if let Some(word) = attr.word() {\n-                                sel.insert(word.name().clone(), attr.span());\n-                            } else {\n-                                span_err!(self.sess, attr.span(), E0466, \"bad macro import\");\n-                            }\n-                        }\n-                    }\n-                }\n-                \"macro_reexport\" => {\n-                    let names = match attr.meta_item_list() {\n-                        Some(names) => names,\n-                        None => {\n-                            call_bad_macro_reexport(self.sess, attr.span);\n-                            continue;\n-                        }\n-                    };\n-\n-                    for attr in names {\n-                        if let Some(word) = attr.word() {\n-                            reexport.insert(word.name().clone(), attr.span());\n-                        } else {\n-                            call_bad_macro_reexport(self.sess, attr.span());\n-                        }\n-                    }\n-                }\n-                \"no_link\" => no_link = true,\n-                _ => used = false,\n-            }\n-            if used {\n-                attr::mark_used(attr);\n-            }\n-        }\n-\n-        self.load_macros(extern_crate, allows_macros, import, reexport, no_link)\n-    }\n-\n-    fn load_macros<'b>(&mut self,\n-                       vi: &ast::Item,\n-                       allows_macros: bool,\n-                       import: ImportSelection,\n-                       reexport: MacroSelection,\n-                       no_link: bool)\n-                       -> Vec<LoadedMacro> {\n-        if let ImportSelection::Some(ref sel) = import {\n-            if sel.is_empty() && reexport.is_empty() {\n-                // Make sure we can read macros from `#[no_link]` crates.\n-                if no_link {\n-                    self.read_macros(vi);\n-                }\n-                return Vec::new();\n-            }\n-        }\n-\n-        if !allows_macros {\n-            span_err!(self.sess, vi.span, E0468,\n-                      \"an `extern crate` loading macros must be at the crate root\");\n-            return Vec::new();\n-        }\n-\n-        let mut macros = self.read_macros(vi);\n-        let mut ret = Vec::new();\n-        let mut seen = HashSet::new();\n-\n-        for mut def in macros.macro_rules.drain(..) {\n-            let name = def.ident.name.as_str();\n-\n-            let import_site = match import {\n-                ImportSelection::All(span) => Some(span),\n-                ImportSelection::Some(ref sel) => sel.get(&name).cloned()\n-            };\n-            def.use_locally = import_site.is_some();\n-            def.export = reexport.contains_key(&name);\n-            def.allow_internal_unstable = attr::contains_name(&def.attrs,\n-                                                              \"allow_internal_unstable\");\n-            debug!(\"load_macros: loaded: {:?}\", def);\n-            ret.push(LoadedMacro {\n-                kind: LoadedMacroKind::Def(def),\n-                import_site: import_site.unwrap_or(DUMMY_SP),\n-            });\n-            seen.insert(name);\n-        }\n-\n-        if let Some(index) = macros.custom_derive_registrar {\n-            // custom derive crates currently should not have any macro_rules!\n-            // exported macros, enforced elsewhere\n-            assert_eq!(ret.len(), 0);\n-\n-            if let ImportSelection::Some(..) = import {\n-                self.sess.span_err(vi.span, \"`proc-macro` crates cannot be \\\n-                                             selectively imported from, must \\\n-                                             use `#[macro_use]`\");\n-            }\n-\n-            if reexport.len() > 0 {\n-                self.sess.span_err(vi.span, \"`proc-macro` crates cannot be \\\n-                                             reexported from\");\n-            }\n-\n-            self.load_derive_macros(vi.span, &macros, index, &mut ret);\n-        }\n-\n-        if let ImportSelection::Some(sel) = import {\n-            for (name, span) in sel {\n-                if !seen.contains(&name) {\n-                    span_err!(self.sess, span, E0469,\n-                              \"imported macro not found\");\n-                }\n-            }\n-        }\n-\n-        for (name, span) in &reexport {\n-            if !seen.contains(&name) {\n-                span_err!(self.sess, *span, E0470,\n-                          \"reexported macro not found\");\n-            }\n-        }\n-\n-        return ret\n-    }\n-\n-    /// Load the custom derive macros into the list of macros we're loading.\n-    ///\n-    /// Note that this is intentionally similar to how we load plugins today,\n-    /// but also intentionally separate. Plugins are likely always going to be\n-    /// implemented as dynamic libraries, but we have a possible future where\n-    /// custom derive (and other macro-1.1 style features) are implemented via\n-    /// executables and custom IPC.\n-    fn load_derive_macros(&mut self,\n-                          span: Span,\n-                          macros: &Macros,\n-                          index: DefIndex,\n-                          ret: &mut Vec<LoadedMacro>) {\n-        // Make sure the path contains a / or the linker will search for it.\n-        let path = macros.dylib.as_ref().unwrap();\n-        let path = env::current_dir().unwrap().join(path);\n-        let lib = match DynamicLibrary::open(Some(&path)) {\n-            Ok(lib) => lib,\n-            Err(err) => self.sess.span_fatal(span, &err),\n-        };\n-\n-        let sym = self.sess.generate_derive_registrar_symbol(&macros.svh, index);\n-        let registrar = unsafe {\n-            let sym = match lib.symbol(&sym) {\n-                Ok(f) => f,\n-                Err(err) => self.sess.span_fatal(span, &err),\n-            };\n-            mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n-        };\n-\n-        struct MyRegistrar<'a>(&'a mut Vec<LoadedMacro>, Span);\n-\n-        impl<'a> Registry for MyRegistrar<'a> {\n-            fn register_custom_derive(&mut self,\n-                                      trait_name: &str,\n-                                      expand: fn(TokenStream) -> TokenStream) {\n-                let derive = Box::new(CustomDerive::new(expand));\n-                self.0.push(LoadedMacro {\n-                    kind: LoadedMacroKind::CustomDerive(trait_name.to_string(), derive),\n-                    import_site: self.1,\n-                });\n-            }\n-        }\n-\n-        registrar(&mut MyRegistrar(ret, span));\n-\n-        // Intentionally leak the dynamic library. We can't ever unload it\n-        // since the library can make things that will live arbitrarily long.\n-        mem::forget(lib);\n-    }\n-}"}, {"sha": "db86840fd381cf120069e2ef7fbeb5e41a4e3b1e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 160, "deletions": 60, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -21,10 +21,11 @@ use {NameBinding, NameBindingKind, ToNameBinding};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::LoadedMacroKind;\n+use rustc::middle::cstore::LoadedMacros;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n+use rustc::util::nodemap::FnvHashMap;\n \n use std::cell::Cell;\n use std::rc::Rc;\n@@ -58,6 +59,14 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n     }\n }\n \n+#[derive(Default, PartialEq, Eq)]\n+struct LegacyMacroImports {\n+    import_all: Option<Span>,\n+    imports: Vec<(Name, Span)>,\n+    reexports: Vec<(Name, Span)>,\n+    no_link: bool,\n+}\n+\n impl<'b> Resolver<'b> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n@@ -193,57 +202,27 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::ExternCrate(_) => {\n-                // We need to error on `#[macro_use] extern crate` when it isn't at the\n-                // crate root, because `$crate` won't work properly.\n-                let is_crate_root = self.current_module.parent.is_none();\n-                let import_macro = |this: &mut Self, name, ext, span| {\n-                    let shadowing = this.builtin_macros.insert(name, Rc::new(ext)).is_some();\n-                    if shadowing && expansion != Mark::root() {\n-                        let msg = format!(\"`{}` is already in scope\", name);\n-                        this.session.struct_span_err(span, &msg)\n-                            .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n-                                   existing macros (see RFC 1560)\")\n-                            .emit();\n-                    }\n-                };\n-\n-                let mut custom_derive_crate = false;\n-                // The mark of the expansion that generates the loaded macros.\n-                let mut opt_mark = None;\n-                for loaded_macro in self.crate_loader.load_macros(item, is_crate_root) {\n-                    let mark = opt_mark.unwrap_or_else(Mark::fresh);\n-                    opt_mark = Some(mark);\n-                    match loaded_macro.kind {\n-                        LoadedMacroKind::Def(mut def) => {\n-                            if def.use_locally {\n-                                self.macro_names.insert(def.ident.name);\n-                                def.body = mark_tts(&def.body, mark);\n-                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                                import_macro(self, def.ident.name, ext, loaded_macro.import_site);\n-                            }\n-                            if def.export {\n-                                def.id = self.next_node_id();\n-                                self.exported_macros.push(def);\n-                            }\n-                        }\n-                        LoadedMacroKind::CustomDerive(name, ext) => {\n-                            custom_derive_crate = true;\n-                            let ext = SyntaxExtension::CustomDerive(ext);\n-                            import_macro(self, token::intern(&name), ext, loaded_macro.import_site);\n-                        }\n+                let legacy_imports = self.legacy_macro_imports(&item.attrs);\n+                // `#[macro_use]` and `#[macro_reexport]` are only allowed at the crate root.\n+                if self.current_module.parent.is_some() && {\n+                    legacy_imports.import_all.is_some() || !legacy_imports.imports.is_empty() ||\n+                    !legacy_imports.reexports.is_empty()\n+                } {\n+                    if self.current_module.parent.is_some() {\n+                        span_err!(self.session, item.span, E0468,\n+                                  \"an `extern crate` loading macros must be at the crate root\");\n                     }\n                 }\n \n-                if custom_derive_crate && !self.session.features.borrow().proc_macro {\n-                    let issue = feature_gate::GateIssue::Language;\n-                    let msg = \"loading custom derive macro crates is experimentally supported\";\n-                    emit_feature_err(&self.session.parse_sess, \"proc_macro\", item.span, issue, msg);\n-                }\n-\n-                self.crate_loader.process_item(item, &self.definitions);\n+                let loaded_macros = if legacy_imports != LegacyMacroImports::default() {\n+                    self.crate_loader.process_item(item, &self.definitions, true)\n+                } else {\n+                    self.crate_loader.process_item(item, &self.definitions, false)\n+                };\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                if let Some(crate_id) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n+                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id);\n+                let module = if let Some(crate_id) = crate_id {\n                     let def_id = DefId {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n@@ -254,25 +233,21 @@ impl<'b> Resolver<'b> {\n                         ..ModuleS::new(Some(parent), ModuleKind::Def(Def::Mod(def_id), name))\n                     });\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n-\n-                    if let Some(mark) = opt_mark {\n-                        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n-                            module: Cell::new(module),\n-                            def_index: CRATE_DEF_INDEX,\n-                            const_integer: false,\n-                            legacy_scope: Cell::new(LegacyScope::Empty),\n-                            expansion: Cell::new(LegacyScope::Empty),\n-                        });\n-                        self.invocations.insert(mark, invocation);\n-                    }\n-\n                     self.populate_module_if_necessary(module);\n+                    module\n                 } else {\n                     // Define an empty module\n                     let def = Def::Mod(self.definitions.local_def_id(item.id));\n                     let module = ModuleS::new(Some(parent), ModuleKind::Def(def, name));\n                     let module = self.arenas.alloc_module(module);\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n+                    module\n+                };\n+\n+                if let Some(loaded_macros) = loaded_macros {\n+                    self.import_extern_crate_macros(\n+                        item, module, loaded_macros, legacy_imports, expansion == Mark::root(),\n+                    );\n                 }\n             }\n \n@@ -294,7 +269,9 @@ impl<'b> Resolver<'b> {\n                 self.current_module = module;\n             }\n \n-            ItemKind::ForeignMod(..) => self.crate_loader.process_item(item, &self.definitions),\n+            ItemKind::ForeignMod(..) => {\n+                self.crate_loader.process_item(item, &self.definitions, false);\n+            }\n \n             // These items live in the value namespace.\n             ItemKind::Static(_, m, _) => {\n@@ -516,6 +493,93 @@ impl<'b> Resolver<'b> {\n         module.populated.set(true)\n     }\n \n+    fn import_extern_crate_macros(&mut self,\n+                                  extern_crate: &Item,\n+                                  module: Module<'b>,\n+                                  loaded_macros: LoadedMacros,\n+                                  legacy_imports: LegacyMacroImports,\n+                                  allow_shadowing: bool) {\n+        let import_macro = |this: &mut Self, name, ext: Rc<_>, span| {\n+            if let SyntaxExtension::NormalTT(..) = *ext {\n+                this.macro_names.insert(name);\n+            }\n+            if this.builtin_macros.insert(name, ext).is_some() && !allow_shadowing {\n+                let msg = format!(\"`{}` is already in scope\", name);\n+                let note =\n+                    \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n+                this.session.struct_span_err(span, &msg).note(note).emit();\n+            }\n+        };\n+\n+        match loaded_macros {\n+            LoadedMacros::MacroRules(macros) => {\n+                let mark = Mark::fresh();\n+                if !macros.is_empty() {\n+                    let invocation = self.arenas.alloc_invocation_data(InvocationData {\n+                        module: Cell::new(module),\n+                        def_index: CRATE_DEF_INDEX,\n+                        const_integer: false,\n+                        legacy_scope: Cell::new(LegacyScope::Empty),\n+                        expansion: Cell::new(LegacyScope::Empty),\n+                    });\n+                    self.invocations.insert(mark, invocation);\n+                }\n+\n+                let mut macros: FnvHashMap<_, _> = macros.into_iter().map(|mut def| {\n+                    def.body = mark_tts(&def.body, mark);\n+                    let ext = macro_rules::compile(&self.session.parse_sess, &def);\n+                    (def.ident.name, (def, Rc::new(ext)))\n+                }).collect();\n+\n+                if let Some(span) = legacy_imports.import_all {\n+                    for (&name, &(_, ref ext)) in macros.iter() {\n+                        import_macro(self, name, ext.clone(), span);\n+                    }\n+                } else {\n+                    for (name, span) in legacy_imports.imports {\n+                        if let Some(&(_, ref ext)) = macros.get(&name) {\n+                            import_macro(self, name, ext.clone(), span);\n+                        } else {\n+                            span_err!(self.session, span, E0469, \"imported macro not found\");\n+                        }\n+                    }\n+                }\n+                for (name, span) in legacy_imports.reexports {\n+                    if let Some((mut def, _)) = macros.remove(&name) {\n+                        def.id = self.next_node_id();\n+                        self.exported_macros.push(def);\n+                    } else {\n+                        span_err!(self.session, span, E0470, \"reexported macro not found\");\n+                    }\n+                }\n+            }\n+\n+            LoadedMacros::ProcMacros(macros) => {\n+                if !self.session.features.borrow().proc_macro {\n+                    let sess = &self.session.parse_sess;\n+                    let issue = feature_gate::GateIssue::Language;\n+                    let msg =\n+                        \"loading custom derive macro crates is experimentally supported\";\n+                    emit_feature_err(sess, \"proc_macro\", extern_crate.span, issue, msg);\n+                }\n+                if !legacy_imports.imports.is_empty() {\n+                    let msg = \"`proc-macro` crates cannot be selectively imported from, \\\n+                               must use `#[macro_use]`\";\n+                    self.session.span_err(extern_crate.span, msg);\n+                }\n+                if !legacy_imports.reexports.is_empty() {\n+                    let msg = \"`proc-macro` crates cannot be reexported from\";\n+                    self.session.span_err(extern_crate.span, msg);\n+                }\n+                if let Some(span) = legacy_imports.import_all {\n+                    for (name, ext) in macros {\n+                        import_macro(self, name, Rc::new(ext), span);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     // does this attribute list contain \"macro_use\"?\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n@@ -539,6 +603,42 @@ impl<'b> Resolver<'b> {\n \n         false\n     }\n+\n+    fn legacy_macro_imports(&mut self, attrs: &[ast::Attribute]) -> LegacyMacroImports {\n+        let mut imports = LegacyMacroImports::default();\n+        for attr in attrs {\n+            if attr.check_name(\"macro_use\") {\n+                match attr.meta_item_list() {\n+                    Some(names) => for attr in names {\n+                        if let Some(word) = attr.word() {\n+                            imports.imports.push((token::intern(&word.name()), attr.span()));\n+                        } else {\n+                            span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n+                        }\n+                    },\n+                    None => imports.import_all = Some(attr.span),\n+                }\n+            } else if attr.check_name(\"macro_reexport\") {\n+                let bad_macro_reexport = |this: &mut Self, span| {\n+                    span_err!(this.session, span, E0467, \"bad macro reexport\");\n+                };\n+                if let Some(names) = attr.meta_item_list() {\n+                    for attr in names {\n+                        if let Some(word) = attr.word() {\n+                            imports.reexports.push((token::intern(&word.name()), attr.span()));\n+                        } else {\n+                            bad_macro_reexport(self, attr.span());\n+                        }\n+                    }\n+                } else {\n+                    bad_macro_reexport(self, attr.span());\n+                }\n+            } else if attr.check_name(\"no_link\") {\n+                imports.no_link = true;\n+            }\n+        }\n+        imports\n+    }\n }\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {"}, {"sha": "f2a5aedbb3ab463cbe2f12d10ed7c3e360b8b537", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -1272,6 +1272,185 @@ impl Foo for i32 {}\n ```\n \"##,\n \n+E0466: r##\"\n+Macro import declarations were malformed.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0466\n+#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n+extern crate core as some_crate;\n+\n+#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n+extern crate core as another_crate;\n+```\n+\n+This is a syntax error at the level of attribute declarations. The proper\n+syntax for macro imports is the following:\n+\n+```ignore\n+// In some_crate:\n+#[macro_export]\n+macro_rules! get_tacos {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! get_pimientos {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n+extern crate some_crate;               // `get_pimientos` macros from some_crate\n+```\n+\n+If you would like to import all exported macros, write `macro_use` with no\n+arguments.\n+\"##,\n+\n+E0467: r##\"\n+Macro reexport declarations were empty or malformed.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0467\n+#[macro_reexport]                    // error: no macros listed for export\n+extern crate core as macros_for_good;\n+\n+#[macro_reexport(fun_macro = \"foo\")] // error: not a macro identifier\n+extern crate core as other_macros_for_good;\n+```\n+\n+This is a syntax error at the level of attribute declarations.\n+\n+Currently, `macro_reexport` requires at least one macro name to be listed.\n+Unlike `macro_use`, listing no names does not reexport all macros from the\n+given crate.\n+\n+Decide which macros you would like to export and list them properly.\n+\n+These are proper reexport declarations:\n+\n+```ignore\n+#[macro_reexport(some_macro, another_macro)]\n+extern crate macros_for_good;\n+```\n+\"##,\n+\n+E0468: r##\"\n+A non-root module attempts to import macros from another crate.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0468\n+mod foo {\n+    #[macro_use(helpful_macro)] // error: must be at crate root to import\n+    extern crate core;          //        macros from another crate\n+    helpful_macro!(...);\n+}\n+```\n+\n+Only `extern crate` imports at the crate root level are allowed to import\n+macros.\n+\n+Either move the macro import to crate root or do without the foreign macros.\n+This will work:\n+\n+```ignore\n+#[macro_use(helpful_macro)]\n+extern crate some_crate;\n+\n+mod foo {\n+    helpful_macro!(...)\n+}\n+```\n+\"##,\n+\n+E0469: r##\"\n+A macro listed for import was not found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0469\n+#[macro_use(drink, be_merry)] // error: imported macro not found\n+extern crate collections;\n+\n+fn main() {\n+    // ...\n+}\n+```\n+\n+Either the listed macro is not contained in the imported crate, or it is not\n+exported from the given crate.\n+\n+This could be caused by a typo. Did you misspell the macro's name?\n+\n+Double-check the names of the macros listed for import, and that the crate\n+in question exports them.\n+\n+A working version would be:\n+\n+```ignore\n+// In some_crate crate:\n+#[macro_export]\n+macro_rules! eat {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! drink {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(eat, drink)]\n+extern crate some_crate; //ok!\n+```\n+\"##,\n+\n+E0470: r##\"\n+A macro listed for reexport was not found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0470\n+#[macro_reexport(drink, be_merry)]\n+extern crate collections;\n+\n+fn main() {\n+    // ...\n+}\n+```\n+\n+Either the listed macro is not contained in the imported crate, or it is not\n+exported from the given crate.\n+\n+This could be caused by a typo. Did you misspell the macro's name?\n+\n+Double-check the names of the macros listed for reexport, and that the crate\n+in question exports them.\n+\n+A working version:\n+\n+```ignore\n+// In some_crate crate:\n+#[macro_export]\n+macro_rules! eat {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! drink {\n+    ...\n+}\n+\n+// In your_crate:\n+#[macro_reexport(eat, drink)]\n+extern crate some_crate;\n+```\n+\"##,\n+\n E0530: r##\"\n A binding shadowed something it shouldn't.\n "}, {"sha": "72e5823598ea1fde236654bf9c62abcaab766ca5", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -114,22 +114,22 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n-    fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n+    fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef, export: bool) {\n         if &def.ident.name.as_str() == \"macro_rules\" {\n             self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n-        if def.use_locally {\n-            let invocation = self.invocations[&scope];\n-            let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent: invocation.legacy_scope.get(),\n-                name: def.ident.name,\n-                ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-                span: def.span,\n-            });\n-            invocation.legacy_scope.set(LegacyScope::Binding(binding));\n-            self.macro_names.insert(def.ident.name);\n-        }\n-        if def.export {\n+\n+        let invocation = self.invocations[&scope];\n+        let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n+            parent: invocation.legacy_scope.get(),\n+            name: def.ident.name,\n+            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n+            span: def.span,\n+        });\n+        invocation.legacy_scope.set(LegacyScope::Binding(binding));\n+        self.macro_names.insert(def.ident.name);\n+\n+        if export {\n             def.id = self.next_node_id();\n             self.exported_macros.push(def);\n         }"}, {"sha": "ae036e66c69036f86d50d3160ef5ccc124dd312a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -2012,8 +2012,6 @@ pub struct MacroDef {\n     pub id: NodeId,\n     pub span: Span,\n     pub imported_from: Option<Ident>,\n-    pub export: bool,\n-    pub use_locally: bool,\n     pub allow_internal_unstable: bool,\n     pub body: Vec<TokenTree>,\n }"}, {"sha": "c404c6d1162f90ebb3ea8d88d172a516381469de", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -519,7 +519,7 @@ pub trait Resolver {\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n-    fn add_macro(&mut self, scope: Mark, def: ast::MacroDef);\n+    fn add_macro(&mut self, scope: Mark, def: ast::MacroDef, export: bool);\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n@@ -541,7 +541,7 @@ impl Resolver for DummyResolver {\n     fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n-    fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef) {}\n+    fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef, _export: bool) {}\n     fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n "}, {"sha": "ceca698f479abb77bbdb6aaed24a576206b38ace", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affc3b7552324284ccd7042b5b23f6ecd391babc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=affc3b7552324284ccd7042b5b23f6ecd391babc", "patch": "@@ -157,14 +157,13 @@ impl IdentMacroExpander for MacroRulesExpander {\n               tts: Vec<tokenstream::TokenTree>,\n               attrs: Vec<ast::Attribute>)\n               -> Box<MacResult> {\n+        let export = attr::contains_name(&attrs, \"macro_export\");\n         let def = ast::MacroDef {\n             ident: ident,\n             id: ast::DUMMY_NODE_ID,\n             span: span,\n             imported_from: None,\n-            use_locally: true,\n             body: tts,\n-            export: attr::contains_name(&attrs, \"macro_export\"),\n             allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n             attrs: attrs,\n         };\n@@ -176,7 +175,7 @@ impl IdentMacroExpander for MacroRulesExpander {\n             MacEager::items(placeholders::macro_scope_placeholder().make_items())\n         };\n \n-        cx.resolver.add_macro(cx.current_expansion.mark, def);\n+        cx.resolver.add_macro(cx.current_expansion.mark, def, export);\n         result\n     }\n }"}]}