{"sha": "093c02ed460cfe726badc7d7bee2c868f8288e16", "node_id": "C_kwDOAAsO6NoAKDA5M2MwMmVkNDYwY2ZlNzI2YmFkYzdkN2JlZTJjODY4ZjgyODhlMTY", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-10-22T17:15:03Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:47:42Z"}, "message": "document `is_aligned{,_to}`", "tree": {"sha": "2a35a259e8b04263943033de32a9444e1a6fddfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a35a259e8b04263943033de32a9444e1a6fddfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/093c02ed460cfe726badc7d7bee2c868f8288e16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/093c02ed460cfe726badc7d7bee2c868f8288e16", "html_url": "https://github.com/rust-lang/rust/commit/093c02ed460cfe726badc7d7bee2c868f8288e16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/093c02ed460cfe726badc7d7bee2c868f8288e16/comments", "author": null, "committer": null, "parents": [{"sha": "a906f6cb698df6d29093e14984878446c269082d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a906f6cb698df6d29093e14984878446c269082d", "html_url": "https://github.com/rust-lang/rust/commit/a906f6cb698df6d29093e14984878446c269082d"}], "stats": {"total": 276, "additions": 268, "deletions": 8}, "files": [{"sha": "6457e5184b0e4c637eb2fa9a647096a5824d9435", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 134, "deletions": 4, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/093c02ed460cfe726badc7d7bee2c868f8288e16/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093c02ed460cfe726badc7d7bee2c868f8288e16/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=093c02ed460cfe726badc7d7bee2c868f8288e16", "patch": "@@ -1364,8 +1364,72 @@ impl<T: ?Sized> *const T {\n     }\n \n     /// Returns whether the pointer is properly aligned for `T`.\n-    // #[cfg(not(bootstrap))] -- Calling this function in a const context from the bootstrap\n-    // compiler will always return false.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    /// ```\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(pointer_byte_offsets)]\n+    ///\n+    /// let data: i32 = 42;\n+    /// let ptr: *const i32 = &data;\n+    ///\n+    /// assert!(ptr.is_aligned());\n+    /// assert!(!ptr.wrapping_byte_add(1).is_aligned());\n+    /// ```\n+    ///\n+    /// # At compiletime\n+    /// **Note: Alignment at compiletime is experimental and subject to change. See the\n+    /// [tracking issue] for details.**\n+    ///\n+    /// At compiletime, the compiler may not know where a value will end up in memory.\n+    /// Calling this function on a pointer created from a reference at compiletime will only\n+    /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n+    /// is never aligned if cast to a type with a stricter alignment than the reference's\n+    /// underlying allocation.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let data: i32 = 42;\n+    ///     let ptr: *const i32 = &data;\n+    ///     assert!(ptr.is_aligned());\n+    ///\n+    ///     // At runtime either `ptr1` or `ptr2` would be aligned,\n+    ///     // but at compiletime neither is aligned.\n+    ///     let ptr1: *const i64 = ptr.cast();\n+    ///     let ptr2: *const i64 = ptr.wrapping_add(1).cast();\n+    ///     assert!(!ptr1.is_aligned());\n+    ///     assert!(!ptr2.is_aligned());\n+    /// };\n+    /// ```\n+    ///\n+    /// If a pointer is created from a fixed address, this function behaves the same during\n+    /// runtime and compiletime.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let ptr = 40 as *const i32;\n+    ///     assert!(ptr.is_aligned());\n+    ///\n+    ///     // For pointers with a known address, runtime and\n+    ///     // compiletime behavior are identical.\n+    ///     let ptr1: *const i64 = ptr.cast();\n+    ///     let ptr2: *const i64 = ptr.wrapping_add(1).cast();\n+    ///     assert!(ptr1.is_aligned());\n+    ///     assert!(!ptr2.is_aligned());\n+    /// };\n+    /// ```\n+    ///\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/comming-soon\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n@@ -1385,8 +1449,74 @@ impl<T: ?Sized> *const T {\n     /// # Panics\n     ///\n     /// The function panics if `align` is not a power-of-two (this includes 0).\n-    // #[cfg(not(bootstrap))] -- Calling this function in a const context from the bootstrap\n-    // compiler will always return false.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    /// ```\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(pointer_byte_offsets)]\n+    ///\n+    /// let data: i32 = 42;\n+    /// let ptr: *const i32 = &data;\n+    ///\n+    /// assert!(ptr.is_aligned_to(1));\n+    /// assert!(ptr.is_aligned_to(2));\n+    /// assert!(ptr.is_aligned_to(4));\n+    ///\n+    /// assert!(ptr.wrapping_byte_add(2).is_aligned_to(2));\n+    /// assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));\n+    ///\n+    /// assert_ne!(ptr.is_aligned_to(8), ptr.wrapping_add(1).is_aligned_to(8));\n+    /// ```\n+    ///\n+    /// # At compiletime\n+    /// **Note: Alignment at compiletime is experimental and subject to change. See the\n+    /// [tracking issue] for details.**\n+    ///\n+    /// At compiletime, the compiler may not know where a value will end up in memory.\n+    /// Calling this function on a pointer created from a reference at compiletime will only\n+    /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n+    /// cannot be stricter aligned than the reference's underlying allocation.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let data: i32 = 42;\n+    ///     let ptr: *const i32 = &data;\n+    ///\n+    ///     assert!(ptr.is_aligned_to(1));\n+    ///     assert!(ptr.is_aligned_to(2));\n+    ///     assert!(ptr.is_aligned_to(4));\n+    ///\n+    ///     // At compiletime, we know for sure that the pointer isn't aligned to 8.\n+    ///     assert!(!ptr.is_aligned_to(8));\n+    ///     assert!(!ptr.wrapping_add(1).is_aligned_to(8));\n+    /// };\n+    /// ```\n+    ///\n+    /// If a pointer is created from a fixed address, this function behaves the same during\n+    /// runtime and compiletime.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let ptr = 40 as *const i32;\n+    ///     assert!(ptr.is_aligned_to(1));\n+    ///     assert!(ptr.is_aligned_to(2));\n+    ///     assert!(ptr.is_aligned_to(4));\n+    ///     assert!(ptr.is_aligned_to(8));\n+    ///     assert!(!ptr.is_aligned_to(16));\n+    /// };\n+    /// ```\n+    ///\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/comming-soon\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]"}, {"sha": "c79f815e35fd465e4c4712c53381acbe5b253a56", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 134, "deletions": 4, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/093c02ed460cfe726badc7d7bee2c868f8288e16/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093c02ed460cfe726badc7d7bee2c868f8288e16/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=093c02ed460cfe726badc7d7bee2c868f8288e16", "patch": "@@ -1632,8 +1632,72 @@ impl<T: ?Sized> *mut T {\n     }\n \n     /// Returns whether the pointer is properly aligned for `T`.\n-    // #[cfg(not(bootstrap))] -- Calling this function in a const context from the bootstrap\n-    // compiler will always return false.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    /// ```\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(pointer_byte_offsets)]\n+    ///\n+    /// let data: i32 = 42;\n+    /// let ptr: *const i32 = &data;\n+    ///\n+    /// assert!(ptr.is_aligned());\n+    /// assert!(!ptr.wrapping_byte_add(1).is_aligned());\n+    /// ```\n+    ///\n+    /// # At compiletime\n+    /// **Note: Alignment at compiletime is experimental and subject to change. See the\n+    /// [tracking issue] for details.**\n+    ///\n+    /// At compiletime, the compiler may not know where a value will end up in memory.\n+    /// Calling this function on a pointer created from a reference at compiletime will only\n+    /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n+    /// is never aligned if cast to a type with a stricter alignment than the reference's\n+    /// underlying allocation.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let data: i32 = 42;\n+    ///     let ptr: *const i32 = &data;\n+    ///     assert!(ptr.is_aligned());\n+    ///\n+    ///     // At runtime either `ptr1` or `ptr2` would be aligned,\n+    ///     // but at compiletime neither is aligned.\n+    ///     let ptr1: *const i64 = ptr.cast();\n+    ///     let ptr2: *const i64 = ptr.wrapping_add(1).cast();\n+    ///     assert!(!ptr1.is_aligned());\n+    ///     assert!(!ptr2.is_aligned());\n+    /// };\n+    /// ```\n+    ///\n+    /// If a pointer is created from a fixed address, this function behaves the same during\n+    /// runtime and compiletime.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let ptr = 40 as *const i32;\n+    ///     assert!(ptr.is_aligned());\n+    ///\n+    ///     // For pointers with a known address, runtime and\n+    ///     // compiletime behavior are identical.\n+    ///     let ptr1: *const i64 = ptr.cast();\n+    ///     let ptr2: *const i64 = ptr.wrapping_add(1).cast();\n+    ///     assert!(ptr1.is_aligned());\n+    ///     assert!(!ptr2.is_aligned());\n+    /// };\n+    /// ```\n+    ///\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/comming-soon\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n@@ -1653,8 +1717,74 @@ impl<T: ?Sized> *mut T {\n     /// # Panics\n     ///\n     /// The function panics if `align` is not a power-of-two (this includes 0).\n-    // #[cfg(not(bootstrap))] -- Calling this function in a const context from the bootstrap\n-    // compiler will always return false.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    /// ```\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(pointer_byte_offsets)]\n+    ///\n+    /// let data: i32 = 42;\n+    /// let ptr: *const i32 = &data;\n+    ///\n+    /// assert!(ptr.is_aligned_to(1));\n+    /// assert!(ptr.is_aligned_to(2));\n+    /// assert!(ptr.is_aligned_to(4));\n+    ///\n+    /// assert!(ptr.wrapping_byte_add(2).is_aligned_to(2));\n+    /// assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));\n+    ///\n+    /// assert_ne!(ptr.is_aligned_to(8), ptr.wrapping_add(1).is_aligned_to(8));\n+    /// ```\n+    ///\n+    /// # At compiletime\n+    /// **Note: Alignment at compiletime is experimental and subject to change. See the\n+    /// [tracking issue] for details.**\n+    ///\n+    /// At compiletime, the compiler may not know where a value will end up in memory.\n+    /// Calling this function on a pointer created from a reference at compiletime will only\n+    /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n+    /// cannot be stricter aligned than the reference's underlying allocation.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let data: i32 = 42;\n+    ///     let ptr: *const i32 = &data;\n+    ///\n+    ///     assert!(ptr.is_aligned_to(1));\n+    ///     assert!(ptr.is_aligned_to(2));\n+    ///     assert!(ptr.is_aligned_to(4));\n+    ///\n+    ///     // At compiletime, we know for sure that the pointer isn't aligned to 8.\n+    ///     assert!(!ptr.is_aligned_to(8));\n+    ///     assert!(!ptr.wrapping_add(1).is_aligned_to(8));\n+    /// };\n+    /// ```\n+    ///\n+    /// If a pointer is created from a fixed address, this function behaves the same during\n+    /// runtime and compiletime.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let ptr = 40 as *const i32;\n+    ///     assert!(ptr.is_aligned_to(1));\n+    ///     assert!(ptr.is_aligned_to(2));\n+    ///     assert!(ptr.is_aligned_to(4));\n+    ///     assert!(ptr.is_aligned_to(8));\n+    ///     assert!(!ptr.is_aligned_to(16));\n+    /// };\n+    /// ```\n+    ///\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/comming-soon\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]"}]}