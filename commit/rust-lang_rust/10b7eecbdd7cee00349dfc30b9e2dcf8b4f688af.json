{"sha": "10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYjdlZWNiZGQ3Y2VlMDAzNDlkZmMzMGI5ZTJkY2Y4YjRmNjg4YWY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-17T21:09:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-17T21:09:08Z"}, "message": "Rollup merge of #74169 - ecstatic-morse:dataflow-unreachable, r=pnkfelix\n\nStop processing unreachable blocks when solving dataflow\n\n...instead we `debug_assert` that the user is not checking the dataflow state for an unreachable block. This resolves a FIXME in the dataflow engine. The old behavior was an artifact of the previous dataflow framework. Things should run a tiny bit faster now, but I suspect not enough to show up in benchmarks. AFAIK, only the generator transform runs dataflow on MIR with unreachable basic blocks.\n\nThis PR also adds some utility methods to `mir::traversal`.\n\nr? @pnkfelix", "tree": {"sha": "c1c12aa7bea1cedeaffb73e98efc407d45b1ebdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1c12aa7bea1cedeaffb73e98efc407d45b1ebdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEhN1CRBK7hj4Ov3rIwAAdHIIAHwEpodGj+PaVo4jv4X+lNzc\nCROeafW5FbX0NfMsv4ojNyMYCu/pEXX+LdEERI2xGlpxZU503YWsFA9i9hdVus7c\noEicfyaTUNo9m5CexjhEvTT180YQU7kyU5J32PSbzBGHmFH+VPoDhJqEnD5mrCb9\n267Y1fEy7V4bR+0G0CI2L1fS7ZuDE01bUw+v3PbjAub63ao9dQb4zUNBv3F3p61D\nSXQhARHhTPF51RMPeP7K6JUY3esasT7mwaw3OBHkVYomV9AjIN+KHsn/TfBwlpv4\n99tJ8X6MYENDTf6IbZkkFwy8MVbYwOBW8JNawPc2Xwujrv3QNGsVUa4aX69Ktqs=\n=kio+\n-----END PGP SIGNATURE-----\n", "payload": "tree c1c12aa7bea1cedeaffb73e98efc407d45b1ebdc\nparent 9c84c6b836bce0730cd1c34ef7e4832b755a713d\nparent 698e870f75710152309158342fd18461531cc0fb\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595020148 -0700\ncommitter GitHub <noreply@github.com> 1595020148 -0700\n\nRollup merge of #74169 - ecstatic-morse:dataflow-unreachable, r=pnkfelix\n\nStop processing unreachable blocks when solving dataflow\n\n...instead we `debug_assert` that the user is not checking the dataflow state for an unreachable block. This resolves a FIXME in the dataflow engine. The old behavior was an artifact of the previous dataflow framework. Things should run a tiny bit faster now, but I suspect not enough to show up in benchmarks. AFAIK, only the generator transform runs dataflow on MIR with unreachable basic blocks.\n\nThis PR also adds some utility methods to `mir::traversal`.\n\nr? @pnkfelix\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "html_url": "https://github.com/rust-lang/rust/commit/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c84c6b836bce0730cd1c34ef7e4832b755a713d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c84c6b836bce0730cd1c34ef7e4832b755a713d", "html_url": "https://github.com/rust-lang/rust/commit/9c84c6b836bce0730cd1c34ef7e4832b755a713d"}, {"sha": "698e870f75710152309158342fd18461531cc0fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/698e870f75710152309158342fd18461531cc0fb", "html_url": "https://github.com/rust-lang/rust/commit/698e870f75710152309158342fd18461531cc0fb"}], "stats": {"total": 54, "additions": 42, "deletions": 12}, "files": [{"sha": "36e277d1a88f3d3e4a49504ee92b4fe173b136eb", "filename": "src/librustc_middle/mir/traversal.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_middle%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_middle%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftraversal.rs?ref=10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "patch": "@@ -292,3 +292,20 @@ impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ExactSizeIterator for ReversePostorder<'a, 'tcx> {}\n+\n+/// Returns an iterator over all basic blocks reachable from the `START_BLOCK` in no particular\n+/// order.\n+///\n+/// This is clearer than writing `preorder` in cases where the order doesn't matter.\n+pub fn reachable<'a, 'tcx>(\n+    body: &'a Body<'tcx>,\n+) -> impl 'a + Iterator<Item = (BasicBlock, &'a BasicBlockData<'tcx>)> {\n+    preorder(body)\n+}\n+\n+/// Returns a `BitSet` containing all basic blocks reachable from the `START_BLOCK`.\n+pub fn reachable_as_bitset(body: &Body<'tcx>) -> BitSet<BasicBlock> {\n+    let mut iter = preorder(body);\n+    (&mut iter).for_each(drop);\n+    iter.visited\n+}"}, {"sha": "4f5930dc3f5a209c9e3d6baccef11bdad4fcfcab", "filename": "src/librustc_mir/dataflow/framework/cursor.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs?ref=10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "patch": "@@ -34,6 +34,9 @@ where\n     ///\n     /// When this flag is set, we need to reset to an entry set before doing a seek.\n     state_needs_reset: bool,\n+\n+    #[cfg(debug_assertions)]\n+    reachable_blocks: BitSet<BasicBlock>,\n }\n \n impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n@@ -55,6 +58,9 @@ where\n             state_needs_reset: true,\n             state: BitSet::new_empty(bits_per_block),\n             pos: CursorPosition::block_entry(mir::START_BLOCK),\n+\n+            #[cfg(debug_assertions)]\n+            reachable_blocks: mir::traversal::reachable_as_bitset(body),\n         }\n     }\n \n@@ -85,6 +91,9 @@ where\n     ///\n     /// For backward dataflow analyses, this is the dataflow state after the terminator.\n     pub(super) fn seek_to_block_entry(&mut self, block: BasicBlock) {\n+        #[cfg(debug_assertions)]\n+        assert!(self.reachable_blocks.contains(block));\n+\n         self.state.overwrite(&self.results.borrow().entry_set_for_block(block));\n         self.pos = CursorPosition::block_entry(block);\n         self.state_needs_reset = false;"}, {"sha": "003c40f290b8d02db5cf163d5dd4b1ce7322906c", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "patch": "@@ -52,6 +52,15 @@ where\n         visit_results(body, blocks, self, vis)\n     }\n \n+    pub fn visit_reachable_with(\n+        &self,\n+        body: &'mir mir::Body<'tcx>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+    ) {\n+        let blocks = mir::traversal::reachable(body);\n+        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n+    }\n+\n     pub fn visit_in_rpo_with(\n         &self,\n         body: &'mir mir::Body<'tcx>,\n@@ -204,15 +213,6 @@ where\n             }\n         }\n \n-        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n-        // be processed after the ones added above.\n-        //\n-        // FIXME(ecstaticmorse): Is this actually necessary? In principle, we shouldn't need to\n-        // know the dataflow state in unreachable basic blocks.\n-        for bb in body.basic_blocks().indices() {\n-            dirty_queue.insert(bb);\n-        }\n-\n         let mut state = BitSet::new_empty(bits_per_block);\n         while let Some(bb) = dirty_queue.pop() {\n             let bb_data = &body[bb];"}, {"sha": "257f3cb9a6dd0ddd1026b1041fbe6babc3e13238", "filename": "src/librustc_mir/dataflow/framework/visitor.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs?ref=10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "patch": "@@ -16,7 +16,13 @@ pub fn visit_results<F, V>(\n {\n     let mut state = results.new_flow_state(body);\n \n+    #[cfg(debug_assertions)]\n+    let reachable_blocks = mir::traversal::reachable_as_bitset(body);\n+\n     for block in blocks {\n+        #[cfg(debug_assertions)]\n+        assert!(reachable_blocks.contains(block));\n+\n         let block_data = &body[block];\n         V::Direction::visit_results_in_block(&mut state, block, block_data, results, vis);\n     }"}, {"sha": "8618cc126c563e336919ef366d306752ff1282ee", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=10b7eecbdd7cee00349dfc30b9e2dcf8b4f688af", "patch": "@@ -624,9 +624,7 @@ fn compute_storage_conflicts(\n         local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n \n-    // Visit only reachable basic blocks. The exact order is not important.\n-    let reachable_blocks = traversal::preorder(body).map(|(bb, _)| bb);\n-    requires_storage.visit_with(body, reachable_blocks, &mut visitor);\n+    requires_storage.visit_reachable_with(body, &mut visitor);\n \n     let local_conflicts = visitor.local_conflicts;\n "}]}