{"sha": "5b67543c981d13233b2f4f2004b7de8abf279d54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNjc1NDNjOTgxZDEzMjMzYjJmNGYyMDA0YjdkZThhYmYyNzlkNTQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-30T09:34:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-30T09:34:26Z"}, "message": "Rollup merge of #83579 - RalfJung:ptr-arithmetic, r=dtolnay\n\nImprove pointer arithmetic docs\n\n* Add slightly more detailed definition of \"allocated object\" to the module docs, and link it from everywhere.\n* Clarify the \"remains attached\" wording a bit (at least I hope this is clearer).\n* Remove the sentence about using integer arithmetic; this seems to confuse people even if it is technically correct.\n\nAs usual, the edit needs to be done in a dozen places to remain consistent, I hope I got them all.", "tree": {"sha": "60bebcadc524586f9a0a2b598ee80da93ec2a390", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60bebcadc524586f9a0a2b598ee80da93ec2a390"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b67543c981d13233b2f4f2004b7de8abf279d54", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgYvCiCRBK7hj4Ov3rIwAAdHIIABd+evPNnu3dmSXpsUCltk1a\nDYd6gQHtOrsjZ0BzsubTnlHCbz5SmzvsOwoA9oWLGMsogxhTpfXH9eyhbMnwxUYE\nz6LJRO4jo7yPotytwW1Eo53m5RVYFTo4VR3yzEyr4WoHlPdOYBbf0YECxm/Yd7cQ\nFV/ajXDKYY4Q3Gj+NBN4LCzitR3ay8HQeBOTQYFBLeaB4olHEczSTk/gHomkd9KC\nFvyGjTO+Vv8D3CUmgdpRSpyso3g9J4/teXUuqYQZ3SAuaU+oMMddoRvEgGUEvBRl\nbPghZ9gRVTawyZZM6ANrkMSU2fZcfpq2KaII5H8c1RI/qrBSOy987ikmhmKoqBw=\n=xOHK\n-----END PGP SIGNATURE-----\n", "payload": "tree 60bebcadc524586f9a0a2b598ee80da93ec2a390\nparent ad2a80e412768fd2c9a162a3b68e1489af446f2f\nparent 4f03f94863dda70ea42ce772b790a520f1490647\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617096866 +0200\ncommitter GitHub <noreply@github.com> 1617096866 +0200\n\nRollup merge of #83579 - RalfJung:ptr-arithmetic, r=dtolnay\n\nImprove pointer arithmetic docs\n\n* Add slightly more detailed definition of \"allocated object\" to the module docs, and link it from everywhere.\n* Clarify the \"remains attached\" wording a bit (at least I hope this is clearer).\n* Remove the sentence about using integer arithmetic; this seems to confuse people even if it is technically correct.\n\nAs usual, the edit needs to be done in a dozen places to remain consistent, I hope I got them all.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b67543c981d13233b2f4f2004b7de8abf279d54", "html_url": "https://github.com/rust-lang/rust/commit/5b67543c981d13233b2f4f2004b7de8abf279d54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b67543c981d13233b2f4f2004b7de8abf279d54/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad2a80e412768fd2c9a162a3b68e1489af446f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad2a80e412768fd2c9a162a3b68e1489af446f2f", "html_url": "https://github.com/rust-lang/rust/commit/ad2a80e412768fd2c9a162a3b68e1489af446f2f"}, {"sha": "4f03f94863dda70ea42ce772b790a520f1490647", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f03f94863dda70ea42ce772b790a520f1490647", "html_url": "https://github.com/rust-lang/rust/commit/4f03f94863dda70ea42ce772b790a520f1490647"}], "stats": {"total": 102, "additions": 47, "deletions": 55}, "files": [{"sha": "25b8f435accf24aace4e214dcc65a2370def3cda", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5b67543c981d13233b2f4f2004b7de8abf279d54/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b67543c981d13233b2f4f2004b7de8abf279d54/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=5b67543c981d13233b2f4f2004b7de8abf279d54", "patch": "@@ -184,8 +184,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -210,6 +209,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_offset`]: #method.wrapping_offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -245,9 +245,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -265,10 +264,8 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n     /// words, leaving the allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`offset`]: #method.offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -314,8 +311,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * Both pointers must be *derived from* a pointer to the same object.\n     ///   (See below for an example.)\n@@ -345,6 +341,7 @@ impl<T: ?Sized> *const T {\n     /// such large allocations either.)\n     ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Panics\n     ///\n@@ -468,8 +465,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -494,6 +490,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_add`]: #method.wrapping_add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -532,8 +529,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n     ///\n@@ -558,6 +554,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_sub`]: #method.wrapping_sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -594,9 +591,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -614,10 +610,8 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -659,9 +653,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -679,10 +672,8 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`sub`]: #method.sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -997,7 +988,7 @@ impl<T> *const [T] {\n     /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n     ///   and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1019,6 +1010,7 @@ impl<T> *const [T] {\n     /// See also [`slice::from_raw_parts`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {"}, {"sha": "6412bd41a8c092192d1a9ad5b8490885bc7d6242", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b67543c981d13233b2f4f2004b7de8abf279d54/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b67543c981d13233b2f4f2004b7de8abf279d54/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=5b67543c981d13233b2f4f2004b7de8abf279d54", "patch": "@@ -55,6 +55,14 @@\n //! has size 0, i.e., even if memory is not actually touched. Consider using\n //! [`NonNull::dangling`] in such cases.\n //!\n+//! ## Allocated object\n+//!\n+//! For several operations, such as [`offset`] or field projections (`expr.field`), the notion of an\n+//! \"allocated object\" becomes relevant. An allocated object is a contiguous region of memory.\n+//! Common examples of allocated objects include stack-allocated variables (each variable is a\n+//! separate allocated object), heap allocations (each allocation created by the global allocator is\n+//! a separate allocated object), and `static` variables.\n+//!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html"}, {"sha": "732e1273b4be8ab9b402fdc4e729d8927924ccd8", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5b67543c981d13233b2f4f2004b7de8abf279d54/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b67543c981d13233b2f4f2004b7de8abf279d54/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=5b67543c981d13233b2f4f2004b7de8abf279d54", "patch": "@@ -189,8 +189,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -215,6 +214,7 @@ impl<T: ?Sized> *mut T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_offset`]: #method.wrapping_offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -251,9 +251,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -271,10 +270,8 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n     /// words, leaving the allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`offset`]: #method.offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -485,8 +482,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * Both pointers must be *derived from* a pointer to the same object.\n     ///   (See below for an example.)\n@@ -516,6 +512,7 @@ impl<T: ?Sized> *mut T {\n     /// such large allocations either.)\n     ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Panics\n     ///\n@@ -575,8 +572,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -639,8 +635,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n     ///\n@@ -665,6 +660,7 @@ impl<T: ?Sized> *mut T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_sub`]: #method.wrapping_sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -701,9 +697,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -721,10 +716,8 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -766,9 +759,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -786,10 +778,8 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`sub`]: #method.sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -1261,7 +1251,7 @@ impl<T> *mut [T] {\n     /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n     ///   and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1283,6 +1273,7 @@ impl<T> *mut [T] {\n     /// See also [`slice::from_raw_parts`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n@@ -1311,7 +1302,7 @@ impl<T> *mut [T] {\n     /// * The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()`\n     ///   many bytes, and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1333,6 +1324,7 @@ impl<T> *mut [T] {\n     /// See also [`slice::from_raw_parts_mut`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {"}]}