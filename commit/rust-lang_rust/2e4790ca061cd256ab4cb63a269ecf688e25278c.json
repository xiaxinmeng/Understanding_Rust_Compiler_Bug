{"sha": "2e4790ca061cd256ab4cb63a269ecf688e25278c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNDc5MGNhMDYxY2QyNTZhYjRjYjYzYTI2OWVjZjY4OGUyNTI3OGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-06T20:10:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-06T20:10:31Z"}, "message": "Merge remote-tracking branch 'mozilla/incoming' into issue-5910-dyna-freeze", "tree": {"sha": "0d890fd7c9775c88e6566f4ad3330ae5974fa982", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d890fd7c9775c88e6566f4ad3330ae5974fa982"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e4790ca061cd256ab4cb63a269ecf688e25278c", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e4790ca061cd256ab4cb63a269ecf688e25278c", "html_url": "https://github.com/rust-lang/rust/commit/2e4790ca061cd256ab4cb63a269ecf688e25278c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e4790ca061cd256ab4cb63a269ecf688e25278c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "html_url": "https://github.com/rust-lang/rust/commit/0ef4e860da1fb755b9fff5d1b30bee3974514ea2"}, {"sha": "a5891bebc132d4c373a5a5ffc93ba1bea2e8beb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5891bebc132d4c373a5a5ffc93ba1bea2e8beb5", "html_url": "https://github.com/rust-lang/rust/commit/a5891bebc132d4c373a5a5ffc93ba1bea2e8beb5"}], "stats": {"total": 766, "additions": 403, "deletions": 363}, "files": [{"sha": "80f1f05961a5d8ac03d7ceb6393b0f44043c3f9f", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -66,6 +66,13 @@ totaleq_impl!(uint)\n \n totaleq_impl!(char)\n \n+/// Trait for testing approximate equality\n+pub trait ApproxEq<Eps> {\n+    fn approx_epsilon() -> Eps;\n+    fn approx_eq(&self, other: &Self) -> bool;\n+    fn approx_eq_eps(&self, other: &Self, approx_epsilon: &Eps) -> bool;\n+}\n+\n #[deriving(Clone, Eq)]\n pub enum Ordering { Less = -1, Equal = 0, Greater = 1 }\n "}, {"sha": "7c13f136a80f27ef4c761eb0f1975b2d7ca0ce69", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 90, "deletions": 74, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -210,6 +210,22 @@ impl Eq for f32 {\n     fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n }\n \n+#[cfg(notest)]\n+impl ApproxEq<f32> for f32 {\n+    #[inline(always)]\n+    fn approx_epsilon() -> f32 { 1.0e-6 }\n+\n+    #[inline(always)]\n+    fn approx_eq(&self, other: &f32) -> bool {\n+        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f32, f32>())\n+    }\n+\n+    #[inline(always)]\n+    fn approx_eq_eps(&self, other: &f32, approx_epsilon: &f32) -> bool {\n+        (*self - *other).abs() < *approx_epsilon\n+    }\n+}\n+\n #[cfg(notest)]\n impl Ord for f32 {\n     #[inline(always)]\n@@ -810,15 +826,6 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n-    macro_rules! assert_fuzzy_eq(\n-        ($a:expr, $b:expr) => ({\n-            let a = $a, b = $b;\n-            if !((a - b).abs() < 1.0e-6) {\n-                fail!(fmt!(\"The values were not approximately equal. Found: %? and %?\", a, b));\n-            }\n-        })\n-    )\n-\n     #[test]\n     fn test_num() {\n         num::test_num(10f32, 2f32);\n@@ -848,91 +855,91 @@ mod tests {\n \n     #[test]\n     fn test_floor() {\n-        assert_fuzzy_eq!(1.0f32.floor(), 1.0f32);\n-        assert_fuzzy_eq!(1.3f32.floor(), 1.0f32);\n-        assert_fuzzy_eq!(1.5f32.floor(), 1.0f32);\n-        assert_fuzzy_eq!(1.7f32.floor(), 1.0f32);\n-        assert_fuzzy_eq!(0.0f32.floor(), 0.0f32);\n-        assert_fuzzy_eq!((-0.0f32).floor(), -0.0f32);\n-        assert_fuzzy_eq!((-1.0f32).floor(), -1.0f32);\n-        assert_fuzzy_eq!((-1.3f32).floor(), -2.0f32);\n-        assert_fuzzy_eq!((-1.5f32).floor(), -2.0f32);\n-        assert_fuzzy_eq!((-1.7f32).floor(), -2.0f32);\n+        assert_approx_eq!(1.0f32.floor(), 1.0f32);\n+        assert_approx_eq!(1.3f32.floor(), 1.0f32);\n+        assert_approx_eq!(1.5f32.floor(), 1.0f32);\n+        assert_approx_eq!(1.7f32.floor(), 1.0f32);\n+        assert_approx_eq!(0.0f32.floor(), 0.0f32);\n+        assert_approx_eq!((-0.0f32).floor(), -0.0f32);\n+        assert_approx_eq!((-1.0f32).floor(), -1.0f32);\n+        assert_approx_eq!((-1.3f32).floor(), -2.0f32);\n+        assert_approx_eq!((-1.5f32).floor(), -2.0f32);\n+        assert_approx_eq!((-1.7f32).floor(), -2.0f32);\n     }\n \n     #[test]\n     fn test_ceil() {\n-        assert_fuzzy_eq!(1.0f32.ceil(), 1.0f32);\n-        assert_fuzzy_eq!(1.3f32.ceil(), 2.0f32);\n-        assert_fuzzy_eq!(1.5f32.ceil(), 2.0f32);\n-        assert_fuzzy_eq!(1.7f32.ceil(), 2.0f32);\n-        assert_fuzzy_eq!(0.0f32.ceil(), 0.0f32);\n-        assert_fuzzy_eq!((-0.0f32).ceil(), -0.0f32);\n-        assert_fuzzy_eq!((-1.0f32).ceil(), -1.0f32);\n-        assert_fuzzy_eq!((-1.3f32).ceil(), -1.0f32);\n-        assert_fuzzy_eq!((-1.5f32).ceil(), -1.0f32);\n-        assert_fuzzy_eq!((-1.7f32).ceil(), -1.0f32);\n+        assert_approx_eq!(1.0f32.ceil(), 1.0f32);\n+        assert_approx_eq!(1.3f32.ceil(), 2.0f32);\n+        assert_approx_eq!(1.5f32.ceil(), 2.0f32);\n+        assert_approx_eq!(1.7f32.ceil(), 2.0f32);\n+        assert_approx_eq!(0.0f32.ceil(), 0.0f32);\n+        assert_approx_eq!((-0.0f32).ceil(), -0.0f32);\n+        assert_approx_eq!((-1.0f32).ceil(), -1.0f32);\n+        assert_approx_eq!((-1.3f32).ceil(), -1.0f32);\n+        assert_approx_eq!((-1.5f32).ceil(), -1.0f32);\n+        assert_approx_eq!((-1.7f32).ceil(), -1.0f32);\n     }\n \n     #[test]\n     fn test_round() {\n-        assert_fuzzy_eq!(1.0f32.round(), 1.0f32);\n-        assert_fuzzy_eq!(1.3f32.round(), 1.0f32);\n-        assert_fuzzy_eq!(1.5f32.round(), 2.0f32);\n-        assert_fuzzy_eq!(1.7f32.round(), 2.0f32);\n-        assert_fuzzy_eq!(0.0f32.round(), 0.0f32);\n-        assert_fuzzy_eq!((-0.0f32).round(), -0.0f32);\n-        assert_fuzzy_eq!((-1.0f32).round(), -1.0f32);\n-        assert_fuzzy_eq!((-1.3f32).round(), -1.0f32);\n-        assert_fuzzy_eq!((-1.5f32).round(), -2.0f32);\n-        assert_fuzzy_eq!((-1.7f32).round(), -2.0f32);\n+        assert_approx_eq!(1.0f32.round(), 1.0f32);\n+        assert_approx_eq!(1.3f32.round(), 1.0f32);\n+        assert_approx_eq!(1.5f32.round(), 2.0f32);\n+        assert_approx_eq!(1.7f32.round(), 2.0f32);\n+        assert_approx_eq!(0.0f32.round(), 0.0f32);\n+        assert_approx_eq!((-0.0f32).round(), -0.0f32);\n+        assert_approx_eq!((-1.0f32).round(), -1.0f32);\n+        assert_approx_eq!((-1.3f32).round(), -1.0f32);\n+        assert_approx_eq!((-1.5f32).round(), -2.0f32);\n+        assert_approx_eq!((-1.7f32).round(), -2.0f32);\n     }\n \n     #[test]\n     fn test_trunc() {\n-        assert_fuzzy_eq!(1.0f32.trunc(), 1.0f32);\n-        assert_fuzzy_eq!(1.3f32.trunc(), 1.0f32);\n-        assert_fuzzy_eq!(1.5f32.trunc(), 1.0f32);\n-        assert_fuzzy_eq!(1.7f32.trunc(), 1.0f32);\n-        assert_fuzzy_eq!(0.0f32.trunc(), 0.0f32);\n-        assert_fuzzy_eq!((-0.0f32).trunc(), -0.0f32);\n-        assert_fuzzy_eq!((-1.0f32).trunc(), -1.0f32);\n-        assert_fuzzy_eq!((-1.3f32).trunc(), -1.0f32);\n-        assert_fuzzy_eq!((-1.5f32).trunc(), -1.0f32);\n-        assert_fuzzy_eq!((-1.7f32).trunc(), -1.0f32);\n+        assert_approx_eq!(1.0f32.trunc(), 1.0f32);\n+        assert_approx_eq!(1.3f32.trunc(), 1.0f32);\n+        assert_approx_eq!(1.5f32.trunc(), 1.0f32);\n+        assert_approx_eq!(1.7f32.trunc(), 1.0f32);\n+        assert_approx_eq!(0.0f32.trunc(), 0.0f32);\n+        assert_approx_eq!((-0.0f32).trunc(), -0.0f32);\n+        assert_approx_eq!((-1.0f32).trunc(), -1.0f32);\n+        assert_approx_eq!((-1.3f32).trunc(), -1.0f32);\n+        assert_approx_eq!((-1.5f32).trunc(), -1.0f32);\n+        assert_approx_eq!((-1.7f32).trunc(), -1.0f32);\n     }\n \n     #[test]\n     fn test_fract() {\n-        assert_fuzzy_eq!(1.0f32.fract(), 0.0f32);\n-        assert_fuzzy_eq!(1.3f32.fract(), 0.3f32);\n-        assert_fuzzy_eq!(1.5f32.fract(), 0.5f32);\n-        assert_fuzzy_eq!(1.7f32.fract(), 0.7f32);\n-        assert_fuzzy_eq!(0.0f32.fract(), 0.0f32);\n-        assert_fuzzy_eq!((-0.0f32).fract(), -0.0f32);\n-        assert_fuzzy_eq!((-1.0f32).fract(), -0.0f32);\n-        assert_fuzzy_eq!((-1.3f32).fract(), -0.3f32);\n-        assert_fuzzy_eq!((-1.5f32).fract(), -0.5f32);\n-        assert_fuzzy_eq!((-1.7f32).fract(), -0.7f32);\n+        assert_approx_eq!(1.0f32.fract(), 0.0f32);\n+        assert_approx_eq!(1.3f32.fract(), 0.3f32);\n+        assert_approx_eq!(1.5f32.fract(), 0.5f32);\n+        assert_approx_eq!(1.7f32.fract(), 0.7f32);\n+        assert_approx_eq!(0.0f32.fract(), 0.0f32);\n+        assert_approx_eq!((-0.0f32).fract(), -0.0f32);\n+        assert_approx_eq!((-1.0f32).fract(), -0.0f32);\n+        assert_approx_eq!((-1.3f32).fract(), -0.3f32);\n+        assert_approx_eq!((-1.5f32).fract(), -0.5f32);\n+        assert_approx_eq!((-1.7f32).fract(), -0.7f32);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_fuzzy_eq!(Real::two_pi::<f32>(), 2f32 * Real::pi::<f32>());\n-        assert_fuzzy_eq!(Real::frac_pi_2::<f32>(), Real::pi::<f32>() / 2f32);\n-        assert_fuzzy_eq!(Real::frac_pi_3::<f32>(), Real::pi::<f32>() / 3f32);\n-        assert_fuzzy_eq!(Real::frac_pi_4::<f32>(), Real::pi::<f32>() / 4f32);\n-        assert_fuzzy_eq!(Real::frac_pi_6::<f32>(), Real::pi::<f32>() / 6f32);\n-        assert_fuzzy_eq!(Real::frac_pi_8::<f32>(), Real::pi::<f32>() / 8f32);\n-        assert_fuzzy_eq!(Real::frac_1_pi::<f32>(), 1f32 / Real::pi::<f32>());\n-        assert_fuzzy_eq!(Real::frac_2_pi::<f32>(), 2f32 / Real::pi::<f32>());\n-        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<f32>(), 2f32 / Real::pi::<f32>().sqrt());\n-        assert_fuzzy_eq!(Real::sqrt2::<f32>(), 2f32.sqrt());\n-        assert_fuzzy_eq!(Real::frac_1_sqrt2::<f32>(), 1f32 / 2f32.sqrt());\n-        assert_fuzzy_eq!(Real::log2_e::<f32>(), Real::e::<f32>().log2());\n-        assert_fuzzy_eq!(Real::log10_e::<f32>(), Real::e::<f32>().log10());\n-        assert_fuzzy_eq!(Real::log_2::<f32>(), 2f32.log());\n-        assert_fuzzy_eq!(Real::log_10::<f32>(), 10f32.log());\n+        assert_approx_eq!(Real::two_pi::<f32>(), 2f32 * Real::pi::<f32>());\n+        assert_approx_eq!(Real::frac_pi_2::<f32>(), Real::pi::<f32>() / 2f32);\n+        assert_approx_eq!(Real::frac_pi_3::<f32>(), Real::pi::<f32>() / 3f32);\n+        assert_approx_eq!(Real::frac_pi_4::<f32>(), Real::pi::<f32>() / 4f32);\n+        assert_approx_eq!(Real::frac_pi_6::<f32>(), Real::pi::<f32>() / 6f32);\n+        assert_approx_eq!(Real::frac_pi_8::<f32>(), Real::pi::<f32>() / 8f32);\n+        assert_approx_eq!(Real::frac_1_pi::<f32>(), 1f32 / Real::pi::<f32>());\n+        assert_approx_eq!(Real::frac_2_pi::<f32>(), 2f32 / Real::pi::<f32>());\n+        assert_approx_eq!(Real::frac_2_sqrtpi::<f32>(), 2f32 / Real::pi::<f32>().sqrt());\n+        assert_approx_eq!(Real::sqrt2::<f32>(), 2f32.sqrt());\n+        assert_approx_eq!(Real::frac_1_sqrt2::<f32>(), 1f32 / 2f32.sqrt());\n+        assert_approx_eq!(Real::log2_e::<f32>(), Real::e::<f32>().log2());\n+        assert_approx_eq!(Real::log10_e::<f32>(), Real::e::<f32>().log10());\n+        assert_approx_eq!(Real::log_2::<f32>(), 2f32.log());\n+        assert_approx_eq!(Real::log_10::<f32>(), 10f32.log());\n     }\n \n     #[test]\n@@ -974,6 +981,15 @@ mod tests {\n         assert!(!NaN.is_negative());\n     }\n \n+    #[test]\n+    fn test_approx_eq() {\n+        assert!(1.0f32.approx_eq(&1f32));\n+        assert!(0.9999999f32.approx_eq(&1f32));\n+        assert!(1.000001f32.approx_eq_eps(&1f32, &1.0e-5));\n+        assert!(1.0000001f32.approx_eq_eps(&1f32, &1.0e-6));\n+        assert!(!1.0000001f32.approx_eq_eps(&1f32, &1.0e-7));\n+    }\n+\n     #[test]\n     fn test_primitive() {\n         assert_eq!(Primitive::bits::<f32>(), sys::size_of::<f32>() * 8);"}, {"sha": "e5f10c23ecd8755e66f61cf203d1cd6fb332532e", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 90, "deletions": 75, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -233,6 +233,22 @@ impl Eq for f64 {\n     fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n }\n \n+#[cfg(notest)]\n+impl ApproxEq<f64> for f64 {\n+    #[inline(always)]\n+    fn approx_epsilon() -> f64 { 1.0e-6 }\n+\n+    #[inline(always)]\n+    fn approx_eq(&self, other: &f64) -> bool {\n+        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f64, f64>())\n+    }\n+\n+    #[inline(always)]\n+    fn approx_eq_eps(&self, other: &f64, approx_epsilon: &f64) -> bool {\n+        (*self - *other).abs() < *approx_epsilon\n+    }\n+}\n+\n #[cfg(notest)]\n impl Ord for f64 {\n     #[inline(always)]\n@@ -853,16 +869,6 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n-    macro_rules! assert_fuzzy_eq(\n-        ($a:expr, $b:expr) => ({\n-            let a = $a, b = $b;\n-            if !((a - b).abs() < 1.0e-6) {\n-                fail!(fmt!(\"The values were not approximately equal. \\\n-                            Found: %? and expected %?\", a, b));\n-            }\n-        })\n-    )\n-\n     #[test]\n     fn test_num() {\n         num::test_num(10f64, 2f64);\n@@ -896,91 +902,91 @@ mod tests {\n \n     #[test]\n     fn test_floor() {\n-        assert_fuzzy_eq!(1.0f64.floor(), 1.0f64);\n-        assert_fuzzy_eq!(1.3f64.floor(), 1.0f64);\n-        assert_fuzzy_eq!(1.5f64.floor(), 1.0f64);\n-        assert_fuzzy_eq!(1.7f64.floor(), 1.0f64);\n-        assert_fuzzy_eq!(0.0f64.floor(), 0.0f64);\n-        assert_fuzzy_eq!((-0.0f64).floor(), -0.0f64);\n-        assert_fuzzy_eq!((-1.0f64).floor(), -1.0f64);\n-        assert_fuzzy_eq!((-1.3f64).floor(), -2.0f64);\n-        assert_fuzzy_eq!((-1.5f64).floor(), -2.0f64);\n-        assert_fuzzy_eq!((-1.7f64).floor(), -2.0f64);\n+        assert_approx_eq!(1.0f64.floor(), 1.0f64);\n+        assert_approx_eq!(1.3f64.floor(), 1.0f64);\n+        assert_approx_eq!(1.5f64.floor(), 1.0f64);\n+        assert_approx_eq!(1.7f64.floor(), 1.0f64);\n+        assert_approx_eq!(0.0f64.floor(), 0.0f64);\n+        assert_approx_eq!((-0.0f64).floor(), -0.0f64);\n+        assert_approx_eq!((-1.0f64).floor(), -1.0f64);\n+        assert_approx_eq!((-1.3f64).floor(), -2.0f64);\n+        assert_approx_eq!((-1.5f64).floor(), -2.0f64);\n+        assert_approx_eq!((-1.7f64).floor(), -2.0f64);\n     }\n \n     #[test]\n     fn test_ceil() {\n-        assert_fuzzy_eq!(1.0f64.ceil(), 1.0f64);\n-        assert_fuzzy_eq!(1.3f64.ceil(), 2.0f64);\n-        assert_fuzzy_eq!(1.5f64.ceil(), 2.0f64);\n-        assert_fuzzy_eq!(1.7f64.ceil(), 2.0f64);\n-        assert_fuzzy_eq!(0.0f64.ceil(), 0.0f64);\n-        assert_fuzzy_eq!((-0.0f64).ceil(), -0.0f64);\n-        assert_fuzzy_eq!((-1.0f64).ceil(), -1.0f64);\n-        assert_fuzzy_eq!((-1.3f64).ceil(), -1.0f64);\n-        assert_fuzzy_eq!((-1.5f64).ceil(), -1.0f64);\n-        assert_fuzzy_eq!((-1.7f64).ceil(), -1.0f64);\n+        assert_approx_eq!(1.0f64.ceil(), 1.0f64);\n+        assert_approx_eq!(1.3f64.ceil(), 2.0f64);\n+        assert_approx_eq!(1.5f64.ceil(), 2.0f64);\n+        assert_approx_eq!(1.7f64.ceil(), 2.0f64);\n+        assert_approx_eq!(0.0f64.ceil(), 0.0f64);\n+        assert_approx_eq!((-0.0f64).ceil(), -0.0f64);\n+        assert_approx_eq!((-1.0f64).ceil(), -1.0f64);\n+        assert_approx_eq!((-1.3f64).ceil(), -1.0f64);\n+        assert_approx_eq!((-1.5f64).ceil(), -1.0f64);\n+        assert_approx_eq!((-1.7f64).ceil(), -1.0f64);\n     }\n \n     #[test]\n     fn test_round() {\n-        assert_fuzzy_eq!(1.0f64.round(), 1.0f64);\n-        assert_fuzzy_eq!(1.3f64.round(), 1.0f64);\n-        assert_fuzzy_eq!(1.5f64.round(), 2.0f64);\n-        assert_fuzzy_eq!(1.7f64.round(), 2.0f64);\n-        assert_fuzzy_eq!(0.0f64.round(), 0.0f64);\n-        assert_fuzzy_eq!((-0.0f64).round(), -0.0f64);\n-        assert_fuzzy_eq!((-1.0f64).round(), -1.0f64);\n-        assert_fuzzy_eq!((-1.3f64).round(), -1.0f64);\n-        assert_fuzzy_eq!((-1.5f64).round(), -2.0f64);\n-        assert_fuzzy_eq!((-1.7f64).round(), -2.0f64);\n+        assert_approx_eq!(1.0f64.round(), 1.0f64);\n+        assert_approx_eq!(1.3f64.round(), 1.0f64);\n+        assert_approx_eq!(1.5f64.round(), 2.0f64);\n+        assert_approx_eq!(1.7f64.round(), 2.0f64);\n+        assert_approx_eq!(0.0f64.round(), 0.0f64);\n+        assert_approx_eq!((-0.0f64).round(), -0.0f64);\n+        assert_approx_eq!((-1.0f64).round(), -1.0f64);\n+        assert_approx_eq!((-1.3f64).round(), -1.0f64);\n+        assert_approx_eq!((-1.5f64).round(), -2.0f64);\n+        assert_approx_eq!((-1.7f64).round(), -2.0f64);\n     }\n \n     #[test]\n     fn test_trunc() {\n-        assert_fuzzy_eq!(1.0f64.trunc(), 1.0f64);\n-        assert_fuzzy_eq!(1.3f64.trunc(), 1.0f64);\n-        assert_fuzzy_eq!(1.5f64.trunc(), 1.0f64);\n-        assert_fuzzy_eq!(1.7f64.trunc(), 1.0f64);\n-        assert_fuzzy_eq!(0.0f64.trunc(), 0.0f64);\n-        assert_fuzzy_eq!((-0.0f64).trunc(), -0.0f64);\n-        assert_fuzzy_eq!((-1.0f64).trunc(), -1.0f64);\n-        assert_fuzzy_eq!((-1.3f64).trunc(), -1.0f64);\n-        assert_fuzzy_eq!((-1.5f64).trunc(), -1.0f64);\n-        assert_fuzzy_eq!((-1.7f64).trunc(), -1.0f64);\n+        assert_approx_eq!(1.0f64.trunc(), 1.0f64);\n+        assert_approx_eq!(1.3f64.trunc(), 1.0f64);\n+        assert_approx_eq!(1.5f64.trunc(), 1.0f64);\n+        assert_approx_eq!(1.7f64.trunc(), 1.0f64);\n+        assert_approx_eq!(0.0f64.trunc(), 0.0f64);\n+        assert_approx_eq!((-0.0f64).trunc(), -0.0f64);\n+        assert_approx_eq!((-1.0f64).trunc(), -1.0f64);\n+        assert_approx_eq!((-1.3f64).trunc(), -1.0f64);\n+        assert_approx_eq!((-1.5f64).trunc(), -1.0f64);\n+        assert_approx_eq!((-1.7f64).trunc(), -1.0f64);\n     }\n \n     #[test]\n     fn test_fract() {\n-        assert_fuzzy_eq!(1.0f64.fract(), 0.0f64);\n-        assert_fuzzy_eq!(1.3f64.fract(), 0.3f64);\n-        assert_fuzzy_eq!(1.5f64.fract(), 0.5f64);\n-        assert_fuzzy_eq!(1.7f64.fract(), 0.7f64);\n-        assert_fuzzy_eq!(0.0f64.fract(), 0.0f64);\n-        assert_fuzzy_eq!((-0.0f64).fract(), -0.0f64);\n-        assert_fuzzy_eq!((-1.0f64).fract(), -0.0f64);\n-        assert_fuzzy_eq!((-1.3f64).fract(), -0.3f64);\n-        assert_fuzzy_eq!((-1.5f64).fract(), -0.5f64);\n-        assert_fuzzy_eq!((-1.7f64).fract(), -0.7f64);\n+        assert_approx_eq!(1.0f64.fract(), 0.0f64);\n+        assert_approx_eq!(1.3f64.fract(), 0.3f64);\n+        assert_approx_eq!(1.5f64.fract(), 0.5f64);\n+        assert_approx_eq!(1.7f64.fract(), 0.7f64);\n+        assert_approx_eq!(0.0f64.fract(), 0.0f64);\n+        assert_approx_eq!((-0.0f64).fract(), -0.0f64);\n+        assert_approx_eq!((-1.0f64).fract(), -0.0f64);\n+        assert_approx_eq!((-1.3f64).fract(), -0.3f64);\n+        assert_approx_eq!((-1.5f64).fract(), -0.5f64);\n+        assert_approx_eq!((-1.7f64).fract(), -0.7f64);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_fuzzy_eq!(Real::two_pi::<f64>(), 2.0 * Real::pi::<f64>());\n-        assert_fuzzy_eq!(Real::frac_pi_2::<f64>(), Real::pi::<f64>() / 2f64);\n-        assert_fuzzy_eq!(Real::frac_pi_3::<f64>(), Real::pi::<f64>() / 3f64);\n-        assert_fuzzy_eq!(Real::frac_pi_4::<f64>(), Real::pi::<f64>() / 4f64);\n-        assert_fuzzy_eq!(Real::frac_pi_6::<f64>(), Real::pi::<f64>() / 6f64);\n-        assert_fuzzy_eq!(Real::frac_pi_8::<f64>(), Real::pi::<f64>() / 8f64);\n-        assert_fuzzy_eq!(Real::frac_1_pi::<f64>(), 1f64 / Real::pi::<f64>());\n-        assert_fuzzy_eq!(Real::frac_2_pi::<f64>(), 2f64 / Real::pi::<f64>());\n-        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<f64>(), 2f64 / Real::pi::<f64>().sqrt());\n-        assert_fuzzy_eq!(Real::sqrt2::<f64>(), 2f64.sqrt());\n-        assert_fuzzy_eq!(Real::frac_1_sqrt2::<f64>(), 1f64 / 2f64.sqrt());\n-        assert_fuzzy_eq!(Real::log2_e::<f64>(), Real::e::<f64>().log2());\n-        assert_fuzzy_eq!(Real::log10_e::<f64>(), Real::e::<f64>().log10());\n-        assert_fuzzy_eq!(Real::log_2::<f64>(), 2f64.log());\n-        assert_fuzzy_eq!(Real::log_10::<f64>(), 10f64.log());\n+        assert_approx_eq!(Real::two_pi::<f64>(), 2.0 * Real::pi::<f64>());\n+        assert_approx_eq!(Real::frac_pi_2::<f64>(), Real::pi::<f64>() / 2f64);\n+        assert_approx_eq!(Real::frac_pi_3::<f64>(), Real::pi::<f64>() / 3f64);\n+        assert_approx_eq!(Real::frac_pi_4::<f64>(), Real::pi::<f64>() / 4f64);\n+        assert_approx_eq!(Real::frac_pi_6::<f64>(), Real::pi::<f64>() / 6f64);\n+        assert_approx_eq!(Real::frac_pi_8::<f64>(), Real::pi::<f64>() / 8f64);\n+        assert_approx_eq!(Real::frac_1_pi::<f64>(), 1f64 / Real::pi::<f64>());\n+        assert_approx_eq!(Real::frac_2_pi::<f64>(), 2f64 / Real::pi::<f64>());\n+        assert_approx_eq!(Real::frac_2_sqrtpi::<f64>(), 2f64 / Real::pi::<f64>().sqrt());\n+        assert_approx_eq!(Real::sqrt2::<f64>(), 2f64.sqrt());\n+        assert_approx_eq!(Real::frac_1_sqrt2::<f64>(), 1f64 / 2f64.sqrt());\n+        assert_approx_eq!(Real::log2_e::<f64>(), Real::e::<f64>().log2());\n+        assert_approx_eq!(Real::log10_e::<f64>(), Real::e::<f64>().log10());\n+        assert_approx_eq!(Real::log_2::<f64>(), 2f64.log());\n+        assert_approx_eq!(Real::log_10::<f64>(), 10f64.log());\n     }\n \n     #[test]\n@@ -1022,6 +1028,15 @@ mod tests {\n         assert!(!NaN.is_negative());\n     }\n \n+    #[test]\n+    fn test_approx_eq() {\n+        assert!(1.0f64.approx_eq(&1f64));\n+        assert!(0.9999999f64.approx_eq(&1f64));\n+        assert!(1.000001f64.approx_eq_eps(&1f64, &1.0e-5));\n+        assert!(1.0000001f64.approx_eq_eps(&1f64, &1.0e-6));\n+        assert!(!1.0000001f64.approx_eq_eps(&1f64, &1.0e-7));\n+    }\n+\n     #[test]\n     fn test_primitive() {\n         assert_eq!(Primitive::bits::<f64>(), sys::size_of::<f64>() * 8);"}, {"sha": "a54816532639666faa931c32fa4ab7b0928bc26c", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 90, "deletions": 74, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -371,6 +371,22 @@ impl Eq for float {\n     fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n+#[cfg(notest)]\n+impl ApproxEq<float> for float {\n+    #[inline(always)]\n+    fn approx_epsilon() -> float { 1.0e-6 }\n+\n+    #[inline(always)]\n+    fn approx_eq(&self, other: &float) -> bool {\n+        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<float, float>())\n+    }\n+\n+    #[inline(always)]\n+    fn approx_eq_eps(&self, other: &float, approx_epsilon: &float) -> bool {\n+        (*self - *other).abs() < *approx_epsilon\n+    }\n+}\n+\n #[cfg(notest)]\n impl Ord for float {\n     #[inline(always)]\n@@ -821,15 +837,6 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n-    macro_rules! assert_fuzzy_eq(\n-        ($a:expr, $b:expr) => ({\n-            let a = $a, b = $b;\n-            if !((a - b).abs() < 1.0e-6) {\n-                fail!(fmt!(\"The values were not approximately equal. Found: %? and %?\", a, b));\n-            }\n-        })\n-    )\n-\n     #[test]\n     fn test_num() {\n         num::test_num(10f, 2f);\n@@ -859,91 +866,91 @@ mod tests {\n \n     #[test]\n     fn test_floor() {\n-        assert_fuzzy_eq!(1.0f.floor(), 1.0f);\n-        assert_fuzzy_eq!(1.3f.floor(), 1.0f);\n-        assert_fuzzy_eq!(1.5f.floor(), 1.0f);\n-        assert_fuzzy_eq!(1.7f.floor(), 1.0f);\n-        assert_fuzzy_eq!(0.0f.floor(), 0.0f);\n-        assert_fuzzy_eq!((-0.0f).floor(), -0.0f);\n-        assert_fuzzy_eq!((-1.0f).floor(), -1.0f);\n-        assert_fuzzy_eq!((-1.3f).floor(), -2.0f);\n-        assert_fuzzy_eq!((-1.5f).floor(), -2.0f);\n-        assert_fuzzy_eq!((-1.7f).floor(), -2.0f);\n+        assert_approx_eq!(1.0f.floor(), 1.0f);\n+        assert_approx_eq!(1.3f.floor(), 1.0f);\n+        assert_approx_eq!(1.5f.floor(), 1.0f);\n+        assert_approx_eq!(1.7f.floor(), 1.0f);\n+        assert_approx_eq!(0.0f.floor(), 0.0f);\n+        assert_approx_eq!((-0.0f).floor(), -0.0f);\n+        assert_approx_eq!((-1.0f).floor(), -1.0f);\n+        assert_approx_eq!((-1.3f).floor(), -2.0f);\n+        assert_approx_eq!((-1.5f).floor(), -2.0f);\n+        assert_approx_eq!((-1.7f).floor(), -2.0f);\n     }\n \n     #[test]\n     fn test_ceil() {\n-        assert_fuzzy_eq!(1.0f.ceil(), 1.0f);\n-        assert_fuzzy_eq!(1.3f.ceil(), 2.0f);\n-        assert_fuzzy_eq!(1.5f.ceil(), 2.0f);\n-        assert_fuzzy_eq!(1.7f.ceil(), 2.0f);\n-        assert_fuzzy_eq!(0.0f.ceil(), 0.0f);\n-        assert_fuzzy_eq!((-0.0f).ceil(), -0.0f);\n-        assert_fuzzy_eq!((-1.0f).ceil(), -1.0f);\n-        assert_fuzzy_eq!((-1.3f).ceil(), -1.0f);\n-        assert_fuzzy_eq!((-1.5f).ceil(), -1.0f);\n-        assert_fuzzy_eq!((-1.7f).ceil(), -1.0f);\n+        assert_approx_eq!(1.0f.ceil(), 1.0f);\n+        assert_approx_eq!(1.3f.ceil(), 2.0f);\n+        assert_approx_eq!(1.5f.ceil(), 2.0f);\n+        assert_approx_eq!(1.7f.ceil(), 2.0f);\n+        assert_approx_eq!(0.0f.ceil(), 0.0f);\n+        assert_approx_eq!((-0.0f).ceil(), -0.0f);\n+        assert_approx_eq!((-1.0f).ceil(), -1.0f);\n+        assert_approx_eq!((-1.3f).ceil(), -1.0f);\n+        assert_approx_eq!((-1.5f).ceil(), -1.0f);\n+        assert_approx_eq!((-1.7f).ceil(), -1.0f);\n     }\n \n     #[test]\n     fn test_round() {\n-        assert_fuzzy_eq!(1.0f.round(), 1.0f);\n-        assert_fuzzy_eq!(1.3f.round(), 1.0f);\n-        assert_fuzzy_eq!(1.5f.round(), 2.0f);\n-        assert_fuzzy_eq!(1.7f.round(), 2.0f);\n-        assert_fuzzy_eq!(0.0f.round(), 0.0f);\n-        assert_fuzzy_eq!((-0.0f).round(), -0.0f);\n-        assert_fuzzy_eq!((-1.0f).round(), -1.0f);\n-        assert_fuzzy_eq!((-1.3f).round(), -1.0f);\n-        assert_fuzzy_eq!((-1.5f).round(), -2.0f);\n-        assert_fuzzy_eq!((-1.7f).round(), -2.0f);\n+        assert_approx_eq!(1.0f.round(), 1.0f);\n+        assert_approx_eq!(1.3f.round(), 1.0f);\n+        assert_approx_eq!(1.5f.round(), 2.0f);\n+        assert_approx_eq!(1.7f.round(), 2.0f);\n+        assert_approx_eq!(0.0f.round(), 0.0f);\n+        assert_approx_eq!((-0.0f).round(), -0.0f);\n+        assert_approx_eq!((-1.0f).round(), -1.0f);\n+        assert_approx_eq!((-1.3f).round(), -1.0f);\n+        assert_approx_eq!((-1.5f).round(), -2.0f);\n+        assert_approx_eq!((-1.7f).round(), -2.0f);\n     }\n \n     #[test]\n     fn test_trunc() {\n-        assert_fuzzy_eq!(1.0f.trunc(), 1.0f);\n-        assert_fuzzy_eq!(1.3f.trunc(), 1.0f);\n-        assert_fuzzy_eq!(1.5f.trunc(), 1.0f);\n-        assert_fuzzy_eq!(1.7f.trunc(), 1.0f);\n-        assert_fuzzy_eq!(0.0f.trunc(), 0.0f);\n-        assert_fuzzy_eq!((-0.0f).trunc(), -0.0f);\n-        assert_fuzzy_eq!((-1.0f).trunc(), -1.0f);\n-        assert_fuzzy_eq!((-1.3f).trunc(), -1.0f);\n-        assert_fuzzy_eq!((-1.5f).trunc(), -1.0f);\n-        assert_fuzzy_eq!((-1.7f).trunc(), -1.0f);\n+        assert_approx_eq!(1.0f.trunc(), 1.0f);\n+        assert_approx_eq!(1.3f.trunc(), 1.0f);\n+        assert_approx_eq!(1.5f.trunc(), 1.0f);\n+        assert_approx_eq!(1.7f.trunc(), 1.0f);\n+        assert_approx_eq!(0.0f.trunc(), 0.0f);\n+        assert_approx_eq!((-0.0f).trunc(), -0.0f);\n+        assert_approx_eq!((-1.0f).trunc(), -1.0f);\n+        assert_approx_eq!((-1.3f).trunc(), -1.0f);\n+        assert_approx_eq!((-1.5f).trunc(), -1.0f);\n+        assert_approx_eq!((-1.7f).trunc(), -1.0f);\n     }\n \n     #[test]\n     fn test_fract() {\n-        assert_fuzzy_eq!(1.0f.fract(), 0.0f);\n-        assert_fuzzy_eq!(1.3f.fract(), 0.3f);\n-        assert_fuzzy_eq!(1.5f.fract(), 0.5f);\n-        assert_fuzzy_eq!(1.7f.fract(), 0.7f);\n-        assert_fuzzy_eq!(0.0f.fract(), 0.0f);\n-        assert_fuzzy_eq!((-0.0f).fract(), -0.0f);\n-        assert_fuzzy_eq!((-1.0f).fract(), -0.0f);\n-        assert_fuzzy_eq!((-1.3f).fract(), -0.3f);\n-        assert_fuzzy_eq!((-1.5f).fract(), -0.5f);\n-        assert_fuzzy_eq!((-1.7f).fract(), -0.7f);\n+        assert_approx_eq!(1.0f.fract(), 0.0f);\n+        assert_approx_eq!(1.3f.fract(), 0.3f);\n+        assert_approx_eq!(1.5f.fract(), 0.5f);\n+        assert_approx_eq!(1.7f.fract(), 0.7f);\n+        assert_approx_eq!(0.0f.fract(), 0.0f);\n+        assert_approx_eq!((-0.0f).fract(), -0.0f);\n+        assert_approx_eq!((-1.0f).fract(), -0.0f);\n+        assert_approx_eq!((-1.3f).fract(), -0.3f);\n+        assert_approx_eq!((-1.5f).fract(), -0.5f);\n+        assert_approx_eq!((-1.7f).fract(), -0.7f);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_fuzzy_eq!(Real::two_pi::<float>(), 2f * Real::pi::<float>());\n-        assert_fuzzy_eq!(Real::frac_pi_2::<float>(), Real::pi::<float>() / 2f);\n-        assert_fuzzy_eq!(Real::frac_pi_3::<float>(), Real::pi::<float>() / 3f);\n-        assert_fuzzy_eq!(Real::frac_pi_4::<float>(), Real::pi::<float>() / 4f);\n-        assert_fuzzy_eq!(Real::frac_pi_6::<float>(), Real::pi::<float>() / 6f);\n-        assert_fuzzy_eq!(Real::frac_pi_8::<float>(), Real::pi::<float>() / 8f);\n-        assert_fuzzy_eq!(Real::frac_1_pi::<float>(), 1f / Real::pi::<float>());\n-        assert_fuzzy_eq!(Real::frac_2_pi::<float>(), 2f / Real::pi::<float>());\n-        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<float>(), 2f / Real::pi::<float>().sqrt());\n-        assert_fuzzy_eq!(Real::sqrt2::<float>(), 2f.sqrt());\n-        assert_fuzzy_eq!(Real::frac_1_sqrt2::<float>(), 1f / 2f.sqrt());\n-        assert_fuzzy_eq!(Real::log2_e::<float>(), Real::e::<float>().log2());\n-        assert_fuzzy_eq!(Real::log10_e::<float>(), Real::e::<float>().log10());\n-        assert_fuzzy_eq!(Real::log_2::<float>(), 2f.log());\n-        assert_fuzzy_eq!(Real::log_10::<float>(), 10f.log());\n+        assert_approx_eq!(Real::two_pi::<float>(), 2f * Real::pi::<float>());\n+        assert_approx_eq!(Real::frac_pi_2::<float>(), Real::pi::<float>() / 2f);\n+        assert_approx_eq!(Real::frac_pi_3::<float>(), Real::pi::<float>() / 3f);\n+        assert_approx_eq!(Real::frac_pi_4::<float>(), Real::pi::<float>() / 4f);\n+        assert_approx_eq!(Real::frac_pi_6::<float>(), Real::pi::<float>() / 6f);\n+        assert_approx_eq!(Real::frac_pi_8::<float>(), Real::pi::<float>() / 8f);\n+        assert_approx_eq!(Real::frac_1_pi::<float>(), 1f / Real::pi::<float>());\n+        assert_approx_eq!(Real::frac_2_pi::<float>(), 2f / Real::pi::<float>());\n+        assert_approx_eq!(Real::frac_2_sqrtpi::<float>(), 2f / Real::pi::<float>().sqrt());\n+        assert_approx_eq!(Real::sqrt2::<float>(), 2f.sqrt());\n+        assert_approx_eq!(Real::frac_1_sqrt2::<float>(), 1f / 2f.sqrt());\n+        assert_approx_eq!(Real::log2_e::<float>(), Real::e::<float>().log2());\n+        assert_approx_eq!(Real::log10_e::<float>(), Real::e::<float>().log10());\n+        assert_approx_eq!(Real::log_2::<float>(), 2f.log());\n+        assert_approx_eq!(Real::log_10::<float>(), 10f.log());\n     }\n \n     #[test]\n@@ -985,6 +992,15 @@ mod tests {\n         assert!(!NaN.is_negative());\n     }\n \n+    #[test]\n+    fn test_approx_eq() {\n+        assert!(1.0f.approx_eq(&1f));\n+        assert!(0.9999999f.approx_eq(&1f));\n+        assert!(1.000001f.approx_eq_eps(&1f, &1.0e-5));\n+        assert!(1.0000001f.approx_eq_eps(&1f, &1.0e-6));\n+        assert!(!1.0000001f.approx_eq_eps(&1f, &1.0e-7));\n+    }\n+\n     #[test]\n     fn test_primitive() {\n         assert_eq!(Primitive::bits::<float>(), sys::size_of::<float>() * 8);"}, {"sha": "caa14ea802f6cdc6c821e10fecbb058f2a4e988b", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! An interface for numeric types\n-use cmp::{Eq, Ord};\n+use cmp::{Eq, ApproxEq, Ord};\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n@@ -240,7 +240,8 @@ pub trait Int: Integer\n ///\n pub trait Float: Real\n                + Signed\n-               + Primitive {\n+               + Primitive\n+               + ApproxEq<Self> {\n     // FIXME (#5527): These should be associated constants\n     fn NaN() -> Self;\n     fn infinity() -> Self;"}, {"sha": "10b36d38d43ae77d30f0db60ec582da333b6b402", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -28,7 +28,7 @@ pub use io::{print, println};\n /* Reexported types and traits */\n \n pub use clone::Clone;\n-pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n+pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use old_iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};"}, {"sha": "ccf3ffcdfffcd4b5d2d4a4182884c20ccc1a0c9a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -819,6 +819,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n         }\n \n         encode_name(ecx, ebml_w, item.ident);\n+        encode_attributes(ebml_w, item.attrs);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n "}, {"sha": "ea3793c13748358caabd93b41649447029430553", "filename": "src/libstd/cmp.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -1,102 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the\n-// COPYRIGHT file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Additional general-purpose comparison functionality.\n-\n-use core::f32;\n-use core::f64;\n-use core::float;\n-\n-pub static FUZZY_EPSILON: float = 1.0e-6;\n-\n-pub trait FuzzyEq<Eps> {\n-    fn fuzzy_eq(&self, other: &Self) -> bool;\n-    fn fuzzy_eq_eps(&self, other: &Self, epsilon: &Eps) -> bool;\n-}\n-\n-impl FuzzyEq<float> for float {\n-    fn fuzzy_eq(&self, other: &float) -> bool {\n-        self.fuzzy_eq_eps(other, &FUZZY_EPSILON)\n-    }\n-\n-    fn fuzzy_eq_eps(&self, other: &float, epsilon: &float) -> bool {\n-        float::abs(*self - *other) < *epsilon\n-    }\n-}\n-\n-impl FuzzyEq<f32> for f32 {\n-    fn fuzzy_eq(&self, other: &f32) -> bool {\n-        self.fuzzy_eq_eps(other, &(FUZZY_EPSILON as f32))\n-    }\n-\n-    fn fuzzy_eq_eps(&self, other: &f32, epsilon: &f32) -> bool {\n-        f32::abs(*self - *other) < *epsilon\n-    }\n-}\n-\n-impl FuzzyEq<f64> for f64 {\n-    fn fuzzy_eq(&self, other: &f64) -> bool {\n-        self.fuzzy_eq_eps(other, &(FUZZY_EPSILON as f64))\n-    }\n-\n-    fn fuzzy_eq_eps(&self, other: &f64, epsilon: &f64) -> bool {\n-        f64::abs(*self - *other) < *epsilon\n-    }\n-}\n-\n-#[test]\n-fn test_fuzzy_equals() {\n-    assert!((&1.0f).fuzzy_eq(&1.0));\n-    assert!((&1.0f32).fuzzy_eq(&1.0f32));\n-    assert!((&1.0f64).fuzzy_eq(&1.0f64));\n-}\n-\n-#[test]\n-fn test_fuzzy_eq_eps() {\n-    assert!((&1.2f).fuzzy_eq_eps(&0.9, &0.5));\n-    assert!(!(&1.5f).fuzzy_eq_eps(&0.9, &0.5));\n-}\n-\n-#[cfg(test)]\n-mod test_complex{\n-    use cmp::*;\n-\n-    struct Complex { r: float, i: float }\n-\n-    impl FuzzyEq<float> for Complex {\n-        fn fuzzy_eq(&self, other: &Complex) -> bool {\n-            self.fuzzy_eq_eps(other, &FUZZY_EPSILON)\n-        }\n-\n-        fn fuzzy_eq_eps(&self, other: &Complex,\n-                             epsilon: &float) -> bool {\n-            self.r.fuzzy_eq_eps(&other.r, epsilon) &&\n-            self.i.fuzzy_eq_eps(&other.i, epsilon)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_fuzzy_equals() {\n-        let a = Complex {r: 0.9, i: 0.9};\n-        let b = Complex {r: 0.9, i: 0.9};\n-\n-        assert!((a.fuzzy_eq(&b)));\n-    }\n-\n-    #[test]\n-    fn test_fuzzy_eq_eps() {\n-        let other = Complex {r: 0.9, i: 0.9};\n-\n-        assert!((&Complex {r: 0.9, i: 1.2}).fuzzy_eq_eps(&other, &0.5));\n-        assert!((&Complex {r: 1.2, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n-        assert!(!(&Complex {r: 0.9, i: 1.5}).fuzzy_eq_eps(&other, &0.5));\n-        assert!(!(&Complex {r: 1.5, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n-    }\n-}"}, {"sha": "d96dae76c42903af75fde3f34bcf409e9b01597c", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -93,7 +93,6 @@ pub mod term;\n pub mod time;\n pub mod arena;\n pub mod par;\n-pub mod cmp;\n pub mod base64;\n pub mod rl;\n pub mod workcache;"}, {"sha": "0f2ad4cd54a3da7dacda4c9e33bc6e974ec0e23c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -486,6 +486,42 @@ pub fn core_macros() -> ~str {\n         )\n     )\n \n+    macro_rules! assert_approx_eq (\n+        ($given:expr , $expected:expr) => (\n+            {\n+                use core::cmp::ApproxEq;\n+\n+                let given_val = $given;\n+                let expected_val = $expected;\n+                // check both directions of equality....\n+                if !(\n+                    given_val.approx_eq(&expected_val) &&\n+                    expected_val.approx_eq(&given_val)\n+                ) {\n+                    fail!(\\\"left: %? does not approximately equal right: %?\\\",\n+                          given_val, expected_val);\n+                }\n+            }\n+        );\n+        ($given:expr , $expected:expr , $epsilon:expr) => (\n+            {\n+                use core::cmp::ApproxEq;\n+\n+                let given_val = $given;\n+                let expected_val = $expected;\n+                let epsilon_val = $epsilon;\n+                // check both directions of equality....\n+                if !(\n+                    given_val.approx_eq_eps(&expected_val, &epsilon_val) &&\n+                    expected_val.approx_eq_eps(&given_val, &epsilon_val)\n+                ) {\n+                    fail!(\\\"left: %? does not approximately equal right: %? with epsilon: %?\\\",\n+                          given_val, expected_val, epsilon_val);\n+                }\n+            }\n+        )\n+    )\n+\n     macro_rules! condition (\n \n         { $c:ident: $in:ty -> $out:ty; } => {"}, {"sha": "478d51b540cdfe2465036bcae4247fca1fce0143", "filename": "src/test/auxiliary/packed.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Fauxiliary%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Fauxiliary%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fpacked.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -0,0 +1,5 @@\n+#[packed]\n+struct S {\n+    a: u8,\n+    b: u32\n+}"}, {"sha": "c0c20f7af43515392695c6080827ae282d7b2dff", "filename": "src/test/run-fail/assert-approx-eq-eps-macro-fail.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-fail%2Fassert-approx-eq-eps-macro-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-fail%2Fassert-approx-eq-eps-macro-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-approx-eq-eps-macro-fail.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:left: 1.0000001 does not approximately equal right: 1 with epsilon: 0.0000001\n+pub fn main() {\n+    assert_approx_eq!(1.0000001f, 1.0f, 1.0e-7);\n+}"}, {"sha": "43de4f92b63b1adf8a62de2f2f6327b6bccfc09b", "filename": "src/test/run-fail/assert-approx-eq-macro-fail.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-fail%2Fassert-approx-eq-macro-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-fail%2Fassert-approx-eq-macro-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-approx-eq-macro-fail.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:left: 1.00001 does not approximately equal right: 1\n+pub fn main() {\n+    assert_approx_eq!(1.00001f, 1.0f);\n+}"}, {"sha": "5c7c11ef503431bb53ba5fd69eecade97a1d8fbb", "filename": "src/test/run-pass/assert-approx-eq-macro-success.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Fassert-approx-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Fassert-approx-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-approx-eq-macro-success.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    assert_approx_eq!(1.0f, 1.0f);\n+    assert_approx_eq!(1.0000001f, 1.0f);\n+    assert_approx_eq!(1.0000001f, 1.0f, 1.0e-6);\n+    assert_approx_eq!(1.000001f, 1.0f, 1.0e-5);\n+}"}, {"sha": "c73df8209e8b94114faa55b3e4becab47b44fa83", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -10,10 +10,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern mod std;\n-\n-use std::cmp::FuzzyEq;\n-\n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     pub extern \"rust-intrinsic\" {\n@@ -54,44 +50,44 @@ pub fn main() {\n     unsafe {\n         use rusti::*;\n \n-        assert!((sqrtf32(64f32).fuzzy_eq(&8f32)));\n-        assert!((sqrtf64(64f64).fuzzy_eq(&8f64)));\n+        assert!((sqrtf32(64f32).approx_eq(&8f32)));\n+        assert!((sqrtf64(64f64).approx_eq(&8f64)));\n \n-        assert!((powif32(25f32, -2i32).fuzzy_eq(&0.0016f32)));\n-        assert!((powif64(23.2f64, 2i32).fuzzy_eq(&538.24f64)));\n+        assert!((powif32(25f32, -2i32).approx_eq(&0.0016f32)));\n+        assert!((powif64(23.2f64, 2i32).approx_eq(&538.24f64)));\n \n-        assert!((sinf32(0f32).fuzzy_eq(&0f32)));\n-        assert!((sinf64(f64::consts::pi / 2f64).fuzzy_eq(&1f64)));\n+        assert!((sinf32(0f32).approx_eq(&0f32)));\n+        assert!((sinf64(f64::consts::pi / 2f64).approx_eq(&1f64)));\n \n-        assert!((cosf32(0f32).fuzzy_eq(&1f32)));\n-        assert!((cosf64(f64::consts::pi * 2f64).fuzzy_eq(&1f64)));\n+        assert!((cosf32(0f32).approx_eq(&1f32)));\n+        assert!((cosf64(f64::consts::pi * 2f64).approx_eq(&1f64)));\n \n-        assert!((powf32(25f32, -2f32).fuzzy_eq(&0.0016f32)));\n-        assert!((powf64(400f64, 0.5f64).fuzzy_eq(&20f64)));\n+        assert!((powf32(25f32, -2f32).approx_eq(&0.0016f32)));\n+        assert!((powf64(400f64, 0.5f64).approx_eq(&20f64)));\n \n-        assert!((fabsf32(expf32(1f32) - f32::consts::e).fuzzy_eq(&0f32)));\n-        assert!((expf64(1f64).fuzzy_eq(&f64::consts::e)));\n+        assert!((fabsf32(expf32(1f32) - f32::consts::e).approx_eq(&0f32)));\n+        assert!((expf64(1f64).approx_eq(&f64::consts::e)));\n \n-        assert!((exp2f32(10f32).fuzzy_eq(&1024f32)));\n-        assert!((exp2f64(50f64).fuzzy_eq(&1125899906842624f64)));\n+        assert!((exp2f32(10f32).approx_eq(&1024f32)));\n+        assert!((exp2f64(50f64).approx_eq(&1125899906842624f64)));\n \n-        assert!((fabsf32(logf32(f32::consts::e) - 1f32).fuzzy_eq(&0f32)));\n-        assert!((logf64(1f64).fuzzy_eq(&0f64)));\n+        assert!((fabsf32(logf32(f32::consts::e) - 1f32).approx_eq(&0f32)));\n+        assert!((logf64(1f64).approx_eq(&0f64)));\n \n-        assert!((log10f32(10f32).fuzzy_eq(&1f32)));\n-        assert!((log10f64(f64::consts::e).fuzzy_eq(&f64::consts::log10_e)));\n+        assert!((log10f32(10f32).approx_eq(&1f32)));\n+        assert!((log10f64(f64::consts::e).approx_eq(&f64::consts::log10_e)));\n \n-        assert!((log2f32(8f32).fuzzy_eq(&3f32)));\n-        assert!((log2f64(f64::consts::e).fuzzy_eq(&f64::consts::log2_e)));\n+        assert!((log2f32(8f32).approx_eq(&3f32)));\n+        assert!((log2f64(f64::consts::e).approx_eq(&f64::consts::log2_e)));\n \n-        assert!((fmaf32(1.0f32, 2.0f32, 5.0f32).fuzzy_eq(&7.0f32)));\n-        assert!((fmaf64(0.0f64, -2.0f64, f64::consts::e).fuzzy_eq(&f64::consts::e)));\n+        assert!((fmaf32(1.0f32, 2.0f32, 5.0f32).approx_eq(&7.0f32)));\n+        assert!((fmaf64(0.0f64, -2.0f64, f64::consts::e).approx_eq(&f64::consts::e)));\n \n-        assert!((fabsf32(-1.0f32).fuzzy_eq(&1.0f32)));\n-        assert!((fabsf64(34.2f64).fuzzy_eq(&34.2f64)));\n+        assert!((fabsf32(-1.0f32).approx_eq(&1.0f32)));\n+        assert!((fabsf64(34.2f64).approx_eq(&34.2f64)));\n \n-        assert!((floorf32(3.8f32).fuzzy_eq(&3.0f32)));\n-        assert!((floorf64(-1.1f64).fuzzy_eq(&-2.0f64)));\n+        assert!((floorf32(3.8f32).approx_eq(&3.0f32)));\n+        assert!((floorf64(-1.1f64).approx_eq(&-2.0f64)));\n \n         // Causes linker error\n         // undefined reference to llvm.ceil.f32/64"}, {"sha": "ddfc2b17aa70625ef96fdf4edc56e6f0f464b2b5", "filename": "src/test/run-pass/packed-struct-size-xc.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -0,0 +1,8 @@\n+// xfail-fast\n+// aux-build:packed.rs\n+\n+extern mod packed;\n+\n+fn main() {\n+    assert_eq!(sys::size_of::<packed::S>(), 5);\n+}"}, {"sha": "5179d13813cea4cddb23810b0ceb981f49827b2f", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -14,11 +14,10 @@ extern mod std;\n \n use core::cmp::{Eq, Ord};\n use core::num::NumCast::from;\n-use std::cmp::FuzzyEq;\n \n pub trait NumExt: Num + NumCast + Eq + Ord {}\n \n-pub trait FloatExt: NumExt + FuzzyEq<Self> {}\n+pub trait FloatExt: NumExt + ApproxEq<Self> {}\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > from(1) }\n fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > from(1) }"}, {"sha": "f7edd2855a4cde5a208faebc32fc7efbcacf2b0b", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e4790ca061cd256ab4cb63a269ecf688e25278c/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=2e4790ca061cd256ab4cb63a269ecf688e25278c", "patch": "@@ -16,7 +16,6 @@ extern mod std;\n \n use core::cmp::{Eq, Ord};\n use core::num::NumCast::from;\n-use std::cmp::FuzzyEq;\n \n pub trait TypeExt {}\n \n@@ -94,7 +93,7 @@ impl IntegerExt for i64 {}\n impl IntegerExt for int {}\n \n \n-pub trait FloatExt: NumExt + FuzzyEq<Self> {}\n+pub trait FloatExt: NumExt + ApproxEq<Self> {}\n \n impl FloatExt for f32 {}\n impl FloatExt for f64 {}"}]}