{"sha": "1643d1534b92eef1cf55631aba3ca9289c3cea72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NDNkMTUzNGI5MmVlZjFjZjU1NjMxYWJhM2NhOTI4OWMzY2VhNzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-06T19:11:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-06T19:11:41Z"}, "message": "Merge #8385\n\n8385: Align `InferenceVar` to Chalk r=flodiebold a=flodiebold\n\n\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "8db339ad4a14cde9a63235d7616f648d4e560e56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8db339ad4a14cde9a63235d7616f648d4e560e56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1643d1534b92eef1cf55631aba3ca9289c3cea72", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgbLJtCRBK7hj4Ov3rIwAAdHIIAI4gJiLl4mLNgbq7aiyQJvMK\nL/VV+Uxeron6ffpldWwLayDcxfysBizewokGSez+ya375GbLKwOB2N/AiD46g6Gu\nDTtd7FXrvVt4/xmOCsXTkp6kuYwvuB+sSxk6FT2qwbpazwt2IGDtZplp/WMBaPMX\nOUxDVlKuYkJ82zzlS4kvM515MpVUCKd6XjTV0WJQlStj7DLDH6ju+Mr8yUbb8GT7\n3tioneoiTtUKWSfnp9tNL6j78FTgFVx3PF9ITMUMR7xvbHBhksdALz3/Q2wqrtAj\nmPzmJlLHdxB7IXrw06RVUXo9/K5mLmnlALBv1Rxrxm0lg7gmztOE4EUhnGx1KOI=\n=0Yyh\n-----END PGP SIGNATURE-----\n", "payload": "tree 8db339ad4a14cde9a63235d7616f648d4e560e56\nparent 5df65e5066a534cfb1e0d5ff494b1cd775d5dd90\nparent 768ee3e47a140e354575154f431421375b0b5203\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617736301 +0000\ncommitter GitHub <noreply@github.com> 1617736301 +0000\n\nMerge #8385\n\n8385: Align `InferenceVar` to Chalk r=flodiebold a=flodiebold\n\n\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1643d1534b92eef1cf55631aba3ca9289c3cea72", "html_url": "https://github.com/rust-lang/rust/commit/1643d1534b92eef1cf55631aba3ca9289c3cea72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1643d1534b92eef1cf55631aba3ca9289c3cea72/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5df65e5066a534cfb1e0d5ff494b1cd775d5dd90", "url": "https://api.github.com/repos/rust-lang/rust/commits/5df65e5066a534cfb1e0d5ff494b1cd775d5dd90", "html_url": "https://github.com/rust-lang/rust/commit/5df65e5066a534cfb1e0d5ff494b1cd775d5dd90"}, {"sha": "768ee3e47a140e354575154f431421375b0b5203", "url": "https://api.github.com/repos/rust-lang/rust/commits/768ee3e47a140e354575154f431421375b0b5203", "html_url": "https://github.com/rust-lang/rust/commit/768ee3e47a140e354575154f431421375b0b5203"}], "stats": {"total": 188, "additions": 85, "deletions": 103}, "files": [{"sha": "75d633c960c996cc73215478825168183c3954ab", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=1643d1534b92eef1cf55631aba3ca9289c3cea72", "patch": "@@ -683,25 +683,6 @@ impl<'a> InferenceContext<'a> {\n     }\n }\n \n-/// The kinds of placeholders we need during type inference. There's separate\n-/// values for general types, and for integer and float variables. The latter\n-/// two are used for inference of literal values (e.g. `100` could be one of\n-/// several integer types).\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct InferenceVar {\n-    index: u32,\n-}\n-\n-impl InferenceVar {\n-    fn to_inner(self) -> unify::TypeVarId {\n-        unify::TypeVarId(self.index)\n-    }\n-\n-    fn from_inner(unify::TypeVarId(index): unify::TypeVarId) -> Self {\n-        InferenceVar { index }\n-    }\n-}\n-\n /// When inferring an expression, we propagate downward whatever type hint we\n /// are able in the form of an `Expectation`.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "d717e33759f7afbf518fece059a40e3d194dfbe1", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=1643d1534b92eef1cf55631aba3ca9289c3cea72", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n         t.fold_binders(\n             &mut |ty, binders| match ty.kind(&Interner) {\n                 &TyKind::InferenceVar(var, kind) => {\n-                    let inner = var.to_inner();\n+                    let inner = from_inference_var(var);\n                     if self.var_stack.contains(&inner) {\n                         // recursive type\n                         return self.ctx.table.type_variable_table.fallback_value(var, kind);\n@@ -65,7 +65,7 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n                         result\n                     } else {\n                         let root = self.ctx.table.var_unification_table.find(inner);\n-                        let position = self.add(InferenceVar::from_inner(root), kind);\n+                        let position = self.add(to_inference_var(root), kind);\n                         TyKind::BoundVar(BoundVar::new(binders, position)).intern(&Interner)\n                     }\n                 }\n@@ -207,16 +207,16 @@ impl TypeVariableTable {\n     }\n \n     pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n-        self.inner[iv.to_inner().0 as usize].diverging = diverging;\n+        self.inner[from_inference_var(iv).0 as usize].diverging = diverging;\n     }\n \n     fn is_diverging(&mut self, iv: InferenceVar) -> bool {\n-        self.inner[iv.to_inner().0 as usize].diverging\n+        self.inner[from_inference_var(iv).0 as usize].diverging\n     }\n \n     fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n         match kind {\n-            _ if self.inner[iv.to_inner().0 as usize].diverging => TyKind::Never,\n+            _ if self.inner[from_inference_var(iv).0 as usize].diverging => TyKind::Never,\n             TyVariableKind::General => TyKind::Error,\n             TyVariableKind::Integer => TyKind::Scalar(Scalar::Int(IntTy::I32)),\n             TyVariableKind::Float => TyKind::Scalar(Scalar::Float(FloatTy::F64)),\n@@ -250,7 +250,7 @@ impl InferenceTable {\n         self.type_variable_table.push(TypeVariableData { diverging });\n         let key = self.var_unification_table.new_key(TypeVarValue::Unknown);\n         assert_eq!(key.0 as usize, self.type_variable_table.inner.len() - 1);\n-        TyKind::InferenceVar(InferenceVar::from_inner(key), kind).intern(&Interner)\n+        TyKind::InferenceVar(to_inference_var(key), kind).intern(&Interner)\n     }\n \n     pub(crate) fn new_type_var(&mut self) -> Ty {\n@@ -369,8 +369,12 @@ impl InferenceTable {\n                 == self.type_variable_table.is_diverging(*tv2) =>\n             {\n                 // both type vars are unknown since we tried to resolve them\n-                if !self.var_unification_table.unioned(tv1.to_inner(), tv2.to_inner()) {\n-                    self.var_unification_table.union(tv1.to_inner(), tv2.to_inner());\n+                if !self\n+                    .var_unification_table\n+                    .unioned(from_inference_var(*tv1), from_inference_var(*tv2))\n+                {\n+                    self.var_unification_table\n+                        .union(from_inference_var(*tv1), from_inference_var(*tv2));\n                     self.revision += 1;\n                 }\n                 true\n@@ -407,7 +411,7 @@ impl InferenceTable {\n             ) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(\n-                    tv.to_inner(),\n+                    from_inference_var(*tv),\n                     TypeVarValue::Known(other.clone().intern(&Interner)),\n                 );\n                 self.revision += 1;\n@@ -462,7 +466,7 @@ impl InferenceTable {\n             }\n             match ty.kind(&Interner) {\n                 TyKind::InferenceVar(tv, _) => {\n-                    let inner = tv.to_inner();\n+                    let inner = from_inference_var(*tv);\n                     match self.var_unification_table.inlined_probe_value(inner).known() {\n                         Some(known_ty) => {\n                             // The known_ty can't be a type var itself\n@@ -485,7 +489,7 @@ impl InferenceTable {\n     fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty.kind(&Interner) {\n             &TyKind::InferenceVar(tv, kind) => {\n-                let inner = tv.to_inner();\n+                let inner = from_inference_var(tv);\n                 if tv_stack.contains(&inner) {\n                     cov_mark::hit!(type_var_cycles_resolve_as_possible);\n                     // recursive type\n@@ -512,7 +516,7 @@ impl InferenceTable {\n     fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty.kind(&Interner) {\n             &TyKind::InferenceVar(tv, kind) => {\n-                let inner = tv.to_inner();\n+                let inner = from_inference_var(tv);\n                 if tv_stack.contains(&inner) {\n                     cov_mark::hit!(type_var_cycles_resolve_completely);\n                     // recursive type\n@@ -555,6 +559,14 @@ impl UnifyKey for TypeVarId {\n     }\n }\n \n+fn from_inference_var(var: InferenceVar) -> TypeVarId {\n+    TypeVarId(var.index())\n+}\n+\n+fn to_inference_var(TypeVarId(index): TypeVarId) -> InferenceVar {\n+    index.into()\n+}\n+\n /// The value of a type variable: either we already know the type, or we don't\n /// know it yet.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "5c83a508d45c1c5d4ac17d0943cbf92dede11c9b", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=1643d1534b92eef1cf55631aba3ca9289c3cea72", "patch": "@@ -42,7 +42,7 @@ use crate::{db::HirDatabase, display::HirDisplay, utils::generics};\n pub use autoderef::autoderef;\n pub use builder::TyBuilder;\n pub use chalk_ext::{ProjectionTyExt, TyExt};\n-pub use infer::{could_unify, InferenceResult, InferenceVar};\n+pub use infer::{could_unify, InferenceResult};\n pub use lower::{\n     associated_type_shorthand_candidates, callable_item_sig, CallableDefId, ImplTraitLoweringMode,\n     TyDefId, TyLoweringContext, ValueTyDefId,"}, {"sha": "0536b934e7e3c234e62afc0f595e5733de27ae17", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 37, "deletions": 69, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=1643d1534b92eef1cf55631aba3ca9289c3cea72", "patch": "@@ -10,10 +10,9 @@ use base_db::salsa::InternKey;\n use hir_def::{GenericDefId, TypeAliasId};\n \n use crate::{\n-    chalk_ext::ProjectionTyExt, db::HirDatabase, dummy_usize_const, static_lifetime, AliasTy,\n-    CallableDefId, Canonical, Const, DomainGoal, FnPointer, GenericArg, InEnvironment, Lifetime,\n-    OpaqueTy, ProjectionTy, QuantifiedWhereClause, Substitution, TraitRef, Ty, TypeWalk,\n-    WhereClause,\n+    chalk_ext::ProjectionTyExt, db::HirDatabase, static_lifetime, AliasTy, CallableDefId,\n+    Canonical, DomainGoal, FnPointer, GenericArg, InEnvironment, OpaqueTy, ProjectionTy,\n+    QuantifiedWhereClause, Substitution, TraitRef, Ty, TypeWalk, WhereClause,\n };\n \n use super::interner::*;\n@@ -23,16 +22,16 @@ impl ToChalk for Ty {\n     type Chalk = chalk_ir::Ty<Interner>;\n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n         match self.into_inner() {\n-            TyKind::Ref(m, lt, ty) => ref_to_chalk(db, m, lt, ty),\n-            TyKind::Array(ty, size) => array_to_chalk(db, ty, size),\n-            TyKind::Function(FnPointer { sig, substitution: substs, .. }) => {\n+            TyKind::Ref(m, lt, ty) => {\n+                chalk_ir::TyKind::Ref(m, lt, ty.to_chalk(db)).intern(&Interner)\n+            }\n+            TyKind::Array(ty, size) => {\n+                chalk_ir::TyKind::Array(ty.to_chalk(db), size).intern(&Interner)\n+            }\n+            TyKind::Function(FnPointer { sig, substitution: substs, num_binders }) => {\n                 let substitution = chalk_ir::FnSubst(substs.0.to_chalk(db));\n-                chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n-                    num_binders: 0,\n-                    sig,\n-                    substitution,\n-                })\n-                .intern(&Interner)\n+                chalk_ir::TyKind::Function(chalk_ir::FnPointer { num_binders, sig, substitution })\n+                    .intern(&Interner)\n             }\n             TyKind::AssociatedType(assoc_type_id, substs) => {\n                 let substitution = substs.to_chalk(db);\n@@ -74,22 +73,13 @@ impl ToChalk for Ty {\n                 chalk_ir::TyKind::Adt(adt_id, substitution).intern(&Interner)\n             }\n             TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n-                let associated_ty_id = proj_ty.associated_ty_id;\n-                let substitution = proj_ty.substitution.to_chalk(db);\n-                chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n-                    associated_ty_id,\n-                    substitution,\n-                })\n-                .cast(&Interner)\n-                .intern(&Interner)\n-            }\n-            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n-                let opaque_ty_id = opaque_ty.opaque_ty_id;\n-                let substitution = opaque_ty.substitution.to_chalk(db);\n-                chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy { opaque_ty_id, substitution })\n+                chalk_ir::AliasTy::Projection(proj_ty.to_chalk(db))\n                     .cast(&Interner)\n                     .intern(&Interner)\n             }\n+            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n+                chalk_ir::AliasTy::Opaque(opaque_ty.to_chalk(db)).cast(&Interner).intern(&Interner)\n+            }\n             TyKind::Placeholder(idx) => idx.to_ty::<Interner>(&Interner),\n             TyKind::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n             TyKind::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n@@ -101,7 +91,7 @@ impl ToChalk for Ty {\n                 );\n                 let bounded_ty = chalk_ir::DynTy {\n                     bounds: chalk_ir::Binders::new(binders, where_clauses),\n-                    lifetime: static_lifetime(),\n+                    lifetime: dyn_ty.lifetime,\n                 };\n                 chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n             }\n@@ -114,17 +104,10 @@ impl ToChalk for Ty {\n             chalk_ir::TyKind::Array(ty, size) => TyKind::Array(from_chalk(db, ty), size),\n             chalk_ir::TyKind::Placeholder(idx) => TyKind::Placeholder(idx),\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n-                let associated_ty = proj.associated_ty_id;\n-                let parameters = from_chalk(db, proj.substitution);\n-                TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                    associated_ty_id: associated_ty,\n-                    substitution: parameters,\n-                }))\n+                TyKind::Alias(AliasTy::Projection(from_chalk(db, proj)))\n             }\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n-                let opaque_ty_id = opaque_ty.opaque_ty_id;\n-                let parameters = from_chalk(db, opaque_ty.substitution);\n-                TyKind::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id, substitution: parameters }))\n+                TyKind::Alias(AliasTy::Opaque(from_chalk(db, opaque_ty)))\n             }\n             chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                 num_binders,\n@@ -138,18 +121,19 @@ impl ToChalk for Ty {\n             }\n             chalk_ir::TyKind::BoundVar(idx) => TyKind::BoundVar(idx),\n             chalk_ir::TyKind::InferenceVar(_iv, _kind) => TyKind::Error,\n-            chalk_ir::TyKind::Dyn(where_clauses) => {\n-                assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n-                let bounds = where_clauses\n-                    .bounds\n-                    .skip_binders()\n-                    .iter(&Interner)\n-                    .map(|c| from_chalk(db, c.clone()));\n+            chalk_ir::TyKind::Dyn(dyn_ty) => {\n+                assert_eq!(dyn_ty.bounds.binders.len(&Interner), 1);\n+                let (bounds, binders) = dyn_ty.bounds.into_value_and_skipped_binders();\n+                let where_clauses = crate::QuantifiedWhereClauses::from_iter(\n+                    &Interner,\n+                    bounds.interned().iter().cloned().map(|p| from_chalk(db, p)),\n+                );\n                 TyKind::Dyn(crate::DynTy {\n-                    bounds: crate::Binders::new(\n-                        where_clauses.bounds.binders.clone(),\n-                        crate::QuantifiedWhereClauses::from_iter(&Interner, bounds),\n-                    ),\n+                    bounds: crate::Binders::new(binders, where_clauses),\n+                    // HACK: we sometimes get lifetime variables back in solutions\n+                    // from Chalk, and don't have the infrastructure to substitute\n+                    // them yet. So for now we just turn them into 'static right\n+                    // when we get them\n                     lifetime: static_lifetime(),\n                 })\n             }\n@@ -169,8 +153,12 @@ impl ToChalk for Ty {\n             }\n             chalk_ir::TyKind::Raw(mutability, ty) => TyKind::Raw(mutability, from_chalk(db, ty)),\n             chalk_ir::TyKind::Slice(ty) => TyKind::Slice(from_chalk(db, ty)),\n-            chalk_ir::TyKind::Ref(mutability, lifetime, ty) => {\n-                TyKind::Ref(mutability, lifetime, from_chalk(db, ty))\n+            chalk_ir::TyKind::Ref(mutability, _lifetime, ty) => {\n+                // HACK: we sometimes get lifetime variables back in solutions\n+                // from Chalk, and don't have the infrastructure to substitute\n+                // them yet. So for now we just turn them into 'static right\n+                // when we get them\n+                TyKind::Ref(mutability, static_lifetime(), from_chalk(db, ty))\n             }\n             chalk_ir::TyKind::Str => TyKind::Str,\n             chalk_ir::TyKind::Never => TyKind::Never,\n@@ -189,26 +177,6 @@ impl ToChalk for Ty {\n     }\n }\n \n-/// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n-/// fake lifetime here, because Chalks built-in logic may expect it to be there.\n-fn ref_to_chalk(\n-    db: &dyn HirDatabase,\n-    mutability: chalk_ir::Mutability,\n-    _lifetime: Lifetime,\n-    ty: Ty,\n-) -> chalk_ir::Ty<Interner> {\n-    let arg = ty.to_chalk(db);\n-    let lifetime = static_lifetime();\n-    chalk_ir::TyKind::Ref(mutability, lifetime, arg).intern(&Interner)\n-}\n-\n-/// We currently don't model constants, but Chalk does. So, we have to insert a\n-/// fake constant here, because Chalks built-in logic may expect it to be there.\n-fn array_to_chalk(db: &dyn HirDatabase, ty: Ty, _: Const) -> chalk_ir::Ty<Interner> {\n-    let arg = ty.to_chalk(db);\n-    chalk_ir::TyKind::Array(arg, dummy_usize_const()).intern(&Interner)\n-}\n-\n impl ToChalk for GenericArg {\n     type Chalk = chalk_ir::GenericArg<Interner>;\n "}, {"sha": "eac1b790009619919799fe88873750f49c002316", "filename": "crates/hir_ty/src/types.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1643d1534b92eef1cf55631aba3ca9289c3cea72/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftypes.rs?ref=1643d1534b92eef1cf55631aba3ca9289c3cea72", "patch": "@@ -11,8 +11,7 @@ use smallvec::SmallVec;\n \n use crate::{\n     AssocTypeId, CanonicalVarKinds, ChalkTraitId, ClosureId, Const, FnDefId, FnSig, ForeignDefId,\n-    InferenceVar, Interner, Lifetime, OpaqueTyId, PlaceholderIndex, TypeWalk, VariableKind,\n-    VariableKinds,\n+    Interner, Lifetime, OpaqueTyId, PlaceholderIndex, TypeWalk, VariableKind, VariableKinds,\n };\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -524,3 +523,25 @@ pub enum Guidance {\n     /// There's no useful information to feed back to type inference\n     Unknown,\n }\n+\n+/// The kinds of placeholders we need during type inference. There's separate\n+/// values for general types, and for integer and float variables. The latter\n+/// two are used for inference of literal values (e.g. `100` could be one of\n+/// several integer types).\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct InferenceVar {\n+    index: u32,\n+}\n+\n+impl From<u32> for InferenceVar {\n+    fn from(index: u32) -> InferenceVar {\n+        InferenceVar { index }\n+    }\n+}\n+\n+impl InferenceVar {\n+    /// Gets the underlying index value.\n+    pub fn index(self) -> u32 {\n+        self.index\n+    }\n+}"}]}