{"sha": "1d498d5a4311524fe89a2a0cc8056839a049b28c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNDk4ZDVhNDMxMTUyNGZlODlhMmEwY2M4MDU2ODM5YTA0OWIyOGM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T23:14:29Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T06:44:37Z"}, "message": "make ptr_op finally reponsible for all ops involving pointers; make ValTy constructor private\n\nAlso remove public OpTy constructors, but a pub(crate) constructor remains", "tree": {"sha": "b28174c238fef108c6c7458bca40ea4c7bed1da1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b28174c238fef108c6c7458bca40ea4c7bed1da1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d498d5a4311524fe89a2a0cc8056839a049b28c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d498d5a4311524fe89a2a0cc8056839a049b28c", "html_url": "https://github.com/rust-lang/rust/commit/1d498d5a4311524fe89a2a0cc8056839a049b28c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d498d5a4311524fe89a2a0cc8056839a049b28c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec056d51889349818138d0c92cebcd2eeb4eb730", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec056d51889349818138d0c92cebcd2eeb4eb730", "html_url": "https://github.com/rust-lang/rust/commit/ec056d51889349818138d0c92cebcd2eeb4eb730"}], "stats": {"total": 140, "additions": 63, "deletions": 77}, "files": [{"sha": "70addf2c907e65ebeabff542e3a6c7b1735b013c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=1d498d5a4311524fe89a2a0cc8056839a049b28c", "patch": "@@ -288,21 +288,17 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         )\n     }\n \n-    fn try_ptr_op<'a>(\n+    fn ptr_op<'a>(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        left: Scalar,\n+        _left: Scalar,\n         _left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        _right: Scalar,\n         _right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n-        if left.is_bits() && right.is_bits() {\n-            Ok(None)\n-        } else {\n-            Err(\n-                ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n-            )\n-        }\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        Err(\n+            ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n+        )\n     }\n \n     fn find_foreign_static<'a>("}, {"sha": "83264acf76a31809d7d4047713c592be56c72700", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=1d498d5a4311524fe89a2a0cc8056839a049b28c", "patch": "@@ -48,13 +48,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Misc => {\n                 let src = self.read_value(src)?;\n                 if self.type_is_fat_ptr(src_layout.ty) {\n-                    match (src.value, self.type_is_fat_ptr(dest.layout.ty)) {\n+                    match (*src, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n                         (Value::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n                         (Value::ScalarPair(..), true) => {\n                             // No change to value\n-                            self.write_value(src.value, dest)?;\n+                            self.write_value(*src, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n                         (Value::ScalarPair(data, _), false) => {"}, {"sha": "57af63d63d9c47d074d9572b4c642b588c97345d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1d498d5a4311524fe89a2a0cc8056839a049b28c", "patch": "@@ -69,20 +69,18 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         def_id: DefId,\n     ) -> EvalResult<'tcx, &'tcx Allocation>;\n \n-    /// Called for all binary operations except on float types.\n-    ///\n-    /// Returns `None` if the operation should be handled by the integer\n-    /// op code in order to share more code between machines\n+    /// Called for all binary operations on integer(-like) types when one operand is a pointer\n+    /// value, and for the `Offset` operation that is inherently about pointers.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n-    fn try_ptr_op<'a>(\n+    fn ptr_op<'a>(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n+    ) -> EvalResult<'tcx, (Scalar, bool)>;\n \n     /// Heap allocations via the `box` keyword\n     ///"}, {"sha": "6f9e0cf3e37b60f8d4e0ac636121d23c5c554ed2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=1d498d5a4311524fe89a2a0cc8056839a049b28c", "patch": "@@ -15,7 +15,7 @@ use std::hash::{Hash, Hasher};\n use std::convert::TryInto;\n \n use rustc::{mir, ty};\n-use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n+use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{\n@@ -85,7 +85,7 @@ impl<'tcx> Value {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ValTy<'tcx> {\n-    pub value: Value,\n+    value: Value,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -107,16 +107,6 @@ pub enum Operand {\n }\n \n impl Operand {\n-    #[inline]\n-    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n-        Operand::Indirect(MemPlace::from_ptr(ptr, align))\n-    }\n-\n-    #[inline]\n-    pub fn from_scalar_value(val: Scalar) -> Self {\n-        Operand::Immediate(Value::Scalar(val.into()))\n-    }\n-\n     #[inline]\n     pub fn to_mem_place(self) -> MemPlace {\n         match self {\n@@ -138,7 +128,7 @@ impl Operand {\n \n #[derive(Copy, Clone, Debug)]\n pub struct OpTy<'tcx> {\n-    crate op: Operand, // ideally we'd make this private, but we are not there yet\n+    crate op: Operand, // ideally we'd make this private, but const_prop needs this\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -184,23 +174,6 @@ impl<'tcx> PartialEq for OpTy<'tcx> {\n }\n impl<'tcx> Eq for OpTy<'tcx> {}\n \n-impl<'tcx> OpTy<'tcx> {\n-    #[inline]\n-    pub fn from_ptr(ptr: Pointer, align: Align, layout: TyLayout<'tcx>) -> Self {\n-        OpTy { op: Operand::from_ptr(ptr, align), layout }\n-    }\n-\n-    #[inline]\n-    pub fn from_aligned_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> Self {\n-        OpTy { op: Operand::from_ptr(ptr, layout.align), layout }\n-    }\n-\n-    #[inline]\n-    pub fn from_scalar_value(val: Scalar, layout: TyLayout<'tcx>) -> Self {\n-        OpTy { op: Operand::Immediate(Value::Scalar(val.into())), layout }\n-    }\n-}\n-\n // Use the existing layout if given (but sanity check in debug mode),\n // or compute the layout.\n #[inline(always)]\n@@ -507,7 +480,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ConstValue::ByRef(id, alloc, offset) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway.\n-                Ok(Operand::from_ptr(Pointer::new(id, offset), alloc.align))\n+                Ok(Operand::Indirect(MemPlace::from_ptr(Pointer::new(id, offset), alloc.align)))\n             },\n             ConstValue::ScalarPair(a, b) =>\n                 Ok(Operand::Immediate(Value::ScalarPair(a.into(), b))),"}, {"sha": "d07d37d43b13e64a7eaa958bacae83018b10e185", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=1d498d5a4311524fe89a2a0cc8056839a049b28c", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         right: ValTy<'tcx>,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let (val, overflowed) = self.binary_op(op, left, right)?;\n+        let (val, overflowed) = self.binary_op_val(op, left, right)?;\n         let val = Value::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_value(val, dest)\n     }\n@@ -42,7 +42,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         right: ValTy<'tcx>,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let (val, _overflowed) = self.binary_op(op, left, right)?;\n+        let (val, _overflowed) = self.binary_op_val(op, left, right)?;\n         self.write_scalar(val, dest)\n     }\n }\n@@ -282,16 +282,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok((val, false))\n     }\n \n+    /// Convenience wrapper that's useful when keeping the layout together with the\n+    /// value.\n+    #[inline]\n+    pub fn binary_op_val(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: ValTy<'tcx>,\n+        right: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        self.binary_op(\n+            bin_op,\n+            left.to_scalar()?, left.layout,\n+            right.to_scalar()?, right.layout,\n+        )\n+    }\n+\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        ValTy { value: left, layout: left_layout }: ValTy<'tcx>,\n-        ValTy { value: right, layout: right_layout }: ValTy<'tcx>,\n+        left: Scalar,\n+        left_layout: TyLayout<'tcx>,\n+        right: Scalar,\n+        right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n-        let left = left.to_scalar()?;\n-        let right = right.to_scalar()?;\n-\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op, left, left_layout.ty, right, right_layout.ty);\n \n@@ -322,15 +337,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     right_layout.ty.is_fn());\n \n                 // Handle operations that support pointer values\n-                if let Some(handled) =\n-                    M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n-                {\n-                    return Ok(handled);\n+                if left.is_ptr() || right.is_ptr() || bin_op == mir::BinOp::Offset {\n+                    return M::ptr_op(self, bin_op, left, left_layout, right, right_layout);\n                 }\n \n                 // Everything else only works with \"proper\" bits\n-                let left = left.to_bits(left_layout.size)?;\n-                let right = right.to_bits(right_layout.size)?;\n+                let left = left.to_bits(left_layout.size).expect(\"we checked is_ptr\");\n+                let right = right.to_bits(right_layout.size).expect(\"we checked is_ptr\");\n                 self.binary_int_op(bin_op, left, left_layout, right, right_layout)\n             }\n         }"}, {"sha": "de8681062740938f62df21db9c279c3b17cfd5d3", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=1d498d5a4311524fe89a2a0cc8056839a049b28c", "patch": "@@ -17,7 +17,7 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Value, OpTy, Place, PlaceTy, Operand, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -61,8 +61,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     // Compare using binary_op, to also support pointer values\n                     let const_int = Scalar::from_uint(const_int, discr.layout.size);\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n-                        discr,\n-                        ValTy { value: Value::Scalar(const_int.into()), layout: discr.layout }\n+                        discr.to_scalar()?, discr.layout,\n+                        const_int, discr.layout,\n                     )?;\n                     if res.to_bool()? {\n                         target_block = targets[index];"}, {"sha": "e2b1a255eaca29fba90b48c664c84f5b27b2e5c0", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d498d5a4311524fe89a2a0cc8056839a049b28c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1d498d5a4311524fe89a2a0cc8056839a049b28c", "patch": "@@ -22,7 +22,7 @@ use rustc::mir::interpret::{\n };\n use rustc::ty::{TyCtxt, self, Instance};\n use interpret::{EvalContext, CompileTimeEvaluator, eval_promoted, mk_borrowck_eval_cx};\n-use interpret::{Value, OpTy, MemoryKind};\n+use interpret::{self, Value, OpTy, MemoryKind};\n use transform::{MirPass, MirSource};\n use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n@@ -358,13 +358,15 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n-                    OpTy::from_scalar_value(\n-                        Scalar::Bits {\n-                            bits: n as u128,\n-                            size: self.tcx.data_layout.pointer_size.bytes() as u8,\n-                        },\n-                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    ),\n+                    OpTy {\n+                        op: interpret::Operand::Immediate(Value::Scalar(\n+                            Scalar::Bits {\n+                                bits: n as u128,\n+                                size: self.tcx.data_layout.pointer_size.bytes() as u8,\n+                            }.into()\n+                        )),\n+                        layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    },\n                     span,\n                 )))\n             }\n@@ -399,7 +401,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     // Now run the actual operation.\n                     this.ecx.unary_op(op, prim, arg.layout)\n                 })?;\n-                Some((OpTy::from_scalar_value(val, place_layout), span))\n+                let res = OpTy {\n+                    op: interpret::Operand::Immediate(Value::Scalar(val.into())),\n+                    layout: place_layout,\n+                };\n+                Some((res, span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -454,7 +460,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op(op, l, r)\n+                    this.ecx.binary_op_val(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Value::ScalarPair(\n@@ -470,7 +476,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     Value::Scalar(val.into())\n                 };\n                 let res = OpTy {\n-                    op: ::interpret::Operand::Immediate(val),\n+                    op: interpret::Operand::Immediate(val),\n                     layout: place_layout,\n                 };\n                 Some((res, span))"}]}