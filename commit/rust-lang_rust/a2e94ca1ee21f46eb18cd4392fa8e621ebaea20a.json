{"sha": "a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZTk0Y2ExZWUyMWY0NmViMThjZDQzOTJmYThlNjIxZWJhZWEyMGE=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2019-07-24T22:39:39Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2019-10-24T13:46:44Z"}, "message": "Add `array::IntoIter` as a consuming/by-value array iterator\n\nThe iterator is implemented using const generics. It implements the\ntraits `Iterator`, `DoubleEndedIterator`, `ExactSizeIterator`,\n`FusedIterator` and `TrustedLen`. It also contains a public method\n`new` to create it from an array.\n\n`IntoIterator` was not implemented for arrays yet, as there are still\nsome open questions regarding backwards compatibility. This commit\nonly adds the iterator impl and does not yet offer a convenient way\nto obtain that iterator.", "tree": {"sha": "176e19a4adfc196795c5a0f0c055e35901890fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/176e19a4adfc196795c5a0f0c055e35901890fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEENwctvZ5TgcKYXim8PLr0FT+BhicFAl2xq0QACgkQPLr0FT+B\nhicL1A/8D/miZXUpDthk8XxkMrbvvjxgZnK58SYuER5DsqJ1rIHUNv8PdAK8WkWz\nw05zzfjbQoC526x4I/tQxJYR1hdUyU85DSSoXFTCO0dj2Rf6xdBGojjsu0r95fQv\nq6VtnmLmEGd+5mDJuB9j/oy9LLaHVcl0KsckMAKOwP8aeKtjcArF7I4N7EYhC8iL\nRoIKWzDthY+xcKrQhC9tnYyVJSPokm3+Kz78CcOmXr8DyJlTrR3zQ/svtm5aNUPf\nAjDa4KmonqqhEAJHr4l70PubQjfAGFaKsIpQ+TsgZ1FzBOQ7FgvaGyO588U/DFv3\nevzZrOa9xyIXer9s3WY/QdtrWp1rtR9OnbokC+7MmGamub5mdFZGkO+SUu81gihn\n5Ske7txH73ViuKMZ/UOqTaALjrCXr2efENV9M2wK+B/Uk4ckjfKAxJVEappwjDS5\nTjIzpJBtouZ+CyeAOWQR4CTyAjj+BRT9xK25mDipsYqr3xZae4uXald1HV+Av4el\nMEJmZFS0+TqBFkX8T951En9o4AQJztf75TVXhCJXr+e3W9fzXLCrRMDic84oXAuG\nROECVMD7w+6SylLvXweIUPXFUfRBmPLzXmTIWOiWREDPRj9u503q8ZFuxwjM8ohB\nfmceCfVoH6zOUAMHoAEB2JoMtbz6uTaRv7hLqjZnUk9+Y+XPBPQ=\n=GWHq\n-----END PGP SIGNATURE-----", "payload": "tree 176e19a4adfc196795c5a0f0c055e35901890fd9\nparent 8e0007f829661e57d008d2e908c95f6e84b04b25\nauthor Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1564007979 +0200\ncommitter Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1571924804 +0200\n\nAdd `array::IntoIter` as a consuming/by-value array iterator\n\nThe iterator is implemented using const generics. It implements the\ntraits `Iterator`, `DoubleEndedIterator`, `ExactSizeIterator`,\n`FusedIterator` and `TrustedLen`. It also contains a public method\n`new` to create it from an array.\n\n`IntoIterator` was not implemented for arrays yet, as there are still\nsome open questions regarding backwards compatibility. This commit\nonly adds the iterator impl and does not yet offer a convenient way\nto obtain that iterator.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a", "html_url": "https://github.com/rust-lang/rust/commit/a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e0007f829661e57d008d2e908c95f6e84b04b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0007f829661e57d008d2e908c95f6e84b04b25", "html_url": "https://github.com/rust-lang/rust/commit/8e0007f829661e57d008d2e908c95f6e84b04b25"}], "stats": {"total": 273, "additions": 273, "deletions": 0}, "files": [{"sha": "850a599c6599f46de6858786e3335d87ce30f04e", "filename": "src/libcore/array/iter.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a", "patch": "@@ -0,0 +1,266 @@\n+//! Defines the `IntoIter` owned iterator for arrays.\n+\n+use crate::{\n+    fmt,\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+    mem::{self, MaybeUninit},\n+    ops::Range,\n+    ptr,\n+};\n+use super::LengthAtMost32;\n+\n+\n+/// A by-value [array] iterator.\n+///\n+/// [array]: ../../std/primitive.array.html\n+#[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+pub struct IntoIter<T, const N: usize>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// This is the array we are iterating over.\n+    ///\n+    /// Elements with index `i` where `alive.start <= i < alive.end` have not\n+    /// been yielded yet and are valid array entries. Elements with indices `i\n+    /// < alive.start` or `i >= alive.end` have been yielded already and must\n+    /// not be accessed anymore! Those dead elements might even be in a\n+    /// completely uninitialized state!\n+    ///\n+    /// So the invariants are:\n+    /// - `data[alive]` is alive (i.e. contains valid elements)\n+    /// - `data[..alive.start]` and `data[alive.end..]` are dead (i.e. the\n+    ///   elements were already read and must not be touched anymore!)\n+    data: [MaybeUninit<T>; N],\n+\n+    /// The elements in `data` that have not been yielded yet.\n+    ///\n+    /// Invariants:\n+    /// - `alive.start <= alive.end`\n+    /// - `alive.end <= N`\n+    alive: Range<usize>,\n+}\n+\n+impl<T, const N: usize> IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// Creates a new iterator over the given `array`.\n+    ///\n+    /// *Note*: this method might never get stabilized and/or removed in the\n+    /// future as there will likely be another, preferred way of obtaining this\n+    /// iterator (either via `IntoIterator` for arrays or via another way).\n+    #[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+    pub fn new(array: [T; N]) -> Self {\n+        // The transmute here is actually safe. The docs of `MaybeUninit`\n+        // promise:\n+        //\n+        // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n+        // > as `T`.\n+        //\n+        // The docs even show a transmute from an array of `MaybeUninit<T>` to\n+        // an array of `T`.\n+        //\n+        // With that, this initialization satisfies the invariants.\n+\n+        // FIXME(LukasKalbertodt): actually use `mem::transmute` here, once it\n+        // works with const generics:\n+        //     `mem::transmute::<[T; {N}], [MaybeUninit<T>; {N}]>(array)`\n+        //\n+        // Until then, we do it manually here. We first create a bitwise copy\n+        // but cast the pointer so that it is treated as a different type. Then\n+        // we forget `array` so that it is not dropped.\n+        let data = unsafe {\n+            let data = ptr::read(&array as *const [T; N] as *const [MaybeUninit<T>; N]);\n+            mem::forget(array);\n+            data\n+        };\n+\n+        Self {\n+            data,\n+            alive: 0..N,\n+        }\n+    }\n+\n+    /// Returns an immutable slice of all elements that have not been yielded\n+    /// yet.\n+    fn as_slice(&self) -> &[T] {\n+        // This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n+        // the size and alignment of `T`. Furthermore, we know that all\n+        // elements within `alive` are properly initialized.\n+        let slice = &self.data[self.alive.clone()];\n+        unsafe {\n+            mem::transmute::<&[MaybeUninit<T>], &[T]>(slice)\n+        }\n+    }\n+}\n+\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> Iterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.alive.start == self.alive.end {\n+            return None;\n+        }\n+\n+        // Bump start index.\n+        //\n+        // From the check above we know that `alive.start != alive.end`.\n+        // Combine this with the invariant `alive.start <= alive.end`, we know\n+        // that `alive.start < alive.end`. Increasing `alive.start` by 1\n+        // maintains the invariant regarding `alive`. However, due to this\n+        // change, for a short time, the alive zone is not `data[alive]`\n+        // anymore, but `data[idx..alive.end]`.\n+        let idx = self.alive.start;\n+        self.alive.start += 1;\n+\n+        // Read the element from the array. This is safe: `idx` is an index\n+        // into the \"alive\" region of the array. Reading this element means\n+        // that `data[idx]` is regarded as dead now (i.e. do not touch). As\n+        // `idx` was the start of the alive-zone, the alive zone is now\n+        // `data[alive]` again, restoring all invariants.\n+        let out = unsafe { self.data.get_unchecked(idx).read() };\n+\n+        Some(out)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len();\n+        (len, Some(len))\n+    }\n+\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.alive.start == self.alive.end {\n+            return None;\n+        }\n+\n+        // Decrease end index.\n+        //\n+        // From the check above we know that `alive.start != alive.end`.\n+        // Combine this with the invariant `alive.start <= alive.end`, we know\n+        // that `alive.start < alive.end`. As `alive.start` cannot be negative,\n+        // `alive.end` is at least 1, meaning that we can safely decrement it\n+        // by one. This also maintains the invariant `alive.start <=\n+        // alive.end`. However, due to this change, for a short time, the alive\n+        // zone is not `data[alive]` anymore, but `data[alive.start..alive.end\n+        // + 1]`.\n+        self.alive.end -= 1;\n+\n+        // Read the element from the array. This is safe: `alive.end` is an\n+        // index into the \"alive\" region of the array. Compare the previous\n+        // comment that states that the alive region is\n+        // `data[alive.start..alive.end + 1]`. Reading this element means that\n+        // `data[alive.end]` is regarded as dead now (i.e. do not touch). As\n+        // `alive.end` was the end of the alive-zone, the alive zone is now\n+        // `data[alive]` again, restoring all invariants.\n+        let out = unsafe { self.data.get_unchecked(self.alive.end).read() };\n+\n+        Some(out)\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> Drop for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn drop(&mut self) {\n+        // We simply drop each element via `for_each`. This should not incur\n+        // any significant runtime overhead and avoids adding another `unsafe`\n+        // block.\n+        self.by_ref().for_each(drop);\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> ExactSizeIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn len(&self) -> usize {\n+        // Will never underflow due to the invariant `alive.start <=\n+        // alive.end`.\n+        self.alive.end - self.alive.start\n+    }\n+    fn is_empty(&self) -> bool {\n+        self.alive.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> FusedIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{}\n+\n+// The iterator indeed reports the correct length. The number of \"alive\"\n+// elements (that will still be yielded) is the length of the range `alive`.\n+// This range is decremented in length in either `next` or `next_back`. It is\n+// always decremented by 1 in those methods, but only if `Some(_)` is returned.\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T: Clone, const N: usize> Clone for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn clone(&self) -> Self {\n+        unsafe {\n+            // This creates a new uninitialized array. Note that the `assume_init`\n+            // refers to the array, not the individual elements. And it is Ok if\n+            // the array is in an uninitialized state as all elements may be\n+            // uninitialized (all bit patterns are valid). Compare the\n+            // `MaybeUninit` docs for more information.\n+            let mut new_data: [MaybeUninit<T>; N] = MaybeUninit::uninit().assume_init();\n+\n+            // Clone all alive elements.\n+            for idx in self.alive.clone() {\n+                // The element at `idx` in the old array is alive, so we can\n+                // safely call `get_ref()`. We then clone it, and write the\n+                // clone into the new array.\n+                let clone = self.data.get_unchecked(idx).get_ref().clone();\n+                new_data.get_unchecked_mut(idx).write(clone);\n+            }\n+\n+            Self {\n+                data: new_data,\n+                alive: self.alive.clone(),\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Only print the elements that were not yielded yet: we cannot\n+        // access the yielded elements anymore.\n+        f.debug_tuple(\"IntoIter\")\n+            .field(&self.as_slice())\n+            .finish()\n+    }\n+}"}, {"sha": "120658e9a4343caee366b45152b44c52c8663986", "filename": "src/libcore/array/mod.rs", "status": "renamed", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=a2e94ca1ee21f46eb18cd4392fa8e621ebaea20a", "patch": "@@ -14,6 +14,13 @@ use crate::hash::{Hash, self};\n use crate::marker::Unsize;\n use crate::slice::{Iter, IterMut};\n \n+#[cfg(not(bootstrap))]\n+mod iter;\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+pub use iter::IntoIter;\n+\n /// Utility trait implemented only on arrays of fixed size\n ///\n /// This trait can be used to implement other traits on fixed-size arrays", "previous_filename": "src/libcore/array.rs"}]}