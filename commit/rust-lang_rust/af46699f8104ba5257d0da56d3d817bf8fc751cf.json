{"sha": "af46699f8104ba5257d0da56d3d817bf8fc751cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNDY2OTlmODEwNGJhNTI1N2QwZGE1NmQzZDgxN2JmOGZjNzUxY2Y=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-07-29T17:00:41Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-08-21T18:27:27Z"}, "message": "Remove `Session.used_attrs` and move logic to `CheckAttrVisitor`\n\nInstead of updating global state to mark attributes as used,\nwe now explicitly emit a warning when an attribute is used in\nan unsupported position. As a side effect, we are to emit more\ndetailed warning messages (instead of just a generic \"unused\" message).\n\n`Session.check_name` is removed, since its only purpose was to mark\nthe attribute as used. All of the callers are modified to use\n`Attribute.has_name`\n\nAdditionally, `AttributeType::AssumedUsed` is removed - an 'assumed\nused' attribute is implemented by simply not performing any checks\nin `CheckAttrVisitor` for a particular attribute.\n\nWe no longer emit unused attribute warnings for the `#[rustc_dummy]`\nattribute - it's an internal attribute used for tests, so it doesn't\nmark sense to treat it as 'unused'.\n\nWith this commit, a large source of global untracked state is removed.", "tree": {"sha": "44efd77918662bdbd638ae9f3d26479e52318cfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44efd77918662bdbd638ae9f3d26479e52318cfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af46699f8104ba5257d0da56d3d817bf8fc751cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmEhRZAACgkQtAh+UQ6Y\nsWSjWg//RQ9DFu6aYOIiwtHzj9BeLQt6YBMb+X1dfiZV0GIeA1YrmcfBNj6GFxvK\nRjUxquOt0yWyx+qjNhTZyfqoavm4NFOCsiYzDFuAAf7vEVJ4z4bHV4NvKw96ynA2\nYnZI7XQKuyK2cuqf0rTe4eiRiyoyek1sc5Nz6UJaJC62sGPkdajC3fYBREawL8XJ\npq1prFgdSGTD90hulFDjWO5KsSnH06u5baJi9jkx91/KybP7rLgtoyJyD2YIfUdU\nDwyEm5MLkmZs8eQfjEqaRrb+jDK4hZXIw6zjmGbIKzkqpHwTed6QOBI4+20uFoZd\nAct5UybL/U9GSkaS/KHPChXChaOnh52Cgxhr2ol0F2hAsbRhJ4f91Fpf/taVFOtE\nenPA+AnGlGmUKC+hNMHZ2QRarlGQDOeOvbXe0Okw5ayl0gCwOCV8DP65vxfJuNgA\nsIWkieQOEVxfxp2QYSNzPsDwyUOgXAgZ91epB5c/Zw/Depwa0aHMXY3HbpROWYSy\nga4grcgM/bpu2OnROgryXEjGD7RGMF8tzA3tbpG46h0XDKQwlS66LFqcnGEIdo5X\nfpnv5qBGgcfSlkl4F1jWMCDDhqjuDlrw5fbi9wRRfaeYvp00bxrGNWkv4nmagvuS\nA9REtU8B5ISSdW9GjbOBWbOQRIBLSCDiao4+OOrIcNgFhpld60A=\n=bef7\n-----END PGP SIGNATURE-----", "payload": "tree 44efd77918662bdbd638ae9f3d26479e52318cfd\nparent b6e334d87349502766be70d649e6fe4a73573482\nauthor Aaron Hill <aa1ronham@gmail.com> 1627578041 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1629570447 -0500\n\nRemove `Session.used_attrs` and move logic to `CheckAttrVisitor`\n\nInstead of updating global state to mark attributes as used,\nwe now explicitly emit a warning when an attribute is used in\nan unsupported position. As a side effect, we are to emit more\ndetailed warning messages (instead of just a generic \"unused\" message).\n\n`Session.check_name` is removed, since its only purpose was to mark\nthe attribute as used. All of the callers are modified to use\n`Attribute.has_name`\n\nAdditionally, `AttributeType::AssumedUsed` is removed - an 'assumed\nused' attribute is implemented by simply not performing any checks\nin `CheckAttrVisitor` for a particular attribute.\n\nWe no longer emit unused attribute warnings for the `#[rustc_dummy]`\nattribute - it's an internal attribute used for tests, so it doesn't\nmark sense to treat it as 'unused'.\n\nWith this commit, a large source of global untracked state is removed.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af46699f8104ba5257d0da56d3d817bf8fc751cf", "html_url": "https://github.com/rust-lang/rust/commit/af46699f8104ba5257d0da56d3d817bf8fc751cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af46699f8104ba5257d0da56d3d817bf8fc751cf/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6e334d87349502766be70d649e6fe4a73573482", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e334d87349502766be70d649e6fe4a73573482", "html_url": "https://github.com/rust-lang/rust/commit/b6e334d87349502766be70d649e6fe4a73573482"}], "stats": {"total": 1274, "additions": 535, "deletions": 739}, "files": [{"sha": "e4612d8a954205fbb41d802012135bb6a0646d68", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -4115,10 +4115,12 @@ dependencies = [\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n  \"rustc_middle\",\n+ \"rustc_parse\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "b6aef1543ff1de63bf0707c7a86031449d1b6b4f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -2281,7 +2281,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     synthetic: param\n                         .attrs\n                         .iter()\n-                        .filter(|attr| self.sess.check_name(attr, sym::rustc_synthetic))\n+                        .filter(|attr| attr.has_name(sym::rustc_synthetic))\n                         .map(|_| hir::SyntheticTyParamKind::FromAttr)\n                         .next(),\n                 };"}, {"sha": "0be26b6f8e9de8d8eb11f86558269f2c87cbaff3", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -268,7 +268,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_fn!(self, has_feature, attr.span, name, descr);\n         }\n         // Check unstable flavors of the `#[doc]` attribute.\n-        if self.sess.check_name(attr, sym::doc) {\n+        if attr.has_name(sym::doc) {\n             for nested_meta in attr.meta_item_list().unwrap_or_default() {\n                 macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n                     $(if nested_meta.has_name(sym::$name) {\n@@ -287,7 +287,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         }\n \n         // Check for unstable modifiers on `#[link(..)]` attribute\n-        if self.sess.check_name(attr, sym::link) {\n+        if attr.has_name(sym::link) {\n             for nested_meta in attr.meta_item_list().unwrap_or_default() {\n                 if nested_meta.has_name(sym::modifiers) {\n                     gate_feature_post!(\n@@ -709,7 +709,7 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n \n     if !sess.opts.unstable_features.is_nightly_build() {\n         let lang_features = &sess.features_untracked().declared_lang_features;\n-        for attr in krate.attrs.iter().filter(|attr| sess.check_name(attr, sym::feature)) {\n+        for attr in krate.attrs.iter().filter(|attr| attr.has_name(sym::feature)) {\n             let mut err = struct_span_err!(\n                 sess.parse_sess.span_diagnostic,\n                 attr.span,"}, {"sha": "0ab452fb42dc62161e0e9f1617758f2a68230b7c", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -166,8 +166,6 @@ where\n             continue; // not a stability level\n         }\n \n-        sess.mark_attr_used(attr);\n-\n         let meta = attr.meta();\n \n         if attr.has_name(sym::rustc_promotable) {\n@@ -636,8 +634,7 @@ where\n     let diagnostic = &sess.parse_sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n-        if !(sess.check_name(attr, sym::deprecated) || sess.check_name(attr, sym::rustc_deprecated))\n-        {\n+        if !(attr.has_name(sym::deprecated) || attr.has_name(sym::rustc_deprecated)) {\n             continue;\n         }\n \n@@ -700,17 +697,17 @@ where\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::note if sess.check_name(attr, sym::deprecated) => {\n+                            sym::note if attr.has_name(sym::deprecated) => {\n                                 if !get(mi, &mut note) {\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::reason if sess.check_name(attr, sym::rustc_deprecated) => {\n+                            sym::reason if attr.has_name(sym::rustc_deprecated) => {\n                                 if !get(mi, &mut note) {\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::suggestion if sess.check_name(attr, sym::rustc_deprecated) => {\n+                            sym::suggestion if attr.has_name(sym::rustc_deprecated) => {\n                                 if !get(mi, &mut suggestion) {\n                                     continue 'outer;\n                                 }\n@@ -721,7 +718,7 @@ where\n                                     meta.span(),\n                                     AttrError::UnknownMetaItem(\n                                         pprust::path_to_string(&mi.path),\n-                                        if sess.check_name(attr, sym::deprecated) {\n+                                        if attr.has_name(sym::deprecated) {\n                                             &[\"since\", \"note\"]\n                                         } else {\n                                             &[\"since\", \"reason\", \"suggestion\"]\n@@ -747,11 +744,11 @@ where\n             }\n         }\n \n-        if suggestion.is_some() && sess.check_name(attr, sym::deprecated) {\n+        if suggestion.is_some() && attr.has_name(sym::deprecated) {\n             unreachable!(\"only allowed on rustc_deprecated\")\n         }\n \n-        if sess.check_name(attr, sym::rustc_deprecated) {\n+        if attr.has_name(sym::rustc_deprecated) {\n             if since.is_none() {\n                 handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n                 continue;\n@@ -763,9 +760,7 @@ where\n             }\n         }\n \n-        sess.mark_attr_used(&attr);\n-\n-        let is_since_rustc_version = sess.check_name(attr, sym::rustc_deprecated);\n+        let is_since_rustc_version = attr.has_name(sym::rustc_deprecated);\n         depr = Some((Deprecation { since, note, suggestion, is_since_rustc_version }, attr.span));\n     }\n \n@@ -816,7 +811,6 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n     let diagnostic = &sess.parse_sess.span_diagnostic;\n     if attr.has_name(sym::repr) {\n         if let Some(items) = attr.meta_item_list() {\n-            sess.mark_attr_used(attr);\n             for item in items {\n                 let mut recognised = false;\n                 if item.is_word() {\n@@ -1015,14 +1009,13 @@ pub enum TransparencyError {\n }\n \n pub fn find_transparency(\n-    sess: &Session,\n     attrs: &[Attribute],\n     macro_rules: bool,\n ) -> (Transparency, Option<TransparencyError>) {\n     let mut transparency = None;\n     let mut error = None;\n     for attr in attrs {\n-        if sess.check_name(attr, sym::rustc_macro_transparency) {\n+        if attr.has_name(sym::rustc_macro_transparency) {\n             if let Some((_, old_span)) = transparency {\n                 error = Some(TransparencyError::MultipleTransparencyAttrs(old_span, attr.span));\n                 break;"}, {"sha": "85499623f4135496a3527c6f34453078c0e27e73", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -677,8 +677,6 @@ impl<'a> TraitDef<'a> {\n         let self_type = cx.ty_path(path);\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n-        // Just mark it now since we know that it'll end up used downstream\n-        cx.sess.mark_attr_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n             let word = rustc_ast::attr::mk_nested_word_item(Ident::new("}, {"sha": "7971c1fff428ce7658c3fa64916a72f38495813c", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -260,11 +260,11 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             return;\n         }\n \n-        if self.sess.check_name(attr, sym::proc_macro_derive) {\n+        if attr.has_name(sym::proc_macro_derive) {\n             self.collect_custom_derive(item, attr);\n-        } else if self.sess.check_name(attr, sym::proc_macro_attribute) {\n+        } else if attr.has_name(sym::proc_macro_attribute) {\n             self.collect_attr_proc_macro(item);\n-        } else if self.sess.check_name(attr, sym::proc_macro) {\n+        } else if attr.has_name(sym::proc_macro) {\n             self.collect_bang_proc_macro(item);\n         };\n "}, {"sha": "d791677cb8ee1adbd64cd24f9df8aa3fe5aa1c2c", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -188,8 +188,7 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n                     let attrs = attrs\n                         .into_iter()\n                         .filter(|attr| {\n-                            !self.sess.check_name(attr, sym::rustc_main)\n-                                && !self.sess.check_name(attr, sym::start)\n+                            !attr.has_name(sym::rustc_main) && !attr.has_name(sym::start)\n                         })\n                         .chain(iter::once(allow_dead_code))\n                         .collect();"}, {"sha": "e09893f7f3884a494c76c8a8ea2ddae91518fc2d", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use rustc_ast::tokenstream::{DelimSpan, Spacing};\n use rustc_ast::tokenstream::{LazyTokenStream, TokenTree};\n-use rustc_ast::{self as ast, AstLike, AttrItem, AttrStyle, Attribute, MetaItem};\n+use rustc_ast::{self as ast, AstLike, AttrStyle, Attribute, MetaItem};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -14,7 +14,7 @@ use rustc_feature::{Feature, Features, State as FeatureState};\n use rustc_feature::{\n     ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,\n };\n-use rustc_parse::{parse_in, validate_attr};\n+use rustc_parse::validate_attr;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::edition::{Edition, ALL_EDITIONS};\n@@ -75,7 +75,7 @@ fn get_features(\n     // Process the edition umbrella feature-gates first, to ensure\n     // `edition_enabled_features` is completed before it's queried.\n     for attr in krate_attrs {\n-        if !sess.check_name(attr, sym::feature) {\n+        if !attr.has_name(sym::feature) {\n             continue;\n         }\n \n@@ -108,7 +108,7 @@ fn get_features(\n     }\n \n     for attr in krate_attrs {\n-        if !sess.check_name(attr, sym::feature) {\n+        if !attr.has_name(sym::feature) {\n             continue;\n         }\n \n@@ -237,11 +237,6 @@ macro_rules! configure {\n     };\n }\n \n-const CFG_ATTR_GRAMMAR_HELP: &str = \"#[cfg_attr(condition, attribute, other_attribute, ...)]\";\n-const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n-    <https://doc.rust-lang.org/reference/conditional-compilation.html\\\n-    #the-cfg_attr-attribute>\";\n-\n impl<'a> StripUnconfigured<'a> {\n     pub fn configure<T: AstLike>(&mut self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n@@ -349,19 +344,17 @@ impl<'a> StripUnconfigured<'a> {\n             return vec![attr];\n         }\n \n-        let (cfg_predicate, expanded_attrs) = match self.parse_cfg_attr(&attr) {\n-            None => return vec![],\n-            Some(r) => r,\n-        };\n+        let (cfg_predicate, expanded_attrs) =\n+            match rustc_parse::parse_cfg_attr(&attr, &self.sess.parse_sess) {\n+                None => return vec![],\n+                Some(r) => r,\n+            };\n \n         // Lint on zero attributes in source.\n         if expanded_attrs.is_empty() {\n             return vec![attr];\n         }\n \n-        // At this point we know the attribute is considered used.\n-        self.sess.mark_attr_used(&attr);\n-\n         if !attr::cfg_matches(&cfg_predicate, &self.sess.parse_sess, self.features) {\n             return vec![];\n         }\n@@ -415,46 +408,10 @@ impl<'a> StripUnconfigured<'a> {\n             .collect()\n     }\n \n-    fn parse_cfg_attr(&self, attr: &Attribute) -> Option<(MetaItem, Vec<(AttrItem, Span)>)> {\n-        match attr.get_normal_item().args {\n-            ast::MacArgs::Delimited(dspan, delim, ref tts) if !tts.is_empty() => {\n-                let msg = \"wrong `cfg_attr` delimiters\";\n-                validate_attr::check_meta_bad_delim(&self.sess.parse_sess, dspan, delim, msg);\n-                match parse_in(&self.sess.parse_sess, tts.clone(), \"`cfg_attr` input\", |p| {\n-                    p.parse_cfg_attr()\n-                }) {\n-                    Ok(r) => return Some(r),\n-                    Err(mut e) => {\n-                        e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n-                            .note(CFG_ATTR_NOTE_REF)\n-                            .emit();\n-                    }\n-                }\n-            }\n-            _ => self.error_malformed_cfg_attr_missing(attr.span),\n-        }\n-        None\n-    }\n-\n-    fn error_malformed_cfg_attr_missing(&self, span: Span) {\n-        self.sess\n-            .parse_sess\n-            .span_diagnostic\n-            .struct_span_err(span, \"malformed `cfg_attr` attribute input\")\n-            .span_suggestion(\n-                span,\n-                \"missing condition and attribute\",\n-                CFG_ATTR_GRAMMAR_HELP.to_string(),\n-                Applicability::HasPlaceholders,\n-            )\n-            .note(CFG_ATTR_NOTE_REF)\n-            .emit();\n-    }\n-\n     /// Determines if a node with the given attributes should be included in this configuration.\n     fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n-            if !is_cfg(self.sess, attr) {\n+            if !is_cfg(attr) {\n                 return true;\n             }\n             let meta_item = match validate_attr::parse_meta(&self.sess.parse_sess, attr) {\n@@ -500,7 +457,7 @@ impl<'a> StripUnconfigured<'a> {\n         //\n         // N.B., this is intentionally not part of the visit_expr() function\n         //     in order for filter_map_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(self.sess, a)) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(*a)) {\n             let msg = \"removing an expression is not supported in this position\";\n             self.sess.parse_sess.span_diagnostic.span_err(attr.span, msg);\n         }\n@@ -536,6 +493,6 @@ pub fn parse_cfg<'a>(meta_item: &'a MetaItem, sess: &Session) -> Option<&'a Meta\n     }\n }\n \n-fn is_cfg(sess: &Session, attr: &Attribute) -> bool {\n-    sess.check_name(attr, sym::cfg)\n+fn is_cfg(attr: &Attribute) -> bool {\n+    attr.has_name(sym::cfg)\n }"}, {"sha": "abe81ec978f0d886857fd4abd5a3379e164793aa", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -753,11 +753,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         }\n                     }\n                 }\n-                SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n+                SyntaxExtensionKind::NonMacroAttr { mark_used: _ } => {\n                     self.cx.expanded_inert_attrs.mark(&attr);\n-                    if *mark_used {\n-                        self.cx.sess.mark_attr_used(&attr);\n-                    }\n                     item.visit_attrs(|attrs| attrs.insert(pos, attr));\n                     fragment_kind.expect_from_annotatables(iter::once(item))\n                 }"}, {"sha": "e0c62388fe0ce7f4f49bf6e2392de4cff166ad14", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -535,7 +535,7 @@ pub fn compile_declarative_macro(\n \n     valid &= macro_check::check_meta_variables(&sess.parse_sess, def.id, def.span, &lhses, &rhses);\n \n-    let (transparency, transparency_error) = attr::find_transparency(sess, &def.attrs, macro_rules);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) => {\n             diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value))"}, {"sha": "45db4c7f1186fa794f6674582fb80b0ea4f1fce1", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 79, "deletions": 84, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -52,11 +52,6 @@ pub enum AttributeType {\n     /// by the compiler before the unused_attribute check\n     Normal,\n \n-    /// Builtin attribute that may not be consumed by the compiler\n-    /// before the unused_attribute check. These attributes\n-    /// will be ignored by the unused_attribute lint\n-    AssumedUsed,\n-\n     /// Builtin attribute that is only allowed at the crate level\n     CrateLevel,\n }\n@@ -186,7 +181,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"),\n     ),\n     // FIXME(Centril): This can be used on stable but shouldn't.\n-    ungated!(reexport_test_harness_main, Normal, template!(NameValueStr: \"name\")),\n+    ungated!(reexport_test_harness_main, CrateLevel, template!(NameValueStr: \"name\")),\n \n     // Macros:\n     ungated!(automatically_derived, Normal, template!(Word)),\n@@ -206,7 +201,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n     ungated!(forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n     ungated!(deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n-    ungated!(must_use, AssumedUsed, template!(Word, NameValueStr: \"reason\")),\n+    ungated!(must_use, Normal, template!(Word, NameValueStr: \"reason\")),\n     // FIXME(#14407)\n     ungated!(\n         deprecated, Normal,\n@@ -224,16 +219,16 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // ABI, linking, symbols, and FFI\n     ungated!(\n-        link, AssumedUsed,\n+        link, Normal,\n         template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\"\"#),\n     ),\n-    ungated!(link_name, AssumedUsed, template!(NameValueStr: \"name\")),\n-    ungated!(no_link, AssumedUsed, template!(Word)),\n-    ungated!(repr, AssumedUsed, template!(List: \"C\")),\n-    ungated!(export_name, AssumedUsed, template!(NameValueStr: \"name\")),\n-    ungated!(link_section, AssumedUsed, template!(NameValueStr: \"name\")),\n-    ungated!(no_mangle, AssumedUsed, template!(Word)),\n-    ungated!(used, AssumedUsed, template!(Word)),\n+    ungated!(link_name, Normal, template!(NameValueStr: \"name\")),\n+    ungated!(no_link, Normal, template!(Word)),\n+    ungated!(repr, Normal, template!(List: \"C\")),\n+    ungated!(export_name, Normal, template!(NameValueStr: \"name\")),\n+    ungated!(link_section, Normal, template!(NameValueStr: \"name\")),\n+    ungated!(no_mangle, Normal, template!(Word)),\n+    ungated!(used, Normal, template!(Word)),\n \n     // Limits:\n     ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\")),\n@@ -256,37 +251,37 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Modules, prelude, and resolution:\n     ungated!(path, Normal, template!(NameValueStr: \"file\")),\n     ungated!(no_std, CrateLevel, template!(Word)),\n-    ungated!(no_implicit_prelude, Normal, template!(Word)),\n-    ungated!(non_exhaustive, AssumedUsed, template!(Word)),\n+    ungated!(no_implicit_prelude, CrateLevel, template!(Word)),\n+    ungated!(non_exhaustive, Normal, template!(Word)),\n \n     // Runtime\n-    ungated!(windows_subsystem, AssumedUsed, template!(NameValueStr: \"windows|console\")),\n+    ungated!(windows_subsystem, Normal, template!(NameValueStr: \"windows|console\")),\n     ungated!(panic_handler, Normal, template!(Word)), // RFC 2070\n \n     // Code generation:\n-    ungated!(inline, AssumedUsed, template!(Word, List: \"always|never\")),\n-    ungated!(cold, AssumedUsed, template!(Word)),\n-    ungated!(no_builtins, AssumedUsed, template!(Word)),\n-    ungated!(target_feature, AssumedUsed, template!(List: r#\"enable = \"name\"\"#)),\n-    ungated!(track_caller, AssumedUsed, template!(Word)),\n+    ungated!(inline, Normal, template!(Word, List: \"always|never\")),\n+    ungated!(cold, Normal, template!(Word)),\n+    ungated!(no_builtins, Normal, template!(Word)),\n+    ungated!(target_feature, Normal, template!(List: r#\"enable = \"name\"\"#)),\n+    ungated!(track_caller, Normal, template!(Word)),\n     gated!(\n-        no_sanitize, AssumedUsed,\n+        no_sanitize, Normal,\n         template!(List: \"address, memory, thread\"),\n         experimental!(no_sanitize)\n     ),\n-    gated!(no_coverage, AssumedUsed, template!(Word), experimental!(no_coverage)),\n+    gated!(no_coverage, Normal, template!(Word), experimental!(no_coverage)),\n \n     // FIXME: #14408 assume docs are used since rustdoc looks at them.\n-    ungated!(doc, AssumedUsed, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),\n+    ungated!(doc, Normal, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),\n \n     // ==========================================================================\n     // Unstable attributes:\n     // ==========================================================================\n \n     // Linking:\n-    gated!(naked, AssumedUsed, template!(Word), naked_functions, experimental!(naked)),\n+    gated!(naked, Normal, template!(Word), naked_functions, experimental!(naked)),\n     gated!(\n-        link_ordinal, AssumedUsed, template!(List: \"ordinal\"), raw_dylib,\n+        link_ordinal, Normal, template!(List: \"ordinal\"), raw_dylib,\n         experimental!(link_ordinal)\n     ),\n \n@@ -311,23 +306,23 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         \"custom test frameworks are an unstable feature\",\n     ),\n     // RFC #1268\n-    gated!(marker, AssumedUsed, template!(Word), marker_trait_attr, experimental!(marker)),\n+    gated!(marker, Normal, template!(Word), marker_trait_attr, experimental!(marker)),\n     gated!(\n-        thread_local, AssumedUsed, template!(Word),\n+        thread_local, Normal, template!(Word),\n         \"`#[thread_local]` is an experimental feature, and does not currently handle destructors\",\n     ),\n     gated!(no_core, CrateLevel, template!(Word), experimental!(no_core)),\n     // RFC 2412\n     gated!(\n-        optimize, AssumedUsed, template!(List: \"size|speed\"), optimize_attribute,\n+        optimize, Normal, template!(List: \"size|speed\"), optimize_attribute,\n         experimental!(optimize),\n     ),\n     // RFC 2867\n-    gated!(instruction_set, AssumedUsed, template!(List: \"set\"), isa_attribute, experimental!(instruction_set)),\n+    gated!(instruction_set, Normal, template!(List: \"set\"), isa_attribute, experimental!(instruction_set)),\n \n-    gated!(ffi_returns_twice, AssumedUsed, template!(Word), experimental!(ffi_returns_twice)),\n-    gated!(ffi_pure, AssumedUsed, template!(Word), experimental!(ffi_pure)),\n-    gated!(ffi_const, AssumedUsed, template!(Word), experimental!(ffi_const)),\n+    gated!(ffi_returns_twice, Normal, template!(Word), experimental!(ffi_returns_twice)),\n+    gated!(ffi_pure, Normal, template!(Word), experimental!(ffi_pure)),\n+    gated!(ffi_const, Normal, template!(Word), experimental!(ffi_const)),\n     gated!(\n         register_attr, CrateLevel, template!(List: \"attr1, attr2, ...\"),\n         experimental!(register_attr),\n@@ -337,10 +332,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         experimental!(register_tool),\n     ),\n \n-    gated!(cmse_nonsecure_entry, AssumedUsed, template!(Word), experimental!(cmse_nonsecure_entry)),\n+    gated!(cmse_nonsecure_entry, Normal, template!(Word), experimental!(cmse_nonsecure_entry)),\n     // RFC 2632\n     gated!(\n-        default_method_body_is_const, AssumedUsed, template!(Word), const_trait_impl,\n+        default_method_body_is_const, Normal, template!(Word), const_trait_impl,\n         \"`default_method_body_is_const` is a temporary placeholder for declaring default bodies \\\n         as `const`, which may be removed or renamed in the future.\"\n     ),\n@@ -353,26 +348,26 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // FIXME(#14407) -- only looked at on-demand so we can't\n     // guarantee they'll have already been checked.\n     ungated!(\n-        rustc_deprecated, AssumedUsed,\n+        rustc_deprecated, Normal,\n         template!(List: r#\"since = \"version\", reason = \"...\"\"#)\n     ),\n     // FIXME(#14407)\n-    ungated!(stable, AssumedUsed, template!(List: r#\"feature = \"name\", since = \"version\"\"#)),\n+    ungated!(stable, Normal, template!(List: r#\"feature = \"name\", since = \"version\"\"#)),\n     // FIXME(#14407)\n     ungated!(\n-        unstable, AssumedUsed,\n+        unstable, Normal,\n         template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#),\n     ),\n     // FIXME(#14407)\n-    ungated!(rustc_const_unstable, AssumedUsed, template!(List: r#\"feature = \"name\"\"#)),\n+    ungated!(rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#)),\n     // FIXME(#14407)\n-    ungated!(rustc_const_stable, AssumedUsed, template!(List: r#\"feature = \"name\"\"#)),\n+    ungated!(rustc_const_stable, Normal, template!(List: r#\"feature = \"name\"\"#)),\n     gated!(\n-        allow_internal_unstable, AssumedUsed, template!(Word, List: \"feat1, feat2, ...\"),\n+        allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n         \"allow_internal_unstable side-steps feature gating and stability checks\",\n     ),\n     gated!(\n-        rustc_allow_const_fn_unstable, AssumedUsed, template!(Word, List: \"feat1, feat2, ...\"),\n+        rustc_allow_const_fn_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n         \"rustc_allow_const_fn_unstable side-steps feature gating and stability checks\"\n     ),\n     gated!(\n@@ -384,7 +379,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes: Type system related:\n     // ==========================================================================\n \n-    gated!(fundamental, AssumedUsed, template!(Word), experimental!(fundamental)),\n+    gated!(fundamental, Normal, template!(Word), experimental!(fundamental)),\n     gated!(\n         may_dangle, Normal, template!(Word), dropck_eyepatch,\n         \"`may_dangle` has unstable semantics and may be removed in the future\",\n@@ -394,26 +389,26 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes: Runtime related:\n     // ==========================================================================\n \n-    rustc_attr!(rustc_allocator, AssumedUsed, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_allocator_nounwind, AssumedUsed, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allocator, Normal, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allocator_nounwind, Normal, template!(Word), IMPL_DETAIL),\n     gated!(alloc_error_handler, Normal, template!(Word), experimental!(alloc_error_handler)),\n     gated!(\n-        default_lib_allocator, AssumedUsed, template!(Word), allocator_internals,\n+        default_lib_allocator, Normal, template!(Word), allocator_internals,\n         experimental!(default_lib_allocator),\n     ),\n     gated!(\n         needs_allocator, Normal, template!(Word), allocator_internals,\n         experimental!(needs_allocator),\n     ),\n-    gated!(panic_runtime, AssumedUsed, template!(Word), experimental!(panic_runtime)),\n-    gated!(needs_panic_runtime, AssumedUsed, template!(Word), experimental!(needs_panic_runtime)),\n+    gated!(panic_runtime, Normal, template!(Word), experimental!(panic_runtime)),\n+    gated!(needs_panic_runtime, Normal, template!(Word), experimental!(needs_panic_runtime)),\n     gated!(\n-        compiler_builtins, AssumedUsed, template!(Word),\n+        compiler_builtins, Normal, template!(Word),\n         \"the `#[compiler_builtins]` attribute is used to identify the `compiler_builtins` crate \\\n         which contains compiler-rt intrinsics and will never be stable\",\n     ),\n     gated!(\n-        profiler_runtime, AssumedUsed, template!(Word),\n+        profiler_runtime, Normal, template!(Word),\n         \"the `#[profiler_runtime]` attribute is used to identify the `profiler_builtins` crate \\\n         which contains the profiler runtime and will never be stable\",\n     ),\n@@ -423,23 +418,23 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     gated!(\n-        linkage, AssumedUsed, template!(NameValueStr: \"external|internal|...\"),\n+        linkage, Normal, template!(NameValueStr: \"external|internal|...\"),\n         \"the `linkage` attribute is experimental and not portable across platforms\",\n     ),\n-    rustc_attr!(rustc_std_internal_symbol, AssumedUsed, template!(Word), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_std_internal_symbol, Normal, template!(Word), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Macro related:\n     // ==========================================================================\n \n     rustc_attr!(\n-        rustc_builtin_macro, AssumedUsed,\n+        rustc_builtin_macro, Normal,\n         template!(Word, List: \"name, /*opt*/ attributes(name1, name2, ...)\"),\n         IMPL_DETAIL,\n     ),\n     rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), INTERNAL_UNSTABLE),\n     rustc_attr!(\n-        rustc_macro_transparency, AssumedUsed,\n+        rustc_macro_transparency, Normal,\n         template!(NameValueStr: \"transparent|semitransparent|opaque\"),\n         \"used internally for testing macro hygiene\",\n     ),\n@@ -449,39 +444,39 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     rustc_attr!(\n-        rustc_on_unimplemented, AssumedUsed,\n+        rustc_on_unimplemented, Normal,\n         template!(\n             List: r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n             NameValueStr: \"message\"\n         ),\n         INTERNAL_UNSTABLE\n     ),\n     // Enumerates \"identity-like\" conversion methods to suggest on type mismatch.\n-    rustc_attr!(rustc_conversion_suggestion, AssumedUsed, template!(Word), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_conversion_suggestion, Normal, template!(Word), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Const related:\n     // ==========================================================================\n \n-    rustc_attr!(rustc_promotable, AssumedUsed, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_legacy_const_generics, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_promotable, Normal, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_legacy_const_generics, Normal, template!(List: \"N\"), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Layout related:\n     // ==========================================================================\n \n     rustc_attr!(\n-        rustc_layout_scalar_valid_range_start, AssumedUsed, template!(List: \"value\"),\n+        rustc_layout_scalar_valid_range_start, Normal, template!(List: \"value\"),\n         \"the `#[rustc_layout_scalar_valid_range_start]` attribute is just used to enable \\\n         niche optimizations in libcore and will never be stable\",\n     ),\n     rustc_attr!(\n-        rustc_layout_scalar_valid_range_end, AssumedUsed, template!(List: \"value\"),\n+        rustc_layout_scalar_valid_range_end, Normal, template!(List: \"value\"),\n         \"the `#[rustc_layout_scalar_valid_range_end]` attribute is just used to enable \\\n         niche optimizations in libcore and will never be stable\",\n     ),\n     rustc_attr!(\n-        rustc_nonnull_optimization_guaranteed, AssumedUsed, template!(Word),\n+        rustc_nonnull_optimization_guaranteed, Normal, template!(Word),\n         \"the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable \\\n         niche optimizations in libcore and will never be stable\",\n     ),\n@@ -506,15 +501,15 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     gated!(\n         // Used in resolve:\n-        prelude_import, AssumedUsed, template!(Word),\n+        prelude_import, Normal, template!(Word),\n         \"`#[prelude_import]` is for use by rustc only\",\n     ),\n     gated!(\n         rustc_paren_sugar, Normal, template!(Word), unboxed_closures,\n         \"unboxed_closures are still evolving\",\n     ),\n     rustc_attr!(\n-        rustc_inherit_overflow_checks, AssumedUsed, template!(Word),\n+        rustc_inherit_overflow_checks, Normal, template!(Word),\n         \"the `#[rustc_inherit_overflow_checks]` attribute is just used to control \\\n         overflow checking behavior of several libcore functions that are inlined \\\n         across crates and will never be stable\",\n@@ -556,41 +551,41 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\")),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word)),\n     rustc_attr!(\n-        TEST, rustc_error, AssumedUsed,\n+        TEST, rustc_error, Normal,\n         template!(Word, List: \"delay_span_bug_from_inside_query\")\n     ),\n-    rustc_attr!(TEST, rustc_dump_user_substs, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_evaluate_where_clauses, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_if_this_changed, AssumedUsed, template!(Word, List: \"DepNode\")),\n-    rustc_attr!(TEST, rustc_then_this_would_need, AssumedUsed, template!(List: \"DepNode\")),\n+    rustc_attr!(TEST, rustc_dump_user_substs, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_evaluate_where_clauses, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_if_this_changed, Normal, template!(Word, List: \"DepNode\")),\n+    rustc_attr!(TEST, rustc_then_this_would_need, Normal, template!(List: \"DepNode\")),\n     rustc_attr!(\n-        TEST, rustc_clean, AssumedUsed,\n+        TEST, rustc_clean, Normal,\n         template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n     ),\n     rustc_attr!(\n-        TEST, rustc_partition_reused, AssumedUsed,\n+        TEST, rustc_partition_reused, Normal,\n         template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n     ),\n     rustc_attr!(\n-        TEST, rustc_partition_codegened, AssumedUsed,\n+        TEST, rustc_partition_codegened, Normal,\n         template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n     ),\n     rustc_attr!(\n-        TEST, rustc_expected_cgu_reuse, AssumedUsed,\n+        TEST, rustc_expected_cgu_reuse, Normal,\n         template!(List: r#\"cfg = \"...\", module = \"...\", kind = \"...\"\"#),\n     ),\n-    rustc_attr!(TEST, rustc_synthetic, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_symbol_name, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_polymorphize_error, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_def_path, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_mir, AssumedUsed, template!(List: \"arg1, arg2, ...\")),\n-    rustc_attr!(TEST, rustc_dump_program_clauses, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_dump_env_program_clauses, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_object_lifetime_default, AssumedUsed, template!(Word)),\n-    rustc_attr!(TEST, rustc_dump_vtable, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_synthetic, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_symbol_name, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_polymorphize_error, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_def_path, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_mir, Normal, template!(List: \"arg1, arg2, ...\")),\n+    rustc_attr!(TEST, rustc_dump_program_clauses, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_dump_env_program_clauses, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_object_lifetime_default, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_dump_vtable, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_dummy, Normal, template!(Word /* doesn't matter*/)),\n     gated!(\n-        omit_gdb_pretty_printer_section, AssumedUsed, template!(Word),\n+        omit_gdb_pretty_printer_section, Normal, template!(Word),\n         \"the `#[omit_gdb_pretty_printer_section]` attribute is just used for the Rust test suite\",\n     ),\n ];"}, {"sha": "0a558eb0555de713a76217746dedd77fee8e173b", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -123,7 +123,7 @@ impl IfThisChanged<'tcx> {\n         let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n         let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n-            if self.tcx.sess.check_name(attr, sym::rustc_if_this_changed) {\n+            if attr.has_name(sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     None => DepNode::from_def_path_hash(def_path_hash, DepKind::hir_owner),\n@@ -138,7 +138,7 @@ impl IfThisChanged<'tcx> {\n                     },\n                 };\n                 self.if_this_changed.push((attr.span, def_id.to_def_id(), dep_node));\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_then_this_would_need) {\n+            } else if attr.has_name(sym::rustc_then_this_would_need) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     Some(n) => match DepNode::from_label_string(&n.as_str(), def_path_hash) {"}, {"sha": "a5f3e4553ce56abc45c8a77e1d5a8ad2e9be9294", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -57,27 +57,26 @@ struct AssertModuleSource<'tcx> {\n \n impl AssertModuleSource<'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n-        let (expected_reuse, comp_kind) =\n-            if self.tcx.sess.check_name(attr, sym::rustc_partition_reused) {\n-                (CguReuse::PreLto, ComparisonKind::AtLeast)\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_partition_codegened) {\n-                (CguReuse::No, ComparisonKind::Exact)\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_expected_cgu_reuse) {\n-                match self.field(attr, sym::kind) {\n-                    sym::no => (CguReuse::No, ComparisonKind::Exact),\n-                    sym::pre_dash_lto => (CguReuse::PreLto, ComparisonKind::Exact),\n-                    sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n-                    sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n-                    other => {\n-                        self.tcx.sess.span_fatal(\n-                            attr.span,\n-                            &format!(\"unknown cgu-reuse-kind `{}` specified\", other),\n-                        );\n-                    }\n+        let (expected_reuse, comp_kind) = if attr.has_name(sym::rustc_partition_reused) {\n+            (CguReuse::PreLto, ComparisonKind::AtLeast)\n+        } else if attr.has_name(sym::rustc_partition_codegened) {\n+            (CguReuse::No, ComparisonKind::Exact)\n+        } else if attr.has_name(sym::rustc_expected_cgu_reuse) {\n+            match self.field(attr, sym::kind) {\n+                sym::no => (CguReuse::No, ComparisonKind::Exact),\n+                sym::pre_dash_lto => (CguReuse::PreLto, ComparisonKind::Exact),\n+                sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n+                sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n+                other => {\n+                    self.tcx.sess.span_fatal(\n+                        attr.span,\n+                        &format!(\"unknown cgu-reuse-kind `{}` specified\", other),\n+                    );\n                 }\n-            } else {\n-                return;\n-            };\n+            }\n+        } else {\n+            return;\n+        };\n \n         if !self.tcx.sess.opts.debugging_opts.query_dep_graph {\n             self.tcx.sess.span_fatal("}, {"sha": "c4dc0fbadc813d885f4ff9b775d9fa060cc81319", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -159,7 +159,7 @@ pub struct DirtyCleanVisitor<'tcx> {\n impl DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n     fn assertion_maybe(&mut self, item_id: LocalDefId, attr: &Attribute) -> Option<Assertion> {\n-        if !self.tcx.sess.check_name(attr, sym::rustc_clean) {\n+        if !attr.has_name(sym::rustc_clean) {\n             // skip: not rustc_clean/dirty\n             return None;\n         }\n@@ -427,7 +427,7 @@ pub struct FindAllAttrs<'tcx> {\n \n impl FindAllAttrs<'tcx> {\n     fn is_active_attr(&mut self, attr: &Attribute) -> bool {\n-        if self.tcx.sess.check_name(attr, sym::rustc_clean) && check_config(self.tcx, attr) {\n+        if attr.has_name(sym::rustc_clean) && check_config(self.tcx, attr) {\n             return true;\n         }\n "}, {"sha": "2f540395b2d79f082b1c398c5d62933257733d9b", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -266,7 +266,7 @@ impl<'tcx> Queries<'tcx> {\n         };\n \n         let attrs = &*tcx.get_attrs(def_id);\n-        let attrs = attrs.iter().filter(|attr| tcx.sess.check_name(attr, sym::rustc_error));\n+        let attrs = attrs.iter().filter(|attr| attr.has_name(sym::rustc_error));\n         for attr in attrs {\n             match attr.meta_item_list() {\n                 // Check if there is a `#[rustc_error(delay_span_bug_from_inside_query)]`."}, {"sha": "6b64614363f188909a62e56f08a919738c783eec", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -488,13 +488,13 @@ pub fn get_codegen_sysroot(\n }\n \n pub(crate) fn check_attr_crate_type(\n-    sess: &Session,\n+    _sess: &Session,\n     attrs: &[ast::Attribute],\n     lint_buffer: &mut LintBuffer,\n ) {\n     // Unconditionally collect crate types from attributes to make them used\n     for a in attrs.iter() {\n-        if sess.check_name(a, sym::crate_type) {\n+        if a.has_name(sym::crate_type) {\n             if let Some(n) = a.value_str() {\n                 if categorize_crate_type(n).is_some() {\n                     return;\n@@ -552,7 +552,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<C\n     let attr_types: Vec<CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n-            if session.check_name(a, sym::crate_type) {\n+            if a.has_name(sym::crate_type) {\n                 match a.value_str() {\n                     Some(s) => categorize_crate_type(s),\n                     _ => None,"}, {"sha": "afa2cfca1880fec96d8e200344748d938ab828e2", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -46,7 +46,6 @@ use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{self, layout::LayoutError, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibilityReason;\n-use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -344,7 +343,7 @@ impl UnsafeCode {\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n-        if cx.sess().check_name(attr, sym::allow_internal_unsafe) {\n+        if attr.has_name(sym::allow_internal_unsafe) {\n             self.report_unsafe(cx, attr.span, |lint| {\n                 lint.build(\n                     \"`allow_internal_unsafe` allows defining \\\n@@ -492,12 +491,12 @@ pub struct MissingDoc {\n \n impl_lint_pass!(MissingDoc => [MISSING_DOCS]);\n \n-fn has_doc(sess: &Session, attr: &ast::Attribute) -> bool {\n+fn has_doc(attr: &ast::Attribute) -> bool {\n     if attr.is_doc_comment() {\n         return true;\n     }\n \n-    if !sess.check_name(attr, sym::doc) {\n+    if !attr.has_name(sym::doc) {\n         return false;\n     }\n \n@@ -554,7 +553,7 @@ impl MissingDoc {\n         }\n \n         let attrs = cx.tcx.get_attrs(def_id.to_def_id());\n-        let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n+        let has_doc = attrs.iter().any(has_doc);\n         if !has_doc {\n             cx.struct_span_lint(\n                 MISSING_DOCS,\n@@ -568,10 +567,10 @@ impl MissingDoc {\n }\n \n impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n-    fn enter_lint_attrs(&mut self, cx: &LateContext<'_>, attrs: &[ast::Attribute]) {\n+    fn enter_lint_attrs(&mut self, _cx: &LateContext<'_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n-                cx.sess().check_name(attr, sym::doc)\n+                attr.has_name(sym::doc)\n                     && match attr.meta_item_list() {\n                         None => false,\n                         Some(l) => attr::list_contains_name(&l, sym::hidden),\n@@ -595,7 +594,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             }\n \n             let attrs = cx.tcx.hir().attrs(macro_def.hir_id());\n-            let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n+            let has_doc = attrs.iter().any(has_doc);\n             if !has_doc {\n                 cx.struct_span_lint(\n                     MISSING_DOCS,\n@@ -999,7 +998,7 @@ impl EarlyLintPass for DeprecatedAttr {\n                 return;\n             }\n         }\n-        if cx.sess().check_name(attr, sym::no_start) || cx.sess().check_name(attr, sym::crate_id) {\n+        if attr.has_name(sym::no_start) || attr.has_name(sym::crate_id) {\n             let path_str = pprust::path_to_string(&attr.get_normal_item().path);\n             let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", path_str);\n             lint_deprecated_attr(cx, attr, &msg, None);\n@@ -1028,7 +1027,7 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n \n         let span = sugared_span.take().unwrap_or(attr.span);\n \n-        if is_doc_comment || cx.sess().check_name(attr, sym::doc) {\n+        if is_doc_comment || attr.has_name(sym::doc) {\n             cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, |lint| {\n                 let mut err = lint.build(\"unused doc comment\");\n                 err.span_label(\n@@ -1301,7 +1300,7 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n     fn check_attribute(&mut self, cx: &LateContext<'_>, attr: &ast::Attribute) {\n-        if cx.sess().check_name(attr, sym::feature) {\n+        if attr.has_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n                     cx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n@@ -2771,7 +2770,7 @@ impl ClashingExternDeclarations {\n                     overridden_link_name,\n                     tcx.get_attrs(fi.def_id.to_def_id())\n                         .iter()\n-                        .find(|at| tcx.sess.check_name(at, sym::link_name))\n+                        .find(|at| at.has_name(sym::link_name))\n                         .unwrap()\n                         .span,\n                 )"}, {"sha": "e6cbfa0c9e29d2a55611ccebebf72c038c8e9a9b", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -236,8 +236,6 @@ impl<'s> LintLevelsBuilder<'s> {\n                 Some(lvl) => lvl,\n             };\n \n-            self.sess.mark_attr_used(attr);\n-\n             let mut metas = unwrap_or!(attr.meta_item_list(), continue);\n \n             if metas.is_empty() {"}, {"sha": "c4008e77bab7cd0d633c7837f28b44f588e23585", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -151,8 +151,6 @@ macro_rules! late_lint_passes {\n                 // FIXME: Look into regression when this is used as a module lint\n                 // May Depend on constants elsewhere\n                 UnusedBrokenConst: UnusedBrokenConst,\n-                // Uses attr::is_used which is untracked, can't be an incremental module pass.\n-                UnusedAttributes: UnusedAttributes::new(),\n                 // Needs to run after UnusedAttributes as it marks all `feature` attributes as used.\n                 UnstableFeatures: UnstableFeatures,\n                 // Tracks state across modules"}, {"sha": "b8f8d5983a295a493b4380b0a18fb4d1d0832d37", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -669,9 +669,7 @@ enum FfiResult<'tcx> {\n }\n \n crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: &ty::AdtDef) -> bool {\n-    tcx.get_attrs(def.did)\n-        .iter()\n-        .any(|a| tcx.sess.check_name(a, sym::rustc_nonnull_optimization_guaranteed))\n+    tcx.get_attrs(def.did).iter().any(|a| a.has_name(sym::rustc_nonnull_optimization_guaranteed))\n }\n \n /// `repr(transparent)` structs can have a single non-ZST field, this function returns that"}, {"sha": "be137884b4b27ee57be4087ce8fd858f97bfee5e", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -4,21 +4,16 @@ use rustc_ast as ast;\n use rustc_ast::util::parser;\n use rustc_ast::{ExprKind, StmtKind};\n use rustc_ast_pretty::pprust;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, Applicability};\n-use rustc_feature::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n-use rustc_session::lint::builtin::UNUSED_ATTRIBUTES;\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n-use tracing::debug;\n-\n declare_lint! {\n     /// The `unused_must_use` lint detects unused result of a type flagged as\n     /// `#[must_use]`.\n@@ -308,7 +303,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n-                if cx.sess().check_name(attr, sym::must_use) {\n+                if attr.has_name(sym::must_use) {\n                     cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n                         let msg = format!(\n                             \"unused {}`{}`{} that must be used\",\n@@ -382,62 +377,6 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnusedAttributes {\n-    builtin_attributes: &'static FxHashMap<Symbol, &'static BuiltinAttribute>,\n-}\n-\n-impl UnusedAttributes {\n-    pub fn new() -> Self {\n-        UnusedAttributes { builtin_attributes: &*BUILTIN_ATTRIBUTE_MAP }\n-    }\n-}\n-\n-impl_lint_pass!(UnusedAttributes => [UNUSED_ATTRIBUTES]);\n-\n-impl<'tcx> LateLintPass<'tcx> for UnusedAttributes {\n-    fn check_attribute(&mut self, cx: &LateContext<'_>, attr: &ast::Attribute) {\n-        debug!(\"checking attribute: {:?}\", attr);\n-\n-        if attr.is_doc_comment() {\n-            return;\n-        }\n-\n-        let attr_info = attr.ident().and_then(|ident| self.builtin_attributes.get(&ident.name));\n-\n-        if let Some(&&(name, ty, ..)) = attr_info {\n-            if let AttributeType::AssumedUsed = ty {\n-                debug!(\"{:?} is AssumedUsed\", name);\n-                return;\n-            }\n-        }\n-\n-        if !cx.sess().is_attr_used(attr) {\n-            debug!(\"emitting warning for: {:?}\", attr);\n-            cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n-                // Mark as used to avoid duplicate warnings.\n-                cx.sess().mark_attr_used(attr);\n-                lint.build(\"unused attribute\").emit()\n-            });\n-            // Is it a builtin attribute that must be used at the crate level?\n-            if attr_info.map_or(false, |(_, ty, ..)| ty == &AttributeType::CrateLevel) {\n-                cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n-                    let msg = match attr.style {\n-                        ast::AttrStyle::Outer => {\n-                            \"crate-level attribute should be an inner attribute: add an exclamation \\\n-                             mark: `#![foo]`\"\n-                        }\n-                        ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n-                    };\n-                    lint.build(msg).emit()\n-                });\n-            }\n-        } else {\n-            debug!(\"Attr was used: {:?}\", attr);\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum UnusedDelimsCtx {\n     FunctionArg,"}, {"sha": "6dac3f54cfa94fdaba31c408986e1c671ddcf21a", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -3042,6 +3042,7 @@ declare_lint_pass! {\n         RUST_2021_PREFIXES_INCOMPATIBLE_SYNTAX,\n         UNSUPPORTED_CALLING_CONVENTIONS,\n         BREAK_WITH_LABEL_AND_LOOP,\n+        UNUSED_ATTRIBUTES,\n     ]\n }\n "}, {"sha": "5f0d8c46f20dcd27eb0cb3a0972b9eb30a722ea1", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -44,8 +44,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n \n         // Process all of the #[link(..)]-style arguments\n         let sess = &self.tcx.sess;\n-        for m in self.tcx.hir().attrs(it.hir_id()).iter().filter(|a| sess.check_name(a, sym::link))\n-        {\n+        for m in self.tcx.hir().attrs(it.hir_id()).iter().filter(|a| a.has_name(sym::link)) {\n             let items = match m.meta_item_list() {\n                 Some(item) => item,\n                 None => continue,"}, {"sha": "20dcb670cd60b0710ad92d40b57f9141447b2889", "filename": "compiler/rustc_middle/src/middle/limits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -48,7 +48,7 @@ pub fn get_recursion_limit(krate_attrs: &[Attribute], sess: &Session) -> Limit {\n \n fn get_limit(krate_attrs: &[Attribute], sess: &Session, name: Symbol, default: usize) -> Limit {\n     for attr in krate_attrs {\n-        if !sess.check_name(attr, name) {\n+        if !attr.has_name(name) {\n             continue;\n         }\n "}, {"sha": "9c6ec25213c5898f1f7f734dcb70f6960641a88e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -1136,7 +1136,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {\n         let attrs = self.get_attrs(def_id);\n         let get = |name| {\n-            let attr = match attrs.iter().find(|a| self.sess.check_name(a, name)) {\n+            let attr = match attrs.iter().find(|a| a.has_name(name)) {\n                 Some(attr) => attr,\n                 None => return Bound::Unbounded,\n             };"}, {"sha": "7ff7c860591fb76e2950b573dd4cdcf673fd2309", "filename": "compiler/rustc_mir/src/dataflow/framework/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -338,7 +338,7 @@ impl RustcMirAttrs {\n \n         let rustc_mir_attrs = attrs\n             .iter()\n-            .filter(|attr| tcx.sess.check_name(attr, sym::rustc_mir))\n+            .filter(|attr| attr.has_name(sym::rustc_mir))\n             .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n \n         for attr in rustc_mir_attrs {"}, {"sha": "8a426cc1015ccbdd4ae0562156a611fba8400c64", "filename": "compiler/rustc_mir/src/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -30,12 +30,12 @@ pub struct MoveDataParamEnv<'tcx> {\n }\n \n pub(crate) fn has_rustc_mir_with(\n-    sess: &Session,\n+    _sess: &Session,\n     attrs: &[ast::Attribute],\n     name: Symbol,\n ) -> Option<MetaItem> {\n     for attr in attrs {\n-        if sess.check_name(attr, sym::rustc_mir) {\n+        if attr.has_name(sym::rustc_mir) {\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n                 match item.meta_item() {"}, {"sha": "fea1adfa3d58b784399f667affc59c533856aa81", "filename": "compiler/rustc_mir/src/monomorphize/polymorphize.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -204,11 +204,7 @@ fn emit_unused_generic_params_error<'tcx>(\n     unused_parameters: &FiniteBitSet<u32>,\n ) {\n     let base_def_id = tcx.closure_base_def_id(def_id);\n-    if !tcx\n-        .get_attrs(base_def_id)\n-        .iter()\n-        .any(|a| tcx.sess.check_name(a, sym::rustc_polymorphize_error))\n-    {\n+    if !tcx.get_attrs(base_def_id).iter().any(|a| a.has_name(sym::rustc_polymorphize_error)) {\n         return;\n     }\n "}, {"sha": "07f972c2fa897e0625ff90b00f91fb810146fbfb", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -13,9 +13,10 @@ use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use rustc_ast::tokenstream::{Spacing, TokenStream};\n use rustc_ast::AstLike;\n use rustc_ast::Attribute;\n+use rustc_ast::{AttrItem, MetaItem};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n+use rustc_errors::{Applicability, Diagnostic, FatalError, Level, PResult};\n use rustc_session::parse::ParseSess;\n use rustc_span::{FileName, SourceFile, Span};\n \n@@ -324,3 +325,44 @@ pub fn fake_token_stream(sess: &ParseSess, nt: &Nonterminal) -> TokenStream {\n     let filename = FileName::macro_expansion_source_code(&source);\n     parse_stream_from_source_str(filename, source, sess, Some(nt.span()))\n }\n+\n+pub fn parse_cfg_attr(\n+    attr: &Attribute,\n+    parse_sess: &ParseSess,\n+) -> Option<(MetaItem, Vec<(AttrItem, Span)>)> {\n+    match attr.get_normal_item().args {\n+        ast::MacArgs::Delimited(dspan, delim, ref tts) if !tts.is_empty() => {\n+            let msg = \"wrong `cfg_attr` delimiters\";\n+            crate::validate_attr::check_meta_bad_delim(parse_sess, dspan, delim, msg);\n+            match parse_in(parse_sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n+                Ok(r) => return Some(r),\n+                Err(mut e) => {\n+                    e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n+                        .note(CFG_ATTR_NOTE_REF)\n+                        .emit();\n+                }\n+            }\n+        }\n+        _ => error_malformed_cfg_attr_missing(attr.span, parse_sess),\n+    }\n+    None\n+}\n+\n+const CFG_ATTR_GRAMMAR_HELP: &str = \"#[cfg_attr(condition, attribute, other_attribute, ...)]\";\n+const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n+    <https://doc.rust-lang.org/reference/conditional-compilation.html\\\n+    #the-cfg_attr-attribute>\";\n+\n+fn error_malformed_cfg_attr_missing(span: Span, parse_sess: &ParseSess) {\n+    parse_sess\n+        .span_diagnostic\n+        .struct_span_err(span, \"malformed `cfg_attr` attribute input\")\n+        .span_suggestion(\n+            span,\n+            \"missing condition and attribute\",\n+            CFG_ATTR_GRAMMAR_HELP.to_string(),\n+            Applicability::HasPlaceholders,\n+        )\n+        .note(CFG_ATTR_NOTE_REF)\n+        .emit();\n+}"}, {"sha": "bf1e52cd9a8ad4a18eb567de9418cba1e295e027", "filename": "compiler/rustc_passes/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2FCargo.toml?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -11,10 +11,12 @@ rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n+rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n+rustc_feature = { path = \"../rustc_feature\" }"}, {"sha": "3009c2c3f2f4aa27968cae759d446ad5b3a5b405", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 157, "deletions": 4, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -8,8 +8,10 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n \n-use rustc_ast::{AttrStyle, Attribute, Lit, LitKind, NestedMetaItem};\n+use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, NestedMetaItem};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n+use rustc_feature::{AttributeType, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -66,9 +68,10 @@ impl CheckAttrVisitor<'tcx> {\n     ) {\n         let mut is_valid = true;\n         let mut specified_inline = None;\n+        let mut seen = FxHashSet::default();\n         let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n-            is_valid &= match attr.name_or_empty() {\n+            let attr_is_valid = match attr.name_or_empty() {\n                 sym::inline => self.check_inline(hir_id, attr, span, target),\n                 sym::non_exhaustive => self.check_non_exhaustive(hir_id, attr, span, target),\n                 sym::marker => self.check_marker(hir_id, attr, span, target),\n@@ -101,14 +104,66 @@ impl CheckAttrVisitor<'tcx> {\n                 sym::default_method_body_is_const => {\n                     self.check_default_method_body_is_const(attr, span, target)\n                 }\n+                sym::rustc_const_unstable\n+                | sym::rustc_const_stable\n+                | sym::unstable\n+                | sym::stable\n+                | sym::rustc_promotable => self.check_stability_promotable(&attr, span, target),\n                 _ => true,\n             };\n+            is_valid &= attr_is_valid;\n+\n             // lint-only checks\n             match attr.name_or_empty() {\n                 sym::cold => self.check_cold(hir_id, attr, span, target),\n                 sym::link_name => self.check_link_name(hir_id, attr, span, target),\n                 sym::link_section => self.check_link_section(hir_id, attr, span, target),\n                 sym::no_mangle => self.check_no_mangle(hir_id, attr, span, target),\n+                sym::deprecated | sym::rustc_deprecated => {\n+                    self.check_deprecated(hir_id, attr, span, target)\n+                }\n+                sym::macro_use | sym::macro_escape => self.check_macro_use(hir_id, attr, target),\n+                sym::path => self.check_generic_attr(hir_id, attr, target, &[Target::Mod]),\n+                sym::cfg_attr => self.check_cfg_attr(hir_id, attr),\n+                sym::plugin_registrar => self.check_plugin_registrar(hir_id, attr, target),\n+                sym::macro_export => self.check_macro_export(hir_id, attr, target),\n+                sym::ignore | sym::should_panic | sym::proc_macro_derive => {\n+                    self.check_generic_attr(hir_id, attr, target, &[Target::Fn])\n+                }\n+                _ => {}\n+            }\n+\n+            if hir_id != CRATE_HIR_ID {\n+                if let Some((_, AttributeType::CrateLevel, ..)) =\n+                    attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name))\n+                {\n+                    self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                        let msg = match attr.style {\n+                            ast::AttrStyle::Outer => {\n+                                \"crate-level attribute should be an inner attribute: add an exclamation \\\n+                                 mark: `#![foo]`\"\n+                            }\n+                            ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n+                        };\n+                        lint.build(msg).emit()\n+                    });\n+                }\n+            }\n+\n+            // Duplicate attributes\n+            match attr.name_or_empty() {\n+                name @ sym::macro_use => {\n+                    let args = attr.meta_item_list().unwrap_or_else(Vec::new);\n+                    let args: Vec<_> = args.iter().map(|arg| arg.name_or_empty()).collect();\n+                    if !seen.insert((name, args)) {\n+                        self.tcx.struct_span_lint_hir(\n+                            UNUSED_ATTRIBUTES,\n+                            hir_id,\n+                            attr.span,\n+                            |lint| lint.build(\"unused attribute\").emit(),\n+                        );\n+                    }\n+                }\n                 _ => {}\n             }\n         }\n@@ -211,6 +266,38 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n+    fn check_generic_attr(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        target: Target,\n+        allowed_targets: &[Target],\n+    ) {\n+        if !allowed_targets.iter().any(|t| t == &target) {\n+            let name = attr.name_or_empty();\n+            let mut i = allowed_targets.iter();\n+            // Pluralize\n+            let b = i.next().map_or_else(String::new, |t| t.to_string() + \"s\");\n+            let supported_names = i.enumerate().fold(b, |mut b, (i, allowed_target)| {\n+                if allowed_targets.len() > 2 && i == allowed_targets.len() - 2 {\n+                    b.push_str(\", and \");\n+                } else if allowed_targets.len() == 2 && i == allowed_targets.len() - 2 {\n+                    b.push_str(\" and \");\n+                } else {\n+                    b.push_str(\", \");\n+                }\n+                // Pluralize\n+                b.push_str(&(allowed_target.to_string() + \"s\"));\n+                b\n+            });\n+            //let supported_names = allowed_targets.iter().fold(String::new(), |msg, t| msg + \", \" + &t.to_string());\n+            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                lint.build(&format!(\"`#[{name}]` only has an effect on {}\", supported_names))\n+                    .emit();\n+            });\n+        }\n+    }\n+\n     /// Checks if `#[naked]` is applied to a function definition.\n     fn check_naked(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n@@ -1555,6 +1642,72 @@ impl CheckAttrVisitor<'tcx> {\n             }\n         }\n     }\n+\n+    fn check_stability_promotable(&self, attr: &Attribute, _span: &Span, target: Target) -> bool {\n+        match target {\n+            Target::Expression => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(attr.span, \"attribute cannot be applied to an expression\")\n+                    .emit();\n+                false\n+            }\n+            _ => true,\n+        }\n+    }\n+\n+    fn check_deprecated(&self, hir_id: HirId, attr: &Attribute, _span: &Span, target: Target) {\n+        match target {\n+            Target::Closure | Target::Expression | Target::Statement | Target::Arm => {\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"attribute is ignored here\").emit();\n+                });\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_macro_use(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n+        let name = attr.name_or_empty();\n+        match target {\n+            Target::ExternCrate | Target::Mod => {}\n+            _ => {\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(&format!(\n+                        \"`#[{name}]` only has an effect on `extern crate` and modules\"\n+                    ))\n+                    .emit();\n+                });\n+            }\n+        }\n+    }\n+\n+    fn check_macro_export(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n+        if target != Target::MacroDef {\n+            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                lint.build(&format!(\"`#[macro_export]` only has an effect on macro definitions\"))\n+                    .emit();\n+            });\n+        }\n+    }\n+\n+    fn check_cfg_attr(&self, hir_id: HirId, attr: &Attribute) {\n+        if let Some((_, attrs)) = rustc_parse::parse_cfg_attr(&attr, &self.tcx.sess.parse_sess) {\n+            if attrs.is_empty() {\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"`#[cfg_attr]` does not expand to any attributes\").emit();\n+                });\n+            }\n+        }\n+    }\n+\n+    fn check_plugin_registrar(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n+        if target != Target::Fn {\n+            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                lint.build(\"`#[plugin_registrar]` only has an effect on functions\").emit();\n+            });\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n@@ -1675,7 +1828,7 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n \n     for attr in attrs {\n         for attr_to_check in ATTRS_TO_CHECK {\n-            if tcx.sess.check_name(attr, *attr_to_check) {\n+            if attr.has_name(*attr_to_check) {\n                 tcx.sess\n                     .struct_span_err(\n                         attr.span,\n@@ -1692,7 +1845,7 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n \n fn check_invalid_macro_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n     for attr in attrs {\n-        if tcx.sess.check_name(attr, sym::inline) {\n+        if attr.has_name(sym::inline) {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,"}, {"sha": "e43abda713351c6042a95a06eeb88713defaf27d", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -15,7 +15,6 @@ use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::Session;\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_span::symbol::{sym, Symbol};\n \n@@ -51,7 +50,7 @@ impl<'tcx> DiagnosticItemCollector<'tcx> {\n     fn observe_item(&mut self, def_id: LocalDefId) {\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let attrs = self.tcx.hir().attrs(hir_id);\n-        if let Some(name) = extract(&self.tcx.sess, attrs) {\n+        if let Some(name) = extract(attrs) {\n             // insert into our table\n             collect_item(self.tcx, &mut self.items, name, def_id.to_def_id());\n         }\n@@ -91,10 +90,10 @@ fn collect_item(\n     }\n }\n \n-/// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.\n-fn extract(sess: &Session, attrs: &[ast::Attribute]) -> Option<Symbol> {\n+/// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.p\n+fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().find_map(|attr| {\n-        if sess.check_name(attr, sym::rustc_diagnostic_item) { attr.value_str() } else { None }\n+        if attr.has_name(sym::rustc_diagnostic_item) { attr.value_str() } else { None }\n     })\n }\n "}, {"sha": "62f9bcfdc47299bc2a1a59ec9304b3cd361ed634", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -13,6 +13,7 @@ use crate::weak_lang_items;\n use rustc_middle::middle::cstore::ExternCrate;\n use rustc_middle::ty::TyCtxt;\n \n+use rustc_ast::Attribute;\n use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -57,7 +58,7 @@ impl LanguageItemCollector<'tcx> {\n \n     fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId) {\n         let attrs = self.tcx.hir().attrs(hir_id);\n-        let check_name = |attr, sym| self.tcx.sess.check_name(attr, sym);\n+        let check_name = |attr: &Attribute, sym| attr.has_name(sym);\n         if let Some((value, span)) = extract(check_name, &attrs) {\n             match ITEM_REFS.get(&value).cloned() {\n                 // Known lang item with attribute on correct target."}, {"sha": "43a3a3062e77b053f02ba8117cf5f8315218d284", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -27,7 +27,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..) => {\n                 for attr in self.tcx.get_attrs(item.def_id.to_def_id()).iter() {\n-                    if self.tcx.sess.check_name(attr, sym::rustc_layout) {\n+                    if attr.has_name(sym::rustc_layout) {\n                         self.dump_layout_of(item.def_id, item, attr);\n                     }\n                 }"}, {"sha": "f583a5d58d540edade0e2af98a8366a44479fba9", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -7,6 +7,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n+#![feature(format_args_capture)]\n #![feature(iter_zip)]\n #![feature(nll)]\n #![feature(min_specialization)]"}, {"sha": "605b52f18913f2c22df23a556965c6cb47af3c34", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -33,9 +33,7 @@ impl LibFeatureCollector<'tcx> {\n \n         // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n         // `#[rustc_const_unstable (..)]`).\n-        if let Some(stab_attr) =\n-            stab_attrs.iter().find(|stab_attr| self.tcx.sess.check_name(attr, **stab_attr))\n-        {\n+        if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| attr.has_name(**stab_attr)) {\n             let meta_item = attr.meta();\n             if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta_item {\n                 let mut feature = None;"}, {"sha": "b64dcb0bbf03b00ed6dea5cffdc85f40838671e4", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -148,7 +148,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n \n         if self.tcx.features().staged_api {\n-            if let Some(a) = attrs.iter().find(|a| self.tcx.sess.check_name(a, sym::deprecated)) {\n+            if let Some(a) = attrs.iter().find(|a| a.has_name(sym::deprecated)) {\n                 self.tcx\n                     .sess\n                     .struct_span_err(a.span, \"`#[deprecated]` cannot be used in staged API\")\n@@ -350,7 +350,6 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         for attr in attrs {\n             let name = attr.name_or_empty();\n             if unstable_attrs.contains(&name) {\n-                self.tcx.sess.mark_attr_used(attr);\n                 struct_span_err!(\n                     self.tcx.sess,\n                     attr.span,"}, {"sha": "3a662a9bab2f6ee2f8fdf9826021ab2c1de86b53", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -1,5 +1,6 @@\n //! Validity checking for weak lang items\n \n+use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -96,7 +97,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n-        let check_name = |attr, sym| self.tcx.sess.check_name(attr, sym);\n+        let check_name = |attr: &Attribute, sym| attr.has_name(sym);\n         let attrs = self.tcx.hir().attrs(i.hir_id());\n         if let Some((lang_item, _)) = lang_items::extract(check_name, attrs) {\n             self.register(lang_item, i.span);"}, {"sha": "51cf85f794b8a749184501568b3a84dd012ec453", "filename": "compiler/rustc_plugin_impl/src/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -32,7 +32,7 @@ pub fn load_plugins(\n     let mut plugins = Vec::new();\n \n     for attr in &krate.attrs {\n-        if !sess.check_name(attr, sym::plugin) {\n+        if !attr.has_name(sym::plugin) {\n             continue;\n         }\n "}, {"sha": "9e4c4b443e77a07d9482570347f4f229b3f61788", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -885,9 +885,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n         // Non-opaque macros cannot make other items more accessible than they already are.\n         let attrs = self.tcx.hir().attrs(md.hir_id());\n-        if attr::find_transparency(&self.tcx.sess, &attrs, md.ast.macro_rules).0\n-            != Transparency::Opaque\n-        {\n+        if attr::find_transparency(&attrs, md.ast.macro_rules).0 != Transparency::Opaque {\n             // `#[macro_export]`-ed `macro_rules!` are `Public` since they\n             // ignore their containing path to always appear at the crate root.\n             if md.ast.macro_rules {"}, {"sha": "c06ef08e0a8bf34851dff2af61f25c1c2bd7f80b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -1059,7 +1059,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n-            if self.r.session.check_name(attr, sym::macro_use) {\n+            if attr.has_name(sym::macro_use) {\n                 if self.parent_scope.module.parent.is_some() {\n                     struct_span_err!(\n                         self.r.session,\n@@ -1165,15 +1165,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     /// Returns `true` if this attribute list contains `macro_use`.\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n-            if self.r.session.check_name(attr, sym::macro_escape) {\n+            if attr.has_name(sym::macro_escape) {\n                 let msg = \"`#[macro_escape]` is a deprecated synonym for `#[macro_use]`\";\n                 let mut err = self.r.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"try an outer attribute: `#[macro_use]`\").emit();\n                 } else {\n                     err.emit();\n                 }\n-            } else if !self.r.session.check_name(attr, sym::macro_use) {\n+            } else if !attr.has_name(sym::macro_use) {\n                 continue;\n             }\n "}, {"sha": "882d15cf8920f43beaa8ca9e435b6eb74891ba32", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -2057,9 +2057,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             if let Some(def_id) = parent_def_id.as_local() {\n                                 let parent_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n-                                if self.tcx.hir().attrs(parent_hir_id).iter().any(|attr| {\n-                                    self.tcx.sess.check_name(attr, sym::automatically_derived)\n-                                }) {\n+                                if self\n+                                    .tcx\n+                                    .hir()\n+                                    .attrs(parent_hir_id)\n+                                    .iter()\n+                                    .any(|attr| attr.has_name(sym::automatically_derived))\n+                                {\n                                     continue;\n                                 }\n                             }"}, {"sha": "438a109f96737b68d00b3de758a1fece02d596c8", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -3382,9 +3382,8 @@ impl<'a> Resolver<'a> {\n \n                 let parse_attrs = || {\n                     let attrs = self.cstore().item_attrs(def_id, self.session);\n-                    let attr = attrs\n-                        .iter()\n-                        .find(|a| self.session.check_name(a, sym::rustc_legacy_const_generics))?;\n+                    let attr =\n+                        attrs.iter().find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n                     let mut ret = vec![];\n                     for meta in attr.meta_item_list()? {\n                         match meta.literal()?.kind {"}, {"sha": "d49ba861785b3e19efdcc93050aee92befa36e15", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -213,8 +213,6 @@ pub struct Session {\n     /// Set of enabled features for the current target.\n     pub target_features: FxHashSet<Symbol>,\n \n-    used_attrs: Lock<MarkedAttrs>,\n-\n     /// `Span`s for `if` conditions that we have suggested turning into `if let`.\n     pub if_let_suggestions: Lock<FxHashSet<Span>>,\n }\n@@ -1066,63 +1064,38 @@ impl Session {\n             == config::InstrumentCoverage::ExceptUnusedFunctions\n     }\n \n-    pub fn mark_attr_used(&self, attr: &Attribute) {\n-        self.used_attrs.lock().mark(attr)\n-    }\n-\n-    pub fn is_attr_used(&self, attr: &Attribute) -> bool {\n-        self.used_attrs.lock().is_marked(attr)\n-    }\n-\n-    /// Returns `true` if the attribute's path matches the argument. If it\n-    /// matches, then the attribute is marked as used.\n-    ///\n-    /// This method should only be used by rustc, other tools can use\n-    /// `Attribute::has_name` instead, because only rustc is supposed to report\n-    /// the `unused_attributes` lint. (`MetaItem` and `NestedMetaItem` are\n-    /// produced by lowering an `Attribute` and don't have identity, so they\n-    /// only have the `has_name` method, and you need to mark the original\n-    /// `Attribute` as used when necessary.)\n-    pub fn check_name(&self, attr: &Attribute, name: Symbol) -> bool {\n-        let matches = attr.has_name(name);\n-        if matches {\n-            self.mark_attr_used(attr);\n-        }\n-        matches\n-    }\n-\n     pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n         [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n             .iter()\n-            .any(|kind| self.check_name(attr, *kind))\n+            .any(|kind| attr.has_name(*kind))\n     }\n \n     pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n-        attrs.iter().any(|item| self.check_name(item, name))\n+        attrs.iter().any(|item| item.has_name(name))\n     }\n \n     pub fn find_by_name<'a>(\n         &'a self,\n         attrs: &'a [Attribute],\n         name: Symbol,\n     ) -> Option<&'a Attribute> {\n-        attrs.iter().find(|attr| self.check_name(attr, name))\n+        attrs.iter().find(|attr| attr.has_name(name))\n     }\n \n     pub fn filter_by_name<'a>(\n         &'a self,\n         attrs: &'a [Attribute],\n         name: Symbol,\n     ) -> impl Iterator<Item = &'a Attribute> {\n-        attrs.iter().filter(move |attr| self.check_name(attr, name))\n+        attrs.iter().filter(move |attr| attr.has_name(name))\n     }\n \n     pub fn first_attr_value_str_by_name(\n         &self,\n         attrs: &[Attribute],\n         name: Symbol,\n     ) -> Option<Symbol> {\n-        attrs.iter().find(|at| self.check_name(at, name)).and_then(|at| at.value_str())\n+        attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n     }\n }\n \n@@ -1359,7 +1332,6 @@ pub fn build_session(\n         miri_unleashed_features: Lock::new(Default::default()),\n         asm_arch,\n         target_features: FxHashSet::default(),\n-        used_attrs: Lock::new(MarkedAttrs::new()),\n         if_let_suggestions: Default::default(),\n     };\n "}, {"sha": "183df96f316686da9703f67b004fa1bf8842a65f", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -35,7 +35,7 @@ impl SymbolNamesTest<'tcx> {\n     fn process_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n         for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n-            if tcx.sess.check_name(attr, SYMBOL_NAME) {\n+            if attr.has_name(SYMBOL_NAME) {\n                 let def_id = def_id.to_def_id();\n                 let instance = Instance::new(\n                     def_id,\n@@ -47,7 +47,7 @@ impl SymbolNamesTest<'tcx> {\n                     tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n                     tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n                 }\n-            } else if tcx.sess.check_name(attr, DEF_PATH) {\n+            } else if attr.has_name(DEF_PATH) {\n                 let path = with_no_trimmed_paths(|| tcx.def_path_str(def_id.to_def_id()));\n                 tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n             }"}, {"sha": "ccfa0893d11fa09f28aa1be3a46be99242c4557a", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     //\n                     // FIXME? Other potential candidate methods: `as_ref` and\n                     // `as_mut`?\n-                    .any(|a| self.sess().check_name(a, sym::rustc_conversion_suggestion))\n+                    .any(|a| a.has_name(sym::rustc_conversion_suggestion))\n         });\n \n         methods"}, {"sha": "1c6fd5983cb59f49256980ead01bf435e530b101", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -21,6 +21,7 @@ use crate::constrained_generic_params as cgp;\n use crate::errors;\n use crate::middle::resolve_lifetime as rl;\n use rustc_ast as ast;\n+use rustc_ast::Attribute;\n use rustc_ast::{MetaItemKind, NestedMetaItem};\n use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n@@ -2769,11 +2770,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     let mut link_ordinal_span = None;\n     let mut no_sanitize_span = None;\n     for attr in attrs.iter() {\n-        if tcx.sess.check_name(attr, sym::cold) {\n+        if attr.has_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if tcx.sess.check_name(attr, sym::rustc_allocator) {\n+        } else if attr.has_name(sym::rustc_allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if tcx.sess.check_name(attr, sym::ffi_returns_twice) {\n+        } else if attr.has_name(sym::ffi_returns_twice) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n@@ -2786,9 +2787,9 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if tcx.sess.check_name(attr, sym::ffi_pure) {\n+        } else if attr.has_name(sym::ffi_pure) {\n             if tcx.is_foreign_item(id) {\n-                if attrs.iter().any(|a| tcx.sess.check_name(a, sym::ffi_const)) {\n+                if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n                     // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n                     struct_span_err!(\n                         tcx.sess,\n@@ -2810,7 +2811,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if tcx.sess.check_name(attr, sym::ffi_const) {\n+        } else if attr.has_name(sym::ffi_const) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n             } else {\n@@ -2823,19 +2824,19 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if tcx.sess.check_name(attr, sym::rustc_allocator_nounwind) {\n+        } else if attr.has_name(sym::rustc_allocator_nounwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        } else if tcx.sess.check_name(attr, sym::naked) {\n+        } else if attr.has_name(sym::naked) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if tcx.sess.check_name(attr, sym::no_mangle) {\n+        } else if attr.has_name(sym::no_mangle) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if tcx.sess.check_name(attr, sym::no_coverage) {\n+        } else if attr.has_name(sym::no_coverage) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        } else if tcx.sess.check_name(attr, sym::rustc_std_internal_symbol) {\n+        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if tcx.sess.check_name(attr, sym::used) {\n+        } else if attr.has_name(sym::used) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-        } else if tcx.sess.check_name(attr, sym::cmse_nonsecure_entry) {\n+        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n             if !matches!(tcx.fn_sig(id).abi(), abi::Abi::C { .. }) {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -2850,15 +2851,15 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     .emit();\n             }\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n-        } else if tcx.sess.check_name(attr, sym::thread_local) {\n+        } else if attr.has_name(sym::thread_local) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if tcx.sess.check_name(attr, sym::track_caller) {\n+        } else if attr.has_name(sym::track_caller) {\n             if tcx.is_closure(id) || tcx.fn_sig(id).abi() != abi::Abi::Rust {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n             }\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-        } else if tcx.sess.check_name(attr, sym::export_name) {\n+        } else if attr.has_name(sym::export_name) {\n             if let Some(s) = attr.value_str() {\n                 if s.as_str().contains('\\0') {\n                     // `#[export_name = ...]` will be converted to a null-terminated string,\n@@ -2873,7 +2874,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 }\n                 codegen_fn_attrs.export_name = Some(s);\n             }\n-        } else if tcx.sess.check_name(attr, sym::target_feature) {\n+        } else if attr.has_name(sym::target_feature) {\n             if !tcx.is_closure(id) && tcx.fn_sig(id).unsafety() == hir::Unsafety::Normal {\n                 if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n                     // The `#[target_feature]` attribute is allowed on\n@@ -2913,11 +2914,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 &supported_target_features,\n                 &mut codegen_fn_attrs.target_features,\n             );\n-        } else if tcx.sess.check_name(attr, sym::linkage) {\n+        } else if attr.has_name(sym::linkage) {\n             if let Some(val) = attr.value_str() {\n                 codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n             }\n-        } else if tcx.sess.check_name(attr, sym::link_section) {\n+        } else if attr.has_name(sym::link_section) {\n             if let Some(val) = attr.value_str() {\n                 if val.as_str().bytes().any(|b| b == 0) {\n                     let msg = format!(\n@@ -2930,14 +2931,14 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     codegen_fn_attrs.link_section = Some(val);\n                 }\n             }\n-        } else if tcx.sess.check_name(attr, sym::link_name) {\n+        } else if attr.has_name(sym::link_name) {\n             codegen_fn_attrs.link_name = attr.value_str();\n-        } else if tcx.sess.check_name(attr, sym::link_ordinal) {\n+        } else if attr.has_name(sym::link_ordinal) {\n             link_ordinal_span = Some(attr.span);\n             if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n                 codegen_fn_attrs.link_ordinal = ordinal;\n             }\n-        } else if tcx.sess.check_name(attr, sym::no_sanitize) {\n+        } else if attr.has_name(sym::no_sanitize) {\n             no_sanitize_span = Some(attr.span);\n             if let Some(list) = attr.meta_item_list() {\n                 for item in list.iter() {\n@@ -2957,7 +2958,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     }\n                 }\n             }\n-        } else if tcx.sess.check_name(attr, sym::instruction_set) {\n+        } else if attr.has_name(sym::instruction_set) {\n             codegen_fn_attrs.instruction_set = match attr.meta().map(|i| i.kind) {\n                 Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n                     [NestedMetaItem::MetaItem(set)] => {\n@@ -3026,7 +3027,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     None\n                 }\n             };\n-        } else if tcx.sess.check_name(attr, sym::repr) {\n+        } else if attr.has_name(sym::repr) {\n             codegen_fn_attrs.alignment = match attr.meta_item_list() {\n                 Some(items) => match items.as_slice() {\n                     [item] => match item.name_value_literal() {\n@@ -3064,12 +3065,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             return ia;\n         }\n         match attr.meta().map(|i| i.kind) {\n-            Some(MetaItemKind::Word) => {\n-                tcx.sess.mark_attr_used(attr);\n-                InlineAttr::Hint\n-            }\n+            Some(MetaItemKind::Word) => InlineAttr::Hint,\n             Some(MetaItemKind::List(ref items)) => {\n-                tcx.sess.mark_attr_used(attr);\n                 inline_span = Some(attr.span);\n                 if items.len() != 1 {\n                     struct_span_err!(\n@@ -3112,7 +3109,6 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 ia\n             }\n             Some(MetaItemKind::List(ref items)) => {\n-                tcx.sess.mark_attr_used(attr);\n                 inline_span = Some(attr.span);\n                 if items.len() != 1 {\n                     err(attr.span, \"expected one argument\");\n@@ -3181,7 +3177,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if tcx.is_weak_lang_item(id) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n-    let check_name = |attr, sym| tcx.sess.check_name(attr, sym);\n+    let check_name = |attr: &Attribute, sym| attr.has_name(sym);\n     if let Some(name) = weak_lang_items::link_name(check_name, &attrs) {\n         codegen_fn_attrs.export_name = Some(name);\n         codegen_fn_attrs.link_name = Some(name);"}, {"sha": "61631f3b14bb17ae0c79886c89b3fa635dae9a51", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -291,7 +291,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     }\n \n     for attr in tcx.get_attrs(main_def_id) {\n-        if tcx.sess.check_name(attr, sym::track_caller) {\n+        if attr.has_name(sym::track_caller) {\n             tcx.sess\n                 .struct_span_err(\n                     attr.span,\n@@ -405,7 +405,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n \n                     let attrs = tcx.hir().attrs(start_id);\n                     for attr in attrs {\n-                        if tcx.sess.check_name(attr, sym::track_caller) {\n+                        if attr.has_name(sym::track_caller) {\n                             tcx.sess\n                                 .struct_span_err(\n                                     attr.span,"}, {"sha": "680614656538afebe2273ca1bf529a242dd6a967", "filename": "src/test/ui/attributes/register-attr-tool-unused.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-unused.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -4,7 +4,5 @@\n #![feature(register_tool)]\n \n #[register_attr(attr)] //~ ERROR crate-level attribute should be an inner attribute\n-                       //~| ERROR unused attribute\n #[register_tool(tool)] //~ ERROR crate-level attribute should be an inner attribute\n-                       //~| ERROR unused attribute\n fn main() {}"}, {"sha": "8d2e1b6bc2894dbf5224bc62d8cba45eb4441457", "filename": "src/test/ui/attributes/register-attr-tool-unused.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-unused.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-unused.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-unused.stderr?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -1,4 +1,4 @@\n-error: unused attribute\n+error: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n   --> $DIR/register-attr-tool-unused.rs:6:1\n    |\n LL | #[register_attr(attr)]\n@@ -12,22 +12,10 @@ LL | #![deny(unused)]\n    = note: `#[deny(unused_attributes)]` implied by `#[deny(unused)]`\n \n error: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/register-attr-tool-unused.rs:6:1\n-   |\n-LL | #[register_attr(attr)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/register-attr-tool-unused.rs:8:1\n-   |\n-LL | #[register_tool(tool)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/register-attr-tool-unused.rs:8:1\n+  --> $DIR/register-attr-tool-unused.rs:7:1\n    |\n LL | #[register_tool(tool)]\n    | ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "2600ec7c444a068b4526b1e7c9f8ae6dbea4c653", "filename": "src/test/ui/conditional-compilation/cfg-attr-empty-is-unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-empty-is-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-empty-is-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-empty-is-unused.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -4,10 +4,10 @@\n \n #![deny(unused)]\n \n-#[cfg_attr(FALSE,)] //~ ERROR unused attribute\n+#[cfg_attr(FALSE,)] //~ ERROR `#[cfg_attr]` does not expand to any attributes\n fn _f() {}\n \n-#[cfg_attr(TRUE,)] //~ ERROR unused attribute\n+#[cfg_attr(TRUE,)] //~ ERROR `#[cfg_attr]` does not expand to any attributes\n fn _g() {}\n \n fn main() {}"}, {"sha": "87b698813535316083490814c57c0268443f7735", "filename": "src/test/ui/conditional-compilation/cfg-attr-empty-is-unused.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-empty-is-unused.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-empty-is-unused.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-empty-is-unused.stderr?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -1,4 +1,4 @@\n-error: unused attribute\n+error: `#[cfg_attr]` does not expand to any attributes\n   --> $DIR/cfg-attr-empty-is-unused.rs:7:1\n    |\n LL | #[cfg_attr(FALSE,)]\n@@ -11,7 +11,7 @@ LL | #![deny(unused)]\n    |         ^^^^^^\n    = note: `#[deny(unused_attributes)]` implied by `#[deny(unused)]`\n \n-error: unused attribute\n+error: `#[cfg_attr]` does not expand to any attributes\n   --> $DIR/cfg-attr-empty-is-unused.rs:10:1\n    |\n LL | #[cfg_attr(TRUE,)]"}, {"sha": "8eb8f368b12f35926711bc29e5e55675a275c739", "filename": "src/test/ui/const-generics/defaults/default-annotation.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdefault-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdefault-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdefault-annotation.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -13,7 +13,6 @@ pub struct ConstDefaultUnstable<const N: usize = 3>;\n \n #[stable(feature = \"const_default_unstable\", since=\"none\")]\n pub struct ConstDefaultStable<const N: usize = {\n-    #[stable(feature = \"const_default_unstable_val\", since=\"none\")]\n     3\n }>;\n "}, {"sha": "767c521b91f2bcb3fe309872c60402c576fca3bb", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs.rs", "status": "modified", "additions": 88, "deletions": 135, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -49,14 +49,14 @@\n #![macro_use] // (allowed if no argument; see issue-43160-gating-of-macro_use.rs)\n // skipping testing of cfg\n // skipping testing of cfg_attr\n-#![should_panic] //~ WARN unused attribute\n-#![ignore] //~ WARN unused attribute\n+#![should_panic] //~ WARN `#[should_panic]` only has an effect\n+#![ignore] //~ WARN `#[ignore]` only has an effect on functions\n #![no_implicit_prelude]\n #![reexport_test_harness_main = \"2900\"]\n // see gated-link-args.rs\n // see issue-43106-gating-of-macro_escape.rs for crate-level; but non crate-level is below at \"2700\"\n // (cannot easily test gating of crate-level #[no_std]; but non crate-level is below at \"2600\")\n-#![proc_macro_derive()] //~ WARN unused attribute\n+#![proc_macro_derive()] //~ WARN `#[proc_macro_derive]` only has an effect\n #![doc = \"2400\"]\n #![cold] //~ WARN attribute should be applied to a function\n //~^ WARN\n@@ -182,35 +182,35 @@ mod macro_use {\n     mod inner { #![macro_use] }\n \n     #[macro_use] fn f() { }\n-    //~^ WARN unused attribute\n+    //~^ `#[macro_use]` only has an effect\n \n     #[macro_use] struct S;\n-    //~^ WARN unused attribute\n+    //~^ `#[macro_use]` only has an effect\n \n     #[macro_use] type T = S;\n-    //~^ WARN unused attribute\n+    //~^ `#[macro_use]` only has an effect\n \n     #[macro_use] impl S { }\n-    //~^ WARN unused attribute\n+    //~^ `#[macro_use]` only has an effect\n }\n \n #[macro_export]\n-//~^ WARN unused attribute\n+//~^ WARN `#[macro_export]` only has an effect on macro definitions\n mod macro_export {\n     mod inner { #![macro_export] }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_export]` only has an effect on macro definitions\n \n     #[macro_export] fn f() { }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_export]` only has an effect on macro definitions\n \n     #[macro_export] struct S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_export]` only has an effect on macro definitions\n \n     #[macro_export] type T = S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_export]` only has an effect on macro definitions\n \n     #[macro_export] impl S { }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_export]` only has an effect on macro definitions\n }\n \n // At time of unit test authorship, if compiling without `--test` then\n@@ -263,35 +263,32 @@ mod path {\n     mod inner { #![path=\"3800\"] }\n \n     #[path = \"3800\"] fn f() { }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[path]` only has an effect\n \n     #[path = \"3800\"]  struct S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[path]` only has an effect\n \n     #[path = \"3800\"] type T = S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[path]` only has an effect\n \n     #[path = \"3800\"] impl S { }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[path]` only has an effect\n }\n \n+// Don't warn on `automatically_derived` - a custom derive\n+// could reasonally annotate anything that it emits with\n+// this attribute\n #[automatically_derived]\n-//~^ WARN unused attribute\n mod automatically_derived {\n     mod inner { #![automatically_derived] }\n-    //~^ WARN unused attribute\n \n     #[automatically_derived] fn f() { }\n-    //~^ WARN unused attribute\n \n     #[automatically_derived] struct S;\n-    //~^ WARN unused attribute\n \n     #[automatically_derived] type T = S;\n-    //~^ WARN unused attribute\n \n     #[automatically_derived] impl S { }\n-    //~^ WARN unused attribute\n }\n \n #[no_mangle]\n@@ -335,79 +332,77 @@ mod no_mangle {\n }\n \n #[should_panic]\n-//~^ WARN unused attribute\n+//~^ WARN `#[should_panic]` only has an effect on\n mod should_panic {\n     mod inner { #![should_panic] }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[should_panic]` only has an effect on\n \n     #[should_panic] fn f() { }\n-    //~^ WARN unused attribute\n \n     #[should_panic] struct S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[should_panic]` only has an effect on\n \n     #[should_panic] type T = S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[should_panic]` only has an effect on\n \n     #[should_panic] impl S { }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[should_panic]` only has an effect on\n }\n \n #[ignore]\n-//~^ WARN unused attribute\n+//~^ WARN `#[ignore]` only has an effect on functions\n mod ignore {\n     mod inner { #![ignore] }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[ignore]` only has an effect on functions\n \n     #[ignore] fn f() { }\n-    //~^ WARN unused attribute\n \n     #[ignore] struct S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[ignore]` only has an effect on functions\n \n     #[ignore] type T = S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[ignore]` only has an effect on functions\n \n     #[ignore] impl S { }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[ignore]` only has an effect on functions\n }\n \n #[no_implicit_prelude]\n-//~^ WARN unused attribute\n+//~^ WARN crate-level attribute\n mod no_implicit_prelude {\n     mod inner { #![no_implicit_prelude] }\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute\n \n     #[no_implicit_prelude] fn f() { }\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute\n \n     #[no_implicit_prelude] struct S;\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute\n \n     #[no_implicit_prelude] type T = S;\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute\n \n     #[no_implicit_prelude] impl S { }\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute\n }\n \n #[reexport_test_harness_main = \"2900\"]\n-//~^ WARN unused attribute\n+//~^ WARN crate-level attribute should be\n mod reexport_test_harness_main {\n     mod inner { #![reexport_test_harness_main=\"2900\"] }\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute should be\n \n     #[reexport_test_harness_main = \"2900\"] fn f() { }\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute should be\n \n     #[reexport_test_harness_main = \"2900\"] struct S;\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute should be\n \n     #[reexport_test_harness_main = \"2900\"] type T = S;\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute should be\n \n     #[reexport_test_harness_main = \"2900\"] impl S { }\n-    //~^ WARN unused attribute\n+    //~^ WARN crate-level attribute should be\n }\n \n // Cannot feed \"2700\" to `#[macro_escape]` without signaling an error.\n@@ -419,41 +414,35 @@ mod macro_escape {\n     //~| HELP try an outer attribute: `#[macro_use]`\n \n     #[macro_escape] fn f() { }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_escape]` only has an effect\n \n     #[macro_escape] struct S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_escape]` only has an effect\n \n     #[macro_escape] type T = S;\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_escape]` only has an effect\n \n     #[macro_escape] impl S { }\n-    //~^ WARN unused attribute\n+    //~^ WARN `#[macro_escape]` only has an effect\n }\n \n #[no_std]\n-//~^ WARN unused attribute\n-//~| WARN crate-level attribute should be an inner attribute\n+//~^ WARN crate-level attribute should be an inner attribute\n mod no_std {\n     mod inner { #![no_std] }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be in the root module\n+//~^ WARN crate-level attribute should be in the root module\n \n     #[no_std] fn f() { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[no_std] struct S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[no_std] type T = S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[no_std] impl S { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n }\n \n // At time of authorship, #[proc_macro_derive = \"2500\"] signals error\n@@ -633,104 +622,80 @@ mod windows_subsystem {\n // BROKEN USES OF CRATE-LEVEL BUILT-IN ATTRIBUTES\n \n #[crate_name = \"0900\"]\n-//~^ WARN unused attribute\n-//~| WARN crate-level attribute should be an inner attribute\n+//~^ WARN crate-level attribute should be an inner attribute\n mod crate_name {\n     mod inner { #![crate_name=\"0900\"] }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be in the root module\n+//~^ WARN crate-level attribute should be in the root module\n \n     #[crate_name = \"0900\"] fn f() { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[crate_name = \"0900\"] struct S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[crate_name = \"0900\"] type T = S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[crate_name = \"0900\"] impl S { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n }\n \n #[crate_type = \"0800\"]\n-//~^ WARN unused attribute\n-//~| WARN crate-level attribute should be an inner attribute\n+//~^ WARN crate-level attribute should be an inner attribute\n mod crate_type {\n     mod inner { #![crate_type=\"0800\"] }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be in the root module\n+//~^ WARN crate-level attribute should be in the root module\n \n     #[crate_type = \"0800\"] fn f() { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[crate_type = \"0800\"] struct S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[crate_type = \"0800\"] type T = S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[crate_type = \"0800\"] impl S { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n }\n \n #[feature(x0600)]\n-//~^ WARN unused attribute\n-//~| WARN crate-level attribute should be an inner attribute\n+//~^ WARN crate-level attribute should be an inner attribute\n mod feature {\n     mod inner { #![feature(x0600)] }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be in the root module\n+//~^ WARN crate-level attribute should be in the root module\n \n     #[feature(x0600)] fn f() { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[feature(x0600)] struct S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[feature(x0600)] type T = S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[feature(x0600)] impl S { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n }\n \n \n #[no_main]\n-//~^ WARN unused attribute\n-//~| WARN crate-level attribute should be an inner attribute\n+//~^ WARN crate-level attribute should be an inner attribute\n mod no_main_1 {\n     mod inner { #![no_main] }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be in the root module\n+//~^ WARN crate-level attribute should be in the root module\n \n     #[no_main] fn f() { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[no_main] struct S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[no_main] type T = S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[no_main] impl S { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n }\n \n #[no_builtins]\n@@ -747,53 +712,41 @@ mod no_builtins {\n }\n \n #[recursion_limit=\"0200\"]\n-//~^ WARN unused attribute\n-//~| WARN crate-level attribute should be an inner attribute\n+//~^ WARN crate-level attribute should be an inner attribute\n mod recursion_limit {\n     mod inner { #![recursion_limit=\"0200\"] }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be in the root module\n+//~^ WARN crate-level attribute should be in the root module\n \n     #[recursion_limit=\"0200\"] fn f() { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[recursion_limit=\"0200\"] struct S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[recursion_limit=\"0200\"] type T = S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[recursion_limit=\"0200\"] impl S { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n }\n \n #[type_length_limit=\"0100\"]\n-//~^ WARN unused attribute\n-//~| WARN crate-level attribute should be an inner attribute\n+//~^ WARN crate-level attribute should be an inner attribute\n mod type_length_limit {\n     mod inner { #![type_length_limit=\"0100\"] }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be in the root module\n+//~^ WARN crate-level attribute should be in the root module\n \n     #[type_length_limit=\"0100\"] fn f() { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[type_length_limit=\"0100\"] struct S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[type_length_limit=\"0100\"] type T = S;\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n \n     #[type_length_limit=\"0100\"] impl S { }\n-    //~^ WARN unused attribute\n-    //~| WARN crate-level attribute should be an inner attribute\n+    //~^ WARN crate-level attribute should be an inner attribute\n }\n \n fn main() {}"}, {"sha": "3080af2450047a43187f933840d048f595d795ea", "filename": "src/test/ui/invalid/invalid-plugin-attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Finvalid%2Finvalid-plugin-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Finvalid%2Finvalid-plugin-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-plugin-attr.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -1,8 +1,7 @@\n #![deny(unused_attributes)]\n #![feature(plugin)]\n \n-#[plugin(bla)]  //~ ERROR unused attribute\n-                //~^ ERROR should be an inner attribute\n+#[plugin(bla)] //~ ERROR should be an inner attribute\n //~| WARN use of deprecated attribute `plugin`: compiler plugins are deprecated\n \n fn main() {}"}, {"sha": "d3882d33fc484090ed1df362a79e02a1a1127b33", "filename": "src/test/ui/invalid/invalid-plugin-attr.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Finvalid%2Finvalid-plugin-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Finvalid%2Finvalid-plugin-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-plugin-attr.stderr?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -6,7 +6,7 @@ LL | #[plugin(bla)]\n    |\n    = note: `#[warn(deprecated)]` on by default\n \n-error: unused attribute\n+error: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n   --> $DIR/invalid-plugin-attr.rs:4:1\n    |\n LL | #[plugin(bla)]\n@@ -18,11 +18,5 @@ note: the lint level is defined here\n LL | #![deny(unused_attributes)]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/invalid-plugin-attr.rs:4:1\n-   |\n-LL | #[plugin(bla)]\n-   | ^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors; 1 warning emitted\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "d06917ea3f8abea25c0d49db0accfe9003737c5e", "filename": "src/test/ui/lint/lint-misplaced-attr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Flint%2Flint-misplaced-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Flint%2Flint-misplaced-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-misplaced-attr.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -4,9 +4,7 @@\n #![deny(unused_attributes)]\n \n mod a {\n-    #![crate_type = \"bin\"] //~ ERROR unused attribute\n-                           //~^ ERROR should be in the root module\n+    #![crate_type = \"bin\"] //~ ERROR should be in the root module\n }\n \n-#[crate_type = \"bin\"] fn main() {} //~ ERROR unused attribute\n-                                   //~^ ERROR should be an inner\n+#[crate_type = \"bin\"] fn main() {} //~ ERROR should be an inner"}, {"sha": "abaf4620e6f8fe171083c6dc42ee8e46f4b44f1e", "filename": "src/test/ui/lint/lint-misplaced-attr.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Flint%2Flint-misplaced-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Flint%2Flint-misplaced-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-misplaced-attr.stderr?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -1,4 +1,4 @@\n-error: unused attribute\n+error: crate-level attribute should be in the root module\n   --> $DIR/lint-misplaced-attr.rs:7:5\n    |\n LL |     #![crate_type = \"bin\"]\n@@ -10,23 +10,11 @@ note: the lint level is defined here\n LL | #![deny(unused_attributes)]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: crate-level attribute should be in the root module\n-  --> $DIR/lint-misplaced-attr.rs:7:5\n-   |\n-LL |     #![crate_type = \"bin\"]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/lint-misplaced-attr.rs:11:1\n-   |\n-LL | #[crate_type = \"bin\"] fn main() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^\n-\n error: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/lint-misplaced-attr.rs:11:1\n+  --> $DIR/lint-misplaced-attr.rs:10:1\n    |\n LL | #[crate_type = \"bin\"] fn main() {}\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "c0fc280ab1a7c1f0c165daaaa437610ac89374a2", "filename": "src/test/ui/lint/unused/unused-attr-macro-rules.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-macro-rules.rs?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -4,10 +4,9 @@\n \n // A sample of various built-in attributes.\n #[macro_export]\n-#[macro_use] //~ ERROR unused attribute\n-#[path=\"foo\"] //~ ERROR unused attribute\n-#[recursion_limit=\"1\"] //~ ERROR unused attribute\n-                       //~| ERROR crate-level attribute should be an inner attribute\n+#[macro_use] //~ ERROR `#[macro_use]` only has an effect\n+#[path=\"foo\"] //~ ERROR #[path]` only has an effect\n+#[recursion_limit=\"1\"] //~ ERROR crate-level attribute should be an inner attribute\n macro_rules! foo {\n     () => {};\n }"}, {"sha": "e3ca90d9acdd02bb675642cb3088bd74097bbe8f", "filename": "src/test/ui/lint/unused/unused-attr-macro-rules.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-macro-rules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af46699f8104ba5257d0da56d3d817bf8fc751cf/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-macro-rules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-macro-rules.stderr?ref=af46699f8104ba5257d0da56d3d817bf8fc751cf", "patch": "@@ -1,4 +1,4 @@\n-error: unused attribute\n+error: `#[macro_use]` only has an effect on `extern crate` and modules\n   --> $DIR/unused-attr-macro-rules.rs:7:1\n    |\n LL | #[macro_use]\n@@ -10,23 +10,17 @@ note: the lint level is defined here\n LL | #![deny(unused_attributes)]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: unused attribute\n+error: `#[path]` only has an effect on modules\n   --> $DIR/unused-attr-macro-rules.rs:8:1\n    |\n LL | #[path=\"foo\"]\n    | ^^^^^^^^^^^^^\n \n-error: unused attribute\n-  --> $DIR/unused-attr-macro-rules.rs:9:1\n-   |\n-LL | #[recursion_limit=\"1\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-\n error: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n   --> $DIR/unused-attr-macro-rules.rs:9:1\n    |\n LL | #[recursion_limit=\"1\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "cb8ac0e6a05c0837433fae4b7ff3df756421c165", "filename": "src/test/ui/lint/unused/unused-attr.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b6e334d87349502766be70d649e6fe4a73573482/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e334d87349502766be70d649e6fe4a73573482/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr.rs?ref=b6e334d87349502766be70d649e6fe4a73573482", "patch": "@@ -1,49 +0,0 @@\n-#![deny(unused_attributes)]\n-#![feature(rustc_attrs)]\n-\n-#![rustc_dummy] //~ ERROR unused attribute\n-\n-#[rustc_dummy] //~ ERROR unused attribute\n-extern crate core;\n-\n-#[rustc_dummy] //~ ERROR unused attribute\n-use std::collections;\n-\n-#[rustc_dummy] //~ ERROR unused attribute\n-extern \"C\" {\n-    #[rustc_dummy] //~ ERROR unused attribute\n-    fn foo();\n-}\n-\n-#[rustc_dummy] //~ ERROR unused attribute\n-mod foo {\n-    #[rustc_dummy] //~ ERROR unused attribute\n-    pub enum Foo {\n-        #[rustc_dummy] //~ ERROR unused attribute\n-        Bar,\n-    }\n-}\n-\n-#[rustc_dummy] //~ ERROR unused attribute\n-fn bar(f: foo::Foo) {\n-    match f {\n-        #[rustc_dummy] //~ ERROR unused attribute\n-        foo::Foo::Bar => {}\n-    }\n-}\n-\n-#[rustc_dummy] //~ ERROR unused attribute\n-struct Foo {\n-    #[rustc_dummy] //~ ERROR unused attribute\n-    a: isize\n-}\n-\n-#[rustc_dummy] //~ ERROR unused attribute\n-trait Baz {\n-    #[rustc_dummy] //~ ERROR unused attribute\n-    fn blah(&self);\n-    #[rustc_dummy] //~ ERROR unused attribute\n-    fn blah2(&self) {}\n-}\n-\n-fn main() {}"}, {"sha": "707521b7802f0af9bb2af97f083d091d96bfdb70", "filename": "src/test/ui/lint/unused/unused-attr.stderr", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b6e334d87349502766be70d649e6fe4a73573482/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e334d87349502766be70d649e6fe4a73573482/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr.stderr?ref=b6e334d87349502766be70d649e6fe4a73573482", "patch": "@@ -1,98 +0,0 @@\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:4:1\n-   |\n-LL | #![rustc_dummy]\n-   | ^^^^^^^^^^^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/unused-attr.rs:1:9\n-   |\n-LL | #![deny(unused_attributes)]\n-   |         ^^^^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:6:1\n-   |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:9:1\n-   |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:12:1\n-   |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:14:5\n-   |\n-LL |     #[rustc_dummy]\n-   |     ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:18:1\n-   |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:20:5\n-   |\n-LL |     #[rustc_dummy]\n-   |     ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:22:9\n-   |\n-LL |         #[rustc_dummy]\n-   |         ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:27:1\n-   |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:30:9\n-   |\n-LL |         #[rustc_dummy]\n-   |         ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:35:1\n-   |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:37:5\n-   |\n-LL |     #[rustc_dummy]\n-   |     ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:41:1\n-   |\n-LL | #[rustc_dummy]\n-   | ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:43:5\n-   |\n-LL |     #[rustc_dummy]\n-   |     ^^^^^^^^^^^^^^\n-\n-error: unused attribute\n-  --> $DIR/unused-attr.rs:45:5\n-   |\n-LL |     #[rustc_dummy]\n-   |     ^^^^^^^^^^^^^^\n-\n-error: aborting due to 15 previous errors\n-"}]}