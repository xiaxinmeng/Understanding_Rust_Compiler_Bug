{"sha": "f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZjEwZGJhMjk3NWI1MWMyZDJjOTIxNTcwMThkYjNhYzEzZDRkNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-17T20:31:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-17T20:31:08Z"}, "message": "auto merge of #21300 : steveklabnik/rust/rollup, r=steveklabnik\n\nmanual rollup to fix some conflicts and diagnose why the test is failing...", "tree": {"sha": "54bad6d9f9d3472c424b02ec91ff508a81ea1ffa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54bad6d9f9d3472c424b02ec91ff508a81ea1ffa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "html_url": "https://github.com/rust-lang/rust/commit/f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89c4e3792ddc5b45706ea0e919806a248f7a87c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/89c4e3792ddc5b45706ea0e919806a248f7a87c3", "html_url": "https://github.com/rust-lang/rust/commit/89c4e3792ddc5b45706ea0e919806a248f7a87c3"}, {"sha": "6553c0f5eb7cb903b698431556ade4e954dcb4e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6553c0f5eb7cb903b698431556ade4e954dcb4e6", "html_url": "https://github.com/rust-lang/rust/commit/6553c0f5eb7cb903b698431556ade4e954dcb4e6"}], "stats": {"total": 1061, "additions": 604, "deletions": 457}, "files": [{"sha": "e69282e381bc07152cc7598f21f3162e4bbb1f22", "filename": "LICENSE-MIT", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/LICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/LICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSE-MIT?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-Copyright (c) 2014 The Rust Project Developers\n+Copyright (c) 2015 The Rust Project Developers\n \n Permission is hereby granted, free of charge, to any\n person obtaining a copy of this software and associated"}, {"sha": "5957405f0f9ec08c2b5ec476e6491031213af059", "filename": "mk/crates.mk", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -52,7 +52,7 @@\n TARGET_CRATES := libc std flate arena term \\\n                  serialize getopts collections test rand \\\n                  log regex graphviz core rbml alloc \\\n-                 unicode\n+                 unicode rustc_bitflags\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n@@ -64,7 +64,8 @@ DEPS_libc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n DEPS_std := core libc rand alloc collections unicode \\\n-\tnative:rust_builtin native:backtrace native:rustrt_native\n+\tnative:rust_builtin native:backtrace native:rustrt_native \\\n+\trustc_bitflags\n DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n@@ -83,6 +84,7 @@ DEPS_rustc_llvm := native:rustllvm libc std\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test\n+DEPS_rustc_bitflags := core\n DEPS_flate := std native:miniz\n DEPS_arena := std\n DEPS_graphviz := std\n@@ -114,6 +116,7 @@ ONLY_RLIB_alloc := 1\n ONLY_RLIB_rand := 1\n ONLY_RLIB_collections := 1\n ONLY_RLIB_unicode := 1\n+ONLY_RLIB_rustc_bitflags := 1\n \n ################################################################################\n # You should not need to edit below this line"}, {"sha": "3487738467fbc463a04e684f1361078d025e36b1", "filename": "src/doc/intro.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -424,11 +424,11 @@ Let's see an example. This Rust code will not compile:\n use std::thread::Thread;\n \n fn main() {\n-    let mut numbers = vec![1i, 2i, 3i];\n+    let mut numbers = vec![1is, 2, 3];\n \n-    for i in range(0u, 3u) {\n+    for i in 0..3 {\n         Thread::spawn(move || {\n-            for j in range(0, 3) { numbers[j] += 1 }\n+            for j in 0..3 { numbers[j] += 1 }\n         });\n     }\n }\n@@ -438,15 +438,15 @@ It gives us this error:\n \n ```text\n 6:71 error: capture of moved value: `numbers`\n-    for j in range(0, 3) { numbers[j] += 1 }\n-               ^~~~~~~\n+    for j in 0..3 { numbers[j] += 1 }\n+                    ^~~~~~~\n 7:50 note: `numbers` moved into closure environment here\n     spawn(move || {\n-        for j in range(0, 3) { numbers[j] += 1 }\n+        for j in 0..3 { numbers[j] += 1 }\n     });\n 6:79 error: cannot assign to immutable dereference (dereference is implicit, due to indexing)\n-        for j in range(0, 3) { numbers[j] += 1 }\n-                           ^~~~~~~~~~~~~~~\n+        for j in 0..3 { numbers[j] += 1 }\n+                        ^~~~~~~~~~~~~~~\n ```\n \n It mentions that \"numbers moved into closure environment\". Because we\n@@ -478,9 +478,9 @@ use std::thread::Thread;\n use std::sync::{Arc,Mutex};\n \n fn main() {\n-    let numbers = Arc::new(Mutex::new(vec![1i, 2i, 3i]));\n+    let numbers = Arc::new(Mutex::new(vec![1is, 2, 3]));\n \n-    for i in range(0u, 3u) {\n+    for i in 0..3 {\n         let number = numbers.clone();\n         Thread::spawn(move || {\n             let mut array = number.lock().unwrap();\n@@ -541,12 +541,12 @@ safety check that makes this an error about moved values:\n use std::thread::Thread;\n \n fn main() {\n-    let vec = vec![1i, 2, 3];\n+    let vec = vec![1is, 2, 3];\n \n-    for i in range(0u, 3) {\n+    for i in 0us..3 {\n         Thread::spawn(move || {\n             println!(\"{}\", vec[i]);\n-        }).detach();\n+        });\n     }\n }\n ```\n@@ -557,9 +557,9 @@ you can remove it. As an example, this is a poor way to iterate through\n a vector:\n \n ```{rust}\n-let vec = vec![1i, 2, 3];\n+let vec = vec![1, 2, 3];\n \n-for i in range(0u, vec.len()) {\n+for i in 0..vec.len() {\n      println!(\"{}\", vec[i]);\n }\n ```\n@@ -569,7 +569,7 @@ that we don't try to access an invalid index. However, we can remove this\n while retaining safety. The answer is iterators:\n \n ```{rust}\n-let vec = vec![1i, 2, 3];\n+let vec = vec![1, 2, 3];\n \n for x in vec.iter() {\n     println!(\"{}\", x);"}, {"sha": "a27d6c6e268a9c052dfe89b6b51eb45cdb3ef552", "filename": "src/doc/reference.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1413,6 +1413,27 @@ a = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n In this example, `Cat` is a _struct-like enum variant_,\n whereas `Dog` is simply called an enum variant.\n \n+Enums have a discriminant. You can assign them explicitly:\n+\n+```\n+enum Foo {\n+    Bar = 123,\n+}\n+```\n+\n+If a discriminant isn't assigned, they start at zero, and add one for each\n+variant, in order.\n+\n+You can cast an enum to get this value:\n+\n+```\n+# enum Foo { Bar = 123 }\n+let x = Foo::Bar as u32; // x is now 123u32\n+```\n+\n+This only works as long as none of the variants have data attached. If\n+it were `Bar(i32)`, this is disallowed.\n+\n ### Constant items\n \n ```{.ebnf .gram}"}, {"sha": "2df769b3c2c67c1484610617d97f62ea1a6ee6b6", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -5,7 +5,7 @@ things. The most basic is the *array*, a fixed-size list of elements of the\n same type. By default, arrays are immutable.\n \n ```{rust}\n-let a = [1, 2, 3];     // a: [i32; 3]\n+let a = [1, 2, 3]; // a: [i32; 3]\n let mut m = [1, 2, 3]; // mut m: [i32; 3]\n ```\n \n@@ -68,7 +68,7 @@ let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>\n \n nums.push(4);\n \n-println!(\"The length of nums is now {}\", nums.len());   // Prints 4\n+println!(\"The length of nums is now {}\", nums.len()); // Prints 4\n ```\n \n Vectors have many more useful methods.\n@@ -82,10 +82,10 @@ arrays:\n \n ```{rust}\n let a = [0, 1, 2, 3, 4];\n-let middle = &a[1..4];     // A slice of a: just the elements 1, 2, and 3\n+let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n \n for e in middle.iter() {\n-    println!(\"{}\", e);          // Prints 1, 2, 3\n+    println!(\"{}\", e); // Prints 1, 2, 3\n }\n ```\n "}, {"sha": "0616f094e376e0b3f3af6398b01ec2738cf5808e", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -51,7 +51,7 @@ arity and contained types.\n \n ```rust\n let mut x = (1, 2); // x: (i32, i32)\n-let y = (2, 3);     // y: (i32, i32)\n+let y = (2, 3); // y: (i32, i32)\n \n x = y;\n ```\n@@ -156,7 +156,7 @@ These two will not be equal, even if they have the same values:\n ```{rust}\n # struct Color(i32, i32, i32);\n # struct Point(i32, i32, i32);\n-let black  = Color(0, 0, 0);\n+let black = Color(0, 0, 0);\n let origin = Point(0, 0, 0);\n ```\n \n@@ -297,7 +297,7 @@ enum StringResult {\n }\n ```\n Where a `StringResult` is either a `StringResult::StringOK`, with the result of\n-a computation, or an `StringResult::ErrorReason` with a `String` explaining\n+a computation, or a `StringResult::ErrorReason` with a `String` explaining\n what caused the computation to fail. These kinds of `enum`s are actually very\n useful and are even part of the standard library.\n "}, {"sha": "6c5c14fe3111db5c0827e692cd80a5494266ba9e", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% The Rust Crates and Modules Guide\n+% Crates and Modules\n \n When a project starts getting large, it's considered a good software\n engineering practice to split it up into a bunch of smaller pieces, and then"}, {"sha": "d66142edf3fc9b1b4cae7d7eedc140517dfae296", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% Error Handling in Rust\n+% Error Handling\n \n > The best-laid plans of mice and men  \n > Often go awry\n@@ -60,12 +60,12 @@ fn probability(_: &Event) -> f64 {\n \n fn descriptive_probability(event: Event) -> &'static str {\n     match probability(&event) {\n-        1.00          => \"certain\",\n-        0.00          => \"impossible\",\n+        1.00 => \"certain\",\n+        0.00 => \"impossible\",\n         0.00 ... 0.25 => \"very unlikely\",\n         0.25 ... 0.50 => \"unlikely\",\n         0.50 ... 0.75 => \"likely\",\n-        0.75 ... 1.00  => \"very likely\",\n+        0.75 ... 1.00 => \"very likely\",\n     }\n }\n \n@@ -97,12 +97,12 @@ fn probability(_: &Event) -> f64 {\n \n fn descriptive_probability(event: Event) -> &'static str {\n     match probability(&event) {\n-        1.00          => \"certain\",\n-        0.00          => \"impossible\",\n+        1.00 => \"certain\",\n+        0.00 => \"impossible\",\n         0.00 ... 0.25 => \"very unlikely\",\n         0.25 ... 0.50 => \"unlikely\",\n         0.50 ... 0.75 => \"likely\",\n-        0.75 ... 1.00  => \"very likely\",\n+        0.75 ... 1.00 => \"very likely\",\n         _ => unreachable!()\n     }\n }"}, {"sha": "640f9cc388ef00a9beff06e90815c2a768288a78", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% The Rust Foreign Function Interface Guide\n+% Foreign Function Interface\n \n # Introduction\n \n@@ -11,7 +11,7 @@ snappy includes a C interface (documented in\n The following is a minimal example of calling a foreign function which will\n compile if snappy is installed:\n \n-~~~~no_run\n+```no_run\n extern crate libc;\n use libc::size_t;\n \n@@ -24,7 +24,7 @@ fn main() {\n     let x = unsafe { snappy_max_compressed_length(100) };\n     println!(\"max compressed length of a 100 byte buffer: {}\", x);\n }\n-~~~~\n+```\n \n The `extern` block is a list of function signatures in a foreign library, in\n this case with the platform's C ABI. The `#[link(...)]` attribute is used to\n@@ -44,7 +44,7 @@ keeping the binding correct at runtime.\n \n The `extern` block can be extended to cover the entire snappy API:\n \n-~~~~no_run\n+```no_run\n extern crate libc;\n use libc::{c_int, size_t};\n \n@@ -66,7 +66,7 @@ extern {\n                                          compressed_length: size_t) -> c_int;\n }\n # fn main() {}\n-~~~~\n+```\n \n # Creating a safe interface\n \n@@ -79,7 +79,7 @@ vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous\n length is number of elements currently contained, and the capacity is the total size in elements of\n the allocated memory. The length is less than or equal to the capacity.\n \n-~~~~\n+```\n # extern crate libc;\n # use libc::{c_int, size_t};\n # unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -> c_int { 0 }\n@@ -89,7 +89,7 @@ pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n         snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n     }\n }\n-~~~~\n+```\n \n The `validate_compressed_buffer` wrapper above makes use of an `unsafe` block, but it makes the\n guarantee that calling it is safe for all inputs by leaving off `unsafe` from the function\n@@ -103,7 +103,7 @@ required capacity to hold the compressed output. The vector can then be passed t\n `snappy_compress` function as an output parameter. An output parameter is also passed to retrieve\n the true length after compression for setting the length.\n \n-~~~~\n+```\n # extern crate libc;\n # use libc::{size_t, c_int};\n # unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,\n@@ -116,20 +116,20 @@ pub fn compress(src: &[u8]) -> Vec<u8> {\n         let psrc = src.as_ptr();\n \n         let mut dstlen = snappy_max_compressed_length(srclen);\n-        let mut dst = Vec::with_capacity(dstlen as uint);\n+        let mut dst = Vec::with_capacity(dstlen as usize);\n         let pdst = dst.as_mut_ptr();\n \n         snappy_compress(psrc, srclen, pdst, &mut dstlen);\n-        dst.set_len(dstlen as uint);\n+        dst.set_len(dstlen as usize);\n         dst\n     }\n }\n-~~~~\n+```\n \n Decompression is similar, because snappy stores the uncompressed size as part of the compression\n format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n \n-~~~~\n+```\n # extern crate libc;\n # use libc::{size_t, c_int};\n # unsafe fn snappy_uncompress(compressed: *const u8,\n@@ -148,45 +148,22 @@ pub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n         let mut dstlen: size_t = 0;\n         snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n \n-        let mut dst = Vec::with_capacity(dstlen as uint);\n+        let mut dst = Vec::with_capacity(dstlen as usize);\n         let pdst = dst.as_mut_ptr();\n \n         if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n-            dst.set_len(dstlen as uint);\n+            dst.set_len(dstlen as usize);\n             Some(dst)\n         } else {\n             None // SNAPPY_INVALID_INPUT\n         }\n     }\n }\n-~~~~\n+```\n \n For reference, the examples used here are also available as an [library on\n GitHub](https://github.com/thestinger/rust-snappy).\n \n-# Stack management\n-\n-Rust threads by default run on a *large stack*. This is actually implemented as a\n-reserving a large segment of the address space and then lazily mapping in pages\n-as they are needed. When calling an external C function, the code is invoked on\n-the same stack as the rust stack. This means that there is no extra\n-stack-switching mechanism in place because it is assumed that the large stack\n-for the rust thread is plenty for the C function to have.\n-\n-A planned future improvement (not yet implemented at the time of this writing)\n-is to have a guard page at the end of every rust stack. No rust function will\n-hit this guard page (due to Rust's usage of LLVM's `__morestack`). The intention\n-for this unmapped page is to prevent infinite recursion in C from overflowing\n-onto other rust stacks. If the guard page is hit, then the process will be\n-terminated with a message saying that the guard page was hit.\n-\n-For normal external function usage, this all means that there shouldn't be any\n-need for any extra effort on a user's perspective. The C stack naturally\n-interleaves with the rust stack, and it's \"large enough\" for both to\n-interoperate. If, however, it is determined that a larger stack is necessary,\n-there are appropriate functions in the thread spawning API to control the size of\n-the stack of the thread which is spawned.\n-\n # Destructors\n \n Foreign libraries often hand off ownership of resources to the calling code.\n@@ -208,7 +185,7 @@ A basic example is:\n \n Rust code:\n \n-~~~~no_run\n+```no_run\n extern fn callback(a: i32) {\n     println!(\"I'm called from C with value {0}\", a);\n }\n@@ -225,11 +202,11 @@ fn main() {\n         trigger_callback(); // Triggers the callback\n     }\n }\n-~~~~\n+```\n \n C code:\n \n-~~~~c\n+```c\n typedef void (*rust_callback)(int32_t);\n rust_callback cb;\n \n@@ -241,7 +218,7 @@ int32_t register_callback(rust_callback callback) {\n void trigger_callback() {\n   cb(7); // Will call callback(7) in Rust\n }\n-~~~~\n+```\n \n In this example Rust's `main()` will call `trigger_callback()` in C,\n which would, in turn, call back to `callback()` in Rust.\n@@ -261,7 +238,7 @@ referenced Rust object.\n \n Rust code:\n \n-~~~~no_run\n+```no_run\n #[repr(C)]\n struct RustObject {\n     a: i32,\n@@ -292,11 +269,11 @@ fn main() {\n         trigger_callback();\n     }\n }\n-~~~~\n+```\n \n C code:\n \n-~~~~c\n+```c\n typedef void (*rust_callback)(void*, int32_t);\n void* cb_target;\n rust_callback cb;\n@@ -310,7 +287,7 @@ int32_t register_callback(void* callback_target, rust_callback callback) {\n void trigger_callback() {\n   cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust\n }\n-~~~~\n+```\n \n ## Asynchronous callbacks\n \n@@ -389,13 +366,13 @@ the `link_args` attribute. This attribute is applied to `extern` blocks and\n specifies raw flags which need to get passed to the linker when producing an\n artifact. An example usage would be:\n \n-~~~ no_run\n+``` no_run\n #![feature(link_args)]\n \n #[link_args = \"-foo -bar -baz\"]\n extern {}\n # fn main() {}\n-~~~\n+```\n \n Note that this feature is currently hidden behind the `feature(link_args)` gate\n because this is not a sanctioned way of performing linking. Right now rustc\n@@ -416,9 +393,9 @@ the compiler that the unsafety does not leak out of the block.\n Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\n this:\n \n-~~~~\n+```\n unsafe fn kaboom(ptr: *const int) -> int { *ptr }\n-~~~~\n+```\n \n This function can only be called from an `unsafe` block or another `unsafe` function.\n \n@@ -428,7 +405,7 @@ Foreign APIs often export a global variable which could do something like track\n global state. In order to access these variables, you declare them in `extern`\n blocks with the `static` keyword:\n \n-~~~no_run\n+```no_run\n extern crate libc;\n \n #[link(name = \"readline\")]\n@@ -440,13 +417,13 @@ fn main() {\n     println!(\"You have readline version {} installed.\",\n              rl_readline_version as int);\n }\n-~~~\n+```\n \n Alternatively, you may need to alter global state provided by a foreign\n interface. To do this, statics can be declared with `mut` so rust can mutate\n them.\n \n-~~~no_run\n+```no_run\n extern crate libc;\n \n use std::ffi::CString;\n@@ -463,15 +440,15 @@ fn main() {\n     // get a line, process it\n     unsafe { rl_prompt = ptr::null(); }\n }\n-~~~\n+```\n \n # Foreign calling conventions\n \n Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when\n calling foreign functions. Some foreign functions, most notably the Windows API, use other calling\n conventions. Rust provides a way to tell the compiler which convention to use:\n \n-~~~~\n+```\n extern crate libc;\n \n #[cfg(all(target_os = \"win32\", target_arch = \"x86\"))]\n@@ -481,7 +458,7 @@ extern \"stdcall\" {\n     fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -> libc::c_int;\n }\n # fn main() { }\n-~~~~\n+```\n \n This applies to the entire `extern` block. The list of supported ABI constraints\n are:\n@@ -541,3 +518,22 @@ with one of the non-nullable types, it is represented as a single pointer,\n and the non-data variant is represented as the null pointer. So\n `Option<extern \"C\" fn(c_int) -> c_int>` is how one represents a nullable\n function pointer using the C ABI.\n+\n+# Calling Rust code from C\n+\n+You may wish to compile Rust code in a way so that it can be called from C. This is\n+fairly easy, but requires a few things:\n+\n+```\n+#[no_mangle]\n+pub extern fn hello_rust() -> *const u8 {\n+    \"Hello, world!\\0\".as_ptr()\n+}\n+# fn main() {}\n+```\n+\n+The `extern` makes this function adhere to the C calling convention, as\n+discussed above in \"[Foreign Calling\n+Conventions](guide-ffi.html#foreign-calling-conventions)\". The `no_mangle`\n+attribute turns off Rust's name mangling, so that it is easier to link to.\n+"}, {"sha": "d0ecb6067955da7cc74cffbe08dc62708500a9f1", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -143,7 +143,7 @@ fn foo(x: i32) -> i32 {\n ```\n \n The previous definition without `return` may look a bit strange if you haven't\n-worked in an expression-based language before, but it becomes intutive over\n+worked in an expression-based language before, but it becomes intuitive over\n time. If this were production code, we wouldn't write it in that way anyway,\n we'd write this:\n "}, {"sha": "74cb4530935dffb849f4a50411cf76358d0ee61f", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -5,7 +5,7 @@ multiple types of arguments. For example, remember our `OptionalInt` type?\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n ```\n@@ -40,26 +40,26 @@ we substitute that type for the same type used in the generic. Here's an\n example of using `Option<T>`, with some extra type annotations:\n \n ```{rust}\n-let x: Option<int> = Some(5i);\n+let x: Option<i32> = Some(5);\n ```\n \n-In the type declaration, we say `Option<int>`. Note how similar this looks to\n-`Option<T>`. So, in this particular `Option`, `T` has the value of `int`. On\n-the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n-Since that's an `int`, the two sides match, and Rust is happy. If they didn't\n+In the type declaration, we say `Option<i32>`. Note how similar this looks to\n+`Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On\n+the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.\n+Since that's an `i32`, the two sides match, and Rust is happy. If they didn't\n match, we'd get an error:\n \n ```{rust,ignore}\n-let x: Option<f64> = Some(5i);\n-// error: mismatched types: expected `core::option::Option<f64>`\n-// but found `core::option::Option<int>` (expected f64 but found int)\n+let x: Option<f64> = Some(5);\n+// error: mismatched types: expected `core::option::Option<f64>`,\n+// found `core::option::Option<_>` (expected f64 but found integral variable)\n ```\n \n That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n match up:\n \n ```{rust}\n-let x: Option<int> = Some(5i);\n+let x: Option<i32> = Some(5);\n let y: Option<f64> = Some(5.0f64);\n ```\n "}, {"sha": "6f67c88f2c0cca1e6c15becc9da45925671e89b1", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -297,9 +297,9 @@ fn main() {\n     println!(\"You guessed: {}\", input);\n \n     match cmp(input, secret_number) {\n-        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Less => println!(\"Too small!\"),\n         Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal   => println!(\"You win!\"),\n+        Ordering::Equal => println!(\"You win!\"),\n     }\n }\n \n@@ -352,9 +352,9 @@ fn main() {\n     println!(\"You guessed: {}\", input);\n \n     match cmp(input, secret_number) {\n-        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Less => println!(\"Too small!\"),\n         Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal   => println!(\"You win!\"),\n+        Ordering::Equal => println!(\"You win!\"),\n     }\n }\n \n@@ -422,8 +422,8 @@ In this case, we say `x` is a `u32` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = \"5\".parse::<u32>();         // input_num: Option<u32>\n-let input_num: Option<u32> = \"5\".parse();   // input_num: Option<u32>\n+let input_num = \"5\".parse::<u32>(); // input_num: Option<u32>\n+let input_num: Option<u32> = \"5\".parse(); // input_num: Option<u32>\n ```\n \n Anyway, with us now converting our input to a number, our code looks like this:\n@@ -450,9 +450,9 @@ fn main() {\n     println!(\"You guessed: {}\", input_num);\n \n     match cmp(input_num, secret_number) {\n-        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Less => println!(\"Too small!\"),\n         Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal   => println!(\"You win!\"),\n+        Ordering::Equal => println!(\"You win!\"),\n     }\n }\n \n@@ -499,7 +499,7 @@ fn main() {\n \n     let num = match input_num {\n         Some(num) => num,\n-        None      => {\n+        None => {\n             println!(\"Please input a number!\");\n             return;\n         }\n@@ -509,9 +509,9 @@ fn main() {\n     println!(\"You guessed: {}\", num);\n \n     match cmp(num, secret_number) {\n-        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Less => println!(\"Too small!\"),\n         Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal   => println!(\"You win!\"),\n+        Ordering::Equal => println!(\"You win!\"),\n     }\n }\n \n@@ -566,7 +566,7 @@ fn main() {\n \n     let num = match input_num {\n         Some(num) => num,\n-        None      => {\n+        None => {\n             println!(\"Please input a number!\");\n             return;\n         }\n@@ -576,9 +576,9 @@ fn main() {\n     println!(\"You guessed: {}\", num);\n \n     match cmp(num, secret_number) {\n-        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Less => println!(\"Too small!\"),\n         Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal   => println!(\"You win!\"),\n+        Ordering::Equal => println!(\"You win!\"),\n     }\n }\n \n@@ -642,7 +642,7 @@ fn main() {\n \n         let num = match input_num {\n             Some(num) => num,\n-            None      => {\n+            None => {\n                 println!(\"Please input a number!\");\n                 return;\n             }\n@@ -652,9 +652,9 @@ fn main() {\n         println!(\"You guessed: {}\", num);\n \n         match cmp(num, secret_number) {\n-            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Less => println!(\"Too small!\"),\n             Ordering::Greater => println!(\"Too big!\"),\n-            Ordering::Equal   => println!(\"You win!\"),\n+            Ordering::Equal => println!(\"You win!\"),\n         }\n     }\n }\n@@ -718,7 +718,7 @@ fn main() {\n \n         let num = match input_num {\n             Some(num) => num,\n-            None      => {\n+            None => {\n                 println!(\"Please input a number!\");\n                 return;\n             }\n@@ -728,9 +728,9 @@ fn main() {\n         println!(\"You guessed: {}\", num);\n \n         match cmp(num, secret_number) {\n-            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Less => println!(\"Too small!\"),\n             Ordering::Greater => println!(\"Too big!\"),\n-            Ordering::Equal   => {\n+            Ordering::Equal => {\n                 println!(\"You win!\");\n                 return;\n             },\n@@ -774,7 +774,7 @@ fn main() {\n \n         let num = match input_num {\n             Some(num) => num,\n-            None      => {\n+            None => {\n                 println!(\"Please input a number!\");\n                 continue;\n             }\n@@ -784,9 +784,9 @@ fn main() {\n         println!(\"You guessed: {}\", num);\n \n         match cmp(num, secret_number) {\n-            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Less => println!(\"Too small!\"),\n             Ordering::Greater => println!(\"Too big!\"),\n-            Ordering::Equal   => {\n+            Ordering::Equal => {\n                 println!(\"You win!\");\n                 return;\n             },\n@@ -851,7 +851,7 @@ fn main() {\n \n         let num = match input_num {\n             Some(num) => num,\n-            None      => {\n+            None => {\n                 println!(\"Please input a number!\");\n                 continue;\n             }\n@@ -861,9 +861,9 @@ fn main() {\n         println!(\"You guessed: {}\", num);\n \n         match cmp(num, secret_number) {\n-            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Less => println!(\"Too small!\"),\n             Ordering::Greater => println!(\"Too big!\"),\n-            Ordering::Equal   => {\n+            Ordering::Equal => {\n                 println!(\"You win!\");\n                 return;\n             },"}, {"sha": "75b3f8b06fc3b83ac19ab23315e1b20ce8bf0860", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -5,7 +5,7 @@ Let's talk about loops.\n Remember Rust's `for` loop? Here's an example:\n \n ```{rust}\n-for x in range(0i, 10i) {\n+for x in range(0, 10) {\n     println!(\"{}\", x);\n }\n ```\n@@ -17,7 +17,7 @@ call the `.next()` method on repeatedly, and it gives us a sequence of things.\n Like this:\n \n ```{rust}\n-let mut range = range(0i, 10i);\n+let mut range = range(0, 10);\n \n loop {\n     match range.next() {\n@@ -32,8 +32,8 @@ loop {\n We make a mutable binding to the return value of `range`, which is our iterator.\n We then `loop`, with an inner `match`. This `match` is used on the result of\n `range.next()`, which gives us a reference to the next value of the iterator.\n-`next` returns an `Option<int>`, in this case, which will be `Some(int)` when\n-we have a value and `None` once we run out. If we get `Some(int)`, we print it\n+`next` returns an `Option<i32>`, in this case, which will be `Some(i32)` when\n+we have a value and `None` once we run out. If we get `Some(i32)`, we print it\n out, and if we get `None`, we `break` out of the loop.\n \n This code sample is basically the same as our `for` loop version. The `for`\n@@ -50,9 +50,9 @@ primitive. For example, if you needed to iterate over the contents of\n a vector, you may be tempted to write this:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n-for i in range(0u, nums.len()) {\n+for i in range(0, nums.len()) {\n     println!(\"{}\", nums[i]);\n }\n ```\n@@ -62,7 +62,7 @@ vectors returns an iterator which iterates through a reference to each element\n of the vector in turn. So write this:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n     println!(\"{}\", num);\n@@ -79,12 +79,12 @@ very common with iterators: we can ignore unnecessary bounds checks, but still\n know that we're safe.\n \n There's another detail here that's not 100% clear because of how `println!`\n-works. `num` is actually of type `&int`. That is, it's a reference to an `int`,\n-not an `int` itself. `println!` handles the dereferencing for us, so we don't\n+works. `num` is actually of type `&i32`. That is, it's a reference to an `i32`,\n+not an `i32` itself. `println!` handles the dereferencing for us, so we don't\n see it. This code works fine too:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n     println!(\"{}\", *num);\n@@ -118,7 +118,7 @@ The most common consumer is `collect()`. This code doesn't quite compile,\n but it shows the intention:\n \n ```{rust,ignore}\n-let one_to_one_hundred = range(1i, 101i).collect();\n+let one_to_one_hundred = range(1, 101).collect();\n ```\n \n As you can see, we call `collect()` on our iterator. `collect()` takes\n@@ -128,7 +128,7 @@ type of things you want to collect, and so you need to let it know.\n Here's the version that does compile:\n \n ```{rust}\n-let one_to_one_hundred = range(1i, 101i).collect::<Vec<int>>();\n+let one_to_one_hundred = range(1, 101).collect::<Vec<i32>>();\n ```\n \n If you remember, the `::<>` syntax allows us to give a type hint,\n@@ -138,12 +138,12 @@ and so we tell it that we want a vector of integers.\n is one:\n \n ```{rust}\n-let greater_than_forty_two = range(0i, 100i)\n+let greater_than_forty_two = range(0, 100)\n                              .find(|x| *x > 42);\n \n match greater_than_forty_two {\n     Some(_) => println!(\"We got some numbers!\"),\n-    None    => println!(\"No numbers found :(\"),\n+    None => println!(\"No numbers found :(\"),\n }\n ```\n \n@@ -155,8 +155,8 @@ element, `find` returns an `Option` rather than the element itself.\n Another important consumer is `fold`. Here's what it looks like:\n \n ```{rust}\n-let sum = range(1i, 4i)\n-              .fold(0i, |sum, x| sum + x);\n+let sum = range(1, 4)\n+              .fold(0, |sum, x| sum + x);\n ```\n \n `fold()` is a consumer that looks like this:\n@@ -172,24 +172,24 @@ in this iterator:\n \n | base | accumulator | element | closure result |\n |------|-------------|---------|----------------|\n-| 0i   | 0i          | 1i      | 1i             |\n-| 0i   | 1i          | 2i      | 3i             |\n-| 0i   | 3i          | 3i      | 6i             |\n+| 0    | 0           | 1       | 1              |\n+| 0    | 1           | 2       | 3              |\n+| 0    | 3           | 3       | 6              |\n \n We called `fold()` with these arguments:\n \n ```{rust}\n-# range(1i, 4i)\n-.fold(0i, |sum, x| sum + x);\n+# range(1, 4)\n+.fold(0, |sum, x| sum + x);\n ```\n \n-So, `0i` is our base, `sum` is our accumulator, and `x` is our element.  On the\n-first iteration, we set `sum` to `0i`, and `x` is the first element of `nums`,\n-`1i`. We then add `sum` and `x`, which gives us `0i + 1i = 1i`. On the second\n+So, `0` is our base, `sum` is our accumulator, and `x` is our element.  On the\n+first iteration, we set `sum` to `0`, and `x` is the first element of `nums`,\n+`1`. We then add `sum` and `x`, which gives us `0 + 1 = 1`. On the second\n iteration, that value becomes our accumulator, `sum`, and the element is\n-the second element of the array, `2i`. `1i + 2i = 3i`, and so that becomes\n+the second element of the array, `2`. `1 + 2 = 3`, and so that becomes\n the value of the accumulator for the last iteration. On that iteration,\n-`x` is the last element, `3i`, and `3i + 3i = 6i`, which is our final\n+`x` is the last element, `3`, and `3 + 3 = 6`, which is our final\n result for our sum. `1 + 2 + 3 = 6`, and that's the result we got.\n \n Whew. `fold` can be a bit strange the first few times you see it, but once it\n@@ -210,14 +210,14 @@ This code, for example, does not actually generate the numbers\n `1-100`, and just creates a value that represents the sequence:\n \n ```{rust}\n-let nums = range(1i, 100i);\n+let nums = range(1, 100);\n ```\n \n Since we didn't do anything with the range, it didn't generate the sequence.\n Let's add the consumer:\n \n ```{rust}\n-let nums = range(1i, 100i).collect::<Vec<int>>();\n+let nums = range(1, 100).collect::<Vec<i32>>();\n ```\n \n Now, `collect()` will require that `range()` give it some numbers, and so\n@@ -228,7 +228,7 @@ which you've used before. `iter()` can turn a vector into a simple iterator\n that gives you each element in turn:\n \n ```{rust}\n-let nums = [1i, 2i, 3i];\n+let nums = [1, 2, 3];\n \n for num in nums.iter() {\n    println!(\"{}\", num);\n@@ -239,12 +239,12 @@ These two basic iterators should serve you well. There are some more\n advanced iterators, including ones that are infinite. Like `count`:\n \n ```{rust}\n-std::iter::count(1i, 5i);\n+std::iter::count(1, 5);\n ```\n \n This iterator counts up from one, adding five each time. It will give\n you a new integer every time, forever (well, technically, until it reaches the\n-maximum number representable by an `int`). But since iterators are lazy,\n+maximum number representable by an `i32`). But since iterators are lazy,\n that's okay! You probably don't want to use `collect()` on it, though...\n \n That's enough about iterators. Iterator adapters are the last concept\n@@ -256,7 +256,7 @@ we need to talk about with regards to iterators. Let's get to it!\n a new iterator. The simplest one is called `map`:\n \n ```{rust,ignore}\n-range(1i, 100i).map(|x| x + 1i);\n+range(1, 100).map(|x| x + 1);\n ```\n \n `map` is called upon another iterator, and produces a new iterator where each\n@@ -267,15 +267,15 @@ compile the example, you'll get a warning:\n ```{notrust,ignore}\n warning: unused result which must be used: iterator adaptors are lazy and\n          do nothing unless consumed, #[warn(unused_must_use)] on by default\n- range(1i, 100i).map(|x| x + 1i);\n+ range(1, 100).map(|x| x + 1);\n  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n ```\n \n Laziness strikes again! That closure will never execute. This example\n doesn't print any numbers:\n \n ```{rust,ignore}\n-range(1i, 100i).map(|x| println!(\"{}\", x));\n+range(1, 100).map(|x| println!(\"{}\", x));\n ```\n \n If you are trying to execute a closure on an iterator for its side effects,\n@@ -287,7 +287,7 @@ has no side effect on the original iterator. Let's try it out with our infinite\n iterator from before, `count()`:\n \n ```{rust}\n-for i in std::iter::count(1i, 5i).take(5) {\n+for i in std::iter::count(1, 5).take(5) {\n     println!(\"{}\", i);\n }\n ```\n@@ -307,7 +307,7 @@ returns `true` or `false`. The new iterator `filter()` produces\n only the elements that that closure returns `true` for:\n \n ```{rust}\n-for i in range(1i, 100i).filter(|&x| x % 2 == 0) {\n+for i in range(1, 100).filter(|&x| x % 2 == 0) {\n     println!(\"{}\", i);\n }\n ```\n@@ -322,11 +322,11 @@ You can chain all three things together: start with an iterator, adapt it\n a few times, and then consume the result. Check it out:\n \n ```{rust}\n-range(1i, 1000i)\n+range(1, 1000)\n     .filter(|&x| x % 2 == 0)\n     .filter(|&x| x % 3 == 0)\n     .take(5)\n-    .collect::<Vec<int>>();\n+    .collect::<Vec<i32>>();\n ```\n \n This will give you a vector containing `6`, `12`, `18`, `24`, and `30`."}, {"sha": "28f02b1ffe1528239ba2ba798a12dad126dde496", "filename": "src/doc/trpl/looping.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -54,7 +54,7 @@ The other kind of looping construct in Rust is the `while` loop. It looks like\n this:\n \n ```{rust}\n-let mut x = 5u32;       // mut x: u32\n+let mut x = 5; // mut x: u32\n let mut done = false; // mut done: bool\n \n while !done {\n@@ -91,7 +91,7 @@ can do with safety and code generation, so you should always prefer\n Let's take a look at that `while` loop we had earlier:\n \n ```{rust}\n-let mut x = 5u32;\n+let mut x = 5;\n let mut done = false;\n \n while !done {\n@@ -108,7 +108,7 @@ modifying iteration: `break` and `continue`.\n In this case, we can write the loop in a better way with `break`:\n \n ```{rust}\n-let mut x = 5u32;\n+let mut x = 5;\n \n loop {\n     x += x - 3;"}, {"sha": "e0bccb1b86f329679ea59d8d4ad0735d530987f0", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% The Rust Macros Guide\n+% Macros\n \n # Introduction\n \n@@ -11,8 +11,8 @@ which both pattern-match on their input and both return early in one case,\n doing nothing otherwise:\n \n ~~~~\n-# enum T { SpecialA(uint), SpecialB(uint) }\n-# fn f() -> uint {\n+# enum T { SpecialA(u32), SpecialB(u32) }\n+# fn f() -> u32 {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n match input_1 {\n@@ -24,7 +24,7 @@ match input_2 {\n     T::SpecialB(x) => { return x; }\n     _ => {}\n }\n-# return 0u;\n+# return 0;\n # }\n ~~~~\n \n@@ -37,8 +37,8 @@ lightweight custom syntax extensions, themselves defined using the\n the pattern in the above code:\n \n ~~~~\n-# enum T { SpecialA(uint), SpecialB(uint) }\n-# fn f() -> uint {\n+# enum T { SpecialA(u32), SpecialB(u32) }\n+# fn f() -> u32 {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n@@ -165,8 +165,8 @@ separator token (a comma-separated list could be written `$(...),*`), and `+`\n instead of `*` to mean \"at least one\".\n \n ~~~~\n-# enum T { SpecialA(uint),SpecialB(uint),SpecialC(uint),SpecialD(uint)}\n-# fn f() -> uint {\n+# enum T { SpecialA(u32), SpecialB(u32), SpecialC(u32), SpecialD(u32) }\n+# fn f() -> u32 {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n@@ -226,10 +226,10 @@ solves the problem.\n Now consider code like the following:\n \n ~~~~\n-# enum T1 { Good1(T2, uint), Bad1}\n+# enum T1 { Good1(T2, u32), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2}\n-# fn f(x: T1) -> uint {\n+# enum T3 { Good2(u32), Bad2}\n+# fn f(x: T1) -> u32 {\n match x {\n     T1::Good1(g1, val) => {\n         match g1.body {\n@@ -273,10 +273,10 @@ macro_rules! biased_match {\n     )\n }\n \n-# enum T1 { Good1(T2, uint), Bad1}\n+# enum T1 { Good1(T2, u32), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2}\n-# fn f(x: T1) -> uint {\n+# enum T3 { Good2(u32), Bad2}\n+# fn f(x: T1) -> u32 {\n biased_match!((x)       -> (T1::Good1(g1, val)) else { return 0 };\n               binds g1, val );\n biased_match!((g1.body) -> (T3::Good2(result) )\n@@ -383,10 +383,10 @@ macro_rules! biased_match {\n }\n \n \n-# enum T1 { Good1(T2, uint), Bad1}\n+# enum T1 { Good1(T2, u32), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2}\n-# fn f(x: T1) -> uint {\n+# enum T3 { Good2(u32), Bad2}\n+# fn f(x: T1) -> u32 {\n biased_match!(\n     (x)       -> (T1::Good1(g1, val)) else { return 0 };\n     (g1.body) -> (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n@@ -528,7 +528,7 @@ A further difficulty occurs when a macro is used in multiple crates.  Say that\n `mylib` defines\n \n ```rust\n-pub fn increment(x: uint) -> uint {\n+pub fn increment(x: u32) -> u32 {\n     x + 1\n }\n "}, {"sha": "73bc775a1b29063fc9a384d3870b12f47490bd32", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -84,9 +84,9 @@ fn main() {\n     let y = 10;\n \n     match cmp(x, y) {\n-        Ordering::Less    => println!(\"less\"),\n+        Ordering::Less => println!(\"less\"),\n         Ordering::Greater => println!(\"greater\"),\n-        Ordering::Equal   => println!(\"equal\"),\n+        Ordering::Equal => println!(\"equal\"),\n     }\n }\n ```\n@@ -112,12 +112,12 @@ fn main() {\n \n     match x {\n         OptionalInt::Value(n) => println!(\"x is {}\", n),\n-        OptionalInt::Missing  => println!(\"x is missing!\"),\n+        OptionalInt::Missing => println!(\"x is missing!\"),\n     }\n \n     match y {\n         OptionalInt::Value(n) => println!(\"y is {}\", n),\n-        OptionalInt::Missing  => println!(\"y is missing!\"),\n+        OptionalInt::Missing => println!(\"y is missing!\"),\n     }\n }\n ```\n@@ -146,9 +146,9 @@ fn main() {\n     let y = 10;\n \n     println!(\"{}\", match cmp(x, y) {\n-        Ordering::Less    => \"less\",\n+        Ordering::Less => \"less\",\n         Ordering::Greater => \"greater\",\n-        Ordering::Equal   => \"equal\",\n+        Ordering::Equal => \"equal\",\n     });\n }\n ```"}, {"sha": "9ced5bb656c42774a6df44b9bb8aaa8afce28247", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% The Rust Ownership Guide\n+% Ownership\n \n This guide presents Rust's ownership system. This is one of Rust's most unique\n and compelling features, with which Rust developers should become quite\n@@ -418,7 +418,7 @@ struct Wheel {\n fn main() {\n     let car = Car { name: \"DeLorean\".to_string() };\n \n-    for _ in range(0u, 4) {\n+    for _ in range(0, 4) {\n         Wheel { size: 360, owner: car };\n     }\n }\n@@ -456,7 +456,7 @@ fn main() {\n \n     let car_owner = Rc::new(car);\n \n-    for _ in range(0u, 4) {\n+    for _ in range(0, 4) {\n         Wheel { size: 360, owner: car_owner.clone() };\n     }\n }\n@@ -517,31 +517,31 @@ Here are some examples of functions with elided lifetimes, and the version of\n what the elided lifetimes are expand to:\n \n ```{rust,ignore}\n-fn print(s: &str);                                      // elided\n-fn print<'a>(s: &'a str);                               // expanded\n+fn print(s: &str); // elided\n+fn print<'a>(s: &'a str); // expanded\n \n-fn debug(lvl: u32, s: &str);                           // elided\n-fn debug<'a>(lvl: u32, s: &'a str);                    // expanded\n+fn debug(lvl: u32, s: &str); // elided\n+fn debug<'a>(lvl: u32, s: &'a str); // expanded\n \n // In the preceeding example, `lvl` doesn't need a lifetime because it's not a\n // reference (`&`). Only things relating to references (such as a `struct`\n // which contains a reference) need lifetimes.\n \n-fn substr(s: &str, until: u32) -> &str;                // elided\n-fn substr<'a>(s: &'a str, until: u32) -> &'a str;      // expanded\n+fn substr(s: &str, until: u32) -> &str; // elided\n+fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n \n-fn get_str() -> &str;                                   // ILLEGAL, no inputs\n+fn get_str() -> &str; // ILLEGAL, no inputs\n \n-fn frob(s: &str, t: &str) -> &str;                      // ILLEGAL, two inputs\n+fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n \n-fn get_mut(&mut self) -> &mut T;                        // elided\n-fn get_mut<'a>(&'a mut self) -> &'a mut T;              // expanded\n+fn get_mut(&mut self) -> &mut T; // elided\n+fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n \n-fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command                  // elided\n+fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided\n fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n \n-fn new(buf: &mut [u8]) -> BufWriter;                    // elided\n-fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded\n+fn new(buf: &mut [u8]) -> BufWriter; // elided\n+fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded\n ```\n \n # Related Resources"}, {"sha": "5c7b406a6fc4398f555a74af8452c69151360ada", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -8,7 +8,7 @@ A quick refresher: you can match against literals directly, and `_` acts as an\n *any* case:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 => println!(\"one\"),\n@@ -21,7 +21,7 @@ match x {\n You can match multiple patterns with `|`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 | 2 => println!(\"one or two\"),\n@@ -33,7 +33,7 @@ match x {\n You can match a range of values with `...`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 ... 5 => println!(\"one through five\"),\n@@ -47,7 +47,7 @@ If you're matching multiple things, via a `|` or a `...`, you can bind\n the value to a name with `@`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     e @ 1 ... 5 => println!(\"got a range element {}\", e),\n@@ -60,66 +60,66 @@ ignore the value and type in the variant:\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n \n-let x = OptionalInt::Value(5i);\n+let x = OptionalInt::Value(5);\n \n match x {\n     OptionalInt::Value(..) => println!(\"Got an int!\"),\n-    OptionalInt::Missing   => println!(\"No such luck.\"),\n+    OptionalInt::Missing => println!(\"No such luck.\"),\n }\n ```\n \n You can introduce *match guards* with `if`:\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n \n-let x = OptionalInt::Value(5i);\n+let x = OptionalInt::Value(5);\n \n match x {\n     OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n     OptionalInt::Value(..) => println!(\"Got an int!\"),\n-    OptionalInt::Missing   => println!(\"No such luck.\"),\n+    OptionalInt::Missing => println!(\"No such luck.\"),\n }\n ```\n \n If you're matching on a pointer, you can use the same syntax as you declared it\n with. First, `&`:\n \n ```{rust}\n-let x = &5i;\n+let x = &5;\n \n match x {\n     &val => println!(\"Got a value: {}\", val),\n }\n ```\n \n-Here, the `val` inside the `match` has type `int`. In other words, the left-hand\n-side of the pattern destructures the value. If we have `&5i`, then in `&val`, `val`\n-would be `5i`.\n+Here, the `val` inside the `match` has type `i32`. In other words, the left-hand\n+side of the pattern destructures the value. If we have `&5`, then in `&val`, `val`\n+would be `5`.\n \n If you want to get a reference, use the `ref` keyword:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n \n match x {\n     ref r => println!(\"Got a reference to {}\", r),\n }\n ```\n \n-Here, the `r` inside the `match` has the type `&int`. In other words, the `ref`\n+Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n keyword _creates_ a reference, for use in the pattern. If you need a mutable\n reference, `ref mut` will work in the same way:\n \n ```{rust}\n-let mut x = 5i;\n+let mut x = 5;\n \n match x {\n     ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n@@ -131,11 +131,11 @@ If you have a struct, you can destructure it inside of a pattern:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { x: x, y: y } => println!(\"({},{})\", x, y),\n@@ -147,11 +147,11 @@ If we only care about some of the values, we don't have to give them all names:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { x: x, .. } => println!(\"x is {}\", x),\n@@ -163,11 +163,11 @@ You can do this kind of match on any member, not just the first:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { y: y, .. } => println!(\"y is {}\", y),"}, {"sha": "6e8e2c7ffe292d430364c35f58ac29fb7bc71365", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% The Rust Compiler Plugins Guide\n+% Compiler Plugins\n \n <div class=\"unstable-feature\">\n \n@@ -68,7 +68,7 @@ use rustc::plugin::Registry;\n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<MacResult + 'static> {\n \n-    static NUMERALS: &'static [(&'static str, uint)] = &[\n+    static NUMERALS: &'static [(&'static str, u32)] = &[\n         (\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400),\n         (\"C\",  100), (\"XC\",  90), (\"L\",  50), (\"XL\",  40),\n         (\"X\",   10), (\"IX\",   9), (\"V\",   5), (\"IV\",   4),\n@@ -83,7 +83,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n     };\n \n     let mut text = text.as_slice();\n-    let mut total = 0u;\n+    let mut total = 0;\n     while !text.is_empty() {\n         match NUMERALS.iter().find(|&&(rn, _)| text.starts_with(rn)) {\n             Some(&(rn, val)) => {\n@@ -118,7 +118,7 @@ fn main() {\n }\n ```\n \n-The advantages over a simple `fn(&str) -> uint` are:\n+The advantages over a simple `fn(&str) -> u32` are:\n \n * The (arbitrarily complex) conversion is done at compile time.\n * Input validation is also performed at compile time."}, {"sha": "d74c10b814507f5d45d1dcd3b66443248728b184", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% The Rust Pointer Guide\n+% Pointers\n \n Rust's pointers are one of its more unique and compelling features. Pointers\n are also one of the more confusing topics for newcomers to Rust. They can also\n@@ -28,9 +28,10 @@ question](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-\n as the rest of this guide assumes you know the difference.) Like this:\n \n ```{rust}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n ```\n+\n | location | value |\n |----------|-------|\n | 0xd3e030 | 5\t   |\n@@ -46,10 +47,11 @@ Let's introduce a pointer. In some languages, there is just one type of\n *reference*, which is the simplest kind of pointer.\n \n ```{rust}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n let z = &y;\n ```\n+\n |location | value    |\n |-------- |----------|\n |0xd3e030 | 5        |\n@@ -58,25 +60,25 @@ let z = &y;\n \n See the difference? Rather than contain a value, the value of a pointer is a\n location in memory. In this case, the location of `y`. `x` and `y` have the\n-type `int`, but `z` has the type `&int`. We can print this location using the\n+type `i32`, but `z` has the type `&i32`. We can print this location using the\n `{:p}` format string:\n \n ```{rust}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n let z = &y;\n \n println!(\"{:p}\", z);\n ```\n \n This would print `0xd3e028`, with our fictional memory addresses.\n \n-Because `int` and `&int` are different types, we can't, for example, add them\n+Because `i32` and `&i32` are different types, we can't, for example, add them\n together:\n \n ```{rust,ignore}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n let z = &y;\n \n println!(\"{}\", x + z);\n@@ -85,7 +87,7 @@ println!(\"{}\", x + z);\n This gives us an error:\n \n ```text\n-hello.rs:6:24: 6:25 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)\n+hello.rs:6:24: 6:25 error: mismatched types: expected `i32` but found `&i32` (expected i32 but found &-ptr)\n hello.rs:6     println!(\"{}\", x + z);\n                                   ^\n ```\n@@ -95,8 +97,8 @@ pointer means accessing the value at the location stored in the pointer. This\n will work:\n \n ```{rust}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n let z = &y;\n \n println!(\"{}\", x + *z);\n@@ -153,7 +155,7 @@ So what do pointers have to do with this? Well, since pointers point to a\n location in memory...\n \n ```text\n-func foo(&int x) {\n+func foo(&i32 x) {\n     *x = 5\n }\n \n@@ -252,7 +254,7 @@ The most basic type of pointer that Rust has is called a *reference*. Rust\n references look like this:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n \n println!(\"{}\", *y);\n@@ -269,18 +271,18 @@ referent, because `println!` will automatically dereference it for us.\n Here's a function that takes a reference:\n \n ```{rust}\n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n ```\n \n You can also use `&` as an operator to create a reference, so we can\n call this function in two different ways:\n \n ```{rust}\n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n \n fn main() {\n \n-    let x = 5i;\n+    let x = 5;\n     let y = &x;\n \n     println!(\"{}\", succ(y));\n@@ -294,13 +296,13 @@ Of course, if this were real code, we wouldn't bother with the reference, and\n just write:\n \n ```{rust}\n-fn succ(x: int) -> int { x + 1 }\n+fn succ(x: i32) -> i32 { x + 1 }\n ```\n \n References are immutable by default:\n \n ```{rust,ignore}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n \n *y = 5; // error: cannot assign to immutable dereference of `&`-pointer `*y`\n@@ -310,29 +312,29 @@ They can be made mutable with `mut`, but only if its referent is also mutable.\n This works:\n \n ```{rust}\n-let mut x = 5i;\n+let mut x = 5;\n let y = &mut x;\n ```\n \n This does not:\n \n ```{rust,ignore}\n-let x = 5i;\n+let x = 5;\n let y = &mut x; // error: cannot borrow immutable local variable `x` as mutable\n ```\n \n Immutable pointers are allowed to alias:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n let z = &x;\n ```\n \n Mutable ones, however, are not:\n \n ```{rust,ignore}\n-let mut x = 5i;\n+let mut x = 5;\n let y = &mut x;\n let z = &mut x; // error: cannot borrow `x` as mutable more than once at a time\n ```\n@@ -359,7 +361,7 @@ duration a *lifetime*. Let's try a more complex example:\n \n ```{rust}\n fn main() {\n-    let x = &mut 5i;\n+    let x = &mut 5;\n \n     if *x < 10 {\n         let y = &x;\n@@ -380,7 +382,7 @@ mutated, and therefore, lets us pass. This wouldn't work:\n \n ```{rust,ignore}\n fn main() {\n-    let x = &mut 5i;\n+    let x = &mut 5;\n \n     if *x < 10 {\n         let y = &x;\n@@ -425,43 +427,43 @@ References just borrow ownership, which is more polite if you don't need the\n ownership. In other words, prefer:\n \n ```{rust}\n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n ```\n \n to\n \n ```{rust}\n-fn succ(x: Box<int>) -> int { *x + 1 }\n+fn succ(x: Box<i32>) -> i32 { *x + 1 }\n ```\n \n As a corollary to that rule, references allow you to accept a wide variety of\n other pointers, and so are useful so that you don't have to write a number\n of variants per pointer. In other words, prefer:\n \n ```{rust}\n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n ```\n \n to\n \n ```{rust}\n use std::rc::Rc;\n \n-fn box_succ(x: Box<int>) -> int { *x + 1 }\n+fn box_succ(x: Box<i32>) -> i32 { *x + 1 }\n \n-fn rc_succ(x: Rc<int>) -> int { *x + 1 }\n+fn rc_succ(x: Rc<i32>) -> i32 { *x + 1 }\n ```\n \n Note that the caller of your function will have to modify their calls slightly:\n \n ```{rust}\n use std::rc::Rc;\n \n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n \n-let ref_x = &5i;\n-let box_x = Box::new(5i);\n-let rc_x  = Rc::new(5i);\n+let ref_x = &5;\n+let box_x = Box::new(5);\n+let rc_x = Rc::new(5);\n \n succ(ref_x);\n succ(&*box_x);\n@@ -477,15 +479,15 @@ those contents.\n heap allocation in Rust. Creating a box looks like this:\n \n ```{rust}\n-let x = Box::new(5i);\n+let x = Box::new(5);\n ```\n \n Boxes are heap allocated and they are deallocated automatically by Rust when\n they go out of scope:\n \n ```{rust}\n {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     // stuff happens\n \n@@ -505,7 +507,7 @@ boxes, though. As a rough approximation, you can treat this Rust code:\n \n ```{rust}\n {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     // stuff happens\n }\n@@ -544,12 +546,12 @@ for more detail on how lifetimes work.\n Using boxes and references together is very common. For example:\n \n ```{rust}\n-fn add_one(x: &int) -> int {\n+fn add_one(x: &i32) -> i32 {\n     *x + 1\n }\n \n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     println!(\"{}\", add_one(&*x));\n }\n@@ -561,12 +563,12 @@ function, and since it's only reading the value, allows it.\n We can borrow `x` multiple times, as long as it's not simultaneous:\n \n ```{rust}\n-fn add_one(x: &int) -> int {\n+fn add_one(x: &i32) -> i32 {\n     *x + 1\n }\n \n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     println!(\"{}\", add_one(&*x));\n     println!(\"{}\", add_one(&*x));\n@@ -577,12 +579,12 @@ fn main() {\n Or as long as it's not a mutable borrow. This will error:\n \n ```{rust,ignore}\n-fn add_one(x: &mut int) -> int {\n+fn add_one(x: &mut i32) -> i32 {\n     *x + 1\n }\n \n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     println!(\"{}\", add_one(&*x)); // error: cannot borrow immutable dereference\n                                   // of `&`-pointer as mutable\n@@ -610,7 +612,7 @@ enum List<T> {\n }\n \n fn main() {\n-    let list: List<int> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));\n+    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));\n     println!(\"{:?}\", list);\n }\n ```\n@@ -659,10 +661,10 @@ so as to avoid copying a large data structure. For example:\n \n ```{rust}\n struct BigStruct {\n-    one: int,\n-    two: int,\n+    one: i32,\n+    two: i32,\n     // etc\n-    one_hundred: int,\n+    one_hundred: i32,\n }\n \n fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n@@ -687,10 +689,10 @@ This is an antipattern in Rust. Instead, write this:\n \n ```{rust}\n struct BigStruct {\n-    one: int,\n-    two: int,\n+    one: i32,\n+    two: i32,\n     // etc\n-    one_hundred: int,\n+    one_hundred: i32,\n }\n \n fn foo(x: Box<BigStruct>) -> BigStruct {"}, {"sha": "7145139bba57e9296b380eb16d7cc0b7718c3637", "filename": "src/doc/trpl/standard-input.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -83,12 +83,12 @@ fn main() {\n \n     match x {\n         OptionalInt::Value(n) => println!(\"x is {}\", n),\n-        OptionalInt::Missing  => println!(\"x is missing!\"),\n+        OptionalInt::Missing => println!(\"x is missing!\"),\n     }\n \n     match y {\n         OptionalInt::Value(n) => println!(\"y is {}\", n),\n-        OptionalInt::Missing  => println!(\"y is missing!\"),\n+        OptionalInt::Missing => println!(\"y is missing!\"),\n     }\n }\n ```\n@@ -141,11 +141,11 @@ use std::io;\n fn main() {\n     println!(\"Type something!\");\n \n-                                                  // here, we'll show the types at each step\n+    // here, we'll show the types at each step\n \n-    let input = io::stdin()                       // std::io::stdio::StdinReader\n-                  .read_line()                    // IoResult<String>\n-                  .ok()                           // Option<String>\n+    let input = io::stdin() // std::io::stdio::StdinReader\n+                  .read_line() // IoResult<String>\n+                  .ok() // Option<String>\n                   .expect(\"Failed to read line\"); // String\n \n     println!(\"{}\", input);"}, {"sha": "1c93fd351b6e4c8483be675e4c2e3d7df73803c9", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% The Rust Testing Guide\n+% Testing\n \n > Program testing can be a very effective way to show the presence of bugs, but\n > it is hopelessly inadequate for showing their absence. \n@@ -512,7 +512,7 @@ use test::Bencher;\n #[bench]\n fn bench_xor_1000_ints(b: &mut Bencher) {\n     b.iter(|| {\n-        range(0u, 1000).fold(0, |old, new| old ^ new);\n+        range(0, 1000).fold(0, |old, new| old ^ new);\n     });\n }\n ```\n@@ -537,7 +537,7 @@ computation entirely. This could be done for the example above by adjusting the\n # impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n b.iter(|| {\n     // note lack of `;` (could also use an explicit `return`).\n-    range(0u, 1000).fold(0, |old, new| old ^ new)\n+    range(0, 1000).fold(0, |old, new| old ^ new)\n });\n ```\n "}, {"sha": "1bad09b4b6e55442be4d5aa2fd14c1e4227f4ec7", "filename": "src/doc/trpl/threads.md", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fthreads.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fthreads.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthreads.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -51,13 +51,15 @@ closure is limited to capturing `Send`-able data from its environment\n ensures that `spawn` can safely move the entire closure and all its\n associated state into an entirely different thread for execution.\n \n-```{rust,ignore}\n-# use std::thread::spawn;\n-# fn generate_thread_number() -> int { 0 }\n+```rust\n+use std::thread::Thread;\n+\n+fn generate_thread_number() -> i32 { 4 } // a very simple generation\n+\n // Generate some state locally\n let child_thread_number = generate_thread_number();\n \n-spawn(move || {\n+Thread::spawn(move || {\n     // Capture it in the remote thread. The `move` keyword indicates\n     // that this closure should move `child_thread_number` into its\n     // environment, rather than capturing a reference into the\n@@ -77,40 +79,44 @@ The simplest way to create a channel is to use the `channel` function to create\n of a channel, and a *receiver* is the receiving endpoint. Consider the following\n example of calculating two results concurrently:\n \n-```{rust,ignore}\n-# use std::thread::spawn;\n+```rust\n+use std::thread::Thread;\n+use std::sync::mpsc;\n \n-let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n+let (tx, rx): (mpsc::Sender<u32>, mpsc::Receiver<u32>) = mpsc::channel();\n \n-spawn(move || {\n+Thread::spawn(move || {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n \n some_other_expensive_computation();\n let result = rx.recv();\n-# fn some_expensive_computation() -> int { 42 }\n-# fn some_other_expensive_computation() {}\n+\n+fn some_expensive_computation() -> u32 { 42 } // very expensive ;)\n+fn some_other_expensive_computation() {}      // even more so\n ```\n \n Let's examine this example in detail. First, the `let` statement creates a\n stream for sending and receiving integers (the left-hand side of the `let`,\n `(tx, rx)`, is an example of a destructuring let: the pattern separates a tuple\n into its component parts).\n \n-```{rust,ignore}\n-let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n+```rust\n+# use std::sync::mpsc;\n+let (tx, rx): (mpsc::Sender<u32>, mpsc::Receiver<u32>) = mpsc::channel();\n ```\n \n The child thread will use the sender to send data to the parent thread, which will\n wait to receive the data on the receiver. The next statement spawns the child\n thread.\n \n-```{rust,ignore}\n-# use std::thread::spawn;\n-# fn some_expensive_computation() -> int { 42 }\n-# let (tx, rx) = channel();\n-spawn(move || {\n+```rust\n+# use std::thread::Thread;\n+# use std::sync::mpsc;\n+# fn some_expensive_computation() -> u32 { 42 }\n+# let (tx, rx) = mpsc::channel();\n+Thread::spawn(move || {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n@@ -125,9 +131,10 @@ computation, then sends the result over the captured channel.\n Finally, the parent continues with some other expensive computation, then waits\n for the child's result to arrive on the receiver:\n \n-```{rust,ignore}\n+```rust\n+# use std::sync::mpsc;\n # fn some_other_expensive_computation() {}\n-# let (tx, rx) = channel::<int>();\n+# let (tx, rx) = mpsc::channel::<u32>();\n # tx.send(0);\n some_other_expensive_computation();\n let result = rx.recv();\n@@ -140,8 +147,9 @@ single `Receiver` value.  What if our example needed to compute multiple\n results across a number of threads? The following program is ill-typed:\n \n ```{rust,ignore}\n-# fn some_expensive_computation() -> int { 42 }\n-let (tx, rx) = channel();\n+# use std::sync::mpsc;\n+# fn some_expensive_computation() -> u32 { 42 }\n+let (tx, rx) = mpsc::channel();\n \n spawn(move || {\n     tx.send(some_expensive_computation());\n@@ -156,19 +164,22 @@ spawn(move || {\n \n Instead we can clone the `tx`, which allows for multiple senders.\n \n-```{rust,ignore}\n-let (tx, rx) = channel();\n+```rust\n+use std::thread::Thread;\n+use std::sync::mpsc;\n+\n+let (tx, rx) = mpsc::channel();\n \n-for init_val in range(0u, 3) {\n+for init_val in 0 .. 3 {\n     // Create a new channel handle to distribute to the child thread\n     let child_tx = tx.clone();\n-    spawn(move || {\n+    Thread::spawn(move || {\n         child_tx.send(some_expensive_computation(init_val));\n     });\n }\n \n-let result = rx.recv() + rx.recv() + rx.recv();\n-# fn some_expensive_computation(_i: uint) -> int { 42 }\n+let result = rx.recv().unwrap() + rx.recv().unwrap() + rx.recv().unwrap();\n+# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n ```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n@@ -181,21 +192,22 @@ Note that the above cloning example is somewhat contrived since you could also\n simply use three `Sender` pairs, but it serves to illustrate the point. For\n reference, written with multiple streams, it might look like the example below.\n \n-```{rust,ignore}\n-# use std::thread::spawn;\n+```rust\n+use std::thread::Thread;\n+use std::sync::mpsc;\n \n // Create a vector of ports, one for each child thread\n-let rxs = Vec::from_fn(3, |init_val| {\n-    let (tx, rx) = channel();\n-    spawn(move || {\n+let rxs = (0 .. 3).map(|&:init_val| {\n+    let (tx, rx) = mpsc::channel();\n+    Thread::spawn(move || {\n         tx.send(some_expensive_computation(init_val));\n     });\n     rx\n-});\n+}).collect::<Vec<_>>();\n \n // Wait on each port, accumulating the results\n-let result = rxs.iter().fold(0, |accum, rx| accum + rx.recv() );\n-# fn some_expensive_computation(_i: uint) -> int { 42 }\n+let result = rxs.iter().fold(0, |&:accum, rx| accum + rx.recv().unwrap() );\n+# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n ```\n \n ## Backgrounding computations: Futures\n@@ -212,7 +224,7 @@ use std::sync::Future;\n # fn main() {\n # fn make_a_sandwich() {};\n fn fib(n: u64) -> u64 {\n-    // lengthy computation returning an uint\n+    // lengthy computation returning an 64\n     12586269025\n }\n \n@@ -237,7 +249,7 @@ computations. The workload will be distributed on the available cores.\n # #![allow(deprecated)]\n # use std::num::Float;\n # use std::sync::Future;\n-fn partial_sum(start: uint) -> f64 {\n+fn partial_sum(start: u64) -> f64 {\n     let mut local_sum = 0f64;\n     for num in range(start*100000, (start+1)*100000) {\n         local_sum += (num as f64 + 1.0).powf(-2.0);\n@@ -277,15 +289,15 @@ use std::num::Float;\n use std::rand;\n use std::sync::Arc;\n \n-fn pnorm(nums: &[f64], p: uint) -> f64 {\n+fn pnorm(nums: &[f64], p: u64) -> f64 {\n     nums.iter().fold(0.0, |a, b| a + b.powf(p as f64)).powf(1.0 / (p as f64))\n }\n \n fn main() {\n     let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n     let numbers_arc = Arc::new(numbers);\n \n-    for num in range(1u, 10) {\n+    for num in range(1, 10) {\n         let thread_numbers = numbers_arc.clone();\n \n         spawn(move || {\n@@ -316,7 +328,7 @@ if it were local.\n ```{rust,ignore}\n # use std::rand;\n # use std::sync::Arc;\n-# fn pnorm(nums: &[f64], p: uint) -> f64 { 4.0 }\n+# fn pnorm(nums: &[f64], p: u64) -> f64 { 4.0 }\n # fn main() {\n # let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n@@ -345,16 +357,16 @@ each other if they panic. The simplest way of handling a panic is with the\n `try` function, which is similar to `spawn`, but immediately blocks and waits\n for the child thread to finish. `try` returns a value of type\n `Result<T, Box<Any + Send>>`. `Result` is an `enum` type with two variants:\n-`Ok` and `Err`. In this case, because the type arguments to `Result` are `int`\n+`Ok` and `Err`. In this case, because the type arguments to `Result` are `i32`\n and `()`, callers can pattern-match on a result to check whether it's an `Ok`\n-result with an `int` field (representing a successful result) or an `Err` result\n+result with an `i32` field (representing a successful result) or an `Err` result\n (representing termination with an error).\n \n ```{rust,ignore}\n # use std::thread::Thread;\n # fn some_condition() -> bool { false }\n-# fn calculate_result() -> int { 0 }\n-let result: Result<int, Box<std::any::Any + Send>> = Thread::spawn(move || {\n+# fn calculate_result() -> i32 { 0 }\n+let result: Result<i32, Box<std::any::Any + Send>> = Thread::spawn(move || {\n     if some_condition() {\n         calculate_result()\n     } else {"}, {"sha": "d12480d7dd9fa9339c6912a6e02abab81531db2d", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -145,7 +145,7 @@ As you can see, `print_area` is now generic, but also ensures that we\n have passed in the correct types. If we pass in an incorrect type:\n \n ```{rust,ignore}\n-print_area(5i);\n+print_area(5);\n ```\n \n We get a compile-time error:\n@@ -156,22 +156,22 @@ error: failed to find an implementation of trait main::HasArea for int\n \n So far, we've only added trait implementations to structs, but you can\n implement a trait for any type. So technically, we _could_ implement\n-`HasArea` for `int`:\n+`HasArea` for `i32`:\n \n ```{rust}\n trait HasArea {\n     fn area(&self) -> f64;\n }\n \n-impl HasArea for int {\n+impl HasArea for i32 {\n     fn area(&self) -> f64 {\n         println!(\"this is silly\");\n \n         *self as f64\n     }\n }\n \n-5i.area();\n+5.area();\n ```\n \n It is considered poor style to implement methods on such primitive types, even\n@@ -264,8 +264,8 @@ it won't affect you, unless you `use` that trait.\n \n There's one more restriction on implementing traits. Either the trait or the\n type you're writing the `impl` for must be inside your crate. So, we could\n-implement the `HasArea` type for `int`, because `HasArea` is in our crate.  But\n-if we tried to implement `Float`, a trait provided by Rust, for `int`, we could\n+implement the `HasArea` type for `i32`, because `HasArea` is in our crate.  But\n+if we tried to implement `Float`, a trait provided by Rust, for `i32`, we could\n not, because both the trait and the type aren't in our crate.\n \n One last thing about traits: generic functions with a trait bound use"}, {"sha": "de6d311be57edc1149c3ff96019954942888fd22", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% Writing Unsafe and Low-Level Code in Rust\n+% Unsafe and Low-Level Code\n \n # Introduction\n \n@@ -95,7 +95,7 @@ offered by the Rust language and libraries. For example, they\n   use-after-free;\n - are considered sendable (if their contents is considered sendable),\n   so the compiler offers no assistance with ensuring their use is\n-  thread-safe; for example, one can concurrently access a `*mut int`\n+  thread-safe; for example, one can concurrently access a `*mut i32`\n   from two threads without synchronization.\n - lack any form of lifetimes, unlike `&`, and so the compiler cannot\n   reason about dangling pointers; and\n@@ -265,12 +265,12 @@ impl<T: Send> Drop for Unique<T> {\n // A comparison between the built-in `Box` and this reimplementation\n fn main() {\n     {\n-        let mut x = Box::new(5i);\n+        let mut x = Box::new(5);\n         *x = 10;\n     } // `x` is freed here\n \n     {\n-        let mut y = Unique::new(5i);\n+        let mut y = Unique::new(5);\n         *y.borrow_mut() = 10;\n     } // `y` is freed here\n }\n@@ -367,7 +367,7 @@ expressions must be mutable lvalues:\n ```\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn add(a: int, b: int) -> int {\n+fn add(a: i32, b: i32) -> i32 {\n     let mut c = 0;\n     unsafe {\n         asm!(\"add $2, $0\"\n@@ -378,7 +378,7 @@ fn add(a: int, b: int) -> int {\n     c\n }\n # #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn add(a: int, b: int) -> int { a + b }\n+# fn add(a: i32, b: i32) -> i32 { a + b }\n \n fn main() {\n     assert_eq!(add(3, 14159), 14162)\n@@ -454,7 +454,7 @@ extern crate libc;\n \n // Entry point for this program\n #[start]\n-fn start(_argc: int, _argv: *const *const u8) -> int {\n+fn start(_argc: isize, _argv: *const *const u8) -> isize {\n     0\n }\n \n@@ -480,7 +480,7 @@ compiler's name mangling too:\n extern crate libc;\n \n #[no_mangle] // ensure that this symbol is called `main` in the output\n-pub extern fn main(argc: int, argv: *const *const u8) -> int {\n+pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n     0\n }\n \n@@ -552,8 +552,8 @@ pub extern fn dot_product(a: *const u32, a_len: u32,\n     // cannot tell the pointers are valid.\n     let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {\n         mem::transmute((\n-            Slice { data: a, len: a_len as uint },\n-            Slice { data: b, len: b_len as uint },\n+            Slice { data: a, len: a_len as usize },\n+            Slice { data: b, len: b_len as usize },\n         ))\n     };\n \n@@ -567,14 +567,14 @@ pub extern fn dot_product(a: *const u32, a_len: u32,\n \n #[lang = \"panic_fmt\"]\n extern fn panic_fmt(args: &core::fmt::Arguments,\n-                       file: &str,\n-                       line: uint) -> ! {\n+                    file: &str,\n+                    line: u32) -> ! {\n     loop {}\n }\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-# #[start] fn start(argc: int, argv: *const *const u8) -> int { 0 }\n+# #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n # fn main() {}\n ```\n \n@@ -628,7 +628,7 @@ via a declaration like\n extern \"rust-intrinsic\" {\n     fn transmute<T, U>(x: T) -> U;\n \n-    fn offset<T>(dst: *const T, offset: int) -> *const T;\n+    fn offset<T>(dst: *const T, offset: isize) -> *const T;\n }\n ```\n \n@@ -665,24 +665,24 @@ extern {\n pub struct Box<T>(*mut T);\n \n #[lang=\"exchange_malloc\"]\n-unsafe fn allocate(size: uint, _align: uint) -> *mut u8 {\n+unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     let p = libc::malloc(size as libc::size_t) as *mut u8;\n \n     // malloc failed\n-    if p as uint == 0 {\n+    if p as usize == 0 {\n         abort();\n     }\n \n     p\n }\n #[lang=\"exchange_free\"]\n-unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n+unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n     libc::free(ptr as *mut libc::c_void)\n }\n \n #[start]\n-fn main(argc: int, argv: *const *const u8) -> int {\n-    let x = box 1i;\n+fn main(argc: isize, argv: *const *const u8) -> isize {\n+    let x = box 1;\n \n     0\n }"}, {"sha": "41c0e9de9b5056092058f7b7ffcfa9096f19d2ed", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -1,4 +1,4 @@\n-% Variable bindings\n+% Variable Bindings\n \n The first thing we'll learn about are *variable bindings*. They look like this:\n "}, {"sha": "efd056b0d66a51ccd51aecbe9a8b5768a234324c", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -156,7 +156,7 @@ static FALSE: bool = false;\n /// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[stable]\n+#[unstable = \"RFC 509\"]\n pub struct Bitv {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n@@ -1107,7 +1107,7 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n-#[stable]\n+#[unstable = \"RFC 509\"]\n pub struct BitvSet {\n     bitv: Bitv,\n }"}, {"sha": "e222373ff59800ba0afee5a7f1bab94aba13458d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -70,12 +70,12 @@ pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n-#[stable]\n+#[unstable = \"RFC 509\"]\n pub mod bitv {\n     pub use bit::{Bitv, Iter};\n }\n \n-#[stable]\n+#[unstable = \"RFC 509\"]\n pub mod bitv_set {\n     pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;"}, {"sha": "963cb48db0701115347e6fb0dc29d6356e7187f5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -115,7 +115,6 @@\n //!     }\n //! #   fn calc_span_tree(&self) -> Vec<(uint, uint)> { vec![] }\n //! }\n-//! # fn main() { }\n //! ```\n //!\n //! ## Mutating implementations of `clone`"}, {"sha": "ed3612bded05e93e08458bf2afc2a03b76c06e87", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -23,13 +23,11 @@\n //!\n //! use std::finally::Finally;\n //!\n-//! # fn main() {\n //! (|&mut:| {\n //!     // ...\n //! }).finally(|| {\n //!     // this code is always run\n //! })\n-//! # }\n //! ```\n \n #![deprecated = \"It is unclear if this module is more robust than implementing \\"}, {"sha": "1c37126e8e9020b3b281405a52e09d4978e28045", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -39,13 +39,16 @@ macro_rules! panic {\n /// // the panic message for these assertions is the stringified value of the\n /// // expression given.\n /// assert!(true);\n-/// # fn some_computation() -> bool { true }\n+///\n+/// fn some_computation() -> bool { true } // a very simple function\n+///\n /// assert!(some_computation());\n ///\n /// // assert with a custom message\n-/// # let x = true;\n+/// let x = true;\n /// assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n+///\n+/// let a = 3i; let b = 27i;\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n@@ -108,13 +111,15 @@ macro_rules! assert_eq {\n /// // the panic message for these assertions is the stringified value of the\n /// // expression given.\n /// debug_assert!(true);\n-/// # fn some_expensive_computation() -> bool { true }\n+///\n+/// fn some_expensive_computation() -> bool { true } // a very simple function\n /// debug_assert!(some_expensive_computation());\n ///\n /// // assert with a custom message\n-/// # let x = true;\n+/// let x = true;\n /// debug_assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n+///\n+/// let a = 3; let b = 27;\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]"}, {"sha": "99ba9666cd2963157fb52ee4be2c28c0a466eefd", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -42,6 +42,104 @@ pub trait Sized {\n }\n \n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n+///\n+/// By default, variable bindings have 'move semantics.' In other\n+/// words:\n+///\n+/// ```\n+/// #[derive(Show)]\n+/// struct Foo;\n+///\n+/// let x = Foo;\n+///\n+/// let y = x;\n+///\n+/// // `x` has moved into `y`, and so cannot be used\n+///\n+/// // println!(\"{:?}\", x); // error: use of moved value\n+/// ```\n+///\n+/// However, if a type implements `Copy`, it instead has 'copy semantics':\n+///\n+/// ```\n+/// // we can just derive a `Copy` implementation\n+/// #[derive(Show, Copy)]\n+/// struct Foo;\n+///\n+/// let x = Foo;\n+///\n+/// let y = x;\n+///\n+/// // `y` is a copy of `x`\n+///\n+/// println!(\"{:?}\", x); // A-OK!\n+/// ```\n+///\n+/// It's important to note that in these two examples, the only difference is if you are allowed to\n+/// access `x` after the assignment: a move is also a bitwise copy under the hood.\n+///\n+/// ## When can my type be `Copy`?\n+///\n+/// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n+/// `struct` can be `Copy`:\n+///\n+/// ```\n+/// struct Point {\n+///    x: i32,\n+///    y: i32,\n+/// }\n+/// ```\n+///\n+/// A `struct` can be `Copy`, and `i32` is `Copy`, so therefore, `Point` is eligible to be `Copy`.\n+///\n+/// ```\n+/// # struct Point;\n+/// struct PointList {\n+///     points: Vec<Point>,\n+/// }\n+/// ```\n+///\n+/// The `PointList` `struct` cannot implement `Copy`, because `Vec<T>` is not `Copy`. If we\n+/// attempt to derive a `Copy` implementation, we'll get an error.\n+///\n+/// ```text\n+/// error: the trait `Copy` may not be implemented for this type; field `points` does not implement\n+/// `Copy`\n+/// ```\n+///\n+/// ## How can I implement `Copy`?\n+///\n+/// There are two ways to implement `Copy` on your type:\n+///\n+/// ```\n+/// #[derive(Copy)]\n+/// struct MyStruct;\n+/// ```\n+///\n+/// and\n+///\n+/// ```\n+/// struct MyStruct;\n+/// impl Copy for MyStruct {}\n+/// ```\n+///\n+/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n+/// bound on type parameters, which isn't always desired.\n+///\n+/// ## When can my type _not_ be `Copy`?\n+///\n+/// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n+/// mutable reference, and copying `String` would result in two attempts to free the same buffer.\n+///\n+/// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n+/// managing some resource besides its own `size_of::<T>()` bytes.\n+///\n+/// ## When should my type be `Copy`?\n+///\n+/// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing\n+/// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n+/// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n+/// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n #[stable]\n #[lang=\"copy\"]\n pub trait Copy {\n@@ -210,8 +308,7 @@ impl<T: ?Sized> Clone for ContravariantType<T> {\n /// \"interior\" mutability:\n ///\n /// ```\n-/// pub struct Cell<T> { value: T }\n-/// # fn main() {}\n+/// struct Cell<T> { value: T }\n /// ```\n ///\n /// The type system would infer that `value` is only read here and"}, {"sha": "7d41c3fc5a56f45e2a0dbef004b0ead22e497d71", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -830,28 +830,27 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n ///\n /// # Example\n ///\n-/// A trivial implementation of `Index`. When `Foo[Foo]` happens, it ends up\n+/// A trivial implementation of `Index`. When `Foo[Bar]` happens, it ends up\n /// calling `index`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Index;\n ///\n /// #[derive(Copy)]\n /// struct Foo;\n+/// struct Bar;\n ///\n-/// impl Index<Foo> for Foo {\n+/// impl Index<Bar> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index<'a>(&'a self, _index: &Foo) -> &'a Foo {\n+///     fn index<'a>(&'a self, _index: &Bar) -> &'a Foo {\n ///         println!(\"Indexing!\");\n ///         self\n ///     }\n /// }\n ///\n /// fn main() {\n-///     Foo[Foo];\n+///     Foo[Bar];\n /// }\n /// ```\n #[lang=\"index\"]\n@@ -867,28 +866,27 @@ pub trait Index<Index: ?Sized> {\n ///\n /// # Example\n ///\n-/// A trivial implementation of `IndexMut`. When `Foo[Foo]` happens, it ends up\n+/// A trivial implementation of `IndexMut`. When `Foo[Bar]` happens, it ends up\n /// calling `index_mut`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::IndexMut;\n ///\n /// #[derive(Copy)]\n /// struct Foo;\n+/// struct Bar;\n ///\n-/// impl IndexMut<Foo> for Foo {\n+/// impl IndexMut<Bar> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index_mut<'a>(&'a mut self, _index: &Foo) -> &'a mut Foo {\n+///     fn index_mut<'a>(&'a mut self, _index: &Bar) -> &'a mut Foo {\n ///         println!(\"Indexing!\");\n ///         self\n ///     }\n /// }\n ///\n /// fn main() {\n-///     &mut Foo[Foo];\n+///     &mut Foo[Bar];\n /// }\n /// ```\n #[lang=\"index_mut\"]"}, {"sha": "da3f180d7e127d02d20f16af611572997efc77cb", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -21,11 +21,7 @@\n //! # Example\n //!\n //! ```ignore\n-//! # fn main() {\n-//! #![feature(globs)]\n-//!\n //! use core::prelude::*;\n-//! # }\n //! ```\n \n // Reexported core operators"}, {"sha": "1ab810f937de9a8c715d2e838a6f0ddc543c061a", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -217,11 +217,9 @@\n //! makes it clear:\n //!\n //! ```\n-//! # #![feature(macro_rules)]\n //! macro_rules! try {\n //!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n //! }\n-//! # fn main() { }\n //! ```\n //!\n //! `try!` is imported by the prelude, and is available everywhere."}, {"sha": "7fb609b4c9450fd486beee123e67cb7a6f2922b0", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -4168,6 +4168,27 @@ pub mod funcs {\n                 pub fn malloc(size: size_t) -> *mut c_void;\n                 pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n                 pub fn free(p: *mut c_void);\n+\n+                /// Exits the running program in a possibly dangerous manner.\n+                ///\n+                /// # Unsafety\n+                ///\n+                /// While this forces your program to exit, it does so in a way that has\n+                /// consequences. This will skip all unwinding code, which means that anything\n+                /// relying on unwinding for cleanup (such as flushing and closing a buffer to a\n+                /// file) may act in an unexpected way.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```no_run\n+                /// extern crate libc;\n+                ///\n+                /// fn main() {\n+                ///     unsafe {\n+                ///         libc::exit(1);\n+                ///     }\n+                /// }\n+                /// ```\n                 pub fn exit(status: c_int) -> !;\n                 pub fn _exit(status: c_int) -> !;\n                 pub fn atexit(cb: extern fn()) -> c_int;"}, {"sha": "a283fdf36a96bdfd564443dcd94d839321d005ac", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -44,6 +44,7 @@ extern crate rbml;\n extern crate collections;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+#[macro_use] #[no_link] extern crate rustc_bitflags;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n "}, {"sha": "c47a525552ded384bb9db0ae8276c152cbff1866", "filename": "src/librustc_bitflags/lib.rs", "status": "renamed", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -8,10 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![crate_name = \"rustc_bitflags\"]\n #![unstable]\n+#![staged_api]\n+#![crate_type = \"rlib\"]\n+#![no_std]\n \n //! A typesafe bitmask flag generator.\n \n+#[cfg(test)] #[macro_use] extern crate std;\n+\n /// The `bitflags!` macro generates a `struct` that holds a set of C-style\n /// bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n ///\n@@ -21,6 +27,8 @@\n /// # Example\n ///\n /// ```{.rust}\n+/// #[macro_use] extern crate rustc_bitflags;\n+///\n /// bitflags! {\n ///     flags Flags: u32 {\n ///         const FLAG_A       = 0b00000001,\n@@ -45,6 +53,8 @@\n /// The generated `struct`s can also be extended with type and trait implementations:\n ///\n /// ```{.rust}\n+/// #[macro_use] extern crate rustc_bitflags;\n+///\n /// use std::fmt;\n ///\n /// bitflags! {\n@@ -273,8 +283,8 @@ macro_rules! bitflags {\n #[cfg(test)]\n #[allow(non_upper_case_globals)]\n mod tests {\n-    use hash::{self, SipHasher};\n-    use option::Option::{Some, None};\n+    use std::hash::{self, SipHasher};\n+    use std::option::Option::{Some, None};\n \n     bitflags! {\n         #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]", "previous_filename": "src/libstd/bitflags.rs"}, {"sha": "59676fa3504a912c984ef678e7538051e0b040b3", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -28,6 +28,7 @@\n #![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate libc;\n+#[macro_use] #[no_link] extern crate rustc_bitflags;\n \n pub use self::OtherAttribute::*;\n pub use self::SpecialAttribute::*;"}, {"sha": "22064a35058ecf4544c9e3915abae717d23dfebd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -23,6 +23,7 @@\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+#[macro_use] #[no_link] extern crate rustc_bitflags;\n \n extern crate rustc;\n "}, {"sha": "36afa0956d2deb7cc77773847dcb1726cf9d203e", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -26,15 +26,13 @@\n //!\n //! Some examples of the `format!` extension are:\n //!\n-//! ```rust\n-//! # fn main() {\n+//! ```\n //! format!(\"Hello\");                  // => \"Hello\"\n //! format!(\"Hello, {}!\", \"world\");    // => \"Hello, world!\"\n //! format!(\"The number is {}\", 1i);   // => \"The number is 1\"\n //! format!(\"{:?}\", (3i, 4i));         // => \"(3i, 4i)\"\n //! format!(\"{value}\", value=4i);      // => \"4\"\n //! format!(\"{} {}\", 1i, 2u);          // => \"1 2\"\n-//! # }\n //! ```\n //!\n //! From these, you can see that the first argument is a format string. It is\n@@ -83,12 +81,10 @@\n //!\n //! For example, the following `format!` expressions all use named argument:\n //!\n-//! ```rust\n-//! # fn main() {\n+//! ```\n //! format!(\"{argument}\", argument = \"test\");   // => \"test\"\n //! format!(\"{name} {}\", 1i, name = 2i);        // => \"2 1\"\n //! format!(\"{a} {c} {b}\", a=\"a\", b='b', c=3i);  // => \"a 3 b\"\n-//! # }\n //! ```\n //!\n //! It is illegal to put positional parameters (those without names) after\n@@ -288,8 +284,6 @@\n //! use std::fmt;\n //! use std::io;\n //!\n-//! # #[allow(unused_must_use)]\n-//! # fn main() {\n //! fmt::format(format_args!(\"this returns {}\", \"String\"));\n //!\n //! let some_writer: &mut io::Writer = &mut io::stdout();\n@@ -299,7 +293,6 @@\n //!     write!(&mut io::stdout(), \"{}\", args);\n //! }\n //! my_fmt_fn(format_args!(\"or a {} too\", \"function\"));\n-//! # }\n //! ```\n //!\n //! The result of the `format_args!` macro is a value of type `fmt::Arguments`."}, {"sha": "e2b71cd43af25e2eedc146755b19d0b9597190db", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -934,16 +934,15 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// A `RefReader` is a struct implementing `Reader` which contains a reference\n /// to another reader. This is often useful when composing streams.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n-/// # fn main() {}\n-/// # fn process_input<R: Reader>(r: R) {}\n-/// # fn foo() {\n /// use std::io;\n /// use std::io::ByRefReader;\n /// use std::io::util::LimitReader;\n ///\n+/// fn process_input<R: Reader>(r: R) {}\n+///\n /// let mut stream = io::stdin();\n ///\n /// // Only allow the function to process at most one kilobyte of input\n@@ -953,8 +952,6 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// }\n ///\n /// // 'stream' is still available for use here\n-///\n-/// # }\n /// ```\n pub struct RefReader<'a, R:'a> {\n     /// The underlying reader which this is referencing\n@@ -1269,12 +1266,11 @@ impl<'a> Writer for &'a mut (Writer+'a) {\n /// # Example\n ///\n /// ```\n-/// # fn main() {}\n-/// # fn process_input<R: Reader>(r: R) {}\n-/// # fn foo () {\n /// use std::io::util::TeeReader;\n /// use std::io::{stdin, ByRefWriter};\n ///\n+/// fn process_input<R: Reader>(r: R) {}\n+///\n /// let mut output = Vec::new();\n ///\n /// {\n@@ -1285,7 +1281,6 @@ impl<'a> Writer for &'a mut (Writer+'a) {\n /// }\n ///\n /// println!(\"input processed: {:?}\", output);\n-/// # }\n /// ```\n pub struct RefWriter<'a, W:'a> {\n     /// The underlying writer which this is referencing\n@@ -1705,19 +1700,19 @@ pub enum FileType {\n /// A structure used to describe metadata information about a file. This\n /// structure is created through the `stat` method on a `Path`.\n ///\n-/// # Example\n+/// # Examples\n+///\n+/// ```no_run\n+/// # #![allow(unstable)]\n+///\n+/// use std::io::fs::PathExtensions;\n ///\n-/// ```\n-/// # use std::io::fs::PathExtensions;\n-/// # fn main() {}\n-/// # fn foo() {\n /// let info = match Path::new(\"foo.txt\").stat() {\n ///     Ok(stat) => stat,\n ///     Err(e) => panic!(\"couldn't read foo.txt: {}\", e),\n /// };\n ///\n /// println!(\"byte size: {}\", info.size);\n-/// # }\n /// ```\n #[derive(Copy, Hash)]\n pub struct FileStat {"}, {"sha": "61d164d21e320769f8e65fbf610ff104369636de", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -168,9 +168,7 @@ impl UnixListener {\n     /// # Example\n     ///\n     /// ```\n-    /// # fn main() {}\n     /// # fn foo() {\n-    /// # #![allow(unused_must_use)]\n     /// use std::io::net::pipe::UnixListener;\n     /// use std::io::{Listener, Acceptor};\n     ///"}, {"sha": "4978085fa4fbeacd4faa23c602308a3229d9d0a7", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -272,12 +272,10 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// A structure representing a socket server. This listener is used to create a\n /// `TcpAcceptor` which can be used to accept sockets on a local port.\n ///\n-/// # Example\n+/// # Examples\n ///\n-/// ```rust\n-/// # fn main() { }\n+/// ```\n /// # fn foo() {\n-/// # #![allow(dead_code)]\n /// use std::io::{TcpListener, TcpStream};\n /// use std::io::{Acceptor, Listener};\n /// use std::thread::Thread;"}, {"sha": "844a97dea2d50eacb54817873e8b5c30c373a37f", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -27,10 +27,9 @@ use sys::timer::Timer as TimerImp;\n /// period of time. Handles to this timer can also be created in the form of\n /// receivers which will receive notifications over time.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n-/// # fn main() {}\n /// # fn foo() {\n /// use std::io::Timer;\n /// use std::time::Duration;\n@@ -54,7 +53,6 @@ use sys::timer::Timer as TimerImp;\n /// the `io::timer` module.\n ///\n /// ```\n-/// # fn main() {}\n /// # fn foo() {\n /// use std::io::timer;\n /// use std::time::Duration;"}, {"sha": "2553bbdf52310b039cb2bf043a9b2f6d885b6410", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -111,7 +111,7 @@\n #![feature(box_syntax)]\n #![feature(old_impl_check)]\n #![feature(optin_builtin_traits)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(int_uint)]\n \n // Don't link to std. We are std.\n #![no_std]\n@@ -136,6 +136,8 @@ extern crate alloc;\n extern crate unicode;\n extern crate libc;\n \n+#[macro_use] #[no_link] extern crate rustc_bitflags;\n+\n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern crate \"std\" as realstd;\n #[cfg(test)] pub use realstd::marker;\n@@ -181,9 +183,6 @@ pub use unicode::char;\n #[macro_use]\n mod macros;\n \n-#[macro_use]\n-pub mod bitflags;\n-\n mod rtdeps;\n \n /* The Prelude. */"}, {"sha": "8a8d14c4f3aa98f11f6dd74bee1c17f44fe12dc4", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -122,16 +122,18 @@ macro_rules! try {\n /// receivers. It places no restrictions on the types of receivers given to\n /// this macro, this can be viewed as a heterogeneous select.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::thread::Thread;\n-/// use std::sync::mpsc::channel;\n+/// use std::sync::mpsc;\n+///\n+/// // two placeholder functions for now\n+/// fn long_running_task() {}\n+/// fn calculate_the_answer() -> u32 { 42 }\n ///\n-/// let (tx1, rx1) = channel();\n-/// let (tx2, rx2) = channel();\n-/// # fn long_running_task() {}\n-/// # fn calculate_the_answer() -> int { 42i }\n+/// let (tx1, rx1) = mpsc::channel();\n+/// let (tx2, rx2) = mpsc::channel();\n ///\n /// Thread::spawn(move|| { long_running_task(); tx1.send(()).unwrap(); });\n /// Thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n@@ -251,13 +253,13 @@ pub mod builtin {\n     /// statement or expression position, meaning this macro may be difficult to\n     /// use in some situations.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// #![feature(concat_idents)]\n     ///\n     /// # fn main() {\n-    /// fn foobar() -> int { 23 }\n+    /// fn foobar() -> u32 { 23 }\n     ///\n     /// let f = concat_idents!(foo, bar);\n     /// println!(\"{}\", f());"}, {"sha": "36bbc5ff5b423952685d0225b7a1c5ab5f94ce3e", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -11,14 +11,18 @@\n //! A type representing values that may be computed concurrently and operations\n //! for working with them.\n //!\n-//! # Example\n+//! # Examples\n //!\n-//! ```rust\n+//! ```\n //! use std::sync::Future;\n-//! # fn fib(n: uint) -> uint {42};\n-//! # fn make_a_sandwich() {};\n-//! let mut delayed_fib = Future::spawn(move|| { fib(5000) });\n-//! make_a_sandwich();\n+//!\n+//! // a fake, for now\n+//! fn fib(n: u32) -> u32 { 42 };\n+//!\n+//! let mut delayed_fib = Future::spawn(move || fib(5000));\n+//!\n+//! // do stuff...\n+//!\n //! println!(\"fib(5000) = {}\", delayed_fib.get())\n //! ```\n "}, {"sha": "096e96b003bb04b23453c2b923f9515390def13a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -35,6 +35,7 @@ extern crate serialize;\n extern crate term;\n extern crate libc;\n #[macro_use] extern crate log;\n+#[macro_use] #[no_link] extern crate rustc_bitflags;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n "}, {"sha": "ca17c898ec37cdf2e582b028cb79b4a18d6aa50b", "filename": "src/test/compile-fail/unsupported-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f10dba2975b51c2d2c92157018db3ac13d4d4a/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs?ref=f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "patch": "@@ -14,5 +14,5 @@\n extern crate libc;\n \n fn main() {\n-  println!(\"{}\", 1.0 as *libc::FILE); // Can't cast float to foreign.\n+  println!(\"{:?}\", 1.0 as *const libc::FILE); // Can't cast float to foreign.\n }"}]}