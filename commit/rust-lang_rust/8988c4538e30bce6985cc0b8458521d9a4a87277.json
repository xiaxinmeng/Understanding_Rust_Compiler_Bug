{"sha": "8988c4538e30bce6985cc0b8458521d9a4a87277", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ODhjNDUzOGUzMGJjZTY5ODVjYzBiODQ1ODUyMWQ5YTRhODcyNzc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-13T02:53:22Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-26T18:23:53Z"}, "message": "Refactor away `resolve_import_for_module`", "tree": {"sha": "a379bf284124e8f9c582671fcb1f371051fa4b96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a379bf284124e8f9c582671fcb1f371051fa4b96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8988c4538e30bce6985cc0b8458521d9a4a87277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8988c4538e30bce6985cc0b8458521d9a4a87277", "html_url": "https://github.com/rust-lang/rust/commit/8988c4538e30bce6985cc0b8458521d9a4a87277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8988c4538e30bce6985cc0b8458521d9a4a87277/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43dffc329402d99a93e224bba1a30f587c70dc7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/43dffc329402d99a93e224bba1a30f587c70dc7d", "html_url": "https://github.com/rust-lang/rust/commit/43dffc329402d99a93e224bba1a30f587c70dc7d"}], "stats": {"total": 30, "additions": 14, "deletions": 16}, "files": [{"sha": "b6fbfe174066f35f0a6615f2a68496aca07237f8", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8988c4538e30bce6985cc0b8458521d9a4a87277/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8988c4538e30bce6985cc0b8458521d9a4a87277/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8988c4538e30bce6985cc0b8458521d9a4a87277", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         ::std::mem::swap(&mut imports, &mut unresolved_imports);\n \n         for import_directive in imports {\n-            match self.resolve_import_for_module(&import_directive) {\n+            match self.resolve_import(&import_directive) {\n                 Failed(err) => {\n                     let (span, help) = match err {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n@@ -411,7 +411,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     });\n                 }\n                 Indeterminate => unresolved_imports.push(import_directive),\n-                Success(()) => {}\n+                Success(()) => {\n+                    // Decrement the count of unresolved imports.\n+                    assert!(self.resolver.unresolved_imports >= 1);\n+                    self.resolver.unresolved_imports -= 1;\n+                }\n             }\n         }\n     }\n@@ -421,25 +425,19 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// don't know whether the name exists at the moment due to other\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import_for_module(&mut self, directive: &'b ImportDirective) -> ResolveResult<()> {\n+    fn resolve_import(&mut self, directive: &'b ImportDirective) -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&directive.module_path),\n                module_to_string(self.resolver.current_module));\n \n-        self.resolver\n-            .resolve_module_path(&directive.module_path, DontUseLexicalScope, directive.span)\n-            // Once we have the module that contains the target, we can resolve the import.\n-            .and_then(|containing_module| self.resolve_import(containing_module, directive))\n-            .and_then(|()| {\n-                // Decrement the count of unresolved imports.\n-                assert!(self.resolver.unresolved_imports >= 1);\n-                self.resolver.unresolved_imports -= 1;\n-                Success(())\n-            })\n-    }\n+        let target_module = match self.resolver.resolve_module_path(&directive.module_path,\n+                                                                    DontUseLexicalScope,\n+                                                                    directive.span) {\n+            Success(module) => module,\n+            Indeterminate => return Indeterminate,\n+            Failed(err) => return Failed(err),\n+        };\n \n-    fn resolve_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective)\n-                      -> ResolveResult<()> {\n         let (source, target, value_determined, type_determined) = match directive.subclass {\n             SingleImport { source, target, ref value_determined, ref type_determined } =>\n                 (source, target, value_determined, type_determined),"}]}