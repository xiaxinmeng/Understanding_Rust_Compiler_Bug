{"sha": "032dfe43605f4324966933078ffe6f717b77c7c8", "node_id": "C_kwDOAAsO6NoAKDAzMmRmZTQzNjA1ZjQzMjQ5NjY5MzMwNzhmZmU2ZjcxN2I3N2M3Yzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-13T02:17:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-13T02:17:20Z"}, "message": "Auto merge of #89167 - workingjubilee:use-simd, r=MarkSimulacrum\n\npub use core::simd;\n\nA portable abstraction over SIMD has been a major pursuit in recent years for several programming languages. In Rust, `std::arch` offers explicit SIMD acceleration via compiler intrinsics, but it does so at the cost of having to individually maintain each and every single such API, and is almost completely `unsafe` to use.  `core::simd` offers safe abstractions that are resolved to the appropriate SIMD instructions by LLVM during compilation, including scalar instructions if that is all that is available.\n\n`core::simd` is enabled by the `#![portable_simd]` nightly feature tracked in https://github.com/rust-lang/rust/issues/86656 and is introduced here by pulling in the https://github.com/rust-lang/portable-simd repository as a subtree. We built the repository out-of-tree to allow faster compilation and a stochastic test suite backed by the proptest crate to verify that different targets, features, and optimizations produce the same result, so that using this library does not introduce any surprises. As these tests are technically non-deterministic, and thus can introduce overly interesting Heisenbugs if included in the rustc CI, they are visible in the commit history of the subtree but do nothing here. Some tests **are** introduced via the documentation, but these use deterministic asserts.\n\nThere are multiple unsolved problems with the library at the current moment, including a want for better documentation, technical issues with LLVM scalarizing and lowering to libm, room for improvement for the APIs, and so far I have not added the necessary plumbing for allowing the more experimental or libm-dependent APIs to be used. However, I thought it would be prudent to open this for review in its current condition, as it is both usable and it is likely I am going to learn something else needs to be fixed when bors tries this out.\n\nThe major types are\n- `core::simd::Simd<T, N>`\n- `core::simd::Mask<T, N>`\n\nThere is also the `LaneCount` struct, which, together with the SimdElement and SupportedLaneCount traits, limit the implementation's maximum support to vectors we know will actually compile and provide supporting logic for bitmasks. I'm hoping to simplify at least some of these out of the way as the compiler and library evolve.", "tree": {"sha": "ccd1d0a8cb3f7c183a4e22cb4e3c5d68709ac427", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccd1d0a8cb3f7c183a4e22cb4e3c5d68709ac427"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/032dfe43605f4324966933078ffe6f717b77c7c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/032dfe43605f4324966933078ffe6f717b77c7c8", "html_url": "https://github.com/rust-lang/rust/commit/032dfe43605f4324966933078ffe6f717b77c7c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/032dfe43605f4324966933078ffe6f717b77c7c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e90c5fbbc5df5c81267747daeb937d4e955ce6ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/e90c5fbbc5df5c81267747daeb937d4e955ce6ad", "html_url": "https://github.com/rust-lang/rust/commit/e90c5fbbc5df5c81267747daeb937d4e955ce6ad"}, {"sha": "7c3d72d069600c7826e44d26bf005eb28e91b169", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3d72d069600c7826e44d26bf005eb28e91b169", "html_url": "https://github.com/rust-lang/rust/commit/7c3d72d069600c7826e44d26bf005eb28e91b169"}], "stats": {"total": 7631, "additions": 7631, "deletions": 0}, "files": [{"sha": "e58ce8a883bde29514350f4e88409e8748b6b36b", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -392,4 +392,25 @@ pub mod arch {\n     }\n }\n \n+// Pull in the `core_simd` crate directly into libcore. The contents of\n+// `core_simd` are in a different repository: rust-lang/portable-simd.\n+//\n+// `core_simd` depends on libcore, but the contents of this module are\n+// set up in such a way that directly pulling it here works such that the\n+// crate uses this crate as its libcore.\n+#[path = \"../../portable-simd/crates/core_simd/src/mod.rs\"]\n+#[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n+#[allow(rustdoc::bare_urls)]\n+#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+#[cfg(not(bootstrap))]\n+mod core_simd;\n+\n+#[doc = include_str!(\"../../portable-simd/crates/core_simd/src/core_simd_docs.md\")]\n+#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+#[cfg(not(bootstrap))]\n+pub mod simd {\n+    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+    pub use crate::core_simd::simd::*;\n+}\n+\n include!(\"primitive_docs.rs\");"}, {"sha": "199842f0ab11d42f95b3f77db46c18b42cb910c0", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -60,6 +60,7 @@\n #![feature(never_type)]\n #![feature(unwrap_infallible)]\n #![feature(result_into_ok_or_err)]\n+#![cfg_attr(not(bootstrap), feature(portable_simd))]\n #![feature(ptr_metadata)]\n #![feature(once_cell)]\n #![feature(unsized_tuple_coercion)]\n@@ -105,6 +106,8 @@ mod pattern;\n mod pin;\n mod ptr;\n mod result;\n+#[cfg(not(bootstrap))]\n+mod simd;\n mod slice;\n mod str;\n mod str_lossy;"}, {"sha": "8c11d788c67ae0d94a6cb0030cdf392ea7d334d4", "filename": "library/core/tests/simd.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fcore%2Ftests%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fcore%2Ftests%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fsimd.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,13 @@\n+use core::simd::f32x4;\n+\n+#[test]\n+fn testing() {\n+    let x = f32x4::from_array([1.0, 1.0, 1.0, 1.0]);\n+    let y = -x;\n+\n+    let h = x * 0.5;\n+\n+    let r = y.abs();\n+    assert_eq!(x, r);\n+    assert_eq!(h, f32x4::splat(0.5));\n+}"}, {"sha": "9aef3ebe637a1d1b325266165389786032876f93", "filename": "library/portable-simd/.github/ISSUE_TEMPLATE/blank_issue.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,4 @@\n+---\n+name: Blank Issue\n+about: Create a blank issue.\n+---"}, {"sha": "16a8251d52ba9ee7e6203b5bfd7ce4d3983cc7fa", "filename": "library/portable-simd/.github/ISSUE_TEMPLATE/bug_report.md", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,50 @@\n+---\n+name: Bug Report\n+about: Create a bug report for Rust.\n+labels: C-bug\n+---\n+<!--\n+Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n+along with any information you feel relevant to replicating the bug.\n+-->\n+\n+I tried this code:\n+\n+```rust\n+<code>\n+```\n+\n+I expected to see this happen: *explanation*\n+\n+Instead, this happened: *explanation*\n+\n+### Meta\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+\n+`crate version in Cargo.toml`:\n+```toml\n+[dependencies]\n+stdsimd = \n+```\n+<!-- If this specifies the repo at HEAD, please include the latest commit. -->\n+\n+\n+<!--\n+If a backtrace is available, please include a backtrace in the code block by\n+setting `RUST_BACKTRACE=1` in your environment. e.g.\n+`RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary>Backtrace</summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>"}, {"sha": "1567542c01a4c1b7a33db0fcbd96106df86089f1", "filename": "library/portable-simd/.github/ISSUE_TEMPLATE/config.yml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fconfig.yml", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fconfig.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Fconfig.yml?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,10 @@\n+# This only controls whether a tiny, hard-to-find \"open a blank issue\" link appears at the end of\n+# the template list.\n+blank_issues_enabled: true\n+contact_links:\n+  - name: Intrinsic Support\n+    url: https://github.com/rust-lang/stdarch/issues\n+    about: Please direct issues about Rust's support for vendor intrinsics to core::arch\n+  - name: Internal Compiler Error\n+    url: https://github.com/rust-lang/rust/issues\n+    about: Please report ICEs to the rustc repository"}, {"sha": "be6c9e3d17e257ee6b910fb38d240962fb60fecb", "filename": "library/portable-simd/.github/ISSUE_TEMPLATE/feature_request.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Ffeature_request.md", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Ffeature_request.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2FISSUE_TEMPLATE%2Ffeature_request.md?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,14 @@\n+---\n+name: Feature Request\n+about: Request an addition to the core::simd API\n+labels: C-feature-request\n+---\n+<!--\n+  Hello!\n+\n+  We are very interested in any feature requests you may have.\n+\n+  However, please be aware that core::simd exists to address concerns with creating a portable SIMD API for Rust.\n+  Requests for extensions to compiler features, such as `target_feature`, binary versioning for SIMD APIs, or\n+  improving specific compilation issues in general should be discussed at https://internals.rust-lang.org/\n+-->"}, {"sha": "31422b7934501918bc904e6e4549d51a3549fa81", "filename": "library/portable-simd/.github/PULL_REQUEST_TEMPLATE.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FPULL_REQUEST_TEMPLATE.md", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2FPULL_REQUEST_TEMPLATE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2FPULL_REQUEST_TEMPLATE.md?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,18 @@\n+Hello, welcome to `std::simd`!\n+\n+It seems this pull request template checklist was created while a lot of vector math ops were being implemented, and only really applies to ops. Feel free to delete everything here if it's not applicable, or ask for help if you're not sure what it means!\n+\n+For a given vector math operation on TxN, please add tests for interactions with:\n+  - [ ] `T::MAX`\n+  - [ ] `T::MIN`\n+  - [ ] -1\n+  - [ ] 1\n+  - [ ] 0\n+\n+\n+For a given vector math operation on TxN where T is a float, please add tests for test interactions with:\n+  - [ ] a really large number, larger than the mantissa\n+  - [ ] a really small \"subnormal\" number\n+  - [ ] NaN\n+  - [ ] Infinity\n+  - [ ] Negative Infinity"}, {"sha": "d50dfa1be4cba292f65500132daaf6e05a394ca6", "filename": "library/portable-simd/.github/workflows/ci.yml", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,260 @@\n+name: CI\n+\n+on:\n+  pull_request:\n+  push:\n+    branches:\n+      - master\n+\n+env:\n+  CARGO_NET_RETRY: 10\n+  RUSTUP_MAX_RETRIES: 10\n+\n+jobs:\n+  rustfmt:\n+    name: \"rustfmt\"\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+      - uses: actions/checkout@v2\n+      - name: Setup Rust\n+        run: |\n+          rustup update nightly --no-self-update\n+          rustup default nightly\n+          rustup component add rustfmt\n+      - name: Run rustfmt\n+        run: cargo fmt --all -- --check\n+\n+  clippy:\n+    name: \"clippy on ${{ matrix.target }}\"\n+    runs-on: ubuntu-latest\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        target:\n+          # We shouldn't really have any OS-specific code, so think of this as a list of architectures\n+          - x86_64-unknown-linux-gnu\n+          - i686-unknown-linux-gnu\n+          - i586-unknown-linux-gnu\n+          - aarch64-unknown-linux-gnu\n+          - armv7-unknown-linux-gnueabihf\n+          - mips-unknown-linux-gnu\n+          - mips64-unknown-linux-gnuabi64\n+          - powerpc-unknown-linux-gnu\n+          - powerpc64-unknown-linux-gnu\n+          - riscv64gc-unknown-linux-gnu\n+          - s390x-unknown-linux-gnu\n+          - sparc64-unknown-linux-gnu\n+          - wasm32-unknown-unknown\n+\n+    steps:\n+      - uses: actions/checkout@v2\n+      - name: Setup Rust\n+        run: |\n+          rustup update nightly --no-self-update\n+          rustup default nightly\n+          rustup target add ${{ matrix.target }}\n+          rustup component add clippy\n+      - name: Run Clippy\n+        run: cargo clippy --all-targets --target ${{ matrix.target }}\n+\n+  x86-tests:\n+    name: \"${{ matrix.target_feature }} on ${{ matrix.target }}\"\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        target: [x86_64-pc-windows-msvc, i686-pc-windows-msvc, i586-pc-windows-msvc, x86_64-unknown-linux-gnu, x86_64-apple-darwin]\n+        # `default` means we use the default target config for the target,\n+        # `native` means we run with `-Ctarget-cpu=native`, and anything else is\n+        # an arg to `-Ctarget-feature`\n+        target_feature: [default, native, +sse3, +ssse3, +sse4.1, +sse4.2, +avx, +avx2]\n+\n+        exclude:\n+          # The macos runners seem to only reliably support up to `avx`.\n+          - { target: x86_64-apple-darwin, target_feature: +avx2 }\n+          # These features are statically known to be present for all 64 bit\n+          # macs, and thus are covered by the `default` test\n+          - { target: x86_64-apple-darwin, target_feature: +sse3 }\n+          - { target: x86_64-apple-darwin, target_feature: +ssse3 }\n+          # -Ctarget-cpu=native sounds like bad-news if target != host\n+          - { target: i686-pc-windows-msvc, target_feature: native }\n+          - { target: i586-pc-windows-msvc, target_feature: native }\n+\n+        include:\n+          # Populate the `matrix.os` field\n+          - { target: x86_64-apple-darwin,      os: macos-latest }\n+          - { target: x86_64-unknown-linux-gnu, os: ubuntu-latest }\n+          - { target: x86_64-pc-windows-msvc,   os: windows-latest }\n+          - { target: i686-pc-windows-msvc,     os: windows-latest }\n+          - { target: i586-pc-windows-msvc,     os: windows-latest }\n+\n+          # These are globally available on all the other targets.\n+          - { target: i586-pc-windows-msvc, target_feature: +sse, os: windows-latest }\n+          - { target: i586-pc-windows-msvc, target_feature: +sse2, os: windows-latest }\n+\n+          # Annoyingly, the x86_64-unknown-linux-gnu runner *almost* always has\n+          # avx512vl, but occasionally doesn't.  Maybe one day we can enable it.\n+\n+    steps:\n+      - uses: actions/checkout@v2\n+      - name: Setup Rust\n+        run: |\n+          rustup update nightly --no-self-update\n+          rustup default nightly\n+          rustup target add ${{ matrix.target }}\n+\n+      - name: Configure RUSTFLAGS\n+        shell: bash\n+        run: |\n+          case \"${{ matrix.target_feature }}\" in\n+            default)\n+              echo \"RUSTFLAGS=-Dwarnings\" >> $GITHUB_ENV;;\n+            native)\n+              echo \"RUSTFLAGS=-Dwarnings -Ctarget-cpu=native\" >> $GITHUB_ENV\n+              ;;\n+            *)\n+              echo \"RUSTFLAGS=-Dwarnings -Ctarget-feature=${{ matrix.target_feature }}\" >> $GITHUB_ENV\n+              ;;\n+          esac\n+\n+      # Super useful for debugging why a SIGILL occurred.\n+      - name: Dump target configuration and support\n+        run: |\n+          rustc -Vv\n+\n+          echo \"Caveat: not all target features are expected to be logged\"\n+\n+          echo \"## Requested target configuration (RUSTFLAGS=$RUSTFLAGS)\"\n+          rustc --print=cfg --target=${{ matrix.target }} $RUSTFLAGS\n+\n+          echo \"## Supported target configuration for --target=${{ matrix.target }}\"\n+          rustc --print=cfg --target=${{ matrix.target }} -Ctarget-cpu=native\n+\n+          echo \"## Natively supported target configuration\"\n+          rustc --print=cfg -Ctarget-cpu=native\n+\n+      - name: Test (debug)\n+        run: cargo test --verbose --target=${{ matrix.target }}\n+\n+      - name: Test (release)\n+        run: cargo test --verbose --target=${{ matrix.target }} --release\n+\n+  wasm-tests:\n+    name: \"wasm (firefox, ${{ matrix.name }})\"\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { name: default, RUSTFLAGS: \"\" }\n+          - { name: simd128, RUSTFLAGS: \"-C target-feature=+simd128\" }\n+    steps:\n+      - uses: actions/checkout@v2\n+      - name: Setup Rust\n+        run: |\n+          rustup update nightly --no-self-update\n+          rustup default nightly\n+      - name: Install wasm-pack\n+        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\n+      - name: Test (debug)\n+        run: wasm-pack test --firefox --headless crates/core_simd\n+        env:\n+            RUSTFLAGS: ${{ matrix.rustflags }}\n+      - name: Test (release)\n+        run: wasm-pack test --firefox --headless crates/core_simd --release\n+        env:\n+            RUSTFLAGS: ${{ matrix.rustflags }}\n+\n+  cross-tests:\n+    name: \"${{ matrix.target }} (via cross)\"\n+    runs-on: ubuntu-latest\n+    strategy:\n+      fail-fast: false\n+      # TODO: Sadly, we cant configure target-feature in a meaningful way\n+      # because `cross` doesn't tell qemu to enable any non-default cpu\n+      # features, nor does it give us a way to do so.\n+      #\n+      # Ultimately, we'd like to do something like [rust-lang/stdarch][stdarch].\n+      # This is a lot more complex... but in practice it's likely that we can just\n+      # snarf the docker config from around [here][1000-dockerfiles].\n+      #\n+      # [stdarch]: https://github.com/rust-lang/stdarch/blob/a5db4eaf/.github/workflows/main.yml#L67\n+      # [1000-dockerfiles]: https://github.com/rust-lang/stdarch/tree/a5db4eaf/ci/docker\n+\n+      matrix:\n+        target:\n+          - i586-unknown-linux-gnu\n+          # 32-bit arm has a few idiosyncracies like having subnormal flushing\n+          # to zero on by default. Ideally we'd set\n+          - armv7-unknown-linux-gnueabihf\n+          - aarch64-unknown-linux-gnu\n+          # Note: The issue above means neither of these mips targets will use\n+          # MSA (mips simd) but MIPS uses a nonstandard binary representation\n+          # for NaNs which makes it worth testing on despite that.\n+          - mips-unknown-linux-gnu\n+          - mips64-unknown-linux-gnuabi64\n+          - riscv64gc-unknown-linux-gnu\n+          # TODO this test works, but it appears to time out\n+          # - powerpc-unknown-linux-gnu\n+          # TODO this test is broken, but it appears to be a problem with QEMU, not us.\n+          # - powerpc64le-unknown-linux-gnu\n+          # TODO enable this once a new version of cross is released\n+          # - powerpc64-unknown-linux-gnu\n+\n+    steps:\n+      - uses: actions/checkout@v2\n+      - name: Setup Rust\n+        run: |\n+          rustup update nightly --no-self-update\n+          rustup default nightly\n+          rustup target add ${{ matrix.target }}\n+          rustup component add rust-src\n+\n+      - name: Install Cross\n+        # Equivalent to `cargo install cross`, but downloading a prebuilt\n+        # binary. Ideally we wouldn't hardcode a version, but the version number\n+        # being part of the tarball means we can't just use the download/latest\n+        # URL :(\n+        run: |\n+          CROSS_URL=https://github.com/rust-embedded/cross/releases/download/v0.2.1/cross-v0.2.1-x86_64-unknown-linux-gnu.tar.gz\n+          mkdir -p \"$HOME/.bin\"\n+          curl -sfSL --retry-delay 10 --retry 5 \"${CROSS_URL}\" | tar zxf - -C \"$HOME/.bin\"\n+          echo \"$HOME/.bin\" >> $GITHUB_PATH\n+\n+      - name: Test (debug)\n+        run: cross test --verbose --target=${{ matrix.target }}\n+\n+      - name: Test (release)\n+        run: cross test --verbose --target=${{ matrix.target }} --release\n+\n+  features:\n+    name: \"Check cargo features (${{ matrix.simd }} \u00d7 ${{ matrix.features }})\"\n+    runs-on: ubuntu-latest\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        simd:\n+          - \"\"\n+          - \"avx512\"\n+        features:\n+          - \"\"\n+          - \"--features std\"\n+          - \"--features generic_const_exprs\"\n+          - \"--features std --features generic_const_exprs\"\n+\n+    steps:\n+      - uses: actions/checkout@v2\n+      - name: Setup Rust\n+        run: |\n+          rustup update nightly --no-self-update\n+          rustup default nightly\n+      - name: Detect AVX512\n+        run: echo \"CPU_FEATURE=$(lscpu | grep -o avx512[a-z]* | sed s/avx/+avx/ | tr '\\n' ',' )\" >> $GITHUB_ENV\n+      - name: Check build\n+        if: ${{ matrix.simd == '' }}\n+        run: RUSTFLAGS=\"-Dwarnings\" cargo check --all-targets --no-default-features ${{ matrix.features }}\n+      - name: Check AVX\n+        if: ${{ matrix.simd == 'avx512' && contains(env.CPU_FEATURE, 'avx512') }}\n+        run: |\n+          echo \"Found AVX features: $CPU_FEATURE\"\n+          RUSTFLAGS=\"-Dwarnings -Ctarget-feature=$CPU_FEATURE\" cargo check --all-targets --no-default-features ${{ matrix.features }}"}, {"sha": "9d1fa66ccb595c5807ba4c55aa3b36f5233f8e54", "filename": "library/portable-simd/.github/workflows/doc.yml", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2Fworkflows%2Fdoc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.github%2Fworkflows%2Fdoc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2Fworkflows%2Fdoc.yml?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,30 @@\n+name: Documentation\n+\n+on:\n+  push:\n+    branches:\n+      - master\n+\n+jobs:\n+  release:\n+    name: Deploy Documentation\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+      - name: Checkout Repository\n+        uses: actions/checkout@v1\n+\n+      - name: Setup Rust\n+        run: |\n+          rustup update nightly --no-self-update\n+          rustup default nightly\n+\n+      - name: Build Documentation\n+        run: cargo doc --no-deps\n+      \n+      - name: Deploy Documentation\n+        uses: peaceiris/actions-gh-pages@v3\n+        with:\n+          github_token: ${{ secrets.GITHUB_TOKEN }}\n+          publish_branch: gh-pages\n+          publish_dir: ./target/doc"}, {"sha": "96ef6c0b944e24fc22f51f18136cd62ffd5b0b8f", "filename": "library/portable-simd/.gitignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.gitignore?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,2 @@\n+/target\n+Cargo.lock"}, {"sha": "f9ba12d3a1b3adb53ddd6f321837a60f5f7860e7", "filename": "library/portable-simd/CONTRIBUTING.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FCONTRIBUTING.md?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,32 @@\n+# Contributing to `std::simd`\n+\n+Simple version:\n+1. Fork it and `git clone` it\n+2. Create your feature branch: `git checkout -b my-branch`\n+3. Write your changes.\n+4. Test it: `cargo test`. Remember to enable whatever SIMD features you intend to test by setting `RUSTFLAGS`.\n+5. Commit your changes: `git commit add ./path/to/changes && git commit -m 'Fix some bug'`\n+6. Push the branch: `git push --set-upstream origin my-branch`\n+7. Submit a pull request!\n+\n+## Taking on an Issue\n+\n+SIMD can be quite complex, and even a \"simple\" issue can be huge. If an issue is organized like a tracking issue, with an itemized list of items that don't necessarily have to be done in a specific order, please take the issue one item at a time. This will help by letting work proceed apace on the rest of the issue. If it's a (relatively) small issue, feel free to announce your intention to solve it on the issue tracker and take it in one go!\n+\n+## CI\n+\n+We currently have 2 CI matrices through Travis CI and GitHub Actions that will automatically build and test your change in order to verify that `std::simd`'s portable API is, in fact, portable. If your change builds locally, but does not build on either, this is likely due to a platform-specific concern that your code has not addressed. Please consult the build logs and address the error, or ask for help if you need it.\n+\n+## Beyond stdsimd\n+\n+A large amount of the core SIMD implementation is found in the rustc_codegen_* crates in the [main rustc repo](https://github.com/rust-lang/rust). In addition, actual platform-specific functions are implemented in [stdarch]. Not all changes to `std::simd` require interacting with either of these, but if you're wondering where something is and it doesn't seem to be in this repository, those might be where to start looking.\n+\n+## Questions? Concerns? Need Help?\n+\n+Please feel free to ask in the [#project-portable-simd][zulip-portable-simd] stream on the [rust-lang Zulip][zulip] for help with making changes to `std::simd`!\n+If your changes include directly modifying the compiler, it might also be useful to ask in [#t-compiler/help][zulip-compiler-help].\n+\n+[zulip-portable-simd]: https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd\n+[zulip-compiler-help]: https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp\n+[zulip]: https://rust-lang.zulipchat.com\n+[stdarch]: https://github.com/rust-lang/stdarch"}, {"sha": "3f1abd73519bdd1bb02bf43787019bdb8b6c427c", "filename": "library/portable-simd/Cargo.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FCargo.toml?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,6 @@\n+[workspace]\n+\n+members = [\n+    \"crates/core_simd\",\n+    \"crates/test_helpers\",\n+]"}, {"sha": "d645695673349e3947e8e5ae42332d0ac3164cd7", "filename": "library/portable-simd/LICENSE-APACHE", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FLICENSE-APACHE?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,202 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License."}, {"sha": "0e9d2f43a06002c1fe691a06a9650e652aaadee3", "filename": "library/portable-simd/LICENSE-MIT", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FLICENSE-MIT?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,19 @@\n+Copyright (c) 2020 The Rust Project Developers\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."}, {"sha": "da536a4d6f2d5f2133e92cbf3da6e1127eb888e6", "filename": "library/portable-simd/README.md", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FREADME.md?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,69 @@\n+# The Rust standard library's portable SIMD API\n+[![Build Status](https://travis-ci.com/rust-lang/portable-simd.svg?branch=master)](https://travis-ci.com/rust-lang/portable-simd)\n+\n+Code repository for the [Portable SIMD Project Group](https://github.com/rust-lang/project-portable-simd).\n+Please refer to [CONTRIBUTING.md](./CONTRIBUTING.md) for our contributing guidelines.\n+\n+The docs for this crate are published from the main branch.\n+You can [read them here][docs].\n+\n+If you have questions about SIMD, we have begun writing a [guide][simd-guide].\n+We can also be found on [Zulip][zulip-project-portable-simd].\n+\n+If you are interested in support for a specific architecture, you may want [stdarch] instead.\n+\n+## Hello World\n+\n+Now we're gonna dip our toes into this world with a small SIMD \"Hello, World!\" example. Make sure your compiler is up to date and using `nightly`. We can do that by running \n+\n+```bash\n+rustup update -- nightly\n+```\n+\n+or by setting up `rustup default nightly` or else with `cargo +nightly {build,test,run}`. After updating, run \n+```bash\n+cargo new hellosimd\n+```\n+to create a new crate. Edit `hellosimd/Cargo.toml` to be \n+```toml\n+[package]\n+name = \"hellosimd\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+[dependencies]\n+core_simd = { git = \"https://github.com/rust-lang/portable-simd\" }\n+```\n+\n+and finally write this in `src/main.rs`:\n+```rust\n+use core_simd::*;\n+fn main() {\n+    let a = f32x4::splat(10.0);\n+    let b = f32x4::from_array([1.0, 2.0, 3.0, 4.0]);\n+    println!(\"{:?}\", a + b);\n+}\n+```\n+\n+Explanation: We import all the bindings from the crate with the first line. Then, we construct our SIMD vectors with methods like `splat` or `from_array`. Finally, we can use operators on them like `+` and the appropriate SIMD instructions will be carried out. When we run `cargo run` you should get `[11.0, 12.0, 13.0, 14.0]`.\n+\n+## Code Organization\n+\n+Currently the crate is organized so that each element type is a file, and then the 64-bit, 128-bit, 256-bit, and 512-bit vectors using those types are contained in said file.\n+\n+All types are then exported as a single, flat module.\n+\n+Depending on the size of the primitive type, the number of lanes the vector will have varies. For example, 128-bit vectors have four `f32` lanes and two `f64` lanes.\n+\n+The supported element types are as follows:\n+* **Floating Point:** `f32`, `f64`\n+* **Signed Integers:** `i8`, `i16`, `i32`, `i64`, `i128`, `isize`\n+* **Unsigned Integers:** `u8`, `u16`, `u32`, `u64`, `u128`, `usize`\n+* **Masks:** `mask8`, `mask16`, `mask32`, `mask64`, `mask128`, `masksize`\n+\n+Floating point, signed integers, and unsigned integers are the [primitive types](https://doc.rust-lang.org/core/primitive/index.html) you're already used to.\n+The `mask` types are \"truthy\" values, but they use the number of bits in their name instead of just 1 bit like a normal `bool` uses.\n+\n+[simd-guide]: ./beginners-guide.md\n+[zulip-project-portable-simd]: https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd\n+[stdarch]: https://github.com/rust-lang/stdarch\n+[docs]: https://rust-lang.github.io/portable-simd/core_simd"}, {"sha": "dfd357c459200f7b7eb3901d2afd1b8fa74dd98d", "filename": "library/portable-simd/beginners-guide.md", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fbeginners-guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fbeginners-guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fbeginners-guide.md?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,86 @@\n+\n+# Beginner's Guide To SIMD\n+\n+Hello and welcome to our SIMD basics guide!\n+\n+Because SIMD is a subject that many programmers haven't worked with before, we thought that it's best to outline some terms and other basics for you to get started with.\n+\n+## Quick Background\n+\n+**SIMD** stands for *Single Instruction, Multiple Data*. In other words, SIMD is when the CPU performs a single action on more than one logical piece of data at the same time. Instead of adding two registers that each contain one `f32` value and getting an `f32` as the result, you might add two registers that each contain `f32x4` (128 bits of data) and then you get an `f32x4` as the output.\n+\n+This might seem a tiny bit weird at first, but there's a good reason for it. Back in the day, as CPUs got faster and faster, eventually they got so fast that the CPU would just melt itself. The heat management (heat sinks, fans, etc) simply couldn't keep up with how much electricity was going through the metal. Two main strategies were developed to help get around the limits of physics.\n+* One of them you're probably familiar with: Multi-core processors. By giving a processor more than one core, each core can do its own work, and because they're physically distant (at least on the CPU's scale) the heat can still be managed. Unfortunately, not all tasks can just be split up across cores in an efficient way.\n+* The second strategy is SIMD. If you can't make the register go any faster, you can still make the register *wider*. This lets you process more data at a time, which is *almost* as good as just having a faster CPU. As with multi-core programming, SIMD doesn't fit every kind of task, so you have to know when it will improve your program.\n+\n+## Terms\n+\n+SIMD has a few special vocabulary terms you should know:\n+\n+* **Vector:** A SIMD value is called a vector. This shouldn't be confused with the `Vec<T>` type. A SIMD vector has a fixed size, known at compile time. All of the elements within the vector are of the same type. This makes vectors *similar to* arrays. One difference is that a vector is generally aligned to its *entire* size (eg: 16 bytes, 32 bytes, etc), not just the size of an individual element. Sometimes vector data is called \"packed\" data.\n+\n+* **Vectorize**: An operation that uses SIMD instructions to operate over a vector is often referred to as \"vectorized\".\n+\n+* **Autovectorization**: Also known as _implicit vectorization_. This is when a compiler can automatically recognize a situation where scalar instructions may be replaced with SIMD instructions, and use those instead.\n+\n+* **Scalar:** \"Scalar\" in mathematical contexts refers to values that can be represented as a single element, mostly numbers like 6, 3.14, or -2. It can also be used to describe \"scalar operations\" that use strictly scalar values, like addition. This term is mostly used to differentiate between vectorized operations that use SIMD instructions and scalar operations that don't.\n+\n+* **Lane:** A single element position within a vector is called a lane. If you have `N` lanes available then they're numbered from `0` to `N-1` when referring to them, again like an array. The biggest difference between an array element and a vector lane is that in general is *relatively costly* to access an individual lane value. On most architectures, the vector has to be pushed out of the SIMD register onto the stack, then an individual lane is accessed while it's on the stack (and possibly the stack value is read back into a register). For this reason, when working with SIMD you should avoid reading or writing the value of an individual lane during hot loops.\n+\n+* **Bit Widths:** When talking about SIMD, the bit widths used are the bit size of the vectors involved, *not* the individual elements. So \"128-bit SIMD\" has 128-bit vectors, and that might be `f32x4`, `i32x4`, `i16x8`, or other variations. While 128-bit SIMD is the most common, there's also 64-bit, 256-bit, and even 512-bit on the newest CPUs.\n+\n+* **Vector Register:** The extra-wide registers that are used for SIMD operations are commonly called vector registers, though you may also see \"SIMD registers\", vendor names for specific features, or even \"floating-point register\" as it is common for the same registers to be used with both scalar and vectorized floating-point operations.\n+\n+* **Vertical:** When an operation is \"vertical\", each lane processes individually without regard to the other lanes in the same vector. For example, a \"vertical add\" between two vectors would add lane 0 in `a` with lane 0 in `b`, with the total in lane 0 of `out`, and then the same thing for lanes 1, 2, etc. Most SIMD operations are vertical operations, so if your problem is a vertical problem then you can probably solve it with SIMD.\n+\n+* **Horizontal:** When an operation is \"horizontal\", the lanes within a single vector interact in some way. A \"horizontal add\" might add up lane 0 of `a` with lane 1 of `a`, with the total in lane 0 of `out`.\n+\n+* **Target Feature:** Rust calls a CPU architecture extension a `target_feature`. Proper SIMD requires various CPU extensions to be enabled (details below). Don't confuse this with `feature`, which is a Cargo crate concept.\n+\n+## Target Features\n+\n+When using SIMD, you should be familiar with the CPU feature set that you're targeting.\n+\n+On `arm` and `aarch64` it's fairly simple. There's just one CPU feature that controls if SIMD is available: `neon` (or \"NEON\", all caps, as the ARM docs often put it). Neon registers can be used as 64-bit or 128-bit. When doing 128-bit operations it just uses two 64-bit registers as a single 128-bit register.\n+\n+> By default, the `aarch64`, `arm`, and `thumb` Rust targets generally do not enable `neon` unless it's in the target string.\n+\n+On `x86` and `x86_64` it's slightly more complicated. The SIMD support is split into many levels:\n+* 128-bit: `sse`, `sse2`, `sse3`, `ssse3` (not a typo!), `sse4.1`, `sse4.2`, `sse4a` (AMD only)\n+* 256-bit (mostly): `avx`, `avx2`, `fma`\n+* 512-bit (mostly): a *wide* range of `avx512` variations\n+\n+The list notes the bit widths available at each feature level, though the operations of the more advanced features can generally be used with the smaller register sizes as well. For example, new operations introduced in `avx` generally have a 128-bit form as well as a 256-bit form. This means that even if you only do 128-bit work you can still benefit from the later feature levels.\n+\n+> By default, the `i686` and `x86_64` Rust targets enable `sse` and `sse2`.\n+\n+### Selecting Additional Target Features\n+\n+If you want to enable support for a target feature within your build, generally you should use a [target-feature](https://rust-lang.github.io/packed_simd/perf-guide/target-feature/rustflags.html#target-feature) setting within you `RUSTFLAGS` setting.\n+\n+If you know that you're targeting a specific CPU you can instead use the [target-cpu](https://rust-lang.github.io/packed_simd/perf-guide/target-feature/rustflags.html#target-cpu) flag and the compiler will enable the correct set of features for that CPU.\n+\n+The [Steam Hardware Survey](https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam) is one of the few places with data on how common various CPU features are. The dataset is limited to \"the kinds of computers owned by people who play computer games\", so the info only covers `x86`/`x86_64`, and it also probably skews to slightly higher quality computers than average. Still, we can see that the `sse` levels have very high support, `avx` and `avx2` are quite common as well, and the `avx-512` family is still so early in adoption you can barely find it in consumer grade stuff.\n+\n+## Running a program compiled for a CPU feature level that the CPU doesn't support is automatic undefined behavior.\n+\n+This means that if you build your program with `avx` support enabled and run it on a CPU without `avx` support, it's **instantly** undefined behavior.\n+\n+Even without an `unsafe` block in sight.\n+\n+This is no bug in Rust, or soundness hole in the type system. You just plain can't make a CPU do what it doesn't know how to do.\n+\n+This is why the various Rust targets *don't* enable many CPU feature flags by default: requiring a more advanced CPU makes the final binary *less* portable.\n+\n+So please select an appropriate CPU feature level when building your programs.\n+\n+## Size, Alignment, and Unsafe Code\n+\n+Most of the portable SIMD API is designed to allow the user to gloss over the details of different architectures and avoid using unsafe code. However, there are plenty of reasons to want to use unsafe code with these SIMD types, such as using an intrinsic function from `core::arch` to further accelerate particularly specialized SIMD operations on a given platform, while still using the portable API elsewhere. For these cases, there are some rules to keep in mind.\n+\n+Fortunately, most SIMD types have a fairly predictable size. `i32x4` is bit-equivalent to `[i32; 4]` and so can be bitcast to it, e.g. using [`mem::transmute`], though the API usually offers a safe cast you can use instead.\n+\n+However, this is not the same as alignment. Computer architectures generally prefer aligned accesses, especially when moving data between memory and vector registers, and while some support specialized operations that can bend the rules to help with this, unaligned access is still typically slow, or even undefined behavior. In addition, different architectures can require different alignments when interacting with their native SIMD types. For this reason, any `#[repr(simd)]` type has a non-portable alignment. If it is necessary to directly interact with the alignment of these types, it should be via [`mem::align_of`].\n+\n+[`mem::transmute`]: https://doc.rust-lang.org/core/mem/fn.transmute.html\n+[`mem::align_of`]: https://doc.rust-lang.org/core/mem/fn.align_of.html\n\\ No newline at end of file"}, {"sha": "a103ef115a58626aaa3b21e30847995c49de5482", "filename": "library/portable-simd/crates/core_simd/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,28 @@\n+[package]\n+name = \"core_simd\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+homepage = \"https://github.com/rust-lang/portable-simd\"\n+repository = \"https://github.com/rust-lang/portable-simd\"\n+keywords = [\"core\", \"simd\", \"intrinsics\"]\n+categories = [\"hardware-support\", \"no-std\"]\n+license = \"MIT OR Apache-2.0\"\n+\n+[features]\n+default = [\"std\", \"generic_const_exprs\"]\n+std = []\n+generic_const_exprs = []\n+\n+[target.'cfg(target_arch = \"wasm32\")'.dev-dependencies.wasm-bindgen]\n+version = \"0.2\"\n+\n+[dev-dependencies.wasm-bindgen-test]\n+version = \"0.3\"\n+\n+[dev-dependencies.proptest]\n+version = \"0.10\"\n+default-features = false\n+features = [\"alloc\"]\n+\n+[dev-dependencies.test_helpers]\n+path = \"../test_helpers\""}, {"sha": "d645695673349e3947e8e5ae42332d0ac3164cd7", "filename": "library/portable-simd/crates/core_simd/LICENSE-APACHE", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FLICENSE-APACHE?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,202 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License."}, {"sha": "0e9d2f43a06002c1fe691a06a9650e652aaadee3", "filename": "library/portable-simd/crates/core_simd/LICENSE-MIT", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FLICENSE-MIT?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,19 @@\n+Copyright (c) 2020 The Rust Project Developers\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."}, {"sha": "c51a566deb59dc50bbebcb1e4547b7a97bd17a6b", "filename": "library/portable-simd/crates/core_simd/examples/matrix_inversion.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,316 @@\n+//! 4x4 matrix inverse\n+// Code ported from the `packed_simd` crate\n+// Run this code with `cargo test --example matrix_inversion`\n+#![feature(array_chunks, portable_simd)]\n+use core_simd::simd::*;\n+use Which::*;\n+\n+// Gotta define our own 4x4 matrix since Rust doesn't ship multidim arrays yet :^)\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n+pub struct Matrix4x4([[f32; 4]; 4]);\n+\n+#[allow(clippy::too_many_lines)]\n+pub fn scalar_inv4x4(m: Matrix4x4) -> Option<Matrix4x4> {\n+    let m = m.0;\n+\n+    #[rustfmt::skip]\n+    let mut inv = [\n+        // row 0:\n+        [\n+            // 0,0:\n+            m[1][1] * m[2][2] * m[3][3] -\n+            m[1][1] * m[2][3] * m[3][2] -\n+            m[2][1] * m[1][2] * m[3][3] +\n+            m[2][1] * m[1][3] * m[3][2] +\n+            m[3][1] * m[1][2] * m[2][3] -\n+            m[3][1] * m[1][3] * m[2][2],\n+            // 0,1:\n+           -m[0][1] * m[2][2] * m[3][3] +\n+            m[0][1] * m[2][3] * m[3][2] +\n+            m[2][1] * m[0][2] * m[3][3] -\n+            m[2][1] * m[0][3] * m[3][2] -\n+            m[3][1] * m[0][2] * m[2][3] +\n+            m[3][1] * m[0][3] * m[2][2],\n+            // 0,2:\n+            m[0][1] * m[1][2] * m[3][3] -\n+            m[0][1] * m[1][3] * m[3][2] -\n+            m[1][1] * m[0][2] * m[3][3] +\n+            m[1][1] * m[0][3] * m[3][2] +\n+            m[3][1] * m[0][2] * m[1][3] -\n+            m[3][1] * m[0][3] * m[1][2],\n+            // 0,3:\n+           -m[0][1] * m[1][2] * m[2][3] +\n+            m[0][1] * m[1][3] * m[2][2] +\n+            m[1][1] * m[0][2] * m[2][3] -\n+            m[1][1] * m[0][3] * m[2][2] -\n+            m[2][1] * m[0][2] * m[1][3] +\n+            m[2][1] * m[0][3] * m[1][2],\n+        ],\n+        // row 1\n+        [\n+            // 1,0:\n+           -m[1][0] * m[2][2] * m[3][3] +\n+            m[1][0] * m[2][3] * m[3][2] +\n+            m[2][0] * m[1][2] * m[3][3] -\n+            m[2][0] * m[1][3] * m[3][2] -\n+            m[3][0] * m[1][2] * m[2][3] +\n+            m[3][0] * m[1][3] * m[2][2],\n+            // 1,1:\n+            m[0][0] * m[2][2] * m[3][3] -\n+            m[0][0] * m[2][3] * m[3][2] -\n+            m[2][0] * m[0][2] * m[3][3] +\n+            m[2][0] * m[0][3] * m[3][2] +\n+            m[3][0] * m[0][2] * m[2][3] -\n+            m[3][0] * m[0][3] * m[2][2],\n+            // 1,2:\n+           -m[0][0] * m[1][2] * m[3][3] +\n+            m[0][0] * m[1][3] * m[3][2] +\n+            m[1][0] * m[0][2] * m[3][3] -\n+            m[1][0] * m[0][3] * m[3][2] -\n+            m[3][0] * m[0][2] * m[1][3] +\n+            m[3][0] * m[0][3] * m[1][2],\n+            // 1,3:\n+            m[0][0] * m[1][2] * m[2][3] -\n+            m[0][0] * m[1][3] * m[2][2] -\n+            m[1][0] * m[0][2] * m[2][3] +\n+            m[1][0] * m[0][3] * m[2][2] +\n+            m[2][0] * m[0][2] * m[1][3] -\n+            m[2][0] * m[0][3] * m[1][2],\n+        ],\n+        // row 2\n+        [\n+            // 2,0:\n+            m[1][0] * m[2][1] * m[3][3] -\n+            m[1][0] * m[2][3] * m[3][1] -\n+            m[2][0] * m[1][1] * m[3][3] +\n+            m[2][0] * m[1][3] * m[3][1] +\n+            m[3][0] * m[1][1] * m[2][3] -\n+            m[3][0] * m[1][3] * m[2][1],\n+            // 2,1:\n+           -m[0][0] * m[2][1] * m[3][3] +\n+            m[0][0] * m[2][3] * m[3][1] +\n+            m[2][0] * m[0][1] * m[3][3] -\n+            m[2][0] * m[0][3] * m[3][1] -\n+            m[3][0] * m[0][1] * m[2][3] +\n+            m[3][0] * m[0][3] * m[2][1],\n+            // 2,2:\n+            m[0][0] * m[1][1] * m[3][3] -\n+            m[0][0] * m[1][3] * m[3][1] -\n+            m[1][0] * m[0][1] * m[3][3] +\n+            m[1][0] * m[0][3] * m[3][1] +\n+            m[3][0] * m[0][1] * m[1][3] -\n+            m[3][0] * m[0][3] * m[1][1],\n+            // 2,3:\n+           -m[0][0] * m[1][1] * m[2][3] +\n+            m[0][0] * m[1][3] * m[2][1] +\n+            m[1][0] * m[0][1] * m[2][3] -\n+            m[1][0] * m[0][3] * m[2][1] -\n+            m[2][0] * m[0][1] * m[1][3] +\n+            m[2][0] * m[0][3] * m[1][1],\n+        ],\n+        // row 3\n+        [\n+            // 3,0:\n+           -m[1][0] * m[2][1] * m[3][2] +\n+            m[1][0] * m[2][2] * m[3][1] +\n+            m[2][0] * m[1][1] * m[3][2] -\n+            m[2][0] * m[1][2] * m[3][1] -\n+            m[3][0] * m[1][1] * m[2][2] +\n+            m[3][0] * m[1][2] * m[2][1],\n+            // 3,1:\n+            m[0][0] * m[2][1] * m[3][2] -\n+            m[0][0] * m[2][2] * m[3][1] -\n+            m[2][0] * m[0][1] * m[3][2] +\n+            m[2][0] * m[0][2] * m[3][1] +\n+            m[3][0] * m[0][1] * m[2][2] -\n+            m[3][0] * m[0][2] * m[2][1],\n+            // 3,2:\n+           -m[0][0] * m[1][1] * m[3][2] +\n+            m[0][0] * m[1][2] * m[3][1] +\n+            m[1][0] * m[0][1] * m[3][2] -\n+            m[1][0] * m[0][2] * m[3][1] -\n+            m[3][0] * m[0][1] * m[1][2] +\n+            m[3][0] * m[0][2] * m[1][1],\n+            // 3,3:\n+            m[0][0] * m[1][1] * m[2][2] -\n+            m[0][0] * m[1][2] * m[2][1] -\n+            m[1][0] * m[0][1] * m[2][2] +\n+            m[1][0] * m[0][2] * m[2][1] +\n+            m[2][0] * m[0][1] * m[1][2] -\n+            m[2][0] * m[0][2] * m[1][1],\n+        ],\n+    ];\n+\n+    let det = m[0][0] * inv[0][0] + m[0][1] * inv[1][0] + m[0][2] * inv[2][0] + m[0][3] * inv[3][0];\n+    if det == 0. {\n+        return None;\n+    }\n+\n+    let det_inv = 1. / det;\n+\n+    for row in &mut inv {\n+        for elem in row.iter_mut() {\n+            *elem *= det_inv;\n+        }\n+    }\n+\n+    Some(Matrix4x4(inv))\n+}\n+\n+pub fn simd_inv4x4(m: Matrix4x4) -> Option<Matrix4x4> {\n+    let m = m.0;\n+    let m_0 = f32x4::from_array(m[0]);\n+    let m_1 = f32x4::from_array(m[1]);\n+    let m_2 = f32x4::from_array(m[2]);\n+    let m_3 = f32x4::from_array(m[3]);\n+\n+    const SHUFFLE01: [Which; 4] = [First(0), First(1), Second(0), Second(1)];\n+    const SHUFFLE02: [Which; 4] = [First(0), First(2), Second(0), Second(2)];\n+    const SHUFFLE13: [Which; 4] = [First(1), First(3), Second(1), Second(3)];\n+    const SHUFFLE23: [Which; 4] = [First(2), First(3), Second(2), Second(3)];\n+\n+    let tmp = simd_swizzle!(m_0, m_1, SHUFFLE01);\n+    let row1 = simd_swizzle!(m_2, m_3, SHUFFLE01);\n+\n+    let row0 = simd_swizzle!(tmp, row1, SHUFFLE02);\n+    let row1 = simd_swizzle!(row1, tmp, SHUFFLE13);\n+\n+    let tmp = simd_swizzle!(m_0, m_1, SHUFFLE23);\n+    let row3 = simd_swizzle!(m_2, m_3, SHUFFLE23);\n+    let row2 = simd_swizzle!(tmp, row3, SHUFFLE02);\n+    let row3 = simd_swizzle!(row3, tmp, SHUFFLE13);\n+\n+    let tmp = (row2 * row3).reverse().rotate_lanes_right::<2>();\n+    let minor0 = row1 * tmp;\n+    let minor1 = row0 * tmp;\n+    let tmp = tmp.rotate_lanes_right::<2>();\n+    let minor0 = (row1 * tmp) - minor0;\n+    let minor1 = (row0 * tmp) - minor1;\n+    let minor1 = minor1.rotate_lanes_right::<2>();\n+\n+    let tmp = (row1 * row2).reverse().rotate_lanes_right::<2>();\n+    let minor0 = (row3 * tmp) + minor0;\n+    let minor3 = row0 * tmp;\n+    let tmp = tmp.rotate_lanes_right::<2>();\n+\n+    let minor0 = minor0 - row3 * tmp;\n+    let minor3 = row0 * tmp - minor3;\n+    let minor3 = minor3.rotate_lanes_right::<2>();\n+\n+    let tmp = (row3 * row1.rotate_lanes_right::<2>())\n+        .reverse()\n+        .rotate_lanes_right::<2>();\n+    let row2 = row2.rotate_lanes_right::<2>();\n+    let minor0 = row2 * tmp + minor0;\n+    let minor2 = row0 * tmp;\n+    let tmp = tmp.rotate_lanes_right::<2>();\n+    let minor0 = minor0 - row2 * tmp;\n+    let minor2 = row0 * tmp - minor2;\n+    let minor2 = minor2.rotate_lanes_right::<2>();\n+\n+    let tmp = (row0 * row1).reverse().rotate_lanes_right::<2>();\n+    let minor2 = minor2 + row3 * tmp;\n+    let minor3 = row2 * tmp - minor3;\n+    let tmp = tmp.rotate_lanes_right::<2>();\n+    let minor2 = row3 * tmp - minor2;\n+    let minor3 = minor3 - row2 * tmp;\n+\n+    let tmp = (row0 * row3).reverse().rotate_lanes_right::<2>();\n+    let minor1 = minor1 - row2 * tmp;\n+    let minor2 = row1 * tmp + minor2;\n+    let tmp = tmp.rotate_lanes_right::<2>();\n+    let minor1 = row2 * tmp + minor1;\n+    let minor2 = minor2 - row1 * tmp;\n+\n+    let tmp = (row0 * row2).reverse().rotate_lanes_right::<2>();\n+    let minor1 = row3 * tmp + minor1;\n+    let minor3 = minor3 - row1 * tmp;\n+    let tmp = tmp.rotate_lanes_right::<2>();\n+    let minor1 = minor1 - row3 * tmp;\n+    let minor3 = row1 * tmp + minor3;\n+\n+    let det = row0 * minor0;\n+    let det = det.rotate_lanes_right::<2>() + det;\n+    let det = det.reverse().rotate_lanes_right::<2>() + det;\n+\n+    if det.horizontal_sum() == 0. {\n+        return None;\n+    }\n+    // calculate the reciprocal\n+    let tmp = f32x4::splat(1.0) / det;\n+    let det = tmp + tmp - det * tmp * tmp;\n+\n+    let res0 = minor0 * det;\n+    let res1 = minor1 * det;\n+    let res2 = minor2 * det;\n+    let res3 = minor3 * det;\n+\n+    let mut m = m;\n+\n+    m[0] = res0.to_array();\n+    m[1] = res1.to_array();\n+    m[2] = res2.to_array();\n+    m[3] = res3.to_array();\n+\n+    Some(Matrix4x4(m))\n+}\n+\n+#[cfg(test)]\n+#[rustfmt::skip]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test() {\n+    let tests: &[(Matrix4x4, Option<Matrix4x4>)] = &[\n+        // Identity:\n+        (Matrix4x4([\n+            [1., 0., 0., 0.],\n+            [0., 1., 0., 0.],\n+            [0., 0., 1., 0.],\n+            [0., 0., 0., 1.],\n+         ]),\n+         Some(Matrix4x4([\n+             [1., 0., 0., 0.],\n+             [0., 1., 0., 0.],\n+             [0., 0., 1., 0.],\n+             [0., 0., 0., 1.],\n+         ]))\n+        ),\n+        // None:\n+        (Matrix4x4([\n+            [1., 2., 3., 4.],\n+            [12., 11., 10., 9.],\n+            [5., 6., 7., 8.],\n+            [16., 15., 14., 13.],\n+        ]),\n+         None\n+        ),\n+        // Other:\n+        (Matrix4x4([\n+            [1., 1., 1., 0.],\n+            [0., 3., 1., 2.],\n+            [2., 3., 1., 0.],\n+            [1., 0., 2., 1.],\n+        ]),\n+         Some(Matrix4x4([\n+             [-3., -0.5,   1.5,  1.0],\n+             [ 1., 0.25, -0.25, -0.5],\n+             [ 3., 0.25, -1.25, -0.5],\n+             [-3., 0.0,    1.0,  1.0],\n+         ]))\n+        ),\n+\n+\n+    ];\n+\n+        for &(input, output) in tests {\n+            assert_eq!(scalar_inv4x4(input), output);\n+            assert_eq!(simd_inv4x4(input), output);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    // Empty main to make cargo happy\n+}"}, {"sha": "779575985ed9ed933b67cf4ea1b503e5201950e6", "filename": "library/portable-simd/crates/core_simd/examples/nbody.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,193 @@\n+#![cfg_attr(feature = \"std\", feature(portable_simd))]\n+\n+/// Benchmarks game nbody code\n+/// Taken from the `packed_simd` crate\n+/// Run this benchmark with `cargo test --example nbody`\n+#[cfg(feature = \"std\")]\n+mod nbody {\n+    use core_simd::*;\n+\n+    use std::f64::consts::PI;\n+    const SOLAR_MASS: f64 = 4.0 * PI * PI;\n+    const DAYS_PER_YEAR: f64 = 365.24;\n+\n+    #[derive(Debug, Clone, Copy)]\n+    struct Body {\n+        pub x: f64x4,\n+        pub v: f64x4,\n+        pub mass: f64,\n+    }\n+\n+    const N_BODIES: usize = 5;\n+    const BODIES: [Body; N_BODIES] = [\n+        // sun:\n+        Body {\n+            x: f64x4::from_array([0., 0., 0., 0.]),\n+            v: f64x4::from_array([0., 0., 0., 0.]),\n+            mass: SOLAR_MASS,\n+        },\n+        // jupiter:\n+        Body {\n+            x: f64x4::from_array([\n+                4.84143144246472090e+00,\n+                -1.16032004402742839e+00,\n+                -1.03622044471123109e-01,\n+                0.,\n+            ]),\n+            v: f64x4::from_array([\n+                1.66007664274403694e-03 * DAYS_PER_YEAR,\n+                7.69901118419740425e-03 * DAYS_PER_YEAR,\n+                -6.90460016972063023e-05 * DAYS_PER_YEAR,\n+                0.,\n+            ]),\n+            mass: 9.54791938424326609e-04 * SOLAR_MASS,\n+        },\n+        // saturn:\n+        Body {\n+            x: f64x4::from_array([\n+                8.34336671824457987e+00,\n+                4.12479856412430479e+00,\n+                -4.03523417114321381e-01,\n+                0.,\n+            ]),\n+            v: f64x4::from_array([\n+                -2.76742510726862411e-03 * DAYS_PER_YEAR,\n+                4.99852801234917238e-03 * DAYS_PER_YEAR,\n+                2.30417297573763929e-05 * DAYS_PER_YEAR,\n+                0.,\n+            ]),\n+            mass: 2.85885980666130812e-04 * SOLAR_MASS,\n+        },\n+        // uranus:\n+        Body {\n+            x: f64x4::from_array([\n+                1.28943695621391310e+01,\n+                -1.51111514016986312e+01,\n+                -2.23307578892655734e-01,\n+                0.,\n+            ]),\n+            v: f64x4::from_array([\n+                2.96460137564761618e-03 * DAYS_PER_YEAR,\n+                2.37847173959480950e-03 * DAYS_PER_YEAR,\n+                -2.96589568540237556e-05 * DAYS_PER_YEAR,\n+                0.,\n+            ]),\n+            mass: 4.36624404335156298e-05 * SOLAR_MASS,\n+        },\n+        // neptune:\n+        Body {\n+            x: f64x4::from_array([\n+                1.53796971148509165e+01,\n+                -2.59193146099879641e+01,\n+                1.79258772950371181e-01,\n+                0.,\n+            ]),\n+            v: f64x4::from_array([\n+                2.68067772490389322e-03 * DAYS_PER_YEAR,\n+                1.62824170038242295e-03 * DAYS_PER_YEAR,\n+                -9.51592254519715870e-05 * DAYS_PER_YEAR,\n+                0.,\n+            ]),\n+            mass: 5.15138902046611451e-05 * SOLAR_MASS,\n+        },\n+    ];\n+\n+    fn offset_momentum(bodies: &mut [Body; N_BODIES]) {\n+        let (sun, rest) = bodies.split_at_mut(1);\n+        let sun = &mut sun[0];\n+        for body in rest {\n+            let m_ratio = body.mass / SOLAR_MASS;\n+            sun.v -= body.v * m_ratio;\n+        }\n+    }\n+\n+    fn energy(bodies: &[Body; N_BODIES]) -> f64 {\n+        let mut e = 0.;\n+        for i in 0..N_BODIES {\n+            let bi = &bodies[i];\n+            e += bi.mass * (bi.v * bi.v).horizontal_sum() * 0.5;\n+            for bj in bodies.iter().take(N_BODIES).skip(i + 1) {\n+                let dx = bi.x - bj.x;\n+                e -= bi.mass * bj.mass / (dx * dx).horizontal_sum().sqrt()\n+            }\n+        }\n+        e\n+    }\n+\n+    fn advance(bodies: &mut [Body; N_BODIES], dt: f64) {\n+        const N: usize = N_BODIES * (N_BODIES - 1) / 2;\n+\n+        // compute distance between bodies:\n+        let mut r = [f64x4::splat(0.); N];\n+        {\n+            let mut i = 0;\n+            for j in 0..N_BODIES {\n+                for k in j + 1..N_BODIES {\n+                    r[i] = bodies[j].x - bodies[k].x;\n+                    i += 1;\n+                }\n+            }\n+        }\n+\n+        let mut mag = [0.0; N];\n+        for i in (0..N).step_by(2) {\n+            let d2s = f64x2::from_array([\n+                (r[i] * r[i]).horizontal_sum(),\n+                (r[i + 1] * r[i + 1]).horizontal_sum(),\n+            ]);\n+            let dmags = f64x2::splat(dt) / (d2s * d2s.sqrt());\n+            mag[i] = dmags[0];\n+            mag[i + 1] = dmags[1];\n+        }\n+\n+        let mut i = 0;\n+        for j in 0..N_BODIES {\n+            for k in j + 1..N_BODIES {\n+                let f = r[i] * mag[i];\n+                bodies[j].v -= f * bodies[k].mass;\n+                bodies[k].v += f * bodies[j].mass;\n+                i += 1\n+            }\n+        }\n+        for body in bodies {\n+            body.x += dt * body.v\n+        }\n+    }\n+\n+    pub fn run(n: usize) -> (f64, f64) {\n+        let mut bodies = BODIES;\n+        offset_momentum(&mut bodies);\n+        let energy_before = energy(&bodies);\n+        for _ in 0..n {\n+            advance(&mut bodies, 0.01);\n+        }\n+        let energy_after = energy(&bodies);\n+\n+        (energy_before, energy_after)\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+#[cfg(test)]\n+mod tests {\n+    // Good enough for demonstration purposes, not going for strictness here.\n+    fn approx_eq_f64(a: f64, b: f64) -> bool {\n+        (a - b).abs() < 0.00001\n+    }\n+    #[test]\n+    fn test() {\n+        const OUTPUT: [f64; 2] = [-0.169075164, -0.169087605];\n+        let (energy_before, energy_after) = super::nbody::run(1000);\n+        assert!(approx_eq_f64(energy_before, OUTPUT[0]));\n+        assert!(approx_eq_f64(energy_after, OUTPUT[1]));\n+    }\n+}\n+\n+fn main() {\n+    #[cfg(feature = \"std\")]\n+    {\n+        let (energy_before, energy_after) = nbody::run(1000);\n+        println!(\"Energy before: {}\", energy_before);\n+        println!(\"Energy after:  {}\", energy_after);\n+    }\n+}"}, {"sha": "8c51baca8ede38efa9f8faa26d1a51238d6049fb", "filename": "library/portable-simd/crates/core_simd/src/comparisons.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,50 @@\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    T: SimdElement + PartialEq,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n+    }\n+\n+    /// Test if each lane is not equal to the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    T: SimdElement + PartialOrd,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Test if each lane is less than the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+    }\n+\n+    /// Test if each lane is greater than the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+    }\n+\n+    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+    }\n+\n+    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+    }\n+}"}, {"sha": "15e8ed0253e140f2858711ac20613c844da8b929", "filename": "library/portable-simd/crates/core_simd/src/core_simd_docs.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcore_simd_docs.md", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcore_simd_docs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcore_simd_docs.md?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,4 @@\n+Portable SIMD module.\n+\n+This module offers a portable abstraction for SIMD operations\n+that is not bound to any particular hardware architecture."}, {"sha": "dbd9839c4bfe9c9c61a0a0264de08892fc43d26a", "filename": "library/portable-simd/crates/core_simd/src/fmt.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,39 @@\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::fmt;\n+\n+macro_rules! impl_fmt_trait {\n+    { $($trait:ident,)* } => {\n+        $(\n+            impl<T, const LANES: usize> fmt::$trait for Simd<T, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+                T: SimdElement + fmt::$trait,\n+            {\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    #[repr(transparent)]\n+                    struct Wrapper<'a, T: fmt::$trait>(&'a T);\n+\n+                    impl<T: fmt::$trait> fmt::Debug for Wrapper<'_, T> {\n+                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                            self.0.fmt(f)\n+                        }\n+                    }\n+\n+                    f.debug_list()\n+                        .entries(self.as_array().iter().map(|x| Wrapper(x)))\n+                        .finish()\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_fmt_trait! {\n+    Debug,\n+    Binary,\n+    LowerExp,\n+    UpperExp,\n+    Octal,\n+    LowerHex,\n+    UpperHex,\n+}"}, {"sha": "6a6d26d10a7f28354916c1dc4e55bb1d3728e01a", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,115 @@\n+//! This module contains the LLVM intrinsics bindings that provide the functionality for this\n+//! crate.\n+//!\n+//! The LLVM assembly language is documented here: <https://llvm.org/docs/LangRef.html>\n+\n+/// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n+/// simply lowered to the matching LLVM instructions by the compiler.  The associated instruction\n+/// is documented alongside each intrinsic.\n+extern \"platform-intrinsic\" {\n+    /// add/fadd\n+    pub(crate) fn simd_add<T>(x: T, y: T) -> T;\n+\n+    /// sub/fsub\n+    pub(crate) fn simd_sub<T>(x: T, y: T) -> T;\n+\n+    /// mul/fmul\n+    pub(crate) fn simd_mul<T>(x: T, y: T) -> T;\n+\n+    /// udiv/sdiv/fdiv\n+    pub(crate) fn simd_div<T>(x: T, y: T) -> T;\n+\n+    /// urem/srem/frem\n+    pub(crate) fn simd_rem<T>(x: T, y: T) -> T;\n+\n+    /// shl\n+    pub(crate) fn simd_shl<T>(x: T, y: T) -> T;\n+\n+    /// lshr/ashr\n+    pub(crate) fn simd_shr<T>(x: T, y: T) -> T;\n+\n+    /// and\n+    pub(crate) fn simd_and<T>(x: T, y: T) -> T;\n+\n+    /// or\n+    pub(crate) fn simd_or<T>(x: T, y: T) -> T;\n+\n+    /// xor\n+    pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n+\n+    /// fptoui/fptosi/uitofp/sitofp\n+    pub(crate) fn simd_cast<T, U>(x: T) -> U;\n+\n+    /// neg/fneg\n+    pub(crate) fn simd_neg<T>(x: T) -> T;\n+\n+    /// fabs\n+    pub(crate) fn simd_fabs<T>(x: T) -> T;\n+\n+    pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_le<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_gt<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;\n+\n+    // shufflevector\n+    pub(crate) fn simd_shuffle<T, U, V>(x: T, y: T, idx: U) -> V;\n+\n+    pub(crate) fn simd_gather<T, U, V>(val: T, ptr: U, mask: V) -> T;\n+    pub(crate) fn simd_scatter<T, U, V>(val: T, ptr: U, mask: V);\n+\n+    // {s,u}add.sat\n+    pub(crate) fn simd_saturating_add<T>(x: T, y: T) -> T;\n+\n+    // {s,u}sub.sat\n+    pub(crate) fn simd_saturating_sub<T>(x: T, y: T) -> T;\n+\n+    // reductions\n+    pub(crate) fn simd_reduce_add_ordered<T, U>(x: T, y: U) -> U;\n+    pub(crate) fn simd_reduce_mul_ordered<T, U>(x: T, y: U) -> U;\n+    #[allow(unused)]\n+    pub(crate) fn simd_reduce_all<T>(x: T) -> bool;\n+    #[allow(unused)]\n+    pub(crate) fn simd_reduce_any<T>(x: T) -> bool;\n+    pub(crate) fn simd_reduce_max<T, U>(x: T) -> U;\n+    pub(crate) fn simd_reduce_min<T, U>(x: T) -> U;\n+    pub(crate) fn simd_reduce_and<T, U>(x: T) -> U;\n+    pub(crate) fn simd_reduce_or<T, U>(x: T) -> U;\n+    pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;\n+\n+    // truncate integer vector to bitmask\n+    #[allow(unused)]\n+    pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n+\n+    // select\n+    pub(crate) fn simd_select<M, T>(m: M, a: T, b: T) -> T;\n+    #[allow(unused)]\n+    pub(crate) fn simd_select_bitmask<M, T>(m: M, a: T, b: T) -> T;\n+}\n+\n+#[cfg(feature = \"std\")]\n+mod std {\n+    extern \"platform-intrinsic\" {\n+        // ceil\n+        pub(crate) fn simd_ceil<T>(x: T) -> T;\n+\n+        // floor\n+        pub(crate) fn simd_floor<T>(x: T) -> T;\n+\n+        // round\n+        pub(crate) fn simd_round<T>(x: T) -> T;\n+\n+        // trunc\n+        pub(crate) fn simd_trunc<T>(x: T) -> T;\n+\n+        // fsqrt\n+        pub(crate) fn simd_fsqrt<T>(x: T) -> T;\n+\n+        // fma\n+        pub(crate) fn simd_fma<T>(x: T, y: T, z: T) -> T;\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+pub(crate) use crate::simd::intrinsics::std::*;"}, {"sha": "3275b4db8e49fba2c072b35826f3476e74713aec", "filename": "library/portable-simd/crates/core_simd/src/iter.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fiter.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,58 @@\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use core::{\n+    iter::{Product, Sum},\n+    ops::{Add, Mul},\n+};\n+\n+macro_rules! impl_traits {\n+    { $type:ty } => {\n+        impl<const LANES: usize> Sum<Self> for Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(0 as $type), Add::add)\n+            }\n+        }\n+\n+        impl<const LANES: usize> Product<Self> for Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(1 as $type), Mul::mul)\n+            }\n+        }\n+\n+        impl<'a, const LANES: usize> Sum<&'a Self> for Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(0 as $type), Add::add)\n+            }\n+        }\n+\n+        impl<'a, const LANES: usize> Product<&'a Self> for Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(1 as $type), Mul::mul)\n+            }\n+        }\n+    }\n+}\n+\n+impl_traits! { f32 }\n+impl_traits! { f64 }\n+impl_traits! { u8 }\n+impl_traits! { u16 }\n+impl_traits! { u32 }\n+impl_traits! { u64 }\n+impl_traits! { usize }\n+impl_traits! { i8 }\n+impl_traits! { i16 }\n+impl_traits! { i32 }\n+impl_traits! { i64 }\n+impl_traits! { isize }"}, {"sha": "b017e7d137e308293c8ecd921674d33794565e27", "filename": "library/portable-simd/crates/core_simd/src/lane_count.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,48 @@\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+use sealed::Sealed;\n+\n+/// A type representing a vector lane count.\n+pub struct LaneCount<const LANES: usize>;\n+\n+impl<const LANES: usize> LaneCount<LANES> {\n+    /// The number of bytes in a bitmask with this many lanes.\n+    pub const BITMASK_LEN: usize = (LANES + 7) / 8;\n+}\n+\n+/// Helper trait for vector lane counts.\n+pub trait SupportedLaneCount: Sealed {\n+    #[doc(hidden)]\n+    type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n+\n+    #[doc(hidden)]\n+    type IntBitMask;\n+}\n+\n+impl<const LANES: usize> Sealed for LaneCount<LANES> {}\n+\n+impl SupportedLaneCount for LaneCount<1> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<2> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<4> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<8> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<16> {\n+    type BitMask = [u8; 2];\n+    type IntBitMask = u16;\n+}\n+impl SupportedLaneCount for LaneCount<32> {\n+    type BitMask = [u8; 4];\n+    type IntBitMask = u32;\n+}"}, {"sha": "960a66400839fee40c374fd22686cacba19d0c45", "filename": "library/portable-simd/crates/core_simd/src/lib.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,21 @@\n+#![cfg_attr(not(feature = \"std\"), no_std)]\n+#![feature(\n+    const_fn_trait_bound,\n+    decl_macro,\n+    platform_intrinsics,\n+    repr_simd,\n+    simd_ffi,\n+    staged_api,\n+    stdsimd\n+)]\n+#![cfg_attr(feature = \"generic_const_exprs\", feature(generic_const_exprs))]\n+#![cfg_attr(feature = \"generic_const_exprs\", allow(incomplete_features))]\n+#![warn(missing_docs)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n+#![unstable(feature = \"portable_simd\", issue = \"86656\")]\n+//! Portable SIMD module.\n+\n+#[path = \"mod.rs\"]\n+mod core_simd;\n+pub use self::core_simd::simd;\n+pub use simd::*;"}, {"sha": "d460da0d04f86692d968e6df81645b2e87a901f9", "filename": "library/portable-simd/crates/core_simd/src/masks.rs", "status": "added", "additions": 545, "deletions": 0, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,545 @@\n+//! Types and traits associated with masking lanes of vectors.\n+//! Types representing\n+#![allow(non_camel_case_types)]\n+\n+#[cfg_attr(\n+    not(all(target_arch = \"x86_64\", target_feature = \"avx512f\")),\n+    path = \"masks/full_masks.rs\"\n+)]\n+#[cfg_attr(\n+    all(target_arch = \"x86_64\", target_feature = \"avx512f\"),\n+    path = \"masks/bitmask.rs\"\n+)]\n+mod mask_impl;\n+\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::cmp::Ordering;\n+use core::fmt;\n+\n+mod sealed {\n+    use super::*;\n+\n+    /// Not only does this seal the `MaskElement` trait, but these functions prevent other traits\n+    /// from bleeding into the parent bounds.\n+    ///\n+    /// For example, `eq` could be provided by requiring `MaskElement: PartialEq`, but that would\n+    /// prevent us from ever removing that bound, or from implementing `MaskElement` on\n+    /// non-`PartialEq` types in the future.\n+    pub trait Sealed {\n+        fn valid<const LANES: usize>(values: Simd<Self, LANES>) -> bool\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+            Self: SimdElement;\n+\n+        fn eq(self, other: Self) -> bool;\n+\n+        const TRUE: Self;\n+\n+        const FALSE: Self;\n+    }\n+}\n+use sealed::Sealed;\n+\n+/// Marker trait for types that may be used as SIMD mask elements.\n+pub unsafe trait MaskElement: SimdElement + Sealed {}\n+\n+macro_rules! impl_element {\n+    { $ty:ty } => {\n+        impl Sealed for $ty {\n+            fn valid<const LANES: usize>(value: Simd<Self, LANES>) -> bool\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                (value.lanes_eq(Simd::splat(0)) | value.lanes_eq(Simd::splat(-1))).all()\n+            }\n+\n+            fn eq(self, other: Self) -> bool { self == other }\n+\n+            const TRUE: Self = -1;\n+            const FALSE: Self = 0;\n+        }\n+\n+        unsafe impl MaskElement for $ty {}\n+    }\n+}\n+\n+impl_element! { i8 }\n+impl_element! { i16 }\n+impl_element! { i32 }\n+impl_element! { i64 }\n+impl_element! { isize }\n+\n+/// A SIMD vector mask for `LANES` elements of width specified by `Element`.\n+///\n+/// The layout of this type is unspecified.\n+#[repr(transparent)]\n+pub struct Mask<T, const LANES: usize>(mask_impl::Mask<T, LANES>)\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount;\n+\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<T, const LANES: usize> Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Construct a mask by setting all lanes to the given value.\n+    pub fn splat(value: bool) -> Self {\n+        Self(mask_impl::Mask::splat(value))\n+    }\n+\n+    /// Converts an array to a SIMD vector.\n+    pub fn from_array(array: [bool; LANES]) -> Self {\n+        let mut vector = Self::splat(false);\n+        for (i, v) in array.iter().enumerate() {\n+            vector.set(i, *v);\n+        }\n+        vector\n+    }\n+\n+    /// Converts a SIMD vector to an array.\n+    pub fn to_array(self) -> [bool; LANES] {\n+        let mut array = [false; LANES];\n+        for (i, v) in array.iter_mut().enumerate() {\n+            *v = self.test(i);\n+        }\n+        array\n+    }\n+\n+    /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n+    /// represents `true`.\n+    ///\n+    /// # Safety\n+    /// All lanes must be either 0 or -1.\n+    #[inline]\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n+        unsafe { Self(mask_impl::Mask::from_int_unchecked(value)) }\n+    }\n+\n+    /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n+    /// represents `true`.\n+    ///\n+    /// # Panics\n+    /// Panics if any lane is not 0 or -1.\n+    #[inline]\n+    pub fn from_int(value: Simd<T, LANES>) -> Self {\n+        assert!(T::valid(value), \"all values must be either 0 or -1\",);\n+        unsafe { Self::from_int_unchecked(value) }\n+    }\n+\n+    /// Converts the mask to a vector of integers, where 0 represents `false` and -1\n+    /// represents `true`.\n+    #[inline]\n+    pub fn to_int(self) -> Simd<T, LANES> {\n+        self.0.to_int()\n+    }\n+\n+    /// Tests the value of the specified lane.\n+    ///\n+    /// # Safety\n+    /// `lane` must be less than `LANES`.\n+    #[inline]\n+    pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        unsafe { self.0.test_unchecked(lane) }\n+    }\n+\n+    /// Tests the value of the specified lane.\n+    ///\n+    /// # Panics\n+    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+    #[inline]\n+    pub fn test(&self, lane: usize) -> bool {\n+        assert!(lane < LANES, \"lane index out of range\");\n+        unsafe { self.test_unchecked(lane) }\n+    }\n+\n+    /// Sets the value of the specified lane.\n+    ///\n+    /// # Safety\n+    /// `lane` must be less than `LANES`.\n+    #[inline]\n+    pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        unsafe {\n+            self.0.set_unchecked(lane, value);\n+        }\n+    }\n+\n+    /// Sets the value of the specified lane.\n+    ///\n+    /// # Panics\n+    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+    #[inline]\n+    pub fn set(&mut self, lane: usize, value: bool) {\n+        assert!(lane < LANES, \"lane index out of range\");\n+        unsafe {\n+            self.set_unchecked(lane, value);\n+        }\n+    }\n+\n+    /// Convert this mask to a bitmask, with one bit set per lane.\n+    #[cfg(feature = \"generic_const_exprs\")]\n+    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n+        self.0.to_bitmask()\n+    }\n+\n+    /// Convert a bitmask to a mask.\n+    #[cfg(feature = \"generic_const_exprs\")]\n+    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n+        Self(mask_impl::Mask::from_bitmask(bitmask))\n+    }\n+\n+    /// Returns true if any lane is set, or false otherwise.\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        self.0.any()\n+    }\n+\n+    /// Returns true if all lanes are set, or false otherwise.\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        self.0.all()\n+    }\n+}\n+\n+// vector/array conversion\n+impl<T, const LANES: usize> From<[bool; LANES]> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn from(array: [bool; LANES]) -> Self {\n+        Self::from_array(array)\n+    }\n+}\n+\n+impl<T, const LANES: usize> From<Mask<T, LANES>> for [bool; LANES]\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn from(vector: Mask<T, LANES>) -> Self {\n+        vector.to_array()\n+    }\n+}\n+\n+impl<T, const LANES: usize> Default for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn default() -> Self {\n+        Self::splat(false)\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n+where\n+    T: MaskElement + PartialEq,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 == other.0\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n+where\n+    T: MaskElement + PartialOrd,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.0.partial_cmp(&other.0)\n+    }\n+}\n+\n+impl<T, const LANES: usize> fmt::Debug for Mask<T, LANES>\n+where\n+    T: MaskElement + fmt::Debug,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list()\n+            .entries((0..LANES).map(|lane| self.test(lane)))\n+            .finish()\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: Self) -> Self {\n+        Self(self.0 & rhs.0)\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitAnd<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: bool) -> Self {\n+        self & Self::splat(rhs)\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitAnd<Mask<T, LANES>> for bool\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Mask<T, LANES>;\n+    #[inline]\n+    fn bitand(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n+        Mask::splat(self) & rhs\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: Self) -> Self {\n+        Self(self.0 | rhs.0)\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitOr<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: bool) -> Self {\n+        self | Self::splat(rhs)\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitOr<Mask<T, LANES>> for bool\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Mask<T, LANES>;\n+    #[inline]\n+    fn bitor(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n+        Mask::splat(self) | rhs\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: Self) -> Self::Output {\n+        Self(self.0 ^ rhs.0)\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitXor<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: bool) -> Self::Output {\n+        self ^ Self::splat(rhs)\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitXor<Mask<T, LANES>> for bool\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Mask<T, LANES>;\n+    #[inline]\n+    fn bitxor(self, rhs: Mask<T, LANES>) -> Self::Output {\n+        Mask::splat(self) ^ rhs\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Mask<T, LANES>;\n+    #[inline]\n+    fn not(self) -> Self::Output {\n+        Self(!self.0)\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitAndAssign for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitand_assign(&mut self, rhs: Self) {\n+        self.0 = self.0 & rhs.0;\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitAndAssign<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitand_assign(&mut self, rhs: bool) {\n+        *self &= Self::splat(rhs);\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitOrAssign for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        self.0 = self.0 | rhs.0;\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitOrAssign<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitor_assign(&mut self, rhs: bool) {\n+        *self |= Self::splat(rhs);\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitXorAssign for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: Self) {\n+        self.0 = self.0 ^ rhs.0;\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitXorAssign<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: bool) {\n+        *self ^= Self::splat(rhs);\n+    }\n+}\n+\n+/// Vector of eight 8-bit masks\n+pub type mask8x8 = Mask<i8, 8>;\n+\n+/// Vector of 16 8-bit masks\n+pub type mask8x16 = Mask<i8, 16>;\n+\n+/// Vector of 32 8-bit masks\n+pub type mask8x32 = Mask<i8, 32>;\n+\n+/// Vector of 16 8-bit masks\n+pub type mask8x64 = Mask<i8, 64>;\n+\n+/// Vector of four 16-bit masks\n+pub type mask16x4 = Mask<i16, 4>;\n+\n+/// Vector of eight 16-bit masks\n+pub type mask16x8 = Mask<i16, 8>;\n+\n+/// Vector of 16 16-bit masks\n+pub type mask16x16 = Mask<i16, 16>;\n+\n+/// Vector of 32 16-bit masks\n+pub type mask16x32 = Mask<i32, 32>;\n+\n+/// Vector of two 32-bit masks\n+pub type mask32x2 = Mask<i32, 2>;\n+\n+/// Vector of four 32-bit masks\n+pub type mask32x4 = Mask<i32, 4>;\n+\n+/// Vector of eight 32-bit masks\n+pub type mask32x8 = Mask<i32, 8>;\n+\n+/// Vector of 16 32-bit masks\n+pub type mask32x16 = Mask<i32, 16>;\n+\n+/// Vector of two 64-bit masks\n+pub type mask64x2 = Mask<i64, 2>;\n+\n+/// Vector of four 64-bit masks\n+pub type mask64x4 = Mask<i64, 4>;\n+\n+/// Vector of eight 64-bit masks\n+pub type mask64x8 = Mask<i64, 8>;\n+\n+/// Vector of two pointer-width masks\n+pub type masksizex2 = Mask<isize, 2>;\n+\n+/// Vector of four pointer-width masks\n+pub type masksizex4 = Mask<isize, 4>;\n+\n+/// Vector of eight pointer-width masks\n+pub type masksizex8 = Mask<isize, 8>;\n+\n+macro_rules! impl_from {\n+    { $from:ty  => $($to:ty),* } => {\n+        $(\n+        impl<const LANES: usize> From<Mask<$from, LANES>> for Mask<$to, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            fn from(value: Mask<$from, LANES>) -> Self {\n+                Self(value.0.convert())\n+            }\n+        }\n+        )*\n+    }\n+}\n+impl_from! { i8 => i16, i32, i64, isize }\n+impl_from! { i16 => i32, i64, isize, i8 }\n+impl_from! { i32 => i64, isize, i8, i16 }\n+impl_from! { i64 => isize, i8, i16, i32 }\n+impl_from! { isize => i8, i16, i32, i64 }"}, {"sha": "2689e1a88a8c4b4256d0262244c0b6170489778b", "filename": "library/portable-simd/crates/core_simd/src/masks/bitmask.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,220 @@\n+use super::MaskElement;\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use core::marker::PhantomData;\n+\n+/// A mask where each lane is represented by a single bit.\n+#[repr(transparent)]\n+pub struct Mask<T, const LANES: usize>(\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask,\n+    PhantomData<T>,\n+)\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount;\n+\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.as_ref() == other.0.as_ref()\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        self.0.as_ref().partial_cmp(other.0.as_ref())\n+    }\n+}\n+\n+impl<T, const LANES: usize> Eq for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Ord for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        self.0.as_ref().cmp(other.0.as_ref())\n+    }\n+}\n+\n+impl<T, const LANES: usize> Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    pub fn splat(value: bool) -> Self {\n+        let mut mask = <LaneCount<LANES> as SupportedLaneCount>::BitMask::default();\n+        if value {\n+            mask.as_mut().fill(u8::MAX)\n+        } else {\n+            mask.as_mut().fill(u8::MIN)\n+        }\n+        if LANES % 8 > 0 {\n+            *mask.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n+        }\n+        Self(mask, PhantomData)\n+    }\n+\n+    #[inline]\n+    pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        (self.0.as_ref()[lane / 8] >> (lane % 8)) & 0x1 > 0\n+    }\n+\n+    #[inline]\n+    pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        unsafe {\n+            self.0.as_mut()[lane / 8] ^= ((value ^ self.test_unchecked(lane)) as u8) << (lane % 8)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_int(self) -> Simd<T, LANES> {\n+        unsafe {\n+            let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+                core::mem::transmute_copy(&self);\n+            intrinsics::simd_select_bitmask(mask, Simd::splat(T::TRUE), Simd::splat(T::FALSE))\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n+        // TODO remove the transmute when rustc is more flexible\n+        assert_eq!(\n+            core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::BitMask>(),\n+            core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n+        );\n+        unsafe {\n+            let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+                intrinsics::simd_bitmask(value);\n+            Self(core::mem::transmute_copy(&mask), PhantomData)\n+        }\n+    }\n+\n+    #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n+        // Safety: these are the same type and we are laundering the generic\n+        unsafe { core::mem::transmute_copy(&self.0) }\n+    }\n+\n+    #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n+        // Safety: these are the same type and we are laundering the generic\n+        Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n+    }\n+\n+    #[inline]\n+    pub fn convert<U>(self) -> Mask<U, LANES>\n+    where\n+        U: MaskElement,\n+    {\n+        unsafe { core::mem::transmute_copy(&self) }\n+    }\n+\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        self != Self::splat(false)\n+    }\n+\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        self == Self::splat(true)\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask: AsRef<[u8]> + AsMut<[u8]>,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(mut self, rhs: Self) -> Self {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l &= r;\n+        }\n+        self\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask: AsRef<[u8]> + AsMut<[u8]>,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(mut self, rhs: Self) -> Self {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l |= r;\n+        }\n+        self\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(mut self, rhs: Self) -> Self::Output {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l ^= r;\n+        }\n+        self\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn not(mut self) -> Self::Output {\n+        for x in self.0.as_mut() {\n+            *x = !*x;\n+        }\n+        if LANES % 8 > 0 {\n+            *self.0.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n+        }\n+        self\n+    }\n+}"}, {"sha": "dd981cedb932b4c57681caebb9282a012780a375", "filename": "library/portable-simd/crates/core_simd/src/masks/full_masks.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,228 @@\n+//! Masks that take up full SIMD vector registers.\n+\n+use super::MaskElement;\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+\n+#[repr(transparent)]\n+pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount;\n+\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n+where\n+    T: MaskElement + PartialEq,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.eq(&other.0)\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n+where\n+    T: MaskElement + PartialOrd,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        self.0.partial_cmp(&other.0)\n+    }\n+}\n+\n+impl<T, const LANES: usize> Eq for Mask<T, LANES>\n+where\n+    T: MaskElement + Eq,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Ord for Mask<T, LANES>\n+where\n+    T: MaskElement + Ord,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        self.0.cmp(&other.0)\n+    }\n+}\n+\n+impl<T, const LANES: usize> Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    pub fn splat(value: bool) -> Self {\n+        Self(Simd::splat(if value { T::TRUE } else { T::FALSE }))\n+    }\n+\n+    #[inline]\n+    pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        T::eq(self.0[lane], T::TRUE)\n+    }\n+\n+    #[inline]\n+    pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        self.0[lane] = if value { T::TRUE } else { T::FALSE }\n+    }\n+\n+    #[inline]\n+    pub fn to_int(self) -> Simd<T, LANES> {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n+        Self(value)\n+    }\n+\n+    #[inline]\n+    pub fn convert<U>(self) -> Mask<U, LANES>\n+    where\n+        U: MaskElement,\n+    {\n+        unsafe { Mask(intrinsics::simd_cast(self.0)) }\n+    }\n+\n+    #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n+        unsafe {\n+            // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n+            assert_eq!(\n+                core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n+                LaneCount::<LANES>::BITMASK_LEN,\n+            );\n+            let bitmask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+                intrinsics::simd_bitmask(self.0);\n+            let mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN] =\n+                core::mem::transmute_copy(&bitmask);\n+\n+            // There is a bug where LLVM appears to implement this operation with the wrong\n+            // bit order.\n+            // TODO fix this in a better way\n+            if cfg!(target_endian = \"big\") {\n+                for x in bitmask.as_mut() {\n+                    *x = x.reverse_bits();\n+                }\n+            }\n+\n+            bitmask\n+        }\n+    }\n+\n+    #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    pub fn from_bitmask(mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n+        unsafe {\n+            // There is a bug where LLVM appears to implement this operation with the wrong\n+            // bit order.\n+            // TODO fix this in a better way\n+            if cfg!(target_endian = \"big\") {\n+                for x in bitmask.as_mut() {\n+                    *x = x.reverse_bits();\n+                }\n+            }\n+\n+            // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n+            assert_eq!(\n+                core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n+                LaneCount::<LANES>::BITMASK_LEN,\n+            );\n+            let bitmask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+                core::mem::transmute_copy(&bitmask);\n+\n+            Self::from_int_unchecked(intrinsics::simd_select_bitmask(\n+                bitmask,\n+                Self::splat(true).to_int(),\n+                Self::splat(false).to_int(),\n+            ))\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        unsafe { intrinsics::simd_reduce_any(self.to_int()) }\n+    }\n+\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        unsafe { intrinsics::simd_reduce_all(self.to_int()) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::convert::From<Mask<T, LANES>> for Simd<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn from(value: Mask<T, LANES>) -> Self {\n+        value.0\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: Self) -> Self {\n+        unsafe { Self(intrinsics::simd_and(self.0, rhs.0)) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: Self) -> Self {\n+        unsafe { Self(intrinsics::simd_or(self.0, rhs.0)) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: Self) -> Self {\n+        unsafe { Self(intrinsics::simd_xor(self.0, rhs.0)) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn not(self) -> Self::Output {\n+        Self::splat(true) ^ self\n+    }\n+}"}, {"sha": "2bae414ebfb5494621051e09554287683b3e10a7", "filename": "library/portable-simd/crates/core_simd/src/math.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,159 @@\n+use crate::simd::intrinsics::{simd_saturating_add, simd_saturating_sub};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+\n+macro_rules! impl_uint_arith {\n+    ($($ty:ty),+) => {\n+        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n+\n+            /// Lanewise saturating add.\n+            ///\n+            /// # Examples\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n+            /// let x = Simd::from_array([2, 1, 0, MAX]);\n+            /// let max = Simd::splat(MAX);\n+            /// let unsat = x + max;\n+            /// let sat = x.saturating_add(max);\n+            /// assert_eq!(x - 1, unsat);\n+            /// assert_eq!(sat, max);\n+            /// ```\n+            #[inline]\n+            pub fn saturating_add(self, second: Self) -> Self {\n+                unsafe { simd_saturating_add(self, second) }\n+            }\n+\n+            /// Lanewise saturating subtract.\n+            ///\n+            /// # Examples\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n+            /// let x = Simd::from_array([2, 1, 0, MAX]);\n+            /// let max = Simd::splat(MAX);\n+            /// let unsat = x - max;\n+            /// let sat = x.saturating_sub(max);\n+            /// assert_eq!(unsat, x + 1);\n+            /// assert_eq!(sat, Simd::splat(0));\n+            #[inline]\n+            pub fn saturating_sub(self, second: Self) -> Self {\n+                unsafe { simd_saturating_sub(self, second) }\n+            }\n+        })+\n+    }\n+}\n+\n+macro_rules! impl_int_arith {\n+    ($($ty:ty),+) => {\n+        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n+\n+            /// Lanewise saturating add.\n+            ///\n+            /// # Examples\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n+            /// let max = Simd::splat(MAX);\n+            /// let unsat = x + max;\n+            /// let sat = x.saturating_add(max);\n+            /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n+            /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n+            /// ```\n+            #[inline]\n+            pub fn saturating_add(self, second: Self) -> Self {\n+                unsafe { simd_saturating_add(self, second) }\n+            }\n+\n+            /// Lanewise saturating subtract.\n+            ///\n+            /// # Examples\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n+            /// let max = Simd::splat(MAX);\n+            /// let unsat = x - max;\n+            /// let sat = x.saturating_sub(max);\n+            /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n+            /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n+            #[inline]\n+            pub fn saturating_sub(self, second: Self) -> Self {\n+                unsafe { simd_saturating_sub(self, second) }\n+            }\n+\n+            /// Lanewise absolute value, implemented in Rust.\n+            /// Every lane becomes its absolute value.\n+            ///\n+            /// # Examples\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n+            /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n+            /// ```\n+            #[inline]\n+            pub fn abs(self) -> Self {\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n+                let m = self >> SHR;\n+                (self^m) - m\n+            }\n+\n+            /// Lanewise saturating absolute value, implemented in Rust.\n+            /// As abs(), except the MIN value becomes MAX instead of itself.\n+            ///\n+            /// # Examples\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n+            /// let unsat = xs.abs();\n+            /// let sat = xs.saturating_abs();\n+            /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n+            /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n+            /// ```\n+            #[inline]\n+            pub fn saturating_abs(self) -> Self {\n+                // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n+                let m = self >> SHR;\n+                (self^m).saturating_sub(m)\n+            }\n+\n+            /// Lanewise saturating negation, implemented in Rust.\n+            /// As neg(), except the MIN value becomes MAX instead of itself.\n+            ///\n+            /// # Examples\n+            /// ```\n+            /// # #![feature(portable_simd)]\n+            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n+            /// let unsat = -x;\n+            /// let sat = x.saturating_neg();\n+            /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n+            /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n+            /// ```\n+            #[inline]\n+            pub fn saturating_neg(self) -> Self {\n+                Self::splat(0).saturating_sub(self)\n+            }\n+        })+\n+    }\n+}\n+\n+impl_uint_arith! { u8, u16, u32, u64, usize }\n+impl_int_arith! { i8, i16, i32, i64, isize }"}, {"sha": "ec874a22389d4e789281a2b15e2afe893b341de0", "filename": "library/portable-simd/crates/core_simd/src/mod.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,33 @@\n+#[macro_use]\n+mod reduction;\n+\n+#[macro_use]\n+mod swizzle;\n+\n+pub(crate) mod intrinsics;\n+\n+#[cfg(feature = \"generic_const_exprs\")]\n+mod to_bytes;\n+\n+mod comparisons;\n+mod fmt;\n+mod iter;\n+mod lane_count;\n+mod masks;\n+mod math;\n+mod ops;\n+mod round;\n+mod select;\n+mod vector;\n+mod vendor;\n+\n+#[doc = include_str!(\"core_simd_docs.md\")]\n+pub mod simd {\n+    pub(crate) use crate::core_simd::intrinsics;\n+\n+    pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};\n+    pub use crate::core_simd::masks::*;\n+    pub use crate::core_simd::select::Select;\n+    pub use crate::core_simd::swizzle::*;\n+    pub use crate::core_simd::vector::*;\n+}"}, {"sha": "5d7af474caf7005c9045bcb5e9cc99b226ae7872", "filename": "library/portable-simd/crates/core_simd/src/ops.rs", "status": "added", "additions": 644, "deletions": 0, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,644 @@\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+\n+impl<I, T, const LANES: usize> core::ops::Index<I> for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    I: core::slice::SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+    fn index(&self, index: I) -> &Self::Output {\n+        &self.as_array()[index]\n+    }\n+}\n+\n+impl<I, T, const LANES: usize> core::ops::IndexMut<I> for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    I: core::slice::SliceIndex<[T]>,\n+{\n+    fn index_mut(&mut self, index: I) -> &mut Self::Output {\n+        &mut self.as_mut_array()[index]\n+    }\n+}\n+\n+/// Checks if the right-hand side argument of a left- or right-shift would cause overflow.\n+fn invalid_shift_rhs<T>(rhs: T) -> bool\n+where\n+    T: Default + PartialOrd + core::convert::TryFrom<usize>,\n+    <T as core::convert::TryFrom<usize>>::Error: core::fmt::Debug,\n+{\n+    let bits_in_type = T::try_from(8 * core::mem::size_of::<T>()).unwrap();\n+    rhs < T::default() || rhs >= bits_in_type\n+}\n+\n+/// Automatically implements operators over references in addition to the provided operator.\n+macro_rules! impl_ref_ops {\n+    // binary op\n+    {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n+        where\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n+        {\n+            type Output = $output:ty;\n+\n+            $(#[$attrs:meta])*\n+            fn $fn:ident($self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) -> Self::Output $body:tt\n+        }\n+    } => {\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n+        where\n+            LaneCount<$lanes2>: SupportedLaneCount,\n+        {\n+            type Output = $output;\n+\n+            $(#[$attrs])*\n+            fn $fn($self_tok, $rhs_arg: $rhs_arg_ty) -> Self::Output $body\n+        }\n+\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n+        where\n+            LaneCount<$lanes2>: SupportedLaneCount,\n+        {\n+            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n+\n+            $(#[$attrs])*\n+            fn $fn($self_tok, $rhs_arg: &$rhs) -> Self::Output {\n+                core::ops::$trait::$fn($self_tok, *$rhs_arg)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for &'_ $type\n+        where\n+            LaneCount<$lanes2>: SupportedLaneCount,\n+        {\n+            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n+\n+            $(#[$attrs])*\n+            fn $fn($self_tok, $rhs_arg: $rhs) -> Self::Output {\n+                core::ops::$trait::$fn(*$self_tok, $rhs_arg)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for &'_ $type\n+        where\n+            LaneCount<$lanes2>: SupportedLaneCount,\n+        {\n+            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n+\n+            $(#[$attrs])*\n+            fn $fn($self_tok, $rhs_arg: &$rhs) -> Self::Output {\n+                core::ops::$trait::$fn(*$self_tok, *$rhs_arg)\n+            }\n+        }\n+    };\n+\n+    // binary assignment op\n+    {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n+        where\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n+        {\n+            $(#[$attrs:meta])*\n+            fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n+        }\n+    } => {\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n+        where\n+            LaneCount<$lanes2>: SupportedLaneCount,\n+        {\n+            $(#[$attrs])*\n+            fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n+        }\n+\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n+        where\n+            LaneCount<$lanes2>: SupportedLaneCount,\n+        {\n+            $(#[$attrs])*\n+            fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n+                core::ops::$trait::$fn($self_tok, *$rhs_arg)\n+            }\n+        }\n+    };\n+\n+    // unary op\n+    {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty\n+        where\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n+        {\n+            type Output = $output:ty;\n+            fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n+        }\n+    } => {\n+        impl<const $lanes: usize> core::ops::$trait for $type\n+        where\n+            LaneCount<$lanes2>: SupportedLaneCount,\n+        {\n+            type Output = $output;\n+            fn $fn($self_tok) -> Self::Output $body\n+        }\n+\n+        impl<const $lanes: usize> core::ops::$trait for &'_ $type\n+        where\n+            LaneCount<$lanes2>: SupportedLaneCount,\n+        {\n+            type Output = <$type as core::ops::$trait>::Output;\n+            fn $fn($self_tok) -> Self::Output {\n+                core::ops::$trait::$fn(*$self_tok)\n+            }\n+        }\n+    }\n+}\n+\n+/// Automatically implements operators over vectors and scalars for a particular vector.\n+macro_rules! impl_op {\n+    { impl Add for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Add::add, AddAssign::add_assign, simd_add }\n+    };\n+    { impl Sub for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n+    };\n+    { impl Mul for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n+    };\n+    { impl Div for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Div::div, DivAssign::div_assign, simd_div }\n+    };\n+    { impl Rem for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n+    };\n+    { impl Shl for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n+    };\n+    { impl Shr for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n+    };\n+    { impl BitAnd for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n+    };\n+    { impl BitOr for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n+    };\n+    { impl BitXor for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n+    };\n+\n+    { impl Not for $scalar:ty } => {\n+        impl_ref_ops! {\n+            impl<const LANES: usize> core::ops::Not for Simd<$scalar, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                type Output = Self;\n+                fn not(self) -> Self::Output {\n+                    self ^ Self::splat(!<$scalar>::default())\n+                }\n+            }\n+        }\n+    };\n+\n+    { impl Neg for $scalar:ty } => {\n+        impl_ref_ops! {\n+            impl<const LANES: usize> core::ops::Neg for Simd<$scalar, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                type Output = Self;\n+                fn neg(self) -> Self::Output {\n+                    unsafe { intrinsics::simd_neg(self) }\n+                }\n+            }\n+        }\n+    };\n+\n+    // generic binary op with assignment when output is `Self`\n+    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+        impl_ref_ops! {\n+            impl<const LANES: usize> core::ops::$trait<Self> for Simd<$scalar, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                type Output = Self;\n+\n+                #[inline]\n+                fn $trait_fn(self, rhs: Self) -> Self::Output {\n+                    unsafe {\n+                        intrinsics::$intrinsic(self, rhs)\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl_ref_ops! {\n+            impl<const LANES: usize> core::ops::$trait<$scalar> for Simd<$scalar, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                type Output = Self;\n+\n+                #[inline]\n+                fn $trait_fn(self, rhs: $scalar) -> Self::Output {\n+                    core::ops::$trait::$trait_fn(self, Self::splat(rhs))\n+                }\n+            }\n+        }\n+\n+        impl_ref_ops! {\n+            impl<const LANES: usize> core::ops::$trait<Simd<$scalar, LANES>> for $scalar\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                type Output = Simd<$scalar, LANES>;\n+\n+                #[inline]\n+                fn $trait_fn(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                    core::ops::$trait::$trait_fn(Simd::splat(self), rhs)\n+                }\n+            }\n+        }\n+\n+        impl_ref_ops! {\n+            impl<const LANES: usize> core::ops::$assign_trait<Self> for Simd<$scalar, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                #[inline]\n+                fn $assign_trait_fn(&mut self, rhs: Self) {\n+                    unsafe {\n+                        *self = intrinsics::$intrinsic(*self, rhs);\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl_ref_ops! {\n+            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for Simd<$scalar, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                #[inline]\n+                fn $assign_trait_fn(&mut self, rhs: $scalar) {\n+                    core::ops::$assign_trait::$assign_trait_fn(self, Self::splat(rhs));\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+/// Implements floating-point operators for the provided types.\n+macro_rules! impl_float_ops {\n+    { $($scalar:ty),* } => {\n+        $(\n+            impl_op! { impl Add for $scalar }\n+            impl_op! { impl Sub for $scalar }\n+            impl_op! { impl Mul for $scalar }\n+            impl_op! { impl Div for $scalar }\n+            impl_op! { impl Rem for $scalar }\n+            impl_op! { impl Neg for $scalar }\n+        )*\n+    };\n+}\n+\n+/// Implements unsigned integer operators for the provided types.\n+macro_rules! impl_unsigned_int_ops {\n+    { $($scalar:ty),* } => {\n+        $(\n+            impl_op! { impl Add for $scalar }\n+            impl_op! { impl Sub for $scalar }\n+            impl_op! { impl Mul for $scalar }\n+            impl_op! { impl BitAnd for $scalar }\n+            impl_op! { impl BitOr  for $scalar }\n+            impl_op! { impl BitXor for $scalar }\n+            impl_op! { impl Not for $scalar }\n+\n+            // Integers panic on divide by 0\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn div(self, rhs: Self) -> Self::Output {\n+                        if rhs.as_array()\n+                            .iter()\n+                            .any(|x| *x == 0)\n+                        {\n+                            panic!(\"attempt to divide by zero\");\n+                        }\n+\n+                        // Guards for div(MIN, -1),\n+                        // this check only applies to signed ints\n+                        if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                .zip(rhs.as_array().iter())\n+                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                            panic!(\"attempt to divide with overflow\");\n+                        }\n+                        unsafe { intrinsics::simd_div(self, rhs) }\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn div(self, rhs: $scalar) -> Self::Output {\n+                        if rhs == 0 {\n+                            panic!(\"attempt to divide by zero\");\n+                        }\n+                        if <$scalar>::MIN != 0 &&\n+                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n+                            rhs == -1 as _ {\n+                                panic!(\"attempt to divide with overflow\");\n+                        }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { intrinsics::simd_div(self, rhs) }\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<Simd<$scalar, LANES>> for $scalar\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Simd<$scalar, LANES>;\n+\n+                    #[inline]\n+                    fn div(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                        Simd::splat(self) / rhs\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::DivAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn div_assign(&mut self, rhs: Self) {\n+                        *self = *self / rhs;\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::DivAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn div_assign(&mut self, rhs: $scalar) {\n+                        *self = *self / rhs;\n+                    }\n+                }\n+            }\n+\n+            // remainder panics on zero divisor\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn rem(self, rhs: Self) -> Self::Output {\n+                        if rhs.as_array()\n+                            .iter()\n+                            .any(|x| *x == 0)\n+                        {\n+                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n+                        }\n+\n+                        // Guards for rem(MIN, -1)\n+                        // this branch applies the check only to signed ints\n+                        if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                .zip(rhs.as_array().iter())\n+                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                            panic!(\"attempt to calculate the remainder with overflow\");\n+                        }\n+                        unsafe { intrinsics::simd_rem(self, rhs) }\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn rem(self, rhs: $scalar) -> Self::Output {\n+                        if rhs == 0 {\n+                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n+                        }\n+                        if <$scalar>::MIN != 0 &&\n+                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n+                            rhs == -1 as _ {\n+                                panic!(\"attempt to calculate the remainder with overflow\");\n+                        }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { intrinsics::simd_rem(self, rhs) }\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<Simd<$scalar, LANES>> for $scalar\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Simd<$scalar, LANES>;\n+\n+                    #[inline]\n+                    fn rem(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                        Simd::splat(self) % rhs\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::RemAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn rem_assign(&mut self, rhs: Self) {\n+                        *self = *self % rhs;\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::RemAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn rem_assign(&mut self, rhs: $scalar) {\n+                        *self = *self % rhs;\n+                    }\n+                }\n+            }\n+\n+            // shifts panic on overflow\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shl<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shl(self, rhs: Self) -> Self::Output {\n+                        // TODO there is probably a better way of doing this\n+                        if rhs.as_array()\n+                            .iter()\n+                            .copied()\n+                            .any(invalid_shift_rhs)\n+                        {\n+                            panic!(\"attempt to shift left with overflow\");\n+                        }\n+                        unsafe { intrinsics::simd_shl(self, rhs) }\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shl<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shl(self, rhs: $scalar) -> Self::Output {\n+                        if invalid_shift_rhs(rhs) {\n+                            panic!(\"attempt to shift left with overflow\");\n+                        }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { intrinsics::simd_shl(self, rhs) }\n+                    }\n+                }\n+            }\n+\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShlAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shl_assign(&mut self, rhs: Self) {\n+                        *self = *self << rhs;\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShlAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shl_assign(&mut self, rhs: $scalar) {\n+                        *self = *self << rhs;\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shr<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shr(self, rhs: Self) -> Self::Output {\n+                        // TODO there is probably a better way of doing this\n+                        if rhs.as_array()\n+                            .iter()\n+                            .copied()\n+                            .any(invalid_shift_rhs)\n+                        {\n+                            panic!(\"attempt to shift with overflow\");\n+                        }\n+                        unsafe { intrinsics::simd_shr(self, rhs) }\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shr<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shr(self, rhs: $scalar) -> Self::Output {\n+                        if invalid_shift_rhs(rhs) {\n+                            panic!(\"attempt to shift with overflow\");\n+                        }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { intrinsics::simd_shr(self, rhs) }\n+                    }\n+                }\n+            }\n+\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShrAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shr_assign(&mut self, rhs: Self) {\n+                        *self = *self >> rhs;\n+                    }\n+                }\n+            }\n+\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShrAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shr_assign(&mut self, rhs: $scalar) {\n+                        *self = *self >> rhs;\n+                    }\n+                }\n+            }\n+        )*\n+    };\n+}\n+\n+/// Implements unsigned integer operators for the provided types.\n+macro_rules! impl_signed_int_ops {\n+    { $($scalar:ty),* } => {\n+        impl_unsigned_int_ops! { $($scalar),* }\n+        $( // scalar\n+            impl_op! { impl Neg for $scalar }\n+        )*\n+    };\n+}\n+\n+impl_unsigned_int_ops! { u8, u16, u32, u64, usize }\n+impl_signed_int_ops! { i8, i16, i32, i64, isize }\n+impl_float_ops! { f32, f64 }"}, {"sha": "db0640aae7905aa640816a03b8308eea86b5a923", "filename": "library/portable-simd/crates/core_simd/src/reduction.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,123 @@\n+use crate::simd::intrinsics::{\n+    simd_reduce_add_ordered, simd_reduce_and, simd_reduce_max, simd_reduce_min,\n+    simd_reduce_mul_ordered, simd_reduce_or, simd_reduce_xor,\n+};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+\n+macro_rules! impl_integer_reductions {\n+    { $scalar:ty } => {\n+        impl<const LANES: usize> Simd<$scalar, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n+            #[inline]\n+            pub fn horizontal_sum(self) -> $scalar {\n+                unsafe { simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            /// Horizontal wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n+            #[inline]\n+            pub fn horizontal_product(self) -> $scalar {\n+                unsafe { simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            /// Horizontal bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n+            /// the vector.\n+            #[inline]\n+            pub fn horizontal_and(self) -> $scalar {\n+                unsafe { simd_reduce_and(self) }\n+            }\n+\n+            /// Horizontal bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n+            /// the vector.\n+            #[inline]\n+            pub fn horizontal_or(self) -> $scalar {\n+                unsafe { simd_reduce_or(self) }\n+            }\n+\n+            /// Horizontal bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n+            /// the vector.\n+            #[inline]\n+            pub fn horizontal_xor(self) -> $scalar {\n+                unsafe { simd_reduce_xor(self) }\n+            }\n+\n+            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            #[inline]\n+            pub fn horizontal_max(self) -> $scalar {\n+                unsafe { simd_reduce_max(self) }\n+            }\n+\n+            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            #[inline]\n+            pub fn horizontal_min(self) -> $scalar {\n+                unsafe { simd_reduce_min(self) }\n+            }\n+        }\n+    }\n+}\n+\n+impl_integer_reductions! { i8 }\n+impl_integer_reductions! { i16 }\n+impl_integer_reductions! { i32 }\n+impl_integer_reductions! { i64 }\n+impl_integer_reductions! { isize }\n+impl_integer_reductions! { u8 }\n+impl_integer_reductions! { u16 }\n+impl_integer_reductions! { u32 }\n+impl_integer_reductions! { u64 }\n+impl_integer_reductions! { usize }\n+\n+macro_rules! impl_float_reductions {\n+    { $scalar:ty } => {\n+        impl<const LANES: usize> Simd<$scalar, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+\n+            /// Horizontal add.  Returns the sum of the lanes of the vector.\n+            #[inline]\n+            pub fn horizontal_sum(self) -> $scalar {\n+                // LLVM sum is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_array().iter().sum()\n+                } else {\n+                    unsafe { simd_reduce_add_ordered(self, 0.) }\n+                }\n+            }\n+\n+            /// Horizontal multiply.  Returns the product of the lanes of the vector.\n+            #[inline]\n+            pub fn horizontal_product(self) -> $scalar {\n+                // LLVM product is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_array().iter().product()\n+                } else {\n+                    unsafe { simd_reduce_mul_ordered(self, 1.) }\n+                }\n+            }\n+\n+            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            ///\n+            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+            /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n+            #[inline]\n+            pub fn horizontal_max(self) -> $scalar {\n+                unsafe { simd_reduce_max(self) }\n+            }\n+\n+            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            ///\n+            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+            /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n+            #[inline]\n+            pub fn horizontal_min(self) -> $scalar {\n+                unsafe { simd_reduce_min(self) }\n+            }\n+        }\n+    }\n+}\n+\n+impl_float_reductions! { f32 }\n+impl_float_reductions! { f64 }"}, {"sha": "09789e1149206f9e648d0a03fa3568b9cad9ad57", "filename": "library/portable-simd/crates/core_simd/src/round.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,78 @@\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+\n+macro_rules! implement {\n+    {\n+        $type:ty, $int_type:ty\n+    } => {\n+        #[cfg(feature = \"std\")]\n+        impl<const LANES: usize> Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            /// Returns the smallest integer greater than or equal to each lane.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn ceil(self) -> Self {\n+                unsafe { intrinsics::simd_ceil(self) }\n+            }\n+\n+            /// Returns the largest integer value less than or equal to each lane.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn floor(self) -> Self {\n+                unsafe { intrinsics::simd_floor(self) }\n+            }\n+\n+            /// Rounds to the nearest integer value. Ties round toward zero.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn round(self) -> Self {\n+                unsafe { intrinsics::simd_round(self) }\n+            }\n+\n+            /// Returns the floating point's integer value, with its fractional part removed.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn trunc(self) -> Self {\n+                unsafe { intrinsics::simd_trunc(self) }\n+            }\n+\n+            /// Returns the floating point's fractional value, with its integer part removed.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn fract(self) -> Self {\n+                self - self.trunc()\n+            }\n+        }\n+\n+        impl<const LANES: usize> Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            /// Rounds toward zero and converts to the same-width integer type, assuming that\n+            /// the value is finite and fits in that type.\n+            ///\n+            /// # Safety\n+            /// The value must:\n+            ///\n+            /// * Not be NaN\n+            /// * Not be infinite\n+            /// * Be representable in the return type, after truncating off its fractional part\n+            #[inline]\n+            pub unsafe fn to_int_unchecked(self) -> Simd<$int_type, LANES> {\n+                unsafe { intrinsics::simd_cast(self) }\n+            }\n+\n+            /// Creates a floating-point vector from an integer vector.  Rounds values that are\n+            /// not exactly representable.\n+            #[inline]\n+            pub fn round_from_int(value: Simd<$int_type, LANES>) -> Self {\n+                unsafe { intrinsics::simd_cast(value) }\n+            }\n+        }\n+    }\n+}\n+\n+implement! { f32, i32 }\n+implement! { f64, i64 }"}, {"sha": "d976231a03a84afd7e87208eb201f2a8a3fdac49", "filename": "library/portable-simd/crates/core_simd/src/select.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,86 @@\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Mask, MaskElement, Simd, SimdElement, SupportedLaneCount};\n+\n+mod sealed {\n+    pub trait Sealed<Mask> {\n+        fn select(mask: Mask, true_values: Self, false_values: Self) -> Self;\n+    }\n+}\n+use sealed::Sealed;\n+\n+/// Supporting trait for vector `select` function\n+pub trait Select<Mask>: Sealed<Mask> {}\n+\n+impl<T, const LANES: usize> Sealed<Mask<T::Mask, LANES>> for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn select(mask: Mask<T::Mask, LANES>, true_values: Self, false_values: Self) -> Self {\n+        unsafe { intrinsics::simd_select(mask.to_int(), true_values, false_values) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> Select<Mask<T::Mask, LANES>> for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Sealed<Self> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn select(mask: Self, true_values: Self, false_values: Self) -> Self {\n+        mask & true_values | !mask & false_values\n+    }\n+}\n+\n+impl<T, const LANES: usize> Select<Self> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Choose lanes from two vectors.\n+    ///\n+    /// For each lane in the mask, choose the corresponding lane from `true_values` if\n+    /// that lane mask is true, and `false_values` if that lane mask is false.\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// let a = Simd::from_array([0, 1, 2, 3]);\n+    /// let b = Simd::from_array([4, 5, 6, 7]);\n+    /// let mask = Mask::from_array([true, false, false, true]);\n+    /// let c = mask.select(a, b);\n+    /// assert_eq!(c.to_array(), [0, 5, 6, 3]);\n+    /// ```\n+    ///\n+    /// `select` can also be used on masks:\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::Mask;\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::Mask;\n+    /// let a = Mask::<i32, 4>::from_array([true, true, false, false]);\n+    /// let b = Mask::<i32, 4>::from_array([false, false, true, true]);\n+    /// let mask = Mask::<i32, 4>::from_array([true, false, false, true]);\n+    /// let c = mask.select(a, b);\n+    /// assert_eq!(c.to_array(), [true, false, true, false]);\n+    /// ```\n+    #[inline]\n+    pub fn select<S: Select<Self>>(self, true_values: S, false_values: S) -> S {\n+        S::select(self, true_values, false_values)\n+    }\n+}"}, {"sha": "62cda68f0a94921c91f44c1d370e5092c286c3e2", "filename": "library/portable-simd/crates/core_simd/src/swizzle.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,374 @@\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+\n+/// Constructs a new vector by selecting values from the lanes of the source vector or vectors to use.\n+///\n+/// When swizzling one vector, the indices of the result vector are indicated by a `const` array\n+/// of `usize`, like [`Swizzle`].\n+/// When swizzling two vectors, the indices are indicated by a `const` array of [`Which`], like\n+/// [`Swizzle2`].\n+///\n+/// # Examples\n+/// ## One source vector\n+/// ```\n+/// # #![feature(portable_simd)]\n+/// # #[cfg(feature = \"std\")] use core_simd::{Simd, simd_swizzle};\n+/// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, simd_swizzle};\n+/// let v = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n+///\n+/// // Keeping the same size\n+/// let r = simd_swizzle!(v, [3, 0, 1, 2]);\n+/// assert_eq!(r.to_array(), [3., 0., 1., 2.]);\n+///\n+/// // Changing the number of lanes\n+/// let r = simd_swizzle!(v, [3, 1]);\n+/// assert_eq!(r.to_array(), [3., 1.]);\n+/// ```\n+///\n+/// ## Two source vectors\n+/// ```\n+/// # #![feature(portable_simd)]\n+/// # #[cfg(feature = \"std\")] use core_simd::{Simd, simd_swizzle, Which};\n+/// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, simd_swizzle, Which};\n+/// use Which::*;\n+/// let a = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n+/// let b = Simd::<f32, 4>::from_array([4., 5., 6., 7.]);\n+///\n+/// // Keeping the same size\n+/// let r = simd_swizzle!(a, b, [First(0), First(1), Second(2), Second(3)]);\n+/// assert_eq!(r.to_array(), [0., 1., 6., 7.]);\n+///\n+/// // Changing the number of lanes\n+/// let r = simd_swizzle!(a, b, [First(0), Second(0)]);\n+/// assert_eq!(r.to_array(), [0., 4.]);\n+/// ```\n+#[allow(unused_macros)]\n+pub macro simd_swizzle {\n+    (\n+        $vector:expr, $index:expr $(,)?\n+    ) => {\n+        {\n+            use $crate::simd::Swizzle;\n+            struct Impl;\n+            impl<const LANES: usize> Swizzle<LANES, {$index.len()}> for Impl {\n+                const INDEX: [usize; {$index.len()}] = $index;\n+            }\n+            Impl::swizzle($vector)\n+        }\n+    },\n+    (\n+        $first:expr, $second:expr, $index:expr $(,)?\n+    ) => {\n+        {\n+            use $crate::simd::{Which, Swizzle2};\n+            struct Impl;\n+            impl<const LANES: usize> Swizzle2<LANES, {$index.len()}> for Impl {\n+                const INDEX: [Which; {$index.len()}] = $index;\n+            }\n+            Impl::swizzle2($first, $second)\n+        }\n+    }\n+}\n+\n+/// An index into one of two vectors.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Which {\n+    /// Indexes the first vector.\n+    First(usize),\n+    /// Indexes the second vector.\n+    Second(usize),\n+}\n+\n+/// Create a vector from the elements of another vector.\n+pub trait Swizzle<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n+    /// Map from the lanes of the input vector to the output vector.\n+    const INDEX: [usize; OUTPUT_LANES];\n+\n+    /// Create a new vector from the lanes of `vector`.\n+    ///\n+    /// Lane `i` of the output is `vector[Self::INDEX[i]]`.\n+    fn swizzle<T>(vector: Simd<T, INPUT_LANES>) -> Simd<T, OUTPUT_LANES>\n+    where\n+        T: SimdElement,\n+        LaneCount<INPUT_LANES>: SupportedLaneCount,\n+        LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n+    {\n+        unsafe { intrinsics::simd_shuffle(vector, vector, Self::INDEX_IMPL) }\n+    }\n+}\n+\n+/// Create a vector from the elements of two other vectors.\n+pub trait Swizzle2<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n+    /// Map from the lanes of the input vectors to the output vector\n+    const INDEX: [Which; OUTPUT_LANES];\n+\n+    /// Create a new vector from the lanes of `first` and `second`.\n+    ///\n+    /// Lane `i` is `first[j]` when `Self::INDEX[i]` is `First(j)`, or `second[j]` when it is\n+    /// `Second(j)`.\n+    fn swizzle2<T>(\n+        first: Simd<T, INPUT_LANES>,\n+        second: Simd<T, INPUT_LANES>,\n+    ) -> Simd<T, OUTPUT_LANES>\n+    where\n+        T: SimdElement,\n+        LaneCount<INPUT_LANES>: SupportedLaneCount,\n+        LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n+    {\n+        unsafe { intrinsics::simd_shuffle(first, second, Self::INDEX_IMPL) }\n+    }\n+}\n+\n+/// The `simd_shuffle` intrinsic expects `u32`, so do error checking and conversion here.\n+/// This trait hides `INDEX_IMPL` from the public API.\n+trait SwizzleImpl<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n+    const INDEX_IMPL: [u32; OUTPUT_LANES];\n+}\n+\n+impl<T, const INPUT_LANES: usize, const OUTPUT_LANES: usize> SwizzleImpl<INPUT_LANES, OUTPUT_LANES>\n+    for T\n+where\n+    T: Swizzle<INPUT_LANES, OUTPUT_LANES> + ?Sized,\n+{\n+    const INDEX_IMPL: [u32; OUTPUT_LANES] = {\n+        let mut output = [0; OUTPUT_LANES];\n+        let mut i = 0;\n+        while i < OUTPUT_LANES {\n+            let index = Self::INDEX[i];\n+            assert!(index as u32 as usize == index);\n+            assert!(index < INPUT_LANES, \"source lane exceeds input lane count\",);\n+            output[i] = index as u32;\n+            i += 1;\n+        }\n+        output\n+    };\n+}\n+\n+/// The `simd_shuffle` intrinsic expects `u32`, so do error checking and conversion here.\n+/// This trait hides `INDEX_IMPL` from the public API.\n+trait Swizzle2Impl<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n+    const INDEX_IMPL: [u32; OUTPUT_LANES];\n+}\n+\n+impl<T, const INPUT_LANES: usize, const OUTPUT_LANES: usize> Swizzle2Impl<INPUT_LANES, OUTPUT_LANES>\n+    for T\n+where\n+    T: Swizzle2<INPUT_LANES, OUTPUT_LANES> + ?Sized,\n+{\n+    const INDEX_IMPL: [u32; OUTPUT_LANES] = {\n+        let mut output = [0; OUTPUT_LANES];\n+        let mut i = 0;\n+        while i < OUTPUT_LANES {\n+            let (offset, index) = match Self::INDEX[i] {\n+                Which::First(index) => (false, index),\n+                Which::Second(index) => (true, index),\n+            };\n+            assert!(index < INPUT_LANES, \"source lane exceeds input lane count\",);\n+\n+            // lanes are indexed by the first vector, then second vector\n+            let index = if offset { index + INPUT_LANES } else { index };\n+            assert!(index as u32 as usize == index);\n+            output[i] = index as u32;\n+            i += 1;\n+        }\n+        output\n+    };\n+}\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Reverse the order of the lanes in the vector.\n+    #[inline]\n+    pub fn reverse(self) -> Self {\n+        const fn reverse_index<const LANES: usize>() -> [usize; LANES] {\n+            let mut index = [0; LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                index[i] = LANES - i - 1;\n+                i += 1;\n+            }\n+            index\n+        }\n+\n+        struct Reverse;\n+\n+        impl<const LANES: usize> Swizzle<LANES, LANES> for Reverse {\n+            const INDEX: [usize; LANES] = reverse_index::<LANES>();\n+        }\n+\n+        Reverse::swizzle(self)\n+    }\n+\n+    /// Rotates the vector such that the first `OFFSET` elements of the slice move to the end\n+    /// while the last `LANES - OFFSET` elements move to the front. After calling `rotate_lanes_left`,\n+    /// the element previously in lane `OFFSET` will become the first element in the slice.\n+    #[inline]\n+    pub fn rotate_lanes_left<const OFFSET: usize>(self) -> Self {\n+        const fn rotate_index<const OFFSET: usize, const LANES: usize>() -> [usize; LANES] {\n+            let offset = OFFSET % LANES;\n+            let mut index = [0; LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                index[i] = (i + offset) % LANES;\n+                i += 1;\n+            }\n+            index\n+        }\n+\n+        struct Rotate<const OFFSET: usize>;\n+\n+        impl<const OFFSET: usize, const LANES: usize> Swizzle<LANES, LANES> for Rotate<OFFSET> {\n+            const INDEX: [usize; LANES] = rotate_index::<OFFSET, LANES>();\n+        }\n+\n+        Rotate::<OFFSET>::swizzle(self)\n+    }\n+\n+    /// Rotates the vector such that the first `LANES - OFFSET` elements of the vector move to\n+    /// the end while the last `OFFSET` elements move to the front. After calling `rotate_lanes_right`,\n+    /// the element previously at index `LANES - OFFSET` will become the first element in the slice.\n+    #[inline]\n+    pub fn rotate_lanes_right<const OFFSET: usize>(self) -> Self {\n+        const fn rotate_index<const OFFSET: usize, const LANES: usize>() -> [usize; LANES] {\n+            let offset = LANES - OFFSET % LANES;\n+            let mut index = [0; LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                index[i] = (i + offset) % LANES;\n+                i += 1;\n+            }\n+            index\n+        }\n+\n+        struct Rotate<const OFFSET: usize>;\n+\n+        impl<const OFFSET: usize, const LANES: usize> Swizzle<LANES, LANES> for Rotate<OFFSET> {\n+            const INDEX: [usize; LANES] = rotate_index::<OFFSET, LANES>();\n+        }\n+\n+        Rotate::<OFFSET>::swizzle(self)\n+    }\n+\n+    /// Interleave two vectors.\n+    ///\n+    /// Produces two vectors with lanes taken alternately from `self` and `other`.\n+    ///\n+    /// The first result contains the first `LANES / 2` lanes from `self` and `other`,\n+    /// alternating, starting with the first lane of `self`.\n+    ///\n+    /// The second result contains the last `LANES / 2` lanes from `self` and `other`,\n+    /// alternating, starting with the lane `LANES / 2` from the start of `self`.\n+    ///\n+    /// ```\n+    /// #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// let a = Simd::from_array([0, 1, 2, 3]);\n+    /// let b = Simd::from_array([4, 5, 6, 7]);\n+    /// let (x, y) = a.interleave(b);\n+    /// assert_eq!(x.to_array(), [0, 4, 1, 5]);\n+    /// assert_eq!(y.to_array(), [2, 6, 3, 7]);\n+    /// ```\n+    #[inline]\n+    pub fn interleave(self, other: Self) -> (Self, Self) {\n+        const fn lo<const LANES: usize>() -> [Which; LANES] {\n+            let mut idx = [Which::First(0); LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                let offset = i / 2;\n+                idx[i] = if i % 2 == 0 {\n+                    Which::First(offset)\n+                } else {\n+                    Which::Second(offset)\n+                };\n+                i += 1;\n+            }\n+            idx\n+        }\n+        const fn hi<const LANES: usize>() -> [Which; LANES] {\n+            let mut idx = [Which::First(0); LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                let offset = (LANES + i) / 2;\n+                idx[i] = if i % 2 == 0 {\n+                    Which::First(offset)\n+                } else {\n+                    Which::Second(offset)\n+                };\n+                i += 1;\n+            }\n+            idx\n+        }\n+\n+        struct Lo;\n+        struct Hi;\n+\n+        impl<const LANES: usize> Swizzle2<LANES, LANES> for Lo {\n+            const INDEX: [Which; LANES] = lo::<LANES>();\n+        }\n+\n+        impl<const LANES: usize> Swizzle2<LANES, LANES> for Hi {\n+            const INDEX: [Which; LANES] = hi::<LANES>();\n+        }\n+\n+        (Lo::swizzle2(self, other), Hi::swizzle2(self, other))\n+    }\n+\n+    /// Deinterleave two vectors.\n+    ///\n+    /// The first result takes every other lane of `self` and then `other`, starting with\n+    /// the first lane.\n+    ///\n+    /// The second result takes every other lane of `self` and then `other`, starting with\n+    /// the second lane.\n+    ///\n+    /// ```\n+    /// #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// let a = Simd::from_array([0, 4, 1, 5]);\n+    /// let b = Simd::from_array([2, 6, 3, 7]);\n+    /// let (x, y) = a.deinterleave(b);\n+    /// assert_eq!(x.to_array(), [0, 1, 2, 3]);\n+    /// assert_eq!(y.to_array(), [4, 5, 6, 7]);\n+    /// ```\n+    #[inline]\n+    pub fn deinterleave(self, other: Self) -> (Self, Self) {\n+        const fn even<const LANES: usize>() -> [Which; LANES] {\n+            let mut idx = [Which::First(0); LANES];\n+            let mut i = 0;\n+            while i < LANES / 2 {\n+                idx[i] = Which::First(2 * i);\n+                idx[i + LANES / 2] = Which::Second(2 * i);\n+                i += 1;\n+            }\n+            idx\n+        }\n+        const fn odd<const LANES: usize>() -> [Which; LANES] {\n+            let mut idx = [Which::First(0); LANES];\n+            let mut i = 0;\n+            while i < LANES / 2 {\n+                idx[i] = Which::First(2 * i + 1);\n+                idx[i + LANES / 2] = Which::Second(2 * i + 1);\n+                i += 1;\n+            }\n+            idx\n+        }\n+\n+        struct Even;\n+        struct Odd;\n+\n+        impl<const LANES: usize> Swizzle2<LANES, LANES> for Even {\n+            const INDEX: [Which; LANES] = even::<LANES>();\n+        }\n+\n+        impl<const LANES: usize> Swizzle2<LANES, LANES> for Odd {\n+            const INDEX: [Which; LANES] = odd::<LANES>();\n+        }\n+\n+        (Even::swizzle2(self, other), Odd::swizzle2(self, other))\n+    }\n+}"}, {"sha": "8d9b3e8ff85ea9f458e05d4f9b7732f327c9300c", "filename": "library/portable-simd/crates/core_simd/src/to_bytes.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,39 @@\n+macro_rules! impl_to_bytes {\n+    { $ty:ty, $size:literal } => {\n+        impl<const LANES: usize> crate::simd::Simd<$ty, LANES>\n+        where\n+            crate::simd::LaneCount<LANES>: crate::simd::SupportedLaneCount,\n+            crate::simd::LaneCount<{{ $size * LANES }}>: crate::simd::SupportedLaneCount,\n+        {\n+            /// Return the memory representation of this integer as a byte array in native byte\n+            /// order.\n+            pub fn to_ne_bytes(self) -> crate::simd::Simd<u8, {{ $size * LANES }}> {\n+                unsafe { core::mem::transmute_copy(&self) }\n+            }\n+\n+            /// Create a native endian integer value from its memory representation as a byte array\n+            /// in native endianness.\n+            pub fn from_ne_bytes(bytes: crate::simd::Simd<u8, {{ $size * LANES }}>) -> Self {\n+                unsafe { core::mem::transmute_copy(&bytes) }\n+            }\n+        }\n+    }\n+}\n+\n+impl_to_bytes! { u8, 1 }\n+impl_to_bytes! { u16, 2 }\n+impl_to_bytes! { u32, 4 }\n+impl_to_bytes! { u64, 8 }\n+#[cfg(target_pointer_width = \"32\")]\n+impl_to_bytes! { usize, 4 }\n+#[cfg(target_pointer_width = \"64\")]\n+impl_to_bytes! { usize, 8 }\n+\n+impl_to_bytes! { i8, 1 }\n+impl_to_bytes! { i16, 2 }\n+impl_to_bytes! { i32, 4 }\n+impl_to_bytes! { i64, 8 }\n+#[cfg(target_pointer_width = \"32\")]\n+impl_to_bytes! { isize, 4 }\n+#[cfg(target_pointer_width = \"64\")]\n+impl_to_bytes! { isize, 8 }"}, {"sha": "7c5ec2bc314c434d56b66c3e5e181eefe70baa45", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "added", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,528 @@\n+mod float;\n+mod int;\n+mod uint;\n+\n+pub use float::*;\n+pub use int::*;\n+pub use uint::*;\n+\n+// Vectors of pointers are not for public use at the current time.\n+pub(crate) mod ptr;\n+\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n+\n+/// A SIMD vector of `LANES` elements of type `T`.\n+#[repr(simd)]\n+pub struct Simd<T, const LANES: usize>([T; LANES])\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount;\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    /// Number of lanes in this vector.\n+    pub const LANES: usize = LANES;\n+\n+    /// Get the number of lanes in this vector.\n+    pub const fn lanes(&self) -> usize {\n+        LANES\n+    }\n+\n+    /// Construct a SIMD vector by setting all lanes to the given value.\n+    pub const fn splat(value: T) -> Self {\n+        Self([value; LANES])\n+    }\n+\n+    /// Returns an array reference containing the entire SIMD vector.\n+    pub const fn as_array(&self) -> &[T; LANES] {\n+        &self.0\n+    }\n+\n+    /// Returns a mutable array reference containing the entire SIMD vector.\n+    pub fn as_mut_array(&mut self) -> &mut [T; LANES] {\n+        &mut self.0\n+    }\n+\n+    /// Converts an array to a SIMD vector.\n+    pub const fn from_array(array: [T; LANES]) -> Self {\n+        Self(array)\n+    }\n+\n+    /// Converts a SIMD vector to an array.\n+    pub const fn to_array(self) -> [T; LANES] {\n+        self.0\n+    }\n+\n+    /// Converts a slice to a SIMD vector containing `slice[..LANES]`\n+    /// # Panics\n+    /// `from_slice` will panic if the slice's `len` is less than the vector's `Simd::LANES`.\n+    #[must_use]\n+    pub const fn from_slice(slice: &[T]) -> Self {\n+        assert!(\n+            slice.len() >= LANES,\n+            \"slice length must be at least the number of lanes\"\n+        );\n+        let mut array = [slice[0]; LANES];\n+        let mut i = 0;\n+        while i < LANES {\n+            array[i] = slice[i];\n+            i += 1;\n+        }\n+        Self(array)\n+    }\n+\n+    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+    /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let alt = Simd::from_array([-5, -4, -3, -2]);\n+    ///\n+    /// let result = Simd::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([-5, 13, 10, 15]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_or(slice: &[T], idxs: Simd<usize, LANES>, or: Self) -> Self {\n+        Self::gather_select(slice, Mask::splat(true), idxs, or)\n+    }\n+\n+    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+    /// If an index is out-of-bounds, the lane is set to the default value for the type.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    ///\n+    /// let result = Simd::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([0, 13, 10, 15]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, LANES>) -> Self\n+    where\n+        T: Default,\n+    {\n+        Self::gather_or(slice, idxs, Self::splat(T::default()))\n+    }\n+\n+    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If an index is disabled or is out-of-bounds, the lane is selected from the `or` vector.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let alt = Simd::from_array([-5, -4, -3, -2]);\n+    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    ///\n+    /// let result = Simd::gather_select(&vec, enable, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_select(\n+        slice: &[T],\n+        enable: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n+        or: Self,\n+    ) -> Self {\n+        let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n+        // SAFETY: We have masked-off out-of-bounds lanes.\n+        unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n+    }\n+\n+    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If an index is disabled, the lane is selected from the `or` vector.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this function with an `enable`d out-of-bounds index is *[undefined behavior]*\n+    /// even if the resulting value is not used.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let alt = Simd::from_array([-5, -4, -3, -2]);\n+    /// let enable = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n+    /// // If this mask was used to gather, it would be unsound. Let's fix that.\n+    /// let enable = enable & idxs.lanes_lt(Simd::splat(vec.len()));\n+    ///\n+    /// // We have masked the OOB lane, so it's safe to gather now.\n+    /// let result = unsafe { Simd::gather_select_unchecked(&vec, enable, idxs, alt) };\n+    /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n+    /// ```\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    #[must_use]\n+    #[inline]\n+    pub unsafe fn gather_select_unchecked(\n+        slice: &[T],\n+        enable: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n+        or: Self,\n+    ) -> Self {\n+        let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n+        // Ferris forgive me, I have done pointer arithmetic here.\n+        let ptrs = base_ptr.wrapping_add(idxs);\n+        // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n+        unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n+    }\n+\n+    /// Writes the values in a SIMD vector to potentially discontiguous indices in `slice`.\n+    /// If two lanes in the scattered vector would write to the same index\n+    /// only the last lane is guaranteed to actually be written.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let vals = Simd::from_array([-27, 82, -41, 124]);\n+    ///\n+    /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n+    /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n+    /// ```\n+    #[inline]\n+    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, LANES>) {\n+        self.scatter_select(slice, Mask::splat(true), idxs)\n+    }\n+\n+    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If an enabled index is out-of-bounds, the lane is not written.\n+    /// If two enabled lanes in the scattered vector would write to the same index,\n+    /// only the last lane is guaranteed to actually be written.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let vals = Simd::from_array([-27, 82, -41, 124]);\n+    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    ///\n+    /// vals.scatter_select(&mut vec, enable, idxs); // index 0's second write is masked, thus omitted.\n+    /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n+    /// ```\n+    #[inline]\n+    pub fn scatter_select(\n+        self,\n+        slice: &mut [T],\n+        enable: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n+    ) {\n+        let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n+        // SAFETY: We have masked-off out-of-bounds lanes.\n+        unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n+    }\n+\n+    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If two enabled lanes in the scattered vector would write to the same index,\n+    /// only the last lane is guaranteed to actually be written.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this function with an enabled out-of-bounds index is *[undefined behavior]*,\n+    /// and may lead to memory corruption.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let vals = Simd::from_array([-27, 82, -41, 124]);\n+    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// // If this mask was used to scatter, it would be unsound. Let's fix that.\n+    /// let enable = enable & idxs.lanes_lt(Simd::splat(vec.len()));\n+    ///\n+    /// // We have masked the OOB lane, so it's safe to scatter now.\n+    /// unsafe { vals.scatter_select_unchecked(&mut vec, enable, idxs); }\n+    /// // index 0's second write is masked, thus was omitted.\n+    /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n+    /// ```\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    #[inline]\n+    pub unsafe fn scatter_select_unchecked(\n+        self,\n+        slice: &mut [T],\n+        enable: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n+    ) {\n+        // SAFETY: This block works with *mut T derived from &mut 'a [T],\n+        // which means it is delicate in Rust's borrowing model, circa 2021:\n+        // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n+        // Even though this block is largely safe methods, it must be exactly this way\n+        // to prevent invalidating the raw ptrs while they're live.\n+        // Thus, entering this block requires all values to use being already ready:\n+        // 0. idxs we want to write to, which are used to construct the mask.\n+        // 1. enable, which depends on an initial &'a [T] and the idxs.\n+        // 2. actual values to scatter (self).\n+        // 3. &mut [T] which will become our base ptr.\n+        unsafe {\n+            // Now Entering \u2622\ufe0f *mut T Zone\n+            let base_ptr = crate::simd::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n+            // Ferris forgive me, I have done pointer arithmetic here.\n+            let ptrs = base_ptr.wrapping_add(idxs);\n+            // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n+            intrinsics::simd_scatter(self, ptrs, enable.to_int())\n+            // Cleared \u2622\ufe0f *mut T Zone\n+        }\n+    }\n+}\n+\n+impl<T, const LANES: usize> Copy for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Clone for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<T, const LANES: usize> Default for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + Default,\n+{\n+    #[inline]\n+    fn default() -> Self {\n+        Self::splat(T::default())\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialEq for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + PartialEq,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        // TODO use SIMD equality\n+        self.to_array() == other.to_array()\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialOrd for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + PartialOrd,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        // TODO use SIMD equality\n+        self.to_array().partial_cmp(other.as_ref())\n+    }\n+}\n+\n+impl<T, const LANES: usize> Eq for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + Eq,\n+{\n+}\n+\n+impl<T, const LANES: usize> Ord for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + Ord,\n+{\n+    #[inline]\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        // TODO use SIMD equality\n+        self.to_array().cmp(other.as_ref())\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::hash::Hash for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + core::hash::Hash,\n+{\n+    #[inline]\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: core::hash::Hasher,\n+    {\n+        self.as_array().hash(state)\n+    }\n+}\n+\n+// array references\n+impl<T, const LANES: usize> AsRef<[T; LANES]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[T; LANES] {\n+        &self.0\n+    }\n+}\n+\n+impl<T, const LANES: usize> AsMut<[T; LANES]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [T; LANES] {\n+        &mut self.0\n+    }\n+}\n+\n+// slice references\n+impl<T, const LANES: usize> AsRef<[T]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[T] {\n+        &self.0\n+    }\n+}\n+\n+impl<T, const LANES: usize> AsMut<[T]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [T] {\n+        &mut self.0\n+    }\n+}\n+\n+// vector/array conversion\n+impl<T, const LANES: usize> From<[T; LANES]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    fn from(array: [T; LANES]) -> Self {\n+        Self(array)\n+    }\n+}\n+\n+impl<T, const LANES: usize> From<Simd<T, LANES>> for [T; LANES]\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    fn from(vector: Simd<T, LANES>) -> Self {\n+        vector.to_array()\n+    }\n+}\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+use sealed::Sealed;\n+\n+/// Marker trait for types that may be used as SIMD vector elements.\n+/// SAFETY: This trait, when implemented, asserts the compiler can monomorphize\n+/// `#[repr(simd)]` structs with the marked type as an element.\n+/// Strictly, it is valid to impl if the vector will not be miscompiled.\n+/// Practically, it is user-unfriendly to impl it if the vector won't compile,\n+/// even when no soundness guarantees are broken by allowing the user to try.\n+pub unsafe trait SimdElement: Sealed + Copy {\n+    /// The mask element type corresponding to this element type.\n+    type Mask: MaskElement;\n+}\n+\n+impl Sealed for u8 {}\n+unsafe impl SimdElement for u8 {\n+    type Mask = i8;\n+}\n+\n+impl Sealed for u16 {}\n+unsafe impl SimdElement for u16 {\n+    type Mask = i16;\n+}\n+\n+impl Sealed for u32 {}\n+unsafe impl SimdElement for u32 {\n+    type Mask = i32;\n+}\n+\n+impl Sealed for u64 {}\n+unsafe impl SimdElement for u64 {\n+    type Mask = i64;\n+}\n+\n+impl Sealed for usize {}\n+unsafe impl SimdElement for usize {\n+    type Mask = isize;\n+}\n+\n+impl Sealed for i8 {}\n+unsafe impl SimdElement for i8 {\n+    type Mask = i8;\n+}\n+\n+impl Sealed for i16 {}\n+unsafe impl SimdElement for i16 {\n+    type Mask = i16;\n+}\n+\n+impl Sealed for i32 {}\n+unsafe impl SimdElement for i32 {\n+    type Mask = i32;\n+}\n+\n+impl Sealed for i64 {}\n+unsafe impl SimdElement for i64 {\n+    type Mask = i64;\n+}\n+\n+impl Sealed for isize {}\n+unsafe impl SimdElement for isize {\n+    type Mask = isize;\n+}\n+\n+impl Sealed for f32 {}\n+unsafe impl SimdElement for f32 {\n+    type Mask = i32;\n+}\n+\n+impl Sealed for f64 {}\n+unsafe impl SimdElement for f64 {\n+    type Mask = i64;\n+}"}, {"sha": "c09d0ac84d246c24d8051a02a3373c93d75930b7", "filename": "library/portable-simd/crates/core_simd/src/vector/float.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,210 @@\n+#![allow(non_camel_case_types)]\n+\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Mask, Simd, SupportedLaneCount};\n+\n+/// Implements inherent methods for a float vector containing multiple\n+/// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n+/// representation.\n+macro_rules! impl_float_vector {\n+    { $type:ty, $bits_ty:ty, $mask_ty:ty } => {\n+        impl<const LANES: usize> Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            /// Raw transmutation to an unsigned integer vector type with the\n+            /// same size and number of lanes.\n+            #[inline]\n+            pub fn to_bits(self) -> Simd<$bits_ty, LANES> {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n+                unsafe { core::mem::transmute_copy(&self) }\n+            }\n+\n+            /// Raw transmutation from an unsigned integer vector type with the\n+            /// same size and number of lanes.\n+            #[inline]\n+            pub fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n+                unsafe { core::mem::transmute_copy(&bits) }\n+            }\n+\n+            /// Produces a vector where every lane has the absolute value of the\n+            /// equivalently-indexed lane in `self`.\n+            #[inline]\n+            pub fn abs(self) -> Self {\n+                unsafe { intrinsics::simd_fabs(self) }\n+            }\n+\n+            /// Fused multiply-add.  Computes `(self * a) + b` with only one rounding error,\n+            /// yielding a more accurate result than an unfused multiply-add.\n+            ///\n+            /// Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n+            /// architecture has a dedicated `fma` CPU instruction.  However, this is not always\n+            /// true, and will be heavily dependent on designing algorithms with specific target\n+            /// hardware in mind.\n+            #[cfg(feature = \"std\")]\n+            #[inline]\n+            pub fn mul_add(self, a: Self, b: Self) -> Self {\n+                unsafe { intrinsics::simd_fma(self, a, b) }\n+            }\n+\n+            /// Produces a vector where every lane has the square root value\n+            /// of the equivalently-indexed lane in `self`\n+            #[inline]\n+            #[cfg(feature = \"std\")]\n+            pub fn sqrt(self) -> Self {\n+                unsafe { intrinsics::simd_fsqrt(self) }\n+            }\n+\n+            /// Takes the reciprocal (inverse) of each lane, `1/x`.\n+            #[inline]\n+            pub fn recip(self) -> Self {\n+                Self::splat(1.0) / self\n+            }\n+\n+            /// Converts each lane from radians to degrees.\n+            #[inline]\n+            pub fn to_degrees(self) -> Self {\n+                // to_degrees uses a special constant for better precision, so extract that constant\n+                self * Self::splat(<$type>::to_degrees(1.))\n+            }\n+\n+            /// Converts each lane from degrees to radians.\n+            #[inline]\n+            pub fn to_radians(self) -> Self {\n+                self * Self::splat(<$type>::to_radians(1.))\n+            }\n+\n+            /// Returns true for each lane if it has a positive sign, including\n+            /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n+            #[inline]\n+            pub fn is_sign_positive(self) -> Mask<$mask_ty, LANES> {\n+                !self.is_sign_negative()\n+            }\n+\n+            /// Returns true for each lane if it has a negative sign, including\n+            /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n+            #[inline]\n+            pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n+                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n+                sign_bits.lanes_gt(Simd::splat(0))\n+            }\n+\n+            /// Returns true for each lane if its value is `NaN`.\n+            #[inline]\n+            pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n+                self.lanes_ne(self)\n+            }\n+\n+            /// Returns true for each lane if its value is positive infinity or negative infinity.\n+            #[inline]\n+            pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n+                self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n+            }\n+\n+            /// Returns true for each lane if its value is neither infinite nor `NaN`.\n+            #[inline]\n+            pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n+                self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n+            }\n+\n+            /// Returns true for each lane if its value is subnormal.\n+            #[inline]\n+            pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n+                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(Simd::splat(0))\n+            }\n+\n+            /// Returns true for each lane if its value is neither neither zero, infinite,\n+            /// subnormal, or `NaN`.\n+            #[inline]\n+            pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n+                !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n+            }\n+\n+            /// Replaces each lane with a number that represents its sign.\n+            ///\n+            /// * `1.0` if the number is positive, `+0.0`, or `INFINITY`\n+            /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n+            /// * `NAN` if the number is `NAN`\n+            #[inline]\n+            pub fn signum(self) -> Self {\n+                self.is_nan().select(Self::splat(<$type>::NAN), Self::splat(1.0).copysign(self))\n+            }\n+\n+            /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n+            ///\n+            /// If any lane is a `NAN`, then a `NAN` with the sign of `sign` is returned.\n+            #[inline]\n+            pub fn copysign(self, sign: Self) -> Self {\n+                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n+                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n+                Self::from_bits(sign_bit | magnitude)\n+            }\n+\n+            /// Returns the minimum of each lane.\n+            ///\n+            /// If one of the values is `NAN`, then the other value is returned.\n+            #[inline]\n+            pub fn min(self, other: Self) -> Self {\n+                // TODO consider using an intrinsic\n+                self.is_nan().select(\n+                    other,\n+                    self.lanes_ge(other).select(other, self)\n+                )\n+            }\n+\n+            /// Returns the maximum of each lane.\n+            ///\n+            /// If one of the values is `NAN`, then the other value is returned.\n+            #[inline]\n+            pub fn max(self, other: Self) -> Self {\n+                // TODO consider using an intrinsic\n+                self.is_nan().select(\n+                    other,\n+                    self.lanes_le(other).select(other, self)\n+                )\n+            }\n+\n+            /// Restrict each lane to a certain interval unless it is NaN.\n+            ///\n+            /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n+            /// greater than `max`, and the corresponding lane in `min` if the lane is less\n+            /// than `min`.  Otherwise returns the lane in `self`.\n+            #[inline]\n+            pub fn clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.lanes_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                let mut x = self;\n+                x = x.lanes_lt(min).select(min, x);\n+                x = x.lanes_gt(max).select(max, x);\n+                x\n+            }\n+        }\n+    };\n+}\n+\n+impl_float_vector! { f32, u32, i32 }\n+impl_float_vector! { f64, u64, i64 }\n+\n+/// Vector of two `f32` values\n+pub type f32x2 = Simd<f32, 2>;\n+\n+/// Vector of four `f32` values\n+pub type f32x4 = Simd<f32, 4>;\n+\n+/// Vector of eight `f32` values\n+pub type f32x8 = Simd<f32, 8>;\n+\n+/// Vector of 16 `f32` values\n+pub type f32x16 = Simd<f32, 16>;\n+\n+/// Vector of two `f64` values\n+pub type f64x2 = Simd<f64, 2>;\n+\n+/// Vector of four `f64` values\n+pub type f64x4 = Simd<f64, 4>;\n+\n+/// Vector of eight `f64` values\n+pub type f64x8 = Simd<f64, 8>;"}, {"sha": "3eac02a27618c2047413ab0f9129c436424c9f4a", "filename": "library/portable-simd/crates/core_simd/src/vector/int.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,103 @@\n+#![allow(non_camel_case_types)]\n+\n+use crate::simd::{LaneCount, Mask, Simd, SupportedLaneCount};\n+\n+/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n+macro_rules! impl_integer_vector {\n+    { $type:ty } => {\n+        impl<const LANES: usize> Simd<$type, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            /// Returns true for each positive lane and false if it is zero or negative.\n+            #[inline]\n+            pub fn is_positive(self) -> Mask<$type, LANES> {\n+                self.lanes_gt(Self::splat(0))\n+            }\n+\n+            /// Returns true for each negative lane and false if it is zero or positive.\n+            #[inline]\n+            pub fn is_negative(self) -> Mask<$type, LANES> {\n+                self.lanes_lt(Self::splat(0))\n+            }\n+\n+            /// Returns numbers representing the sign of each lane.\n+            /// * `0` if the number is zero\n+            /// * `1` if the number is positive\n+            /// * `-1` if the number is negative\n+            #[inline]\n+            pub fn signum(self) -> Self {\n+                self.is_positive().select(\n+                    Self::splat(1),\n+                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+impl_integer_vector! { isize }\n+impl_integer_vector! { i16 }\n+impl_integer_vector! { i32 }\n+impl_integer_vector! { i64 }\n+impl_integer_vector! { i8 }\n+\n+/// Vector of two `isize` values\n+pub type isizex2 = Simd<isize, 2>;\n+\n+/// Vector of four `isize` values\n+pub type isizex4 = Simd<isize, 4>;\n+\n+/// Vector of eight `isize` values\n+pub type isizex8 = Simd<isize, 8>;\n+\n+/// Vector of two `i16` values\n+pub type i16x2 = Simd<i16, 2>;\n+\n+/// Vector of four `i16` values\n+pub type i16x4 = Simd<i16, 4>;\n+\n+/// Vector of eight `i16` values\n+pub type i16x8 = Simd<i16, 8>;\n+\n+/// Vector of 16 `i16` values\n+pub type i16x16 = Simd<i16, 16>;\n+\n+/// Vector of 32 `i16` values\n+pub type i16x32 = Simd<i16, 32>;\n+\n+/// Vector of two `i32` values\n+pub type i32x2 = Simd<i32, 2>;\n+\n+/// Vector of four `i32` values\n+pub type i32x4 = Simd<i32, 4>;\n+\n+/// Vector of eight `i32` values\n+pub type i32x8 = Simd<i32, 8>;\n+\n+/// Vector of 16 `i32` values\n+pub type i32x16 = Simd<i32, 16>;\n+\n+/// Vector of two `i64` values\n+pub type i64x2 = Simd<i64, 2>;\n+\n+/// Vector of four `i64` values\n+pub type i64x4 = Simd<i64, 4>;\n+\n+/// Vector of eight `i64` values\n+pub type i64x8 = Simd<i64, 8>;\n+\n+/// Vector of four `i8` values\n+pub type i8x4 = Simd<i8, 4>;\n+\n+/// Vector of eight `i8` values\n+pub type i8x8 = Simd<i8, 8>;\n+\n+/// Vector of 16 `i8` values\n+pub type i8x16 = Simd<i8, 16>;\n+\n+/// Vector of 32 `i8` values\n+pub type i8x32 = Simd<i8, 32>;\n+\n+/// Vector of 64 `i8` values\n+pub type i8x64 = Simd<i8, 64>;"}, {"sha": "ac9b98ca031a64729718d71cf58ea56603146cac", "filename": "library/portable-simd/crates/core_simd/src/vector/ptr.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,55 @@\n+//! Private implementation details of public gather/scatter APIs.\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use core::mem;\n+\n+/// A vector of *const T.\n+#[derive(Debug, Copy, Clone)]\n+#[repr(simd)]\n+pub(crate) struct SimdConstPtr<T, const LANES: usize>([*const T; LANES]);\n+\n+impl<T, const LANES: usize> SimdConstPtr<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: Sized,\n+{\n+    #[inline]\n+    #[must_use]\n+    pub fn splat(ptr: *const T) -> Self {\n+        Self([ptr; LANES])\n+    }\n+\n+    #[inline]\n+    #[must_use]\n+    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        unsafe {\n+            let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n+            mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n+        }\n+    }\n+}\n+\n+/// A vector of *mut T. Be very careful around potential aliasing.\n+#[derive(Debug, Copy, Clone)]\n+#[repr(simd)]\n+pub(crate) struct SimdMutPtr<T, const LANES: usize>([*mut T; LANES]);\n+\n+impl<T, const LANES: usize> SimdMutPtr<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: Sized,\n+{\n+    #[inline]\n+    #[must_use]\n+    pub fn splat(ptr: *mut T) -> Self {\n+        Self([ptr; LANES])\n+    }\n+\n+    #[inline]\n+    #[must_use]\n+    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        unsafe {\n+            let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n+            mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n+        }\n+    }\n+}"}, {"sha": "ed91fc3640e74c85b7911b7fdf51f3dcd6eb727b", "filename": "library/portable-simd/crates/core_simd/src/vector/uint.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,63 @@\n+#![allow(non_camel_case_types)]\n+\n+use crate::simd::Simd;\n+\n+/// Vector of two `usize` values\n+pub type usizex2 = Simd<usize, 2>;\n+\n+/// Vector of four `usize` values\n+pub type usizex4 = Simd<usize, 4>;\n+\n+/// Vector of eight `usize` values\n+pub type usizex8 = Simd<usize, 8>;\n+\n+/// Vector of two `u16` values\n+pub type u16x2 = Simd<u16, 2>;\n+\n+/// Vector of four `u16` values\n+pub type u16x4 = Simd<u16, 4>;\n+\n+/// Vector of eight `u16` values\n+pub type u16x8 = Simd<u16, 8>;\n+\n+/// Vector of 16 `u16` values\n+pub type u16x16 = Simd<u16, 16>;\n+\n+/// Vector of 32 `u16` values\n+pub type u16x32 = Simd<u16, 32>;\n+\n+/// Vector of two `u32` values\n+pub type u32x2 = Simd<u32, 2>;\n+\n+/// Vector of four `u32` values\n+pub type u32x4 = Simd<u32, 4>;\n+\n+/// Vector of eight `u32` values\n+pub type u32x8 = Simd<u32, 8>;\n+\n+/// Vector of 16 `u32` values\n+pub type u32x16 = Simd<u32, 16>;\n+\n+/// Vector of two `u64` values\n+pub type u64x2 = Simd<u64, 2>;\n+\n+/// Vector of four `u64` values\n+pub type u64x4 = Simd<u64, 4>;\n+\n+/// Vector of eight `u64` values\n+pub type u64x8 = Simd<u64, 8>;\n+\n+/// Vector of four `u8` values\n+pub type u8x4 = Simd<u8, 4>;\n+\n+/// Vector of eight `u8` values\n+pub type u8x8 = Simd<u8, 8>;\n+\n+/// Vector of 16 `u8` values\n+pub type u8x16 = Simd<u8, 16>;\n+\n+/// Vector of 32 `u8` values\n+pub type u8x32 = Simd<u8, 32>;\n+\n+/// Vector of 64 `u8` values\n+pub type u8x64 = Simd<u8, 64>;"}, {"sha": "e8ce7176b4f219d4ccb2ed85474365a0916759e2", "filename": "library/portable-simd/crates/core_simd/src/vendor.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,29 @@\n+/// Provides implementations of `From<$a> for $b` and `From<$b> for $a` that transmutes the value.\n+#[allow(unused)]\n+macro_rules! from_transmute {\n+    { unsafe $a:ty => $b:ty } => {\n+        from_transmute!{ @impl $a => $b }\n+        from_transmute!{ @impl $b => $a }\n+    };\n+    { @impl $from:ty => $to:ty } => {\n+        impl core::convert::From<$from> for $to {\n+            #[inline]\n+            fn from(value: $from) -> $to {\n+                unsafe { core::mem::transmute(value) }\n+            }\n+        }\n+    };\n+}\n+\n+/// Conversions to x86's SIMD types.\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+mod x86;\n+\n+#[cfg(any(target_arch = \"wasm32\"))]\n+mod wasm32;\n+\n+#[cfg(any(target_arch = \"aarch64\", target_arch = \"arm\",))]\n+mod arm;\n+\n+#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n+mod powerpc;"}, {"sha": "ff3b69ccf959221fa0814b326082531938522640", "filename": "library/portable-simd/crates/core_simd/src/vendor/arm.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,76 @@\n+#![allow(unused)]\n+use crate::simd::*;\n+\n+#[cfg(target_arch = \"arm\")]\n+use core::arch::arm::*;\n+\n+#[cfg(target_arch = \"aarch64\")]\n+use core::arch::aarch64::*;\n+\n+#[cfg(any(\n+    target_arch = \"aarch64\",\n+    all(target_arch = \"arm\", target_feature = \"v7\"),\n+))]\n+mod neon {\n+    use super::*;\n+\n+    from_transmute! { unsafe f32x2 => float32x2_t }\n+    from_transmute! { unsafe f32x4 => float32x4_t }\n+\n+    from_transmute! { unsafe u8x8 => uint8x8_t }\n+    from_transmute! { unsafe u8x16 => uint8x16_t }\n+    from_transmute! { unsafe i8x8 => int8x8_t }\n+    from_transmute! { unsafe i8x16 => int8x16_t }\n+    from_transmute! { unsafe u8x8 => poly8x8_t }\n+    from_transmute! { unsafe u8x16 => poly8x16_t }\n+\n+    from_transmute! { unsafe u16x4 => uint16x4_t }\n+    from_transmute! { unsafe u16x8 => uint16x8_t }\n+    from_transmute! { unsafe i16x4 => int16x4_t }\n+    from_transmute! { unsafe i16x8 => int16x8_t }\n+    from_transmute! { unsafe u16x4 => poly16x4_t }\n+    from_transmute! { unsafe u16x8 => poly16x8_t }\n+\n+    from_transmute! { unsafe u32x2 => uint32x2_t }\n+    from_transmute! { unsafe u32x4 => uint32x4_t }\n+    from_transmute! { unsafe i32x2 => int32x2_t }\n+    from_transmute! { unsafe i32x4 => int32x4_t }\n+\n+    from_transmute! { unsafe Simd<u64, 1> => uint64x1_t }\n+    from_transmute! { unsafe u64x2 => uint64x2_t }\n+    from_transmute! { unsafe Simd<i64, 1> => int64x1_t }\n+    from_transmute! { unsafe i64x2 => int64x2_t }\n+    from_transmute! { unsafe Simd<u64, 1> => poly64x1_t }\n+    from_transmute! { unsafe u64x2 => poly64x2_t }\n+}\n+\n+#[cfg(any(\n+    all(target_feature = \"v5te\", not(target_feature = \"mclass\")),\n+    all(target_feature = \"mclass\", target_feature = \"dsp\"),\n+))]\n+mod dsp {\n+    use super::*;\n+\n+    from_transmute! { unsafe Simd<u16, 2> => uint16x2_t }\n+    from_transmute! { unsafe Simd<i16, 2> => int16x2_t }\n+}\n+\n+#[cfg(any(\n+    all(target_feature = \"v6\", not(target_feature = \"mclass\")),\n+    all(target_feature = \"mclass\", target_feature = \"dsp\"),\n+))]\n+mod simd32 {\n+    use super::*;\n+\n+    from_transmute! { unsafe Simd<u8, 4> => uint8x4_t }\n+    from_transmute! { unsafe Simd<i8, 4> => int8x4_t }\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod aarch64 {\n+    use super::neon::*;\n+    use super::*;\n+\n+    from_transmute! { unsafe Simd<f64, 1> => float64x1_t }\n+    from_transmute! { unsafe f64x2 => float64x2_t }\n+}"}, {"sha": "92f97d471b6e8690333f0d14f784f555fc2efd11", "filename": "library/portable-simd/crates/core_simd/src/vendor/powerpc.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fpowerpc.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,11 @@\n+use crate::simd::*;\n+\n+#[cfg(target_arch = \"powerpc\")]\n+use core::arch::powerpc::*;\n+\n+#[cfg(target_arch = \"powerpc64\")]\n+use core::arch::powerpc64::*;\n+\n+from_transmute! { unsafe f64x2 => vector_double }\n+from_transmute! { unsafe i64x2 => vector_signed_long }\n+from_transmute! { unsafe u64x2 => vector_unsigned_long }"}, {"sha": "ef3baf885b0fbf4e564f8be0acc000d94e25db92", "filename": "library/portable-simd/crates/core_simd/src/vendor/wasm32.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fwasm32.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,30 @@\n+use crate::simd::*;\n+use core::arch::wasm32::v128;\n+\n+from_transmute! { unsafe u8x16 => v128 }\n+from_transmute! { unsafe i8x16 => v128 }\n+\n+from_transmute! { unsafe u16x8 => v128 }\n+from_transmute! { unsafe i16x8 => v128 }\n+\n+from_transmute! { unsafe u32x4 => v128 }\n+from_transmute! { unsafe i32x4 => v128 }\n+from_transmute! { unsafe f32x4 => v128 }\n+\n+from_transmute! { unsafe u64x2 => v128 }\n+from_transmute! { unsafe i64x2 => v128 }\n+from_transmute! { unsafe f64x2 => v128 }\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod p32 {\n+    use super::*;\n+    from_transmute! { unsafe usizex4 => v128 }\n+    from_transmute! { unsafe isizex4 => v128 }\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod p64 {\n+    use super::*;\n+    from_transmute! { unsafe usizex2 => v128 }\n+    from_transmute! { unsafe isizex2 => v128 }\n+}"}, {"sha": "d3c19ccc539ad4564bab7e35e2de57881686dcf4", "filename": "library/portable-simd/crates/core_simd/src/vendor/x86.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,63 @@\n+use crate::simd::*;\n+\n+#[cfg(any(target_arch = \"x86\"))]\n+use core::arch::x86::*;\n+\n+#[cfg(target_arch = \"x86_64\")]\n+use core::arch::x86_64::*;\n+\n+from_transmute! { unsafe u8x16 => __m128i }\n+from_transmute! { unsafe u8x32 => __m256i }\n+//from_transmute! { unsafe u8x64 => __m512i }\n+from_transmute! { unsafe i8x16 => __m128i }\n+from_transmute! { unsafe i8x32 => __m256i }\n+//from_transmute! { unsafe i8x64 => __m512i }\n+\n+from_transmute! { unsafe u16x8 => __m128i }\n+from_transmute! { unsafe u16x16 => __m256i }\n+from_transmute! { unsafe u16x32 => __m512i }\n+from_transmute! { unsafe i16x8 => __m128i }\n+from_transmute! { unsafe i16x16 => __m256i }\n+from_transmute! { unsafe i16x32 => __m512i }\n+\n+from_transmute! { unsafe u32x4 => __m128i }\n+from_transmute! { unsafe u32x8 => __m256i }\n+from_transmute! { unsafe u32x16 => __m512i }\n+from_transmute! { unsafe i32x4 => __m128i }\n+from_transmute! { unsafe i32x8 => __m256i }\n+from_transmute! { unsafe i32x16 => __m512i }\n+from_transmute! { unsafe f32x4 => __m128 }\n+from_transmute! { unsafe f32x8 => __m256 }\n+from_transmute! { unsafe f32x16 => __m512 }\n+\n+from_transmute! { unsafe u64x2 => __m128i }\n+from_transmute! { unsafe u64x4 => __m256i }\n+from_transmute! { unsafe u64x8 => __m512i }\n+from_transmute! { unsafe i64x2 => __m128i }\n+from_transmute! { unsafe i64x4 => __m256i }\n+from_transmute! { unsafe i64x8 => __m512i }\n+from_transmute! { unsafe f64x2 => __m128d }\n+from_transmute! { unsafe f64x4 => __m256d }\n+from_transmute! { unsafe f64x8 => __m512d }\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod p32 {\n+    use super::*;\n+    from_transmute! { unsafe usizex4 => __m128i }\n+    from_transmute! { unsafe usizex8 => __m256i }\n+    from_transmute! { unsafe Simd<usize, 16> => __m512i }\n+    from_transmute! { unsafe isizex4 => __m128i }\n+    from_transmute! { unsafe isizex8 => __m256i }\n+    from_transmute! { unsafe Simd<isize, 16> => __m512i }\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod p64 {\n+    use super::*;\n+    from_transmute! { unsafe usizex2 => __m128i }\n+    from_transmute! { unsafe usizex4 => __m256i }\n+    from_transmute! { unsafe usizex8 => __m512i }\n+    from_transmute! { unsafe isizex2 => __m128i }\n+    from_transmute! { unsafe isizex4 => __m256i }\n+    from_transmute! { unsafe isizex8 => __m512i }\n+}"}, {"sha": "414a832b1be4128d4d3d162ea9982c9601791703", "filename": "library/portable-simd/crates/core_simd/tests/f32_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ff32_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_float_tests! { f32, i32 }"}, {"sha": "e0a1fa33f33270c1204f00bbade90d3f1fb22a63", "filename": "library/portable-simd/crates/core_simd/tests/f64_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ff64_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_float_tests! { f64, i64 }"}, {"sha": "f6c5d74fbbcc62ffcd2f044b33b9ed594e31abbd", "filename": "library/portable-simd/crates/core_simd/tests/i16_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi16_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { i16 }"}, {"sha": "69a831c52a3faacdaf57305058cac5e4bf287e2f", "filename": "library/portable-simd/crates/core_simd/tests/i32_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi32_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { i32 }"}, {"sha": "37ac08117424c5515c85d70032c3d773a966da46", "filename": "library/portable-simd/crates/core_simd/tests/i64_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi64_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { i64 }"}, {"sha": "11e4a5cd6a9a75e42798902ac65bbdfa04448265", "filename": "library/portable-simd/crates/core_simd/tests/i8_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi8_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi8_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fi8_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { i8 }"}, {"sha": "5cc9de2b7ff8297c883c8cab5f2f78cfa5021ad5", "filename": "library/portable-simd/crates/core_simd/tests/isize_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fisize_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fisize_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fisize_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_signed_tests! { isize }"}, {"sha": "f113b50cb769df9e7959b5adfd6ba2d4d3b6ec72", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,3 @@\n+#![feature(portable_simd)]\n+\n+mod mask_ops_impl;"}, {"sha": "0fe82fa680479a457a7e37852a2d5f0fed94e7bc", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/mask16.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask16.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,4 @@\n+mask_tests! { mask16x4, 4 }\n+mask_tests! { mask16x8, 8 }\n+mask_tests! { mask16x16, 16 }\n+mask_tests! { mask16x32, 32 }"}, {"sha": "66d987a43ce83c295a96e014c3fce7e839ee435a", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/mask32.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask32.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,4 @@\n+mask_tests! { mask32x2, 2 }\n+mask_tests! { mask32x4, 4 }\n+mask_tests! { mask32x8, 8 }\n+mask_tests! { mask32x16, 16 }"}, {"sha": "a1f1f67b23887641de455b53796d1e323e038c8b", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/mask64.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask64.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,3 @@\n+mask_tests! { mask64x2, 2 }\n+mask_tests! { mask64x4, 4 }\n+mask_tests! { mask64x8, 8 }"}, {"sha": "9c06fbc0411d2fcd266c108ae33f8d41bc1e1895", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/mask8.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,3 @@\n+mask_tests! { mask8x8, 8 }\n+mask_tests! { mask8x16, 16 }\n+mask_tests! { mask8x32, 32 }"}, {"sha": "795f9e27c4458fa1dcefeb5e23ece1f66d4d859e", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/mask_macros.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,225 @@\n+macro_rules! mask_tests {\n+    { $vector:ident, $lanes:literal } => {\n+        #[cfg(test)]\n+        mod $vector {\n+            use core_simd::$vector as Vector;\n+            const LANES: usize = $lanes;\n+\n+            #[cfg(target_arch = \"wasm32\")]\n+            use wasm_bindgen_test::*;\n+\n+            #[cfg(target_arch = \"wasm32\")]\n+            wasm_bindgen_test_configure!(run_in_browser);\n+\n+            fn from_slice(slice: &[bool]) -> Vector {\n+                let mut value = Vector::default();\n+                for (i, b) in slice.iter().take(LANES).enumerate() {\n+                    value.set(i, *b);\n+                }\n+                value\n+            }\n+\n+            fn apply_unary_lanewise(x: Vector, f: impl Fn(bool) -> bool) -> Vector {\n+                let mut value = Vector::default();\n+                for i in 0..LANES {\n+                    value.set(i, f(x.test(i)));\n+                }\n+                value\n+            }\n+\n+            fn apply_binary_lanewise(x: Vector, y: Vector, f: impl Fn(bool, bool) -> bool) -> Vector {\n+                let mut value = Vector::default();\n+                for i in 0..LANES {\n+                    value.set(i, f(x.test(i), y.test(i)));\n+                }\n+                value\n+            }\n+\n+            fn apply_binary_scalar_lhs_lanewise(x: bool, mut y: Vector, f: impl Fn(bool, bool) -> bool) -> Vector {\n+                for i in 0..LANES {\n+                    y.set(i, f(x, y.test(i)));\n+                }\n+                y\n+            }\n+\n+            fn apply_binary_scalar_rhs_lanewise(mut x: Vector, y: bool, f: impl Fn(bool, bool) -> bool) -> Vector {\n+                for i in 0..LANES {\n+                    x.set(i, f(x.test(i), y));\n+                }\n+                x\n+            }\n+\n+            const A: [bool; 64] = [\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+                false, true, false, true, false, false, true, true,\n+            ];\n+            const B: [bool; 64] = [\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+                false, false, true, true, false, true, false, true,\n+            ];\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitand() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n+                assert_eq!(a & b, expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitand_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n+                a &= b;\n+                assert_eq!(a, expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitand_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let expected = a;\n+                assert_eq!(a & true, expected);\n+                assert_eq!(a & false, Vector::splat(false));\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitand_scalar_lhs() {\n+                let a = from_slice(&A);\n+                let expected = a;\n+                assert_eq!(true & a, expected);\n+                assert_eq!(false & a, Vector::splat(false));\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitand_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let expected = a;\n+                a &= true;\n+                assert_eq!(a, expected);\n+                a &= false;\n+                assert_eq!(a, Vector::splat(false));\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitor() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n+                assert_eq!(a | b, expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitor_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n+                a |= b;\n+                assert_eq!(a, expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitor_scalar_rhs() {\n+                let a = from_slice(&A);\n+                assert_eq!(a | false, a);\n+                assert_eq!(a | true, Vector::splat(true));\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitor_scalar_lhs() {\n+                let a = from_slice(&A);\n+                assert_eq!(false | a, a);\n+                assert_eq!(true | a, Vector::splat(true));\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitor_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let expected = a;\n+                a |= false;\n+                assert_eq!(a, expected);\n+                a |= true;\n+                assert_eq!(a, Vector::splat(true));\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitxor() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n+                assert_eq!(a ^ b, expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitxor_assign() {\n+                let mut a = from_slice(&A);\n+                let b = from_slice(&B);\n+                let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n+                a ^= b;\n+                assert_eq!(a, expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitxor_scalar_rhs() {\n+                let a = from_slice(&A);\n+                let expected = apply_binary_scalar_rhs_lanewise(a, true, core::ops::BitXor::bitxor);\n+                assert_eq!(a ^ false, a);\n+                assert_eq!(a ^ true, expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitxor_scalar_lhs() {\n+                let a = from_slice(&A);\n+                let expected = apply_binary_scalar_lhs_lanewise(true, a, core::ops::BitXor::bitxor);\n+                assert_eq!(false ^ a, a);\n+                assert_eq!(true ^ a, expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn bitxor_assign_scalar() {\n+                let mut a = from_slice(&A);\n+                let expected_unset = a;\n+                let expected_set = apply_binary_scalar_rhs_lanewise(a, true, core::ops::BitXor::bitxor);\n+                a ^= false;\n+                assert_eq!(a, expected_unset);\n+                a ^= true;\n+                assert_eq!(a, expected_set);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn not() {\n+                let v = from_slice(&A);\n+                let expected = apply_unary_lanewise(v, core::ops::Not::not);\n+                assert_eq!(!v, expected);\n+            }\n+        }\n+    }\n+}"}, {"sha": "e0a44d870ca56b9bdd2e73085e6f9e59e3ac14c1", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/masksize.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmasksize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmasksize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmasksize.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,3 @@\n+mask_tests! { masksizex2, 2 }\n+mask_tests! { masksizex4, 4 }\n+mask_tests! { masksizex8, 8 }"}, {"sha": "b9ec8462a052fb6ac27a6652bbe699622f9af404", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,9 @@\n+#[macro_use]\n+mod mask_macros;\n+\n+#[rustfmt::skip]\n+mod mask8;\n+mod mask16;\n+mod mask32;\n+mod mask64;\n+mod masksize;"}, {"sha": "6a8ecd33a73cfe0e2ea6d1494452233520e287dc", "filename": "library/portable-simd/crates/core_simd/tests/masks.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,102 @@\n+#![feature(portable_simd)]\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+macro_rules! test_mask_api {\n+    { $type:ident } => {\n+        #[allow(non_snake_case)]\n+        mod $type {\n+            #[cfg(target_arch = \"wasm32\")]\n+            use wasm_bindgen_test::*;\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn set_and_test() {\n+                let values = [true, false, false, true, false, false, true, false];\n+                let mut mask = core_simd::Mask::<$type, 8>::splat(false);\n+                for (lane, value) in values.iter().copied().enumerate() {\n+                    mask.set(lane, value);\n+                }\n+                for (lane, value) in values.iter().copied().enumerate() {\n+                    assert_eq!(mask.test(lane), value);\n+                }\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn set_invalid_lane() {\n+                let mut mask = core_simd::Mask::<$type, 8>::splat(false);\n+                mask.set(8, true);\n+                let _ = mask;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn test_invalid_lane() {\n+                let mask = core_simd::Mask::<$type, 8>::splat(false);\n+                let _ = mask.test(8);\n+            }\n+\n+            #[test]\n+            fn any() {\n+                assert!(!core_simd::Mask::<$type, 8>::splat(false).any());\n+                assert!(core_simd::Mask::<$type, 8>::splat(true).any());\n+                let mut v = core_simd::Mask::<$type, 8>::splat(false);\n+                v.set(2, true);\n+                assert!(v.any());\n+            }\n+\n+            #[test]\n+            fn all() {\n+                assert!(!core_simd::Mask::<$type, 8>::splat(false).all());\n+                assert!(core_simd::Mask::<$type, 8>::splat(true).all());\n+                let mut v = core_simd::Mask::<$type, 8>::splat(false);\n+                v.set(2, true);\n+                assert!(!v.all());\n+            }\n+\n+            #[test]\n+            fn roundtrip_int_conversion() {\n+                let values = [true, false, false, true, false, false, true, false];\n+                let mask = core_simd::Mask::<$type, 8>::from_array(values);\n+                let int = mask.to_int();\n+                assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n+                assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n+            }\n+\n+            #[cfg(feature = \"generic_const_exprs\")]\n+            #[test]\n+            fn roundtrip_bitmask_conversion() {\n+                let values = [\n+                    true, false, false, true, false, false, true, false,\n+                    true, true, false, false, false, false, false, true,\n+                ];\n+                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n+                let bitmask = mask.to_bitmask();\n+                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n+            }\n+        }\n+    }\n+}\n+\n+mod mask_api {\n+    test_mask_api! { i8 }\n+    test_mask_api! { i16 }\n+    test_mask_api! { i32 }\n+    test_mask_api! { i64 }\n+    test_mask_api! { isize }\n+}\n+\n+#[test]\n+fn convert() {\n+    let values = [true, false, false, true, false, false, true, false];\n+    assert_eq!(\n+        core_simd::Mask::<i8, 8>::from_array(values),\n+        core_simd::Mask::<i32, 8>::from_array(values).into()\n+    );\n+}"}, {"sha": "31b7ee2069590a516970b5925c0628346dd64ca2", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "added", "additions": 618, "deletions": 0, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,618 @@\n+/// Implements a test on a unary operation using proptest.\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n+#[macro_export]\n+macro_rules! impl_unary_op_test {\n+    { $scalar:ty, $trait:ident :: $fn:ident, $scalar_fn:expr } => {\n+        test_helpers::test_lanes! {\n+            fn $fn<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    &<core_simd::Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n+                    &$scalar_fn,\n+                    &|_| true,\n+                );\n+            }\n+        }\n+    };\n+    { $scalar:ty, $trait:ident :: $fn:ident } => {\n+        impl_unary_op_test! { $scalar, $trait::$fn, <$scalar as core::ops::$trait>::$fn }\n+    };\n+}\n+\n+/// Implements a test on a binary operation using proptest.\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n+#[macro_export]\n+macro_rules! impl_binary_op_test {\n+    { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr } => {\n+        mod $fn {\n+            use super::*;\n+            use core_simd::Simd;\n+\n+            test_helpers::test_lanes! {\n+                fn normal<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &<Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+\n+                fn scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+\n+                fn scalar_lhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_lhs_elementwise(\n+                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+\n+                fn assign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+\n+                fn assign_scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        &$scalar_fn,\n+                        &|_, _| true,\n+                    );\n+                }\n+            }\n+        }\n+    };\n+    { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident } => {\n+        impl_binary_op_test! { $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn }\n+    };\n+}\n+\n+/// Implements a test on a binary operation using proptest.\n+///\n+/// Like `impl_binary_op_test`, but allows providing a function for rejecting particular inputs\n+/// (like the `proptest_assume` macro).\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n+#[macro_export]\n+macro_rules! impl_binary_checked_op_test {\n+    { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr, $check_fn:expr } => {\n+        mod $fn {\n+            use super::*;\n+            use core_simd::Simd;\n+\n+            test_helpers::test_lanes! {\n+                fn normal<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &<Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n+                        &$scalar_fn,\n+                        &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n+                    );\n+                }\n+\n+                fn scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n+                        &$scalar_fn,\n+                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n+                    );\n+                }\n+\n+                fn scalar_lhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_lhs_elementwise(\n+                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n+                        &$scalar_fn,\n+                        &|x, y| y.iter().all(|y| $check_fn(x, *y)),\n+                    );\n+                }\n+\n+                fn assign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        &$scalar_fn,\n+                        &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n+                    )\n+                }\n+\n+                fn assign_scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        &$scalar_fn,\n+                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n+                    )\n+                }\n+            }\n+        }\n+    };\n+    { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $check_fn:expr } => {\n+        impl_binary_checked_op_test! { $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn, $check_fn }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! impl_common_integer_tests {\n+    { $vector:ident, $scalar:ident } => {\n+        test_helpers::test_lanes! {\n+            fn horizontal_sum<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_sum(),\n+                        x.iter().copied().fold(0 as $scalar, $scalar::wrapping_add),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_product<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_product(),\n+                        x.iter().copied().fold(1 as $scalar, $scalar::wrapping_mul),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_and<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_and(),\n+                        x.iter().copied().fold(-1i8 as $scalar, <$scalar as core::ops::BitAnd>::bitand),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_or<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_or(),\n+                        x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitOr>::bitor),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_xor<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_xor(),\n+                        x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitXor>::bitxor),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_max<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_max(),\n+                        x.iter().copied().max().unwrap(),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_min<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_min(),\n+                        x.iter().copied().min().unwrap(),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+/// Implement tests for signed integers.\n+#[macro_export]\n+macro_rules! impl_signed_tests {\n+    { $scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            type Scalar = $scalar;\n+\n+            impl_common_integer_tests! { Vector, Scalar }\n+\n+            test_helpers::test_lanes! {\n+                fn neg<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &<Vector::<LANES> as core::ops::Neg>::neg,\n+                        &<Scalar as core::ops::Neg>::neg,\n+                        &|x| !x.contains(&Scalar::MIN),\n+                    );\n+                }\n+\n+                fn is_positive<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_positive,\n+                        &Scalar::is_positive,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_negative<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_negative,\n+                        &Scalar::is_negative,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn signum<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::signum,\n+                        &Scalar::signum,\n+                        &|_| true,\n+                    )\n+                }\n+\n+            }\n+\n+            test_helpers::test_lanes_panic! {\n+                fn div_min_overflow_panics<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    let _ = a / b;\n+                }\n+\n+                fn div_by_all_zeros_panics<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(0);\n+                    let _ = a / b;\n+                }\n+\n+                fn div_by_one_zero_panics<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let mut b = Vector::<LANES>::splat(21);\n+                    b[0] = 0 as _;\n+                    let _ = a / b;\n+                }\n+\n+                fn rem_min_overflow_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    let _ = a % b;\n+                }\n+\n+                fn rem_zero_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(0);\n+                    let _ = a % b;\n+                }\n+            }\n+\n+            test_helpers::test_lanes! {\n+                fn div_neg_one_no_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    let _ = a / b;\n+                }\n+\n+                fn rem_neg_one_no_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    let _ = a % b;\n+                }\n+            }\n+\n+            impl_binary_op_test!(Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n+            impl_binary_op_test!(Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n+            impl_binary_op_test!(Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+\n+            // Exclude Div and Rem panicking cases\n+            impl_binary_checked_op_test!(Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n+            impl_binary_checked_op_test!(Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n+\n+            impl_unary_op_test!(Scalar, Not::not);\n+            impl_binary_op_test!(Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n+            impl_binary_op_test!(Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n+            impl_binary_op_test!(Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n+        }\n+    }\n+}\n+\n+/// Implement tests for unsigned integers.\n+#[macro_export]\n+macro_rules! impl_unsigned_tests {\n+    { $scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            type Scalar = $scalar;\n+\n+            impl_common_integer_tests! { Vector, Scalar }\n+\n+            test_helpers::test_lanes_panic! {\n+                fn rem_zero_panic<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(42);\n+                    let b = Vector::<LANES>::splat(0);\n+                    let _ = a % b;\n+                }\n+            }\n+\n+            impl_binary_op_test!(Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n+            impl_binary_op_test!(Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n+            impl_binary_op_test!(Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+\n+            // Exclude Div and Rem panicking cases\n+            impl_binary_checked_op_test!(Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |_, y| y != 0);\n+            impl_binary_checked_op_test!(Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |_, y| y != 0);\n+\n+            impl_unary_op_test!(Scalar, Not::not);\n+            impl_binary_op_test!(Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n+            impl_binary_op_test!(Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n+            impl_binary_op_test!(Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n+        }\n+    }\n+}\n+\n+/// Implement tests for floating point numbers.\n+#[macro_export]\n+macro_rules! impl_float_tests {\n+    { $scalar:tt, $int_scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            type Scalar = $scalar;\n+\n+            impl_unary_op_test!(Scalar, Neg::neg);\n+            impl_binary_op_test!(Scalar, Add::add, AddAssign::add_assign);\n+            impl_binary_op_test!(Scalar, Sub::sub, SubAssign::sub_assign);\n+            impl_binary_op_test!(Scalar, Mul::mul, MulAssign::mul_assign);\n+            impl_binary_op_test!(Scalar, Div::div, DivAssign::div_assign);\n+            impl_binary_op_test!(Scalar, Rem::rem, RemAssign::rem_assign);\n+\n+            test_helpers::test_lanes! {\n+                fn is_sign_positive<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_sign_positive,\n+                        &Scalar::is_sign_positive,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_sign_negative<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_sign_negative,\n+                        &Scalar::is_sign_negative,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_finite<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_finite,\n+                        &Scalar::is_finite,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_infinite<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_infinite,\n+                        &Scalar::is_infinite,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_nan<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_nan,\n+                        &Scalar::is_nan,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_normal<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_normal,\n+                        &Scalar::is_normal,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_subnormal<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_subnormal,\n+                        &Scalar::is_subnormal,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn abs<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::abs,\n+                        &Scalar::abs,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn recip<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::recip,\n+                        &Scalar::recip,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn to_degrees<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::to_degrees,\n+                        &Scalar::to_degrees,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn to_radians<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::to_radians,\n+                        &Scalar::to_radians,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn signum<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::signum,\n+                        &Scalar::signum,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn copysign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &Vector::<LANES>::copysign,\n+                        &Scalar::copysign,\n+                        &|_, _| true,\n+                    )\n+                }\n+\n+                fn min<const LANES: usize>() {\n+                    // Regular conditions (both values aren't zero)\n+                    test_helpers::test_binary_elementwise(\n+                        &Vector::<LANES>::min,\n+                        &Scalar::min,\n+                        // Reject the case where both values are zero with different signs\n+                        &|a, b| {\n+                            for (a, b) in a.iter().zip(b.iter()) {\n+                                if *a == 0. && *b == 0. && a.signum() != b.signum() {\n+                                    return false;\n+                                }\n+                            }\n+                            true\n+                        }\n+                    );\n+\n+                    // Special case where both values are zero\n+                    let p_zero = Vector::<LANES>::splat(0.);\n+                    let n_zero = Vector::<LANES>::splat(-0.);\n+                    assert!(p_zero.min(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.min(p_zero).to_array().iter().all(|x| *x == 0.));\n+                }\n+\n+                fn max<const LANES: usize>() {\n+                    // Regular conditions (both values aren't zero)\n+                    test_helpers::test_binary_elementwise(\n+                        &Vector::<LANES>::max,\n+                        &Scalar::max,\n+                        // Reject the case where both values are zero with different signs\n+                        &|a, b| {\n+                            for (a, b) in a.iter().zip(b.iter()) {\n+                                if *a == 0. && *b == 0. && a.signum() != b.signum() {\n+                                    return false;\n+                                }\n+                            }\n+                            true\n+                        }\n+                    );\n+\n+                    // Special case where both values are zero\n+                    let p_zero = Vector::<LANES>::splat(0.);\n+                    let n_zero = Vector::<LANES>::splat(-0.);\n+                    assert!(p_zero.max(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.max(p_zero).to_array().iter().all(|x| *x == 0.));\n+                }\n+\n+                fn clamp<const LANES: usize>() {\n+                    test_helpers::test_3(&|value: [Scalar; LANES], mut min: [Scalar; LANES], mut max: [Scalar; LANES]| {\n+                        for (min, max) in min.iter_mut().zip(max.iter_mut()) {\n+                            if max < min {\n+                                core::mem::swap(min, max);\n+                            }\n+                            if min.is_nan() {\n+                                *min = Scalar::NEG_INFINITY;\n+                            }\n+                            if max.is_nan() {\n+                                *max = Scalar::INFINITY;\n+                            }\n+                        }\n+\n+                        let mut result_scalar = [Scalar::default(); LANES];\n+                        for i in 0..LANES {\n+                            result_scalar[i] = value[i].clamp(min[i], max[i]);\n+                        }\n+                        let result_vector = Vector::from_array(value).clamp(min.into(), max.into()).to_array();\n+                        test_helpers::prop_assert_biteq!(result_scalar, result_vector);\n+                        Ok(())\n+                    })\n+                }\n+\n+                fn horizontal_sum<const LANES: usize>() {\n+                    test_helpers::test_1(&|x| {\n+                        test_helpers::prop_assert_biteq! (\n+                            Vector::<LANES>::from_array(x).horizontal_sum(),\n+                            x.iter().sum(),\n+                        );\n+                        Ok(())\n+                    });\n+                }\n+\n+                fn horizontal_product<const LANES: usize>() {\n+                    test_helpers::test_1(&|x| {\n+                        test_helpers::prop_assert_biteq! (\n+                            Vector::<LANES>::from_array(x).horizontal_product(),\n+                            x.iter().product(),\n+                        );\n+                        Ok(())\n+                    });\n+                }\n+\n+                fn horizontal_max<const LANES: usize>() {\n+                    test_helpers::test_1(&|x| {\n+                        let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n+                        let smax = x.iter().copied().fold(Scalar::NAN, Scalar::max);\n+                        // 0 and -0 are treated the same\n+                        if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {\n+                            test_helpers::prop_assert_biteq!(vmax, smax);\n+                        }\n+                        Ok(())\n+                    });\n+                }\n+\n+                fn horizontal_min<const LANES: usize>() {\n+                    test_helpers::test_1(&|x| {\n+                        let vmax = Vector::<LANES>::from_array(x).horizontal_min();\n+                        let smax = x.iter().copied().fold(Scalar::NAN, Scalar::min);\n+                        // 0 and -0 are treated the same\n+                        if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {\n+                            test_helpers::prop_assert_biteq!(vmax, smax);\n+                        }\n+                        Ok(())\n+                    });\n+                }\n+            }\n+\n+            #[cfg(feature = \"std\")]\n+            mod std {\n+                use super::*;\n+                test_helpers::test_lanes! {\n+                    fn sqrt<const LANES: usize>() {\n+                        test_helpers::test_unary_elementwise(\n+                            &Vector::<LANES>::sqrt,\n+                            &Scalar::sqrt,\n+                            &|_| true,\n+                        )\n+                    }\n+\n+                    fn mul_add<const LANES: usize>() {\n+                        test_helpers::test_ternary_elementwise(\n+                            &Vector::<LANES>::mul_add,\n+                            &Scalar::mul_add,\n+                            &|_, _, _| true,\n+                        )\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "11d617a6c2c56a639a066025de2c0488ec1fa7c9", "filename": "library/portable-simd/crates/core_simd/tests/round.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,92 @@\n+#![feature(portable_simd)]\n+\n+macro_rules! float_rounding_test {\n+    { $scalar:tt, $int_scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::Simd<$scalar, LANES>;\n+            type Scalar = $scalar;\n+            type IntScalar = $int_scalar;\n+\n+            #[cfg(feature = \"std\")]\n+            test_helpers::test_lanes! {\n+                fn ceil<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::ceil,\n+                        &Scalar::ceil,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn floor<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::floor,\n+                        &Scalar::floor,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn round<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::round,\n+                        &Scalar::round,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn trunc<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::trunc,\n+                        &Scalar::trunc,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn fract<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::fract,\n+                        &Scalar::fract,\n+                        &|_| true,\n+                    )\n+                }\n+            }\n+\n+            test_helpers::test_lanes! {\n+                fn from_int<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::round_from_int,\n+                        &|x| x as Scalar,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn to_int_unchecked<const LANES: usize>() {\n+                    // The maximum integer that can be represented by the equivalently sized float has\n+                    // all of the mantissa digits set to 1, pushed up to the MSB.\n+                    const ALL_MANTISSA_BITS: IntScalar = ((1 << <Scalar>::MANTISSA_DIGITS) - 1);\n+                    const MAX_REPRESENTABLE_VALUE: Scalar =\n+                        (ALL_MANTISSA_BITS << (core::mem::size_of::<Scalar>() * 8 - <Scalar>::MANTISSA_DIGITS as usize - 1)) as Scalar;\n+\n+                    let mut runner = proptest::test_runner::TestRunner::default();\n+                    runner.run(\n+                        &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n+                        |x| {\n+                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n+                            let result_2 = {\n+                                let mut result = [0; LANES];\n+                                for (i, o) in x.iter().zip(result.iter_mut()) {\n+                                    *o = unsafe { i.to_int_unchecked() };\n+                                }\n+                                result\n+                            };\n+                            test_helpers::prop_assert_biteq!(result_1, result_2);\n+                            Ok(())\n+                        },\n+                    ).unwrap();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+float_rounding_test! { f32, i32 }\n+float_rounding_test! { f64, i64 }"}, {"sha": "51c63611aba6b9fe0b381006c8c1a44b7b4e65fe", "filename": "library/portable-simd/crates/core_simd/tests/swizzle.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,62 @@\n+#![feature(portable_simd)]\n+use core_simd::{Simd, Swizzle};\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn swizzle() {\n+    struct Index;\n+    impl Swizzle<4, 4> for Index {\n+        const INDEX: [usize; 4] = [2, 1, 3, 0];\n+    }\n+    impl Swizzle<4, 2> for Index {\n+        const INDEX: [usize; 2] = [1, 1];\n+    }\n+\n+    let vector = Simd::from_array([2, 4, 1, 9]);\n+    assert_eq!(Index::swizzle(vector).to_array(), [1, 4, 9, 2]);\n+    assert_eq!(Index::swizzle(vector).to_array(), [4, 4]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn reverse() {\n+    let a = Simd::from_array([1, 2, 3, 4]);\n+    assert_eq!(a.reverse().to_array(), [4, 3, 2, 1]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn rotate() {\n+    let a = Simd::from_array([1, 2, 3, 4]);\n+    assert_eq!(a.rotate_lanes_left::<0>().to_array(), [1, 2, 3, 4]);\n+    assert_eq!(a.rotate_lanes_left::<1>().to_array(), [2, 3, 4, 1]);\n+    assert_eq!(a.rotate_lanes_left::<2>().to_array(), [3, 4, 1, 2]);\n+    assert_eq!(a.rotate_lanes_left::<3>().to_array(), [4, 1, 2, 3]);\n+    assert_eq!(a.rotate_lanes_left::<4>().to_array(), [1, 2, 3, 4]);\n+    assert_eq!(a.rotate_lanes_left::<5>().to_array(), [2, 3, 4, 1]);\n+    assert_eq!(a.rotate_lanes_right::<0>().to_array(), [1, 2, 3, 4]);\n+    assert_eq!(a.rotate_lanes_right::<1>().to_array(), [4, 1, 2, 3]);\n+    assert_eq!(a.rotate_lanes_right::<2>().to_array(), [3, 4, 1, 2]);\n+    assert_eq!(a.rotate_lanes_right::<3>().to_array(), [2, 3, 4, 1]);\n+    assert_eq!(a.rotate_lanes_right::<4>().to_array(), [1, 2, 3, 4]);\n+    assert_eq!(a.rotate_lanes_right::<5>().to_array(), [4, 1, 2, 3]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn interleave() {\n+    let a = Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n+    let b = Simd::from_array([8, 9, 10, 11, 12, 13, 14, 15]);\n+    let (lo, hi) = a.interleave(b);\n+    assert_eq!(lo.to_array(), [0, 8, 1, 9, 2, 10, 3, 11]);\n+    assert_eq!(hi.to_array(), [4, 12, 5, 13, 6, 14, 7, 15]);\n+    let (even, odd) = lo.deinterleave(hi);\n+    assert_eq!(even, a);\n+    assert_eq!(odd, b);\n+}"}, {"sha": "debb4335e2c9672d3b9c609f4290c1adcbc8addb", "filename": "library/portable-simd/crates/core_simd/tests/to_bytes.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,14 @@\n+#![feature(portable_simd, generic_const_exprs, adt_const_params)]\n+#![allow(incomplete_features)]\n+#![cfg(feature = \"generic_const_exprs\")]\n+\n+use core_simd::Simd;\n+\n+#[test]\n+fn byte_convert() {\n+    let int = Simd::<u32, 2>::from_array([0xdeadbeef, 0x8badf00d]);\n+    let bytes = int.to_ne_bytes();\n+    assert_eq!(int[0].to_ne_bytes(), bytes[..4]);\n+    assert_eq!(int[1].to_ne_bytes(), bytes[4..]);\n+    assert_eq!(Simd::<u32, 2>::from_ne_bytes(bytes), int);\n+}"}, {"sha": "9ae3bd6a47d00f511375d791bbc878c4e9b8d350", "filename": "library/portable-simd/crates/core_simd/tests/u16_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu16_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { u16 }"}, {"sha": "de34b73d652621e31881e928a2705342af3cdc3d", "filename": "library/portable-simd/crates/core_simd/tests/u32_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu32_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { u32 }"}, {"sha": "8ee5a318c83d75afe5a29d56cff28ff42d96e70f", "filename": "library/portable-simd/crates/core_simd/tests/u64_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu64_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { u64 }"}, {"sha": "6d7211121284bcbfcc1622df9ca0e504e0cfa2a3", "filename": "library/portable-simd/crates/core_simd/tests/u8_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu8_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu8_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fu8_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { u8 }"}, {"sha": "9c7b1687a08554f757b42184c6a12e8a5da2b208", "filename": "library/portable-simd/crates/core_simd/tests/usize_ops.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fusize_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fusize_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fusize_ops.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,5 @@\n+#![feature(portable_simd)]\n+\n+#[macro_use]\n+mod ops_macros;\n+impl_unsigned_tests! { usize }"}, {"sha": "f1d5734f1cebd23fcc61bca3a0a1b505865cc190", "filename": "library/portable-simd/crates/core_simd/webdriver.json", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fwebdriver.json", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fwebdriver.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fwebdriver.json?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,7 @@\n+{\n+    \"goog:chromeOptions\": {\n+        \"args\": [\n+            \"--enable-features=WebAssemblySimd\"\n+        ]\n+    }\n+}"}, {"sha": "a04b0961d7f701adb9c5857ecdff01cdc61c7670", "filename": "library/portable-simd/crates/test_helpers/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+name = \"test_helpers\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+publish = false\n+\n+[dependencies.proptest]\n+version = \"0.10\"\n+default-features = false\n+features = [\"alloc\"]"}, {"sha": "5ffc922697694948e5d12649bbbce9eeba4da966", "filename": "library/portable-simd/crates/test_helpers/src/array.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,97 @@\n+//! Generic-length array strategy.\n+\n+// Adapted from proptest's array code\n+// Copyright 2017 Jason Lingle\n+\n+use core::{marker::PhantomData, mem::MaybeUninit};\n+use proptest::{\n+    strategy::{NewTree, Strategy, ValueTree},\n+    test_runner::TestRunner,\n+};\n+\n+#[must_use = \"strategies do nothing unless used\"]\n+#[derive(Clone, Copy, Debug)]\n+pub struct UniformArrayStrategy<S, T> {\n+    strategy: S,\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<S, T> UniformArrayStrategy<S, T> {\n+    pub const fn new(strategy: S) -> Self {\n+        Self {\n+            strategy,\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+pub struct ArrayValueTree<T> {\n+    tree: T,\n+    shrinker: usize,\n+    last_shrinker: Option<usize>,\n+}\n+\n+impl<T, S, const LANES: usize> Strategy for UniformArrayStrategy<S, [T; LANES]>\n+where\n+    T: core::fmt::Debug,\n+    S: Strategy<Value = T>,\n+{\n+    type Tree = ArrayValueTree<[S::Tree; LANES]>;\n+    type Value = [T; LANES];\n+\n+    fn new_tree(&self, runner: &mut TestRunner) -> NewTree<Self> {\n+        let tree: [S::Tree; LANES] = unsafe {\n+            let mut tree: [MaybeUninit<S::Tree>; LANES] = MaybeUninit::uninit().assume_init();\n+            for t in tree.iter_mut() {\n+                *t = MaybeUninit::new(self.strategy.new_tree(runner)?)\n+            }\n+            core::mem::transmute_copy(&tree)\n+        };\n+        Ok(ArrayValueTree {\n+            tree,\n+            shrinker: 0,\n+            last_shrinker: None,\n+        })\n+    }\n+}\n+\n+impl<T: ValueTree, const LANES: usize> ValueTree for ArrayValueTree<[T; LANES]> {\n+    type Value = [T::Value; LANES];\n+\n+    fn current(&self) -> Self::Value {\n+        unsafe {\n+            let mut value: [MaybeUninit<T::Value>; LANES] = MaybeUninit::uninit().assume_init();\n+            for (tree_elem, value_elem) in self.tree.iter().zip(value.iter_mut()) {\n+                *value_elem = MaybeUninit::new(tree_elem.current());\n+            }\n+            core::mem::transmute_copy(&value)\n+        }\n+    }\n+\n+    fn simplify(&mut self) -> bool {\n+        while self.shrinker < LANES {\n+            if self.tree[self.shrinker].simplify() {\n+                self.last_shrinker = Some(self.shrinker);\n+                return true;\n+            } else {\n+                self.shrinker += 1;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn complicate(&mut self) -> bool {\n+        if let Some(shrinker) = self.last_shrinker {\n+            self.shrinker = shrinker;\n+            if self.tree[shrinker].complicate() {\n+                true\n+            } else {\n+                self.last_shrinker = None;\n+                false\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "00350e22418d029a63c9704e82205c14e3dd405f", "filename": "library/portable-simd/crates/test_helpers/src/biteq.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,106 @@\n+//! Compare numeric types by exact bit value.\n+\n+pub trait BitEq {\n+    fn biteq(&self, other: &Self) -> bool;\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;\n+}\n+\n+impl BitEq for bool {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+macro_rules! impl_integer_biteq {\n+    { $($type:ty),* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                self == other\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                write!(f, \"{:?} ({:x})\", self, self)\n+            }\n+        }\n+        )*\n+    };\n+}\n+\n+impl_integer_biteq! { u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize }\n+\n+macro_rules! impl_float_biteq {\n+    { $($type:ty),* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                if self.is_nan() && other.is_nan() {\n+                    true // exact nan bits don't matter\n+                } else {\n+                    self.to_bits() == other.to_bits()\n+                }\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                write!(f, \"{:?} ({:x})\", self, self.to_bits())\n+            }\n+        }\n+        )*\n+    };\n+}\n+\n+impl_float_biteq! { f32, f64 }\n+\n+impl<T: BitEq, const N: usize> BitEq for [T; N] {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self.iter()\n+            .zip(other.iter())\n+            .fold(true, |value, (left, right)| value && left.biteq(right))\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        #[repr(transparent)]\n+        struct Wrapper<'a, T: BitEq>(&'a T);\n+\n+        impl<T: BitEq> core::fmt::Debug for Wrapper<'_, T> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                self.0.fmt(f)\n+            }\n+        }\n+\n+        f.debug_list()\n+            .entries(self.iter().map(|x| Wrapper(x)))\n+            .finish()\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub struct BitEqWrapper<'a, T>(pub &'a T);\n+\n+impl<T: BitEq> PartialEq for BitEqWrapper<'_, T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.biteq(other.0)\n+    }\n+}\n+\n+impl<T: BitEq> core::fmt::Debug for BitEqWrapper<'_, T> {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! prop_assert_biteq {\n+    { $a:expr, $b:expr $(,)? } => {\n+        {\n+            use $crate::biteq::BitEqWrapper;\n+            let a = $a;\n+            let b = $b;\n+            proptest::prop_assert_eq!(BitEqWrapper(&a), BitEqWrapper(&b));\n+        }\n+    }\n+}"}, {"sha": "5c6478876f30be88797794d6c571fceb62193a1a", "filename": "library/portable-simd/crates/test_helpers/src/lib.rs", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,437 @@\n+pub mod array;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+pub mod wasm;\n+\n+#[macro_use]\n+pub mod biteq;\n+\n+/// Specifies the default strategy for testing a type.\n+///\n+/// This strategy should be what \"makes sense\" to test.\n+pub trait DefaultStrategy {\n+    type Strategy: proptest::strategy::Strategy<Value = Self>;\n+    fn default_strategy() -> Self::Strategy;\n+}\n+\n+macro_rules! impl_num {\n+    { $type:tt } => {\n+        impl DefaultStrategy for $type {\n+            type Strategy = proptest::num::$type::Any;\n+            fn default_strategy() -> Self::Strategy {\n+                proptest::num::$type::ANY\n+            }\n+        }\n+    }\n+}\n+\n+impl_num! { i8 }\n+impl_num! { i16 }\n+impl_num! { i32 }\n+impl_num! { i64 }\n+impl_num! { isize }\n+impl_num! { u8 }\n+impl_num! { u16 }\n+impl_num! { u32 }\n+impl_num! { u64 }\n+impl_num! { usize }\n+impl_num! { f32 }\n+impl_num! { f64 }\n+\n+#[cfg(not(target_arch = \"wasm32\"))]\n+impl DefaultStrategy for u128 {\n+    type Strategy = proptest::num::u128::Any;\n+    fn default_strategy() -> Self::Strategy {\n+        proptest::num::u128::ANY\n+    }\n+}\n+\n+#[cfg(not(target_arch = \"wasm32\"))]\n+impl DefaultStrategy for i128 {\n+    type Strategy = proptest::num::i128::Any;\n+    fn default_strategy() -> Self::Strategy {\n+        proptest::num::i128::ANY\n+    }\n+}\n+\n+#[cfg(target_arch = \"wasm32\")]\n+impl DefaultStrategy for u128 {\n+    type Strategy = crate::wasm::u128::Any;\n+    fn default_strategy() -> Self::Strategy {\n+        crate::wasm::u128::ANY\n+    }\n+}\n+\n+#[cfg(target_arch = \"wasm32\")]\n+impl DefaultStrategy for i128 {\n+    type Strategy = crate::wasm::i128::Any;\n+    fn default_strategy() -> Self::Strategy {\n+        crate::wasm::i128::ANY\n+    }\n+}\n+\n+impl<T: core::fmt::Debug + DefaultStrategy, const LANES: usize> DefaultStrategy for [T; LANES] {\n+    type Strategy = crate::array::UniformArrayStrategy<T::Strategy, Self>;\n+    fn default_strategy() -> Self::Strategy {\n+        Self::Strategy::new(T::default_strategy())\n+    }\n+}\n+\n+/// Test a function that takes a single value.\n+pub fn test_1<A: core::fmt::Debug + DefaultStrategy>(\n+    f: &dyn Fn(A) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner.run(&A::default_strategy(), f).unwrap();\n+}\n+\n+/// Test a function that takes two values.\n+pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + DefaultStrategy>(\n+    f: &dyn Fn(A, B) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner\n+        .run(&(A::default_strategy(), B::default_strategy()), |(a, b)| {\n+            f(a, b)\n+        })\n+        .unwrap();\n+}\n+\n+/// Test a function that takes two values.\n+pub fn test_3<\n+    A: core::fmt::Debug + DefaultStrategy,\n+    B: core::fmt::Debug + DefaultStrategy,\n+    C: core::fmt::Debug + DefaultStrategy,\n+>(\n+    f: &dyn Fn(A, B, C) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner\n+        .run(\n+            &(\n+                A::default_strategy(),\n+                B::default_strategy(),\n+                C::default_strategy(),\n+            ),\n+            |(a, b, c)| f(a, b, c),\n+        )\n+        .unwrap();\n+}\n+\n+/// Test a unary vector function against a unary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const LANES: usize>(\n+    fv: &dyn Fn(Vector) -> VectorResult,\n+    fs: &dyn Fn(Scalar) -> ScalarResult,\n+    check: &dyn Fn([Scalar; LANES]) -> bool,\n+) where\n+    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_1(&|x: [Scalar; LANES]| {\n+        proptest::prop_assume!(check(x));\n+        let result_1: [ScalarResult; LANES] = fv(x.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Test a unary vector function against a unary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_unary_mask_elementwise<Scalar, Vector, Mask, const LANES: usize>(\n+    fv: &dyn Fn(Vector) -> Mask,\n+    fs: &dyn Fn(Scalar) -> bool,\n+    check: &dyn Fn([Scalar; LANES]) -> bool,\n+) where\n+    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n+    Mask: Into<[bool; LANES]> + From<[bool; LANES]> + Copy,\n+{\n+    test_1(&|x: [Scalar; LANES]| {\n+        proptest::prop_assume!(check(x));\n+        let result_1: [bool; LANES] = fv(x.into()).into();\n+        let result_2: [bool; LANES] = {\n+            let mut result = [false; LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Test a binary vector function against a binary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_binary_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector1,\n+    Vector2,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: &dyn Fn(Vector1, Vector2) -> VectorResult,\n+    fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: &dyn Fn([Scalar1; LANES], [Scalar2; LANES]) -> bool,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n+    Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(&|x: [Scalar1; LANES], y: [Scalar2; LANES]| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_1: [ScalarResult; LANES] = fv(x.into(), y.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for ((i1, i2), o) in x.iter().zip(y.iter()).zip(result.iter_mut()) {\n+                *o = fs(*i1, *i2);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Test a binary vector-scalar function against a binary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_binary_scalar_rhs_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: &dyn Fn(Vector, Scalar2) -> VectorResult,\n+    fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: &dyn Fn([Scalar1; LANES], Scalar2) -> bool,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(&|x: [Scalar1; LANES], y: Scalar2| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_1: [ScalarResult; LANES] = fv(x.into(), y).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i, y);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Test a binary vector-scalar function against a binary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_binary_scalar_lhs_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: &dyn Fn(Scalar1, Vector) -> VectorResult,\n+    fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n+    check: &dyn Fn(Scalar1, [Scalar2; LANES]) -> bool,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(&|x: Scalar1, y: [Scalar2; LANES]| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_1: [ScalarResult; LANES] = fv(x, y.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in y.iter().zip(result.iter_mut()) {\n+                *o = fs(x, *i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+/// Test a ternary vector function against a ternary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_ternary_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    Scalar3,\n+    ScalarResult,\n+    Vector1,\n+    Vector2,\n+    Vector3,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: &dyn Fn(Vector1, Vector2, Vector3) -> VectorResult,\n+    fs: &dyn Fn(Scalar1, Scalar2, Scalar3) -> ScalarResult,\n+    check: &dyn Fn([Scalar1; LANES], [Scalar2; LANES], [Scalar3; LANES]) -> bool,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar3: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n+    Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n+    Vector3: Into<[Scalar3; LANES]> + From<[Scalar3; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_3(\n+        &|x: [Scalar1; LANES], y: [Scalar2; LANES], z: [Scalar3; LANES]| {\n+            proptest::prop_assume!(check(x, y, z));\n+            let result_1: [ScalarResult; LANES] = fv(x.into(), y.into(), z.into()).into();\n+            let result_2: [ScalarResult; LANES] = {\n+                let mut result = [ScalarResult::default(); LANES];\n+                for ((i1, (i2, i3)), o) in\n+                    x.iter().zip(y.iter().zip(z.iter())).zip(result.iter_mut())\n+                {\n+                    *o = fs(*i1, *i2, *i3);\n+                }\n+                result\n+            };\n+            crate::prop_assert_biteq!(result_1, result_2);\n+            Ok(())\n+        },\n+    );\n+}\n+\n+/// Expand a const-generic test into separate tests for each possible lane count.\n+#[macro_export]\n+macro_rules! test_lanes {\n+    {\n+        $(fn $test:ident<const $lanes:ident: usize>() $body:tt)*\n+    } => {\n+        $(\n+            mod $test {\n+                use super::*;\n+\n+                fn implementation<const $lanes: usize>()\n+                where\n+                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n+                $body\n+\n+                #[cfg(target_arch = \"wasm32\")]\n+                wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_1() {\n+                    implementation::<1>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_2() {\n+                    implementation::<2>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_4() {\n+                    implementation::<4>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_8() {\n+                    implementation::<8>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_16() {\n+                    implementation::<16>();\n+                }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_32() {\n+                    implementation::<32>();\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+/// Expand a const-generic `#[should_panic]` test into separate tests for each possible lane count.\n+#[macro_export]\n+macro_rules! test_lanes_panic {\n+    {\n+        $(fn $test:ident<const $lanes:ident: usize>() $body:tt)*\n+    } => {\n+        $(\n+            mod $test {\n+                use super::*;\n+\n+                fn implementation<const $lanes: usize>()\n+                where\n+                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n+                $body\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_1() {\n+                    implementation::<1>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_2() {\n+                    implementation::<2>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_4() {\n+                    implementation::<4>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_8() {\n+                    implementation::<8>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_16() {\n+                    implementation::<16>();\n+                }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_32() {\n+                    implementation::<32>();\n+                }\n+            }\n+        )*\n+    }\n+}"}, {"sha": "3f11d67cbf390bea2a93daaacaada98761e0a858", "filename": "library/portable-simd/crates/test_helpers/src/wasm.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fwasm.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,51 @@\n+//! Strategies for `u128` and `i128`, since proptest doesn't provide them for the wasm target.\n+\n+macro_rules! impl_num {\n+    { $name:ident } => {\n+        pub(crate) mod $name {\n+            type InnerStrategy = crate::array::UniformArrayStrategy<proptest::num::u64::Any, [u64; 2]>;\n+            use proptest::strategy::{Strategy, ValueTree, NewTree};\n+\n+\n+            #[must_use = \"strategies do nothing unless used\"]\n+            #[derive(Clone, Copy, Debug)]\n+            pub struct Any {\n+                strategy: InnerStrategy,\n+            }\n+\n+            pub struct BinarySearch {\n+                inner: <InnerStrategy as Strategy>::Tree,\n+            }\n+\n+            impl ValueTree for BinarySearch {\n+                type Value = $name;\n+\n+                fn current(&self) -> $name {\n+                    unsafe { core::mem::transmute(self.inner.current()) }\n+                }\n+\n+                fn simplify(&mut self) -> bool {\n+                    self.inner.simplify()\n+                }\n+\n+                fn complicate(&mut self) -> bool {\n+                    self.inner.complicate()\n+                }\n+            }\n+\n+            impl Strategy for Any {\n+                type Tree = BinarySearch;\n+                type Value = $name;\n+\n+                fn new_tree(&self, runner: &mut proptest::test_runner::TestRunner) -> NewTree<Self> {\n+                    Ok(BinarySearch { inner: self.strategy.new_tree(runner)? })\n+                }\n+            }\n+\n+            pub const ANY: Any = Any { strategy: InnerStrategy::new(proptest::num::u64::ANY) };\n+        }\n+    }\n+}\n+\n+impl_num! { u128 }\n+impl_num! { i128 }"}, {"sha": "59dff9f6771b6c6c3a0bbf24c18de3c15bf8c364", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -320,6 +320,7 @@\n #![feature(panic_internals)]\n #![feature(panic_unwind)]\n #![feature(pin_static_ref)]\n+#![cfg_attr(not(bootstrap), feature(portable_simd))]\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(rustc_attrs)]\n@@ -471,6 +472,9 @@ pub use core::pin;\n pub use core::ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::result;\n+#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+#[cfg(not(bootstrap))]\n+pub use core::simd;\n #[unstable(feature = \"async_stream\", issue = \"79024\")]\n pub use core::stream;\n #[stable(feature = \"i128\", since = \"1.26.0\")]"}, {"sha": "265f2194fef8d0ce03c61d1c2222828a7c823dde", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -17,6 +17,7 @@ ignore = [\n \n     # do not format submodules\n     \"library/backtrace\",\n+    \"library/portable-simd\",\n     \"library/stdarch\",\n     \"compiler/rustc_codegen_cranelift\",\n     \"compiler/rustc_codegen_gcc\","}, {"sha": "abe460a326bb36c08f5be5c4c6b1805f063a7455", "filename": "src/test/ui/simd/libm_no_std_cant_float.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,21 @@\n+#![crate_type = \"rlib\"]\n+#![no_std]\n+#![feature(portable_simd)]\n+use core::simd::f32x4;\n+\n+// For SIMD float ops, the LLIR version which is used to implement the portable\n+// forms of them may become calls to math.h AKA libm. So, we can't guarantee\n+// we can compile them for #![no_std] crates.\n+// Someday we may solve this.\n+// Until then, this test at least guarantees these functions require std.\n+fn guarantee_no_std_nolibm_calls() -> f32x4 {\n+    let x = f32x4::from_array([0.1, 0.5, 0.6, -1.5]);\n+    let x2 = x + x;\n+    let _xc = x.ceil(); //~ ERROR E0599\n+    let _xf = x.floor(); //~ ERROR E0599\n+    let _xr = x.round(); //~ ERROR E0599\n+    let _xt = x.trunc(); //~ ERROR E0599\n+    let _xfma = x.mul_add(x, x); //~ ERROR E0599\n+    let _xsqrt = x.sqrt(); //~ ERROR E0599\n+    x2.abs() * x2\n+}"}, {"sha": "dc8638f6ab72d2d4831d10b6614d259bf2d4dfef", "filename": "src/test/ui/simd/libm_no_std_cant_float.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.stderr?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,39 @@\n+error[E0599]: no method named `ceil` found for struct `Simd` in the current scope\n+  --> $DIR/libm_no_std_cant_float.rs:14:17\n+   |\n+LL |     let _xc = x.ceil();\n+   |                 ^^^^ method not found in `Simd<f32, 4_usize>`\n+\n+error[E0599]: no method named `floor` found for struct `Simd` in the current scope\n+  --> $DIR/libm_no_std_cant_float.rs:15:17\n+   |\n+LL |     let _xf = x.floor();\n+   |                 ^^^^^ method not found in `Simd<f32, 4_usize>`\n+\n+error[E0599]: no method named `round` found for struct `Simd` in the current scope\n+  --> $DIR/libm_no_std_cant_float.rs:16:17\n+   |\n+LL |     let _xr = x.round();\n+   |                 ^^^^^ method not found in `Simd<f32, 4_usize>`\n+\n+error[E0599]: no method named `trunc` found for struct `Simd` in the current scope\n+  --> $DIR/libm_no_std_cant_float.rs:17:17\n+   |\n+LL |     let _xt = x.trunc();\n+   |                 ^^^^^ method not found in `Simd<f32, 4_usize>`\n+\n+error[E0599]: no method named `mul_add` found for struct `Simd` in the current scope\n+  --> $DIR/libm_no_std_cant_float.rs:18:19\n+   |\n+LL |     let _xfma = x.mul_add(x, x);\n+   |                   ^^^^^^^ method not found in `Simd<f32, 4_usize>`\n+\n+error[E0599]: no method named `sqrt` found for struct `Simd` in the current scope\n+  --> $DIR/libm_no_std_cant_float.rs:19:20\n+   |\n+LL |     let _xsqrt = x.sqrt();\n+   |                    ^^^^ method not found in `Simd<f32, 4_usize>`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "4d7590323550c8599c0a0f94a12d20905e12f699", "filename": "src/test/ui/simd/portable-intrinsics-arent-exposed.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,8 @@\n+// May not matter, since people can use them with a nightly feature.\n+// However this tests to guarantee they don't leak out via portable_simd,\n+// and thus don't accidentally get stabilized.\n+use std::simd::intrinsics; //~ERROR E0603\n+\n+fn main() {\n+    ()\n+}"}, {"sha": "9ac73eca193454791a9d51cb84edb68b2a5c52fd", "filename": "src/test/ui/simd/portable-intrinsics-arent-exposed.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fportable-intrinsics-arent-exposed.stderr?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -0,0 +1,15 @@\n+error[E0603]: module `intrinsics` is private\n+  --> $DIR/portable-intrinsics-arent-exposed.rs:4:16\n+   |\n+LL | use std::simd::intrinsics;\n+   |                ^^^^^^^^^^ private module\n+   |\n+note: the module `intrinsics` is defined here\n+  --> $SRC_DIR/core/src/lib.rs:LL:COL\n+   |\n+LL |     pub use crate::core_simd::simd::*;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "7972437771399f71f356ad3d222c0b7cb0921263", "filename": "src/test/ui/suggestions/issue-71394-no-from-impl.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -4,6 +4,9 @@ error[E0277]: the trait bound `&[i8]: From<&[u8]>` is not satisfied\n LL |     let _: &[i8] = data.into();\n    |                         ^^^^ the trait `From<&[u8]>` is not implemented for `&[i8]`\n    |\n+   = help: the following implementations were found:\n+             <[T; LANES] as From<Simd<T, LANES>>>\n+             <[bool; LANES] as From<Mask<T, LANES>>>\n    = note: required because of the requirements on the impl of `Into<&[i8]>` for `&[u8]`\n \n error: aborting due to previous error"}, {"sha": "09848462ae207f9bbcfd2d2c6c529c1905c492f3", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032dfe43605f4324966933078ffe6f717b77c7c8/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=032dfe43605f4324966933078ffe6f717b77c7c8", "patch": "@@ -60,6 +60,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"compiler/rustc_codegen_gcc\",\n         \"src/llvm-project\",\n         \"library/backtrace\",\n+        \"library/portable-simd\",\n         \"library/stdarch\",\n         \"src/tools/cargo\",\n         \"src/tools/clippy\","}]}