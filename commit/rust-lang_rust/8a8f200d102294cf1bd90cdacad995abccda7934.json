{"sha": "8a8f200d102294cf1bd90cdacad995abccda7934", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhOGYyMDBkMTAyMjk0Y2YxYmQ5MGNkYWNhZDk5NWFiY2NkYTc5MzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-12T04:25:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-12T04:25:01Z"}, "message": "Introduce auto adjustment table to subsume autoderef/autoref/borrowings.\n\nFixes #3261\nFixes #3443", "tree": {"sha": "31e99a460697349c403fc5cf4809427303e14804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31e99a460697349c403fc5cf4809427303e14804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a8f200d102294cf1bd90cdacad995abccda7934", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8f200d102294cf1bd90cdacad995abccda7934", "html_url": "https://github.com/rust-lang/rust/commit/8a8f200d102294cf1bd90cdacad995abccda7934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a8f200d102294cf1bd90cdacad995abccda7934/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02b41097e42082a306ca6dbbd79ee9a1d7d35348", "url": "https://api.github.com/repos/rust-lang/rust/commits/02b41097e42082a306ca6dbbd79ee9a1d7d35348", "html_url": "https://github.com/rust-lang/rust/commit/02b41097e42082a306ca6dbbd79ee9a1d7d35348"}], "stats": {"total": 3526, "additions": 2008, "deletions": 1518}, "files": [{"sha": "570ddfb492a9dfb7d293e246c3848637216342b4", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -1177,7 +1177,7 @@ type SharedChan<T: Send> = unsafe::Exclusive<Chan<T>>;\n impl<T: Send> SharedChan<T>: Channel<T> {\n     fn send(+x: T) {\n         let mut xx = Some(move x);\n-        do self.with |chan| {\n+        do self.with_imm |chan| {\n             let mut x = None;\n             x <-> xx;\n             chan.send(option::unwrap(move x))\n@@ -1186,7 +1186,7 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n \n     fn try_send(+x: T) -> bool {\n         let mut xx = Some(move x);\n-        do self.with |chan| {\n+        do self.with_imm |chan| {\n             let mut x = None;\n             x <-> xx;\n             chan.try_send(option::unwrap(move x))"}, {"sha": "eb3fd3974cdc6832fcc2dd27c88f755f0d0d233f", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -354,6 +354,13 @@ impl<T: Send> Exclusive<T> {\n             move result\n         }\n     }\n+\n+    #[inline(always)]\n+    unsafe fn with_imm<U>(f: fn(x: &T) -> U) -> U {\n+        do self.with |x| {\n+            f(unsafe::transmute_immut(x))\n+        }\n+    }\n }\n \n // FIXME(#2585) make this a by-move method on the exclusive"}, {"sha": "d6b8c2f4908e2c95813c7b3b5cd388d326b7cdd7", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -314,6 +314,8 @@ enum EbmlSerializerTag {\n     EsEnum, EsEnumVid, EsEnumBody,\n     EsVec, EsVecLen, EsVecElt,\n \n+    EsOpaque,\n+\n     EsLabel // Used only when debugging\n }\n \n@@ -340,6 +342,14 @@ impl ebml::Writer: SerializerPriv {\n     }\n }\n \n+impl ebml::Writer {\n+    fn emit_opaque(f: fn()) {\n+        do self.wr_tag(EsOpaque as uint) {\n+            f()\n+        }\n+    }\n+}\n+\n impl ebml::Writer: serialization::Serializer {\n     fn emit_nil() {}\n \n@@ -397,7 +407,7 @@ impl ebml::Writer: serialization::Serializer {\n }\n \n type EbmlDeserializer_ = {mut parent: ebml::Doc,\n-                           mut pos: uint};\n+                          mut pos: uint};\n \n enum EbmlDeserializer {\n     EbmlDeserializer_(EbmlDeserializer_)\n@@ -462,6 +472,14 @@ priv impl EbmlDeserializer {\n     }\n }\n \n+impl EbmlDeserializer {\n+    fn read_opaque<R>(op: fn(ebml::Doc) -> R) -> R {\n+        do self.push_doc(self.next_doc(EsOpaque)) {\n+            op(copy self.parent)\n+        }\n+    }\n+}\n+\n impl EbmlDeserializer: serialization::Deserializer {\n     fn read_nil() -> () { () }\n "}, {"sha": "7622483a64b93c70964f8f8a5837e7833bb473ed", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -794,7 +794,7 @@ impl TcpSocketBuf: io::Reader {\n         count\n     }\n     fn read_byte() -> int {\n-        let bytes = ~[0];\n+        let mut bytes = ~[0];\n         if self.read(bytes, 1u) == 0 { fail } else { bytes[0] as int }\n     }\n     fn unread_byte(amt: int) {"}, {"sha": "25e6d85d1c0c8462611b0a1bf784bf91bceee00a", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -775,7 +775,7 @@ mod tests {\n         let (c,p) = pipes::stream();\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n-        let sharedstate = ~0;\n+        let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(*sharedstate);\n         do task::spawn {\n             let sharedstate: &mut int =\n@@ -1047,7 +1047,7 @@ mod tests {\n         // mutex mutual exclusion test, a ways above.\n         let (c,p) = pipes::stream();\n         let x2 = ~x.clone();\n-        let sharedstate = ~0;\n+        let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(*sharedstate);\n         do task::spawn {\n             let sharedstate: &mut int ="}, {"sha": "af7d8d83b6b8d61b251dd74bffbd7d203dea3352", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -421,6 +421,15 @@ enum vstore {\n     vstore_slice(@region)         // &[1,2,3,4](foo)?\n }\n \n+#[auto_serialize]\n+enum expr_vstore {\n+    // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n+    expr_vstore_fixed(Option<uint>),   // [1,2,3,4]/_ or 4\n+    expr_vstore_uniq,                  // ~[1,2,3,4]\n+    expr_vstore_box,                   // @[1,2,3,4]\n+    expr_vstore_slice                  // &[1,2,3,4]\n+}\n+\n pure fn is_blockish(p: ast::proto) -> bool {\n     match p {\n       proto_block => true,\n@@ -662,7 +671,7 @@ enum alt_mode { alt_check, alt_exhaustive, }\n \n #[auto_serialize]\n enum expr_ {\n-    expr_vstore(@expr, vstore),\n+    expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_rec(~[field], Option<@expr>),\n     expr_call(@expr, ~[@expr], bool), // True iff last argument is a block"}, {"sha": "52357ca4752e89fac969c52aed21200d294519a2", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -260,7 +260,7 @@ impl ext_ctxt: ext_ctxt_helpers {\n                     ast::expr_lit(\n                         @{node: ast::lit_str(s),\n                           span: span})),\n-                ast::vstore_uniq))\n+                ast::expr_vstore_uniq))\n     }\n \n     fn lit_uint(span: span, i: uint) -> @ast::expr {"}, {"sha": "8574c0c90820892a002250826ef8036cdac04478", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -65,24 +65,26 @@ fn mk_base_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     mk_expr(cx, sp, vecexpr)\n }\n-fn mk_vstore_e(cx: ext_ctxt, sp: span, expr: @ast::expr, vst: ast::vstore) ->\n+fn mk_vstore_e(cx: ext_ctxt, sp: span, expr: @ast::expr,\n+               vst: ast::expr_vstore) ->\n    @ast::expr {\n     mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n }\n fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n    @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::vstore_uniq)\n+    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n }\n fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n    @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::vstore_fixed(None))\n+    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n+                ast::expr_vstore_fixed(None))\n }\n fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);\n }\n fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::vstore_uniq)\n+    mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n \n fn mk_rec_e(cx: ext_ctxt, sp: span,"}, {"sha": "b8d55fb105520a977c34de3ea072920bc64665c2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -64,7 +64,9 @@ use ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              variant, view_item, view_item_, view_item_export,\n              view_item_import, view_item_use, view_path, view_path_glob,\n              view_path_list, view_path_simple, visibility, vstore, vstore_box,\n-             vstore_fixed, vstore_slice, vstore_uniq};\n+             vstore_fixed, vstore_slice, vstore_uniq,\n+             expr_vstore_fixed, expr_vstore_slice, expr_vstore_box,\n+             expr_vstore_uniq};\n \n export file_type;\n export parser;\n@@ -1071,7 +1073,8 @@ impl parser {\n             None => (),\n             Some(v) => {\n                 hi = self.span.hi;\n-                ex = expr_vstore(self.mk_expr(lo, hi, ex), vstore_fixed(v));\n+                ex = expr_vstore(self.mk_expr(lo, hi, ex),\n+                                 expr_vstore_fixed(v));\n             }\n           },\n           _ => ()\n@@ -1370,7 +1373,7 @@ impl parser {\n                 ex = match e.node {\n                   expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n                   if m == m_imm => {\n-                    expr_vstore(e, vstore_slice(self.region_from_name(None)))\n+                    expr_vstore(e, expr_vstore_slice)\n                   }\n                   _ => expr_addr_of(m, e)\n                 };\n@@ -1386,7 +1389,7 @@ impl parser {\n             // HACK: turn @[...] into a @-evec\n             ex = match e.node {\n               expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n-              if m == m_imm => expr_vstore(e, vstore_box),\n+              if m == m_imm => expr_vstore(e, expr_vstore_box),\n               _ => expr_unary(box(m), e)\n             };\n           }\n@@ -1398,7 +1401,7 @@ impl parser {\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n               expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n-              if m == m_imm => expr_vstore(e, vstore_uniq),\n+              if m == m_imm => expr_vstore(e, expr_vstore_uniq),\n               _ => expr_unary(uniq(m), e)\n             };\n           }\n@@ -1849,7 +1852,7 @@ impl parser {\n                 node: expr_lit(@{node: lit_str(_), span: _}), _\n               }) => {\n                 let vst = @{id: self.get_id(), callee_id: self.get_id(),\n-                            node: expr_vstore(e, vstore_box),\n+                            node: expr_vstore(e, expr_vstore_box),\n                             span: mk_sp(lo, hi)};\n                 pat_lit(vst)\n               }\n@@ -1866,7 +1869,7 @@ impl parser {\n                 node: expr_lit(@{node: lit_str(_), span: _}), _\n               }) => {\n                 let vst = @{id: self.get_id(), callee_id: self.get_id(),\n-                            node: expr_vstore(e, vstore_uniq),\n+                            node: expr_vstore(e, expr_vstore_uniq),\n                             span: mk_sp(lo, hi)};\n                 pat_lit(vst)\n               }\n@@ -1884,10 +1887,12 @@ impl parser {\n                   pat_lit(e@@{\n                       node: expr_lit(@{node: lit_str(_), span: _}), _\n                   }) => {\n-                      let vst = @{id: self.get_id(), callee_id: self.get_id(),\n-                                  node: expr_vstore(e,\n-                                  vstore_slice(self.region_from_name(None))),\n-                                  span: mk_sp(lo, hi)};\n+                      let vst = @{\n+                          id: self.get_id(),\n+                          callee_id: self.get_id(),\n+                          node: expr_vstore(e, expr_vstore_slice),\n+                          span: mk_sp(lo, hi)\n+                      };\n                       pat_lit(vst)\n                   }\n               _ => pat_region(sub)"}, {"sha": "49133242d5423c69f82aaf0f8b1f3a818e0fe56b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -976,6 +976,16 @@ fn print_vstore(s: ps, t: ast::vstore) {\n     }\n }\n \n+fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n+    match t {\n+      ast::expr_vstore_fixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n+      ast::expr_vstore_fixed(None) => word(s.s, ~\"_\"),\n+      ast::expr_vstore_uniq => word(s.s, ~\"~\"),\n+      ast::expr_vstore_box => word(s.s, ~\"@\"),\n+      ast::expr_vstore_slice => word(s.s, ~\"&\"),\n+    }\n+}\n+\n fn print_expr(s: ps, &&expr: @ast::expr) {\n     fn print_field(s: ps, field: ast::field) {\n         ibox(s, indent_unit);\n@@ -992,17 +1002,17 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n     let ann_node = node_expr(s, expr);\n     s.ann.pre(ann_node);\n     match expr.node {\n-      ast::expr_vstore(e, v) => match v {\n-        ast::vstore_fixed(_) => {\n-            print_expr(s, e);\n-              word(s.s, ~\"/\");\n-              print_vstore(s, v);\n-          }\n-        _ => {\n-            print_vstore(s, v);\n-              print_expr(s, e);\n-          }\n-      },\n+        ast::expr_vstore(e, v) => match v {\n+            ast::expr_vstore_fixed(_) => {\n+                print_expr(s, e);\n+                word(s.s, ~\"/\");\n+                print_expr_vstore(s, v);\n+            }\n+            _ => {\n+                print_expr_vstore(s, v);\n+                print_expr(s, e);\n+            }\n+        },\n       ast::expr_vec(exprs, mutbl) => {\n         ibox(s, indent_unit);\n         word(s.s, ~\"[\");"}, {"sha": "60f14f4ca6318e05c85a33fcd8383a6c400336ff", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -294,7 +294,7 @@ fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n                        span: dummy_sp()};\n     return @{id: cx.sess.next_node_id(),\n           callee_id: cx.sess.next_node_id(),\n-          node: ast::expr_vstore(inner_expr, ast::vstore_uniq),\n+          node: ast::expr_vstore(inner_expr, ast::expr_vstore_uniq),\n           span: dummy_sp()};\n }\n \n@@ -316,7 +316,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let name_expr = {id: cx.sess.next_node_id(),\n                      callee_id: cx.sess.next_node_id(),\n                      node: ast::expr_vstore(name_expr_inner,\n-                                            ast::vstore_uniq),\n+                                            ast::expr_vstore_uniq),\n                      span: dummy_sp()};\n \n "}, {"sha": "a95862a978b42225cbc8ce311de4abf6ffdc49e3", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -120,7 +120,7 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_spill = 0x5f,\n     tag_table_method_map = 0x60,\n     tag_table_vtable_map = 0x61,\n-    tag_table_borrowings = 0x62\n+    tag_table_adjustments = 0x62\n }\n \n // djb's cdb hashes."}, {"sha": "9b723c5d9eb8d17cd8192beaeee07764ed820043", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -11,8 +11,10 @@ use middle::ty;\n use std::map::HashMap;\n use ty::{FnTyBase, FnMeta, FnSig};\n \n-export parse_ty_data, parse_def_id, parse_ident;\n+export parse_state_from_data;\n+export parse_arg_data, parse_ty_data, parse_def_id, parse_ident;\n export parse_bounds_data;\n+export pstate;\n \n // Compact string representation for ty::t values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n@@ -53,13 +55,25 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n     return st.tcx.sess.ident_of(rslt);\n }\n \n+fn parse_state_from_data(data: @~[u8], crate_num: int,\n+                         pos: uint, tcx: ty::ctxt)\n+    -> @pstate\n+{\n+    @{data: data, crate: crate_num, mut pos: pos, tcx: tcx}\n+}\n \n fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                  conv: conv_did) -> ty::t {\n-    let st = @{data: data, crate: crate_num, mut pos: pos, tcx: tcx};\n+    let st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(st, conv)\n }\n \n+fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+                  conv: conv_did) -> ty::arg {\n+    let st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_arg(st, conv)\n+}\n+\n fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n     match peek(st) {\n       '!' => { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n@@ -373,23 +387,32 @@ fn parse_purity(c: char) -> purity {\n     }\n }\n \n+fn parse_arg(st: @pstate, conv: conv_did) -> ty::arg {\n+    {mode: parse_mode(st),\n+     ty: parse_ty(st, conv)}\n+}\n+\n+fn parse_mode(st: @pstate) -> ast::mode {\n+    let m = ast::expl(match next(st) {\n+        '&' => ast::by_mutbl_ref,\n+        '-' => ast::by_move,\n+        '+' => ast::by_copy,\n+        '=' => ast::by_ref,\n+        '#' => ast::by_val,\n+        _ => fail ~\"bad mode\"\n+    });\n+    return m;\n+}\n+\n fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n     let proto = parse_proto(st);\n     let purity = parse_purity(next(st));\n     let bounds = parse_bounds(st, conv);\n     assert (next(st) == '[');\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n-        let mode = match peek(st) {\n-          '&' => ast::by_mutbl_ref,\n-          '-' => ast::by_move,\n-          '+' => ast::by_copy,\n-          '=' => ast::by_ref,\n-          '#' => ast::by_val,\n-          _ => fail ~\"bad mode\"\n-        };\n-        st.pos += 1u;\n-        vec::push(inputs, {mode: ast::expl(mode), ty: parse_ty(st, conv)});\n+        let mode = parse_mode(st);\n+        vec::push(inputs, {mode: mode, ty: parse_ty(st, conv)});\n     }\n     st.pos += 1u; // eat the ']'\n     let (ret_style, ret_ty) = parse_ret_ty(st, conv);\n@@ -432,8 +455,9 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n \n fn parse_bounds_data(data: @~[u8], start: uint,\n                      crate_num: int, tcx: ty::ctxt, conv: conv_did)\n-    -> @~[ty::param_bound] {\n-    let st = @{data: data, crate: crate_num, mut pos: start, tcx: tcx};\n+    -> @~[ty::param_bound]\n+{\n+    let st = parse_state_from_data(data, crate_num, start, tcx);\n     parse_bounds(st, conv)\n }\n "}, {"sha": "2c8df582a55a275a28a5c70a1b05eaa16815b645", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -15,6 +15,7 @@ export ac_use_abbrevs;\n export enc_ty;\n export enc_bounds;\n export enc_mode;\n+export enc_arg;\n \n type ctxt = {\n     diag: span_handler,\n@@ -323,6 +324,11 @@ fn enc_proto(w: io::Writer, cx: @ctxt, proto: ty::fn_proto) {\n     }\n }\n \n+fn enc_arg(w: io::Writer, cx: @ctxt, arg: ty::arg) {\n+    enc_mode(w, cx, arg.mode);\n+    enc_ty(w, cx, arg.ty);\n+}\n+\n fn enc_mode(w: io::Writer, cx: @ctxt, m: mode) {\n     match ty::resolved_mode(cx.tcx, m) {\n       by_mutbl_ref => w.write_char('&'),\n@@ -348,8 +354,7 @@ fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n     enc_bounds(w, cx, ft.meta.bounds);\n     w.write_char('[');\n     for ft.sig.inputs.each |arg| {\n-        enc_mode(w, cx, arg.mode);\n-        enc_ty(w, cx, arg.ty);\n+        enc_arg(w, cx, arg);\n     }\n     w.write_char(']');\n     match ft.meta.ret_style {"}, {"sha": "3172704c971bb4ead9dee81d928ca3bc60a8a56d", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 109, "deletions": 33, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -18,10 +18,8 @@ use std::serialization::DeserializerHelpers;\n use std::prettyprint::Serializer;\n use middle::{ty, typeck};\n use middle::typeck::{method_origin, method_map_entry,\n-                        serialize_method_map_entry,\n-                        deserialize_method_map_entry,\n-                        vtable_res,\n-                        vtable_origin};\n+                     vtable_res,\n+                     vtable_origin};\n use driver::session::session;\n use middle::freevars::{freevar_entry,\n                           serialize_freevar_entry,\n@@ -385,6 +383,45 @@ impl ast::def: tr {\n     }\n }\n \n+// ______________________________________________________________________\n+// Encoding and decoding of adjustment information\n+\n+impl ty::AutoAdjustment: tr {\n+    fn tr(xcx: extended_decode_ctxt) -> ty::AutoAdjustment {\n+        {autoderefs: self.autoderefs,\n+         autoref: self.autoref.map(|ar| ar.tr(xcx))}\n+    }\n+}\n+\n+impl ty::AutoRef: tr {\n+    fn tr(xcx: extended_decode_ctxt) -> ty::AutoRef {\n+        {kind: self.kind,\n+         region: self.region.tr(xcx),\n+         mutbl: self.mutbl}\n+    }\n+}\n+\n+impl ty::region: tr {\n+    fn tr(xcx: extended_decode_ctxt) -> ty::region {\n+        match self {\n+            ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n+            ty::re_free(id, br) => ty::re_free(xcx.tr_id(id), br.tr(xcx)),\n+            ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n+            ty::re_static | ty::re_var(*) => self,\n+        }\n+    }\n+}\n+\n+impl ty::bound_region: tr {\n+    fn tr(xcx: extended_decode_ctxt) -> ty::bound_region {\n+        match self {\n+            ty::br_anon(_) | ty::br_named(_) | ty::br_self => self,\n+            ty::br_cap_avoid(id, br) => ty::br_cap_avoid(xcx.tr_id(id),\n+                                                         @br.tr(xcx))\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n@@ -416,12 +453,31 @@ trait read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry;\n }\n \n+fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n+                              ebml_w: ebml::Writer,\n+                              mme: method_map_entry) {\n+    do ebml_w.emit_rec {\n+        do ebml_w.emit_rec_field(~\"self_arg\", 0u) {\n+            ebml_w.emit_arg(ecx, mme.self_arg);\n+        }\n+        do ebml_w.emit_rec_field(~\"origin\", 1u) {\n+            typeck::serialize_method_origin(ebml_w, mme.origin);\n+        }\n+    }\n+}\n+\n impl ebml::EbmlDeserializer: read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n-        let mme = deserialize_method_map_entry(self);\n-        {derefs: mme.derefs,\n-         self_mode: mme.self_mode,\n-         origin: mme.origin.tr(xcx)}\n+        do self.read_rec {\n+            {self_arg:\n+                 self.read_rec_field(~\"self_arg\", 0u, || {\n+                     self.read_arg(xcx)\n+                 }),\n+             origin:\n+                 self.read_rec_field(~\"origin\", 1u, || {\n+                     typeck::deserialize_method_origin(self).tr(xcx)\n+                 })}\n+        }\n     }\n }\n \n@@ -445,8 +501,8 @@ impl method_origin: tr {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::encode_ctxt,\n-                   ebml_w: ebml::Writer,\n-                   dr: typeck::vtable_res) {\n+                     ebml_w: ebml::Writer,\n+                     dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic serialization of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written serialization routines combine with auto-generated\n@@ -573,6 +629,7 @@ impl @e::encode_ctxt: get_ty_str_ctxt {\n }\n \n trait ebml_writer_helpers {\n+    fn emit_arg(ecx: @e::encode_ctxt, arg: ty::arg);\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t);\n     fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]);\n     fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds);\n@@ -581,17 +638,27 @@ trait ebml_writer_helpers {\n \n impl ebml::Writer: ebml_writer_helpers {\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n-        e::write_type(ecx, self, ty)\n+        do self.emit_opaque {\n+            e::write_type(ecx, self, ty)\n+        }\n+    }\n+\n+    fn emit_arg(ecx: @e::encode_ctxt, arg: ty::arg) {\n+        do self.emit_opaque {\n+            tyencode::enc_arg(self.writer, ecx.ty_str_ctxt(), arg);\n+        }\n     }\n \n     fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]) {\n         do self.emit_from_vec(tys) |ty| {\n-            e::write_type(ecx, self, ty)\n+            self.emit_ty(ecx, ty)\n         }\n     }\n \n     fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds) {\n-        tyencode::enc_bounds(self.writer, ecx.ty_str_ctxt(), bs)\n+        do self.emit_opaque {\n+            tyencode::enc_bounds(self.writer, ecx.ty_str_ctxt(), bs)\n+        }\n     }\n \n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty) {\n@@ -664,7 +731,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_node_type) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                e::write_type(ecx, ebml_w, ty)\n+                ebml_w.emit_ty(ecx, ty);\n             }\n         }\n     }\n@@ -743,7 +810,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_method_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                serialize_method_map_entry(ebml_w, mme)\n+                serialize_method_map_entry(ecx, ebml_w, mme)\n             }\n         }\n     }\n@@ -757,13 +824,11 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(tcx.borrowings.find(id)) |_borrow| {\n-        do ebml_w.tag(c::tag_table_borrowings) {\n+    do option::iter(tcx.adjustments.find(id)) |adj| {\n+        do ebml_w.tag(c::tag_table_adjustments) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                // N.B. We don't actually serialize borrows as, in\n-                // trans, we only care whether a value is borrowed or\n-                // not.\n+                ty::serialize_AutoAdjustment(ebml_w, *adj)\n             }\n         }\n     }\n@@ -782,6 +847,7 @@ impl ebml::Doc: doc_decoder_helpers {\n }\n \n trait ebml_deserializer_decoder_helpers {\n+    fn read_arg(xcx: extended_decode_ctxt) -> ty::arg;\n     fn read_ty(xcx: extended_decode_ctxt) -> ty::t;\n     fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t];\n     fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound];\n@@ -791,29 +857,42 @@ trait ebml_deserializer_decoder_helpers {\n \n impl ebml::EbmlDeserializer: ebml_deserializer_decoder_helpers {\n \n+    fn read_arg(xcx: extended_decode_ctxt) -> ty::arg {\n+        do self.read_opaque |doc| {\n+            tydecode::parse_arg_data(\n+                doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n+                |a| xcx.tr_def_id(a))\n+        }\n+    }\n+\n     fn read_ty(xcx: extended_decode_ctxt) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n         // are not used during trans.\n \n-        tydecode::parse_ty_data(\n-            self.parent.data, xcx.dcx.cdata.cnum, self.pos, xcx.dcx.tcx,\n-            |a| xcx.tr_def_id(a) )\n+        do self.read_opaque |doc| {\n+            tydecode::parse_ty_data(\n+                doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n+                |a| xcx.tr_def_id(a))\n+        }\n     }\n \n     fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t] {\n         self.read_to_vec(|| self.read_ty(xcx) )\n     }\n \n     fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound] {\n-        tydecode::parse_bounds_data(\n-            self.parent.data, self.pos, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n-            |a| xcx.tr_def_id(a) )\n+        do self.read_opaque |doc| {\n+            tydecode::parse_bounds_data(\n+                doc.data, doc.start, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n+                |a| xcx.tr_def_id(a))\n+        }\n     }\n \n     fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n-        -> ty::ty_param_bounds_and_ty {\n+        -> ty::ty_param_bounds_and_ty\n+    {\n         do self.read_rec {\n             {\n                 bounds: self.read_rec_field(~\"bounds\", 0u, || {\n@@ -881,12 +960,9 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             } else if tag == (c::tag_table_vtable_map as uint) {\n                 dcx.maps.vtable_map.insert(id,\n                                            val_dsr.read_vtable_res(xcx));\n-            } else if tag == (c::tag_table_borrowings as uint) {\n-                // N.B.: we don't actually *serialize* borrows because, in\n-                // trans, the only thing we care about is whether a value was\n-                // borrowed or not.\n-                let borrow = {region: ty::re_static, mutbl: ast::m_imm};\n-                dcx.tcx.borrowings.insert(id, borrow);\n+            } else if tag == (c::tag_table_adjustments as uint) {\n+                let adj = @ty::deserialize_AutoAdjustment(val_dsr).tr(xcx);\n+                dcx.tcx.adjustments.insert(id, adj);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n                     fmt!(\"unknown tag found in side tables: %x\", tag));"}, {"sha": "ea5bc48445ef633a1293af6dbf2d8e7a5cb3421a", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -221,7 +221,7 @@ use syntax::ast_util;\n use syntax::ast_map;\n use syntax::codemap::span;\n use util::ppaux::{ty_to_str, region_to_str, explain_region,\n-                  note_and_explain_region};\n+                  expr_repr, note_and_explain_region};\n use std::map::{int_hash, HashMap, Set};\n use std::list;\n use std::list::{List, Cons, Nil};\n@@ -318,7 +318,7 @@ enum bckerr_code {\n     err_mut_uniq,\n     err_mut_variant,\n     err_root_not_permitted,\n-    err_mutbl(ast::mutability, ast::mutability),\n+    err_mutbl(ast::mutability),\n     err_out_of_root_scope(ty::region, ty::region), // superscope, subscope\n     err_out_of_scope(ty::region, ty::region) // superscope, subscope\n }\n@@ -344,9 +344,9 @@ impl bckerr_code : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            err_mutbl(e0a, e1a) => {\n+            err_mutbl(e0a) => {\n                 match other {\n-                    err_mutbl(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    err_mutbl(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n@@ -444,10 +444,6 @@ impl borrowck_ctxt {\n         cat_expr(self.tcx, self.method_map, expr)\n     }\n \n-    fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n-        cat_borrow_of_expr(self.tcx, self.method_map, expr)\n-    }\n-\n     fn cat_def(id: ast::node_id,\n                span: span,\n                ty: ty::t,\n@@ -482,8 +478,8 @@ impl borrowck_ctxt {\n         self.span_err(\n             err.cmt.span,\n             fmt!(\"illegal borrow: %s\",\n-                 self.bckerr_code_to_str(err.code)));\n-        self.note_and_explain_bckerr(err.code);\n+                 self.bckerr_to_str(err)));\n+        self.note_and_explain_bckerr(err);\n     }\n \n     fn span_err(s: span, m: ~str) {\n@@ -506,11 +502,12 @@ impl borrowck_ctxt {\n         }\n     }\n \n-    fn bckerr_code_to_str(code: bckerr_code) -> ~str {\n-        match code {\n-            err_mutbl(req, act) => {\n-                fmt!(\"creating %s alias to aliasable, %s memory\",\n-                     self.mut_to_str(req), self.mut_to_str(act))\n+    fn bckerr_to_str(err: bckerr) -> ~str {\n+        match err.code {\n+            err_mutbl(req) => {\n+                fmt!(\"creating %s alias to %s\",\n+                     self.mut_to_str(req),\n+                     self.cmt_to_str(err.cmt))\n             }\n             err_mut_uniq => {\n                 ~\"unique value in aliasable, mutable location\"\n@@ -533,7 +530,8 @@ impl borrowck_ctxt {\n         }\n     }\n \n-    fn note_and_explain_bckerr(code: bckerr_code) {\n+    fn note_and_explain_bckerr(err: bckerr) {\n+        let code = err.code;\n         match code {\n             err_mutbl(*) | err_mut_uniq | err_mut_variant |\n             err_root_not_permitted => {}"}, {"sha": "ff7a52100071c6f806f4bbb80be56861637b7e7b", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -75,8 +75,7 @@ fn check_loans(bccx: borrowck_ctxt,\n \n enum assignment_type {\n     at_straight_up,\n-    at_swap,\n-    at_mutbl_ref,\n+    at_swap\n }\n \n impl assignment_type : cmp::Eq {\n@@ -92,15 +91,13 @@ impl assignment_type {\n         // are only assigned once; but it doesn't consider &mut\n         match self {\n           at_straight_up => true,\n-          at_swap => true,\n-          at_mutbl_ref => false\n+          at_swap => true\n         }\n     }\n     fn ing_form(desc: ~str) -> ~str {\n         match self {\n           at_straight_up => ~\"assigning to \" + desc,\n-          at_swap => ~\"swapping to and from \" + desc,\n-          at_mutbl_ref => ~\"taking mut reference to \" + desc\n+          at_swap => ~\"swapping to and from \" + desc\n         }\n     }\n }\n@@ -369,11 +366,9 @@ impl check_loan_ctxt {\n         // taking a mutable ref.  that will create a loan of its own\n         // which will be checked for compat separately in\n         // check_for_conflicting_loans()\n-        if at != at_mutbl_ref {\n-            for cmt.lp.each |lp| {\n-                self.check_for_loan_conflicting_with_assignment(\n-                    at, ex, cmt, lp);\n-            }\n+        for cmt.lp.each |lp| {\n+            self.check_for_loan_conflicting_with_assignment(\n+                at, ex, cmt, lp);\n         }\n \n         self.bccx.add_to_mutbl_map(cmt);\n@@ -430,8 +425,8 @@ impl check_loan_ctxt {\n                 self.tcx().sess.span_err(\n                     e.cmt.span,\n                     fmt!(\"illegal borrow unless pure: %s\",\n-                         self.bccx.bckerr_code_to_str(e.code)));\n-                self.bccx.note_and_explain_bckerr(e.code);\n+                         self.bccx.bckerr_to_str(e)));\n+                self.bccx.note_and_explain_bckerr(e);\n                 self.tcx().sess.span_note(\n                     sp,\n                     fmt!(\"impure due to %s\", msg));\n@@ -531,14 +526,12 @@ impl check_loan_ctxt {\n                 ty::node_id_to_type(self.tcx(), callee_id));\n         do vec::iter2(args, arg_tys) |arg, arg_ty| {\n             match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_move => {\n-                self.check_move_out(arg);\n-              }\n-              ast::by_mutbl_ref => {\n-                self.check_assignment(at_mutbl_ref, arg);\n-              }\n-              ast::by_ref | ast::by_copy | ast::by_val => {\n-              }\n+                ast::by_move => {\n+                    self.check_move_out(arg);\n+                }\n+                ast::by_mutbl_ref | ast::by_ref |\n+                ast::by_copy | ast::by_val => {\n+                }\n             }\n         }\n     }\n@@ -645,19 +638,6 @@ fn check_loans_in_expr(expr: @ast::expr,\n             }\n         }\n       }\n-      ast::expr_addr_of(mutbl, base) => {\n-        match mutbl {\n-          m_const => { /*all memory is const*/ }\n-          m_mutbl => {\n-            // If we are taking an &mut ptr, make sure the memory\n-            // being pointed at is assignable in the first place:\n-            self.check_assignment(at_mutbl_ref, base);\n-          }\n-          m_imm => {\n-            // XXX explain why no check is req'd here\n-          }\n-        }\n-      }\n       ast::expr_call(f, args, _) => {\n         self.check_call(expr, Some(f), f.id, f.span, args);\n       }"}, {"sha": "449913e92b7744fe2ee9a28f980a93e68708ea63", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 46, "deletions": 55, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -6,9 +6,9 @@\n // their associated scopes.  In phase two, checking loans, we will then make\n // sure that all of these loans are honored.\n \n-use mem_categorization::{opt_deref_kind};\n+use mem_categorization::{mem_categorization_ctxt, opt_deref_kind};\n use preserve::{preserve_condition, pc_ok, pc_if_pure};\n-use ty::ty_region;\n+use ty::{ty_region};\n \n export gather_loans;\n \n@@ -94,9 +94,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n            ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     // If this expression is borrowed, have to ensure it remains valid:\n-    for tcx.borrowings.find(ex.id).each |borrow| {\n-        let cmt = self.bccx.cat_borrow_of_expr(ex);\n-        self.guarantee_valid(cmt, borrow.mutbl, borrow.region);\n+    for tcx.adjustments.find(ex.id).each |adjustments| {\n+        self.guarantee_adjustments(ex, adjustments);\n     }\n \n     // Special checks for various kinds of expressions:\n@@ -125,45 +124,9 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n               }\n               ast::by_val => {\n-                // Rust's by-val does not actually give ownership to\n-                // the callee.  This means that if a pointer type is\n-                // passed, it is effectively a borrow, and so the\n-                // caller must guarantee that the data remains valid.\n-                //\n-                // Subtle: we only guarantee that the pointer is valid\n-                // and const.  Technically, we ought to pass in the\n-                // mutability that the caller expects (e.g., if the\n-                // formal argument has type @mut, we should guarantee\n-                // validity and mutability, not validity and const).\n-                // However, the type system already guarantees that\n-                // the caller's mutability is compatible with the\n-                // callee, so this is not necessary.  (Note that with\n-                // actual borrows, typeck is more liberal and allows\n-                // the pointer to be borrowed as immutable even if it\n-                // is mutable in the caller's frame, thus effectively\n-                // passing the buck onto us to enforce this)\n-                //\n-                // FIXME (#2493): this handling is not really adequate.\n-                // For example, if there is a type like, {f: ~[int]}, we\n-                // will ignore it, but we ought to be requiring it to be\n-                // immutable (whereas something like {f:int} would be\n-                // fine).\n-                //\n-                match opt_deref_kind(arg_ty.ty) {\n-                  Some(deref_ptr(region_ptr(_))) |\n-                  Some(deref_ptr(unsafe_ptr)) => {\n-                    /* region pointers are (by induction) guaranteed */\n-                    /* unsafe pointers are the user's problem */\n-                  }\n-                  Some(deref_comp(_)) |\n-                  None => {\n-                    /* not a pointer, no worries */\n-                  }\n-                  Some(deref_ptr(_)) => {\n-                    let arg_cmt = self.bccx.cat_borrow_of_expr(arg);\n-                    self.guarantee_valid(arg_cmt, m_const, scope_r);\n-                  }\n-                }\n+                // FIXME (#2493): safety checks would be required here,\n+                // but the correct set is really hard to get right,\n+                // and modes are going away anyhow.\n               }\n               ast::by_move | ast::by_copy => {}\n             }\n@@ -261,6 +224,42 @@ fn req_loans_in_expr(ex: @ast::expr,\n impl gather_loan_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n+    fn guarantee_adjustments(expr: @ast::expr,\n+                             adjustment: &ty::AutoAdjustment) {\n+        debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n+               expr_repr(self.tcx(), expr), adjustment);\n+        let _i = indenter();\n+\n+        match adjustment.autoref {\n+            None => {\n+                debug!(\"no autoref\");\n+                return;\n+            }\n+\n+            Some(ref autoref) => {\n+                let mcx = &mem_categorization_ctxt {\n+                    tcx: self.tcx(),\n+                    method_map: self.bccx.method_map};\n+                let mut cmt = mcx.cat_expr_autoderefd(expr, adjustment);\n+                debug!(\"after autoderef, cmt=%s\", self.bccx.cmt_to_repr(cmt));\n+\n+                match autoref.kind {\n+                    ty::AutoPtr => {\n+                        self.guarantee_valid(cmt,\n+                                             autoref.mutbl,\n+                                             autoref.region)\n+                    }\n+                    ty::AutoSlice => {\n+                        let cmt_index = mcx.cat_index(expr, cmt);\n+                        self.guarantee_valid(cmt_index,\n+                                             autoref.mutbl,\n+                                             autoref.region)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     // guarantees that addr_of(cmt) will be valid for the duration of\n     // `static_scope_r`, or reports an error.  This may entail taking\n     // out loans, which will be added to the `req_loan_map`.  This can\n@@ -387,25 +386,17 @@ impl gather_loan_ctxt {\n     // mutable memory.\n     fn check_mutbl(req_mutbl: ast::mutability,\n                    cmt: cmt) -> bckres<preserve_condition> {\n-        match (req_mutbl, cmt.mutbl) {\n-          (m_const, _) |\n-          (m_imm, m_imm) |\n-          (m_mutbl, m_mutbl) => {\n+        if req_mutbl == m_const || req_mutbl == cmt.mutbl {\n             Ok(pc_ok)\n-          }\n-\n-          (_, m_const) |\n-          (m_imm, m_mutbl) |\n-          (m_mutbl, m_imm) => {\n+        } else {\n             let e = {cmt: cmt,\n-                     code: err_mutbl(req_mutbl, cmt.mutbl)};\n+                     code: err_mutbl(req_mutbl)};\n             if req_mutbl == m_imm {\n                 // you can treat mutable things as imm if you are pure\n                 Ok(pc_if_pure(e))\n             } else {\n                 Err(e)\n             }\n-          }\n         }\n     }\n "}, {"sha": "8d9d7a5796a9a7860af6e6ca01977c420089d855", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -36,23 +36,40 @@ enum loan_ctxt {\n impl loan_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n-    fn ok_with_loan_of(cmt: cmt,\n-                       scope_ub: ty::region,\n-                       mutbl: ast::mutability) -> bckres<()> {\n+    fn issue_loan(cmt: cmt,\n+                  scope_ub: ty::region,\n+                  req_mutbl: ast::mutability) -> bckres<()> {\n         if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n-            // Note: all cmt's that we deal with will have a non-none\n-            // lp, because the entry point into this routine,\n-            // `borrowck_ctxt::loan()`, rejects any cmt with a\n-            // none-lp.\n-            (*self.loans).push({lp: option::get(cmt.lp),\n-                                cmt: cmt,\n-                                mutbl: mutbl});\n-            Ok(())\n+            match req_mutbl {\n+                m_mutbl => {\n+                    // We do not allow non-mutable data to be loaned\n+                    // out as mutable under any circumstances.\n+                    if cmt.mutbl != m_mutbl {\n+                        return Err({cmt:cmt,\n+                                    code:err_mutbl(req_mutbl)});\n+                    }\n+                }\n+                m_const | m_imm => {\n+                    // However, mutable data can be loaned out as\n+                    // immutable (and any data as const).  The\n+                    // `check_loans` pass will then guarantee that no\n+                    // writes occur for the duration of the loan.\n+                }\n+            }\n+\n+            (*self.loans).push({\n+                // Note: cmt.lp must be Some(_) because otherwise this\n+                // loan process does not apply at all.\n+                lp: cmt.lp.get(),\n+                cmt: cmt,\n+                mutbl: req_mutbl});\n+            return Ok(());\n         } else {\n             // The loan being requested lives longer than the data\n             // being loaned out!\n-            Err({cmt:cmt, code:err_out_of_scope(scope_ub,\n-                                                self.scope_region)})\n+            return Err({cmt:cmt,\n+                        code:err_out_of_scope(scope_ub,\n+                                              self.scope_region)});\n         }\n     }\n \n@@ -78,7 +95,7 @@ impl loan_ctxt {\n           }\n           cat_local(local_id) | cat_arg(local_id) => {\n             let local_scope_id = self.tcx().region_map.get(local_id);\n-            self.ok_with_loan_of(cmt, ty::re_scope(local_scope_id), req_mutbl)\n+            self.issue_loan(cmt, ty::re_scope(local_scope_id), req_mutbl)\n           }\n           cat_stack_upvar(cmt) => {\n             self.loan(cmt, req_mutbl) // NDM correct?\n@@ -138,7 +155,7 @@ impl loan_ctxt {\n         do self.loan(cmt_base, base_mutbl).chain |_ok| {\n             // can use static for the scope because the base\n             // determines the lifetime, ultimately\n-            self.ok_with_loan_of(cmt, ty::re_static, req_mutbl)\n+            self.issue_loan(cmt, ty::re_static, req_mutbl)\n         }\n     }\n \n@@ -153,7 +170,7 @@ impl loan_ctxt {\n         // could change.\n         do self.loan(cmt_base, m_imm).chain |_ok| {\n             // can use static, as in loan_stable_comp()\n-            self.ok_with_loan_of(cmt, ty::re_static, req_mutbl)\n+            self.issue_loan(cmt, ty::re_static, req_mutbl)\n         }\n     }\n }"}, {"sha": "6bfb0d091a4ccb30f9f7a20ca3d9a739689934c0", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -169,7 +169,7 @@ priv impl &preserve_ctxt {\n                   }\n                   Err(e) => {\n                     debug!(\"must root @T, err: %s\",\n-                           self.bccx.bckerr_code_to_str(e.code));\n+                           self.bccx.bckerr_to_str(e));\n                     self.attempt_root(cmt, base, derefs)\n                   }\n                 }"}, {"sha": "0a1de0d11a44c0e27b71d2569a1bee505155655a", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -40,7 +40,7 @@ fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n           expr_vstore(@{node: expr_lit(@{node: lit_str(_), _}), _},\n-                      vstore_uniq) => true,\n+                      expr_vstore_uniq) => true,\n           _ => false\n         }\n     }\n@@ -98,8 +98,8 @@ fn check_expr(sess: session, def_map: resolve::DefMap,\n               }\n             }\n           }\n-          expr_vstore(_, vstore_slice(_)) |\n-          expr_vstore(_, vstore_fixed(_)) |\n+          expr_vstore(_, expr_vstore_slice) |\n+          expr_vstore(_, expr_vstore_fixed(_)) |\n           expr_vec(_, m_imm) |\n           expr_addr_of(m_imm, _) |\n           expr_field(*) |"}, {"sha": "6c9617d33109cd2517faf92f55a104498fa91056", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -87,12 +87,12 @@ fn classify(e: @expr,\n               }\n \n               ast::expr_vstore(e, vstore) => {\n-                match vstore {\n-                  ast::vstore_fixed(_) |\n-                  ast::vstore_slice(_) => classify(e, def_map, tcx),\n-                  ast::vstore_uniq |\n-                  ast::vstore_box => non_const\n-                }\n+                  match vstore {\n+                      ast::expr_vstore_fixed(_) |\n+                      ast::expr_vstore_slice => classify(e, def_map, tcx),\n+                      ast::expr_vstore_uniq |\n+                      ast::expr_vstore_box => non_const\n+                  }\n               }\n \n               ast::expr_struct(_, fs, None) |"}, {"sha": "e81c8f967e0c9cb7ac5c5a475744983c3924dc3f", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -332,8 +332,13 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         // If this is a method call with a by-val argument, we need\n         // to check the copy\n         match cx.method_map.find(e.id) {\n-          Some({self_mode: by_copy, _}) => maybe_copy(cx, lhs, None),\n-          _ => ()\n+            Some(ref mme) => {\n+                match ty::arg_mode(cx.tcx, mme.self_arg) {\n+                    by_copy => maybe_copy(cx, lhs, None),\n+                    by_ref | by_val | by_mutbl_ref | by_move => ()\n+                }\n+            }\n+            _ => ()\n         }\n       }\n       expr_repeat(element, count_expr, _) => {\n@@ -437,11 +442,18 @@ fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n         !is_nullary_variant(cx, ex) &&\n \n         // borrowed unique value isn't really a copy\n-        !cx.tcx.borrowings.contains_key(ex.id)\n+        !is_autorefd(cx, ex)\n     {\n         let ty = ty::expr_ty(cx.tcx, ex);\n         check_copy(cx, ex.id, ty, ex.span, implicit_copy, why);\n     }\n+\n+    fn is_autorefd(cx: ctx, ex: @expr) -> bool {\n+        match cx.tcx.adjustments.find(ex.id) {\n+            None => false,\n+            Some(ref adj) => adj.autoref.is_some()\n+        }\n+    }\n }\n \n fn check_imm_free_var(cx: ctx, def: def, sp: span) {"}, {"sha": "e6d27a7d09e09e460cf16aae95995efc4a68b751", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 63, "deletions": 92, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -340,17 +340,6 @@ fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n     }\n }\n \n-fn cat_borrow_of_expr(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    expr: @ast::expr) -> cmt {\n-\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_borrow_of_expr(expr);\n-}\n-\n fn cat_expr(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n@@ -420,33 +409,40 @@ struct mem_categorization_ctxt {\n }\n \n impl &mem_categorization_ctxt {\n-    fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n-        // Any expression can be borrowed (to account for auto-ref on method\n-        // receivers), but @, ~, @vec, and ~vec are handled specially.\n-        let expr_ty = ty::expr_ty(self.tcx, expr);\n-        match ty::get(expr_ty).sty {\n-          ty::ty_evec(*) | ty::ty_estr(*) => {\n-            self.cat_index(expr, expr)\n-          }\n-\n-          ty::ty_uniq(*) | ty::ty_box(*) | ty::ty_rptr(*) => {\n-            let cmt = self.cat_expr(expr);\n-            self.cat_deref(expr, cmt, 0u, true).get()\n-          }\n+    fn cat_expr(expr: @ast::expr) -> cmt {\n+        match self.tcx.adjustments.find(expr.id) {\n+            None => {\n+                // No adjustments.\n+                self.cat_expr_unadjusted(expr)\n+            }\n \n-          /*\n-          ty::ty_fn({proto, _}) {\n-            self.cat_call(expr, expr, proto)\n-          }\n-          */\n+            Some(adjustment) => {\n+                match adjustment.autoref {\n+                    Some(_) => {\n+                        // Equivalent to &*expr or something similar.\n+                        // This is an rvalue, effectively.\n+                        let expr_ty = ty::expr_ty(self.tcx, expr);\n+                        self.cat_rvalue(expr, expr_ty)\n+                    }\n+                    None => {\n+                        // Equivalent to *expr or something similar.\n+                        self.cat_expr_autoderefd(expr, adjustment)\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n-          _ => {\n-            self.cat_rvalue(expr, expr_ty)\n-          }\n+    fn cat_expr_autoderefd(expr: @ast::expr,\n+                           adjustment: &ty::AutoAdjustment) -> cmt {\n+        let mut cmt = self.cat_expr_unadjusted(expr);\n+        for uint::range(1, adjustment.autoderefs+1) |deref| {\n+            cmt = self.cat_deref(expr, cmt, deref);\n         }\n+        return cmt;\n     }\n \n-    fn cat_expr(expr: @ast::expr) -> cmt {\n+    fn cat_expr_unadjusted(expr: @ast::expr) -> cmt {\n         debug!(\"cat_expr: id=%d expr=%s\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -459,23 +455,15 @@ impl &mem_categorization_ctxt {\n             }\n \n             let base_cmt = self.cat_expr(e_base);\n-            match self.cat_deref(expr, base_cmt, 0u, true) {\n-              Some(cmt) => return cmt,\n-              None => {\n-                tcx.sess.span_bug(\n-                    e_base.span,\n-                    fmt!(\"Explicit deref of non-derefable type `%s`\",\n-                         ty_to_str(tcx, tcx.ty(e_base))));\n-              }\n-            }\n+            self.cat_deref(expr, base_cmt, 0)\n           }\n \n           ast::expr_field(base, f_name, _) => {\n             if self.method_map.contains_key(expr.id) {\n                 return self.cat_method_ref(expr, expr_ty);\n             }\n \n-            let base_cmt = self.cat_autoderef(base);\n+            let base_cmt = self.cat_expr(base);\n             self.cat_field(expr, base_cmt, f_name)\n           }\n \n@@ -484,7 +472,8 @@ impl &mem_categorization_ctxt {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n \n-            self.cat_index(expr, base)\n+            let base_cmt = self.cat_expr(base);\n+            self.cat_index(expr, base_cmt)\n           }\n \n           ast::expr_path(_) => {\n@@ -666,53 +655,60 @@ impl &mem_categorization_ctxt {\n           mutbl: m, ty: self.tcx.ty(node)}\n     }\n \n-    fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n-                             expl: bool) -> Option<cmt> {\n-        do ty::deref(self.tcx, base_cmt.ty, expl).map |mt| {\n-            match deref_kind(self.tcx, base_cmt.ty) {\n-              deref_ptr(ptr) => {\n+    fn cat_deref<N:ast_node>(node: N,\n+                             base_cmt: cmt,\n+                             deref_cnt: uint) -> cmt {\n+        let mt = match ty::deref(self.tcx, base_cmt.ty, true) {\n+            Some(mt) => mt,\n+            None => {\n+                self.tcx.sess.span_bug(\n+                    node.span(),\n+                    fmt!(\"Explicit deref of non-derefable type: %s\",\n+                         ty_to_str(self.tcx, base_cmt.ty)));\n+            }\n+        };\n+\n+        match deref_kind(self.tcx, base_cmt.ty) {\n+            deref_ptr(ptr) => {\n                 let lp = do base_cmt.lp.chain |l| {\n                     // Given that the ptr itself is loanable, we can\n                     // loan out deref'd uniq ptrs as the data they are\n                     // the only way to reach the data they point at.\n                     // Other ptr types admit aliases and are therefore\n                     // not loanable.\n                     match ptr {\n-                      uniq_ptr => {Some(@lp_deref(l, ptr))}\n-                      gc_ptr | region_ptr(_) | unsafe_ptr => {None}\n+                        uniq_ptr => {Some(@lp_deref(l, ptr))}\n+                        gc_ptr | region_ptr(_) | unsafe_ptr => {None}\n                     }\n                 };\n \n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = match ptr {\n-                  uniq_ptr => {\n-                    self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n-                  }\n-                  gc_ptr | region_ptr(_) | unsafe_ptr => {\n-                    mt.mutbl\n-                  }\n+                    uniq_ptr => {\n+                        self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n+                    }\n+                    gc_ptr | region_ptr(_) | unsafe_ptr => {\n+                        mt.mutbl\n+                    }\n                 };\n \n                 @{id:node.id(), span:node.span(),\n-                  cat:cat_deref(base_cmt, derefs, ptr), lp:lp,\n+                  cat:cat_deref(base_cmt, deref_cnt, ptr), lp:lp,\n                   mutbl:m, ty:mt.ty}\n-              }\n+            }\n \n-              deref_comp(comp) => {\n+            deref_comp(comp) => {\n                 let lp = base_cmt.lp.map(|l| @lp_comp(l, comp) );\n                 let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n                 @{id:node.id(), span:node.span(),\n                   cat:cat_comp(base_cmt, comp), lp:lp,\n                   mutbl:m, ty:mt.ty}\n-              }\n             }\n         }\n     }\n \n-    fn cat_index(expr: @ast::expr, base: @ast::expr) -> cmt {\n-        let base_cmt = self.cat_autoderef(base);\n-\n+    fn cat_index(expr: @ast::expr, base_cmt: cmt) -> cmt {\n         let mt = match ty::index(self.tcx, base_cmt.ty) {\n           Some(mt) => mt,\n           None => {\n@@ -781,25 +777,6 @@ impl &mem_categorization_ctxt {\n           mutbl:m_imm, ty:expr_ty}\n     }\n \n-    fn cat_autoderef(base: @ast::expr) -> cmt {\n-        // Creates a string of implicit derefences so long as base is\n-        // dereferencable.  n.b., it is important that these dereferences are\n-        // associated with the field/index that caused the autoderef (expr).\n-        // This is used later to adjust ref counts and so forth in trans.\n-\n-        // Given something like base.f where base has type @m1 @m2 T, we want\n-        // to yield the equivalent categories to (**base).f.\n-        let mut cmt = self.cat_expr(base);\n-        let mut ctr = 0u;\n-        loop {\n-            ctr += 1u;\n-            match self.cat_deref(base, cmt, ctr, false) {\n-              None => return cmt,\n-              Some(cmt1) => cmt = cmt1\n-            }\n-        }\n-    }\n-\n     fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n \n         op(cmt, pat);\n@@ -900,15 +877,9 @@ impl &mem_categorization_ctxt {\n \n           ast::pat_box(subpat) | ast::pat_uniq(subpat) |\n           ast::pat_region(subpat) => {\n-            // @p1, ~p1, &p1\n-            match self.cat_deref(subpat, cmt, 0u, true) {\n-              Some(subcmt) => {\n-                self.cat_pattern(subcmt, subpat, op);\n-              }\n-              None => {\n-                tcx.sess.span_bug(pat.span, ~\"Non derefable type\");\n-              }\n-            }\n+            // @p1, ~p1\n+            let subcmt = self.cat_deref(subpat, cmt, 0);\n+            self.cat_pattern(subcmt, subpat, op);\n           }\n \n           ast::pat_lit(_) | ast::pat_range(_, _) => { /*always ok*/ }"}, {"sha": "725848592b1722e14112c4e38b979d4311bf3519", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -500,7 +500,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n \n             let Result {bcx: guard_cx, val} = {\n                 do with_scope_result(bcx, e.info(), ~\"guard\") |bcx| {\n-                    expr::trans_to_appropriate_llval(bcx, e)\n+                    expr::trans_to_datum(bcx, e).to_result()\n                 }\n             };\n "}, {"sha": "4c33bd2b432cccb39b98a80ff312ef961577359c", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 91, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -453,8 +453,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n         do vec::iteri(arg_exprs) |i, arg_expr| {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx, arg_tys[i], arg_expr, &mut temp_cleanups,\n-                               if i == last { ret_flag } else { None },\n-                               0u)\n+                               if i == last { ret_flag } else { None })\n             });\n             vec::push(llargs, arg_val);\n         }\n@@ -480,18 +479,17 @@ fn trans_arg_expr(bcx: block,\n                   formal_ty: ty::arg,\n                   arg_expr: @ast::expr,\n                   temp_cleanups: &mut ~[ValueRef],\n-                  ret_flag: Option<ValueRef>,\n-                  derefs: uint)\n+                  ret_flag: Option<ValueRef>)\n     -> Result\n {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_arg_expr(formal_ty=(%?,%s), arg_expr=%s, \\\n-            ret_flag=%?, derefs=%?)\",\n+            ret_flag=%?)\",\n            formal_ty.mode, bcx.ty_to_str(formal_ty.ty),\n            bcx.expr_to_str(arg_expr),\n-           ret_flag.map(|v| bcx.val_str(v)), derefs);\n+           ret_flag.map(|v| bcx.val_str(v)));\n     let _indenter = indenter();\n \n     // translate the arg expr to a datum\n@@ -528,20 +526,7 @@ fn trans_arg_expr(bcx: block,\n     let mut arg_datum = arg_datumblock.datum;\n     let mut bcx = arg_datumblock.bcx;\n \n-    debug!(\"   initial value: %s\", arg_datum.to_str(bcx.ccx()));\n-\n-    // auto-deref value as required (this only applies to method\n-    // call receivers) of method\n-    if derefs != 0 {\n-        arg_datum = arg_datum.autoderef(bcx, arg_expr.id, derefs);\n-        debug!(\"   deref'd value: %s\", arg_datum.to_str(bcx.ccx()));\n-    };\n-\n-    // borrow value (convert from @T to &T and so forth)\n-    let arg_datum = unpack_datum!(bcx, {\n-        adapt_borrowed_value(bcx, arg_datum, arg_expr)\n-    });\n-    debug!(\"   borrowed value: %s\", arg_datum.to_str(bcx.ccx()));\n+    debug!(\"   arg datum: %s\", arg_datum.to_str(bcx.ccx()));\n \n     // finally, deal with the various modes\n     let arg_mode = ty::resolved_mode(ccx.tcx, formal_ty.mode);\n@@ -601,74 +586,3 @@ fn trans_arg_expr(bcx: block,\n     return rslt(bcx, val);\n }\n \n-// when invoking a method, an argument of type @T or ~T can be implicltly\n-// converted to an argument of type &T. Similarly, ~[T] can be converted to\n-// &[T] and so on.  If such a conversion (called borrowing) is necessary,\n-// then the borrowings table will have an appropriate entry inserted.  This\n-// routine consults this table and performs these adaptations.  It returns a\n-// new location for the borrowed result as well as a new type for the argument\n-// that reflects the borrowed value and not the original.\n-fn adapt_borrowed_value(bcx: block,\n-                        datum: Datum,\n-                        expr: @ast::expr) -> DatumBlock\n-{\n-    if !expr_is_borrowed(bcx, expr) {\n-        return DatumBlock {bcx: bcx, datum: datum};\n-    }\n-\n-    debug!(\"adapt_borrowed_value(datum=%s, expr=%s)\",\n-           datum.to_str(bcx.ccx()),\n-           bcx.expr_to_str(expr));\n-\n-    match ty::get(datum.ty).sty {\n-        ty::ty_uniq(_) | ty::ty_box(_) => {\n-            let body_datum = datum.box_body(bcx);\n-            let rptr_datum = body_datum.to_rptr(bcx);\n-            return DatumBlock {bcx: bcx, datum: rptr_datum};\n-        }\n-\n-        ty::ty_estr(_) | ty::ty_evec(_, _) => {\n-            let ccx = bcx.ccx();\n-            let val = datum.to_appropriate_llval(bcx);\n-\n-            let unit_ty = ty::sequence_element_type(ccx.tcx, datum.ty);\n-            let llunit_ty = type_of::type_of(ccx, unit_ty);\n-            let (base, len) = datum.get_base_and_len(bcx);\n-            let p = alloca(bcx, T_struct(~[T_ptr(llunit_ty), ccx.int_type]));\n-\n-            debug!(\"adapt_borrowed_value: adapting %s to %s\",\n-                   val_str(bcx.ccx().tn, val),\n-                   val_str(bcx.ccx().tn, p));\n-\n-            Store(bcx, base, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n-            Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n-\n-            // this isn't necessarily the type that rust would assign\n-            // but it's close enough for trans purposes, as it will\n-            // have the same runtime representation\n-            let slice_ty = ty::mk_evec(bcx.tcx(),\n-                                       {ty: unit_ty, mutbl: ast::m_imm},\n-                                       ty::vstore_slice(ty::re_static));\n-\n-            return DatumBlock {bcx: bcx,\n-                               datum: Datum {val: p,\n-                                             mode: ByRef,\n-                                             ty: slice_ty,\n-                                             source: FromRvalue}};\n-        }\n-\n-        _ => {\n-            // Just take a reference. This is basically like trans_addr_of.\n-            //\n-            // NDM---this code is almost certainly wrong.  I presume its\n-            // purpose is auto-ref? What if an @T is autoref'd? No good.\n-            let rptr_datum = datum.to_rptr(bcx);\n-            return DatumBlock {bcx: bcx, datum: rptr_datum};\n-        }\n-    }\n-\n-    fn expr_is_borrowed(bcx: block, e: @ast::expr) -> bool {\n-        bcx.tcx().borrowings.contains_key(e.id)\n-    }\n-}\n-"}, {"sha": "87e27bcf6d727a59968b8fbe918c8c01df635e00", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -604,7 +604,7 @@ impl block {\n     }\n \n     fn expr_to_str(e: @ast::expr) -> ~str {\n-        fmt!(\"expr(%d: %s)\", e.id, expr_to_str(e, self.sess().intr()))\n+        util::ppaux::expr_repr(self.tcx(), e)\n     }\n \n     fn expr_is_lval(e: @ast::expr) -> bool {\n@@ -1180,13 +1180,17 @@ fn path_str(sess: session::session, p: path) -> ~str {\n     r\n }\n \n+fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n+    match bcx.fcx.param_substs {\n+        Some(substs) => ty::subst_tps(bcx.tcx(), substs.tys, t),\n+        _ => { assert !ty::type_has_params(t); t }\n+    }\n+}\n+\n fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n-    match bcx.fcx.param_substs {\n-      Some(substs) => ty::subst_tps(tcx, substs.tys, t),\n-      _ => { assert !ty::type_has_params(t); t }\n-    }\n+    monomorphize_type(bcx, t)\n }\n \n fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {"}, {"sha": "68d872883266f990b372ca0044f62e82b981ccf2", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -312,10 +312,10 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         let (v, _, _) = const_vec(cx, e, es);\n         v\n       }\n-      ast::expr_vstore(e, ast::vstore_fixed(_)) => {\n+      ast::expr_vstore(e, ast::expr_vstore_fixed(_)) => {\n         const_expr(cx, e)\n       }\n-      ast::expr_vstore(sub, ast::vstore_slice(_)) => {\n+      ast::expr_vstore(sub, ast::expr_vstore_slice) => {\n         match sub.node {\n           ast::expr_lit(lit) => {\n             match lit.node {"}, {"sha": "7e81b0666935c428c2880394e9f715084fbdca50", "filename": "src/rustc/middle/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -41,7 +41,7 @@ fn trans_if(bcx: block,\n \n     let _icx = bcx.insn_ctxt(\"trans_if\");\n     let Result {bcx, val: cond_val} =\n-        expr::trans_to_appropriate_llval(bcx, cond);\n+        expr::trans_to_datum(bcx, cond).to_result();\n \n     let then_bcx_in = scope_block(bcx, thn.info(), ~\"then\");\n     let else_bcx_in = scope_block(bcx, els.info(), ~\"else\");\n@@ -121,7 +121,7 @@ fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk)\n \n     // compile the condition\n     let Result {bcx: cond_bcx_out, val: cond_val} =\n-        expr::trans_to_appropriate_llval(cond_bcx_in, cond);\n+        expr::trans_to_datum(cond_bcx_in, cond).to_result();\n     let cond_bcx_out =\n         trans_block_cleanups(cond_bcx_out, block_cleanups(cond_bcx_in));\n     CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, next_bcx.llbb);\n@@ -179,7 +179,7 @@ fn trans_log(log_ex: @ast::expr,\n     let current_level = Load(bcx, global);\n     let level = unpack_result!(bcx, {\n         do with_scope_result(bcx, lvl.info(), ~\"level\") |bcx| {\n-            expr::trans_to_appropriate_llval(bcx, lvl)\n+            expr::trans_to_datum(bcx, lvl).to_result()\n         }\n     });\n \n@@ -278,7 +278,7 @@ fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n         + ~\" failed\";\n     let Result {bcx, val} = {\n         do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n-            expr::trans_to_appropriate_llval(bcx, pred_expr)\n+            expr::trans_to_datum(bcx, pred_expr).to_result()\n         }\n     };\n     do with_cond(bcx, Not(bcx, val)) |bcx| {"}, {"sha": "791cebad641e13c5aefecb58c5f4e4bcdddc2245", "filename": "src/rustc/middle/trans/datum.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -174,8 +174,12 @@ fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n     /*!\n      *\n      * Allocates temporary space on the stack using alloca() and\n-     * returns a by-ref Datum pointing to it.  You must arrange\n-     * any cleanups etc yourself! */\n+     * returns a by-ref Datum pointing to it.  If `zero` is true, the\n+     * space will be zeroed when it is allocated; this is normally not\n+     * necessary, but in the case of automatic rooting in match\n+     * statements it is possible to have temporaries that may not get\n+     * initialized if a certain arm is not taken, so we must zero\n+     * them. You must arrange any cleanups etc yourself! */\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n     let scratch = alloca_maybe_zeroed(bcx, llty, zero);"}, {"sha": "303e10ce818c98c6906946c1d7700a40c3fe9e35", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 150, "deletions": 69, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -35,9 +35,6 @@ The two functions above are the most general and can handle any\n situation, but there are a few other functions that are useful\n in specific scenarios:\n \n-- `trans_to_appropriate_llval()` can be used when you just want\n-  an LLVM ValueRef.  It will return by value if the value in\n-  question is immediate, or by ref otherwise.\n - `trans_lvalue()` is exactly like `trans_to_datum()` but it only\n   works on lvalues.  This is mostly used as an assertion for those\n   places where only an lvalue is expected.  It also guarantees that\n@@ -57,10 +54,10 @@ If you invoke `trans_into()`, no cleanup is scheduled for you.  The\n value is written into the given destination and is assumed to be owned\n by that destination.\n \n-When you invoke `trans_to_datum()` or `trans_to_appropriate_llval()`\n-on an rvalue, the resulting datum/value will have an appropriate\n-cleanup scheduled for the innermost cleanup scope.  If you later use\n-`move_to()` or `drop_val()`, this cleanup will be canceled.\n+When you invoke `trans_to_datum()` on an rvalue, the resulting\n+datum/value will have an appropriate cleanup scheduled for the\n+innermost cleanup scope.  If you later use `move_to()` or\n+`drop_val()`, this cleanup will be canceled.\n \n During the evaluation of an expression, temporary cleanups are created\n and later canceled.  These represent intermediate or partial results\n@@ -112,20 +109,21 @@ use base::*;\n use syntax::print::pprust::{expr_to_str};\n use util::ppaux::ty_to_str;\n use util::common::indenter;\n+use ty::{AutoPtr, AutoSlice};\n \n // The primary two functions for translating expressions:\n export trans_to_datum, trans_into;\n-export Dest, SaveIn, Ignore;\n-export cast_type_kind;\n-export cast_kind, cast_pointer, cast_integral, cast_float;\n-export cast_enum, cast_other;\n \n // More specific variants than trans_to_datum/trans_into that are useful\n // in some scenarios:\n-export trans_to_appropriate_llval, trans_lvalue, trans_local_var;\n+export trans_local_var;\n \n-// Other helpers:\n+// Other helpers, types, and so forth:\n export with_field_tys;\n+export Dest, SaveIn, Ignore;\n+export cast_type_kind;\n+export cast_kind, cast_pointer, cast_integral, cast_float;\n+export cast_enum, cast_other;\n \n // Destinations\n \n@@ -160,15 +158,98 @@ impl Dest : cmp::Eq {\n     pure fn ne(&&other: Dest) -> bool { !self.eq(other) }\n }\n \n-fn trans_to_appropriate_llval(bcx: block,\n-                              expr: @ast::expr) -> common::Result {\n-    let mut bcx = bcx;\n-    let datum = unpack_datum!(bcx, trans_to_datum(bcx, expr));\n-    debug!(\"trans_to_appropriate_llval(): datum=%s\", datum.to_str(bcx.ccx()));\n-    rslt(bcx, datum.to_appropriate_llval(bcx))\n+fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n+    debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n+\n+    return match bcx.tcx().adjustments.find(expr.id) {\n+        None => {\n+            trans_to_datum_unadjusted(bcx, expr)\n+        }\n+        Some(adj) => {\n+            let mut bcx = bcx;\n+            let mut datum = unpack_datum!(bcx, {\n+                trans_to_datum_unadjusted(bcx, expr)\n+            });\n+\n+            if adj.autoderefs > 0 {\n+                datum = datum.autoderef(bcx, expr.id, adj.autoderefs);\n+            }\n+\n+            datum = match adj.autoref {\n+                None => datum,\n+                Some(ref autoref) => {\n+                    match autoref.kind {\n+                        AutoPtr => {\n+                            unpack_datum!(bcx, auto_ref(bcx, datum))\n+                        }\n+                        AutoSlice => {\n+                            unpack_datum!(bcx, auto_slice(bcx, datum))\n+                        }\n+                    }\n+                }\n+            };\n+\n+            debug!(\"after adjustments, datum=%s\", datum.to_str(bcx.ccx()));\n+\n+            return DatumBlock {bcx: bcx, datum: datum};\n+        }\n+    };\n+\n+    fn auto_ref(bcx: block, datum: Datum) -> DatumBlock {\n+        DatumBlock {bcx: bcx, datum: datum.to_rptr(bcx)}\n+    }\n+\n+    fn auto_slice(bcx: block, datum: Datum) -> DatumBlock {\n+        // This is not the most efficient thing possible; since slices\n+        // are two words it'd be better if this were compiled in\n+        // 'dest' mode, but I can't find a nice way to structure the\n+        // code and keep it DRY that accommodates that use case at the\n+        // moment.\n+\n+        let tcx = bcx.tcx();\n+        let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n+        let (base, len) = datum.get_base_and_len(bcx);\n+\n+        // this type may have a different region/mutability than the\n+        // real one, but it will have the same runtime representation\n+        let slice_ty = ty::mk_evec(tcx, {ty: unit_ty, mutbl: ast::m_imm},\n+                                   ty::vstore_slice(ty::re_static));\n+\n+        let scratch = scratch_datum(bcx, slice_ty, false);\n+        Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n+        Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n+        DatumBlock {bcx: bcx, datum: scratch}\n+    }\n }\n \n-fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n+fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n+    return match bcx.tcx().adjustments.find(expr.id) {\n+        None => trans_into_unadjusted(bcx, expr, dest),\n+        Some(_) => {\n+            // use trans_to_datum, which is mildly less efficient but\n+            // which will perform the adjustments:\n+            let datumblock = trans_to_datum(bcx, expr);\n+            match dest {\n+                Ignore => datumblock.bcx,\n+                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n+            }\n+        }\n+    }\n+}\n+\n+fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n+    return match bcx.tcx().adjustments.find(expr.id) {\n+        None => trans_lvalue_unadjusted(bcx, expr),\n+        Some(_) => {\n+            bcx.sess().span_bug(\n+                expr.span,\n+                fmt!(\"trans_lvalue() called on an expression \\\n+                      with adjustments\"));\n+        }\n+    };\n+}\n+\n+fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an expression into a datum.  If this expression\n@@ -178,35 +259,38 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n     let mut bcx = bcx;\n \n-    debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n+    debug!(\"trans_to_datum_unadjusted(expr=%s)\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n     debuginfo::update_source_pos(bcx, expr.span);\n \n     match ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr) {\n         ty::LvalueExpr => {\n-            return trans_lvalue(bcx, expr);\n+            return trans_lvalue_unadjusted(bcx, expr);\n         }\n \n         ty::RvalueDatumExpr => {\n-            let datum = unpack_datum!(bcx, trans_rvalue_datum(bcx, expr));\n+            let datum = unpack_datum!(bcx, {\n+                trans_rvalue_datum_unadjusted(bcx, expr)\n+            });\n             datum.add_clean(bcx);\n             return DatumBlock {bcx: bcx, datum: datum};\n         }\n \n         ty::RvalueStmtExpr => {\n-            bcx = trans_rvalue_stmt(bcx, expr);\n+            bcx = trans_rvalue_stmt_unadjusted(bcx, expr);\n             return nil(bcx, expr_ty(bcx, expr));\n         }\n \n         ty::RvalueDpsExpr => {\n             let ty = expr_ty(bcx, expr);\n             if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n-                bcx = trans_rvalue_dps(bcx, expr, Ignore);\n+                bcx = trans_rvalue_dps_unadjusted(bcx, expr, Ignore);\n                 return nil(bcx, ty);\n             } else {\n                 let scratch = scratch_datum(bcx, ty, false);\n-                bcx = trans_rvalue_dps(bcx, expr, SaveIn(scratch.val));\n+                bcx = trans_rvalue_dps_unadjusted(\n+                    bcx, expr, SaveIn(scratch.val));\n \n                 // Note: this is not obviously a good idea.  It causes\n                 // immediate values to be loaded immediately after a\n@@ -231,10 +315,10 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n+fn trans_into_unadjusted(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n     let ty = expr_ty(bcx, expr);\n \n-    debug!(\"trans_into(expr=%s, dest=%s)\",\n+    debug!(\"trans_into_unadjusted(expr=%s, dest=%s)\",\n            bcx.expr_to_str(expr),\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -253,39 +337,39 @@ fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n     debug!(\"expr kind = %?\", kind);\n     match kind {\n         ty::LvalueExpr => {\n-            let datumblock = trans_lvalue(bcx, expr);\n+            let datumblock = trans_lvalue_unadjusted(bcx, expr);\n             match dest {\n                 Ignore => datumblock.bcx,\n                 SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n             }\n         }\n         ty::RvalueDatumExpr => {\n-            let datumblock = trans_rvalue_datum(bcx, expr);\n+            let datumblock = trans_rvalue_datum_unadjusted(bcx, expr);\n             match dest {\n                 Ignore => datumblock.drop_val(),\n                 SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n             }\n         }\n         ty::RvalueDpsExpr => {\n-            return trans_rvalue_dps(bcx, expr, dest);\n+            return trans_rvalue_dps_unadjusted(bcx, expr, dest);\n         }\n         ty::RvalueStmtExpr => {\n-            return trans_rvalue_stmt(bcx, expr);\n+            return trans_rvalue_stmt_unadjusted(bcx, expr);\n         }\n     }\n }\n \n-fn trans_rvalue_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_rvalue_datum\");\n+fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n+    let _icx = bcx.insn_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n-        ast::expr_vstore(contents, ast::vstore_box) => {\n+        ast::expr_vstore(contents, ast::expr_vstore_box) => {\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap_shared,\n                                                       expr, contents);\n         }\n-        ast::expr_vstore(contents, ast::vstore_uniq) => {\n+        ast::expr_vstore(contents, ast::expr_vstore_uniq) => {\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap_exchange,\n                                                       expr, contents);\n         }\n@@ -310,13 +394,14 @@ fn trans_rvalue_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_datum reached fall-through case: %?\",\n+                fmt!(\"trans_rvalue_datum_unadjusted reached \\\n+                      fall-through case: %?\",\n                      expr.node));\n         }\n     }\n }\n \n-fn trans_rvalue_stmt(bcx: block, expr: @ast::expr) -> block {\n+fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_rvalue_stmt\");\n \n@@ -378,22 +463,25 @@ fn trans_rvalue_stmt(bcx: block, expr: @ast::expr) -> block {\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_stmt reached fall-through case: %?\",\n+                fmt!(\"trans_rvalue_stmt_unadjusted reached \\\n+                      fall-through case: %?\",\n                      expr.node));\n         }\n     };\n }\n \n-fn trans_rvalue_dps(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n+fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n+                               dest: Dest) -> block {\n     let mut bcx = bcx;\n-    let _icx = bcx.insn_ctxt(\"trans_rvalue_dps\");\n+    let _icx = bcx.insn_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n         ast::expr_path(_) => {\n-            return trans_def_dps(bcx, expr, bcx.def(expr.id), dest);\n+            return trans_def_dps_unadjusted(bcx, expr,\n+                                            bcx.def(expr.id), dest);\n         }\n         ast::expr_if(cond, thn, els) => {\n             return controlflow::trans_if(bcx, cond, thn, els, dest);\n@@ -416,10 +504,10 @@ fn trans_rvalue_dps(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n         ast::expr_lit(@{node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n         }\n-        ast::expr_vstore(contents, ast::vstore_slice(_)) => {\n+        ast::expr_vstore(contents, ast::expr_vstore_slice) => {\n             return tvec::trans_slice_vstore(bcx, expr, contents, dest);\n         }\n-        ast::expr_vstore(contents, ast::vstore_fixed(_)) => {\n+        ast::expr_vstore(contents, ast::expr_vstore_fixed(_)) => {\n             return tvec::trans_fixed_vstore(bcx, expr, contents, dest);\n         }\n         ast::expr_vec(*) | ast::expr_repeat(*) => {\n@@ -527,15 +615,16 @@ fn trans_rvalue_dps(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_dps reached fall-through case: %?\",\n+                fmt!(\"trans_rvalue_dps_unadjusted reached \\\n+                      fall-through case: %?\",\n                      expr.node));\n         }\n     }\n }\n \n-fn trans_def_dps(bcx: block, ref_expr: @ast::expr,\n-                 def: ast::def, dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_def_dps\");\n+fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n+                            def: ast::def, dest: Dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n \n     let lldest = match dest {\n@@ -575,13 +664,13 @@ fn trans_def_dps(bcx: block, ref_expr: @ast::expr,\n     }\n }\n \n-fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n-    //!\n-    //\n-    // Translates an lvalue expression, always yielding a by-ref\n-    // datum.  Generally speaking you should call trans_to_datum()\n-    // instead, but sometimes we call trans_lvalue() directly as a\n-    // means of asserting that a particular expression is an lvalue.\n+fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n+    /*!\n+     *\n+     * Translates an lvalue expression, always yielding a by-ref\n+     * datum.  Generally speaking you should call trans_to_datum()\n+     * instead, but sometimes we call trans_lvalue() directly as a\n+     * means of asserting that a particular expression is an lvalue. */\n \n     let _icx = bcx.insn_ctxt(\"trans_lval\");\n     let mut bcx = bcx;\n@@ -798,12 +887,7 @@ fn trans_rec_field(bcx: block,\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n \n-    // Translate and autoderef the base expression.  We should have a\n-    // record or a struct when we're done, both of which are currently\n-    // non-immediate and hence always tracked by reference.\n     let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-    let base_datum = base_datum.autoderef(bcx, base.id, uint::max_value);\n-\n     do with_field_tys(bcx.tcx(), base_datum.ty) |_has_dtor, field_tys| {\n         let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n         DatumBlock {\n@@ -822,14 +906,11 @@ fn trans_index(bcx: block,\n     let base_ty = expr_ty(bcx, base);\n     let mut bcx = bcx;\n \n-    // Translate and autoderef the base expression.  We should have some sort\n-    // of vector (@[], &[], ~[], []/_, etc) when we're done.\n     let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-    let base_datum = base_datum.autoderef(bcx, base.id, uint::max_value);\n \n     // Translate index expression and cast to a suitable LLVM integer.\n     // Rust is less strict than LLVM in this regard.\n-    let Result {bcx, val: ix_val} = trans_to_appropriate_llval(bcx, idx);\n+    let Result {bcx, val: ix_val} = trans_to_datum(bcx, idx).to_result();\n     let ix_size = shape::llsize_of_real(bcx.ccx(), val_ty(ix_val));\n     let int_size = shape::llsize_of_real(bcx.ccx(), ccx.int_type);\n     let ix_val = {\n@@ -989,11 +1070,11 @@ fn trans_unary_datum(bcx: block,\n \n     return match op {\n         ast::not => {\n-            let Result {bcx, val} = trans_to_appropriate_llval(bcx, sub_expr);\n+            let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n             immediate_rvalue_bcx(bcx, Not(bcx, val), un_ty)\n         }\n         ast::neg => {\n-            let Result {bcx, val} = trans_to_appropriate_llval(bcx, sub_expr);\n+            let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n             let llneg = {\n                 if ty::type_is_fp(un_ty) {\n                     FNeg(bcx, val)\n@@ -1153,7 +1234,7 @@ fn trans_lazy_binop(bcx: block,\n \n     let Result {bcx: past_lhs, val: lhs} = {\n         do base::with_scope_result(bcx, a.info(), ~\"lhs\") |bcx| {\n-            trans_to_appropriate_llval(bcx, a)\n+            trans_to_datum(bcx, a).to_result()\n         }\n     };\n \n@@ -1170,7 +1251,7 @@ fn trans_lazy_binop(bcx: block,\n     }\n     let Result {bcx: past_rhs, val: rhs} = {\n         do base::with_scope_result(before_rhs, b.info(), ~\"rhs\") |bcx| {\n-            trans_to_appropriate_llval(bcx, b)\n+            trans_to_datum(bcx, b).to_result()\n         }\n     };\n \n@@ -1299,7 +1380,7 @@ fn trans_imm_cast(bcx: block, expr: @ast::expr,\n     let t_out = node_id_type(bcx, id);\n \n     let mut bcx = bcx;\n-    let llexpr = unpack_result!(bcx, trans_to_appropriate_llval(bcx, expr));\n+    let llexpr = unpack_result!(bcx, trans_to_datum(bcx, expr).to_result());\n     let ll_t_in = val_ty(llexpr);\n     let t_in = expr_ty(bcx, expr);\n     let ll_t_out = type_of::type_of(ccx, t_out);"}, {"sha": "a87ae02f8d28a99b184a48079465a28f8cd973cd", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -95,18 +95,17 @@ fn trans_method(ccx: @crate_ctxt,\n fn trans_self_arg(bcx: block, base: @ast::expr,\n                   mentry: typeck::method_map_entry) -> Result {\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n-    let basety = expr_ty(bcx, base);\n-    let mode = ast::expl(mentry.self_mode);\n     let mut temp_cleanups = ~[];\n-    let result = trans_arg_expr(bcx, {mode: mode, ty: basety}, base,\n-                                &mut temp_cleanups, None, mentry.derefs);\n-\n-    // by-ref self argument should not require cleanup in the case of\n-    // other arguments failing:\n-    //assert temp_cleanups == ~[];\n-    //do vec::iter(temp_cleanups) |c| {\n-    //    revoke_clean(bcx, c)\n-    //}\n+    let self_arg = {mode: mentry.self_arg.mode,\n+                    ty: monomorphize_type(bcx, mentry.self_arg.ty)};\n+    let result = trans_arg_expr(bcx, self_arg, base,\n+                                &mut temp_cleanups, None);\n+\n+    // FIXME(#3446)---this is wrong, actually.  The temp_cleanups\n+    // should be revoked only after all arguments have been passed.\n+    for temp_cleanups.each |c| {\n+        revoke_clean(bcx, c)\n+    }\n \n     return result;\n }\n@@ -120,14 +119,14 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n             let Result {bcx, val} = trans_self_arg(bcx, self, mentry);\n-\n+            let tcx = bcx.tcx();\n             Callee {\n                 bcx: bcx,\n                 data: Method(MethodData {\n                     llfn: callee_fn.llfn,\n                     llself: val,\n                     self_ty: node_id_type(bcx, self.id),\n-                    self_mode: mentry.self_mode\n+                    self_mode: ty::resolved_mode(tcx, mentry.self_arg.mode)\n                 })\n             }\n         }\n@@ -144,7 +143,7 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n             }\n         }\n         typeck::method_trait(_, off) => {\n-            trans_trait_callee(bcx, callee_id, off, self, mentry.derefs)\n+            trans_trait_callee(bcx, callee_id, off, self)\n         }\n     }\n }\n@@ -176,7 +175,9 @@ fn trans_static_method_callee(bcx: block,\n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get(callee_id));\n \n-    match vtbls[0] { // is index 0 always the one we want?\n+    // FIXME(#3446) -- I am pretty sure index 0 is not the right one,\n+    // if the static method is implemented on a generic type. (NDM)\n+    match vtbls[0] {\n         typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n \n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n@@ -276,18 +277,19 @@ fn trans_monomorphized_callee(bcx: block,\n           let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n \n           // combine the self environment with the rest\n+          let tcx = bcx.tcx();\n           Callee {\n               bcx: bcx,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n                   llself: llself_val,\n                   self_ty: node_id_type(bcx, base.id),\n-                  self_mode: mentry.self_mode\n+                  self_mode: ty::resolved_mode(tcx, mentry.self_arg.mode)\n               })\n           }\n       }\n       typeck::vtable_trait(*) => {\n-          trans_trait_callee(bcx, callee_id, n_method, base, mentry.derefs)\n+          trans_trait_callee(bcx, callee_id, n_method, base)\n       }\n       typeck::vtable_param(*) => {\n           fail ~\"vtable_param left in monomorphized function's vtable substs\";\n@@ -388,8 +390,7 @@ fn combine_impl_and_methods_origins(bcx: block,\n fn trans_trait_callee(bcx: block,\n                       callee_id: ast::node_id,\n                       n_method: uint,\n-                      self_expr: @ast::expr,\n-                      autoderefs: uint)\n+                      self_expr: @ast::expr)\n     -> Callee\n {\n     //!\n@@ -404,7 +405,6 @@ fn trans_trait_callee(bcx: block,\n     let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n     let mut bcx = bcx;\n     let self_datum = unpack_datum!(bcx, expr::trans_to_datum(bcx, self_expr));\n-    let self_datum = self_datum.autoderef(bcx, self_expr.id, autoderefs);\n     let llpair = self_datum.to_ref_llval(bcx);\n     let callee_ty = node_id_type(bcx, callee_id);\n     trans_trait_callee_from_llval(bcx, callee_ty, n_method, llpair)"}, {"sha": "2edf0178e32cd5d7f78a7fce2a194d17d645e5fc", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 59, "deletions": 43, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -19,7 +19,9 @@ use syntax::ast::*;\n use syntax::print::pprust::*;\n use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n use std::serialization::{serialize_Option,\n-                            deserialize_Option};\n+                         deserialize_Option,\n+                         serialize_uint,\n+                         deserialize_uint};\n \n export TyVid, IntVid, FnVid, RegionVid, vid;\n export br_hashmap;\n@@ -155,6 +157,7 @@ export closure_kind;\n export ck_block;\n export ck_box;\n export ck_uniq;\n+export param_ty;\n export param_bound, param_bounds, bound_copy, bound_owned;\n export param_bounds_to_str, param_bound_to_str;\n export bound_send, bound_trait;\n@@ -192,6 +195,8 @@ export opt_region_variance;\n export serialize_opt_region_variance, deserialize_opt_region_variance;\n export determine_inherited_purity;\n export provided_trait_methods;\n+export AutoAdjustment, serialize_AutoAdjustment, deserialize_AutoAdjustment;\n+export AutoRef, AutoRefKind, AutoSlice, AutoPtr;\n \n // Data types\n \n@@ -287,19 +292,26 @@ impl region_variance: cmp::Eq {\n     pure fn ne(&&other: region_variance) -> bool { !self.eq(other) }\n }\n \n-// N.B.: Borrows from inlined content are not accurately deserialized.  This\n-// is because we don't need the details in trans, we only care if there is an\n-// entry in the table or not.\n-type borrow = {\n-    region: ty::region,\n+#[auto_serialize]\n+type AutoAdjustment = {\n+    autoderefs: uint,\n+    autoref: Option<AutoRef>\n+};\n+\n+#[auto_serialize]\n+type AutoRef = {\n+    kind: AutoRefKind,\n+    region: region,\n     mutbl: ast::mutability\n };\n \n-impl borrow : cmp::Eq {\n-    pure fn eq(&&other: borrow) -> bool {\n-        self.region == other.region && self.mutbl == other.mutbl\n-    }\n-    pure fn ne(&&other: borrow) -> bool { !self.eq(other) }\n+#[auto_serialize]\n+enum AutoRefKind {\n+    /// Convert from @[]/~[] to &[] (or str)\n+    AutoSlice,\n+\n+    /// Convert from T to &T\n+    AutoPtr\n }\n \n type ctxt =\n@@ -340,8 +352,7 @@ type ctxt =\n       trait_method_cache: HashMap<def_id, @~[method]>,\n       ty_param_bounds: HashMap<ast::node_id, param_bounds>,\n       inferred_modes: HashMap<ast::node_id, ast::mode>,\n-      // maps the id of borrowed expr to scope of borrowed ptr\n-      borrowings: HashMap<ast::node_id, borrow>,\n+      adjustments: HashMap<ast::node_id, @AutoAdjustment>,\n       normalized_cache: HashMap<t, t>,\n       lang_items: middle::lang_items::LanguageItems};\n \n@@ -496,6 +507,7 @@ impl param_ty : to_bytes::IterBytes {\n \n \n /// Representation of regions:\n+#[auto_serialize]\n enum region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -523,6 +535,7 @@ enum region {\n     re_var(RegionVid)\n }\n \n+#[auto_serialize]\n enum bound_region {\n     /// The self region for classes, impls (&T in a type defn or &self/T)\n     br_self,\n@@ -533,35 +546,37 @@ enum bound_region {\n     /// Named region parameters for functions (a in &a/T)\n     br_named(ast::ident),\n \n-    /// Handles capture-avoiding substitution in a rather subtle case.  If you\n-    /// have a closure whose argument types are being inferred based on the\n-    /// expected type, and the expected type includes bound regions, then we\n-    /// will wrap those bound regions in a br_cap_avoid() with the id of the\n-    /// fn expression.  This ensures that the names are not \"captured\" by the\n-    /// enclosing scope, which may define the same names.  For an example of\n-    /// where this comes up, see src/test/compile-fail/regions-ret-borrowed.rs\n-    /// and regions-ret-borrowed-1.rs.\n+    /**\n+     * Handles capture-avoiding substitution in a rather subtle case.  If you\n+     * have a closure whose argument types are being inferred based on the\n+     * expected type, and the expected type includes bound regions, then we\n+     * will wrap those bound regions in a br_cap_avoid() with the id of the\n+     * fn expression.  This ensures that the names are not \"captured\" by the\n+     * enclosing scope, which may define the same names.  For an example of\n+     * where this comes up, see src/test/compile-fail/regions-ret-borrowed.rs\n+     * and regions-ret-borrowed-1.rs. */\n     br_cap_avoid(ast::node_id, @bound_region),\n }\n \n type opt_region = Option<region>;\n \n-/// The type substs represents the kinds of things that can be substituted to\n-/// convert a polytype into a monotype.  Note however that substituting bound\n-/// regions other than `self` is done through a different mechanism.\n-///\n-/// `tps` represents the type parameters in scope.  They are indexed according\n-/// to the order in which they were declared.\n-///\n-/// `self_r` indicates the region parameter `self` that is present on nominal\n-/// types (enums, classes) declared as having a region parameter.  `self_r`\n-/// should always be none for types that are not region-parameterized and\n-/// Some(_) for types that are.  The only bound region parameter that should\n-/// appear within a region-parameterized type is `self`.\n-///\n-/// `self_ty` is the type to which `self` should be remapped, if any.  The\n-/// `self` type is rather funny in that it can only appear on traits and\n-/// is always substituted away to the implementing type for a trait.\n+/**\n+ * The type substs represents the kinds of things that can be substituted to\n+ * convert a polytype into a monotype.  Note however that substituting bound\n+ * regions other than `self` is done through a different mechanism:\n+ *\n+ * - `tps` represents the type parameters in scope.  They are indexed\n+ *   according to the order in which they were declared.\n+ *\n+ * - `self_r` indicates the region parameter `self` that is present on nominal\n+ *   types (enums, classes) declared as having a region parameter.  `self_r`\n+ *   should always be none for types that are not region-parameterized and\n+ *   Some(_) for types that are.  The only bound region parameter that should\n+ *   appear within a region-parameterized type is `self`.\n+ *\n+ * - `self_ty` is the type to which `self` should be remapped, if any.  The\n+ *   `self` type is rather funny in that it can only appear on traits and is\n+ *   always substituted away to the implementing type for a trait. */\n type substs = {\n     self_r: opt_region,\n     self_ty: Option<ty::t>,\n@@ -650,6 +665,7 @@ enum param_bound {\n enum TyVid = uint;\n enum IntVid = uint;\n enum FnVid = uint;\n+#[auto_serialize]\n enum RegionVid = uint;\n \n enum InferTy {\n@@ -842,7 +858,7 @@ fn mk_ctxt(s: session::session,\n       trait_method_cache: new_def_hash(),\n       ty_param_bounds: map::int_hash(),\n       inferred_modes: map::int_hash(),\n-      borrowings: map::int_hash(),\n+      adjustments: map::int_hash(),\n       normalized_cache: new_ty_hash(),\n       lang_items: move lang_items}\n }\n@@ -1339,7 +1355,7 @@ fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n     fmt!(\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n          substs.self_r.map_default(~\"none\", |r| region_to_str(cx, r)),\n          substs.self_ty.map_default(~\"none\", |t| ty_to_str(cx, t)),\n-         substs.tps.map(|t| ty_to_str(cx, t)))\n+         tys_to_str(cx, substs.tps))\n }\n \n fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n@@ -2939,8 +2955,8 @@ fn expr_kind(tcx: ctxt,\n         ast::expr_unary_move(*) |\n         ast::expr_repeat(*) |\n         ast::expr_lit(@{node: lit_str(_), _}) |\n-        ast::expr_vstore(_, ast::vstore_slice(_)) |\n-        ast::expr_vstore(_, ast::vstore_fixed(_)) |\n+        ast::expr_vstore(_, ast::expr_vstore_slice) |\n+        ast::expr_vstore(_, ast::expr_vstore_fixed(_)) |\n         ast::expr_vec(*) => {\n             RvalueDpsExpr\n         }\n@@ -2990,8 +3006,8 @@ fn expr_kind(tcx: ctxt,\n         ast::expr_unary(*) |\n         ast::expr_addr_of(*) |\n         ast::expr_binary(*) |\n-        ast::expr_vstore(_, ast::vstore_box) |\n-        ast::expr_vstore(_, ast::vstore_uniq) => {\n+        ast::expr_vstore(_, ast::expr_vstore_box) |\n+        ast::expr_vstore(_, ast::expr_vstore_uniq) => {\n             RvalueDatumExpr\n         }\n "}, {"sha": "4b146d89cf8f8dd1d3b186da7bfe518d558781cd", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -60,7 +60,7 @@ use std::serialization::{serialize_uint, deserialize_uint};\n use vec::each;\n use syntax::print::pprust::*;\n use util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n-                     bound_region_to_str, vstore_to_str};\n+                  bound_region_to_str, vstore_to_str, expr_repr};\n use util::common::{indent, indenter};\n use std::list;\n use list::{List, Nil, Cons};\n@@ -86,7 +86,7 @@ enum method_origin {\n     // method invoked on a type parameter with a bounded trait\n     method_param(method_param),\n \n-    // method invoked on a boxed trait\n+    // method invoked on a trait instance\n     method_trait(ast::def_id, uint),\n }\n \n@@ -108,13 +108,10 @@ type method_param = {\n     bound_num: uint\n };\n \n-#[auto_serialize]\n type method_map_entry = {\n-    // number of derefs that are required on the receiver\n-    derefs: uint,\n-\n-    // the mode by which the self parameter needs to be passed\n-    self_mode: ast::rmode,\n+    // the type and mode of the self parameter, which is not reflected\n+    // in the fn type (FIXME #3446)\n+    self_arg: ty::arg,\n \n     // method details being invoked\n     origin: method_origin"}, {"sha": "9af764511d33eaa1dbb8607887dba7c715bb555f", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 237, "deletions": 189, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -102,7 +102,7 @@ struct inherited {\n     locals: HashMap<ast::node_id, TyVid>,\n     node_types: HashMap<ast::node_id, ty::t>,\n     node_type_substs: HashMap<ast::node_id, ty::substs>,\n-    borrowings: HashMap<ast::node_id, ty::borrow>,\n+    adjustments: HashMap<ast::node_id, @ty::AutoAdjustment>\n }\n \n struct fn_ctxt {\n@@ -143,7 +143,7 @@ fn blank_inherited(ccx: @crate_ctxt) -> @inherited {\n         locals: int_hash(),\n         node_types: map::int_hash(),\n         node_type_substs: map::int_hash(),\n-        borrowings: map::int_hash()\n+        adjustments: map::int_hash()\n     }\n }\n \n@@ -604,6 +604,7 @@ impl @fn_ctxt {\n                node_id, ty_to_str(self.tcx(), ty), self.tag());\n         self.inh.node_types.insert(node_id, ty);\n     }\n+\n     fn write_substs(node_id: ast::node_id, +substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n             debug!(\"write_substs(%d, %s) in fcx %s\",\n@@ -613,12 +614,24 @@ impl @fn_ctxt {\n             self.inh.node_type_substs.insert(node_id, substs);\n         }\n     }\n+\n     fn write_ty_substs(node_id: ast::node_id, ty: ty::t,\n                        +substs: ty::substs) {\n         let ty = ty::subst(self.tcx(), &substs, ty);\n         self.write_ty(node_id, ty);\n         self.write_substs(node_id, substs);\n     }\n+\n+    fn write_autoderef_adjustment(node_id: ast::node_id, derefs: uint) {\n+        if derefs == 0 { return; }\n+        self.write_adjustment(node_id, @{autoderefs: derefs, autoref: None});\n+    }\n+\n+    fn write_adjustment(node_id: ast::node_id, adj: @ty::AutoAdjustment) {\n+        debug!(\"write_adjustment(node_id=%?, adj=%?)\", node_id, adj);\n+        self.inh.adjustments.insert(node_id, adj);\n+    }\n+\n     fn write_nil(node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n@@ -630,14 +643,17 @@ impl @fn_ctxt {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n+    fn expr_to_str(expr: @ast::expr) -> ~str {\n+        expr_repr(self.tcx(), expr)\n+    }\n+\n     fn expr_ty(ex: @ast::expr) -> ty::t {\n         match self.inh.node_types.find(ex.id) {\n             Some(t) => t,\n             None => {\n                 self.tcx().sess.bug(\n-                    fmt!(\"no type for expr %d (%s) in fcx %s\",\n-                         ex.id, expr_to_str(ex, self.ccx.tcx.sess.intr()),\n-                         self.tag()));\n+                    fmt!(\"no type for %s in fcx %s\",\n+                         self.expr_to_str(ex), self.tag()));\n             }\n         }\n     }\n@@ -691,22 +707,15 @@ impl @fn_ctxt {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    fn mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n-                   sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n+    fn mk_assignty(expr: @ast::expr, sub: ty::t, sup: ty::t)\n+        -> Result<(), ty::type_err>\n+    {\n         match infer::mk_assignty(self.infcx(), false, expr.span, sub, sup) {\n             Ok(None) => result::Ok(()),\n             Err(e) => result::Err(e),\n-            Ok(Some(borrow)) => {\n-                match self.mk_subr(true, expr.span,\n-                                   ty::re_scope(borrow_lb), borrow.region) {\n-                    Err(e) => Err(e),\n-                    Ok(()) => {\n-                        debug!(\"inserting borrowing of expr %?: %?\",\n-                               expr.id, borrow);\n-                        self.inh.borrowings.insert(expr.id, borrow);\n-                        Ok(())\n-                    }\n-                }\n+            Ok(Some(adjustment)) => {\n+                self.write_adjustment(expr.id, adjustment);\n+                Ok(())\n             }\n         }\n     }\n@@ -753,9 +762,18 @@ impl @fn_ctxt {\n     }\n }\n \n-fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n+fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n+    /*!\n+     *\n+     * Autoderefs the type `t` as many times as possible, returning\n+     * a new type and a counter for how many times the type was\n+     * deref'd.  If the counter is non-zero, the receiver is responsible\n+     * for inserting an AutoAdjustment record into `tcx.adjustments`\n+     * so that trans/borrowck/etc know about this autoderef. */\n+\n     let mut t1 = t;\n     let mut enum_dids = ~[];\n+    let mut autoderefs = 0;\n     loop {\n         let sty = structure_of(fcx, sp, t1);\n \n@@ -773,13 +791,14 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n             }\n             ty::ty_enum(did, _) => {\n                 // Watch out for a type like `enum t = @t`.  Such a\n-                // type would otherwise infinitely auto-deref.  This\n-                // is the only autoderef loop that needs to be\n+                // type would otherwise infinitely auto-deref.  Only\n+                // autoderef loops during typeck (basically, this one\n+                // and the loops in typeck::check::method) need to be\n                 // concerned with this, as an error will be reported\n                 // on the enum definition as well because the enum is\n                 // not instantiable.\n                 if vec::contains(enum_dids, did) {\n-                    return t1;\n+                    return (t1, autoderefs);\n                 }\n                 vec::push(enum_dids, did);\n             }\n@@ -788,8 +807,13 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n \n         // Otherwise, deref if type is derefable:\n         match ty::deref_sty(fcx.ccx.tcx, &sty, false) {\n-            None => return t1,\n-            Some(mt) => t1 = mt.ty\n+            None => {\n+                return (t1, autoderefs);\n+            }\n+            Some(mt) => {\n+                autoderefs += 1;\n+                t1 = mt.ty\n+            }\n         }\n     };\n }\n@@ -904,16 +928,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expected: Option<ty::t>,\n                            unifier: fn()) -> bool {\n \n-    debug!(\n-        \">> typechecking expr %d (%s)\",\n-        expr.id, syntax::print::pprust::expr_to_str(expr,\n-                                                    fcx.ccx.tcx.sess.intr()));\n+    debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and\n     // overloaded operations\n     fn check_call_inner(\n-        fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id, in_fty: ty::t,\n+        fcx: @fn_ctxt,\n+        sp: span,\n+        call_expr_id: ast::node_id,\n+        in_fty: ty::t,\n         callee_expr: @ast::expr,\n+        check_args: bool,\n         args: ~[@ast::expr]) -> {fty: ty::t, bot: bool} {\n \n         let mut bot = false;\n@@ -956,7 +981,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Grab the argument types, supplying fresh type variables\n         // if the wrong number of arguments were supplied\n         let expected_arg_count = vec::len(fn_ty.sig.inputs);\n-        let arg_tys = if expected_arg_count == supplied_arg_count {\n+        let formal_tys = if expected_arg_count == supplied_arg_count {\n             fn_ty.sig.inputs.map(|a| a.ty)\n         } else {\n             fcx.ccx.tcx.sess.span_err(\n@@ -983,26 +1008,35 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n         for [false, true]/_.each |check_blocks| {\n+            debug!(\"check_blocks=%b\", check_blocks);\n+\n             // More awful hacks: before we check the blocks, try to do\n             // an \"opportunistic\" vtable resolution of any trait\n             // bounds on the call.\n             if check_blocks {\n                 vtable::early_resolve_expr(callee_expr, fcx, true);\n             }\n \n-            for args.eachi |i, a| {\n-                let is_block = match a.node {\n-                  ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n-                  ast::expr_do_body(*) => true,\n-                  _ => false\n+            for args.eachi |i, arg| {\n+                let is_block = match arg.node {\n+                    ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n+                    ast::expr_do_body(*) => true,\n+                    _ => false\n                 };\n+\n                 if is_block == check_blocks {\n-                    let arg_ty = arg_tys[i];\n-                    bot |= check_expr_with_unifier(\n-                        fcx, a, Some(arg_ty),\n-                        || demand::assign(fcx, a.span, call_expr_id,\n-                                          arg_ty, a)\n+                    debug!(\"checking the argument\");\n+                    let formal_ty = formal_tys[i];\n+\n+                    if check_args {\n+                        bot |= check_expr_with_unifier(\n+                            fcx, arg, Some(formal_ty),\n+                            || demand::assign(fcx, arg.span, formal_ty, arg)\n                         );\n+                    } else {\n+                        demand::assign(fcx, arg.span, formal_ty, arg);\n+                        bot |= ty::type_is_bot(fcx.expr_ty(arg));\n+                    }\n                 }\n             }\n         }\n@@ -1036,7 +1070,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Call the generic checker.\n         let fty = {\n             let r = check_call_inner(fcx, sp, call_expr_id,\n-                                     fn_ty, f, args);\n+                                     fn_ty, f, true, args);\n             bot |= r.bot;\n             r.fty\n         };\n@@ -1092,88 +1126,113 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n                         self_ex: @ast::expr, self_t: ty::t,\n-                        opname: ast::ident, args: ~[@ast::expr])\n-        -> Option<(ty::t, bool)> {\n-        let lkup = method::lookup(fcx, op_ex, self_ex, op_ex.id,\n-                     op_ex.callee_id, opname, self_t, ~[], false);\n-        match lkup.method() {\n+                        opname: ast::ident, check_args: bool,\n+                        args: ~[@ast::expr])\n+        -> Option<(ty::t, bool)>\n+    {\n+        match method::lookup(fcx, op_ex, self_ex,\n+                             op_ex.callee_id, opname, self_t, ~[]) {\n           Some(origin) => {\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n                 check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                 method_ty, op_ex, args)\n+                                 method_ty, op_ex, check_args, args)\n             };\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             Some((ty::ty_fn_ret(method_ty), bot))\n           }\n           _ => None\n         }\n     }\n+\n+    fn check_rel_op(fcx: @fn_ctxt,\n+                    expr: @ast::expr,\n+                    op: ast::binop,\n+                    lhs: @ast::expr,\n+                    rhs: @ast::expr) -> bool\n+    {\n+        // We know that only things of equal type can be compared, so\n+        // go ahead and unify the two types before we do anything else\n+        // (with other operators, we must be much more careful not to\n+        // make assumptions, due to the possibility of operator\n+        // overloading; but overloaded == still enforces the\n+        // requirement that only equal types are compared).\n+        let tcx = fcx.ccx.tcx;\n+        let lhs_bot = check_expr(fcx, lhs, None);\n+        let lhs_t = fcx.expr_ty(lhs);\n+        let rhs_bot = check_expr_with(fcx, rhs, lhs_t);\n+\n+        let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n+        if ty::is_binopable(tcx, lhs_t, op) {\n+            let result_t = ty::mk_bool(tcx);\n+            fcx.write_ty(expr.id, result_t);\n+            return lhs_bot | rhs_bot;\n+        }\n+\n+        let (result, rhs_bot) =\n+            check_user_binop(fcx, expr, lhs, lhs_t, op, false, rhs);\n+        fcx.write_ty(expr.id, result);\n+        return lhs_bot | rhs_bot;\n+    }\n+\n     // could be either a expr_binop or an expr_assign_binop\n     fn check_binop(fcx: @fn_ctxt, expr: @ast::expr,\n                    op: ast::binop,\n                    lhs: @ast::expr,\n                    rhs: @ast::expr) -> bool {\n         let tcx = fcx.ccx.tcx;\n-        let lhs_bot = check_expr(fcx, lhs, None);\n-        let lhs_t = fcx.expr_ty(lhs);\n \n-        // Hack: Unify the two sides if this is a relational operator.\n+        // Relational operators are different for type inferencing\n+        // reasons.\n         match op {\n             ast::eq | ast::ne | ast::lt | ast::le | ast::ge | ast::gt => {\n-                check_expr_with(fcx, rhs, lhs_t);\n+                return check_rel_op(fcx, expr, op, lhs, rhs);\n             }\n             _ => {}\n         }\n \n+        let lhs_bot = check_expr(fcx, lhs, None);\n+        let lhs_t = fcx.expr_ty(lhs);\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n-        return match (op, ty::get(lhs_t).sty) {\n-          (_, _) if ty::type_is_integral(lhs_t) &&\n-          ast_util::is_shift_binop(op) => {\n+\n+        if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type\n             let rhs_bot = check_expr(fcx, rhs, None);\n             let rhs_t = fcx.expr_ty(rhs);\n             require_integral(fcx, rhs.span, rhs_t);\n             fcx.write_ty(expr.id, lhs_t);\n-            lhs_bot | rhs_bot\n-          }\n+            return lhs_bot | rhs_bot;\n+        }\n \n-          (_, _) if ty::is_binopable(tcx, lhs_t, op) => {\n+        if ty::is_binopable(tcx, lhs_t, op) {\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n-            let result_t = match op {\n-              ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n-              ast::gt => {\n-                if !ty::type_is_scalar(lhs_t) {\n-                    fcx.ccx.tcx.sess.span_bug(expr.span,\n-                                              ~\"non-scalar compare\");\n-                }\n-                ty::mk_bool(fcx.ccx.tcx)\n-              }\n-              _ => lhs_t\n-            };\n+            let result_t = lhs_t;\n             fcx.write_ty(expr.id, result_t);\n-            if !ast_util::lazy_binop(op) { lhs_bot | rhs_bot }\n-            else { lhs_bot }\n-          }\n+            return {\n+                if !ast_util::lazy_binop(op) { lhs_bot | rhs_bot }\n+                else { lhs_bot }\n+            };\n+        }\n \n-          (_, _) => {\n-            let (result, rhs_bot) =\n-                check_user_binop(fcx, expr, lhs, lhs_t, op, rhs);\n-            fcx.write_ty(expr.id, result);\n-            lhs_bot | rhs_bot\n-          }\n-        };\n+        let (result, rhs_bot) =\n+            check_user_binop(fcx, expr, lhs, lhs_t, op, true, rhs);\n+        fcx.write_ty(expr.id, result);\n+        return lhs_bot | rhs_bot;\n     }\n+\n     fn check_user_binop(fcx: @fn_ctxt, ex: @ast::expr,\n                         lhs_expr: @ast::expr, lhs_resolved_t: ty::t,\n-                        op: ast::binop, rhs: @ast::expr) -> (ty::t, bool) {\n+                        op: ast::binop, check_rhs: bool,\n+                        rhs: @ast::expr) -> (ty::t, bool)\n+    {\n         let tcx = fcx.ccx.tcx;\n         match ast_util::binop_to_method_name(op) {\n           Some(name) => {\n             match lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n-                                   fcx.tcx().sess.ident_of(name), ~[rhs]) {\n+                                   fcx.tcx().sess.ident_of(name),\n+                                   check_rhs, ~[rhs]) {\n               Some(pair) => return pair,\n               _ => ()\n             }\n@@ -1202,11 +1261,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         (lhs_resolved_t, false)\n     }\n+\n     fn check_user_unop(fcx: @fn_ctxt, op_str: ~str, mname: ~str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr, rhs_t: ty::t) -> ty::t {\n         match lookup_op_method(fcx, ex, rhs_expr, rhs_t,\n-                               fcx.tcx().sess.ident_of(mname), ~[]) {\n+                               fcx.tcx().sess.ident_of(mname), true, ~[]) {\n           Some((ret_ty, _)) => ret_ty,\n           _ => {\n             fcx.ccx.tcx.sess.span_err(\n@@ -1308,87 +1368,84 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     // Check field access expressions\n     fn check_field(fcx: @fn_ctxt, expr: @ast::expr, is_callee: bool,\n                    base: @ast::expr, field: ast::ident, tys: ~[@ast::ty])\n-        -> bool {\n+        -> bool\n+    {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base, None);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n-        let base_t = do_autoderef(fcx, expr.span, expr_t);\n-        let mut handled = false;\n+        let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n         let n_tys = vec::len(tys);\n         match structure_of(fcx, expr.span, base_t) {\n-          ty::ty_rec(fields) => {\n-            match ty::field_idx(field, fields) {\n-              Some(ix) => {\n-                if n_tys > 0u {\n-                    tcx.sess.span_err(expr.span,\n-                                      ~\"can't provide type parameters \\\n-                                       to a field access\");\n+            ty::ty_rec(fields) => {\n+                match ty::field_idx(field, fields) {\n+                    Some(ix) => {\n+                        if n_tys > 0u {\n+                            tcx.sess.span_err(\n+                                expr.span,\n+                                ~\"can't provide type parameters \\\n+                                  to a field access\");\n+                        }\n+                        fcx.write_ty(expr.id, fields[ix].mt.ty);\n+                        fcx.write_autoderef_adjustment(base.id, derefs);\n+                        return bot;\n+                    }\n+                    _ => ()\n                 }\n-                fcx.write_ty(expr.id, fields[ix].mt.ty);\n-                handled = true;\n-              }\n-              _ => ()\n             }\n-          }\n-          ty::ty_class(base_id, substs) => {\n-              // This is just for fields -- the same code handles\n-              // methods in both classes and traits\n-\n-              // (1) verify that the class id actually has a field called\n-              // field\n-              debug!(\"class named %s\", ty_to_str(tcx, base_t));\n-              let cls_items = ty::lookup_class_fields(tcx, base_id);\n-              match lookup_field_ty(tcx, base_id, cls_items, field, &substs) {\n-                 Some(field_ty) => {\n-                    // (2) look up what field's type is, and return it\n-                     fcx.write_ty(expr.id, field_ty);\n-                     handled = true;\n-                 }\n-                 None => ()\n-              }\n-          }\n-          _ => ()\n-        }\n-        if !handled {\n-            let tps = vec::map(tys, |ty| fcx.to_ty(ty));\n-            let is_self_ref = self_ref(fcx, base.id);\n-\n-            // this will be the call or block that immediately\n-            // encloses the method call\n-            let borrow_lb = fcx.tcx().region_map.get(expr.id);\n-\n-            let lkup = method::lookup(fcx, expr, base, borrow_lb,\n-                                      expr.id, field, expr_t, tps,\n-                                      is_self_ref);\n-            match lkup.method() {\n-                Some(entry) => {\n-                    fcx.ccx.method_map.insert(expr.id, entry);\n-\n-                    // If we have resolved to a method but this is not in\n-                    // a callee position, error\n-                    if !is_callee {\n-                        tcx.sess.span_err(\n-                            expr.span,\n-                            ~\"attempted to take value of method \\\n-                              (try writing an anonymous function)\");\n+            ty::ty_class(base_id, substs) => {\n+                // This is just for fields -- the same code handles\n+                // methods in both classes and traits\n+\n+                // (1) verify that the class id actually has a field called\n+                // field\n+                debug!(\"class named %s\", ty_to_str(tcx, base_t));\n+                let cls_items = ty::lookup_class_fields(tcx, base_id);\n+                match lookup_field_ty(tcx, base_id, cls_items,\n+                                      field, &substs) {\n+                    Some(field_ty) => {\n+                        // (2) look up what field's type is, and return it\n+                        fcx.write_ty(expr.id, field_ty);\n+                        fcx.write_autoderef_adjustment(base.id, derefs);\n+                        return bot;\n                     }\n+                    None => ()\n                 }\n-                None => {\n-                    let t_err =\n-                        fcx.infcx().resolve_type_vars_if_possible(expr_t);\n-                    let msg =\n-                        fmt!(\n-                            \"attempted access of field `%s` on type `%s`, \\\n-                             but no field or method with that name was found\",\n-                            tcx.sess.str_of(field),\n-                            fcx.infcx().ty_to_str(t_err));\n-                    tcx.sess.span_err(expr.span, msg);\n-                    // NB: Add bogus type to allow typechecking to continue\n-                    fcx.write_ty(expr.id, fcx.infcx().next_ty_var());\n+            }\n+            _ => ()\n+        }\n+\n+        let tps = vec::map(tys, |ty| fcx.to_ty(ty));\n+\n+        match method::lookup(fcx, expr, base, expr.id,\n+                             field, expr_t, tps) {\n+            Some(entry) => {\n+                fcx.ccx.method_map.insert(expr.id, entry);\n+\n+                // If we have resolved to a method but this is not in\n+                // a callee position, error\n+                if !is_callee {\n+                    tcx.sess.span_err(\n+                        expr.span,\n+                        ~\"attempted to take value of method \\\n+                          (try writing an anonymous function)\");\n                 }\n             }\n+            None => {\n+                let t_err =\n+                    fcx.infcx().resolve_type_vars_if_possible(expr_t);\n+                let msg =\n+                    fmt!(\n+                        \"attempted access of field `%s` on type `%s`, \\\n+                         but no field or method with that name was found\",\n+                        tcx.sess.str_of(field),\n+                        fcx.infcx().ty_to_str(t_err));\n+                tcx.sess.span_err(expr.span, msg);\n+                // NB: Add bogus type to allow typechecking to continue\n+                fcx.write_ty(expr.id, fcx.infcx().next_ty_var());\n+            }\n         }\n+\n         return bot;\n     }\n \n@@ -2000,32 +2057,33 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = check_field(fcx, expr, false, base, field, tys);\n       }\n       ast::expr_index(base, idx) => {\n-        bot |= check_expr(fcx, base, None);\n-        let raw_base_t = fcx.expr_ty(base);\n-        let base_t = do_autoderef(fcx, expr.span, raw_base_t);\n-        bot |= check_expr(fcx, idx, None);\n-        let idx_t = fcx.expr_ty(idx);\n-        let base_sty = structure_of(fcx, expr.span, base_t);\n-        match ty::index_sty(tcx, &base_sty) {\n-          Some(mt) => {\n-            require_integral(fcx, idx.span, idx_t);\n-            fcx.write_ty(id, mt.ty);\n-          }\n-          None => {\n-            let resolved = structurally_resolved_type(fcx, expr.span,\n-                                                      raw_base_t);\n-            match lookup_op_method(fcx, expr, base, resolved,\n-                                   tcx.sess.ident_of(~\"index\"),\n-                                 ~[idx]) {\n-              Some((ret_ty, _)) => fcx.write_ty(id, ret_ty),\n-              _ => {\n-                tcx.sess.span_fatal(\n-                    expr.span, ~\"cannot index a value of type `\" +\n-                    fcx.infcx().ty_to_str(base_t) + ~\"`\");\n+          bot |= check_expr(fcx, base, None);\n+          let raw_base_t = fcx.expr_ty(base);\n+          let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n+          bot |= check_expr(fcx, idx, None);\n+          let idx_t = fcx.expr_ty(idx);\n+          let base_sty = structure_of(fcx, expr.span, base_t);\n+          match ty::index_sty(tcx, &base_sty) {\n+              Some(mt) => {\n+                  require_integral(fcx, idx.span, idx_t);\n+                  fcx.write_ty(id, mt.ty);\n+                  fcx.write_autoderef_adjustment(base.id, derefs);\n+              }\n+              None => {\n+                  let resolved = structurally_resolved_type(fcx, expr.span,\n+                                                            raw_base_t);\n+                  match lookup_op_method(fcx, expr, base, resolved,\n+                                         tcx.sess.ident_of(~\"index\"), true,\n+                                         ~[idx]) {\n+                      Some((ret_ty, _)) => fcx.write_ty(id, ret_ty),\n+                      _ => {\n+                          tcx.sess.span_fatal(\n+                              expr.span, ~\"cannot index a value of type `\" +\n+                              fcx.infcx().ty_to_str(base_t) + ~\"`\");\n+                      }\n+                  }\n               }\n-            }\n           }\n-        }\n       }\n     }\n     if bot { fcx.write_bot(expr.id); }\n@@ -2304,16 +2362,6 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-// Determines whether the given node ID is a use of the def of\n-// the self ID for the current method, if there is one\n-// self IDs in an outer scope count. so that means that you can\n-// call your own private methods from nested functions inside\n-// class methods\n-fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n-    option::map_default(fcx.ccx.tcx.def_map.find(id), false,\n-                        ast_util::is_self)\n-}\n-\n fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> TyVid {\n     match fcx.inh.locals.find(id) {\n         Some(x) => x,\n@@ -2480,19 +2528,19 @@ fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n }\n \n fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n-                             v: ast::vstore) -> ty::vstore {\n+                             v: ast::expr_vstore) -> ty::vstore {\n     match v {\n-        ast::vstore_fixed(None) => ty::vstore_fixed(n),\n-        ast::vstore_fixed(Some(u)) => {\n+        ast::expr_vstore_fixed(None) => ty::vstore_fixed(n),\n+        ast::expr_vstore_fixed(Some(u)) => {\n             if n != u {\n                 let s = fmt!(\"fixed-size sequence mismatch: %u vs. %u\",u, n);\n                 fcx.ccx.tcx.sess.span_err(e.span,s);\n             }\n             ty::vstore_fixed(u)\n         }\n-        ast::vstore_uniq => ty::vstore_uniq,\n-        ast::vstore_box => ty::vstore_box,\n-        ast::vstore_slice(_) => {\n+        ast::expr_vstore_uniq => ty::vstore_uniq,\n+        ast::expr_vstore_box => ty::vstore_box,\n+        ast::expr_vstore_slice => {\n             let r = fcx.infcx().next_region_var(e.span, e.id);\n             ty::vstore_slice(r)\n         }"}, {"sha": "3ae59910fe43cfd49c7f215306ec631625f43c5b", "filename": "src/rustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -27,10 +27,9 @@ fn eqtype(fcx: @fn_ctxt, sp: span,\n }\n \n // Checks that the type `actual` can be assigned to `expected`.\n-fn assign(fcx: @fn_ctxt, sp: span, borrow_lb: ast::node_id,\n-          expected: ty::t, expr: @ast::expr) {\n+fn assign(fcx: @fn_ctxt, sp: span, expected: ty::t, expr: @ast::expr) {\n     let expr_ty = fcx.expr_ty(expr);\n-    match fcx.mk_assignty(expr, borrow_lb, expr_ty, expected) {\n+    match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }\n       result::Err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, expr_ty, err);"}, {"sha": "ff90f671d756a92507ff0e77a99bd47a19be876d", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 716, "deletions": 600, "changes": 1316, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -1,719 +1,835 @@\n-/* Code to handle method lookups (which can be quite complex) */\n+/*!\n+\n+# Method lookup\n+\n+Method lookup can be rather complex due to the interaction of a number\n+of factors, such as self types, autoderef, trait lookup, etc.  The\n+algorithm is divided into two parts: candidate collection and\n+candidate selection.\n+\n+## Candidate collection\n+\n+A `Candidate` is a method item that might plausibly be the method\n+being invoked.  Candidates are grouped into two kinds, inherent and\n+extension.  Inherent candidates are those that are derived from the\n+type of the receiver itself.  So, if you have a receiver of some\n+nominal type `Foo` (e.g., a struct), any methods defined within an\n+impl like `impl Foo` are inherent methods.  Nothing needs to be\n+imported to use an inherent method, they are associated with the type\n+itself (note that inherent impls can only be defined in the same\n+module as the type itself).\n+\n+Inherent candidates are not always derived from impls.  If you have a\n+trait instance, such as a value of type `ToStr`, then the trait\n+methods (`to_str()`, in this case) are inherently associated with it.\n+Another case is type parameters, in which case the methods of their\n+bounds are inherent.\n+\n+Extension candidates are derived from imported traits.  If I have the\n+trait `ToStr` imported, and I call `to_str()` on a value of type `T`,\n+then we will go off to find out whether there is an impl of `ToStr`\n+for `T`.  These kinds of method calls are called \"extension methods\".\n+They can be defined in any module, not only the one that defined `T`.\n+Furthermore, you must import the trait to call such a method.\n+\n+For better or worse, we currently give weight to inherent methods over\n+extension methods during candidate selection (below).\n+\n+## Candidate selection\n+\n+Once we know the set of candidates, we can go off and try to select\n+which one is actually being called.  We do this by taking the type of\n+the receiver, let's call it R, and checking whether it matches against\n+the expected receiver type for each of the collected candidates.  We\n+first check for inherent candidates and see whether we get exactly one\n+match (zero means keep searching, more than one is an error).  If so,\n+we return that as the candidate.  Otherwise we search the extension\n+candidates in the same way.\n+\n+If find no matching candidate at all, we proceed to auto-deref the\n+receiver type and search again.  We keep doing that until we cannot\n+auto-deref any longer.  At that point, we will attempt an auto-ref.\n+If THAT fails, method lookup fails altogether.\n+\n+## Why two phases?\n+\n+You might wonder why we first collect the candidates and then select.\n+Both the inherent candidate collection and the candidate selection\n+proceed by progressively deref'ing the receiver type, after all.  The\n+answer is that two phases are needed to elegantly deal with explicit\n+self.  After all, if there is an impl for the type `Foo`, it can\n+define a method with the type `@self`, which means that it expects a\n+receiver of type `@Foo`.  If we have a receiver of type `@Foo`, but we\n+waited to search for that impl until we have deref'd the `@` away and\n+obtained the type `Foo`, we would never match this method.\n+\n+*/\n \n use coherence::get_base_type_def_id;\n use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{mk_box, mk_rptr, mk_uniq, FnTyBase, FnMeta, FnSig};\n-use syntax::ast::{def_id,\n-                     sty_static, sty_box, sty_by_ref, sty_region, sty_uniq};\n-use syntax::ast::{sty_value, by_ref, by_copy};\n+use middle::ty::*;\n+use syntax::ast::{def_id, sty_by_ref, sty_value, sty_region, sty_box,\n+                  sty_uniq, sty_static, node_id, by_copy, by_ref,\n+                  m_const, m_mutbl, m_imm};\n use syntax::ast_map;\n use syntax::ast_map::node_id_to_str;\n use syntax::ast_util::{dummy_sp, new_def_hash};\n use dvec::DVec;\n \n-enum method_lookup_mode {\n-    subtyping_mode,\n-    assignability_mode,\n-    immutable_reference_mode,\n-    mutable_reference_mode\n-}\n-\n-type candidate = {\n-    self_ty: ty::t,             // type of a in a.b()\n-    self_substs: ty::substs,    // values for any tvars def'd on the class\n-    rcvr_ty: ty::t,             // type of receiver in the method def\n-    n_tps_m: uint,              // number of tvars defined on the method\n-    fty: ty::t,                 // type of the method\n-    entry: method_map_entry,\n-    mode: method_lookup_mode    // the mode we used\n-};\n-\n-fn transform_self_type_for_method\n-    (tcx: ty::ctxt,\n-     self_region: Option<ty::region>,\n-     impl_ty: ty::t,\n-     self_type: ast::self_ty_)\n-                               -> ty::t {\n-    match self_type {\n-      sty_static => {\n-        tcx.sess.bug(~\"calling transform_self_type_for_method on \\\n-                       static method\");\n-      }\n-      sty_by_ref | sty_value => {\n-        impl_ty\n-      }\n-      sty_region(mutability) => {\n-        mk_rptr(tcx,\n-                self_region.expect(~\"self region missing for &self param\"),\n-                { ty: impl_ty, mutbl: mutability })\n-      }\n-      sty_box(mutability) => {\n-        mk_box(tcx, { ty: impl_ty, mutbl: mutability })\n-      }\n-      sty_uniq(mutability) => {\n-        mk_uniq(tcx, { ty: impl_ty, mutbl: mutability })\n-      }\n-    }\n-}\n-\n-fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n-    match self_type {\n-      sty_value => by_copy,\n-      _ => by_ref\n-    }\n-}\n-\n-fn lookup(fcx: @fn_ctxt,\n-\n-        // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: @ast::expr,        // The expression `a.b`.\n-        self_expr: @ast::expr,   // The expression `a`.\n-        borrow_lb: ast::node_id, // Scope to borrow the expression `a` for.\n-        node_id: ast::node_id,   // The node_id in which to store the type of\n-                                 // `a.b`.\n-        m_name: ast::ident,      // The ident `b`.\n-        self_ty: ty::t,          // The type of `a`.\n-        supplied_tps: ~[ty::t],  // The list of types X, Y, ... .\n-        include_private: bool) -> lookup {\n+fn lookup(\n+    fcx: @fn_ctxt,\n \n-    lookup {\n+    // In a call `a.b::<X, Y, ...>(...)`:\n+    expr: @ast::expr,        // The expression `a.b`.\n+    self_expr: @ast::expr,   // The expression `a`.\n+    callee_id: node_id, // Where to store the type of `a.b`\n+    m_name: ast::ident,      // The ident `b`.\n+    self_ty: ty::t,          // The type of `a`.\n+    supplied_tps: &[ty::t])  // The list of types X, Y, ... .\n+    -> Option<method_map_entry>\n+{\n+    let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n         self_expr: self_expr,\n-        borrow_lb: borrow_lb,\n-        node_id: node_id,\n+        callee_id: callee_id,\n         m_name: m_name,\n-        self_ty: self_ty,\n-        derefs: 0u,\n-        candidates: DVec(),\n-        candidate_impls: new_def_hash(),\n         supplied_tps: supplied_tps,\n-        include_private: include_private\n-    }\n+        impl_dups: new_def_hash(),\n+        inherent_candidates: DVec(),\n+        extension_candidates: DVec()\n+    };\n+    return lcx.do_lookup(self_ty);\n }\n \n-struct lookup {\n+struct LookupContext {\n     fcx: @fn_ctxt,\n     expr: @ast::expr,\n     self_expr: @ast::expr,\n-    borrow_lb: ast::node_id,\n-    node_id: ast::node_id,\n+    callee_id: node_id,\n     m_name: ast::ident,\n-    mut self_ty: ty::t,\n-    mut derefs: uint,\n-    candidates: DVec<candidate>,\n-    candidate_impls: HashMap<def_id, ()>,\n-    supplied_tps: ~[ty::t],\n-    include_private: bool,\n+    supplied_tps: &[ty::t],\n+    impl_dups: HashMap<def_id, ()>,\n+    inherent_candidates: DVec<Candidate>,\n+    extension_candidates: DVec<Candidate>\n }\n \n-impl lookup {\n-\n-    // Entrypoint:\n-    fn method() -> Option<method_map_entry> {\n-        debug!(\"method lookup(m_name=%s, self_ty=%s, %?)\",\n-               self.fcx.tcx().sess.str_of(self.m_name),\n-               self.fcx.infcx().ty_to_str(self.self_ty),\n-               ty::get(self.self_ty).sty);\n-\n-        // Determine if there are any inherent methods we can call.\n-        // (An inherent method is one that belongs to no trait, but is\n-        // inherent to a class or impl.)\n-        let optional_inherent_methods;\n-        match get_base_type_def_id(self.fcx.infcx(),\n-                                 self.self_expr.span,\n-                                 self.self_ty) {\n-          None => {\n-            optional_inherent_methods = None;\n-          }\n-          Some(base_type_def_id) => {\n-            debug!(\"(checking method) found base type\");\n-            optional_inherent_methods =\n-                self.fcx.ccx.coherence_info.inherent_methods.find\n-                (base_type_def_id);\n-\n-            if optional_inherent_methods.is_none() {\n-                debug!(\"(checking method) ... no inherent methods found\");\n-            } else {\n-                debug!(\"(checking method) ... inherent methods found\");\n-            }\n-          }\n-        }\n+/**\n+ * A potential method that might be called, assuming the receiver\n+ * is of a suitable type. */\n+struct Candidate {\n+    rcvr_ty: ty::t,\n+    rcvr_substs: ty::substs,\n+\n+    // FIXME #3446---these two fields should be easily derived from\n+    // origin, yet are not\n+    num_method_tps: uint,\n+    self_mode: ast::rmode,\n \n-        let matching_modes =\n-            [subtyping_mode, assignability_mode,\n-             immutable_reference_mode, mutable_reference_mode];\n+    origin: method_origin,\n+}\n \n+impl LookupContext {\n+    fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n+        debug!(\"do_lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n+               self.ty_to_str(self_ty),\n+               expr_repr(self.tcx(), self.expr),\n+               expr_repr(self.tcx(), self.self_expr));\n+        let _indenter = indenter();\n+\n+        // Prepare the list of candidates\n+        self.push_inherent_candidates(self_ty);\n+        self.push_extension_candidates();\n+\n+        let enum_dids = DVec();\n+        let mut self_ty = self_ty;\n+        let mut autoderefs = 0;\n         loop {\n-            // Try to find a method that is keyed directly off of the\n-            // type. This only happens for boxed traits, type params,\n-            // classes, and self. If we see some sort of pointer, then\n-            // we look at candidates for the pointed to type to match\n-            // them against methods that take explicit self parameters.\n-            // N.B.: this looking through boxes to match against\n-            // explicit self parameters is *not* the same as\n-            // autoderef.\n-            // Try each of the possible matching semantics in turn.\n-            for matching_modes.each |mode| {\n-                match ty::get(self.self_ty).sty {\n-                  ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_rptr(_, mt) => {\n-                    self.add_candidates_from_type(mt.ty, mode);\n-                  }\n-                  _ => { self.add_candidates_from_type(self.self_ty, mode); }\n+            debug!(\"loop: self_ty=%s autoderefs=%u\",\n+                   self.ty_to_str(self_ty), autoderefs);\n+\n+            match self.search_for_autoderefd_method(self_ty, autoderefs) {\n+                Some(move mme) => { return Some(mme); }\n+                None => {}\n+            }\n+\n+            // some special logic around newtypes:\n+            match ty::get(self_ty).sty {\n+                ty_enum(*) => {\n+                    // Note: in general, we prefer not to auto-ref a\n+                    // partially autoderef'd type, because it\n+                    // seems... crazy.  But we have to be careful\n+                    // around newtype enums.  They can be further\n+                    // deref'd, but they may also have intrinsic\n+                    // methods hanging off of them with interior type.\n+                    match self.search_for_appr_autorefd_method(self_ty,\n+                                                               autoderefs) {\n+                        Some(move mme) => { return Some(mme); }\n+                        None => {}\n+                    }\n                 }\n-                if self.candidates.len() > 0u { break; }\n-            }\n-\n-            // if we found anything, stop now.  otherwise continue to\n-            // loop for impls in scope.  Note: I don't love these\n-            // semantics, but that's what we had so I am preserving\n-            // it.\n-            if self.candidates.len() > 0u { break; }\n-\n-            // Try each of the possible matching semantics in turn.\n-            for matching_modes.each |mode| {\n-                self.add_inherent_and_extension_candidates(\n-                    optional_inherent_methods, mode);\n-                // If we find anything, stop.\n-                if self.candidates.len() > 0u { break; }\n-            }\n-            // if we found anything, stop before attempting auto-deref.\n-            if self.candidates.len() > 0u {\n-                debug!(\"(checking method) found at least one inherent \\\n-                        method; giving up looking now\");\n-                break;\n-            }\n-\n-            // check whether we can autoderef and if so loop around again.\n-            match ty::deref(self.tcx(), self.self_ty, false) {\n-              None => break,\n-              Some(mt) => {\n-                debug!(\"(checking method) ... autodereffing\");\n-                self.self_ty = mt.ty;\n-                self.derefs += 1u;\n-              }\n+                _ => {}\n             }\n-        }\n \n-        if self.candidates.len() == 0u {\n-            debug!(\"(checking method) couldn't find any candidate methods; \\\n-                    returning none\");\n-            return None;\n+            match self.deref(self_ty, &enum_dids) {\n+                None => { break; }\n+                Some(ty) => {\n+                    self_ty = ty;\n+                    autoderefs += 1;\n+                }\n+            }\n         }\n \n-        if self.candidates.len() > 1u {\n-            self.tcx().sess.span_err(\n-                self.expr.span,\n-                ~\"multiple applicable methods in scope\");\n+        self.search_for_appr_autorefd_method(self_ty, autoderefs)\n+    }\n \n-            for self.candidates.eachi |i, candidate| {\n-                match candidate.entry.origin {\n-                  method_static(did) => {\n-                    self.report_static_candidate(i, did);\n-                  }\n-                  method_param(p) => {\n-                    self.report_param_candidate(i, p.trait_id);\n-                  }\n-                  method_trait(did, _) => {\n-                    self.report_trait_candidate(i, did);\n-                  }\n+    fn deref(ty: ty::t, enum_dids: &DVec<ast::def_id>) -> Option<ty::t> {\n+        match ty::get(ty).sty {\n+            ty_enum(did, _) => {\n+                // Watch out for newtype'd enums like \"enum t = @T\".\n+                // See discussion in typeck::check::do_autoderef().\n+                if enum_dids.contains(did) {\n+                    return None;\n                 }\n+                enum_dids.push(did);\n             }\n+            _ => {}\n         }\n \n-        Some(self.write_mty_from_candidate(self.candidates[0u]))\n+        match ty::deref(self.tcx(), ty, false) {\n+            None => None,\n+            Some(t) => {\n+                //FIXME(#3211) -- probably want to force ivars\n+                Some(structurally_resolved_type(self.fcx,\n+                                                self.self_expr.span,\n+                                                t.ty))\n+            }\n+        }\n     }\n \n-    fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n+    // ______________________________________________________________________\n+    // Candidate collection (see comment at start of file)\n+\n+    fn push_inherent_candidates(&self, self_ty: ty::t) {\n+        /*!\n+         *\n+         * Collect all inherent candidates into\n+         * `self.inherent_candidates`.  See comment at the start of\n+         * the file.  To find the inherent candidates, we repeatedly\n+         * deref the self-ty to find the \"base-type\".  So, for\n+         * example, if the receiver is @@C where `C` is a struct type,\n+         * we'll want to find the inherent impls for `C`. */\n+\n+        let enum_dids = DVec();\n+        let mut self_ty = self_ty;\n+        loop {\n+            match get(self_ty).sty {\n+                ty_param(p) => {\n+                    self.push_inherent_candidates_from_param(p);\n+                }\n+                ty_trait(did, ref substs, _) => {\n+                    self.push_inherent_candidates_from_trait(\n+                        self_ty, did, substs);\n+                    self.push_inherent_impl_candidates_for_type(did);\n+                }\n+                ty_self => {\n+                    // Call is of the form \"self.foo()\" and appears in one\n+                    // of a trait's default method implementations.\n+                    let self_did = self.fcx.self_impl_def_id.expect(\n+                        ~\"unexpected `none` for self_impl_def_id\");\n+                    let substs = {self_r: None, self_ty: None, tps: ~[]};\n+                    self.push_inherent_candidates_from_trait(\n+                        self_ty, self_did, &substs);\n+                }\n+                ty_enum(did, _) | ty_class(did, _) => {\n+                    self.push_inherent_impl_candidates_for_type(did);\n+                }\n+                _ => { /* No inherent methods in these types */ }\n+            }\n \n-    fn report_static_candidate(idx: uint, did: ast::def_id) {\n-        let span = if did.crate == ast::local_crate {\n-            match self.tcx().items.get(did.node) {\n-              ast_map::node_method(m, _, _) => m.span,\n-              _ => fail ~\"report_static_candidate: bad item\"\n+            // n.b.: Generally speaking, we only loop if we hit the\n+            // fallthrough case in the match above.  The exception\n+            // would be newtype enums.\n+            self_ty = match self.deref(self_ty, &enum_dids) {\n+                None => { return; }\n+                Some(ty) => { ty }\n             }\n-        } else {\n-            self.expr.span\n-        };\n-        self.tcx().sess.span_note(\n-            span,\n-            fmt!(\"candidate #%u is `%s`\",\n-                 (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)));\n+        }\n     }\n \n-    fn report_param_candidate(idx: uint, did: ast::def_id) {\n-        self.tcx().sess.span_note(\n-            self.expr.span,\n-            fmt!(\"candidate #%u derives from the bound `%s`\",\n-                 (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)));\n+    fn push_extension_candidates(&self) {\n+        // If the method being called is associated with a trait, then\n+        // find all the impls of that trait.  Each of those are\n+        // candidates.\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.find(self.expr.id);\n+        for opt_applicable_traits.each |applicable_traits| {\n+            for applicable_traits.each |trait_did| {\n+                let coherence_info = self.fcx.ccx.coherence_info;\n+                let opt_impl_infos =\n+                    coherence_info.extension_methods.find(trait_did);\n+                for opt_impl_infos.each |impl_infos| {\n+                    for impl_infos.each |impl_info| {\n+                        self.push_candidates_from_impl(\n+                            &self.extension_candidates, impl_info);\n+                    }\n+                }\n+            }\n+        }\n     }\n \n-    fn report_trait_candidate(idx: uint, did: ast::def_id) {\n-        self.tcx().sess.span_note(\n-            self.expr.span,\n-            fmt!(\"candidate #%u derives from the type of the receiver, \\\n-                  which is the trait `%s`\",\n-                 (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)));\n-    }\n+    fn push_inherent_candidates_from_param(&self, param_ty: param_ty)\n+    {\n+        debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n+               param_ty);\n+        let _indenter = indenter();\n \n-    fn add_candidates_from_type(inner_ty: ty::t, mode: method_lookup_mode) {\n-        match ty::get(inner_ty).sty {\n-          // First, see whether this is a bounded parameter.\n-          ty::ty_param(p) => {\n-            self.add_candidates_from_param(inner_ty, mode, p.idx, p.def_id);\n-          }\n-          ty::ty_trait(did, substs, _) => {\n-            self.add_candidates_from_trait(inner_ty, mode, did, substs);\n-          }\n-          ty::ty_class(did, substs) => {\n-            self.add_candidates_from_class(inner_ty, mode, did, substs);\n-          }\n-          ty::ty_self => {\n-            // Call is of the form \"self.foo()\" and appears in one\n-            // of a trait's provided methods.\n-            let self_def_id = self.fcx.self_impl_def_id.expect(\n-                ~\"unexpected `none` for self_impl_def_id\");\n-\n-            let substs = {\n-                self_r: None,\n-                self_ty: None,\n-                tps: ~[],\n+        let tcx = self.tcx();\n+        let mut next_bound_idx = 0; // count only trait bounds\n+        let bounds = tcx.ty_param_bounds.get(param_ty.def_id.node);\n+        for vec::each(*bounds) |bound| {\n+            let bound_t = match bound {\n+                ty::bound_trait(bound_t) => bound_t,\n+\n+                ty::bound_copy | ty::bound_send |\n+                ty::bound_const | ty::bound_owned => {\n+                    loop; // skip non-trait bounds\n+                }\n+            };\n+\n+            let this_bound_idx = next_bound_idx;\n+            next_bound_idx += 1;\n+\n+            let (trait_id, bound_substs) = match ty::get(bound_t).sty {\n+                ty::ty_trait(i, substs, _) => (i, substs),\n+                _ => {\n+                    self.bug(fmt!(\"add_candidates_from_param: \\\n+                                   non-trait bound %s\",\n+                                  self.ty_to_str(bound_t)));\n+                }\n             };\n \n-            self.add_candidates_from_trait(inner_ty, mode,\n-                                           self_def_id, substs);\n-          }\n-          _ => ()\n+            let trait_methods = ty::trait_methods(tcx, trait_id);\n+            let pos = {\n+                // FIXME #3453 can't use trait_methods.position\n+                match vec::position(*trait_methods,\n+                                    |m| (m.self_ty != ast::sty_static &&\n+                                         m.ident == self.m_name))\n+                {\n+                    Some(pos) => pos,\n+                    None => {\n+                        loop; // check next bound\n+                    }\n+                }\n+            };\n+            let method = &trait_methods[pos];\n+\n+            // Replace any appearance of `self` with the type of the\n+            // generic parameter itself.  Note that this is the only\n+            // case where this replacement is necessary: in all other\n+            // cases, we are either invoking a method directly from an\n+            // impl or class (where the self type is not permitted),\n+            // or from a trait type (in which case methods that refer\n+            // to self are not permitted).\n+            let rcvr_ty = ty::mk_param(tcx, param_ty.idx, param_ty.def_id);\n+            let rcvr_substs = {self_ty: Some(rcvr_ty), ..bound_substs};\n+\n+            self.inherent_candidates.push(Candidate {\n+                rcvr_ty: rcvr_ty,\n+                rcvr_substs: rcvr_substs,\n+                num_method_tps: method.tps.len(),\n+                self_mode: get_mode_from_self_type(method.self_ty),\n+                origin: method_param({trait_id:trait_id,\n+                                      method_num:pos,\n+                                      param_num:param_ty.idx,\n+                                      bound_num:this_bound_idx})\n+            });\n         }\n     }\n \n-    fn add_candidates_from_param(inner_ty: ty::t, mode: method_lookup_mode,\n-                                 n: uint, did: ast::def_id) {\n-        debug!(\"add_candidates_from_param\");\n+    fn push_inherent_candidates_from_trait(&self,\n+                                           self_ty: ty::t,\n+                                           did: def_id,\n+                                           substs: &ty::substs)\n+    {\n+        debug!(\"push_inherent_candidates_from_trait(did=%s, substs=%s)\",\n+               self.did_to_str(did),\n+               substs_to_str(self.tcx(), substs));\n+        let _indenter = indenter();\n \n         let tcx = self.tcx();\n-        let mut trait_bnd_idx = 0u; // count only trait bounds\n-        let bounds = tcx.ty_param_bounds.get(did.node);\n-        for vec::each(*bounds) |bound| {\n-            let (trait_id, bound_substs) = match bound {\n-              ty::bound_copy | ty::bound_send | ty::bound_const |\n-              ty::bound_owned => {\n-                loop; /* ok */\n-              }\n-              ty::bound_trait(bound_t) => {\n-                match ty::get(bound_t).sty {\n-                  ty::ty_trait(i, substs, _) => (i, substs),\n-                  _ => fail ~\"add_candidates_from_param: non-trait bound\"\n-                }\n-              }\n-            };\n+        let ms = ty::trait_methods(tcx, did);\n+        let index = match vec::position(*ms, |m| m.ident == self.m_name) {\n+            Some(i) => i,\n+            None => { return; } // no method with the right name\n+        };\n+        let method = &ms[index];\n \n-            let trt_methods = ty::trait_methods(tcx, trait_id);\n-            let match_fn: &fn(m: ty::method) -> bool = |m| {\n-                m.self_ty != ast::sty_static && m.ident == self.m_name\n-            };\n-            match vec::position(*trt_methods, match_fn) {\n-              None => {\n-                /* check next bound */\n-                trait_bnd_idx += 1u;\n-              }\n-\n-              Some(pos) => {\n-                // Replace any appearance of `self` with the type of the\n-                // generic parameter itself.  Note that this is the only case\n-                // where this replacement is necessary: in all other cases, we\n-                // are either invoking a method directly from an impl or class\n-                // (where the self type is not permitted), or from a trait\n-                // type (in which case methods that refer to self are not\n-                // permitted).\n-                let substs = {self_ty: Some(self.self_ty),\n-                              .. bound_substs};\n-\n-                self.add_candidates_from_m(\n-                    inner_ty,\n-                    mode,\n-                    substs, trt_methods[pos],\n-                    method_param({trait_id:trait_id,\n-                                  method_num:pos,\n-                                  param_num:n,\n-                                  bound_num:trait_bnd_idx}));\n-              }\n+        /* FIXME(#3468) we should transform the vstore in accordance\n+           with the self type\n+\n+        match method.self_type {\n+            ast::sty_region(_) => {\n+                return; // inapplicable\n             }\n+            ast::sty_by_ref | ast::sty_region(_) => vstore_slice(r)\n+            ast::sty_box(_) => vstore_box, // XXX NDM mutability\n+            ast::sty_uniq(_) => vstore_uniq\n         }\n+        */\n \n+        // It is illegal to invoke a method on a trait instance that\n+        // refers to the `self` type.  Nonetheless, we substitute\n+        // `trait_ty` for `self` here, because it allows the compiler\n+        // to soldier on.  An error will be reported should this\n+        // candidate be selected if the method refers to `self`.\n+        let rcvr_substs = {self_ty: Some(self_ty), ..*substs};\n+\n+        self.inherent_candidates.push(Candidate {\n+            rcvr_ty: self_ty,\n+            rcvr_substs: move rcvr_substs,\n+            num_method_tps: method.tps.len(),\n+            self_mode: get_mode_from_self_type(method.self_ty),\n+            origin: method_trait(did, index)\n+        });\n     }\n \n-    fn add_candidates_from_trait(inner_ty: ty::t,\n-                                 mode: method_lookup_mode,\n-                                 did: ast::def_id,\n-                                 trait_substs: ty::substs) {\n+    fn push_inherent_impl_candidates_for_type(did: def_id)\n+    {\n+        let opt_impl_infos =\n+            self.fcx.ccx.coherence_info.inherent_methods.find(did);\n+        for opt_impl_infos.each |impl_infos| {\n+            for impl_infos.each |impl_info| {\n+                self.push_candidates_from_impl(\n+                    &self.inherent_candidates, impl_info);\n+            }\n+        }\n+    }\n \n-        debug!(\"add_candidates_from_trait\");\n+    fn push_candidates_from_impl(&self, candidates: &DVec<Candidate>,\n+                                 impl_info: &resolve::Impl)\n+    {\n+        if !self.impl_dups.insert(impl_info.did, ()) {\n+            return; // already visited\n+        }\n \n-        let ms = *ty::trait_methods(self.tcx(), did);\n-        for ms.eachi |i, m| {\n-            if m.ident != self.m_name { loop; }\n+        let idx = {\n+            // FIXME #3453 can't use impl_info.methods.position\n+            match vec::position(impl_info.methods,\n+                                |m| m.ident == self.m_name) {\n+                Some(idx) => idx,\n+                None => { return; } // No method with the right name.\n+            }\n+        };\n \n-            let m_fty = ty::mk_fn(self.tcx(), m.fty);\n+        let tcx = self.tcx();\n+        let method = &impl_info.methods[idx];\n \n-            if ty::type_has_self(m_fty) {\n-                self.tcx().sess.span_err(\n-                    self.expr.span,\n-                    ~\"cannot call a method whose type contains a \\\n-                     self-type through a boxed trait\");\n-            }\n+        let need_rp = match method.self_type {\n+            ast::sty_region(_) => true,\n+            _ => false\n+        };\n \n-            if (*m.tps).len() > 0u {\n-                self.tcx().sess.span_err(\n-                    self.expr.span,\n-                    ~\"cannot call a generic method through a \\\n-                     boxed trait\");\n-            }\n+        // determine the `self` of the impl with fresh\n+        // variables for each parameter:\n+        let {substs: impl_substs, ty: impl_ty} =\n+            impl_self_ty(self.fcx, self.self_expr, impl_info.did, need_rp);\n \n-            // Note: although it is illegal to invoke a method that uses self\n-            // through a trait instance, we use a dummy subst here so that we\n-            // can soldier on with the compilation.\n-            let substs = {self_ty: Some(self.self_ty),\n-                          .. trait_substs};\n+        let impl_ty = transform_self_type_for_method(\n+            tcx, impl_substs.self_r, impl_ty, method.self_type);\n+\n+        candidates.push(Candidate {\n+            rcvr_ty: impl_ty,\n+            rcvr_substs: move impl_substs,\n+            num_method_tps: method.n_tps,\n+            self_mode: get_mode_from_self_type(method.self_type),\n+            origin: method_static(method.did)\n+        });\n+    }\n \n-            self.add_candidates_from_m(\n-                inner_ty, mode, substs, m, method_trait(did, i));\n+    // ______________________________________________________________________\n+    // Candidate selection (see comment at start of file)\n+\n+    fn search_for_autoderefd_method(\n+        &self,\n+        self_ty: ty::t,\n+        autoderefs: uint)\n+        -> Option<method_map_entry>\n+    {\n+        match self.search_for_method(self_ty) {\n+            None => None,\n+            Some(move mme) => {\n+                self.fcx.write_autoderef_adjustment(\n+                    self.self_expr.id, autoderefs);\n+                Some(mme)\n+            }\n         }\n     }\n \n-    fn add_candidates_from_class(inner_ty: ty::t,\n-                                 mode: method_lookup_mode,\n-                                 did: ast::def_id,\n-                                 class_substs: ty::substs) {\n-\n-        debug!(\"add_candidates_from_class\");\n+    fn search_for_appr_autorefd_method(\n+        &self,\n+        self_ty: ty::t,\n+        autoderefs: uint)\n+        -> Option<method_map_entry>\n+    {\n+        let tcx = self.tcx();\n \n-        let ms = *ty::trait_methods(self.tcx(), did);\n+        // Next, try auto-ref. The precise kind of auto-ref depends on\n+        // the fully deref'd receiver type.  In particular, we must\n+        // treat dynamically sized types like `str`, `[]` or `fn`\n+        // differently than other types because they cannot be fully\n+        // deref'd, unlike say @T.\n+        match ty::get(self_ty).sty {\n+            ty_box(*) | ty_uniq(*) | ty_rptr(*) => {\n+                // we should be fully autoderef'd\n+                self.bug(fmt!(\"Receiver type %s should be fully \\\n+                               autoderef'd by this point\",\n+                              self.ty_to_str(self_ty)));\n+            }\n \n-        for ms.each |m| {\n-            if m.ident != self.m_name { loop; }\n+            ty_infer(IntVar(_)) | // FIXME(#3211)---should be resolved\n+            ty_self | ty_param(*) | ty_nil | ty_bot | ty_bool |\n+            ty_int(*) | ty_uint(*) |\n+            ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_rec(*) |\n+            ty_class(*) | ty_tup(*) => {\n+                return self.search_for_autorefd_method(\n+                    AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n+                    |m,r| ty::mk_rptr(tcx, r, {ty:self_ty, mutbl:m}));\n+            }\n \n-            if m.vis == ast::private && !self.include_private {\n-                self.tcx().sess.span_fatal(\n-                    self.expr.span,\n-                    ~\"call to private method not allowed outside \\\n-                     its defining class\");\n+            ty_trait(*) | ty_fn(*) => {\n+                // NDM---eventually these should be some variant of autoref\n+                return None;\n             }\n \n-            // look up method named <name>.\n-            let m_declared = ty::lookup_class_method_by_name(\n-                self.tcx(), did, self.m_name, self.expr.span);\n+            ty_estr(vstore_slice(_)) |\n+            ty_evec(_, vstore_slice(_)) => {\n+                return None;\n+            }\n \n-            self.add_candidates_from_m(\n-                inner_ty, mode, class_substs, m, method_static(m_declared));\n-        }\n-    }\n+            ty_evec(mt, vstore_box) |\n+            ty_evec(mt, vstore_uniq) |\n+            ty_evec(mt, vstore_fixed(_)) => {\n+                return self.search_for_autorefd_method(\n+                    AutoSlice, autoderefs, [m_const, m_imm, m_mutbl],\n+                    |m,r| ty::mk_evec(tcx,\n+                                      {ty:mt.ty, mutbl:m},\n+                                      vstore_slice(r)));\n+            }\n \n-    fn ty_from_did(did: ast::def_id) -> ty::t {\n-        match ty::get(ty::lookup_item_type(self.tcx(), did).ty).sty {\n-            ty::ty_fn(ref fty) => {\n-                ty::mk_fn(self.tcx(), FnTyBase {\n-                    meta: FnMeta {proto: ty::proto_vstore(ty::vstore_box),\n-                                  ..fty.meta},\n-                    sig: fty.sig\n-                })\n-          }\n-          _ => fail ~\"ty_from_did: not function ty\"\n-        }\n-        /*\n-        if did.crate == ast::local_crate {\n-            match check self.tcx().items.get(did.node) {\n-              ast_map::node_method(m, _, _) {\n-                // NDM trait/impl regions\n-                let mt = ty_of_method(self.fcx.ccx, m, ast::rp_none);\n-                ty::mk_fn(self.tcx(), {proto: ast::proto_box with mt.fty})\n-              }\n+            ty_estr(vstore_box) |\n+            ty_estr(vstore_uniq) |\n+            ty_estr(vstore_fixed(_)) => {\n+                return self.search_for_autorefd_method(\n+                    AutoSlice, autoderefs, [m_imm],\n+                    |_m,r| ty::mk_estr(tcx, vstore_slice(r)));\n             }\n-        } else {\n-            match check ty::get(csearch::get_type(self.tcx(), did).ty)\n-              .sty {\n \n-              ty::ty_fn(fty) {\n-                ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n-              }\n+            ty_opaque_closure_ptr(_) | ty_unboxed_vec(_) |\n+            ty_opaque_box | ty_type | ty_infer(TyVar(_)) => {\n+                self.bug(fmt!(\"Unexpected type: %s\",\n+                              self.ty_to_str(self_ty)));\n             }\n         }\n-        */\n     }\n \n-    fn check_type_match(impl_ty: ty::t,\n-                        mode: method_lookup_mode)\n-        -> Result<(), ty::type_err> {\n-        // Depending on our argument, we find potential matches by\n-        // checking subtypability, type assignability, or reference\n-        // subtypability. Collect the matches.\n-        match mode {\n-            subtyping_mode => self.fcx.can_mk_subty(self.self_ty, impl_ty),\n-            assignability_mode => self.fcx.can_mk_assignty(self.self_ty,\n-                                                           impl_ty),\n-            immutable_reference_mode => {\n-                let region = self.fcx.infcx().next_region_var(\n-                    self.self_expr.span,\n-                    self.self_expr.id);\n-                let tm = { ty: self.self_ty, mutbl: ast::m_imm };\n-                let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n-                self.fcx.can_mk_subty(ref_ty, impl_ty)\n-            }\n-            mutable_reference_mode => {\n-                let region = self.fcx.infcx().next_region_var(\n-                    self.self_expr.span,\n-                    self.self_expr.id);\n-                let tm = { ty: self.self_ty, mutbl: ast::m_mutbl };\n-                let ref_ty = ty::mk_rptr(self.tcx(), region, tm);\n-                self.fcx.can_mk_subty(ref_ty, impl_ty)\n+    fn search_for_autorefd_method(\n+        &self,\n+        kind: AutoRefKind,\n+        autoderefs: uint,\n+        mutbls: &[ast::mutability],\n+        mk_autoref_ty: &fn(ast::mutability, ty::region) -> ty::t)\n+        -> Option<method_map_entry>\n+    {\n+        // This is hokey. We should have mutability inference as a\n+        // variable.  But for now, try &const, then &, then &mut:\n+        let region = self.infcx().next_region_var(self.expr.span,\n+                                                  self.expr.id);\n+        for mutbls.each |mutbl| {\n+            let autoref_ty = mk_autoref_ty(mutbl, region);\n+            match self.search_for_method(autoref_ty) {\n+                None => {}\n+                Some(move mme) => {\n+                    self.fcx.write_adjustment(\n+                        self.self_expr.id,\n+                        @{autoderefs: autoderefs,\n+                          autoref: Some({kind: kind,\n+                                         region: region,\n+                                         mutbl: mutbl})});\n+                    return Some(mme);\n+                }\n             }\n         }\n+        return None;\n     }\n \n-    // Returns true if any were added and false otherwise.\n-    fn add_candidates_from_impl(im: @resolve::Impl, mode: method_lookup_mode)\n-                             -> bool {\n-        let mut added_any = false;\n-\n-        // Check whether this impl has a method with the right name.\n-        for im.methods.find(|m| m.ident == self.m_name).each |m| {\n-\n-            let need_rp = match m.self_type { ast::sty_region(_) => true,\n-                                              _ => false };\n-\n-            // determine the `self` of the impl with fresh\n-            // variables for each parameter:\n-            let {substs: impl_substs, ty: impl_ty} =\n-                impl_self_ty(self.fcx, self.self_expr, im.did, need_rp);\n-\n-            let impl_ty = transform_self_type_for_method(\n-                self.tcx(), impl_substs.self_r,\n-                impl_ty, m.self_type);\n-\n-            let matches = self.check_type_match(impl_ty, mode);\n-            debug!(\"matches = %?\", matches);\n-            match matches {\n-              result::Err(_) => { /* keep looking */ }\n-              result::Ok(_) => {\n-                if !self.candidate_impls.contains_key(im.did) {\n-                    let fty = self.ty_from_did(m.did);\n-                    self.candidates.push(\n-                        {self_ty: self.self_ty,\n-                         self_substs: impl_substs,\n-                         rcvr_ty: impl_ty,\n-                         n_tps_m: m.n_tps,\n-                         fty: fty,\n-                         entry: {derefs: self.derefs,\n-                                 self_mode: get_mode_from_self_type(\n-                                     m.self_type),\n-                                 origin: method_static(m.did)},\n-                         mode: mode});\n-                    self.candidate_impls.insert(im.did, ());\n-                    added_any = true;\n-                }\n-              }\n+    fn search_for_method(&self,\n+                         self_ty: ty::t)\n+        -> Option<method_map_entry>\n+    {\n+        debug!(\"search_for_method(self_ty=%s)\", self.ty_to_str(self_ty));\n+        let _indenter = indenter();\n+\n+        // I am not sure that inherent methods should have higher\n+        // priority, but it is necessary ATM to handle some of the\n+        // existing code.\n+\n+        debug!(\"searching inherent candidates\");\n+        match self.consider_candidates(self_ty, &self.inherent_candidates) {\n+            None => {}\n+            Some(move mme) => {\n+                return Some(move mme);\n             }\n         }\n \n-        return added_any;\n+        debug!(\"searching extension candidates\");\n+        match self.consider_candidates(self_ty, &self.extension_candidates) {\n+            None => {\n+                return None;\n+            }\n+            Some(move mme) => {\n+                return Some(move mme);\n+            }\n+        }\n     }\n \n-    fn add_candidates_from_m(inner_ty: ty::t,\n-                             mode: method_lookup_mode,\n-                             self_substs: ty::substs,\n-                             m: ty::method,\n-                             origin: method_origin) {\n-        let tcx = self.fcx.ccx.tcx;\n-\n-        // If we don't have a self region but have an region pointer\n-        // explicit self, we need to make up a new region.\n-        let self_r = match self_substs.self_r {\n-          None => {\n-            match m.self_ty {\n-              ast::sty_region(_) =>\n-                  Some(self.fcx.infcx().next_region_var(\n-                      self.self_expr.span,\n-                      self.self_expr.id)),\n-              _ => None\n-            }\n-          }\n-          Some(_) => self_substs.self_r\n-        };\n-        let self_substs = {self_r: self_r,.. self_substs};\n-\n-        // Before we can be sure we succeeded we need to match the\n-        // self type against the impl type that we get when we apply\n-        // the explicit self parameter to whatever inner type we are\n-        // looking at (which may be something that the self_type\n-        // points to).\n-        let impl_ty = transform_self_type_for_method(\n-            self.tcx(), self_substs.self_r,\n-            inner_ty, m.self_ty);\n-\n-        let matches = self.check_type_match(impl_ty, mode);\n-        debug!(\"matches = %?\", matches);\n-        if matches.is_err() { return; }\n-\n-        // a bit hokey, but the method unbound has a bare protocol, whereas\n-        // a.b has a protocol like fn@() (perhaps eventually fn&()):\n-        let fty = ty::mk_fn(tcx, FnTyBase {\n-            meta: FnMeta {proto: ty::proto_vstore(ty::vstore_box),\n-                          ..m.fty.meta},\n-            sig: m.fty.sig\n-        });\n-\n-        self.candidates.push(\n-            {self_ty: self.self_ty,\n-             self_substs: self_substs,\n-             rcvr_ty: self.self_ty,\n-             n_tps_m: (*m.tps).len(),\n-             fty: fty,\n-             entry: {derefs: self.derefs,\n-                     self_mode: get_mode_from_self_type(m.self_ty),\n-                     origin: origin},\n-             mode: mode});\n-    }\n+    fn consider_candidates(&self,\n+                           self_ty: ty::t,\n+                           candidates: &DVec<Candidate>)\n+        -> Option<method_map_entry>\n+    {\n+        let relevant_candidates =\n+            candidates.filter_to_vec(|c| self.is_relevant(self_ty, &c));\n \n-    fn add_inherent_and_extension_candidates(optional_inherent_methods:\n-                                                Option<@DVec<@Impl>>,\n-                                             mode: method_lookup_mode) {\n-\n-        // Add inherent methods.\n-        match optional_inherent_methods {\n-          None => {\n-            // Continue.\n-          }\n-          Some(inherent_methods) => {\n-            debug!(\"(adding inherent and extension candidates) adding \\\n-                    inherent candidates\");\n-            for inherent_methods.each |implementation| {\n-                debug!(\"(adding inherent and extension candidates) \\\n-                        adding candidates from impl: %s\",\n-                        node_id_to_str(self.tcx().items,\n-                                       implementation.did.node,\n-                                       self.fcx.tcx().sess.parse_sess\n-                                           .interner));\n-                self.add_candidates_from_impl(implementation, mode);\n-            }\n-          }\n+        if relevant_candidates.len() == 0 {\n+            return None;\n         }\n \n-        // Add trait methods.\n-        match self.fcx.ccx.trait_map.find(self.expr.id) {\n-          None => {\n-            // Should only happen for placement new right now.\n-          }\n-          Some(trait_ids) => {\n-            for (*trait_ids).each |trait_id| {\n-                debug!(\"(adding inherent and extension candidates) \\\n-                        trying trait: %s\",\n-                        self.def_id_to_str(trait_id));\n-\n-                let coherence_info = self.fcx.ccx.coherence_info;\n-                match coherence_info.extension_methods.find(trait_id) {\n-                  None => {\n-                    // Do nothing.\n-                  }\n-                  Some(extension_methods) => {\n-                    for extension_methods.each |implementation| {\n-                        debug!(\"(adding inherent and extension \\\n-                                candidates) adding impl %s\",\n-                                self.def_id_to_str\n-                                (implementation.did));\n-                        self.add_candidates_from_impl(implementation, mode);\n-                    }\n-                  }\n-                }\n+        if relevant_candidates.len() > 1 {\n+            self.tcx().sess.span_err(\n+                self.expr.span,\n+                ~\"multiple applicable methods in scope\");\n+            for uint::range(0, relevant_candidates.len()) |idx| {\n+                self.report_candidate(idx, &relevant_candidates[idx].origin);\n             }\n-          }\n         }\n-    }\n \n-    fn def_id_to_str(def_id: ast::def_id) -> ~str {\n-        if def_id.crate == ast::local_crate {\n-            node_id_to_str(self.tcx().items, def_id.node,\n-                           self.fcx.tcx().sess.parse_sess.interner)\n-        } else {\n-            ast_map::path_to_str(csearch::get_item_path(self.tcx(), def_id),\n-                                 self.fcx.tcx().sess.parse_sess.interner)\n-        }\n+        Some(self.confirm_candidate(self_ty, &relevant_candidates[0]))\n     }\n \n-    fn write_mty_from_candidate(cand: candidate) -> method_map_entry {\n-        let tcx = self.fcx.ccx.tcx;\n-\n-        debug!(\"write_mty_from_candidate(n_tps_m=%u, fty=%s, entry=%?)\",\n-               cand.n_tps_m,\n-               self.fcx.infcx().ty_to_str(cand.fty),\n-               cand.entry);\n-\n-        match cand.mode {\n-            subtyping_mode | assignability_mode => {\n-                // Make the actual receiver type (cand.self_ty) assignable to\n-                // the required receiver type (cand.rcvr_ty).  If this method\n-                // is not from an impl, this'll basically be a no-nop.\n-                match self.fcx.mk_assignty(self.self_expr, self.borrow_lb,\n-                                           cand.self_ty, cand.rcvr_ty) {\n-                  result::Ok(_) => (),\n-                  result::Err(_) => {\n-                    self.tcx().sess.span_bug(\n-                        self.expr.span,\n-                        fmt!(\"%s was assignable to %s but now is not?\",\n-                             self.fcx.infcx().ty_to_str(cand.self_ty),\n-                             self.fcx.infcx().ty_to_str(cand.rcvr_ty)));\n-                  }\n-                }\n-            }\n-            immutable_reference_mode => {\n-                // Borrow as an immutable reference.\n-                self.add_borrow(ast::m_imm);\n-            }\n-            mutable_reference_mode => {\n-                // Borrow as a mutable reference.\n-                self.add_borrow(ast::m_mutbl);\n+    fn confirm_candidate(&self,\n+                         self_ty: ty::t,\n+                         candidate: &Candidate)\n+        -> method_map_entry\n+    {\n+        let tcx = self.tcx();\n+        let fty = self.fn_ty_from_origin(&candidate.origin);\n+\n+        self.enforce_trait_instance_limitations(fty, candidate);\n+\n+        // before we only checked whether self_ty could be a subtype\n+        // of rcvr_ty; now we actually make it so (this may cause\n+        // variables to unify etc).  Since we checked beforehand, and\n+        // nothing has changed in the meantime, this unification\n+        // should never fail.\n+        match self.fcx.mk_subty(false, self.self_expr.span,\n+                                self_ty, candidate.rcvr_ty) {\n+            result::Ok(_) => (),\n+            result::Err(_) => {\n+                self.bug(fmt!(\"%s was assignable to %s but now is not?\",\n+                              self.ty_to_str(self_ty),\n+                              self.ty_to_str(candidate.rcvr_ty)));\n             }\n         }\n \n-        // Construct the full set of type parameters for the method,\n-        // which is equal to the class tps + the method tps.\n-        let n_tps_supplied = self.supplied_tps.len();\n-        let n_tps_m = cand.n_tps_m;\n+        // Determine the values for the type parameters of the method.\n+        // If they were not explicitly supplied, just construct fresh\n+        // type variables.\n+        let num_supplied_tps = self.supplied_tps.len();\n         let m_substs = {\n-            if n_tps_supplied == 0u {\n-                self.fcx.infcx().next_ty_vars(n_tps_m)\n-            } else if n_tps_m == 0u {\n+            if num_supplied_tps == 0u {\n+                self.fcx.infcx().next_ty_vars(candidate.num_method_tps)\n+            } else if candidate.num_method_tps == 0u {\n                 tcx.sess.span_err(\n                     self.expr.span,\n                     ~\"this method does not take type parameters\");\n-                self.fcx.infcx().next_ty_vars(n_tps_m)\n-            } else if n_tps_supplied != n_tps_m {\n+                self.fcx.infcx().next_ty_vars(candidate.num_method_tps)\n+            } else if num_supplied_tps != candidate.num_method_tps {\n                 tcx.sess.span_err(\n                     self.expr.span,\n                     ~\"incorrect number of type \\\n                      parameters given for this method\");\n-                self.fcx.infcx().next_ty_vars(n_tps_m)\n+                self.fcx.infcx().next_ty_vars(candidate.num_method_tps)\n             } else {\n-                self.supplied_tps\n+                self.supplied_tps.to_vec()\n+            }\n+        };\n+\n+        // Construct the full set of type parameters for the method,\n+        // which is equal to the class tps + the method tps.\n+        let all_substs = {tps: vec::append(candidate.rcvr_substs.tps,\n+                                           m_substs),\n+                          ..candidate.rcvr_substs};\n+\n+        self.fcx.write_ty_substs(self.callee_id, fty, all_substs);\n+        return {self_arg: {mode: ast::expl(candidate.self_mode),\n+                           ty: candidate.rcvr_ty},\n+                origin: candidate.origin};\n+    }\n+\n+    fn enforce_trait_instance_limitations(&self,\n+                                          method_fty: ty::t,\n+                                          candidate: &Candidate)\n+    {\n+        /*!\n+         *\n+         * There are some limitations to calling functions through a\n+         * traint instance, because (a) the self type is not known\n+         * (that's the whole point of a trait instance, after all, to\n+         * obscure the self type) and (b) the call must go through a\n+         * vtable and hence cannot be monomorphized. */\n+\n+        match candidate.origin {\n+            method_static(*) | method_param(*) => {\n+                return; // not a call to a trait instance\n+            }\n+            method_trait(*) => {}\n+        }\n+\n+        if ty::type_has_self(method_fty) {\n+            self.tcx().sess.span_err(\n+                self.expr.span,\n+                ~\"cannot call a method whose type contains a \\\n+                  self-type through a boxed trait\");\n+        }\n+\n+        if candidate.num_method_tps > 0 {\n+            self.tcx().sess.span_err(\n+                self.expr.span,\n+                ~\"cannot call a generic method through a boxed trait\");\n+        }\n+    }\n+\n+    fn is_relevant(&self, self_ty: ty::t, candidate: &Candidate) -> bool {\n+        self.fcx.can_mk_subty(self_ty, candidate.rcvr_ty).is_ok()\n+    }\n+\n+    fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n+        return match *origin {\n+            method_static(did) => {\n+                ty::lookup_item_type(self.tcx(), did).ty\n+            }\n+            method_param(ref mp) => {\n+                type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n+            }\n+            method_trait(did, idx) => {\n+                type_of_trait_method(self.tcx(), did, idx)\n+            }\n+        };\n+\n+        fn type_of_trait_method(tcx: ty::ctxt,\n+                                trait_did: def_id,\n+                                method_num: uint) -> ty::t {\n+            let trait_methods = ty::trait_methods(tcx, trait_did);\n+            ty::mk_fn(tcx, trait_methods[method_num].fty)\n+        }\n+    }\n+\n+    fn report_candidate(idx: uint, origin: &method_origin) {\n+        match *origin {\n+            method_static(impl_did) => {\n+                self.report_static_candidate(idx, impl_did)\n+            }\n+            method_param(mp) => {\n+                self.report_param_candidate(idx, mp.trait_id)\n+            }\n+            method_trait(trait_did, _) => {\n+                self.report_param_candidate(idx, trait_did)\n+            }\n+        }\n+    }\n+\n+    fn report_static_candidate(idx: uint, did: def_id) {\n+        let span = if did.crate == ast::local_crate {\n+            match self.tcx().items.get(did.node) {\n+              ast_map::node_method(m, _, _) => m.span,\n+              _ => fail ~\"report_static_candidate: bad item\"\n             }\n+        } else {\n+            self.expr.span\n         };\n+        self.tcx().sess.span_note(\n+            span,\n+            fmt!(\"candidate #%u is `%s`\",\n+                 (idx+1u),\n+                 ty::item_path_str(self.tcx(), did)));\n+    }\n \n-        let all_substs = {tps: vec::append(cand.self_substs.tps, m_substs),\n-                          .. cand.self_substs};\n+    fn report_param_candidate(idx: uint, did: def_id) {\n+        self.tcx().sess.span_note(\n+            self.expr.span,\n+            fmt!(\"candidate #%u derives from the bound `%s`\",\n+                 (idx+1u),\n+                 ty::item_path_str(self.tcx(), did)));\n+    }\n \n-        self.fcx.write_ty_substs(self.node_id, cand.fty, all_substs);\n+    fn report_trait_candidate(idx: uint, did: def_id) {\n+        self.tcx().sess.span_note(\n+            self.expr.span,\n+            fmt!(\"candidate #%u derives from the type of the receiver, \\\n+                  which is the trait `%s`\",\n+                 (idx+1u),\n+                 ty::item_path_str(self.tcx(), did)));\n+    }\n+\n+    fn infcx() -> infer::infer_ctxt {\n+        self.fcx.inh.infcx\n+    }\n+\n+    fn tcx() -> ty::ctxt {\n+        self.fcx.tcx()\n+    }\n+\n+    fn ty_to_str(t: ty::t) -> ~str {\n+        self.fcx.infcx().ty_to_str(t)\n+    }\n \n-        return cand.entry;\n+    fn did_to_str(did: def_id) -> ~str {\n+        ty::item_path_str(self.tcx(), did)\n     }\n \n-    fn add_borrow(mutbl: ast::mutability) {\n-        let region_var = self.fcx.infcx().next_region_var(\n-            self.self_expr.span,\n-            self.self_expr.id);\n-        self.fcx.inh.borrowings.insert(self.self_expr.id, {region: region_var,\n-                                                           mutbl: mutbl});\n+    fn bug(s: ~str) -> ! {\n+        self.tcx().sess.bug(s)\n     }\n }\n \n+fn transform_self_type_for_method(tcx: ty::ctxt,\n+                                  self_region: Option<ty::region>,\n+                                  impl_ty: ty::t,\n+                                  self_type: ast::self_ty_)\n+    -> ty::t\n+{\n+    match self_type {\n+      sty_static => {\n+        tcx.sess.bug(~\"calling transform_self_type_for_method on \\\n+                       static method\");\n+      }\n+      sty_by_ref | sty_value => {\n+        impl_ty\n+      }\n+      sty_region(mutability) => {\n+        mk_rptr(tcx,\n+                self_region.expect(~\"self region missing for &self param\"),\n+                { ty: impl_ty, mutbl: mutability })\n+      }\n+      sty_box(mutability) => {\n+        mk_box(tcx, { ty: impl_ty, mutbl: mutability })\n+      }\n+      sty_uniq(mutability) => {\n+        mk_uniq(tcx, { ty: impl_ty, mutbl: mutability })\n+      }\n+    }\n+}\n+\n+fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n+    match self_type { sty_value => by_copy, _ => by_ref }\n+}"}, {"sha": "d5c6be4116aa81d860c1d0af8b7f4294bb56a40f", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 169, "deletions": 93, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -155,126 +155,169 @@ fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n \n-fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n+fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\",\n-           pprust::expr_to_str(e, rcx.fcx.tcx().sess.intr()));\n-\n-    match e.node {\n-      ast::expr_path(*) => {\n-        // Avoid checking the use of local variables, as we already\n-        // check their definitions.  The def'n always encloses the\n-        // use.  So if the def'n is enclosed by the region, then the\n-        // uses will also be enclosed (and otherwise, an error will\n-        // have been reported at the def'n site).\n-        match lookup_def(rcx.fcx, e.span, e.id) {\n-          ast::def_local(*) | ast::def_arg(*) | ast::def_upvar(*) => return,\n-          _ => ()\n-        }\n-      }\n-\n-      ast::expr_cast(source, _) => {\n-        // Determine if we are casting `source` to an trait instance.\n-        // If so, we have to be sure that the type of the source obeys\n-        // the trait's region bound.\n-        //\n-        // Note: there is a subtle point here concerning type\n-        // parameters.  It is possible that the type of `source`\n-        // contains type parameters, which in turn may contain regions\n-        // that are not visible to us (only the caller knows about\n-        // them).  The kind checker is ultimately responsible for\n-        // guaranteeing region safety in that particular case.  There\n-        // is an extensive comment on the function\n-        // check_cast_for_escaping_regions() in kind.rs explaining how\n-        // it goes about doing that.\n-        match rcx.resolve_node_type(e.id) {\n-          result::Err(_) => { return; /* typeck will fail anyhow */ }\n-          result::Ok(target_ty) => {\n-            match ty::get(target_ty).sty {\n-              ty::ty_trait(_, substs, _) => {\n-                let trait_region = match substs.self_r {\n-                  Some(r) => {r}\n-                  None => {ty::re_static}\n-                };\n-                let source_ty = rcx.fcx.expr_ty(source);\n-                constrain_regions_in_type(rcx, trait_region,\n-                                          e.span, source_ty);\n-              }\n-              _ => ()\n+           pprust::expr_to_str(expr, rcx.fcx.tcx().sess.intr()));\n+\n+    // constrain_auto_ref(rcx, expr);\n+\n+    match expr.node {\n+        ast::expr_path(*) => {\n+            // Avoid checking the use of local variables, as we\n+            // already check their definitions.  The def'n always\n+            // encloses the use.  So if the def'n is enclosed by the\n+            // region, then the uses will also be enclosed (and\n+            // otherwise, an error will have been reported at the\n+            // def'n site).\n+            match lookup_def(rcx.fcx, expr.span, expr.id) {\n+                ast::def_local(*) | ast::def_arg(*) |\n+                ast::def_upvar(*) => return,\n+                _ => ()\n             }\n-          }\n-        };\n-      }\n-\n-      ast::expr_addr_of(*) => {\n-        // FIXME(#3148) -- in some cases, we need to capture a dependency\n-        // between the regions found in operand the resulting region type.\n-        // See #3148 for more details.\n-      }\n-\n-      ast::expr_fn(*) | ast::expr_fn_block(*) => {\n-        match rcx.resolve_node_type(e.id) {\n-          result::Err(_) => return,   // Typechecking will fail anyhow.\n-          result::Ok(function_type) => {\n-            match ty::get(function_type).sty {\n-              ty::ty_fn(ref fn_ty) => {\n-                  match fn_ty.meta.proto {\n-                      proto_vstore(vstore_slice(region)) => {\n-                          constrain_free_variables(rcx, region, e);\n-                      }\n-                      _ => {}\n-                  }\n-              }\n-              _ => ()\n+        }\n+\n+        ast::expr_cast(source, _) => {\n+            // Determine if we are casting `source` to an trait\n+            // instance.  If so, we have to be sure that the type of\n+            // the source obeys the trait's region bound.\n+            //\n+            // Note: there is a subtle point here concerning type\n+            // parameters.  It is possible that the type of `source`\n+            // contains type parameters, which in turn may contain\n+            // regions that are not visible to us (only the caller\n+            // knows about them).  The kind checker is ultimately\n+            // responsible for guaranteeing region safety in that\n+            // particular case.  There is an extensive comment on the\n+            // function check_cast_for_escaping_regions() in kind.rs\n+            // explaining how it goes about doing that.\n+            match rcx.resolve_node_type(expr.id) {\n+                result::Err(_) => { return; /*typeck will fail anyhow*/ }\n+                result::Ok(target_ty) => {\n+                    match ty::get(target_ty).sty {\n+                        ty::ty_trait(_, substs, _) => {\n+                            let trait_region = match substs.self_r {\n+                                Some(r) => {r}\n+                                None => {ty::re_static}\n+                            };\n+                            let source_ty = rcx.fcx.expr_ty(source);\n+                            constrain_regions_in_type(rcx, trait_region,\n+                                                      expr.span, source_ty);\n+                        }\n+                        _ => ()\n+                    }\n+                }\n+            };\n+        }\n+\n+        ast::expr_addr_of(*) => {\n+            // FIXME(#3148) -- in some cases, we need to capture a\n+            // dependency between the regions found in operand the\n+            // resulting region type.  See #3148 for more details.\n+        }\n+\n+        ast::expr_fn(*) | ast::expr_fn_block(*) => {\n+            match rcx.resolve_node_type(expr.id) {\n+                result::Err(_) => return, // Typechecking will fail anyhow.\n+                result::Ok(function_type) => {\n+                    match ty::get(function_type).sty {\n+                        ty::ty_fn(ref fn_ty) => {\n+                            match fn_ty.meta.proto {\n+                                proto_vstore(vstore_slice(region)) => {\n+                                    constrain_free_variables(rcx, region,\n+                                                             expr);\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                        _ => ()\n+                    }\n+                }\n             }\n-          }\n         }\n-      }\n \n-      _ => ()\n+        _ => ()\n     }\n \n-    if !visit_node(e.id, e.span, rcx) { return; }\n-    visit::visit_expr(e, rcx, v);\n+    if !visit_node(expr.id, expr.span, rcx) { return; }\n+    visit::visit_expr(expr, rcx, v);\n }\n \n fn visit_stmt(s: @ast::stmt, &&rcx: @rcx, v: rvt) {\n     visit::visit_stmt(s, rcx, v);\n }\n \n-// checks the type of the node `id` and reports an error if it\n-// references a region that is not in scope for that node.  Returns\n-// false if an error is reported; this is used to cause us to cut off\n-// region checking for that subtree to avoid reporting tons of errors.\n fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n-    let fcx = rcx.fcx;\n+    /*!\n+     *\n+     * checks the type of the node `id` and reports an error if it\n+     * references a region that is not in scope for that node.\n+     * Returns false if an error is reported; this is used to cause us\n+     * to cut off region checking for that subtree to avoid reporting\n+     * tons of errors. */\n \n-    // Try to resolve the type.  If we encounter an error, then typeck\n-    // is going to fail anyway, so just stop here and let typeck\n-    // report errors later on in the writeback phase.\n-    let ty = match rcx.resolve_node_type(id) {\n-      result::Err(_) => return true,\n-      result::Ok(ty) => ty\n-    };\n+    let fcx = rcx.fcx;\n \n     // find the region where this expr evaluation is taking place\n     let tcx = fcx.ccx.tcx;\n     let encl_region = ty::encl_region(tcx, id);\n \n-    debug!(\"visit_node(ty=%s, id=%d, encl_region=%?)\",\n-           ty_to_str(tcx, ty), id, encl_region);\n-\n     // Otherwise, look at the type and see if it is a region pointer.\n-    return constrain_regions_in_type(rcx, encl_region, span, ty);\n+    constrain_regions_in_type_of_node(rcx, id, encl_region, span)\n+}\n+\n+fn constrain_auto_ref(\n+    rcx: @rcx,\n+    expr: @ast::expr)\n+{\n+    /*!\n+     *\n+     * If `expr` is auto-ref'd (e.g., as part of a borrow), then this\n+     * function ensures that the lifetime of the resulting borrowed\n+     * ptr includes at least the expression `expr`. */\n+\n+    let adjustment = rcx.fcx.inh.adjustments.find(expr.id);\n+    let region = match adjustment {\n+        Some(@{autoref: Some(ref auto_ref), _}) => auto_ref.region,\n+        _ => { return; }\n+    };\n+\n+    let tcx = rcx.fcx.tcx();\n+    let expr_region = ty::re_scope(expr.id);\n+    match rcx.fcx.mk_subr(true, expr.span, expr_region, region) {\n+        result::Ok(()) => {}\n+        result::Err(_) => {\n+            // In practice, this cannot happen: `region` is always a\n+            // region variable, and constraints on region variables\n+            // are collected and then resolved later.  However, I\n+            // included the span_err() here (rather than, say,\n+            // span_bug()) because it seemed more future-proof: if,\n+            // for some reason, the code were to change so that in\n+            // some cases `region` is not a region variable, then\n+            // reporting an error would be the correct path.\n+            tcx.sess.span_err(\n+                expr.span,\n+                ~\"lifetime of borrowed pointer does not include \\\n+                  the expression being borrowed\");\n+            note_and_explain_region(\n+                tcx,\n+                ~\"lifetime of the borrowed pointer is\",\n+                region,\n+                ~\"\");\n+            rcx.errors_reported += 1;\n+        }\n+    }\n }\n \n fn constrain_free_variables(\n     rcx: @rcx,\n     region: ty::region,\n     expr: @ast::expr)\n {\n-    // Make sure that all regions referenced by the free\n-    // variables inside the closure outlive the closure\n-    // itself.\n+    /*!\n+     *\n+     * Make sure that all free variables referenced inside the closure\n+     * outlive the closure itself. */\n+\n     let tcx = rcx.fcx.ccx.tcx;\n     for get_freevars(tcx, expr.id).each |freevar| {\n         debug!(\"freevar def is %?\", freevar.def);\n@@ -302,11 +345,44 @@ fn constrain_free_variables(\n     }\n }\n \n+fn constrain_regions_in_type_of_node(\n+    rcx: @rcx,\n+    id: ast::node_id,\n+    encl_region: ty::region,\n+    span: span) -> bool\n+{\n+    let tcx = rcx.fcx.tcx();\n+\n+    // Try to resolve the type.  If we encounter an error, then typeck\n+    // is going to fail anyway, so just stop here and let typeck\n+    // report errors later on in the writeback phase.\n+    let ty = match rcx.resolve_node_type(id) {\n+      result::Err(_) => return true,\n+      result::Ok(ty) => ty\n+    };\n+\n+    debug!(\"constrain_regions_in_type_of_node(\\\n+            ty=%s, id=%d, encl_region=%?)\",\n+           ty_to_str(tcx, ty), id, encl_region);\n+\n+    constrain_regions_in_type(rcx, encl_region, span, ty)\n+}\n+\n fn constrain_regions_in_type(\n     rcx: @rcx,\n     encl_region: ty::region,\n     span: span,\n-    ty: ty::t) -> bool {\n+    ty: ty::t) -> bool\n+{\n+    /*!\n+     *\n+     * Requires that any regions which appear in `ty` must be\n+     * superregions of `encl_region`.  This prevents regions from\n+     * being used outside of the block in which they are valid.\n+     * Recall that regions represent blocks of code or expressions:\n+     * this requirement basically says \"any place that uses or may use\n+     * a region R must be within the block of code that R corresponds\n+     * to.\" */\n \n     let e = rcx.errors_reported;\n     ty::walk_regions_and_ty("}, {"sha": "ccc5e4c1a82f852500ecaf9a3cd59209d1ad34c2", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -4,6 +4,7 @@ use infer::{resolve_type, resolve_and_force_all_but_regions,\n use ast_util::new_def_hash;\n use syntax::print::pprust;\n use result::{Result, Ok, Err};\n+use util::common::indenter;\n \n // vtable resolution looks for places where trait bounds are\n // subsituted in and figures out which vtable is used. There is some\n@@ -410,6 +411,8 @@ fn insert_vtables(ccx: @crate_ctxt, callee_id: ast::node_id,\n fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n+    let _indent = indenter();\n+\n     let cx = fcx.ccx;\n     match ex.node {\n       ast::expr_path(*) => {"}, {"sha": "d57b012503b2084877deb59808bda486d7ac3eee", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -27,30 +27,53 @@ fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t)\n     }\n }\n \n+fn resolve_method_map_entry(fcx: @fn_ctxt, sp: span, id: ast::node_id)\n+{\n+    // Resolve any method map entry\n+    match fcx.ccx.method_map.find(id) {\n+        None => {}\n+        Some(ref mme) => {\n+            for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n+                fcx.ccx.method_map.insert(\n+                    id,\n+                    {self_arg: {mode: mme.self_arg.mode, ty: t},\n+                     ..*mme});\n+            }\n+        }\n+    }\n+}\n+\n fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n     -> Option<ty::t>\n {\n     let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    match fcx.inh.borrowings.find(id) {\n+    match fcx.inh.adjustments.find(id) {\n         None => (),\n-        Some(borrow) => {\n-            match resolve_region(fcx.infcx(), borrow.region,\n-                                 resolve_all | force_all) {\n-                Err(e) => {\n-                    // This should not, I think, happen.\n-                    fcx.ccx.tcx.sess.span_err(\n-                        sp, fmt!(\"cannot resolve scope of borrow: %s\",\n-                                 infer::fixup_err_to_str(e)));\n-                }\n-                Ok(r) => {\n-                    debug!(\"Borrowing node %d -> region %?, mutbl %?\",\n-                           id, r, borrow.mutbl);\n-                    fcx.tcx().borrowings.insert(id, {region: r,\n-                                                     mutbl: borrow.mutbl});\n+        Some(adj) => {\n+            let resolved_autoref = match adj.autoref {\n+                Some(ref autoref) => {\n+                    match resolve_region(fcx.infcx(), autoref.region,\n+                                         resolve_all | force_all) {\n+                        Err(e) => {\n+                            // This should not, I think, happen.\n+                            fcx.ccx.tcx.sess.span_err(\n+                                sp, fmt!(\"cannot resolve scope of borrow: %s\",\n+                                         infer::fixup_err_to_str(e)));\n+                            Some(*autoref)\n+                        }\n+                        Ok(r) => {\n+                            Some({region: r, ..*autoref})\n+                        }\n+                    }\n                 }\n-            }\n+                None => None\n+            };\n+\n+            let resolved_adj = @{autoref: resolved_autoref, ..*adj};\n+            debug!(\"Adjustments for node %d: %?\", id, resolved_adj);\n+            fcx.tcx().adjustments.insert(id, resolved_adj);\n         }\n     }\n \n@@ -109,6 +132,8 @@ fn visit_stmt(s: @ast::stmt, wbcx: wb_ctxt, v: wb_vt) {\n fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n+    resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n+    resolve_method_map_entry(wbcx.fcx, e.span, e.callee_id);\n     match e.node {\n       ast::expr_fn(_, decl, _, _) |\n       ast::expr_fn_block(decl, _, _) => {"}, {"sha": "a0bb828e4122f798304781eee2bb8afdb3bf85bb", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -275,6 +275,7 @@ use unify::{vals_and_bindings, root};\n use integral::{int_ty_set, int_ty_set_all};\n use combine::{combine_fields, eq_tys};\n use assignment::Assign;\n+use to_str::to_str;\n \n use sub::Sub;\n use lub::Lub;\n@@ -304,7 +305,7 @@ type bounds<T:Copy> = {lb: bound<T>, ub: bound<T>};\n type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n type ures = cres<()>; // \"unify result\"\n type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n-type ares = cres<Option<ty::borrow>>; // \"assignment result\"\n+type ares = cres<Option<@ty::AutoAdjustment>>; // \"assignment result\"\n \n enum infer_ctxt = @{\n     tcx: ty::ctxt,\n@@ -469,19 +470,24 @@ impl ures: then {\n     }\n }\n \n-trait cres_helpers<T> {\n+trait ToUres {\n     fn to_ures() -> ures;\n-    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n }\n \n-impl<T:Copy Eq> cres<T>: cres_helpers<T> {\n+impl<T> cres<T>: ToUres {\n     fn to_ures() -> ures {\n         match self {\n           Ok(_v) => Ok(()),\n           Err(e) => Err(e)\n         }\n     }\n+}\n+\n+trait CresCompare<T> {\n+    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n+}\n \n+impl<T:Copy Eq> cres<T>: CresCompare<T> {\n     fn compare(t: T, f: fn() -> ty::type_err) -> cres<T> {\n         do self.chain |s| {\n             if s == t {"}, {"sha": "53731551df57c05c8879e821b581535cb41e1de2", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -134,18 +134,24 @@ priv impl Assign {\n                     (ty::ty_box(_), ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_box(self.infcx.tcx,\n                                               {ty: mt_b.ty, mutbl: m_const});\n-                        self.try_assign(a, nr_b, mt_b.mutbl, r_b)\n+                        self.try_assign(1, ty::AutoPtr,\n+                                        a, nr_b,\n+                                        mt_b.mutbl, r_b)\n                     }\n                     (ty::ty_uniq(_), ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_uniq(self.infcx.tcx,\n                                                {ty: mt_b.ty, mutbl: m_const});\n-                        self.try_assign(a, nr_b, mt_b.mutbl, r_b)\n+                        self.try_assign(1, ty::AutoPtr,\n+                                        a, nr_b,\n+                                        mt_b.mutbl, r_b)\n                     }\n                     (ty::ty_estr(vs_a),\n                      ty::ty_estr(ty::vstore_slice(r_b)))\n                     if is_borrowable(vs_a) => {\n                         let nr_b = ty::mk_estr(self.infcx.tcx, vs_a);\n-                        self.try_assign(a, nr_b, m_imm, r_b)\n+                        self.try_assign(0, ty::AutoSlice,\n+                                        a, nr_b,\n+                                        m_imm, r_b)\n                     }\n \n                     (ty::ty_evec(_, vs_a),\n@@ -154,7 +160,9 @@ priv impl Assign {\n                         let nr_b = ty::mk_evec(self.infcx.tcx,\n                                                {ty: mt_b.ty, mutbl: m_const},\n                                                vs_a);\n-                        self.try_assign(a, nr_b, mt_b.mutbl, r_b)\n+                        self.try_assign(0, ty::AutoSlice,\n+                                        a, nr_b,\n+                                        mt_b.mutbl, r_b)\n                     }\n \n                     _ => {\n@@ -177,7 +185,9 @@ priv impl Assign {\n     /// variable `r_a >= r_b` and returns a corresponding assignment\n     /// record.  See the discussion at the top of this file for more\n     /// details.\n-    fn try_assign(a: ty::t,\n+    fn try_assign(autoderefs: uint,\n+                  kind: ty::AutoRefKind,\n+                  a: ty::t,\n                   nr_b: ty::t,\n                   m: ast::mutability,\n                   r_b: ty::region) -> ares {\n@@ -193,7 +203,14 @@ priv impl Assign {\n             do sub.tys(a, nr_b).chain |_t| {\n                 let r_a = self.infcx.next_region_var_nb(self.span);\n                 do sub.contraregions(r_a, r_b).chain |_r| {\n-                    Ok(Some({region: r_a, mutbl: m}))\n+                    Ok(Some(@{\n+                        autoderefs: autoderefs,\n+                        autoref: Some({\n+                            kind: kind,\n+                            region: r_a,\n+                            mutbl: m\n+                        })\n+                    }))\n                 }\n             }\n         }"}, {"sha": "fce115c1c2a419e66caa79de45ec13996ab802e3", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -18,7 +18,7 @@ use syntax::codemap;\n use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::print::pprust::{path_to_str, proto_to_str,\n-                               mode_to_str, purity_to_str};\n+                            mode_to_str, purity_to_str};\n use syntax::{ast, ast_util};\n use syntax::ast_map;\n use driver::session::session;\n@@ -229,10 +229,15 @@ fn proto_ty_to_str(cx: ctxt, proto: ty::fn_proto) -> ~str {\n     }\n }\n \n+fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n+    fmt!(\"expr(%d: %s)\",\n+         expr.id,\n+         pprust::expr_to_str(expr, cx.sess.intr()))\n+}\n+\n fn tys_to_str(cx: ctxt, ts: ~[t]) -> ~str {\n-    let mut rs = ~\"\";\n-    for ts.each |t| { rs += ty_to_str(cx, t); }\n-    rs\n+    let tstrs = ts.map(|t| ty_to_str(cx, t));\n+    fmt!(\"[%s]\", str::connect(tstrs, \", \"))\n }\n \n fn bound_to_str(cx: ctxt, b: param_bound) -> ~str {"}, {"sha": "24878e36cf33a722acc6a2447cfdd14ad2ee38d9", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -19,4 +19,5 @@ fn cat(in_x : uint, in_y : int) -> cat {\n fn main() {\n   let nyan : cat = cat(52u, 99);\n   nyan.speak = fn@() { debug!(\"meow\"); }; //~ ERROR attempted to take value of method\n+  //~^ ERROR mismatched types\n }"}, {"sha": "c38c5cbbf937859f4e19af80a1ae414ec6bf49fb", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -0,0 +1,19 @@\n+use either::*;\n+enum X = Either<(uint,uint),fn()>;\n+impl &X {\n+    fn with(blk: fn(x: &Either<(uint,uint),fn()>)) {\n+        blk(&**self)\n+    }\n+}\n+fn main() {\n+    let mut x = X(Right(main));\n+    do (&mut x).with |opt| {  //~ ERROR illegal borrow\n+        match *opt {\n+            Right(f) => {\n+                x = X(Left((0,0)));\n+                f()\n+            },\n+            _ => fail\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "14e268e52adf99f71c3e53498dbdcf16287025ff", "filename": "src/test/compile-fail/borrowck-call-method-from-mut-aliasable.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -0,0 +1,31 @@\n+struct Foo {\n+    x: int,\n+}\n+\n+impl Foo {\n+    fn f(&self) {}\n+    fn g(&const self) {}\n+    fn h(&mut self) {}\n+}\n+\n+fn a(x: &mut Foo) {\n+    x.f(); //~ ERROR illegal borrow unless pure\n+    x.g();\n+    x.h();\n+}\n+\n+fn b(x: &Foo) {\n+    x.f();\n+    x.g();\n+    x.h(); //~ ERROR illegal borrow\n+}\n+\n+fn c(x: &const Foo) {\n+    x.f(); //~ ERROR illegal borrow unless pure\n+    x.g();\n+    x.h(); //~ ERROR illegal borrow\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "3cb7009ee270f26aba23779c7062305a504099bf", "filename": "src/test/compile-fail/borrowck-lend-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -5,7 +5,7 @@ fn borrow_from_arg_imm_ref(&&v: ~int) {\n }\n \n fn borrow_from_arg_mut_ref(&v: ~int) {\n-    borrow(v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    borrow(v); //~ ERROR illegal borrow unless pure\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "7fdfbae75a68e35458075f45d19968e5cb66e7e8", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -47,7 +47,7 @@ fn c() {\n \n \n     // ...but not impure fns\n-    (*q).times(3); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    (*q).times(3); //~ ERROR illegal borrow unless pure\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "7111600d186f757bb5e37868a6f0a37d365aa1a2", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -53,7 +53,7 @@ fn c() {\n     (*q).purem();\n \n     // ...but not impure fns\n-    (*q).impurem(); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    (*q).impurem(); //~ ERROR illegal borrow unless pure\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "af002ac686b1c0f91b24cfdfc62734c2b42b2f01", "filename": "src/test/compile-fail/borrowck-mut-addr-of-imm-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let x: int = 3;\n-    let y: &mut int = &mut x; //~ ERROR taking mut reference to immutable local variable\n+    let y: &mut int = &mut x; //~ ERROR illegal borrow\n     *y = 5;\n     log (debug, *y);\n }"}, {"sha": "19964740a6a7cf93df0c1a2afe74225bdec8c437", "filename": "src/test/compile-fail/borrowck-mut-deref-comp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -1,7 +1,7 @@\n enum foo = ~int;\n \n fn borrow(x: @mut foo) {\n-    let _y = &***x; //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    let _y = &***x; //~ ERROR illegal borrow unless pure\n     *x = foo(~4); //~ NOTE impure due to assigning to dereference of mutable @ pointer\n }\n "}, {"sha": "652183a053e695fcb4f02afb436129546668b854", "filename": "src/test/compile-fail/borrowck-mut-slice-of-imm-vec.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -0,0 +1,8 @@\n+fn write(v: &[mut int]) {\n+    v[0] += 1;\n+}\n+\n+fn main() {\n+    let v = ~[1, 2, 3];\n+    write(v); //~ ERROR illegal borrow\n+}"}, {"sha": "7b8d8e99b0afa131db96c8d3654df227ed77b294", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -5,7 +5,7 @@ fn want_slice(v: &[int]) -> int {\n }\n \n fn has_mut_vec(+v: @~[mut int]) -> int {\n-    want_slice(*v) //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    want_slice(*v) //~ ERROR illegal borrow unless pure\n         //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "59707bfcf21d5d1802f9e289ff519fd7e1bce293", "filename": "src/test/compile-fail/borrowck-pure-scope-in-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -4,7 +4,7 @@ fn test1(x: @mut ~int) {\n     // Here, evaluating the second argument actually invalidates the\n     // first borrow, even though it occurs outside of the scope of the\n     // borrow!\n-    pure_borrow(*x, *x = ~5);  //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    pure_borrow(*x, *x = ~5);  //~ ERROR illegal borrow unless pure\n     //~^ NOTE impure due to assigning to dereference of mutable @ pointer\n }\n "}, {"sha": "c3fa58b617aa9f67d380aa2f470421b0e0a41817", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -1,23 +1,19 @@\n fn borrow(_v: &int) {}\n \n fn box_mut(v: @mut ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(*v); //~ ERROR illegal borrow unless pure\n }\n \n fn box_rec_mut(v: @{mut f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_mut_rec(v: @mut {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_mut_recs(v: @mut {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n }\n \n fn box_imm(v: @~int) {\n@@ -33,28 +29,23 @@ fn box_imm_recs(v: @{f: {g: {h: ~int}}}) {\n }\n \n fn box_const(v: @const ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(*v); //~ ERROR illegal borrow unless pure\n }\n \n fn box_rec_const(v: @{const f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_recs_const(v: @{f: {g: {const h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n }\n \n fn box_const_rec(v: @const {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_const_recs(v: @const {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n }\n \n fn main() {"}, {"sha": "1a5390e62a623aaaf477d7effae050bb0be3e48b", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -1,23 +1,19 @@\n fn borrow(_v: &int) {}\n \n fn box_mut(v: &mut ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(*v); //~ ERROR illegal borrow unless pure\n }\n \n fn box_rec_mut(v: &{mut f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_mut_rec(v: &mut {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_mut_recs(v: &mut {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n }\n \n fn box_imm(v: &~int) {\n@@ -33,28 +29,23 @@ fn box_imm_recs(v: &{f: {g: {h: ~int}}}) {\n }\n \n fn box_const(v: &const ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(*v); //~ ERROR illegal borrow unless pure\n }\n \n fn box_rec_const(v: &{const f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_recs_const(v: &{f: {g: {const h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n }\n \n fn box_const_rec(v: &const {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f); //~ ERROR illegal borrow unless pure\n }\n \n fn box_const_recs(v: &const {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n-    //~^ NOTE impure due to access to impure function\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure\n }\n \n fn main() {"}, {"sha": "a3498dd19686b8d1af05b1a36540c609b3c69a0e", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -7,6 +7,5 @@ fn f<T:Eq>(&o: Option<T>) {\n \n fn main() {\n     f::<int>(option::None);\n-    //~^ ERROR taking mut reference to static item\n-    //~^^ ERROR illegal borrow: creating mutable alias to aliasable, immutable memory\n+    //~^ ERROR illegal borrow: creating mutable alias to static item\n }"}, {"sha": "184acbfa44f151f19485148ab0f5c5ac6d3d2103", "filename": "src/test/run-pass/auto-ref-newtype.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -0,0 +1,14 @@\n+// Check that we can define inherent methods on newtype enums that use\n+// an auto-ref'd receiver.\n+\n+enum Foo = uint;\n+\n+impl Foo {\n+    fn len(&self) -> uint { **self }\n+}\n+\n+fn main() {\n+    let m = Foo(3);\n+    assert m.len() == 3;\n+}\n+"}, {"sha": "2e60b41688761cac2307cb85e8de0012f7a3504d", "filename": "src/test/run-pass/autoderef-and-borrow-method-receiver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8f200d102294cf1bd90cdacad995abccda7934/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-and-borrow-method-receiver.rs?ref=8a8f200d102294cf1bd90cdacad995abccda7934", "patch": "@@ -3,7 +3,7 @@ struct Foo {\n }\n \n impl Foo {\n-    fn f(&self) {}\n+    fn f(&const self) {}\n }\n \n fn g(x: &mut Foo) {"}]}