{"sha": "b8226320735bc8e3f699cc177be638433ed396d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MjI2MzIwNzM1YmM4ZTNmNjk5Y2MxNzdiZTYzODQzM2VkMzk2ZDk=", "commit": {"author": {"name": "Markus Legner", "email": "markus@legner.ch", "date": "2020-11-23T09:18:27Z"}, "committer": {"name": "Markus Legner", "email": "markus@legner.ch", "date": "2020-11-27T07:55:04Z"}, "message": "Factor out `check_binary` from function `check_expr`.", "tree": {"sha": "f239943d30c01e57d2c196d91e876732a0cd6eba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f239943d30c01e57d2c196d91e876732a0cd6eba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8226320735bc8e3f699cc177be638433ed396d9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE8Gd4tklnUGrwqsxng3PtO0zPqEUFAl/AsNgACgkQg3PtO0zP\nqEVTww//SuwDQ3YeV1JNuIBFd0w6IO90GIa/4bzkOKwCZNRwE+qYiH0MmoellPTH\nFfIY4Tz2O5YxbNqhbC3wj+DdmPLquedeGQX8uhBD3Xxo1BUurIdWLdxHc2zxXQod\n7FfSBnD1Cj0UoRMzFKgwdsQqSz5sPjwDnDpwhS2aMzYxpyY+NZE7keaSm722H4Bo\nrKjsD59XcDS36B5o2Br+DB75bvnpPKBuHD4vxoQmp1PXYxm8uksYuFpk1S8/bUXb\nK+HzdKg+2RwiNmIXvGs7gwR+wZbSw47vtwpLgv+1jAURWOcOaBxC+gQnB9Jh32IC\nHQNj1JKJ+baby0S8UCUkROLIK44eT1AQodwY/wK2qjdTYa3ho3exvvZgNmqK9ZZW\nRVk6/NTAwNbU29CsbUbaMhXKB2hmEd9tMEB/gSkbYDqtewqO5k4wyf+U4hQA6Wqa\nAos9c82X39M0FVgC/5U7psbIMs9GFA0i3RqJbiZ3o43ltcFftwSQd11SD1O0ykC/\nY+PnwbIgubbQAhm8C/DV78c7f6eibOKGCqObaJUPKk3u9Kr+/fN5fnkuZXc1RdsL\njs08wu1DFcAnw1bURzQoxBoYWyweFUlM0+aSkWm5X8JGpHtS5I2l7FovsSGZibhF\nD+s9c85qbStVn54ykLWSN1gYP40G7wzwKnIojr0nXiDfYu0+bQg=\n=Jtu/\n-----END PGP SIGNATURE-----", "payload": "tree f239943d30c01e57d2c196d91e876732a0cd6eba\nparent e42a18f02a45ffc12016a71bb4a210aa62af9a24\nauthor Markus Legner <markus@legner.ch> 1606123107 +0100\ncommitter Markus Legner <markus@legner.ch> 1606463704 +0100\n\nFactor out `check_binary` from function `check_expr`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8226320735bc8e3f699cc177be638433ed396d9", "html_url": "https://github.com/rust-lang/rust/commit/b8226320735bc8e3f699cc177be638433ed396d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8226320735bc8e3f699cc177be638433ed396d9/comments", "author": {"login": "mlegner", "id": 5960634, "node_id": "MDQ6VXNlcjU5NjA2MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5960634?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mlegner", "html_url": "https://github.com/mlegner", "followers_url": "https://api.github.com/users/mlegner/followers", "following_url": "https://api.github.com/users/mlegner/following{/other_user}", "gists_url": "https://api.github.com/users/mlegner/gists{/gist_id}", "starred_url": "https://api.github.com/users/mlegner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mlegner/subscriptions", "organizations_url": "https://api.github.com/users/mlegner/orgs", "repos_url": "https://api.github.com/users/mlegner/repos", "events_url": "https://api.github.com/users/mlegner/events{/privacy}", "received_events_url": "https://api.github.com/users/mlegner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mlegner", "id": 5960634, "node_id": "MDQ6VXNlcjU5NjA2MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5960634?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mlegner", "html_url": "https://github.com/mlegner", "followers_url": "https://api.github.com/users/mlegner/followers", "following_url": "https://api.github.com/users/mlegner/following{/other_user}", "gists_url": "https://api.github.com/users/mlegner/gists{/gist_id}", "starred_url": "https://api.github.com/users/mlegner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mlegner/subscriptions", "organizations_url": "https://api.github.com/users/mlegner/orgs", "repos_url": "https://api.github.com/users/mlegner/repos", "events_url": "https://api.github.com/users/mlegner/events{/privacy}", "received_events_url": "https://api.github.com/users/mlegner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42a18f02a45ffc12016a71bb4a210aa62af9a24", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42a18f02a45ffc12016a71bb4a210aa62af9a24", "html_url": "https://github.com/rust-lang/rust/commit/e42a18f02a45ffc12016a71bb4a210aa62af9a24"}], "stats": {"total": 140, "additions": 73, "deletions": 67}, "files": [{"sha": "0512d74c7b1c8350bd31ca5f039d84578d663b83", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 73, "deletions": 67, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b8226320735bc8e3f699cc177be638433ed396d9/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8226320735bc8e3f699cc177be638433ed396d9/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=b8226320735bc8e3f699cc177be638433ed396d9", "patch": "@@ -381,73 +381,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 return;\n             },\n             ExprKind::Binary(ref cmp, ref left, ref right) => {\n-                let op = cmp.node;\n-                if op.is_comparison() {\n-                    check_nan(cx, left, expr);\n-                    check_nan(cx, right, expr);\n-                    check_to_owned(cx, left, right, true);\n-                    check_to_owned(cx, right, left, false);\n-                }\n-                if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n-                    if is_allowed(cx, left) || is_allowed(cx, right) {\n-                        return;\n-                    }\n-\n-                    // Allow comparing the results of signum()\n-                    if is_signum(cx, left) && is_signum(cx, right) {\n-                        return;\n-                    }\n-\n-                    if let Some(name) = get_item_name(cx, expr) {\n-                        let name = name.as_str();\n-                        if name == \"eq\"\n-                            || name == \"ne\"\n-                            || name == \"is_nan\"\n-                            || name.starts_with(\"eq_\")\n-                            || name.ends_with(\"_eq\")\n-                        {\n-                            return;\n-                        }\n-                    }\n-                    let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n-                    let (lint, msg) = get_lint_and_message(\n-                        is_named_constant(cx, left) || is_named_constant(cx, right),\n-                        is_comparing_arrays,\n-                    );\n-                    span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n-                        let lhs = Sugg::hir(cx, left, \"..\");\n-                        let rhs = Sugg::hir(cx, right, \"..\");\n-\n-                        if !is_comparing_arrays {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"consider comparing them within some margin of error\",\n-                                format!(\n-                                    \"({}).abs() {} error_margin\",\n-                                    lhs - rhs,\n-                                    if op == BinOpKind::Eq { '<' } else { '>' }\n-                                ),\n-                                Applicability::HasPlaceholders, // snippet\n-                            );\n-                        }\n-                        diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n-                    });\n-                } else if op == BinOpKind::Rem {\n-                    if is_integer_const(cx, right, 1) {\n-                        span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-                    }\n-\n-                    if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n-                        if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n-                            span_lint(\n-                                cx,\n-                                MODULO_ONE,\n-                                expr.span,\n-                                \"any number modulo -1 will panic/overflow or result in 0\",\n-                            );\n-                        }\n-                    };\n-                }\n+                check_binary(cx, expr, cmp, left, right);\n+                return;\n             },\n             _ => {},\n         }\n@@ -760,3 +695,74 @@ fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>)\n         }\n     }\n }\n+\n+fn check_binary(\n+    cx: &LateContext<'a>,\n+    expr: &Expr<'_>,\n+    cmp: &rustc_span::source_map::Spanned<rustc_hir::BinOpKind>,\n+    left: &'a Expr<'_>,\n+    right: &'a Expr<'_>,\n+) {\n+    let op = cmp.node;\n+    if op.is_comparison() {\n+        check_nan(cx, left, expr);\n+        check_nan(cx, right, expr);\n+        check_to_owned(cx, left, right, true);\n+        check_to_owned(cx, right, left, false);\n+    }\n+    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n+        if is_allowed(cx, left) || is_allowed(cx, right) {\n+            return;\n+        }\n+\n+        // Allow comparing the results of signum()\n+        if is_signum(cx, left) && is_signum(cx, right) {\n+            return;\n+        }\n+\n+        if let Some(name) = get_item_name(cx, expr) {\n+            let name = name.as_str();\n+            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n+                return;\n+            }\n+        }\n+        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n+        let (lint, msg) = get_lint_and_message(\n+            is_named_constant(cx, left) || is_named_constant(cx, right),\n+            is_comparing_arrays,\n+        );\n+        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n+            let lhs = Sugg::hir(cx, left, \"..\");\n+            let rhs = Sugg::hir(cx, right, \"..\");\n+\n+            if !is_comparing_arrays {\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"consider comparing them within some margin of error\",\n+                    format!(\n+                        \"({}).abs() {} error_margin\",\n+                        lhs - rhs,\n+                        if op == BinOpKind::Eq { '<' } else { '>' }\n+                    ),\n+                    Applicability::HasPlaceholders, // snippet\n+                );\n+            }\n+            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n+        });\n+    } else if op == BinOpKind::Rem {\n+        if is_integer_const(cx, right, 1) {\n+            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+        }\n+\n+        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n+            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n+                span_lint(\n+                    cx,\n+                    MODULO_ONE,\n+                    expr.span,\n+                    \"any number modulo -1 will panic/overflow or result in 0\",\n+                );\n+            }\n+        };\n+    }\n+}"}]}