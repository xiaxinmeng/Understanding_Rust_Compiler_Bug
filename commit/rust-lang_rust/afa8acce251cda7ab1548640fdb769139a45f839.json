{"sha": "afa8acce251cda7ab1548640fdb769139a45f839", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYThhY2NlMjUxY2RhN2FiMTU0ODY0MGZkYjc2OTEzOWE0NWY4Mzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-09T02:26:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-09T02:26:43Z"}, "message": "Auto merge of #47489 - pnkfelix:limit-2pb-issue-46747, r=nikomatsakis\n\nNLL: Limit two-phase borrows to autoref-introduced borrows\n\nThis imposes a restriction on two-phase borrows so that it only applies to autoref-introduced borrows.\n\nThe goal is to ensure that our initial deployment of two-phase borrows is very conservative. We want it to still cover the `v.push(v.len());` example, but we do not want it to cover cases like `let imm = &v; let mu = &mut v; mu.push(imm.len());`\n\n(Why do we want it to be conservative? Because when you are not conservative, then the results you get, at least with the current analysis, are tightly coupled to details of the MIR construction that we would rather remain invisible to the end user.)\n\nFix #46747\n\nI decided, for this PR, to add a debug-flag `-Z two-phase-beyond-autoref`, to re-enable the more general approach. But my intention here is *not* that we would eventually turn on that debugflag by default; the main reason I added it was that I thought it was useful for writing tests to be able to write source that looks like desugared MIR.", "tree": {"sha": "bc933826b368226427af8894bc4de82291c7ea9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc933826b368226427af8894bc4de82291c7ea9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afa8acce251cda7ab1548640fdb769139a45f839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afa8acce251cda7ab1548640fdb769139a45f839", "html_url": "https://github.com/rust-lang/rust/commit/afa8acce251cda7ab1548640fdb769139a45f839", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afa8acce251cda7ab1548640fdb769139a45f839/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "932c736479f43dc8893a924946e4335d8e308c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/932c736479f43dc8893a924946e4335d8e308c2e", "html_url": "https://github.com/rust-lang/rust/commit/932c736479f43dc8893a924946e4335d8e308c2e"}, {"sha": "b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8", "html_url": "https://github.com/rust-lang/rust/commit/b55cd8cc7c55a50941cc55cd399f6d5aebdf77f8"}], "stats": {"total": 641, "additions": 564, "deletions": 77}, "files": [{"sha": "03a369577a31e3e85e27e7555e27b521e14ab890", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -20,7 +20,6 @@ use std::mem;\n impl_stable_hash_for!(struct mir::GeneratorLayout<'tcx> { fields });\n impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n-impl_stable_hash_for!(enum mir::BorrowKind { Shared, Unique, Mut });\n impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     mutability,\n@@ -36,6 +35,25 @@ impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator,\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+for mir::BorrowKind {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::BorrowKind::Shared |\n+            mir::BorrowKind::Unique => {}\n+            mir::BorrowKind::Mut { allow_two_phase_borrow } => {\n+                allow_two_phase_borrow.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::UnsafetyViolationKind {\n     #[inline]"}, {"sha": "d1e431597e7455237c7683d78dc88115177cf4fa", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -163,6 +163,20 @@ impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::adjustment::AutoBorrowMutability {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::adjustment::AutoBorrowMutability::Mutable { ref allow_two_phase_borrow } => {\n+                allow_two_phase_borrow.hash_stable(hcx, hasher);\n+            }\n+            ty::adjustment::AutoBorrowMutability::Immutable => {}\n+        }\n+    }\n+}\n+\n impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n \n impl_stable_hash_for!(enum ty::BorrowKind {"}, {"sha": "7db75a516689896067ed41770e55f14b5fe61230", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -760,7 +760,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                      expr.span,\n                                      cmt_base,\n                                      r,\n-                                     ty::BorrowKind::from_mutbl(m),\n+                                     ty::BorrowKind::from_mutbl(m.into()),\n                                      AutoRef);\n             }\n "}, {"sha": "c035d02a612328fa3d2b8d0e60f0548ce367577d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -413,7 +413,20 @@ pub enum BorrowKind {\n     Unique,\n \n     /// Data is mutable and not aliasable.\n-    Mut,\n+    Mut {\n+        /// True if this borrow arose from method-call auto-ref\n+        /// (i.e. `adjustment::Adjust::Borrow`)\n+        allow_two_phase_borrow: bool\n+    }\n+}\n+\n+impl BorrowKind {\n+    pub fn allows_two_phase_borrow(&self) -> bool {\n+        match *self {\n+            BorrowKind::Shared | BorrowKind::Unique => false,\n+            BorrowKind::Mut { allow_two_phase_borrow } => allow_two_phase_borrow,\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -1611,7 +1624,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Ref(region, borrow_kind, ref place) => {\n                 let kind_str = match borrow_kind {\n                     BorrowKind::Shared => \"\",\n-                    BorrowKind::Mut | BorrowKind::Unique => \"mut \",\n+                    BorrowKind::Mut { .. } | BorrowKind::Unique => \"mut \",\n                 };\n \n                 // When printing regions, add trailing space if necessary."}, {"sha": "5433c54fb949cd54196f1e1eb06b23c9bff4e0cb", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -264,7 +264,7 @@ impl<'tcx> BinOp {\n impl BorrowKind {\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            BorrowKind::Mut => hir::MutMutable,\n+            BorrowKind::Mut { .. } => hir::MutMutable,\n             BorrowKind::Shared => hir::MutImmutable,\n \n             // We have no type corresponding to a unique imm borrow, so"}, {"sha": "afaf7d41e92ffc4cc8288b794fc440cf0b4155ba", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -951,9 +951,10 @@ impl<'tcx> PlaceContext<'tcx> {\n     pub fn is_mutating_use(&self) -> bool {\n         match *self {\n             PlaceContext::Store | PlaceContext::AsmOutput | PlaceContext::Call |\n-            PlaceContext::Borrow { kind: BorrowKind::Mut, .. } |\n+            PlaceContext::Borrow { kind: BorrowKind::Mut { .. }, .. } |\n             PlaceContext::Projection(Mutability::Mut) |\n             PlaceContext::Drop => true,\n+\n             PlaceContext::Inspect |\n             PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |\n             PlaceContext::Borrow { kind: BorrowKind::Unique, .. } |\n@@ -971,7 +972,8 @@ impl<'tcx> PlaceContext<'tcx> {\n             PlaceContext::Borrow { kind: BorrowKind::Unique, .. } |\n             PlaceContext::Projection(Mutability::Not) |\n             PlaceContext::Copy | PlaceContext::Move => true,\n-            PlaceContext::Borrow { kind: BorrowKind::Mut, .. } | PlaceContext::Store |\n+\n+            PlaceContext::Borrow { kind: BorrowKind::Mut { .. }, .. } | PlaceContext::Store |\n             PlaceContext::AsmOutput |\n             PlaceContext::Call | PlaceContext::Projection(Mutability::Mut) |\n             PlaceContext::Drop | PlaceContext::StorageLive | PlaceContext::StorageDead |"}, {"sha": "5b8092e86da045f13d798275174c57f1f089098b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -1121,6 +1121,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"select which borrowck is used (`ast`, `mir`, or `compare`)\"),\n     two_phase_borrows: bool = (false, parse_bool, [UNTRACKED],\n         \"use two-phase reserved/active distinction for `&mut` borrows in MIR borrowck\"),\n+    two_phase_beyond_autoref: bool = (false, parse_bool, [UNTRACKED],\n+        \"when using two-phase-borrows, allow two phases even for non-autoref `&mut` borrows\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,"}, {"sha": "7579d95a8fe6822f2a14818d8f93bcc9a6906272", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -119,10 +119,25 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AutoBorrowMutability {\n+    Mutable { allow_two_phase_borrow: bool },\n+    Immutable,\n+}\n+\n+impl From<AutoBorrowMutability> for hir::Mutability {\n+    fn from(m: AutoBorrowMutability) -> Self {\n+        match m {\n+            AutoBorrowMutability::Mutable { .. } => hir::MutMutable,\n+            AutoBorrowMutability::Immutable => hir::MutImmutable,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T.\n-    Ref(ty::Region<'tcx>, hir::Mutability),\n+    Ref(ty::Region<'tcx>, AutoBorrowMutability),\n \n     /// Convert from T to *T.\n     RawPtr(hir::Mutability),"}, {"sha": "bdb1001124de6bdd314959fce6a689622a085f39", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -134,7 +134,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                     BindingMode::ByValue => mutability == Mutability::Mut,\n                     BindingMode::ByRef(_, bk) => {\n                         write!(f, \"ref \")?;\n-                        bk == BorrowKind::Mut\n+                        match bk { BorrowKind::Mut { .. } => true, _ => false }\n                     }\n                 };\n                 if is_mut {\n@@ -429,7 +429,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         (Mutability::Not, BindingMode::ByValue),\n                     ty::BindByReference(hir::MutMutable) =>\n                         (Mutability::Not, BindingMode::ByRef(\n-                            region.unwrap(), BorrowKind::Mut)),\n+                            region.unwrap(), BorrowKind::Mut { allow_two_phase_borrow: false })),\n                     ty::BindByReference(hir::MutImmutable) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             region.unwrap(), BorrowKind::Shared)),"}, {"sha": "439533fae49d915d8e9bdb546355c82e7f6952a1", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -437,8 +437,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n         for adj in cx.tables.expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n                 let msg = match m {\n-                    hir::MutImmutable => \"unnecessary allocation, use & instead\",\n-                    hir::MutMutable => \"unnecessary allocation, use &mut instead\"\n+                    adjustment::AutoBorrowMutability::Immutable =>\n+                        \"unnecessary allocation, use & instead\",\n+                    adjustment::AutoBorrowMutability::Mutable { .. }=>\n+                        \"unnecessary allocation, use &mut instead\"\n                 };\n                 cx.span_lint(UNUSED_ALLOCATION, e.span, msg);\n             }"}, {"sha": "34551e8e76f5993cf92be5afb6efdf226f90ba37", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -256,8 +256,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"immutable\",\n             \"mutable\",\n         ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) |\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n                 .cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n@@ -271,7 +271,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Origin::Mir,\n                 ),\n \n-            (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) => self.tcx\n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => self.tcx\n                 .cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n@@ -314,7 +314,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Origin::Mir,\n                 ),\n \n-            (BorrowKind::Mut, _, lft, BorrowKind::Unique, _, _) => self.tcx\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => self.tcx\n                 .cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,"}, {"sha": "217dfdf8d416e3117af902bde36b363e03e21f2d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -707,6 +707,15 @@ impl InitializationRequiringAction {\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Returns true if the borrow represented by `kind` is\n+    /// allowed to be split into separate Reservation and\n+    /// Activation phases.\n+    fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n+        self.tcx.sess.two_phase_borrows() &&\n+            (kind.allows_two_phase_borrow() ||\n+             self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+    }\n+\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this\n@@ -797,9 +806,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Control::Continue\n                 }\n \n-                (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut) => {\n+                (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if this.tcx.sess.two_phase_borrows() && index.is_reservation()\n+                    if this.allow_two_phase_borrow(borrow.kind) && index.is_reservation()\n                     {\n                         return Control::Continue;\n                     }\n@@ -828,7 +837,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 (Reservation(kind), BorrowKind::Unique)\n-                | (Reservation(kind), BorrowKind::Mut)\n+                | (Reservation(kind), BorrowKind::Mut { .. })\n                 | (Activation(kind, _), _)\n                 | (Write(kind), _) => {\n                     match rw {\n@@ -945,9 +954,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n-                    BorrowKind::Unique | BorrowKind::Mut => {\n+                    BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n-                        if self.tcx.sess.two_phase_borrows() {\n+                        if self.allow_two_phase_borrow(bk) {\n                             (Deep, Reservation(wk))\n                         } else {\n                             (Deep, Write(wk))\n@@ -1196,7 +1205,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // mutable borrow before we check it.\n                 match borrow.kind {\n                     BorrowKind::Shared => return,\n-                    BorrowKind::Unique | BorrowKind::Mut => {}\n+                    BorrowKind::Unique | BorrowKind::Mut { .. } => {}\n                 }\n \n                 self.access_place(\n@@ -1467,8 +1476,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n                 }\n             }\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut))\n-            | Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => if let Err(place_err) =\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut { .. }))\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => if let Err(place_err) =\n                 self.is_mutable(place, is_local_mutation_allowed)\n             {\n                 error_reported = true;\n@@ -1532,7 +1541,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Activation(..) => {} // permission checks are done at Reservation point.\n \n             Read(ReadKind::Borrow(BorrowKind::Unique))\n-            | Read(ReadKind::Borrow(BorrowKind::Mut))\n+            | Read(ReadKind::Borrow(BorrowKind::Mut { .. }))\n             | Read(ReadKind::Borrow(BorrowKind::Shared))\n             | Read(ReadKind::Copy) => {} // Access authorized\n         }"}, {"sha": "fe9b0b86befc3b8e8a715b375be684af4cabbf88", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n         let kind = match self.kind {\n             mir::BorrowKind::Shared => \"\",\n             mir::BorrowKind::Unique => \"uniq \",\n-            mir::BorrowKind::Mut => \"mut \",\n+            mir::BorrowKind::Mut { .. } => \"mut \",\n         };\n         let region = format!(\"{}\", self.region);\n         let region = if region.len() > 0 { format!(\"{} \", region) } else { region };"}, {"sha": "00ab2e4599528f3de48828ff454a454f83b75042", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -17,10 +17,11 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n+use rustc::mir::{BorrowKind};\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n@@ -111,7 +112,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 span,\n                 kind: ExprKind::Borrow {\n                     region: deref.region,\n-                    borrow_kind: to_borrow_kind(deref.mutbl),\n+                    borrow_kind: deref.mutbl.to_borrow_kind(),\n                     arg: expr.to_ref(),\n                 },\n             };\n@@ -121,7 +122,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Adjust::Borrow(AutoBorrow::Ref(r, m)) => {\n             ExprKind::Borrow {\n                 region: r,\n-                borrow_kind: to_borrow_kind(m),\n+                borrow_kind: m.to_borrow_kind(),\n                 arg: expr.to_ref(),\n             }\n         }\n@@ -141,7 +142,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 span,\n                 kind: ExprKind::Borrow {\n                     region,\n-                    borrow_kind: to_borrow_kind(m),\n+                    borrow_kind: m.to_borrow_kind(),\n                     arg: expr.to_ref(),\n                 },\n             };\n@@ -287,7 +288,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n             ExprKind::Borrow {\n                 region,\n-                borrow_kind: to_borrow_kind(mutbl),\n+                borrow_kind: mutbl.to_borrow_kind(),\n                 arg: expr.to_ref(),\n             }\n         }\n@@ -642,10 +643,25 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n-    match m {\n-        hir::MutMutable => BorrowKind::Mut,\n-        hir::MutImmutable => BorrowKind::Shared,\n+trait ToBorrowKind { fn to_borrow_kind(&self) -> BorrowKind; }\n+\n+impl ToBorrowKind for AutoBorrowMutability {\n+    fn to_borrow_kind(&self) -> BorrowKind {\n+        match *self {\n+            AutoBorrowMutability::Mutable { allow_two_phase_borrow } =>\n+                BorrowKind::Mut { allow_two_phase_borrow },\n+            AutoBorrowMutability::Immutable =>\n+                BorrowKind::Shared,\n+        }\n+    }\n+}\n+\n+impl ToBorrowKind for hir::Mutability {\n+    fn to_borrow_kind(&self) -> BorrowKind {\n+        match *self {\n+            hir::MutMutable => BorrowKind::Mut { allow_two_phase_borrow: false },\n+            hir::MutImmutable => BorrowKind::Shared,\n+        }\n     }\n }\n \n@@ -947,7 +963,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n                 ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n-                ty::BorrowKind::MutBorrow => BorrowKind::Mut,\n+                ty::BorrowKind::MutBorrow => BorrowKind::Mut { allow_two_phase_borrow: false }\n             };\n             Expr {\n                 temp_lifetime,"}, {"sha": "e6ebdd3d6c16702fc2c839f7d23a600bf6bac105", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -716,11 +716,14 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }),\n                 span\n             ));\n+            let borrow_kind = BorrowKind::Mut {\n+                allow_two_phase_borrow: false,\n+            };\n             statements.push(Statement {\n                 source_info,\n                 kind: StatementKind::Assign(\n                     Place::Local(ref_rcvr),\n-                    Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, rcvr_l)\n+                    Rvalue::Ref(tcx.types.re_erased, borrow_kind, rcvr_l)\n                 )\n             });\n             Operand::Move(Place::Local(ref_rcvr))"}, {"sha": "15bbcad7325bec57b2f5d296fe427e6b5020f82f", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -426,7 +426,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     debug!(\"Creating temp for return destination\");\n                     let dest = Rvalue::Ref(\n                         self.tcx.types.re_erased,\n-                        BorrowKind::Mut,\n+                        BorrowKind::Mut { allow_two_phase_borrow: false },\n                         destination.0);\n \n                     let ty = dest.ty(caller_mir, self.tcx);\n@@ -511,7 +511,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                          callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Local {\n         let arg = Rvalue::Ref(\n             self.tcx.types.re_erased,\n-            BorrowKind::Mut,\n+            BorrowKind::Mut { allow_two_phase_borrow: false },\n             arg.deref());\n \n         let ty = arg.ty(caller_mir, self.tcx);"}, {"sha": "e7bb03eefc4c5b7b0027835e20d2993cdee70190", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -602,7 +602,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n \n                 let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                if kind == BorrowKind::Mut {\n+                if let BorrowKind::Mut { .. } = kind {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions."}, {"sha": "e2feb0ed39054c839c26f0e126b91dc0432ba608", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -531,7 +531,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let result = BasicBlockData {\n             statements: vec![self.assign(\n                 &Place::Local(ref_place),\n-                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.place.clone())\n+                Rvalue::Ref(tcx.types.re_erased,\n+                            BorrowKind::Mut { allow_two_phase_borrow: false },\n+                            self.place.clone())\n             )],\n             terminator: Some(Terminator {\n                 kind: TerminatorKind::Call {\n@@ -591,7 +593,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         } else {\n             (Rvalue::Ref(\n                  tcx.types.re_erased,\n-                 BorrowKind::Mut,\n+                 BorrowKind::Mut { allow_two_phase_borrow: false },\n                  self.place.clone().index(cur)),\n              Rvalue::BinaryOp(BinOp::Add, copy(&Place::Local(cur)), one))\n         };\n@@ -735,7 +737,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n             drop_block_stmts.push(self.assign(&tmp, Rvalue::Ref(\n-                tcx.types.re_erased, BorrowKind::Mut, self.place.clone()\n+                tcx.types.re_erased,\n+                BorrowKind::Mut { allow_two_phase_borrow: false },\n+                self.place.clone()\n             )));\n             drop_block_stmts.push(self.assign(&cur, Rvalue::Cast(\n                 CastKind::Misc, Operand::Move(tmp.clone()), iter_ty"}, {"sha": "49b4ef0d38549db657d754baeceec0329a5ff0fa", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -870,7 +870,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         } else {\n                             self.cx.tcx.data_layout.pointer_align\n                         };\n-                        if bk == mir::BorrowKind::Mut {\n+                        if let mir::BorrowKind::Mut { .. } = bk {\n                             consts::addr_of_mut(self.cx, llval, align, \"ref_mut\")\n                         } else {\n                             consts::addr_of(self.cx, llval, align, \"ref\")"}, {"sha": "3d61ffe39336a5b7778948cb8b2d6c36cc32a539", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -16,7 +16,7 @@ use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, TypeFoldable, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use syntax::abi;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -176,8 +176,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let mut autoref = None;\n                     if borrow {\n                         if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                            let mutbl = match mt.mutbl {\n+                                hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                    // For initial two-phase borrow\n+                                    // deployment, conservatively omit\n+                                    // overloaded function call ops.\n+                                    allow_two_phase_borrow: false,\n+                                }\n+                            };\n                             autoref = Some(Adjustment {\n-                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                                 target: method.sig.inputs()[0]\n                             });\n                         }"}, {"sha": "47e4b0272bed416bc07f0caf21300b1e7e4204d7", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -68,7 +68,7 @@ use rustc::infer::{Coercion, InferResult, InferOk};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::lint;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::{self, TypeAndMut, Ty, ClosureSubsts};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n@@ -421,8 +421,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n+        let mutbl = match mt_b.mutbl {\n+            hir::MutImmutable => AutoBorrowMutability::Immutable,\n+            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                // Deref-coercion is a case where we deliberately\n+                // disallow two-phase borrows in its initial\n+                // deployment; see discussion on PR #47489.\n+                allow_two_phase_borrow: false,\n+            }\n+        };\n         adjustments.push(Adjustment {\n-            kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mt_b.mutbl)),\n+            kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mutbl)),\n             target: ty\n         });\n \n@@ -461,11 +470,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n+                let mutbl = match mt_b.mutbl {\n+                    hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                    hir::MutMutable => AutoBorrowMutability::Mutable {\n+                        allow_two_phase_borrow: false,\n+                    }\n+                };\n                 Some((Adjustment {\n                     kind: Adjust::Deref(None),\n                     target: mt_a.ty\n                 }, Adjustment {\n-                    kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mt_b.mutbl)),\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mutbl)),\n                     target:  self.tcx.mk_ref(r_borrow, ty::TypeAndMut {\n                         mutbl: mt_b.mutbl,\n                         ty: mt_a.ty\n@@ -871,6 +886,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ] => {\n                     match self.node_ty(expr.hir_id).sty {\n                         ty::TyRef(_, mt_orig) => {\n+                            let mutbl_adj: hir::Mutability = mutbl_adj.into();\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref\n                             // which will be merged into it."}, {"sha": "20d58991496459403ebaf132dab3fc9e48ed93e8", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -17,7 +17,7 @@ use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, OverloadedDeref};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability, OverloadedDeref};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n@@ -165,14 +165,22 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 mutbl,\n                 ty: target\n             });\n+            let mutbl = match mutbl {\n+                hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                    // Method call receivers are the primary use case\n+                    // for two-phase borrows.\n+                    allow_two_phase_borrow: true,\n+                }\n+            };\n             adjustments.push(Adjustment {\n                 kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                 target\n             });\n \n             if let Some(unsize_target) = pick.unsize {\n                 target = self.tcx.mk_ref(region, ty::TypeAndMut {\n-                    mutbl,\n+                    mutbl: mutbl.into(),\n                     ty: unsize_target\n                 });\n                 adjustments.push(Adjustment {\n@@ -530,10 +538,19 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             for adjustment in &mut adjustments[..] {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n                     debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    let mutbl = match mutbl {\n+                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                            // For initial two-phase borrow\n+                            // deployment, conservatively omit\n+                            // overloaded operators.\n+                            allow_two_phase_borrow: false,\n+                        }\n+                    };\n                     adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n                     adjustment.target = self.tcx.mk_ref(region, ty::TypeAndMut {\n                         ty: source,\n-                        mutbl\n+                        mutbl: mutbl.into(),\n                     });\n                 }\n                 source = adjustment.target;"}, {"sha": "5fd4e0cb109cc05382e76b1bea4a9ea3a93cd9ef", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -96,7 +96,7 @@ use rustc::middle::region;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n-use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n@@ -2357,8 +2357,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 let mut adjustments = autoderef.adjust_steps(needs);\n                 if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                    let mutbl = match mt.mutbl {\n+                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                            // FIXME (#46747): arguably indexing is\n+                            // \"just another kind of call\"; perhaps it\n+                            // would be more consistent to allow\n+                            // two-phase borrows for .index()\n+                            // receivers here.\n+                            allow_two_phase_borrow: false,\n+                        }\n+                    };\n                     adjustments.push(Adjustment {\n-                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                         target: self.tcx.mk_ref(region, ty::TypeAndMut {\n                             mutbl: mt.mutbl,\n                             ty: adjusted_ty\n@@ -3646,8 +3657,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 expr.span, oprnd_t, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n                             if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                                let mutbl = match mt.mutbl {\n+                                    hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                    hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                        // (It shouldn't actually matter for unary ops whether\n+                                        // we enable two-phase borrows or not, since a unary\n+                                        // op has no additional operands.)\n+                                        allow_two_phase_borrow: false,\n+                                    }\n+                                };\n                                 self.apply_adjustments(oprnd, vec![Adjustment {\n-                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                                     target: method.sig.inputs()[0]\n                                 }]);\n                             }"}, {"sha": "a6776a0fe8612f75d7776a772f0d11f6b9496d3c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -14,7 +14,7 @@ use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n use rustc::ty::{self, Ty, TypeFoldable, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n use syntax_pos::Span;\n@@ -198,17 +198,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n                     if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                        let mutbl = match mt.mutbl {\n+                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                // For initial two-phase borrow\n+                                // deployment, conservatively omit\n+                                // overloaded binary ops.\n+                                allow_two_phase_borrow: false,\n+                            }\n+                        };\n                         let autoref = Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                             target: method.sig.inputs()[0]\n                         };\n                         self.apply_adjustments(lhs_expr, vec![autoref]);\n                     }\n                 }\n                 if by_ref_binop {\n                     if let ty::TyRef(region, mt) = method.sig.inputs()[1].sty {\n+                        let mutbl = match mt.mutbl {\n+                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                // For initial two-phase borrow\n+                                // deployment, conservatively omit\n+                                // overloaded binary ops.\n+                                allow_two_phase_borrow: false,\n+                            }\n+                        };\n                         let autoref = Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                             target: method.sig.inputs()[1]\n                         };\n                         // HACK(eddyb) Bypass checks due to reborrows being in"}, {"sha": "b5bf59fef9afc7852232a473f04168b7551b6abb", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -1063,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n                 self.link_region(expr.span, r,\n-                                 ty::BorrowKind::from_mutbl(m), expr_cmt);\n+                                 ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {"}, {"sha": "709c00ba8464a41590333caa3926b0d92181563d", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -8,16 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// ignore-tidy-linelength\n+\n+// revisions: lxl_beyond nll_beyond nll_target\n+\n+//[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n+//[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+//[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is an important corner case pointed out by Niko: one is\n // allowed to initiate a shared borrow during a reservation, but it\n // *must end* before the activation occurs.\n //\n // FIXME: for clarity, diagnostics for these cases might be better off\n // if they specifically said \"cannot activate mutable borrow of `x`\"\n+//\n+// The convention for the listed revisions: \"lxl\" means lexical\n+// lifetimes (which can be easier to reason about). \"nll\" means\n+// non-lexical lifetimes. \"nll_target\" means the initial conservative\n+// two-phase borrows that only applies to autoref-introduced borrows.\n+// \"nll_beyond\" means the generalization of two-phase borrows to all\n+// `&mut`-borrows (doing so makes it easier to write code for specific\n+// corner cases).\n \n #![allow(dead_code)]\n \n@@ -27,35 +39,41 @@ fn ok() {\n     let mut x = 3;\n     let y = &mut x;\n     { let z = &x; read(z); }\n+    //[nll_target]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n     *y += 1;\n }\n \n fn not_ok() {\n     let mut x = 3;\n     let y = &mut x;\n     let z = &x;\n+    //[nll_target]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n     *y += 1;\n-    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n-    //[nll]~^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[lxl_beyond]~^   ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[nll_beyond]~^^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[nll_target]~^^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n     read(z);\n }\n \n fn should_be_ok_with_nll() {\n     let mut x = 3;\n     let y = &mut x;\n     let z = &x;\n+    //[nll_target]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n     read(z);\n     *y += 1;\n-    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n-    // (okay with nll today)\n+    //[lxl_beyond]~^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    // (okay with (generalized) nll today)\n }\n \n fn should_also_eventually_be_ok_with_nll() {\n     let mut x = 3;\n     let y = &mut x;\n     let _z = &x;\n+    //[nll_target]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n     *y += 1;\n-    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[lxl_beyond]~^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    // (okay with (generalized) nll today)\n }\n \n fn main() { }"}, {"sha": "dd174981fb1e289543cee49e0f5de09585effedd", "filename": "src/test/compile-fail/borrowck/two-phase-allow-access-during-reservation.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -8,28 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// ignore-tidy-linelength\n+\n+// revisions: lxl_beyond nll_beyond nll_target\n+//[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref\n+//[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref -Z nll\n+//[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is the second counter-example from Niko's blog post\n // smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n //\n // It is \"artificial\". It is meant to illustrate directly that we\n // should allow an aliasing access during reservation, but *not* while\n // the mutable borrow is active.\n+//\n+// The convention for the listed revisions: \"lxl\" means lexical\n+// lifetimes (which can be easier to reason about). \"nll\" means\n+// non-lexical lifetimes. \"nll_target\" means the initial conservative\n+// two-phase borrows that only applies to autoref-introduced borrows.\n+// \"nll_beyond\" means the generalization of two-phase borrows to all\n+// `&mut`-borrows (doing so makes it easier to write code for specific\n+// corner cases).\n \n fn main() {\n     /*0*/ let mut i = 0;\n \n     /*1*/ let p = &mut i; // (reservation of `i` starts here)\n \n     /*2*/ let j = i;      // OK: `i` is only reserved here\n+                          //[nll_target]~^  ERROR cannot use `i` because it was mutably borrowed [E0503]\n \n     /*3*/ *p += 1;        // (mutable borrow of `i` starts here, since `p` is used)\n \n-    /*4*/ let k = i;      //[lxl]~  ERROR cannot use `i` because it was mutably borrowed [E0503]\n-                          //[nll]~^ ERROR cannot use `i` because it was mutably borrowed [E0503]\n+    /*4*/ let k = i;      //[lxl_beyond]~   ERROR cannot use `i` because it was mutably borrowed [E0503]\n+                          //[nll_beyond]~^  ERROR cannot use `i` because it was mutably borrowed [E0503]\n+                          //[nll_target]~^^ ERROR cannot use `i` because it was mutably borrowed [E0503]\n \n     /*5*/ *p += 1;\n "}, {"sha": "795d45a776db595489dc8d76b6d26b5a6ba83beb", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -0,0 +1,260 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll g2p\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+//[g2p]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll -Z two-phase-beyond-autoref\n+\n+// This is a test checking that when we limit two-phase borrows to\n+// method receivers, we do not let other kinds of auto-ref to leak\n+// through.\n+//\n+// The g2p revision illustrates the \"undesirable\" behavior you would\n+// otherwise observe without limiting the phasing to autoref on method\n+// receivers (namely, in many cases demonstrated below, the error\n+// would not arise).\n+\n+// (If we revise the compiler or this test so that the g2p revision\n+// passes, turn the `rustc_attrs` feature back on and tag the `fn\n+// main` with `#[rustc_error]` so that this remains a valid\n+// compile-fail test.)\n+//\n+// #![feature(rustc_attrs)]\n+\n+use std::ops::{Index, IndexMut};\n+use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+use std::ops::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n+\n+// This is case outlined by Niko that we want to ensure we reject\n+// (at least initially).\n+\n+fn foo(x: &mut u32, y: u32) {\n+    *x += y;\n+}\n+\n+fn deref_coercion(x: &mut u32) {\n+    foo(x, *x);\n+    //[lxl]~^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n+    //[nll]~^^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n+}\n+\n+// While adding a flag to adjustments (indicating whether they\n+// should support two-phase borrows, here are the cases I\n+// encountered:\n+//\n+// - [x] Resolving overloaded_call_traits (call, call_mut, call_once)\n+// - [x] deref_coercion (shown above)\n+// - [x] coerce_unsized e.g. `&[T; n]`, `&mut [T; n] -> &[T]`,\n+//                      `&mut [T; n] -> &mut [T]`, `&Concrete -> &Trait`\n+// - [x] Method Call Receivers (the case we want to support!)\n+// - [x] ExprIndex and ExprUnary Deref; only need to handle coerce_index_op\n+// - [x] overloaded_binops\n+\n+fn overloaded_call_traits() {\n+    // Regarding overloaded call traits, note that there is no\n+    // scenario where adding two-phase borrows should \"fix\" these\n+    // cases, because either we will resolve both invocations to\n+    // `call_mut` (in which case the inner call requires a mutable\n+    // borrow which will conflict with the outer reservation), or we\n+    // will resolve both to `call` (which will just work, regardless\n+    // of two-phase borrow support), or we will resolve both to\n+    // `call_once` (in which case the inner call requires moving the\n+    // receiver, invalidating the outer call).\n+\n+    fn twice_ten_sm<F: FnMut(i32) -> i32>(f: &mut F) {\n+        f(f(10));\n+        //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[lxl]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^^^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+    }\n+    fn twice_ten_si<F: Fn(i32) -> i32>(f: &mut F) {\n+        f(f(10));\n+    }\n+    fn twice_ten_so<F: FnOnce(i32) -> i32>(f: Box<F>) {\n+        f(f(10));\n+        //[lxl]~^   ERROR use of moved value: `*f`\n+        //[nll]~^^  ERROR use of moved value: `*f`\n+        //[g2p]~^^^ ERROR use of moved value: `*f`\n+    }\n+\n+    fn twice_ten_om(f: &mut FnMut(i32) -> i32) {\n+        f(f(10));\n+        //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[lxl]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^^^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+    }\n+    fn twice_ten_oi(f: &mut Fn(i32) -> i32) {\n+        f(f(10));\n+    }\n+    fn twice_ten_oo(f: Box<FnOnce(i32) -> i32>) {\n+        f(f(10));\n+        //[lxl]~^             ERROR cannot move a value of type\n+        //[lxl]~^^            ERROR cannot move a value of type\n+        //[lxl]~^^^           ERROR use of moved value: `*f`\n+        //[nll]~^^^^          ERROR cannot move a value of type\n+        //[nll]~^^^^^         ERROR cannot move a value of type\n+        //[nll]~^^^^^^        ERROR cannot move a value of type\n+        //[nll]~^^^^^^^       ERROR cannot move a value of type\n+        //[nll]~^^^^^^^^      ERROR use of moved value: `*f`\n+        //[g2p]~^^^^^^^^^     ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^^    ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^^^   ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^^^^  ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^^^^^ ERROR use of moved value: `*f`\n+    }\n+\n+    twice_ten_sm(&mut |x| x + 1);\n+    twice_ten_si(&mut |x| x + 1);\n+    twice_ten_so(Box::new(|x| x + 1));\n+    twice_ten_om(&mut |x| x + 1);\n+    twice_ten_oi(&mut |x| x + 1);\n+    twice_ten_oo(Box::new(|x| x + 1));\n+}\n+\n+trait TwoMethods {\n+    fn m(&mut self, x: i32) -> i32 { x + 1 }\n+    fn i(&self, x: i32) -> i32 { x + 1 }\n+}\n+\n+struct T;\n+\n+impl TwoMethods for T { }\n+\n+struct S;\n+\n+impl S {\n+    fn m(&mut self, x: i32) -> i32 { x + 1 }\n+    fn i(&self, x: i32) -> i32 { x + 1 }\n+}\n+\n+impl TwoMethods for [i32; 3] { }\n+\n+fn double_access<X: Copy>(m: &mut [X], s: &[X]) {\n+    m[0] = s[1];\n+}\n+\n+fn coerce_unsized() {\n+    let mut a = [1, 2, 3];\n+\n+    // This is not okay.\n+    double_access(&mut a, &a);\n+    //[lxl]~^   ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^  ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[g2p]~^^^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+\n+    // But this is okay.\n+    a.m(a.i(10));\n+}\n+\n+struct I(i32);\n+\n+impl Index<i32> for I {\n+    type Output = i32;\n+    fn index(&self, _: i32) -> &i32 {\n+        &self.0\n+    }\n+}\n+\n+impl IndexMut<i32> for I {\n+    fn index_mut(&mut self, _: i32) -> &mut i32 {\n+        &mut self.0\n+    }\n+}\n+\n+fn coerce_index_op() {\n+    let mut i = I(10);\n+    i[i[3]] = 4;\n+    //[lxl]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+\n+    i[3] = i[4];\n+\n+    i[i[3]] = i[4];\n+    //[lxl]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+}\n+\n+struct A(i32);\n+\n+macro_rules! trivial_binop {\n+    ($Trait:ident, $m:ident) => {\n+        impl $Trait<i32> for A { fn $m(&mut self, rhs: i32) { self.0 = rhs; } }\n+    }\n+}\n+\n+trivial_binop!(AddAssign, add_assign);\n+trivial_binop!(SubAssign, sub_assign);\n+trivial_binop!(MulAssign, mul_assign);\n+trivial_binop!(DivAssign, div_assign);\n+trivial_binop!(RemAssign, rem_assign);\n+trivial_binop!(BitAndAssign, bitand_assign);\n+trivial_binop!(BitOrAssign, bitor_assign);\n+trivial_binop!(BitXorAssign, bitxor_assign);\n+trivial_binop!(ShlAssign, shl_assign);\n+trivial_binop!(ShrAssign, shr_assign);\n+\n+fn overloaded_binops() {\n+    let mut a = A(10);\n+    a += a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a -= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a *= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a /= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a &= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a |= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a ^= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a <<= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+    a >>= a.0;\n+    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n+    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n+}\n+\n+fn main() {\n+\n+    // As a reminder, this is the basic case we want to ensure we handle.\n+    let mut v = vec![1, 2, 3];\n+    v.push(v.len());\n+\n+    // (as a rule, pnkfelix does not like to write tests with dead code.)\n+\n+    deref_coercion(&mut 5);\n+    overloaded_call_traits();\n+\n+\n+    let mut s = S;\n+    s.m(s.i(10));\n+\n+    let mut t = T;\n+    t.m(t.i(10));\n+\n+    coerce_unsized();\n+    coerce_index_op();\n+    overloaded_binops();\n+}"}, {"sha": "b5fda4985f23f1173a9c44d50b99249f9f887b91", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/afa8acce251cda7ab1548640fdb769139a45f839/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa8acce251cda7ab1548640fdb769139a45f839/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs?ref=afa8acce251cda7ab1548640fdb769139a45f839", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// ignore-tidy-linelength\n+\n+// revisions: lxl_beyond nll_beyond nll_target\n+\n+//[lxl_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n+//[nll_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+//[nll_target]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is a corner case that the current implementation is (probably)\n // treating more conservatively than is necessary. But it also does\n@@ -19,6 +23,18 @@\n // So this test is just making a note of the current behavior, with\n // the caveat that in the future, the rules may be loosened, at which\n // point this test might be thrown out.\n+//\n+// The convention for the listed revisions: \"lxl\" means lexical\n+// lifetimes (which can be easier to reason about). \"nll\" means\n+// non-lexical lifetimes. \"nll_target\" means the initial conservative\n+// two-phase borrows that only applies to autoref-introduced borrows.\n+// \"nll_beyond\" means the generalization of two-phase borrows to all\n+// `&mut`-borrows (doing so makes it easier to write code for specific\n+// corner cases).\n+//\n+// FIXME: in \"nll_target\", we currently see the same error reported\n+// twice. This is injected by `-Z two-phase-borrows`; not sure why as\n+// of yet.\n \n fn main() {\n     let mut vec = vec![0, 1];\n@@ -30,8 +46,10 @@ fn main() {\n         // with the shared borrow. But in the current implementation,\n         // its an error.\n         delay = &mut vec;\n-        //[lxl]~^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n-        //[nll]~^^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[lxl_beyond]~^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll_beyond]~^^  ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll_target]~^^^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll_target]~|   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n \n         shared[0];\n     }"}]}