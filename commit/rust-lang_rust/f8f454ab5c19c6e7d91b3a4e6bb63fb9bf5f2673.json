{"sha": "f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZjQ1NGFiNWMxOWM2ZTdkOTFiM2E0ZTZiYjYzZmI5YmY1ZjI2NzM=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2020-02-10T22:45:38Z"}, "committer": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2020-02-14T21:45:42Z"}, "message": "Init implementation of structural search replace", "tree": {"sha": "e80fbf31a2f69916c86b5569da4f673e7818d8ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e80fbf31a2f69916c86b5569da4f673e7818d8ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "html_url": "https://github.com/rust-lang/rust/commit/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fb36dfdcb91f67c28f51e51514ebe420ec3aa22", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fb36dfdcb91f67c28f51e51514ebe420ec3aa22", "html_url": "https://github.com/rust-lang/rust/commit/6fb36dfdcb91f67c28f51e51514ebe420ec3aa22"}], "stats": {"total": 400, "additions": 399, "deletions": 1}, "files": [{"sha": "dfd191e4267b316b9c91d601fa347a070f5ec660", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -37,6 +37,7 @@ mod display;\n mod inlay_hints;\n mod expand;\n mod expand_macro;\n+mod ssr;\n \n #[cfg(test)]\n mod marks;\n@@ -73,6 +74,7 @@ pub use crate::{\n     },\n     runnables::{Runnable, RunnableKind},\n     source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n+    ssr::SsrError,\n     syntax_highlighting::HighlightedRange,\n };\n \n@@ -464,6 +466,16 @@ impl Analysis {\n         self.with_db(|db| references::rename(db, position, new_name))\n     }\n \n+    pub fn structural_search_replace(\n+        &self,\n+        query: &str,\n+    ) -> Cancelable<Result<SourceChange, SsrError>> {\n+        self.with_db(|db| {\n+            let edits = ssr::parse_search_replace(query, db)?;\n+            Ok(SourceChange::source_file_edits(\"ssr\", edits))\n+        })\n+    }\n+\n     /// Performs an operation on that may be Canceled.\n     fn with_db<F: FnOnce(&RootDatabase) -> T + std::panic::UnwindSafe, T>(\n         &self,"}, {"sha": "14eb0b8b259e3d4c8aedc221f19748922831aca2", "filename": "crates/ra_ide/src/ssr.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -0,0 +1,324 @@\n+//!  structural search replace\n+\n+use crate::source_change::SourceFileEdit;\n+use ra_ide_db::RootDatabase;\n+use ra_syntax::ast::make::expr_from_text;\n+use ra_syntax::AstNode;\n+use ra_syntax::SyntaxElement;\n+use ra_syntax::SyntaxNode;\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+use rustc_hash::FxHashMap;\n+use std::collections::HashMap;\n+use std::str::FromStr;\n+\n+pub use ra_db::{SourceDatabase, SourceDatabaseExt};\n+use ra_ide_db::symbol_index::SymbolsDatabase;\n+\n+#[derive(Debug, PartialEq)]\n+pub struct SsrError(String);\n+\n+impl std::fmt::Display for SsrError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        write!(f, \"Parse error: {}\", self.0)\n+    }\n+}\n+\n+impl std::error::Error for SsrError {}\n+\n+pub fn parse_search_replace(\n+    query: &str,\n+    db: &RootDatabase,\n+) -> Result<Vec<SourceFileEdit>, SsrError> {\n+    let mut edits = vec![];\n+    let query: SsrQuery = query.parse()?;\n+    for &root in db.local_roots().iter() {\n+        let sr = db.source_root(root);\n+        for file_id in sr.walk() {\n+            dbg!(db.file_relative_path(file_id));\n+            let matches = find(&query.pattern, db.parse(file_id).tree().syntax());\n+            if !matches.matches.is_empty() {\n+                edits.push(SourceFileEdit { file_id, edit: replace(&matches, &query.template) });\n+            }\n+        }\n+    }\n+    Ok(edits)\n+}\n+\n+#[derive(Debug)]\n+struct SsrQuery {\n+    pattern: SsrPattern,\n+    template: SsrTemplate,\n+}\n+\n+#[derive(Debug)]\n+struct SsrPattern {\n+    pattern: SyntaxNode,\n+    vars: Vec<Var>,\n+}\n+\n+/// represents an `$var` in an SSR query\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+struct Var(String);\n+\n+#[derive(Debug)]\n+struct SsrTemplate {\n+    template: SyntaxNode,\n+    placeholders: FxHashMap<SyntaxNode, Var>,\n+}\n+\n+type Binding = HashMap<Var, SyntaxNode>;\n+\n+#[derive(Debug)]\n+struct Match {\n+    place: SyntaxNode,\n+    binding: Binding,\n+}\n+\n+#[derive(Debug)]\n+struct SsrMatches {\n+    matches: Vec<Match>,\n+}\n+\n+impl FromStr for SsrQuery {\n+    type Err = SsrError;\n+\n+    fn from_str(query: &str) -> Result<SsrQuery, SsrError> {\n+        let mut it = query.split(\"==>>\");\n+        let pattern = it.next().expect(\"at least empty string\").trim();\n+        let mut template =\n+            it.next().ok_or(SsrError(\"Cannot find delemiter `==>>`\".into()))?.trim().to_string();\n+        if it.next().is_some() {\n+            return Err(SsrError(\"More than one delimiter found\".into()));\n+        }\n+        let mut vars = vec![];\n+        let mut it = pattern.split('$');\n+        let mut pattern = it.next().expect(\"something\").to_string();\n+\n+        for part in it.map(split_by_var) {\n+            let (var, var_type, remainder) = part?;\n+            is_expr(var_type)?;\n+            let new_var = create_name(var, &mut vars)?;\n+            pattern.push_str(new_var);\n+            pattern.push_str(remainder);\n+            template = replace_in_template(template, var, new_var);\n+        }\n+\n+        let template = expr_from_text(&template).syntax().clone();\n+        let mut placeholders = FxHashMap::default();\n+\n+        traverse(&template, &mut |n| {\n+            if let Some(v) = vars.iter().find(|v| v.0.as_str() == n.text()) {\n+                placeholders.insert(n.clone(), v.clone());\n+                false\n+            } else {\n+                true\n+            }\n+        });\n+\n+        let pattern = SsrPattern { pattern: expr_from_text(&pattern).syntax().clone(), vars };\n+        let template = SsrTemplate { template, placeholders };\n+        Ok(SsrQuery { pattern, template })\n+    }\n+}\n+\n+fn traverse(node: &SyntaxNode, go: &mut impl FnMut(&SyntaxNode) -> bool) {\n+    if !go(node) {\n+        return;\n+    }\n+    for ref child in node.children() {\n+        traverse(child, go);\n+    }\n+}\n+\n+fn split_by_var(s: &str) -> Result<(&str, &str, &str), SsrError> {\n+    let end_of_name = s.find(\":\").ok_or(SsrError(\"Use $<name>:expr\".into()))?;\n+    let name = &s[0..end_of_name];\n+    is_name(name)?;\n+    let type_begin = end_of_name + 1;\n+    let type_length = s[type_begin..].find(|c| !char::is_ascii_alphanumeric(&c)).unwrap_or(s.len());\n+    let type_name = &s[type_begin..type_begin + type_length];\n+    Ok((name, type_name, &s[type_begin + type_length..]))\n+}\n+\n+fn is_name(s: &str) -> Result<(), SsrError> {\n+    if s.chars().all(|c| c.is_ascii_alphanumeric() || c == '_') {\n+        Ok(())\n+    } else {\n+        Err(SsrError(\"Name can contain only alphanumerics and _\".into()))\n+    }\n+}\n+\n+fn is_expr(s: &str) -> Result<(), SsrError> {\n+    if s == \"expr\" {\n+        Ok(())\n+    } else {\n+        Err(SsrError(\"Only $<name>:expr is supported\".into()))\n+    }\n+}\n+\n+fn replace_in_template(template: String, var: &str, new_var: &str) -> String {\n+    let name = format!(\"${}\", var);\n+    template.replace(&name, new_var)\n+}\n+\n+fn create_name<'a>(name: &str, vars: &'a mut Vec<Var>) -> Result<&'a str, SsrError> {\n+    let sanitized_name = format!(\"__search_pattern_{}\", name);\n+    if vars.iter().any(|a| a.0 == sanitized_name) {\n+        return Err(SsrError(format!(\"Name `{}` repeats more than once\", name)));\n+    }\n+    vars.push(Var(sanitized_name));\n+    Ok(&vars.last().unwrap().0)\n+}\n+\n+fn find(pattern: &SsrPattern, code: &SyntaxNode) -> SsrMatches {\n+    fn check(\n+        pattern: &SyntaxElement,\n+        code: &SyntaxElement,\n+        placeholders: &[Var],\n+        match_: &mut Match,\n+    ) -> bool {\n+        match (pattern, code) {\n+            (SyntaxElement::Token(ref pattern), SyntaxElement::Token(ref code)) => {\n+                pattern.text() == code.text()\n+            }\n+            (SyntaxElement::Node(ref pattern), SyntaxElement::Node(ref code)) => {\n+                if placeholders.iter().find(|&n| n.0.as_str() == pattern.text()).is_some() {\n+                    match_.binding.insert(Var(pattern.text().to_string()), code.clone());\n+                    true\n+                } else {\n+                    pattern.green().children().count() == code.green().children().count()\n+                        && pattern\n+                            .children_with_tokens()\n+                            .zip(code.children_with_tokens())\n+                            .all(|(a, b)| check(&a, &b, placeholders, match_))\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n+    let kind = pattern.pattern.kind();\n+    let matches = code\n+        .descendants_with_tokens()\n+        .filter(|n| n.kind() == kind)\n+        .filter_map(|code| {\n+            let mut match_ =\n+                Match { place: code.as_node().unwrap().clone(), binding: HashMap::new() };\n+            if check(\n+                &SyntaxElement::from(pattern.pattern.clone()),\n+                &code,\n+                &pattern.vars,\n+                &mut match_,\n+            ) {\n+                Some(match_)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect();\n+    SsrMatches { matches }\n+}\n+\n+fn replace(matches: &SsrMatches, template: &SsrTemplate) -> TextEdit {\n+    let mut builder = TextEditBuilder::default();\n+    for match_ in &matches.matches {\n+        builder.replace(match_.place.text_range(), render_replace(&match_.binding, template));\n+    }\n+    builder.finish()\n+}\n+\n+fn render_replace(binding: &Binding, template: &SsrTemplate) -> String {\n+    let mut builder = TextEditBuilder::default();\n+    for element in template.template.descendants() {\n+        if let Some(var) = template.placeholders.get(&element) {\n+            builder.replace(element.text_range(), binding[var].to_string())\n+        }\n+    }\n+    builder.finish().apply(&template.template.text().to_string())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ra_syntax::SourceFile;\n+\n+    fn parse_error_text(query: &str) -> String {\n+        format!(\"{}\", query.parse::<SsrQuery>().unwrap_err())\n+    }\n+\n+    #[test]\n+    fn parser_happy_case() {\n+        let result: SsrQuery = \"foo($a:expr, $b:expr) ==>> bar($b, $a)\".parse().unwrap();\n+        assert_eq!(&result.pattern.pattern.text(), \"foo(__search_pattern_a, __search_pattern_b)\");\n+        assert_eq!(result.pattern.vars.len(), 2);\n+        assert_eq!(result.pattern.vars[0].0, \"__search_pattern_a\");\n+        assert_eq!(result.pattern.vars[1].0, \"__search_pattern_b\");\n+        assert_eq!(&result.template.template.text(), \"bar(__search_pattern_b, __search_pattern_a)\");\n+        dbg!(result.template.placeholders);\n+    }\n+\n+    #[test]\n+    fn parser_empty_query() {\n+        assert_eq!(parse_error_text(\"\"), \"Parse error: Cannot find delemiter `==>>`\");\n+    }\n+\n+    #[test]\n+    fn parser_no_delimiter() {\n+        assert_eq!(parse_error_text(\"foo()\"), \"Parse error: Cannot find delemiter `==>>`\");\n+    }\n+\n+    #[test]\n+    fn parser_two_delimiters() {\n+        assert_eq!(\n+            parse_error_text(\"foo() ==>> a ==>> b \"),\n+            \"Parse error: More than one delimiter found\"\n+        );\n+    }\n+\n+    #[test]\n+    fn parser_no_pattern_type() {\n+        assert_eq!(parse_error_text(\"foo($a) ==>>\"), \"Parse error: Use $<name>:expr\");\n+    }\n+\n+    #[test]\n+    fn parser_invalid_name() {\n+        assert_eq!(\n+            parse_error_text(\"foo($a+:expr) ==>>\"),\n+            \"Parse error: Name can contain only alphanumerics and _\"\n+        );\n+    }\n+\n+    #[test]\n+    fn parser_invalid_type() {\n+        assert_eq!(\n+            parse_error_text(\"foo($a:ident) ==>>\"),\n+            \"Parse error: Only $<name>:expr is supported\"\n+        );\n+    }\n+\n+    #[test]\n+    fn parser_repeated_name() {\n+        assert_eq!(\n+            parse_error_text(\"foo($a:expr, $a:expr) ==>>\"),\n+            \"Parse error: Name `a` repeats more than once\"\n+        );\n+    }\n+\n+    #[test]\n+    fn parse_match_replace() {\n+        let query: SsrQuery = \"foo($x:expr) ==>> bar($x)\".parse().unwrap();\n+        let input = \"fn main() { foo(1+2); }\";\n+\n+        let code = SourceFile::parse(input).tree();\n+        let matches = find(&query.pattern, code.syntax());\n+        assert_eq!(matches.matches.len(), 1);\n+        assert_eq!(matches.matches[0].place.text(), \"foo(1+2)\");\n+        assert_eq!(matches.matches[0].binding.len(), 1);\n+        assert_eq!(\n+            matches.matches[0].binding[&Var(\"__search_pattern_x\".to_string())].text(),\n+            \"1+2\"\n+        );\n+\n+        let edit = replace(&matches, &query.template);\n+        assert_eq!(edit.apply(input), \"fn main() { bar(1+2); }\");\n+    }\n+}"}, {"sha": "061383e28b874406efef77299fb0c040b55ebb29", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -526,6 +526,7 @@ fn on_request(\n         .on::<req::CallHierarchyPrepare>(handlers::handle_call_hierarchy_prepare)?\n         .on::<req::CallHierarchyIncomingCalls>(handlers::handle_call_hierarchy_incoming)?\n         .on::<req::CallHierarchyOutgoingCalls>(handlers::handle_call_hierarchy_outgoing)?\n+        .on::<req::Ssr>(handlers::handle_ssr)?\n         .finish();\n     Ok(())\n }"}, {"sha": "72bb486192210a79961f861bd47c2a8253a05b63", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -881,6 +881,11 @@ pub fn handle_document_highlight(\n     ))\n }\n \n+pub fn handle_ssr(world: WorldSnapshot, params: req::SsrParams) -> Result<req::SourceChange> {\n+    let _p = profile(\"handle_ssr\");\n+    world.analysis().structural_search_replace(&params.arg)??.try_conv_with(&world)\n+}\n+\n pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n     let _p = profile(\"publish_diagnostics\");\n     let line_index = world.analysis().file_line_index(file_id)?;"}, {"sha": "7ff7f60b31f7e879315fc9d4581541321797fc21", "filename": "crates/ra_lsp_server/src/req.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Freq.rs?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -206,3 +206,16 @@ pub struct InlayHint {\n     pub kind: InlayKind,\n     pub label: String,\n }\n+\n+pub enum Ssr {}\n+\n+impl Request for Ssr {\n+    type Params = SsrParams;\n+    type Result = SourceChange;\n+    const METHOD: &'static str = \"rust-analyzer/ssr\";\n+}\n+\n+#[derive(Debug, Deserialize, Serialize)]\n+pub struct SsrParams {\n+    pub arg: String,\n+}"}, {"sha": "89d1403e784d0085283172429098874d0ad89064", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -84,7 +84,7 @@ pub fn expr_prefix(op: SyntaxKind, expr: ast::Expr) -> ast::Expr {\n     let token = token(op);\n     expr_from_text(&format!(\"{}{}\", token, expr.syntax()))\n }\n-fn expr_from_text(text: &str) -> ast::Expr {\n+pub fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n "}, {"sha": "e1a70f05cc6b832e43dbc5bc44f61e60d13cba4a", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -124,6 +124,11 @@\n                 \"command\": \"rust-analyzer.onEnter\",\n                 \"title\": \"Enhanced enter key\",\n                 \"category\": \"Rust Analyzer\"\n+            },\n+            {\n+                \"command\": \"rust-analyzer.ssr\",\n+                \"title\": \"Structural Search Replace\",\n+                \"category\": \"Rust Analyzer\"\n             }\n         ],\n         \"keybindings\": ["}, {"sha": "b5ebec117f3212966c5821a28ddb6035fa6443d6", "filename": "editors/code/src/commands/index.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Findex.ts?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -12,6 +12,7 @@ export * from './parent_module';\n export * from './syntax_tree';\n export * from './expand_macro';\n export * from './runnables';\n+export * from './ssr';\n \n export function collectGarbage(ctx: Ctx): Cmd {\n     return async () => {"}, {"sha": "6287bf47b42d319b248f2c5ade1b1e1713c503e5", "filename": "editors/code/src/commands/ssr.ts", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/editors%2Fcode%2Fsrc%2Fcommands%2Fssr.ts", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/editors%2Fcode%2Fsrc%2Fcommands%2Fssr.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fssr.ts?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -0,0 +1,36 @@\n+import { Ctx, Cmd } from '../ctx';\n+import { applySourceChange, SourceChange } from '../source_change';\n+import * as vscode from 'vscode';\n+\n+export function ssr(ctx: Ctx): Cmd {\n+    return async () => {\n+        const client = ctx.client;\n+        if (!client) return;\n+\n+        const options: vscode.InputBoxOptions = {\n+            placeHolder: \"foo($a:expr, $b:expr) ==>> bar($a, foo($b))\",\n+            prompt: \"Enter request\",\n+            validateInput: (x: string) => {\n+                if (x.includes('==>>')) {\n+                    return null;\n+                }\n+                return \"Enter request: pattern ==>> template\"\n+            }\n+        }\n+        const request = await vscode.window.showInputBox(options);\n+\n+        if (!request) return;\n+\n+        const ssrRequest: SsrRequest = { arg: request };\n+        const change = await client.sendRequest<SourceChange>(\n+            'rust-analyzer/ssr',\n+            ssrRequest,\n+        );\n+\n+        await applySourceChange(ctx, change);\n+    };\n+}\n+\n+interface SsrRequest {\n+    arg: string;\n+}"}, {"sha": "5a99e96f0e51b1f8ff40e6bb2c34d5fe5c3f19ec", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=f8f454ab5c19c6e7d91b3a4e6bb63fb9bf5f2673", "patch": "@@ -22,6 +22,7 @@ export async function activate(context: vscode.ExtensionContext) {\n     ctx.registerCommand('run', commands.run);\n     ctx.registerCommand('reload', commands.reload);\n     ctx.registerCommand('onEnter', commands.onEnter);\n+    ctx.registerCommand('ssr', commands.ssr)\n \n     // Internal commands which are invoked by the server.\n     ctx.registerCommand('runSingle', commands.runSingle);"}]}