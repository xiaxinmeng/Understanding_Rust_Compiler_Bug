{"sha": "e5fdd7b63a7365df015c9d08111a8f635b25e058", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZmRkN2I2M2E3MzY1ZGYwMTVjOWQwODExMWE4ZjYzNWIyNWUwNTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-03T18:05:15Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-03T18:05:15Z"}, "message": "Support while and do-while loops in rustc.", "tree": {"sha": "daa0b7450779173d9eceed343e038424799b645d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daa0b7450779173d9eceed343e038424799b645d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5fdd7b63a7365df015c9d08111a8f635b25e058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5fdd7b63a7365df015c9d08111a8f635b25e058", "html_url": "https://github.com/rust-lang/rust/commit/e5fdd7b63a7365df015c9d08111a8f635b25e058", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5fdd7b63a7365df015c9d08111a8f635b25e058/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc299c9a19cd8e643258f07a485eaeecb3e900b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc299c9a19cd8e643258f07a485eaeecb3e900b9", "html_url": "https://github.com/rust-lang/rust/commit/dc299c9a19cd8e643258f07a485eaeecb3e900b9"}], "stats": {"total": 116, "additions": 116, "deletions": 0}, "files": [{"sha": "32317812f8fbab799fddca8b041c36913423353a", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5fdd7b63a7365df015c9d08111a8f635b25e058/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fdd7b63a7365df015c9d08111a8f635b25e058/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=e5fdd7b63a7365df015c9d08111a8f635b25e058", "patch": "@@ -94,6 +94,8 @@ tag expr_ {\n     expr_lit(@lit, option[@ty]);\n     expr_cast(@expr, @ty);\n     expr_if(@expr, block, option[block], option[@ty]);\n+    expr_while(@expr, block, option[@ty]);\n+    expr_do_while(block, @expr, option[@ty]);\n     expr_block(block, option[@ty]);\n     expr_assign(@expr /* TODO: @expr|is_lval */, @expr, option[@ty]);\n     expr_field(@expr, ident, option[@ty]);"}, {"sha": "7046f4b0da1a6cce5c916019dc789c5a402d357d", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e5fdd7b63a7365df015c9d08111a8f635b25e058/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fdd7b63a7365df015c9d08111a8f635b25e058/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=e5fdd7b63a7365df015c9d08111a8f635b25e058", "patch": "@@ -613,6 +613,33 @@ impure fn parse_if_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ast.expr_if(cond, thn, els, none[@ast.ty]));\n }\n \n+impure fn parse_while_expr(parser p) -> @ast.expr {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+\n+    expect(p, token.WHILE);\n+    expect (p, token.LPAREN);\n+    auto cond = parse_expr(p);\n+    expect(p, token.RPAREN);\n+    auto body = parse_block(p);\n+    hi = body.span;\n+    ret @spanned(lo, hi, ast.expr_while(cond, body, none[@ast.ty]));\n+}\n+\n+impure fn parse_do_while_expr(parser p) -> @ast.expr {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+\n+    expect(p, token.DO);\n+    auto body = parse_block(p);\n+    expect(p, token.WHILE);\n+    expect (p, token.LPAREN);\n+    auto cond = parse_expr(p);\n+    expect(p, token.RPAREN);\n+    hi = cond.span;\n+    ret @spanned(lo, hi, ast.expr_do_while(body, cond, none[@ast.ty]));\n+}\n+\n impure fn parse_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LBRACE) {\n@@ -623,6 +650,12 @@ impure fn parse_expr(parser p) -> @ast.expr {\n         case (token.IF) {\n             ret parse_if_expr(p);\n         }\n+        case (token.WHILE) {\n+            ret parse_while_expr(p);\n+        }\n+        case (token.DO) {\n+            ret parse_do_while_expr(p);\n+        }\n         case (_) {\n             ret parse_assign_expr(p);\n         }\n@@ -741,6 +774,16 @@ impure fn parse_stmt(parser p) -> @ast.stmt {\n             ret @spanned(lo, e.span, ast.stmt_expr(e));\n         }\n \n+        case (token.WHILE) {\n+            auto e = parse_expr(p);\n+            ret @spanned(lo, e.span, ast.stmt_expr(e));\n+        }\n+\n+        case (token.DO) {\n+            auto e = parse_expr(p);\n+            ret @spanned(lo, e.span, ast.stmt_expr(e));\n+        }\n+\n         case (token.LBRACE) {\n             auto e = parse_expr(p);\n             ret @spanned(lo, e.span, ast.stmt_expr(e));"}, {"sha": "c5685680093af9cf14cdc77b8ee54851667ed44e", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e5fdd7b63a7365df015c9d08111a8f635b25e058/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fdd7b63a7365df015c9d08111a8f635b25e058/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=e5fdd7b63a7365df015c9d08111a8f635b25e058", "patch": "@@ -81,6 +81,14 @@ type ast_fold[ENV] =\n          &option[block] els,\n          option[@ty] ty) -> @expr)                fold_expr_if,\n \n+     (fn(&ENV e, &span sp,\n+         @expr cond, &block body,\n+         option[@ty] ty) -> @expr)                fold_expr_while,\n+\n+     (fn(&ENV e, &span sp,\n+         &block body, @expr cond,\n+         option[@ty] ty) -> @expr)                fold_expr_do_while,\n+\n      (fn(&ENV e, &span sp,\n          &block blk, option[@ty] ty) -> @expr)    fold_expr_block,\n \n@@ -335,6 +343,18 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels, t);\n         }\n \n+        case (ast.expr_while(?cnd, ?body, ?t)) {\n+            auto ccnd = fold_expr(env_, fld, cnd);\n+            auto bbody = fold_block(env_, fld, body);\n+            ret fld.fold_expr_while(env_, e.span, ccnd, bbody, t);\n+        }\n+\n+        case (ast.expr_do_while(?body, ?cnd, ?t)) {\n+            auto bbody = fold_block(env_, fld, body);\n+            auto ccnd = fold_expr(env_, fld, cnd);\n+            ret fld.fold_expr_do_while(env_, e.span, bbody, ccnd, t);\n+        }\n+\n         case (ast.expr_block(?b, ?t)) {\n             auto bb = fold_block(env_, fld, b);\n             ret fld.fold_expr_block(env_, e.span, bb, t);\n@@ -598,6 +618,18 @@ fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n     ret @respan(sp, ast.expr_if(cond, thn, els, t));\n }\n \n+fn identity_fold_expr_while[ENV](&ENV env, &span sp,\n+                                 @expr cond, &block body,\n+                                 option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_while(cond, body, t));\n+}\n+\n+fn identity_fold_expr_do_while[ENV](&ENV env, &span sp,\n+                                    &block body, @expr cond,\n+                                    option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_do_while(body, cond, t));\n+}\n+\n fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk,\n                                  option[@ty] t) -> @expr {\n     ret @respan(sp, ast.expr_block(blk, t));\n@@ -765,6 +797,9 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_,_),\n          fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_,_),\n          fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_,_),\n+         fold_expr_while  = bind identity_fold_expr_while[ENV](_,_,_,_,_),\n+         fold_expr_do_while\n+                          = bind identity_fold_expr_do_while[ENV](_,_,_,_,_),\n          fold_expr_block  = bind identity_fold_expr_block[ENV](_,_,_,_),\n          fold_expr_assign = bind identity_fold_expr_assign[ENV](_,_,_,_,_),\n          fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_,_),"}, {"sha": "c5374212f33e96883c642b5c17904dae6cdfb236", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e5fdd7b63a7365df015c9d08111a8f635b25e058/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fdd7b63a7365df015c9d08111a8f635b25e058/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e5fdd7b63a7365df015c9d08111a8f635b25e058", "patch": "@@ -653,6 +653,38 @@ impure fn trans_if(@block_ctxt cx, &ast.expr cond,\n     ret res(next_cx, phi);\n }\n \n+impure fn trans_while(@block_ctxt cx, &ast.expr cond,\n+                      &ast.block body) -> result {\n+\n+    auto cond_cx = new_empty_block_ctxt(cx.fcx);\n+    auto body_cx = new_empty_block_ctxt(cx.fcx);\n+    auto next_cx = new_extension_block_ctxt(cx);\n+\n+    cx.build.Br(cond_cx.llbb);\n+    auto cond_res = trans_expr(cond_cx, cond);\n+    cond_cx.build.CondBr(cond_res.val,\n+                         body_cx.llbb,\n+                         next_cx.llbb);\n+    auto body_res = trans_block(body_cx, body);\n+    body_cx.build.Br(cond_cx.llbb);\n+    ret res(next_cx, C_nil());\n+}\n+\n+impure fn trans_do_while(@block_ctxt cx, &ast.block body,\n+                         &ast.expr cond) -> result {\n+\n+    auto body_cx = new_empty_block_ctxt(cx.fcx);\n+    auto next_cx = new_extension_block_ctxt(cx);\n+\n+    cx.build.Br(body_cx.llbb);\n+    auto body_res = trans_block(body_cx, body);\n+    auto cond_res = trans_expr(body_cx, cond);\n+    body_cx.build.CondBr(cond_res.val,\n+                         body_cx.llbb,\n+                         next_cx.llbb);\n+    ret res(next_cx, body_res.val);\n+}\n+\n // The additional bool returned indicates whether it's a local\n // (that is represented as an alloca, hence needs a 'load' to be\n // used as an rval).\n@@ -723,6 +755,10 @@ impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n             ret trans_if(cx, *cond, thn, els);\n         }\n \n+        case (ast.expr_while(?cond, ?body, _)) {\n+            ret trans_while(cx, *cond, body);\n+        }\n+\n         case (ast.expr_block(?blk, _)) {\n             auto sub_cx = new_empty_block_ctxt(cx.fcx);\n             auto next_cx = new_extension_block_ctxt(cx);"}]}