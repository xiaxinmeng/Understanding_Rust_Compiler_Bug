{"sha": "1440f300d848610b0cb798a735e2c75a94998aa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NDBmMzAwZDg0ODYxMGIwY2I3OThhNzM1ZTJjNzVhOTQ5OThhYTk=", "commit": {"author": {"name": "Cory Sherman", "email": "coryshrmn@gmail.com", "date": "2018-05-24T11:39:35Z"}, "committer": {"name": "Cory Sherman", "email": "coryshrmn@gmail.com", "date": "2018-05-24T12:01:40Z"}, "message": "stabilize RangeBounds collections_range #30877\n\nrename RangeBounds::start() -> start_bound()\nrename RangeBounds::end() -> end_bound()", "tree": {"sha": "02c294e0de1006f3fd964f9e68d427ee400b324f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02c294e0de1006f3fd964f9e68d427ee400b324f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1440f300d848610b0cb798a735e2c75a94998aa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1440f300d848610b0cb798a735e2c75a94998aa9", "html_url": "https://github.com/rust-lang/rust/commit/1440f300d848610b0cb798a735e2c75a94998aa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1440f300d848610b0cb798a735e2c75a94998aa9/comments", "author": {"login": "coryshrmn", "id": 1856203, "node_id": "MDQ6VXNlcjE4NTYyMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/1856203?v=4", "gravatar_id": "", "url": "https://api.github.com/users/coryshrmn", "html_url": "https://github.com/coryshrmn", "followers_url": "https://api.github.com/users/coryshrmn/followers", "following_url": "https://api.github.com/users/coryshrmn/following{/other_user}", "gists_url": "https://api.github.com/users/coryshrmn/gists{/gist_id}", "starred_url": "https://api.github.com/users/coryshrmn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/coryshrmn/subscriptions", "organizations_url": "https://api.github.com/users/coryshrmn/orgs", "repos_url": "https://api.github.com/users/coryshrmn/repos", "events_url": "https://api.github.com/users/coryshrmn/events{/privacy}", "received_events_url": "https://api.github.com/users/coryshrmn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "coryshrmn", "id": 1856203, "node_id": "MDQ6VXNlcjE4NTYyMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/1856203?v=4", "gravatar_id": "", "url": "https://api.github.com/users/coryshrmn", "html_url": "https://github.com/coryshrmn", "followers_url": "https://api.github.com/users/coryshrmn/followers", "following_url": "https://api.github.com/users/coryshrmn/following{/other_user}", "gists_url": "https://api.github.com/users/coryshrmn/gists{/gist_id}", "starred_url": "https://api.github.com/users/coryshrmn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/coryshrmn/subscriptions", "organizations_url": "https://api.github.com/users/coryshrmn/orgs", "repos_url": "https://api.github.com/users/coryshrmn/repos", "events_url": "https://api.github.com/users/coryshrmn/events{/privacy}", "received_events_url": "https://api.github.com/users/coryshrmn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4463d788bfd30b622a87a0e6f8e9271b9102e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4463d788bfd30b622a87a0e6f8e9271b9102e50", "html_url": "https://github.com/rust-lang/rust/commit/b4463d788bfd30b622a87a0e6f8e9271b9102e50"}], "stats": {"total": 168, "additions": 68, "deletions": 100}, "files": [{"sha": "28c42144b2af540f6e3905325bd309964717946c", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=1440f300d848610b0cb798a735e2c75a94998aa9", "patch": "@@ -1834,7 +1834,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n      Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>)\n         where Q: Ord, K: Borrow<Q>\n {\n-    match (range.start(), range.end()) {\n+    match (range.start_bound(), range.end_bound()) {\n         (Excluded(s), Excluded(e)) if s==e =>\n             panic!(\"range start and end are equal and excluded in BTreeMap\"),\n         (Included(s), Included(e)) |\n@@ -1852,7 +1852,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     let mut diverged = false;\n \n     loop {\n-        let min_edge = match (min_found, range.start()) {\n+        let min_edge = match (min_found, range.start_bound()) {\n             (false, Included(key)) => match search::search_linear(&min_node, key) {\n                 (i, true) => { min_found = true; i },\n                 (i, false) => i,\n@@ -1866,7 +1866,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n             (true, Excluded(_)) => 0,\n         };\n \n-        let max_edge = match (max_found, range.end()) {\n+        let max_edge = match (max_found, range.end_bound()) {\n             (false, Included(key)) => match search::search_linear(&max_node, key) {\n                 (i, true) => { max_found = true; i+1 },\n                 (i, false) => i,"}, {"sha": "a988b6a26d9df9e2038c6425581ad38d45c29db5", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=1440f300d848610b0cb798a735e2c75a94998aa9", "patch": "@@ -1493,12 +1493,12 @@ impl String {\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded => len,\n@@ -1551,12 +1551,12 @@ impl String {\n         // Replace_range does not have the memory safety issues of a vector Splice.\n         // of the vector version. The data is just plain bytes.\n \n-        match range.start() {\n+        match range.start_bound() {\n              Included(&n) => assert!(self.is_char_boundary(n)),\n              Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n              Unbounded => {},\n         };\n-        match range.end() {\n+        match range.end_bound() {\n              Included(&n) => assert!(self.is_char_boundary(n + 1)),\n              Excluded(&n) => assert!(self.is_char_boundary(n)),\n              Unbounded => {},"}, {"sha": "b5739e1a825538ceffa016bd3f2a550d5e39ae28", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=1440f300d848610b0cb798a735e2c75a94998aa9", "patch": "@@ -1166,12 +1166,12 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded    => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded    => len,"}, {"sha": "e917a65c9c5ad51c8c7e6576245a0f7c65ae28c0", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=1440f300d848610b0cb798a735e2c75a94998aa9", "patch": "@@ -980,12 +980,12 @@ impl<T> VecDeque<T> {\n         // and the head/tail values will be restored correctly.\n         //\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded    => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded    => len,"}, {"sha": "01e279589da98453c32a0293493164b4b25dc215", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 53, "deletions": 85, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=1440f300d848610b0cb798a735e2c75a94998aa9", "patch": "@@ -588,14 +588,12 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n /// `Bound`s are range endpoints:\n ///\n /// ```\n-/// #![feature(collections_range)]\n-///\n /// use std::ops::Bound::*;\n /// use std::ops::RangeBounds;\n ///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n+/// assert_eq!((..100).start_bound(), Unbounded);\n+/// assert_eq!((1..12).start_bound(), Included(&1));\n+/// assert_eq!((1..12).end_bound(), Excluded(&12));\n /// ```\n ///\n /// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n@@ -632,9 +630,7 @@ pub enum Bound<T> {\n     Unbounded,\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b` or `c..d`.\n pub trait RangeBounds<T: ?Sized> {\n@@ -645,17 +641,16 @@ pub trait RangeBounds<T: ?Sized> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections_range)]\n-    ///\n     /// # fn main() {\n     /// use std::ops::Bound::*;\n     /// use std::ops::RangeBounds;\n     ///\n-    /// assert_eq!((..10).start(), Unbounded);\n-    /// assert_eq!((3..10).start(), Included(&3));\n+    /// assert_eq!((..10).start_bound(), Unbounded);\n+    /// assert_eq!((3..10).start_bound(), Included(&3));\n     /// # }\n     /// ```\n-    fn start(&self) -> Bound<&T>;\n+    #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n+    fn start_bound(&self) -> Bound<&T>;\n \n     /// End index bound.\n     ///\n@@ -664,17 +659,16 @@ pub trait RangeBounds<T: ?Sized> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections_range)]\n-    ///\n     /// # fn main() {\n     /// use std::ops::Bound::*;\n     /// use std::ops::RangeBounds;\n     ///\n-    /// assert_eq!((3..).end(), Unbounded);\n-    /// assert_eq!((3..10).end(), Excluded(&10));\n+    /// assert_eq!((3..).end_bound(), Unbounded);\n+    /// assert_eq!((3..10).end_bound(), Excluded(&10));\n     /// # }\n     /// ```\n-    fn end(&self) -> Bound<&T>;\n+    #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n+    fn end_bound(&self) -> Bound<&T>;\n \n \n     /// Returns `true` if `item` is contained in the range.\n@@ -699,13 +693,13 @@ pub trait RangeBounds<T: ?Sized> {\n         T: PartialOrd<U>,\n         U: ?Sized + PartialOrd<T>,\n     {\n-        (match self.start() {\n+        (match self.start_bound() {\n             Included(ref start) => *start <= item,\n             Excluded(ref start) => *start < item,\n             Unbounded => true,\n         })\n         &&\n-        (match self.end() {\n+        (match self.end_bound() {\n             Included(ref end) => item <= *end,\n             Excluded(ref end) => item < *end,\n             Unbounded => true,\n@@ -715,91 +709,77 @@ pub trait RangeBounds<T: ?Sized> {\n \n use self::Bound::{Excluded, Included, Unbounded};\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T: ?Sized> RangeBounds<T> for RangeFull {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for RangeFrom<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for RangeTo<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Excluded(&self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for Range<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Excluded(&self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for RangeInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Included(&self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for RangeToInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Included(&self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         match *self {\n             (Included(ref start), _) => Included(start),\n             (Excluded(ref start), _) => Excluded(start),\n             (Unbounded, _)           => Unbounded,\n         }\n     }\n \n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         match *self {\n             (_, Included(ref end)) => Included(end),\n             (_, Excluded(ref end)) => Excluded(end),\n@@ -808,75 +788,63 @@ impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         self.0\n     }\n \n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         self.1\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for RangeFrom<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for RangeTo<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Excluded(self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for Range<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Excluded(self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for RangeInclusive<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Included(self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for RangeToInclusive<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Included(self.end)\n     }\n }"}, {"sha": "56bb961324210620f35a50afd74f51a34cd14d15", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=1440f300d848610b0cb798a735e2c75a94998aa9", "patch": "@@ -119,12 +119,12 @@ impl<A: Array> ArrayVec<A> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded    => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded    => len,"}, {"sha": "f7e7d6405fce24074c595237277c217fccac05f0", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1440f300d848610b0cb798a735e2c75a94998aa9/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=1440f300d848610b0cb798a735e2c75a94998aa9", "patch": "@@ -214,7 +214,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n     fn range_slice_indices<R>(&self, range: R) -> (usize, usize)\n         where R: RangeBounds<K>\n     {\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Bound::Included(ref k) => {\n                 match self.lookup_index_for(k) {\n                     Ok(index) | Err(index) => index\n@@ -229,7 +229,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n             Bound::Unbounded => 0,\n         };\n \n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Bound::Included(ref k) => {\n                 match self.lookup_index_for(k) {\n                     Ok(index) => index + 1,"}]}