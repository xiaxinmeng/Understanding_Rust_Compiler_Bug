{"sha": "584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NGQ4MjNiZjJjMzA5Y2I3YjQwYWFkZDlkNTVlY2M3NWY3ZWI5ZmM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-01T02:51:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-01T03:00:20Z"}, "message": "Handle closures.  Add some more tests.", "tree": {"sha": "92cdee27392162888c70fe08b26831823938648e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92cdee27392162888c70fe08b26831823938648e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc", "html_url": "https://github.com/rust-lang/rust/commit/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e73d3145f57817ff91468107fc8cad3c6d6616e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e73d3145f57817ff91468107fc8cad3c6d6616e1", "html_url": "https://github.com/rust-lang/rust/commit/e73d3145f57817ff91468107fc8cad3c6d6616e1"}], "stats": {"total": 170, "additions": 156, "deletions": 14}, "files": [{"sha": "6f136624f0ac51ecfdeb2dae119e8e5c8ae2e8a8", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc", "patch": "@@ -87,6 +87,17 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n     use rustc::hir::intravisit::{self, Visitor};\n     use rustc::hir::map::Node;\n \n+    fn block_is_unsafe(block: &hir::Block) -> bool {\n+        use rustc::hir::BlockCheckMode::*;\n+\n+        match block.rules {\n+            UnsafeBlock(_) | PushUnsafeBlock(_) => true,\n+            // For PopUnsafeBlock, we don't actually know -- but we will always also check all\n+            // parent blocks, so we can safely declare the PopUnsafeBlock to not be unsafe.\n+            DefaultBlock | PopUnsafeBlock(_) => false,\n+        }\n+    }\n+\n     let fn_node_id = match src {\n         MirSource::Fn(node_id) => node_id,\n         _ => return false, // only functions can have unsafe\n@@ -101,8 +112,35 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n     match tcx.hir.find(fn_node_id) {\n         Some(Node::NodeItem(item)) => finder.visit_item(item),\n         Some(Node::NodeImplItem(item)) => finder.visit_impl_item(item),\n+        Some(Node::NodeExpr(item)) => {\n+            // This is a closure.\n+            // We also have to walk up the parents and check that there is no unsafe block\n+            // there.\n+            let mut cur = fn_node_id;\n+            loop {\n+                // Go further upwards.\n+                let parent = tcx.hir.get_parent_node(cur);\n+                if cur == parent {\n+                    break;\n+                }\n+                cur = parent;\n+                // Check if this is a a block\n+                match tcx.hir.find(cur) {\n+                    Some(Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block), ..})) => {\n+                        if block_is_unsafe(&*block) {\n+                            // We can bail out here.\n+                            return true;\n+                        }\n+                    }\n+                    _ => {},\n+                }\n+            }\n+            // Finally, visit the closure itself.\n+            finder.visit_expr(item);\n+        }\n         Some(_) | None =>\n-            bug!(\"Expected method or function, found {}\", tcx.hir.node_to_string(fn_node_id)),\n+            bug!(\"Expected function, method or closure, found {}\",\n+                 tcx.hir.node_to_string(fn_node_id)),\n     };\n \n     impl<'b, 'tcx> Visitor<'tcx> for FindUnsafe<'b, 'tcx> {\n@@ -113,7 +151,7 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n         fn visit_fn(&mut self, fk: intravisit::FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n                     b: hir::BodyId, s: Span, id: NodeId)\n         {\n-            assert!(!self.found_unsafe, \"We should never see more than one fn\");\n+            assert!(!self.found_unsafe, \"We should never see a fn when we already saw unsafe\");\n             let is_unsafe = match fk {\n                 intravisit::FnKind::ItemFn(_, _, unsafety, ..) => unsafety == hir::Unsafety::Unsafe,\n                 intravisit::FnKind::Method(_, sig, ..) => sig.unsafety == hir::Unsafety::Unsafe,\n@@ -129,20 +167,15 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n         }\n \n         fn visit_block(&mut self, b: &'tcx hir::Block) {\n-            use rustc::hir::BlockCheckMode::*;\n-\n             if self.found_unsafe { return; } // short-circuit\n \n-            match b.rules {\n-                UnsafeBlock(_) | PushUnsafeBlock(_) => {\n-                    // We found an unsafe block.\n-                    self.found_unsafe = true;\n-                }\n-                DefaultBlock | PopUnsafeBlock(_) => {\n-                    // No unsafe block here, go on searching.\n-                    intravisit::walk_block(self, b);\n-                }\n-            };\n+            if block_is_unsafe(b) {\n+                // We found an unsafe block.  We can stop searching.\n+                self.found_unsafe = true;\n+            } else {\n+                // No unsafe block here, go on searching.\n+                intravisit::walk_block(self, b);\n+            }\n         }\n     }\n "}, {"sha": "b85d9261e4a913e890496bc499d1c887aae0561e", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc", "patch": "@@ -21,8 +21,15 @@ impl Test {\n fn main() {\n     let mut x = 0;\n     Test.foo(&mut x);\n+\n+    // Also test closures\n+    let c = |x: &mut i32| { let y = &*x; *y };\n+    c(&mut x);\n }\n \n+// FIXME: Also test code generated inside the closure, make sure it has validation.  Unfortunately,\n+// the interesting lines of code also contain name of the source file, so we cannot test for it.\n+\n // END RUST SOURCE\n // START rustc.node10.EraseRegions.after.mir\n //     bb0: {"}, {"sha": "49acaccd86ab795dc0c4d37ee126b814b1f0c2aa", "filename": "src/test/mir-opt/validate_4.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+// Make sure unsafe fns and fns with an unsafe block only get restricted validation.\n+\n+unsafe fn write_42(x: *mut i32) -> bool {\n+    *x = 42;\n+    true\n+}\n+\n+fn test(x: &mut i32) {\n+    unsafe { write_42(x) };\n+}\n+\n+fn main() {\n+    test(&mut 0);\n+\n+    let test_closure = unsafe { |x: &mut i32| write_42(x) };\n+    test_closure(&mut 0);\n+}\n+\n+// FIXME: Also test code generated inside the closure, make sure it only does restricted validation\n+// because it is entirely inside an unsafe block.  Unfortunately, the interesting lines of code also\n+// contain name of the source file, so we cannot test for it.\n+\n+// END RUST SOURCE\n+// START rustc.node4.EraseRegions.after.mir\n+// fn write_42(_1: *mut i32) -> bool {\n+//     bb0: {\n+//         Validate(Acquire, [_1: *mut i32]);\n+//         Validate(Release, [_1: *mut i32]);\n+//         return;\n+//     }\n+// }\n+// END rustc.node4.EraseRegions.after.mir\n+// START rustc.node17.EraseRegions.after.mir\n+// fn test(_1: &ReErased mut i32) -> () {\n+//     bb0: {\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_4/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_4/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         _3 = const write_42(_4) -> bb1;\n+//     }\n+//     bb1: {\n+//         Validate(Acquire, [_3: bool]);\n+//         Validate(Release, [_3: bool]);\n+//     }\n+// }\n+// END rustc.node17.EraseRegions.after.mir"}, {"sha": "1831f9dd713f97f06b257c96f37a12b9fb3de167", "filename": "src/test/mir-opt/validate_5.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=584d823bf2c309cb7b40aadd9d55ecc75f7eb9fc", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=2\n+\n+// Make sure unsafe fns and fns with an unsafe block only get full validation.\n+\n+unsafe fn write_42(x: *mut i32) -> bool {\n+    *x = 42;\n+    true\n+}\n+\n+fn test(x: &mut i32) {\n+    unsafe { write_42(x) };\n+}\n+\n+fn main() {\n+    test(&mut 0);\n+\n+    let test_closure = unsafe { |x: &mut i32| write_42(x) };\n+    test_closure(&mut 0);\n+}\n+\n+// FIXME: Also test code generated inside the closure, make sure it has validation.  Unfortunately,\n+// the interesting lines of code also contain name of the source file, so we cannot test for it.\n+\n+// END RUST SOURCE\n+// START rustc.node17.EraseRegions.after.mir\n+// fn test(_1: &ReErased mut i32) -> () {\n+//     bb0: {\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_5/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_4: *mut i32]);\n+//         _3 = const write_42(_4) -> bb1;\n+//     }\n+// }\n+// END rustc.node17.EraseRegions.after.mir"}]}