{"sha": "f5a64a678f7e5942b42781573683640952498b28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1YTY0YTY3OGY3ZTU5NDJiNDI3ODE1NzM2ODM2NDA5NTI0OThiMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-20T16:21:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-20T16:21:43Z"}, "message": "Auto merge of #28499 - semmaz:doc-anchor-fix, r=steveklabnik\n\nThis changes how rustic generate `id` and `href` attributes for section header anchor. Now they are more github-like.\r\n\r\nAlso fixes breakage in docs caused by this and broken links in \"Error Handling\" section of book.\r\n\r\nr? @steveklabnik\r\ncc @alexcrichton", "tree": {"sha": "3044947cbc17ba2755389aea6ecadddf33094d22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3044947cbc17ba2755389aea6ecadddf33094d22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5a64a678f7e5942b42781573683640952498b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5a64a678f7e5942b42781573683640952498b28", "html_url": "https://github.com/rust-lang/rust/commit/f5a64a678f7e5942b42781573683640952498b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5a64a678f7e5942b42781573683640952498b28/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aed5c3a1c876189c86dfb702bd7a73b209c87ae0", "url": "https://api.github.com/repos/rust-lang/rust/commits/aed5c3a1c876189c86dfb702bd7a73b209c87ae0", "html_url": "https://github.com/rust-lang/rust/commit/aed5c3a1c876189c86dfb702bd7a73b209c87ae0"}, {"sha": "09c1ce18a2711627da621b423d3291d01bc12c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/09c1ce18a2711627da621b423d3291d01bc12c85", "html_url": "https://github.com/rust-lang/rust/commit/09c1ce18a2711627da621b423d3291d01bc12c85"}], "stats": {"total": 173, "additions": 93, "deletions": 80}, "files": [{"sha": "a404d25bf370353cc5f07202ad531d653ce9b2c9", "filename": "src/doc/style/errors/ergonomics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a64a678f7e5942b42781573683640952498b28/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/f5a64a678f7e5942b42781573683640952498b28/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md?ref=f5a64a678f7e5942b42781573683640952498b28", "patch": "@@ -57,7 +57,7 @@ fn write_info(info: &Info) -> Result<(), IoError> {\n ```\n \n See\n-[the `result` module documentation](https://doc.rust-lang.org/stable/std/result/index.html#the-try!-macro)\n+[the `result` module documentation](https://doc.rust-lang.org/stable/std/result/index.html#the-try-macro)\n for more details.\n \n ### The `Result`-`impl` pattern [FIXME]"}, {"sha": "26ffda50ac53dc1a06b30dae8e7b0fc4e2a82d52", "filename": "src/doc/style/features/traits/generics.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5a64a678f7e5942b42781573683640952498b28/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/f5a64a678f7e5942b42781573683640952498b28/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md?ref=f5a64a678f7e5942b42781573683640952498b28", "patch": "@@ -27,7 +27,7 @@ explicitly implement to be used by this generic function.\n * _Inference_. Since the type parameters to generic functions can usually be\n   inferred, generic functions can help cut down on verbosity in code where\n   explicit conversions or other method calls would usually be necessary. See the\n-  [overloading/implicits use case](#use-case:-limited-overloading-and/or-implicit-conversions)\n+  [overloading/implicits use case](#use-case-limited-overloading-andor-implicit-conversions)\n   below.\n * _Precise types_. Because generics give a _name_ to the specific type\n   implementing a trait, it is possible to be precise about places where that\n@@ -51,7 +51,7 @@ explicitly implement to be used by this generic function.\n   a `Vec<T>` contains elements of a single concrete type (and, indeed, the\n   vector representation is specialized to lay these out in line). Sometimes\n   heterogeneous collections are useful; see\n-  [trait objects](#use-case:-trait-objects) below.\n+  [trait objects](#use-case-trait-objects) below.\n * _Signature verbosity_. Heavy use of generics can bloat function signatures.\n   **[Ed. note]** This problem may be mitigated by some language improvements; stay tuned.\n "}, {"sha": "47d41a155e4ca4183eb16231464e748754ceb376", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f5a64a678f7e5942b42781573683640952498b28/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/f5a64a678f7e5942b42781573683640952498b28/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=f5a64a678f7e5942b42781573683640952498b28", "patch": "@@ -24,28 +24,28 @@ systems may want to jump around.\n * [The Basics](#the-basics)\n     * [Unwrapping explained](#unwrapping-explained)\n     * [The `Option` type](#the-option-type)\n-        * [Composing `Option<T>` values](#composing-option<t>-values)\n+        * [Composing `Option<T>` values](#composing-optiont-values)\n     * [The `Result` type](#the-result-type)\n         * [Parsing integers](#parsing-integers)\n         * [The `Result` type alias idiom](#the-result-type-alias-idiom)\n-    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude:-unwrapping-isn't-evil)\n+    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isn't-evil)\n * [Working with multiple error types](#working-with-multiple-error-types)\n     * [Composing `Option` and `Result`](#composing-option-and-result)\n     * [The limits of combinators](#the-limits-of-combinators)\n     * [Early returns](#early-returns)\n-    * [The `try!` macro](#the-try!-macro)\n+    * [The `try!` macro](#the-try-macro)\n     * [Defining your own error type](#defining-your-own-error-type)\n * [Standard library traits used for error handling](#standard-library-traits-used-for-error-handling)\n     * [The `Error` trait](#the-error-trait)\n     * [The `From` trait](#the-from-trait)\n-    * [The real `try!` macro](#the-real-try!-macro)\n+    * [The real `try!` macro](#the-real-try-macro)\n     * [Composing custom error types](#composing-custom-error-types)\n     * [Advice for library writers](#advice-for-library-writers)\n-* [Case study: A program to read population data](#case-study:-a-program-to-read-population-data)\n+* [Case study: A program to read population data](#case-study-a-program-to-read-population-data)\n     * [Initial setup](#initial-setup)\n     * [Argument parsing](#argument-parsing)\n     * [Writing the logic](#writing-the-logic)\n-    * [Error handling with `Box<Error>`](#error-handling-with-box%3Cerror%3E)\n+    * [Error handling with `Box<Error>`](#error-handling-with-boxerror)\n     * [Reading from stdin](#reading-from-stdin)\n     * [Error handling with a custom type](#error-handling-with-a-custom-type)\n     * [Adding functionality](#adding-functionality)\n@@ -87,7 +87,7 @@ thread '<main>' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5\n Here's another example that is slightly less contrived. A program that accepts\n an integer as an argument, doubles it and prints it.\n \n-<a name=\"code-unwrap-double\"></a>\n+<span id=\"code-unwrap-double\"></span>\n \n ```rust,should_panic\n use std::env;\n@@ -139,7 +139,7 @@ system is an important concept because it will cause the compiler to force the\n programmer to handle that absence. Let's take a look at an example that tries\n to find a character in a string:\n \n-<a name=\"code-option-ex-string-find\"></a>\n+<span id=\"code-option-ex-string-find\"></span>\n \n ```rust\n // Searches `haystack` for the Unicode character `needle`. If one is found, the\n@@ -186,7 +186,7 @@ But wait, what about `unwrap` used in [`unwrap-double`](#code-unwrap-double)?\n There was no case analysis there! Instead, the case analysis was put inside the\n `unwrap` method for you. You could define it yourself if you want:\n \n-<a name=\"code-option-def-unwrap\"></a>\n+<span id=\"code-option-def-unwrap\"></span>\n \n ```rust\n enum Option<T> {\n@@ -253,7 +253,7 @@ option is `None`, in which case, just return `None`.\n Rust has parametric polymorphism, so it is very easy to define a combinator\n that abstracts this pattern:\n \n-<a name=\"code-option-map\"></a>\n+<span id=\"code-option-map\"></span>\n \n ```rust\n fn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {\n@@ -394,7 +394,7 @@ remove choices because they will panic if `Option<T>` is `None`.\n The `Result` type is also\n [defined in the standard library][6]:\n \n-<a name=\"code-result-def-1\"></a>\n+<span id=\"code-result-def\"></span>\n \n ```rust\n enum Result<T, E> {\n@@ -562,7 +562,7 @@ combinators that affect only the error type, such as\n ### The `Result` type alias idiom\n \n In the standard library, you may frequently see types like\n-`Result<i32>`. But wait, [we defined `Result`](#code-result-def-1) to\n+`Result<i32>`. But wait, [we defined `Result`](#code-result-def) to\n have two type parameters. How can we get away with only specifying\n one? The key is to define a `Result` type alias that *fixes* one of\n the type parameters to a particular type. Usually the fixed type is\n@@ -672,7 +672,7 @@ with both an `Option` and a `Result`, the solution is *usually* to convert the\n (from `env::args()`) means the user didn't invoke the program correctly. We\n could just use a `String` to describe the error. Let's try:\n \n-<a name=\"code-error-double-string\"></a>\n+<span id=\"code-error-double-string\"></span>\n \n ```rust\n use std::env;\n@@ -906,7 +906,7 @@ seen above.\n \n Here is a simplified definition of a `try!` macro:\n \n-<a nama name=\"code-try-def-simple\"></a>\n+<span id=\"code-try-def-simple\"></span>\n \n ```rust\n macro_rules! try {\n@@ -1168,7 +1168,7 @@ The `std::convert::From` trait is\n [defined in the standard\n library](../std/convert/trait.From.html):\n \n-<a name=\"code-from-def\"></a>\n+<span id=\"code-from-def\"></span>\n \n ```rust\n trait From<T> {\n@@ -1250,7 +1250,7 @@ macro_rules! try {\n This is not its real definition. Its real definition is\n [in the standard library](../std/macro.try!.html):\n \n-<a name=\"code-try-def\"></a>\n+<span id=\"code-try-def\"></span>\n \n ```rust\n macro_rules! try {\n@@ -1515,7 +1515,7 @@ and [`rustc-serialize`](https://crates.io/crates/rustc-serialize) crates.\n \n We're not going to spend a lot of time on setting up a project with\n Cargo because it is already covered well in [the Cargo\n-chapter](../book/hello-cargo) and [Cargo's documentation][14].\n+chapter](../book/hello-cargo.html) and [Cargo's documentation][14].\n \n To get started from scratch, run `cargo new --bin city-pop` and make sure your\n `Cargo.toml` looks something like this:\n@@ -1573,7 +1573,7 @@ fn main() {\n \n     let mut opts = Options::new();\n     opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n-    \n+\n     let matches = match opts.parse(&args[1..]) {\n         Ok(m)  => { m }\n \tErr(e) => { panic!(e.to_string()) }\n@@ -1584,7 +1584,7 @@ fn main() {\n     }\n     let data_path = args[1].clone();\n     let city = args[2].clone();\n-\t\n+\n \t// Do stuff with information\n }\n ```\n@@ -1647,27 +1647,27 @@ fn main() {\n \n     let mut opts = Options::new();\n     opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n-    \n+\n     let matches = match opts.parse(&args[1..]) {\n         Ok(m)  => { m }\n \t\tErr(e) => { panic!(e.to_string()) }\n     };\n-\t\n+\n     if matches.opt_present(\"h\") {\n         print_usage(&program, opts);\n \t\treturn;\n \t}\n-\t\t\n+\n \tlet data_file = args[1].clone();\n \tlet data_path = Path::new(&data_file);\n \tlet city = args[2].clone();\n-\t\n+\n \tlet file = fs::File::open(data_path).unwrap();\n \tlet mut rdr = csv::Reader::from_reader(file);\n-\t\n+\n \tfor row in rdr.decode::<Row>() {\n \t\tlet row = row.unwrap();\n-\t\n+\n \t\tif row.city == city {\n \t\t\tprintln!(\"{}, {}: {:?}\",\n \t\t\t\trow.city, row.country,\n@@ -1773,7 +1773,7 @@ fn main() {\n \t\tprint_usage(&program, opts);\n \t\treturn;\n \t}\n-\t\t\n+\n \tlet data_file = args[1].clone();\n \tlet data_path = Path::new(&data_file);\n \tlet city = args[2].clone();\n@@ -1882,7 +1882,7 @@ opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n ...\n let file = matches.opt_str(\"f\");\n let data_file = file.as_ref().map(Path::new);\n-\t\n+\n let city = if !matches.free.is_empty() {\n \tmatches.free[0].clone()\n } else {"}, {"sha": "f68e82501e91ea4d9123b85d25933553edf4da86", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f5a64a678f7e5942b42781573683640952498b28/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a64a678f7e5942b42781573683640952498b28/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=f5a64a678f7e5942b42781573683640952498b28", "patch": "@@ -207,9 +207,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n ///\n /// Any leading or trailing whitespace will be trimmed.\n fn collapse_whitespace(s: &str) -> String {\n-    s.split(|c: char| c.is_whitespace()).filter(|s| {\n-        !s.is_empty()\n-    }).collect::<Vec<_>>().join(\" \")\n+    s.split_whitespace().collect::<Vec<_>>().join(\" \")\n }\n \n thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, usize>> = {\n@@ -277,25 +275,44 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         // Extract the text provided\n         let s = if text.is_null() {\n-            \"\".to_string()\n+            \"\".to_owned()\n         } else {\n             let s = unsafe { (*text).as_bytes() };\n-            str::from_utf8(s).unwrap().to_string()\n+            str::from_utf8(&s).unwrap().to_owned()\n         };\n \n-        // Transform the contents of the header into a hyphenated string\n-        let id = s.split_whitespace().map(|s| s.to_ascii_lowercase())\n-            .collect::<Vec<String>>().join(\"-\");\n-\n+        // Discard '<em>', '<code>' tags and some escaped characters,\n+        // transform the contents of the header into a hyphenated string\n+        // without non-alphanumeric characters other than '-' and '_'.\n+        //\n         // This is a terrible hack working around how hoedown gives us rendered\n         // html for text rather than the raw text.\n+        let mut id = s.clone();\n+        let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n+                            \"<strong>\", \"</strong>\",\n+                            \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n+        for sub in repl_sub {\n+            id = id.replace(sub, \"\");\n+        }\n+        let id = id.chars().filter_map(|c| {\n+            if c.is_alphanumeric() || c == '-' || c == '_' {\n+                if c.is_ascii() {\n+                    Some(c.to_ascii_lowercase())\n+                } else {\n+                    Some(c)\n+                }\n+            } else if c.is_whitespace() && c.is_ascii() {\n+                Some('-')\n+            } else {\n+                None\n+            }\n+        }).collect::<String>();\n \n         let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n         let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n \n         // Make sure our hyphenated ID is unique for this page\n         let id = USED_HEADER_MAP.with(|map| {\n-            let id = id.replace(\"<code>\", \"\").replace(\"</code>\", \"\").to_string();\n             let id = match map.borrow_mut().get_mut(&id) {\n                 None => id,\n                 Some(a) => { *a += 1; format!(\"{}-{}\", id, *a - 1) }\n@@ -304,22 +321,15 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n             id\n         });\n \n-        let sec = match opaque.toc_builder {\n-            Some(ref mut builder) => {\n-                builder.push(level as u32, s.clone(), id.clone())\n-            }\n-            None => {\"\"}\n-        };\n+\n+        let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n+            format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n+        });\n \n         // Render the HTML\n-        let text = format!(r##\"<h{lvl} id=\"{id}\" class='section-header'><a\n-                           href=\"#{id}\">{sec}{}</a></h{lvl}>\"##,\n-                           s, lvl = level, id = id,\n-                           sec = if sec.is_empty() {\n-                               sec.to_string()\n-                           } else {\n-                               format!(\"{} \", sec)\n-                           });\n+        let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n+                           <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n+                           s, lvl = level, id = id, sec = sec);\n \n         let text = CString::new(text).unwrap();\n         unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n@@ -333,7 +343,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         _: *const hoedown_renderer_data,\n     ) -> libc::c_int {\n         let content = if text.is_null() {\n-            \"\".to_string()\n+            \"\".to_owned()\n         } else {\n             let bytes = unsafe { (*text).as_bytes() };\n             let s = str::from_utf8(bytes).unwrap();\n@@ -367,10 +377,9 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         hoedown_html_renderer_free(renderer);\n \n-        let mut ret = match opaque.toc_builder {\n-            Some(b) => write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", b.into_toc()),\n-            None => Ok(())\n-        };\n+        let mut ret = opaque.toc_builder.map_or(Ok(()), |builder| {\n+            write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n+        });\n \n         if ret.is_ok() {\n             let buf = (*ob).as_bytes();\n@@ -404,7 +413,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                 stripped_filtered_line(l).unwrap_or(l)\n             });\n             let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-            tests.add_test(text.to_string(),\n+            tests.add_test(text.to_owned(),\n                            block_info.should_panic, block_info.no_run,\n                            block_info.ignore, block_info.test_harness);\n         }\n@@ -560,10 +569,7 @@ pub fn plain_summary_line(md: &str) -> String {\n                                 md.len() as libc::size_t);\n         hoedown_document_free(document);\n         let plain_slice = (*ob).as_bytes();\n-        let plain = match str::from_utf8(plain_slice) {\n-            Ok(s) => s.to_string(),\n-            Err(_) => \"\".to_string(),\n-        };\n+        let plain = str::from_utf8(plain_slice).unwrap_or(\"\").to_owned();\n         hoedown_buffer_free(ob);\n         plain\n     }\n@@ -572,7 +578,7 @@ pub fn plain_summary_line(md: &str) -> String {\n #[cfg(test)]\n mod tests {\n     use super::{LangString, Markdown};\n-    use super::{collapse_whitespace, plain_summary_line};\n+    use super::plain_summary_line;\n \n     #[test]\n     fn test_lang_string_parse() {\n@@ -607,6 +613,27 @@ mod tests {\n         format!(\"{}\", Markdown(markdown));\n     }\n \n+    #[test]\n+    fn test_header() {\n+        fn t(input: &str, expect: &str) {\n+            let output = format!(\"{}\", Markdown(input));\n+            assert_eq!(output, expect);\n+        }\n+\n+        t(\"# Foo bar\", \"\\n<h1 id='foo-bar' class='section-header'>\\\n+          <a href='#foo-bar'>Foo bar</a></h1>\");\n+        t(\"## Foo-bar_baz qux\", \"\\n<h2 id='foo-bar_baz-qux' class=\\'section-\\\n+          header'><a href='#foo-bar_baz-qux'>Foo-bar_baz qux</a></h2>\");\n+        t(\"### **Foo** *bar* baz!?!& -_qux_-%\",\n+          \"\\n<h3 id='foo-bar-baz--_qux_-' class='section-header'>\\\n+          <a href='#foo-bar-baz--_qux_-'><strong>Foo</strong> \\\n+          <em>bar</em> baz!?!&amp; -_qux_-%</a></h3>\");\n+        t(\"####**Foo?** & \\\\*bar?!*  _`baz`_ \u2764 #qux\",\n+          \"\\n<h4 id='foo--bar--baz--qux' class='section-header'>\\\n+          <a href='#foo--bar--baz--qux'><strong>Foo?</strong> &amp; *bar?!*  \\\n+          <em><code>baz</code></em> \u2764 #qux</a></h4>\");\n+    }\n+\n     #[test]\n     fn test_plain_summary_line() {\n         fn t(input: &str, expect: &str) {\n@@ -620,18 +647,4 @@ mod tests {\n         t(\"# top header\", \"top header\");\n         t(\"## header\", \"header\");\n     }\n-\n-    #[test]\n-    fn test_collapse_whitespace() {\n-        fn t(input: &str, expected: &str) {\n-            let actual = collapse_whitespace(input);\n-            assert_eq!(actual, expected);\n-        }\n-\n-        t(\"foo\", \"foo\");\n-        t(\"foo bar baz\", \"foo bar baz\");\n-        t(\" foo   bar\", \"foo bar\");\n-        t(\"\\tfoo   bar\\nbaz\", \"foo bar baz\");\n-        t(\"foo   bar \\n   baz\\t\\tqux\\n\", \"foo bar baz qux\");\n-    }\n }"}, {"sha": "c67a4182f54cbb32384b95c3c66b2b71affeb7ac", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a64a678f7e5942b42781573683640952498b28/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a64a678f7e5942b42781573683640952498b28/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=f5a64a678f7e5942b42781573683640952498b28", "patch": "@@ -18,7 +18,7 @@\n //! language primitives](#primitives), [standard macros](#macros),\n //! [I/O](io/index.html) and [multithreading](thread/index.html), among\n //! [many other\n-//! things](#what-is-in-the-standard-library-documentation?).\n+//! things](#what-is-in-the-standard-library-documentation).\n //!\n //! `std` is available to all Rust crates by default, just as if each\n //! one contained an `extern crate std` import at the [crate"}]}