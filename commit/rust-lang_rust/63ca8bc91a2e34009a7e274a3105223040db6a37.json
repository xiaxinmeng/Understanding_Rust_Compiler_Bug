{"sha": "63ca8bc91a2e34009a7e274a3105223040db6a37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzY2E4YmM5MWEyZTM0MDA5YTdlMjc0YTMxMDUyMjMwNDBkYjZhMzc=", "commit": {"author": {"name": "DJMcNab", "email": "36049421+DJMcNab@users.noreply.github.com", "date": "2018-12-20T15:09:22Z"}, "committer": {"name": "DJMcNab", "email": "36049421+DJMcNab@users.noreply.github.com", "date": "2018-12-20T15:09:22Z"}, "message": "Change parser tests dir to inline/ok and inline/err", "tree": {"sha": "1b384353a887c7094977128ccd52b8577169b317", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b384353a887c7094977128ccd52b8577169b317"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63ca8bc91a2e34009a7e274a3105223040db6a37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63ca8bc91a2e34009a7e274a3105223040db6a37", "html_url": "https://github.com/rust-lang/rust/commit/63ca8bc91a2e34009a7e274a3105223040db6a37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63ca8bc91a2e34009a7e274a3105223040db6a37/comments", "author": {"login": "DJMcNab", "id": 36049421, "node_id": "MDQ6VXNlcjM2MDQ5NDIx", "avatar_url": "https://avatars.githubusercontent.com/u/36049421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DJMcNab", "html_url": "https://github.com/DJMcNab", "followers_url": "https://api.github.com/users/DJMcNab/followers", "following_url": "https://api.github.com/users/DJMcNab/following{/other_user}", "gists_url": "https://api.github.com/users/DJMcNab/gists{/gist_id}", "starred_url": "https://api.github.com/users/DJMcNab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DJMcNab/subscriptions", "organizations_url": "https://api.github.com/users/DJMcNab/orgs", "repos_url": "https://api.github.com/users/DJMcNab/repos", "events_url": "https://api.github.com/users/DJMcNab/events{/privacy}", "received_events_url": "https://api.github.com/users/DJMcNab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DJMcNab", "id": 36049421, "node_id": "MDQ6VXNlcjM2MDQ5NDIx", "avatar_url": "https://avatars.githubusercontent.com/u/36049421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DJMcNab", "html_url": "https://github.com/DJMcNab", "followers_url": "https://api.github.com/users/DJMcNab/followers", "following_url": "https://api.github.com/users/DJMcNab/following{/other_user}", "gists_url": "https://api.github.com/users/DJMcNab/gists{/gist_id}", "starred_url": "https://api.github.com/users/DJMcNab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DJMcNab/subscriptions", "organizations_url": "https://api.github.com/users/DJMcNab/orgs", "repos_url": "https://api.github.com/users/DJMcNab/repos", "events_url": "https://api.github.com/users/DJMcNab/events{/privacy}", "received_events_url": "https://api.github.com/users/DJMcNab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2a7e9451881d3b9d1eba7336c657d56558f812e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2a7e9451881d3b9d1eba7336c657d56558f812e", "html_url": "https://github.com/rust-lang/rust/commit/e2a7e9451881d3b9d1eba7336c657d56558f812e"}], "stats": {"total": 89, "additions": 56, "deletions": 33}, "files": [{"sha": "15f70c0903f50b91a37b27734220c3f5db2ac7e5", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63ca8bc91a2e34009a7e274a3105223040db6a37/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ca8bc91a2e34009a7e274a3105223040db6a37/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=63ca8bc91a2e34009a7e274a3105223040db6a37", "patch": "@@ -24,7 +24,7 @@ fn lexer_tests() {\n \n #[test]\n fn parser_tests() {\n-    dir_tests(&[\"parser/inline\", \"parser/ok\"], |text, path| {\n+    dir_tests(&[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n         let file = SourceFileNode::parse(text);\n         let errors = file.errors();\n         assert_eq!(\n@@ -35,7 +35,7 @@ fn parser_tests() {\n         );\n         dump_tree(file.syntax())\n     });\n-    dir_tests(&[\"parser/err\"], |text, path| {\n+    dir_tests(&[\"parser/err\", \"parser/inline/err\"], |text, path| {\n         let file = SourceFileNode::parse(text);\n         let errors = file.errors();\n         assert_ne!("}, {"sha": "66fca5bef185a07fa3ce722fd08f0a3d56416008", "filename": "crates/tools/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63ca8bc91a2e34009a7e274a3105223040db6a37/crates%2Ftools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ca8bc91a2e34009a7e274a3105223040db6a37/crates%2Ftools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Flib.rs?ref=63ca8bc91a2e34009a7e274a3105223040db6a37", "patch": "@@ -21,6 +21,7 @@ const TOOLCHAIN: &str = \"1.31.0\";\n pub struct Test {\n     pub name: String,\n     pub text: String,\n+    pub ok: bool,\n }\n \n pub fn collect_tests(s: &str) -> Vec<(usize, Test)> {\n@@ -38,11 +39,16 @@ pub fn collect_tests(s: &str) -> Vec<(usize, Test)> {\n         }\n         let mut block = block.map(|(idx, line)| (idx, &line[prefix.len()..]));\n \n+        let mut ok = true;\n         let (start_line, name) = loop {\n             match block.next() {\n                 Some((idx, line)) if line.starts_with(\"test \") => {\n                     break (idx, line[\"test \".len()..].to_string());\n                 }\n+                Some((idx, line)) if line.starts_with(\"test_fail \") => {\n+                    ok = false;\n+                    break (idx, line[\"test_fail \".len()..].to_string());\n+                }\n                 Some(_) => (),\n                 None => continue 'outer,\n             }\n@@ -52,7 +58,7 @@ pub fn collect_tests(s: &str) -> Vec<(usize, Test)> {\n             \"\\n\",\n         );\n         assert!(!text.trim().is_empty() && text.ends_with('\\n'));\n-        res.push((start_line, Test { name, text }))\n+        res.push((start_line, Test { name, text, ok }))\n     }\n     res\n }"}, {"sha": "08b21f7afc805b91da9b0d86e52bb03be132e663", "filename": "crates/tools/src/main.rs", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/63ca8bc91a2e34009a7e274a3105223040db6a37/crates%2Ftools%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ca8bc91a2e34009a7e274a3105223040db6a37/crates%2Ftools%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Fmain.rs?ref=63ca8bc91a2e34009a7e274a3105223040db6a37", "patch": "@@ -7,10 +7,11 @@ use std::{\n use clap::{App, Arg, SubCommand};\n use failure::bail;\n \n-use tools::{collect_tests, generate, install_format_hook, run, run_rustfmt, Mode, Overwrite, Result, Test, Verify};\n+use tools::{collect_tests, generate, install_format_hook, run, run_rustfmt, Mode, Overwrite, Result, Test, Verify, project_root};\n \n-const GRAMMAR_DIR: &str = \"./crates/ra_syntax/src/grammar\";\n-const INLINE_TESTS_DIR: &str = \"./crates/ra_syntax/tests/data/parser/inline\";\n+const GRAMMAR_DIR: &str = \"crates/ra_syntax/src/grammar\";\n+const OK_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/tests/data/parser/inline/ok\";\n+const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/tests/data/parser/inline/err\";\n \n fn main() -> Result<()> {\n     let matches = App::new(\"tasks\")\n@@ -48,34 +49,43 @@ fn main() -> Result<()> {\n \n fn gen_tests(mode: Mode) -> Result<()> {\n     let tests = tests_from_dir(Path::new(GRAMMAR_DIR))?;\n+    fn install_tests(tests: &HashMap<String, Test>, into: &str, mode: Mode) -> Result<()> {\n+        let tests_dir = project_root().join(into);\n+        if !tests_dir.is_dir() {\n+            fs::create_dir_all(&tests_dir)?;\n+        }\n+        // ok is never is actually read, but it needs to be specified to create a Test in existing_tests\n+        let existing = existing_tests(&tests_dir, true)?;\n+        for t in existing.keys().filter(|&t| !tests.contains_key(t)) {\n+            panic!(\"Test is deleted: {}\", t);\n+        }\n \n-    let inline_tests_dir = Path::new(INLINE_TESTS_DIR);\n-    if !inline_tests_dir.is_dir() {\n-        fs::create_dir_all(inline_tests_dir)?;\n-    }\n-    let existing = existing_tests(inline_tests_dir)?;\n-\n-    for t in existing.keys().filter(|&t| !tests.contains_key(t)) {\n-        panic!(\"Test is deleted: {}\", t);\n+        let mut new_idx = existing.len() + 2;\n+        for (name, test) in tests {\n+            let path = match existing.get(name) {\n+                Some((path, _test)) => path.clone(),\n+                None => {\n+                    let file_name = format!(\"{:04}_{}.rs\", new_idx, name);\n+                    new_idx += 1;\n+                    tests_dir.join(file_name)\n+                }\n+            };\n+            teraron::update(&path, &test.text, mode)?;\n+        }\n+        Ok(())\n     }\n+    install_tests(&tests.ok, OK_INLINE_TESTS_DIR, mode)?;\n+    install_tests(&tests.err, ERR_INLINE_TESTS_DIR, mode)\n+}\n \n-    let mut new_idx = existing.len() + 2;\n-    for (name, test) in tests {\n-        let path = match existing.get(&name) {\n-            Some((path, _test)) => path.clone(),\n-            None => {\n-                let file_name = format!(\"{:04}_{}.rs\", new_idx, name);\n-                new_idx += 1;\n-                inline_tests_dir.join(file_name)\n-            }\n-        };\n-        teraron::update(&path, &test.text, mode)?;\n-    }\n-    Ok(())\n+#[derive(Default, Debug)]\n+struct Tests {\n+    pub ok: HashMap<String, Test>,\n+    pub err: HashMap<String, Test>,\n }\n \n-fn tests_from_dir(dir: &Path) -> Result<HashMap<String, Test>> {\n-    let mut res = HashMap::new();\n+fn tests_from_dir(dir: &Path) -> Result<Tests> {\n+    let mut res = Tests::default();\n     for entry in ::walkdir::WalkDir::new(dir) {\n         let entry = entry.unwrap();\n         if !entry.file_type().is_file() {\n@@ -89,19 +99,25 @@ fn tests_from_dir(dir: &Path) -> Result<HashMap<String, Test>> {\n     let grammar_rs = dir.parent().unwrap().join(\"grammar.rs\");\n     process_file(&mut res, &grammar_rs)?;\n     return Ok(res);\n-    fn process_file(res: &mut HashMap<String, Test>, path: &Path) -> Result<()> {\n+    fn process_file(res: &mut Tests, path: &Path) -> Result<()> {\n         let text = fs::read_to_string(path)?;\n \n         for (_, test) in collect_tests(&text) {\n-            if let Some(old_test) = res.insert(test.name.clone(), test) {\n-                bail!(\"Duplicate test: {}\", old_test.name)\n+            if test.ok {\n+                if let Some(old_test) = res.ok.insert(test.name.clone(), test) {\n+                    bail!(\"Duplicate test: {}\", old_test.name)\n+                }\n+            } else {\n+                if let Some(old_test) = res.err.insert(test.name.clone(), test) {\n+                    bail!(\"Duplicate test: {}\", old_test.name)\n+                }\n             }\n         }\n         Ok(())\n     }\n }\n \n-fn existing_tests(dir: &Path) -> Result<HashMap<String, (PathBuf, Test)>> {\n+fn existing_tests(dir: &Path, ok: bool) -> Result<HashMap<String, (PathBuf, Test)>> {\n     let mut res = HashMap::new();\n     for file in fs::read_dir(dir)? {\n         let file = file?;\n@@ -117,6 +133,7 @@ fn existing_tests(dir: &Path) -> Result<HashMap<String, (PathBuf, Test)>> {\n         let test = Test {\n             name: name.clone(),\n             text,\n+            ok,\n         };\n         if let Some(old) = res.insert(name, (path, test)) {\n             println!(\"Duplicate test: {:?}\", old);"}]}