{"sha": "17ac2aa523f03c386669f569bc89019deb0c0ecd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YWMyYWE1MjNmMDNjMzg2NjY5ZjU2OWJjODkwMTlkZWIwYzBlY2Q=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-17T15:37:30Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-18T23:18:02Z"}, "message": "std::str: replace .as_imm_buf with .as_ptr.", "tree": {"sha": "52fe2a7bdedb308a25f4515cca59407a66d67ee7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52fe2a7bdedb308a25f4515cca59407a66d67ee7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17ac2aa523f03c386669f569bc89019deb0c0ecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17ac2aa523f03c386669f569bc89019deb0c0ecd", "html_url": "https://github.com/rust-lang/rust/commit/17ac2aa523f03c386669f569bc89019deb0c0ecd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17ac2aa523f03c386669f569bc89019deb0c0ecd/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "html_url": "https://github.com/rust-lang/rust/commit/9177f7ecb4d897a72aeaa0b3dfed930286946cf3"}], "stats": {"total": 180, "additions": 73, "deletions": 107}, "files": [{"sha": "e64e44695f3e97e64d49e1ec7ff0d4267131a767", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=17ac2aa523f03c386669f569bc89019deb0c0ecd", "patch": "@@ -894,9 +894,9 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n             None => ()\n         }\n \n-        let sc = s.as_imm_buf(|buf, buflen| {\n-            llvm::LLVMConstStringInContext(cx.llcx, buf as *c_char, buflen as c_uint, False)\n-        });\n+        let sc = llvm::LLVMConstStringInContext(cx.llcx,\n+                                                s.as_ptr() as *c_char, s.len() as c_uint,\n+                                                False);\n \n         let gsym = token::gensym(\"str\");\n         let g = format!(\"str{}\", gsym).with_c_str(|buf| {"}, {"sha": "513144ad73132f5f1ded439e94ed698a355e1aeb", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=17ac2aa523f03c386669f569bc89019deb0c0ecd", "patch": "@@ -106,9 +106,8 @@ fn render(w: &mut io::Writer, s: &str) {\n         let markdown = sd_markdown_new(extensions, 16, &callbacks,\n                                        &options as *html_renderopt as *libc::c_void);\n \n-        s.as_imm_buf(|data, len| {\n-            sd_markdown_render(ob, data, len as libc::size_t, markdown);\n-        });\n+\n+        sd_markdown_render(ob, s.as_ptr(), s.len() as libc::size_t, markdown);\n         sd_markdown_free(markdown);\n \n         vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {"}, {"sha": "592efe6d981b128df194979d6d97d33cd8f92f6a", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=17ac2aa523f03c386669f569bc89019deb0c0ecd", "patch": "@@ -573,15 +573,14 @@ mod bench {\n \n     #[inline]\n     fn check(s: &str, c_str: *libc::c_char) {\n-        s.as_imm_buf(|s_buf, s_len| {\n-            for i in range(0, s_len) {\n-                unsafe {\n-                    assert_eq!(\n-                        *ptr::offset(s_buf, i as int) as libc::c_char,\n-                        *ptr::offset(c_str, i as int));\n-                }\n+        let s_buf = s.as_ptr();\n+        for i in range(0, s.len()) {\n+            unsafe {\n+                assert_eq!(\n+                    *ptr::offset(s_buf, i as int) as libc::c_char,\n+                    *ptr::offset(c_str, i as int));\n             }\n-        })\n+        }\n     }\n \n     static s_short: &'static str = \"Mary\";"}, {"sha": "5067f6eb1279b44a986ea146b968d1ebceebae32", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=17ac2aa523f03c386669f569bc89019deb0c0ecd", "patch": "@@ -436,10 +436,10 @@ mod tests {\n     #[test]\n     fn test_get_str() {\n         let x = ~\"test\";\n-        let addr_x = x.as_imm_buf(|buf, _len| buf);\n+        let addr_x = x.as_ptr();\n         let opt = Some(x);\n         let y = opt.unwrap();\n-        let addr_y = y.as_imm_buf(|buf, _len| buf);\n+        let addr_y = y.as_ptr();\n         assert_eq!(addr_x, addr_y);\n     }\n "}, {"sha": "8da7c0340f7fe04fc1411063ef33bbe092a90d75", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=17ac2aa523f03c386669f569bc89019deb0c0ecd", "patch": "@@ -72,13 +72,11 @@ pub fn getcwd() -> Path {\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n     let mut buf = [0 as u16, ..BUF_BYTES];\n-    buf.as_mut_buf(|buf, len| {\n-        unsafe {\n-            if libc::GetCurrentDirectoryW(len as DWORD, buf) == 0 as DWORD {\n-                fail!();\n-            }\n+    unsafe {\n+        if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n+            fail!();\n         }\n-    });\n+    }\n     Path::new(str::from_utf16(buf))\n }\n "}, {"sha": "e90d3140077fb353dc83af33cc6da74e3ca0e604", "filename": "src/libstd/str.rs", "status": "modified", "additions": 55, "deletions": 85, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ac2aa523f03c386669f569bc89019deb0c0ecd/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=17ac2aa523f03c386669f569bc89019deb0c0ecd", "patch": "@@ -111,6 +111,7 @@ use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n use default::Default;\n use send_str::{SendStr, SendStrOwned};\n+use unstable::raw::Repr;\n \n /*\n Section: Conditions\n@@ -382,11 +383,7 @@ impl<'a> Iterator<(uint, char)> for CharOffsetIterator<'a> {\n     fn next(&mut self) -> Option<(uint, char)> {\n         // Compute the byte offset by using the pointer offset between\n         // the original string slice and the iterator's remaining part\n-        let offset = self.string.as_imm_buf(|a, _| {\n-            self.iter.string.as_imm_buf(|b, _| {\n-                b as uint - a as uint\n-            })\n-        });\n+        let offset = self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n         self.iter.next().map(|ch| (offset, ch))\n     }\n \n@@ -400,11 +397,8 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         self.iter.next_back().map(|ch| {\n-            let offset = self.string.as_imm_buf(|a, _| {\n-                self.iter.string.as_imm_buf(|b, len| {\n-                    b as uint - a as uint + len\n-                })\n-            });\n+            let offset = self.iter.string.len() +\n+                    self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n             (offset, ch)\n         })\n     }\n@@ -748,41 +742,30 @@ pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n Section: Comparing strings\n */\n \n+// share the implementation of the lang-item vs. non-lang-item\n+// eq_slice.\n+#[inline]\n+fn eq_slice_(a: &str, b: &str) -> bool {\n+    a.len() == b.len() && unsafe {\n+        libc::memcmp(a.as_ptr() as *libc::c_void,\n+                     b.as_ptr() as *libc::c_void,\n+                     a.len() as libc::size_t) == 0\n+    }\n+}\n+\n /// Bytewise slice equality\n #[cfg(not(test))]\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    a.as_imm_buf(|ap, alen| {\n-        b.as_imm_buf(|bp, blen| {\n-            if (alen != blen) { false }\n-            else {\n-                unsafe {\n-                    libc::memcmp(ap as *libc::c_void,\n-                                 bp as *libc::c_void,\n-                                 alen as libc::size_t) == 0\n-                }\n-            }\n-        })\n-    })\n+    eq_slice_(a, b)\n }\n \n /// Bytewise slice equality\n #[cfg(test)]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    a.as_imm_buf(|ap, alen| {\n-        b.as_imm_buf(|bp, blen| {\n-            if (alen != blen) { false }\n-            else {\n-                unsafe {\n-                    libc::memcmp(ap as *libc::c_void,\n-                                 bp as *libc::c_void,\n-                                 alen as libc::size_t) == 0\n-                }\n-            }\n-        })\n-    })\n+    eq_slice_(a, b)\n }\n \n /// Bytewise string equality\n@@ -1080,12 +1063,10 @@ pub mod raw {\n     /// Caller must check slice boundaries!\n     #[inline]\n     pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        s.as_imm_buf(|sbuf, _n| {\n-             cast::transmute(Slice {\n-                 data: sbuf.offset(begin as int),\n-                 len: end - begin,\n-             })\n-        })\n+        cast::transmute(Slice {\n+                data: s.as_ptr().offset(begin as int),\n+                len: end - begin,\n+            })\n     }\n \n     /// Appends a byte to a string.\n@@ -1309,7 +1290,7 @@ impl<'a> Str for @str {\n impl<'a> Container for &'a str {\n     #[inline]\n     fn len(&self) -> uint {\n-        self.as_imm_buf(|_p, n| n)\n+        self.repr().len\n     }\n }\n \n@@ -1997,10 +1978,12 @@ pub trait StrSlice<'a> {\n     /// ```\n     fn subslice_offset(&self, inner: &str) -> uint;\n \n-    /// Work with the byte buffer and length of a slice.\n+    /// Return an unsafe pointer to the strings buffer.\n     ///\n-    /// The buffer does not have a null terminator.\n-    fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T;\n+    /// The caller must ensure that the string outlives this pointer,\n+    /// and that it is not reallocated (e.g. by pushing to the\n+    /// string).\n+    fn as_ptr(&self) -> *u8;\n }\n \n impl<'a> StrSlice<'a> for &'a str {\n@@ -2278,15 +2261,14 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn to_owned(&self) -> ~str {\n-        self.as_imm_buf(|src, len| {\n-            unsafe {\n-                let mut v = vec::with_capacity(len);\n+        let len = self.len();\n+        unsafe {\n+            let mut v = vec::with_capacity(len);\n \n-                ptr::copy_memory(v.as_mut_ptr(), src, len);\n-                v.set_len(len);\n-                ::cast::transmute(v)\n-            }\n-        })\n+            ptr::copy_memory(v.as_mut_ptr(), self.as_ptr(), len);\n+            v.set_len(len);\n+            ::cast::transmute(v)\n+        }\n     }\n \n     #[inline]\n@@ -2482,27 +2464,19 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     fn subslice_offset(&self, inner: &str) -> uint {\n-        self.as_imm_buf(|a, a_len| {\n-            inner.as_imm_buf(|b, b_len| {\n-                let a_start: uint;\n-                let a_end: uint;\n-                let b_start: uint;\n-                let b_end: uint;\n-                unsafe {\n-                    a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n-                    b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n-                }\n-                assert!(a_start <= b_start);\n-                assert!(b_end <= a_end);\n-                b_start - a_start\n-            })\n-        })\n+        let a_start = self.as_ptr() as uint;\n+        let a_end = a_start + self.len();\n+        let b_start = inner.as_ptr() as uint;\n+        let b_end = b_start + inner.len();\n+\n+        assert!(a_start <= b_start);\n+        assert!(b_end <= a_end);\n+        b_start - a_start\n     }\n \n     #[inline]\n-    fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T {\n-        let v: &[u8] = unsafe { cast::transmute(*self) };\n-        f(v.as_ptr(), v.len())\n+    fn as_ptr(&self) -> *u8 {\n+        self.repr().data\n     }\n }\n \n@@ -3391,19 +3365,15 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_imm_buf() {\n-        \"\".as_imm_buf(|_, len| assert_eq!(len, 0));\n-\n-        \"hello\".as_imm_buf(|buf, len| {\n-            assert_eq!(len, 5);\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n-            }\n-        })\n+    fn test_as_ptr() {\n+        let buf = \"hello\".as_ptr();\n+        unsafe {\n+            assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n+            assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n+            assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n+            assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n+            assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n+        }\n     }\n \n     #[test]\n@@ -3936,10 +3906,10 @@ mod tests {\n         assert_eq!(s.as_slice(), \"\");\n \n         let mut s = ~\"12345\";\n-        let p = s.as_imm_buf(|p,_| p);\n+        let p = s.as_ptr();\n         s.truncate(3);\n         s.push_str(\"6\");\n-        let p_ = s.as_imm_buf(|p,_| p);\n+        let p_ = s.as_ptr();\n         assert_eq!(p_, p);\n     }\n "}]}