{"sha": "df035a33b228daa700ac50712d9e16509d373e41", "node_id": "C_kwDOAAsO6NoAKGRmMDM1YTMzYjIyOGRhYTcwMGFjNTA3MTJkOWUxNjUwOWQzNzNlNDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-10T08:55:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-10T08:55:53Z"}, "message": "Auto merge of #87487 - lambinoo:I-64762_unreachable_pub_lint, r=petrochenkov\n\nFixes wrong unreachable_pub lints on nested and glob public reexport\n\nLinked issues: #64762 & #82064", "tree": {"sha": "e98f02a220de459f6b5da0d52985cef02f624af7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e98f02a220de459f6b5da0d52985cef02f624af7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df035a33b228daa700ac50712d9e16509d373e41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df035a33b228daa700ac50712d9e16509d373e41", "html_url": "https://github.com/rust-lang/rust/commit/df035a33b228daa700ac50712d9e16509d373e41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df035a33b228daa700ac50712d9e16509d373e41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "html_url": "https://github.com/rust-lang/rust/commit/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c"}, {"sha": "3a77bb86ff33bd4633aa831f2580aa3792a9c279", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a77bb86ff33bd4633aa831f2580aa3792a9c279", "html_url": "https://github.com/rust-lang/rust/commit/3a77bb86ff33bd4633aa831f2580aa3792a9c279"}], "stats": {"total": 577, "additions": 359, "deletions": 218}, "files": [{"sha": "e4cc44c41ddec5c41506864b68fb6e1f9dbe137b", "filename": "compiler/rustc_errors/src/snippet.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -69,9 +69,6 @@ pub enum AnnotationType {\n     /// Annotation under a single line of code\n     Singleline,\n \n-    /// Annotation enclosing the first and last character of a multiline span\n-    Multiline(MultilineAnnotation),\n-\n     // The Multiline type above is replaced with the following three in order\n     // to reuse the current label drawing code.\n     //"}, {"sha": "c6145ae0d510b366b07f702aa11daae4438b7390", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -92,7 +92,8 @@ use unused::*;\n \n /// Useful for other parts of the compiler / Clippy.\n pub use builtin::SoftLints;\n-pub use context::{CheckLintNameResult, EarlyContext, LateContext, LintContext, LintStore};\n+pub use context::{CheckLintNameResult, FindLintError, LintStore};\n+pub use context::{EarlyContext, LateContext, LintContext};\n pub use early::check_ast_crate;\n pub use late::check_crate;\n pub use passes::{EarlyLintPass, LateLintPass};"}, {"sha": "ff993ac392cf7fe2e18565d8e13d447de6841057", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -28,7 +28,7 @@ pub enum AccessLevel {\n }\n \n /// Holds a map of accessibility levels for reachable HIR nodes.\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct AccessLevels<Id = LocalDefId> {\n     pub map: FxHashMap<Id, AccessLevel>,\n }"}, {"sha": "16adf93b69a368cd92e7574703bd0c18d4d437ed", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -20,6 +20,7 @@ pub use generics::*;\n pub use vtable::*;\n \n use crate::metadata::ModChild;\n+use crate::middle::privacy::AccessLevels;\n use crate::mir::{Body, GeneratorLayout};\n use crate::traits::{self, Reveal};\n use crate::ty;\n@@ -123,6 +124,7 @@ pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n+    pub access_levels: AccessLevels,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,"}, {"sha": "e93cd813db53e56005fcff99c206935f8b93b57e", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 39, "deletions": 181, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -11,8 +11,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet};\n-use rustc_hir::def_id::{CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n use rustc_hir::intravisit::{self, DeepVisitor, NestedVisitorMap, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n@@ -26,7 +25,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Const, GenericParamDefKind, TraitRef, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::traits::const_evaluatable::{self, AbstractConst};\n \n@@ -436,6 +435,15 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         self.access_levels.map.get(&def_id).copied()\n     }\n \n+    fn update_with_hir_id(\n+        &mut self,\n+        hir_id: hir::HirId,\n+        level: Option<AccessLevel>,\n+    ) -> Option<AccessLevel> {\n+        let def_id = self.tcx.hir().local_def_id(hir_id);\n+        self.update(def_id, level)\n+    }\n+\n     /// Updates node level and returns the updated level.\n     fn update(&mut self, def_id: LocalDefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n         let old_level = self.get(def_id);\n@@ -623,54 +631,6 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             | DefKind::Generator => (),\n         }\n     }\n-\n-    /// Given the path segments of an `ItemKind::Use`, then we need\n-    /// to update the visibility of the intermediate use so that it isn't linted\n-    /// by `unreachable_pub`.\n-    ///\n-    /// This isn't trivial as `path.res` has the `DefId` of the eventual target\n-    /// of the use statement not of the next intermediate use statement.\n-    ///\n-    /// To do this, consider the last two segments of the path to our intermediate\n-    /// use statement. We expect the penultimate segment to be a module and the\n-    /// last segment to be the name of the item we are exporting. We can then\n-    /// look at the items contained in the module for the use statement with that\n-    /// name and update that item's visibility.\n-    ///\n-    /// FIXME: This solution won't work with glob imports and doesn't respect\n-    /// namespaces. See <https://github.com/rust-lang/rust/pull/57922#discussion_r251234202>.\n-    fn update_visibility_of_intermediate_use_statements(\n-        &mut self,\n-        segments: &[hir::PathSegment<'_>],\n-    ) {\n-        if let [.., module, segment] = segments {\n-            if let Some(item) = module\n-                .res\n-                .and_then(|res| res.mod_def_id())\n-                // If the module is `self`, i.e. the current crate,\n-                // there will be no corresponding item.\n-                .filter(|def_id| def_id.index != CRATE_DEF_INDEX || def_id.krate != LOCAL_CRATE)\n-                .and_then(|def_id| def_id.as_local())\n-                .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n-            {\n-                if let hir::ItemKind::Mod(m) = &item.kind {\n-                    for &item_id in m.item_ids {\n-                        let item = self.tcx.hir().item(item_id);\n-                        if !self.tcx.hygienic_eq(\n-                            segment.ident,\n-                            item.ident,\n-                            item_id.def_id.to_def_id(),\n-                        ) {\n-                            continue;\n-                        }\n-                        if let hir::ItemKind::Use(..) = item.kind {\n-                            self.update(item.def_id, Some(AccessLevel::Exported));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n@@ -683,120 +643,22 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let inherited_item_level = match item.kind {\n+        let item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                Option::<AccessLevel>::of_impl(item.def_id, self.tcx, &self.access_levels)\n-            }\n-            // Only exported `macro_rules!` items are public, but they always are.\n-            hir::ItemKind::Macro(MacroDef { macro_rules: true, .. }) => {\n-                let def_id = item.def_id.to_def_id();\n-                let is_macro_export = self.tcx.has_attr(def_id, sym::macro_export);\n-                if is_macro_export { Some(AccessLevel::Public) } else { None }\n-            }\n-            // Foreign modules inherit level from parents.\n-            hir::ItemKind::ForeignMod { .. } => self.prev_level,\n-            // Other `pub` items inherit levels from parents.\n-            hir::ItemKind::Const(..)\n-            | hir::ItemKind::Enum(..)\n-            | hir::ItemKind::ExternCrate(..)\n-            | hir::ItemKind::GlobalAsm(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::Macro(..)\n-            | hir::ItemKind::Mod(..)\n-            | hir::ItemKind::Static(..)\n-            | hir::ItemKind::Struct(..)\n-            | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..)\n-            | hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Union(..)\n-            | hir::ItemKind::Use(..) => {\n-                if item.vis.node.is_pub() {\n-                    self.prev_level\n-                } else {\n-                    None\n-                }\n+                let impl_level =\n+                    Option::<AccessLevel>::of_impl(item.def_id, self.tcx, &self.access_levels);\n+                self.update(item.def_id, impl_level)\n             }\n+            _ => self.get(item.def_id),\n         };\n \n-        // Update level of the item itself.\n-        let item_level = self.update(item.def_id, inherited_item_level);\n-\n-        // Update levels of nested things.\n-        match item.kind {\n-            hir::ItemKind::Enum(ref def, _) => {\n-                for variant in def.variants {\n-                    let variant_level =\n-                        self.update(self.tcx.hir().local_def_id(variant.id), item_level);\n-                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-                        self.update(self.tcx.hir().local_def_id(ctor_hir_id), item_level);\n-                    }\n-                    for field in variant.data.fields() {\n-                        self.update(self.tcx.hir().local_def_id(field.hir_id), variant_level);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::Impl(ref impl_) => {\n-                for impl_item_ref in impl_.items {\n-                    if impl_.of_trait.is_some()\n-                        || self.tcx.visibility(impl_item_ref.id.def_id) == ty::Visibility::Public\n-                    {\n-                        self.update(impl_item_ref.id.def_id, item_level);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::Trait(.., trait_item_refs) => {\n-                for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.def_id, item_level);\n-                }\n-            }\n-            hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n-                if let Some(ctor_hir_id) = def.ctor_hir_id() {\n-                    self.update(self.tcx.hir().local_def_id(ctor_hir_id), item_level);\n-                }\n-                for field in def.fields() {\n-                    if field.vis.node.is_pub() {\n-                        self.update(self.tcx.hir().local_def_id(field.hir_id), item_level);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::Macro(ref macro_def) => {\n-                self.update_reachability_from_macro(item.def_id, macro_def);\n-            }\n-            hir::ItemKind::ForeignMod { items, .. } => {\n-                for foreign_item in items {\n-                    if self.tcx.visibility(foreign_item.id.def_id) == ty::Visibility::Public {\n-                        self.update(foreign_item.id.def_id, item_level);\n-                    }\n-                }\n-            }\n-\n-            hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::Use(..)\n-            | hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::GlobalAsm(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Mod(..)\n-            | hir::ItemKind::TraitAlias(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::ExternCrate(..) => {}\n-        }\n-\n         // Mark all items in interfaces of reachable items as reachable.\n         match item.kind {\n             // The interface is empty.\n-            hir::ItemKind::Macro(..) | hir::ItemKind::ExternCrate(..) => {}\n+            hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`.\n             hir::ItemKind::Mod(..) => {}\n-            // Re-exports are handled in `visit_mod`. However, in order to avoid looping over\n-            // all of the items of a mod in `visit_mod` looking for use statements, we handle\n-            // making sure that intermediate use statements have their visibilities updated here.\n-            hir::ItemKind::Use(path, _) => {\n-                if item_level.is_some() {\n-                    self.update_visibility_of_intermediate_use_statements(path.segments.as_ref());\n-                }\n-            }\n+            hir::ItemKind::Use(..) => {}\n             // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::OpaqueTy(..) => {\n@@ -847,6 +709,14 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n+                for impl_item_ref in impl_.items {\n+                    if impl_.of_trait.is_some()\n+                        || self.tcx.visibility(impl_item_ref.id.def_id) == ty::Visibility::Public\n+                    {\n+                        self.update(impl_item_ref.id.def_id, item_level);\n+                    }\n+                }\n+\n                 if item_level.is_some() {\n                     self.reach(item.def_id, item_level).generics().predicates().ty().trait_ref();\n \n@@ -861,15 +731,21 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n                     self.reach(item.def_id, item_level).generics().predicates();\n                 }\n+\n+                let enum_level = self.get(item.def_id);\n                 for variant in def.variants {\n-                    let variant_level = self.get(self.tcx.hir().local_def_id(variant.id));\n+                    let variant_level = self.update_with_hir_id(variant.id, enum_level);\n+\n                     if variant_level.is_some() {\n+                        if let Some(ctor_id) = variant.data.ctor_hir_id() {\n+                            self.update_with_hir_id(ctor_id, variant_level);\n+                        }\n+\n                         for field in variant.data.fields() {\n                             self.reach(self.tcx.hir().local_def_id(field.hir_id), variant_level)\n                                 .ty();\n@@ -880,6 +756,9 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                self.update_reachability_from_macro(item.def_id, macro_def);\n+            }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n@@ -920,27 +799,6 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         intravisit::walk_block(self, b);\n         self.prev_level = orig_level;\n     }\n-\n-    fn visit_mod(&mut self, m: &'tcx hir::Mod<'tcx>, _sp: Span, id: hir::HirId) {\n-        // This code is here instead of in visit_item so that the\n-        // crate module gets processed as well.\n-        if self.prev_level.is_some() {\n-            let def_id = self.tcx.hir().local_def_id(id);\n-            if let Some(exports) = self.tcx.module_reexports(def_id) {\n-                for export in exports.iter() {\n-                    if export.vis.is_public() {\n-                        if let Some(def_id) = export.res.opt_def_id() {\n-                            if let Some(def_id) = def_id.as_local() {\n-                                self.update(def_id, Some(AccessLevel::Exported));\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        intravisit::walk_mod(self, m, id);\n-    }\n }\n \n impl ReachEverythingInTheInterfaceVisitor<'_, '_> {\n@@ -2166,11 +2024,12 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, (): ()) -> &AccessLevels {\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n         tcx,\n-        access_levels: Default::default(),\n+        access_levels: tcx.resolutions(()).access_levels.clone(),\n         macro_reachable: Default::default(),\n         prev_level: Some(AccessLevel::Public),\n         changed: false,\n     };\n+\n     loop {\n         tcx.hir().walk_toplevel_module(&mut visitor);\n         if visitor.changed {\n@@ -2179,7 +2038,6 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, (): ()) -> &AccessLevels {\n             break;\n         }\n     }\n-    visitor.update(CRATE_DEF_ID, Some(AccessLevel::Public));\n \n     tcx.arena.alloc(visitor.access_levels)\n }"}, {"sha": "60cc4248edc9dc1c77e71e3ad6135eb87a5d95f4", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -0,0 +1,237 @@\n+use rustc_ast::ast;\n+use rustc_ast::visit;\n+use rustc_ast::visit::Visitor;\n+use rustc_ast::Crate;\n+use rustc_ast::EnumDef;\n+use rustc_ast::ForeignMod;\n+use rustc_ast::NodeId;\n+use rustc_ast_lowering::ResolverAstLowering;\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::def_id::CRATE_DEF_ID;\n+use rustc_middle::middle::privacy::AccessLevel;\n+use rustc_middle::ty::Visibility;\n+use rustc_span::sym;\n+\n+use crate::imports::ImportKind;\n+use crate::BindingKey;\n+use crate::NameBinding;\n+use crate::NameBindingKind;\n+use crate::Resolver;\n+\n+pub struct AccessLevelsVisitor<'r, 'a> {\n+    r: &'r mut Resolver<'a>,\n+    prev_level: Option<AccessLevel>,\n+    changed: bool,\n+}\n+\n+impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n+    /// Fills the `Resolver::access_levels` table with public & exported items\n+    /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n+    /// need access to a TyCtxt for that.\n+    pub fn compute_access_levels<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n+        let mut visitor =\n+            AccessLevelsVisitor { r, changed: false, prev_level: Some(AccessLevel::Public) };\n+\n+        visitor.set_access_level_def_id(CRATE_DEF_ID, Some(AccessLevel::Public));\n+        visitor.set_exports_access_level(CRATE_DEF_ID);\n+\n+        while visitor.changed {\n+            visitor.reset();\n+            visit::walk_crate(&mut visitor, krate);\n+        }\n+\n+        tracing::info!(\"resolve::access_levels: {:#?}\", r.access_levels);\n+    }\n+\n+    fn reset(&mut self) {\n+        self.changed = false;\n+        self.prev_level = Some(AccessLevel::Public);\n+    }\n+\n+    /// Update the access level of the exports of the given module accordingly. The module access\n+    /// level has to be Exported or Public.\n+    /// This will also follow `use` chains (see PrivacyVisitor::set_import_binding_access_level).\n+    fn set_exports_access_level(&mut self, module_id: LocalDefId) {\n+        assert!(self.r.module_map.contains_key(&&module_id.to_def_id()));\n+\n+        // Set the given binding access level to `AccessLevel::Public` and\n+        // sets the rest of the `use` chain to `AccessLevel::Exported` until\n+        // we hit the actual exported item.\n+        let set_import_binding_access_level =\n+            |this: &mut Self, mut binding: &NameBinding<'a>, mut access_level| {\n+                while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n+                    binding.kind\n+                {\n+                    this.set_access_level(import.id, access_level);\n+                    if let ImportKind::Single { additional_ids, .. } = import.kind {\n+                        this.set_access_level(additional_ids.0, access_level);\n+                        this.set_access_level(additional_ids.1, access_level);\n+                    }\n+\n+                    access_level = Some(AccessLevel::Exported);\n+                    binding = nested_binding;\n+                }\n+            };\n+\n+        let module_level = self.r.access_levels.map.get(&module_id).copied();\n+        assert!(module_level >= Some(AccessLevel::Exported));\n+\n+        if let Some(exports) = self.r.reexport_map.get(&module_id) {\n+            let pub_exports = exports\n+                .iter()\n+                .filter(|ex| ex.vis == Visibility::Public)\n+                .cloned()\n+                .collect::<Vec<_>>();\n+\n+            let module = self.r.get_module(module_id.to_def_id()).unwrap();\n+            for export in pub_exports.into_iter() {\n+                if let Some(export_def_id) = export.res.opt_def_id().and_then(|id| id.as_local()) {\n+                    self.set_access_level_def_id(export_def_id, Some(AccessLevel::Exported));\n+                }\n+\n+                if let Some(ns) = export.res.ns() {\n+                    let key = BindingKey { ident: export.ident, ns, disambiguator: 0 };\n+                    let name_res = self.r.resolution(module, key);\n+                    if let Some(binding) = name_res.borrow().binding() {\n+                        set_import_binding_access_level(self, binding, module_level)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Sets the access level of the `LocalDefId` corresponding to the given `NodeId`.\n+    /// This function will panic if the `NodeId` does not have a `LocalDefId`\n+    fn set_access_level(\n+        &mut self,\n+        node_id: NodeId,\n+        access_level: Option<AccessLevel>,\n+    ) -> Option<AccessLevel> {\n+        self.set_access_level_def_id(self.r.local_def_id(node_id), access_level)\n+    }\n+\n+    fn set_access_level_def_id(\n+        &mut self,\n+        def_id: LocalDefId,\n+        access_level: Option<AccessLevel>,\n+    ) -> Option<AccessLevel> {\n+        let old_level = self.r.access_levels.map.get(&def_id).copied();\n+        if old_level < access_level {\n+            self.r.access_levels.map.insert(def_id, access_level.unwrap());\n+            self.changed = true;\n+            access_level\n+        } else {\n+            old_level\n+        }\n+    }\n+}\n+\n+impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n+    fn visit_item(&mut self, item: &'ast ast::Item) {\n+        let inherited_item_level = match item.kind {\n+            // Resolved in rustc_privacy when types are available\n+            ast::ItemKind::Impl(..) => return,\n+\n+            // Only exported `macro_rules!` items are public, but they always are\n+            ast::ItemKind::MacroDef(..) => {\n+                let is_macro_export =\n+                    item.attrs.iter().any(|attr| attr.has_name(sym::macro_export));\n+                if is_macro_export { Some(AccessLevel::Public) } else { None }\n+            }\n+\n+            // Foreign modules inherit level from parents.\n+            ast::ItemKind::ForeignMod(..) => self.prev_level,\n+\n+            // Other `pub` items inherit levels from parents.\n+            ast::ItemKind::ExternCrate(..)\n+            | ast::ItemKind::Use(..)\n+            | ast::ItemKind::Static(..)\n+            | ast::ItemKind::Const(..)\n+            | ast::ItemKind::Fn(..)\n+            | ast::ItemKind::Mod(..)\n+            | ast::ItemKind::GlobalAsm(..)\n+            | ast::ItemKind::TyAlias(..)\n+            | ast::ItemKind::Enum(..)\n+            | ast::ItemKind::Struct(..)\n+            | ast::ItemKind::Union(..)\n+            | ast::ItemKind::Trait(..)\n+            | ast::ItemKind::TraitAlias(..) => {\n+                if item.vis.kind.is_pub() {\n+                    self.prev_level\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            // Should be unreachable at this stage\n+            ast::ItemKind::MacCall(..) => panic!(\n+                \"ast::ItemKind::MacCall encountered, this should not anymore appear at this stage\"\n+            ),\n+        };\n+\n+        let access_level = self.set_access_level(item.id, inherited_item_level);\n+\n+        // Set access level of nested items.\n+        // If it's a mod, also make the visitor walk all of its items\n+        match item.kind {\n+            ast::ItemKind::Mod(..) => {\n+                if access_level.is_some() {\n+                    self.set_exports_access_level(self.r.local_def_id(item.id));\n+                }\n+\n+                let orig_level = std::mem::replace(&mut self.prev_level, access_level);\n+                visit::walk_item(self, item);\n+                self.prev_level = orig_level;\n+            }\n+\n+            ast::ItemKind::ForeignMod(ForeignMod { ref items, .. }) => {\n+                for nested in items {\n+                    if nested.vis.kind.is_pub() {\n+                        self.set_access_level(nested.id, access_level);\n+                    }\n+                }\n+            }\n+            ast::ItemKind::Enum(EnumDef { ref variants }, _) => {\n+                for variant in variants {\n+                    let variant_level = self.set_access_level(variant.id, access_level);\n+                    if let Some(ctor_id) = variant.data.ctor_id() {\n+                        self.set_access_level(ctor_id, access_level);\n+                    }\n+\n+                    for field in variant.data.fields() {\n+                        self.set_access_level(field.id, variant_level);\n+                    }\n+                }\n+            }\n+            ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n+                if let Some(ctor_id) = def.ctor_id() {\n+                    self.set_access_level(ctor_id, access_level);\n+                }\n+\n+                for field in def.fields() {\n+                    if field.vis.kind.is_pub() {\n+                        self.set_access_level(field.id, access_level);\n+                    }\n+                }\n+            }\n+            ast::ItemKind::Trait(ref trait_kind) => {\n+                for nested in trait_kind.items.iter() {\n+                    self.set_access_level(nested.id, access_level);\n+                }\n+            }\n+\n+            ast::ItemKind::ExternCrate(..)\n+            | ast::ItemKind::Use(..)\n+            | ast::ItemKind::Static(..)\n+            | ast::ItemKind::Const(..)\n+            | ast::ItemKind::GlobalAsm(..)\n+            | ast::ItemKind::TyAlias(..)\n+            | ast::ItemKind::TraitAlias(..)\n+            | ast::ItemKind::MacroDef(..)\n+            | ast::ItemKind::Fn(..) => return,\n+\n+            // Unreachable kinds\n+            ast::ItemKind::Impl(..) | ast::ItemKind::MacCall(..) => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "052770b201a5b7f19e6b3acd74db2d0bbf46e799", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -383,8 +383,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             used: Cell::new(false),\n         });\n \n-        debug!(\"add_import({:?})\", import);\n-\n         self.r.indeterminate_imports.push(import);\n         match import.kind {\n             // Don't add unresolved underscore imports to modules\n@@ -455,7 +453,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             prefix.is_empty() || prefix.len() == 1 && prefix[0].ident.name == kw::PathRoot\n         };\n         match use_tree.kind {\n-            ast::UseTreeKind::Simple(rename, ..) => {\n+            ast::UseTreeKind::Simple(rename, id1, id2) => {\n                 let mut ident = use_tree.ident();\n                 let mut module_path = prefix;\n                 let mut source = module_path.pop().unwrap();\n@@ -565,7 +563,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     },\n                     type_ns_only,\n                     nested,\n+                    additional_ids: (id1, id2),\n                 };\n+\n                 self.add_import(\n                     module_path,\n                     kind,"}, {"sha": "e7f76a18ad31addf4cb8608b1b052c2ed4260f1f", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -48,6 +48,9 @@ pub enum ImportKind<'a> {\n         type_ns_only: bool,\n         /// Did this import result from a nested import? ie. `use foo::{bar, baz};`\n         nested: bool,\n+        /// Additional `NodeId`s allocated to a `ast::UseTree` for automatically generated `use` statement\n+        /// (eg. implicit struct constructors)\n+        additional_ids: (NodeId, NodeId),\n     },\n     Glob {\n         is_prelude: bool,\n@@ -834,7 +837,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         import.span,\n                     );\n                     import.vis.set(orig_vis);\n-\n                     source_bindings[ns].set(binding);\n                 } else {\n                     return;"}, {"sha": "2843774275883f1d9c10d0bf334eac08e3635006", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -50,6 +50,7 @@ use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n+use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, ResolverOutputs};\n@@ -77,8 +78,11 @@ use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind::*};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n+use crate::access_levels::AccessLevelsVisitor;\n+\n type Res = def::Res<NodeId>;\n \n+mod access_levels;\n mod build_reduced_graph;\n mod check_unused;\n mod def_collector;\n@@ -1052,6 +1056,8 @@ pub struct Resolver<'a> {\n     /// they are declared in the static array generated by proc_macro_harness.\n     proc_macros: Vec<NodeId>,\n     confused_type_with_std_module: FxHashMap<Span, Span>,\n+\n+    access_levels: AccessLevels,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1407,6 +1413,7 @@ impl<'a> Resolver<'a> {\n             trait_impls: Default::default(),\n             proc_macros: Default::default(),\n             confused_type_with_std_module: Default::default(),\n+            access_levels: Default::default(),\n         };\n \n         let root_parent_scope = ParentScope::module(graph_root, &resolver);\n@@ -1452,10 +1459,12 @@ impl<'a> Resolver<'a> {\n         let glob_map = self.glob_map;\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n+        let access_levels = self.access_levels;\n         ResolverOutputs {\n             definitions,\n             cstore: Box::new(self.crate_loader.into_cstore()),\n             visibilities,\n+            access_levels,\n             extern_crate_map,\n             reexport_map,\n             glob_map,\n@@ -1477,6 +1486,7 @@ impl<'a> Resolver<'a> {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         ResolverOutputs {\n             definitions: self.definitions.clone(),\n+            access_levels: self.access_levels.clone(),\n             cstore: Box::new(self.cstore().clone()),\n             visibilities: self.visibilities.clone(),\n             extern_crate_map: self.extern_crate_map.clone(),\n@@ -1532,6 +1542,9 @@ impl<'a> Resolver<'a> {\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.session.time(\"resolve_crate\", || {\n             self.session.time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n+            self.session.time(\"resolve_access_levels\", || {\n+                AccessLevelsVisitor::compute_access_levels(self, krate)\n+            });\n             self.session.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n             self.session.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n             self.session.time(\"resolve_main\", || self.resolve_main());"}, {"sha": "62153efbb393baeeb89df1a8c251365457b686dc", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -16,7 +16,10 @@ use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n use super::search::SearchResult::*;\n \n mod entry;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use entry::{Entry, OccupiedEntry, OccupiedError, VacantEntry};\n+\n use Entry::*;\n \n /// Minimum number of elements in a node that is not a root."}, {"sha": "db8776ac7418d9aa2a79be51282e657ec7573426", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -24,6 +24,7 @@ mod take;\n mod take_while;\n mod zip;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::{\n     chain::Chain, cycle::Cycle, enumerate::Enumerate, filter::Filter, filter_map::FilterMap,\n     flatten::FlatMap, fuse::Fuse, inspect::Inspect, map::Map, peekable::Peekable, rev::Rev,"}, {"sha": "37b6f2e2565b2fe613f3386c2f6f75af658756d2", "filename": "library/core/src/iter/sources.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -6,6 +6,7 @@ mod repeat;\n mod repeat_with;\n mod successors;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::repeat::{repeat, Repeat};\n \n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]"}, {"sha": "ed0fb634dbf05043c0712d30900a790ade5d208d", "filename": "library/core/src/iter/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -5,15 +5,17 @@ mod exact_size;\n mod iterator;\n mod marker;\n \n-pub use self::accum::{Product, Sum};\n-pub use self::collect::{Extend, FromIterator, IntoIterator};\n-pub use self::double_ended::DoubleEndedIterator;\n-pub use self::exact_size::ExactSizeIterator;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::iterator::Iterator;\n+pub use self::{\n+    accum::{Product, Sum},\n+    collect::{Extend, FromIterator, IntoIterator},\n+    double_ended::DoubleEndedIterator,\n+    exact_size::ExactSizeIterator,\n+    iterator::Iterator,\n+    marker::{FusedIterator, TrustedLen},\n+};\n+\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n pub use self::marker::InPlaceIterable;\n #[unstable(feature = \"trusted_step\", issue = \"85731\")]\n pub use self::marker::TrustedStep;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::marker::{FusedIterator, TrustedLen};"}, {"sha": "100dab1e2493ca085418a7e46aab100df7ecea5e", "filename": "library/std/src/io/buffered/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -12,12 +12,12 @@ use crate::error;\n use crate::fmt;\n use crate::io::Error;\n \n-pub use bufreader::BufReader;\n-pub use bufwriter::BufWriter;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::{bufreader::BufReader, bufwriter::BufWriter, linewriter::LineWriter};\n+use linewritershim::LineWriterShim;\n+\n #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n pub use bufwriter::WriterPanicked;\n-pub use linewriter::LineWriter;\n-use linewritershim::LineWriterShim;\n \n /// An error returned by [`BufWriter::into_inner`] which combines an error that\n /// happened while writing out the buffer, and the buffered writer object"}, {"sha": "358ef22e708d7484be08ba868cd0ec5a3cdca1cf", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -261,31 +261,24 @@ use crate::str;\n use crate::sys;\n use crate::sys_common::memchr;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::buffered::IntoInnerError;\n #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n pub use self::buffered::WriterPanicked;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::buffered::{BufReader, BufWriter, LineWriter};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::copy::copy;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::cursor::Cursor;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::error::{Error, ErrorKind, Result};\n #[unstable(feature = \"internal_output_capture\", issue = \"none\")]\n #[doc(no_inline, hidden)]\n pub use self::stdio::set_output_capture;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n-#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n-pub use self::stdio::{stderr_locked, stdin_locked, stdout_locked};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n #[unstable(feature = \"print_internals\", issue = \"none\")]\n pub use self::stdio::{_eprint, _print};\n+#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n+pub use self::stdio::{stderr_locked, stdin_locked, stdout_locked};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::util::{empty, repeat, sink, Empty, Repeat, Sink};\n+pub use self::{\n+    buffered::{BufReader, BufWriter, IntoInnerError, LineWriter},\n+    copy::copy,\n+    cursor::Cursor,\n+    error::{Error, ErrorKind, Result},\n+    stdio::{stderr, stdin, stdout, Stderr, StderrLock, Stdin, StdinLock, Stdout, StdoutLock},\n+    util::{empty, repeat, sink, Empty, Repeat, Sink},\n+};\n \n #[unstable(feature = \"read_buf\", issue = \"78485\")]\n pub use self::readbuf::ReadBuf;"}, {"sha": "d78049bce24c2dcd3baf624ad04466a64107a2f1", "filename": "library/std/src/os/linux/raw.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -239,6 +239,7 @@ mod arch {\n     target_arch = \"riscv32\"\n ))]\n mod arch {\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n     pub use libc::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n }\n "}, {"sha": "a4d2ba797d9c470362bb82916cdb52e333aac634", "filename": "library/std/src/os/unix/io/raw.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -2,4 +2,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::os::fd::raw::*;"}, {"sha": "2df6d08e7aeb6f09a0bd6a70b1bb0e32cc42f57c", "filename": "src/test/ui/lint/lint-pub-unreachable-for-nested-glob.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/src%2Ftest%2Fui%2Flint%2Flint-pub-unreachable-for-nested-glob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/src%2Ftest%2Fui%2Flint%2Flint-pub-unreachable-for-nested-glob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-pub-unreachable-for-nested-glob.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+#![deny(unreachable_pub)]\n+\n+pub use self::m1::*;\n+\n+mod m1 {\n+    pub use self::m2::*;\n+\n+    mod m2 {\n+        pub struct Item1;\n+        pub struct Item2;\n+    }\n+}\n+\n+\n+pub use self::o1::{ Item42, Item24 };\n+\n+mod o1 {\n+    pub use self::o2::{ Item42, Item24 };\n+\n+    mod o2 {\n+        pub struct Item42;\n+        pub struct Item24;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fae8080c02e413c09f12a7adf91076022448a5c9", "filename": "src/tools/rustfmt/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df035a33b228daa700ac50712d9e16509d373e41/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df035a33b228daa700ac50712d9e16509d373e41/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs?ref=df035a33b228daa700ac50712d9e16509d373e41", "patch": "@@ -3,6 +3,7 @@\n #![warn(unreachable_pub)]\n #![recursion_limit = \"256\"]\n #![allow(clippy::match_like_matches_macro)]\n+#![allow(unreachable_pub)]\n \n #[macro_use]\n extern crate derive_new;"}]}