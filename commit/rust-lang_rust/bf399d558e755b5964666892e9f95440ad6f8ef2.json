{"sha": "bf399d558e755b5964666892e9f95440ad6f8ef2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMzk5ZDU1OGU3NTViNTk2NDY2Njg5MmU5Zjk1NDQwYWQ2ZjhlZjI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-16T20:25:10Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T06:19:24Z"}, "message": "std: bind uv_fs_readdir(), flesh out DirectoryInfo and docs/cleanup", "tree": {"sha": "60bba6e534cf70e65b84058dfeb8a4433579d165", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60bba6e534cf70e65b84058dfeb8a4433579d165"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf399d558e755b5964666892e9f95440ad6f8ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf399d558e755b5964666892e9f95440ad6f8ef2", "html_url": "https://github.com/rust-lang/rust/commit/bf399d558e755b5964666892e9f95440ad6f8ef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf399d558e755b5964666892e9f95440ad6f8ef2/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25b4d8c1d7de70bab8eca8a57fdfb703e5e281c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/25b4d8c1d7de70bab8eca8a57fdfb703e5e281c9", "html_url": "https://github.com/rust-lang/rust/commit/25b4d8c1d7de70bab8eca8a57fdfb703e5e281c9"}], "stats": {"total": 200, "additions": 184, "deletions": 16}, "files": [{"sha": "7aac79b964f1fda9d605a9d7c071fdf08c3c8e81", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 77, "deletions": 8, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=bf399d558e755b5964666892e9f95440ad6f8ef2", "patch": "@@ -108,6 +108,22 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n     }\n }\n \n+pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n+    let readdir_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_readdir(path, 0)\n+    };\n+    match readdir_result {\n+        Ok(p) => {\n+            Some(p)\n+        },\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n+}\n+\n /// Read-only view of file\n pub struct FileReader { priv stream: FileStream }\n \n@@ -272,6 +288,18 @@ pub trait FileSystemInfo {\n /// Represents passive information about a file (primarily exposed\n /// via the `stat()` method. Also provides methods for opening\n /// a file in various modes/permissions.\n+///\n+/// # Example\n+///\n+/// * Check if a file exists, reading from it if so\n+///\n+///     let f = &Path(\"/some/file/path.txt\");\n+///     if f.exists() {\n+///         let reader = f.open_reader(Open);\n+///         let mut mem = [0u8, 8*64000];\n+///         reader.read(mem);\n+///         // ...\n+///     }\n pub trait FileInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) points at a \"regular file\" on the FS. Will return\n@@ -290,7 +318,7 @@ pub trait FileInfo : FileSystemInfo {\n         match suppressed_stat(|| self.stat()) {\n             Some(s) => match s.is_file {\n                 true => open(self.get_path(), mode, access),\n-                false => None // FIXME: raise condition, not a regular file..\n+                false => None\n             },\n             None => open(self.get_path(), mode, access)\n         }\n@@ -320,13 +348,16 @@ pub trait FileInfo : FileSystemInfo {\n     }\n }\n \n-/// `FileSystemInfo` implementation for `Path`s \n+/// `FileSystemInfo` implementation for `Path`s\n impl FileSystemInfo for Path {\n     fn get_path<'a>(&'a self) -> &'a Path { self }\n }\n-/// `FileInfo` implementation for `Path`s \n+/// `FileInfo` implementation for `Path`s\n impl FileInfo for Path { }\n \n+/// Passive information about a directory on the filesystem. Includes\n+/// Convenience methods to iterate over a directory's contents (via `readdir`, as\n+/// as `mkdir` and `rmdir` operations.\n trait DirectoryInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) points at a directory file\" on the FS. Will return\n@@ -368,8 +399,9 @@ trait DirectoryInfo : FileSystemInfo {\n                         let ioerr = IoError {\n                             kind: MismatchedFileTypeForOperation,\n                             desc: \"Cannot do rmdir() on a non-directory\",\n-                            detail:\n-                                Some(fmt!(\"%s is a non-directory; can't rmdir it\", self.get_path().to_str()))\n+                            detail: Some(fmt!(\n+                                \"%s is a non-directory; can't rmdir it\",\n+                                self.get_path().to_str()))\n                         };\n                         io_error::cond.raise(ioerr);\n                     }\n@@ -383,14 +415,13 @@ trait DirectoryInfo : FileSystemInfo {\n                 })\n         }\n     }\n-    fn readdir(&self) -> ~[~str] {\n-        ~[]\n+    fn readdir(&self) -> Option<~[Path]> {\n+        readdir(self.get_path())\n     }\n     //fn get_subdirs(&self, filter: &str) -> ~[Path];\n     //fn get_files(&self, filter: &str) -> ~[Path];\n }\n \n-/// FIXME: DOCS\n impl DirectoryInfo for Path { }\n \n fn file_test_smoke_test_impl() {\n@@ -663,3 +694,41 @@ fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         assert!(!dir.exists());\n     }\n }\n+\n+#[test]\n+fn file_test_directoryinfo_readdir() {\n+    use str;\n+    do run_in_mt_newsched_task {\n+        let dir = &Path(\"./tmp/di_readdir\");\n+        dir.mkdir();\n+        let prefix = \"foo\";\n+        for n in range(0,3) {\n+            let f = dir.push(fmt!(\"%d.txt\", n));\n+            let mut w = f.open_writer(Create);\n+            let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n+            let msg = msg_str.as_bytes();\n+            w.write(msg);\n+        }\n+        match dir.readdir() {\n+            Some(files) => {\n+                let mut mem = [0u8, .. 4];\n+                for f in files.iter() {\n+                    {\n+                        let n = f.filestem();\n+                        let mut r = f.open_reader(Open);\n+                        r.read(mem);\n+                        let read_str = str::from_utf8(mem);\n+                        let expected = match n {\n+                            Some(n) => prefix+n,\n+                            None => fail!(\"really shouldn't happen..\")\n+                        };\n+                        assert!(expected == read_str);\n+                    }\n+                    f.unlink();\n+                }\n+            },\n+            None => fail!(\"shouldn't happen\")\n+        }\n+        dir.rmdir();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "568ea3317e53d119c7201c4a1725caa3761cc33a", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=bf399d558e755b5964666892e9f95440ad6f8ef2", "patch": "@@ -78,6 +78,8 @@ pub trait IoFactory {\n     //fn fs_fstat(&mut self, fd: c_int) -> Result<FileStat, IoError>;\n     fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n     fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n+    fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n+        Result<~[Path], IoError>;\n }\n \n pub trait RtioStream {"}, {"sha": "cd0a217cc45a908275bccae99b5e2456ffb50f2a", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=bf399d558e755b5964666892e9f95440ad6f8ef2", "patch": "@@ -17,6 +17,7 @@ use rt::uv::uvll;\n use rt::uv::uvll::*;\n use super::super::io::support::PathLike;\n use cast::transmute;\n+use libc;\n use libc::{c_int};\n use option::{None, Some, Option};\n \n@@ -28,14 +29,6 @@ pub struct RequestData {\n }\n \n impl FsRequest {\n-    pub fn new_REFACTOR_ME(cb: Option<FsCallback>) -> FsRequest {\n-        let fs_req = unsafe { malloc_req(UV_FS) };\n-        assert!(fs_req.is_not_null());\n-        let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n-        fs_req.install_req_data(cb);\n-        fs_req\n-    }\n-\n     pub fn new() -> FsRequest {\n         let fs_req = unsafe { malloc_req(UV_FS) };\n         assert!(fs_req.is_not_null());\n@@ -180,6 +173,17 @@ impl FsRequest {\n         });\n     }\n \n+    pub fn readdir<P: PathLike>(self, loop_: &Loop, path: &P,\n+                                flags: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_readdir(loop_.native_handle(),\n+                          self.native_handle(), p, flags, complete_cb_ptr)\n+            })\n+        });\n+    }\n+\n     // accessors/utility funcs\n     fn sync_cleanup(self, result: c_int)\n           -> Result<c_int, UvError> {\n@@ -235,6 +239,36 @@ impl FsRequest {\n         stat\n     }\n \n+    pub fn get_ptr(&self) -> *libc::c_void {\n+        unsafe {\n+            uvll::get_ptr_from_fs_req(self.native_handle())\n+        }\n+    }\n+\n+    pub fn get_paths(&mut self) -> ~[~str] {\n+        use str;\n+        let ptr = self.get_ptr();\n+        match self.get_result() {\n+            n if (n <= 0) => {\n+                ~[]\n+            },\n+            n => {\n+                let n_len = n as uint;\n+                // we pass in the len that uv tells us is there\n+                // for the entries and we don't continue past that..\n+                // it appears that sometimes the multistring isn't\n+                // correctly delimited and we stray into garbage memory?\n+                // in any case, passing Some(n_len) fixes it and ensures\n+                // good results\n+                let raw_path_strs = unsafe {\n+                    str::raw::from_c_multistring(ptr as *libc::c_char, Some(n_len)) };\n+                let raw_len = raw_path_strs.len();\n+                assert_eq!(raw_len, n_len);\n+                raw_path_strs\n+            }\n+        }\n+    }\n+\n     fn cleanup_and_delete(self) {\n         unsafe {\n             let data = uvll::get_data_for_req(self.native_handle());"}, {"sha": "2d024f04e1d8b48ece8c5dde33ac513f0a715ee8", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=bf399d558e755b5964666892e9f95440ad6f8ef2", "patch": "@@ -704,6 +704,44 @@ impl IoFactory for UvIoFactory {\n             };\n         }\n     }\n+    fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n+        Result<~[Path], IoError> {\n+        use str::StrSlice;\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~[Path],\n+                                           IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            let stat_req = file::FsRequest::new();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let path = path_cell.take();\n+                let path_str = path.path_as_str(|p| p.to_owned());\n+                do stat_req.readdir(self.uv_loop(), path, flags)\n+                      |req,err| {\n+                    let res = match err {\n+                        None => {\n+                            let rel_paths = req.get_paths();\n+                            let mut paths = ~[];\n+                            for r in rel_paths.iter() {\n+                                paths.push(Path(path_str+\"/\"+*r));\n+                            }\n+                            Ok(paths)\n+                        },\n+                        Some(e) => {\n+                            Err(uv_error_to_io_error(e))\n+                        }\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                };\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n }\n \n pub struct UvTcpListener {"}, {"sha": "42102a52e2e356a74bdcdeffe7414a1305ba9c46", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=bf399d558e755b5964666892e9f95440ad6f8ef2", "patch": "@@ -811,6 +811,12 @@ pub unsafe fn fs_rmdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n \n     rust_uv_fs_rmdir(loop_ptr, req, path, cb)\n }\n+pub unsafe fn fs_readdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                flags: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_readdir(loop_ptr, req, path, flags, cb)\n+}\n pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -828,6 +834,11 @@ pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n \n     rust_uv_get_result_from_fs_req(req)\n }\n+pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_ptr_from_fs_req(req)\n+}\n pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -1014,9 +1025,12 @@ extern {\n                         mode: c_int, cb: *u8) -> c_int;\n     fn rust_uv_fs_rmdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n                         cb: *u8) -> c_int;\n+    fn rust_uv_fs_readdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        flags: c_int, cb: *u8) -> c_int;\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n     fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n+    fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n     fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n "}, {"sha": "9b460cffd747c920f062a99e4429f23c0864bf83", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=bf399d558e755b5964666892e9f95440ad6f8ef2", "patch": "@@ -542,6 +542,10 @@ extern \"C\" int\n rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n   return req->result;\n }\n+extern \"C\" void*\n+rust_uv_get_ptr_from_fs_req(uv_fs_t* req) {\n+  return req->ptr;\n+}\n extern \"C\" uv_loop_t*\n rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n   return req->loop;\n@@ -593,3 +597,8 @@ extern \"C\" int\n rust_uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n   return uv_fs_rmdir(loop, req, path, cb);\n }\n+\n+extern \"C\" int\n+rust_uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, uv_fs_cb cb) {\n+  return uv_fs_readdir(loop, req, path, flags, cb);\n+}"}, {"sha": "3be958837dc4b8fd3a74ff2f5364265d1f18a874", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/bf399d558e755b5964666892e9f95440ad6f8ef2/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=bf399d558e755b5964666892e9f95440ad6f8ef2", "patch": "@@ -113,13 +113,15 @@ rust_uv_fs_write\n rust_uv_fs_read\n rust_uv_fs_close\n rust_uv_get_result_from_fs_req\n+rust_uv_get_ptr_from_fs_req\n rust_uv_get_loop_from_fs_req\n rust_uv_fs_stat\n rust_uv_fs_fstat\n rust_uv_fs_req_cleanup\n rust_uv_populate_uv_stat\n rust_uv_fs_mkdir\n rust_uv_fs_rmdir\n+rust_uv_fs_readdir\n rust_dbg_lock_create\n rust_dbg_lock_destroy\n rust_dbg_lock_lock"}]}