{"sha": "4bc5911348b5b74b4c561325e29111621776de15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYzU5MTEzNDhiNWI3NGI0YzU2MTMyNWUyOTExMTYyMTc3NmRlMTU=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-05-10T07:48:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-10T07:48:01Z"}, "message": "Merge pull request #3526 from bash/refactor-apply-newline-style\n\nRefactor apply newline style", "tree": {"sha": "c4c436b848bb92b32e84e54fa9deaf408b260b50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4c436b848bb92b32e84e54fa9deaf408b260b50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bc5911348b5b74b4c561325e29111621776de15", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc1SyxCRBK7hj4Ov3rIwAAdHIIAJG2D7bFHlBPfMKDuPRSo+pv\n1F6M0oTxe//TyUcitXrvlpi0iGV73qtjDuUafQXpor5ef+r50HnpvxjXmdcmCjG+\n3d9+GisXABiXihtMXhrv5Y8l1OY2qN/CH2VAWnjD9KZTMj4uVDwjjUltYX7G9bW0\nt/RMINuQfOtBDJX45c1a9po/3FOr5jXVIujVwSE1+hf2GGneFYwZq6vJZ+HaXVx5\nSrPV19hG9hDhKarK57iLKeSoOteBxRWwXrcs6K7OHroioPZMjnObHNnSsNIx+peF\nPHpg6BQJ0yJpbGplIxm0KloRa+xb84MWRQh2j004TxeOYAHMQJ9AblMkxdOyRmY=\n=j5ZZ\n-----END PGP SIGNATURE-----\n", "payload": "tree c4c436b848bb92b32e84e54fa9deaf408b260b50\nparent 509f4c21544d67ea3533967154f2573a12ed6303\nparent 821a370417104c622fe8d952a7fce3384a1dde44\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1557474481 +0200\ncommitter GitHub <noreply@github.com> 1557474481 +0200\n\nMerge pull request #3526 from bash/refactor-apply-newline-style\n\nRefactor apply newline style"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc5911348b5b74b4c561325e29111621776de15", "html_url": "https://github.com/rust-lang/rust/commit/4bc5911348b5b74b4c561325e29111621776de15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bc5911348b5b74b4c561325e29111621776de15/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "509f4c21544d67ea3533967154f2573a12ed6303", "url": "https://api.github.com/repos/rust-lang/rust/commits/509f4c21544d67ea3533967154f2573a12ed6303", "html_url": "https://github.com/rust-lang/rust/commit/509f4c21544d67ea3533967154f2573a12ed6303"}, {"sha": "821a370417104c622fe8d952a7fce3384a1dde44", "url": "https://api.github.com/repos/rust-lang/rust/commits/821a370417104c622fe8d952a7fce3384a1dde44", "html_url": "https://github.com/rust-lang/rust/commit/821a370417104c622fe8d952a7fce3384a1dde44"}], "stats": {"total": 382, "additions": 267, "deletions": 115}, "files": [{"sha": "4de8ef928dd593d85854a7e6a0e30f6aae8ef70e", "filename": "src/config/options.rs", "status": "modified", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/4bc5911348b5b74b4c561325e29111621776de15/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc5911348b5b74b4c561325e29111621776de15/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=4bc5911348b5b74b4c561325e29111621776de15", "patch": "@@ -22,62 +22,6 @@ pub enum NewlineStyle {\n     Native,\n }\n \n-impl NewlineStyle {\n-    fn auto_detect(raw_input_text: &str) -> NewlineStyle {\n-        if let Some(pos) = raw_input_text.find('\\n') {\n-            let pos = pos.saturating_sub(1);\n-            if let Some('\\r') = raw_input_text.chars().nth(pos) {\n-                NewlineStyle::Windows\n-            } else {\n-                NewlineStyle::Unix\n-            }\n-        } else {\n-            NewlineStyle::Native\n-        }\n-    }\n-\n-    fn native() -> NewlineStyle {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n-        } else {\n-            NewlineStyle::Unix\n-        }\n-    }\n-\n-    /// Apply this newline style to the formatted text. When the style is set\n-    /// to `Auto`, the `raw_input_text` is used to detect the existing line\n-    /// endings.\n-    ///\n-    /// If the style is set to `Auto` and `raw_input_text` contains no\n-    /// newlines, the `Native` style will be used.\n-    pub(crate) fn apply(self, formatted_text: &mut String, raw_input_text: &str) {\n-        use crate::NewlineStyle::*;\n-        let mut style = self;\n-        if style == Auto {\n-            style = Self::auto_detect(raw_input_text);\n-        }\n-        if style == Native {\n-            style = Self::native();\n-        }\n-        match style {\n-            Windows => {\n-                let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n-                for c in formatted_text.chars() {\n-                    match c {\n-                        '\\n' => transformed.push_str(\"\\r\\n\"),\n-                        '\\r' => continue,\n-                        c => transformed.push(c),\n-                    }\n-                }\n-                *formatted_text = transformed;\n-            }\n-            Unix => return,\n-            Native => unreachable!(\"NewlineStyle::Native\"),\n-            Auto => unreachable!(\"NewlineStyle::Auto\"),\n-        }\n-    }\n-}\n-\n #[config_type]\n /// Where to put the opening brace of items (`fn`, `impl`, etc.).\n pub enum BraceStyle {\n@@ -412,59 +356,3 @@ impl Edition {\n         }\n     }\n }\n-\n-#[test]\n-fn test_newline_style_auto_detect() {\n-    let lf = \"One\\nTwo\\nThree\";\n-    let crlf = \"One\\r\\nTwo\\r\\nThree\";\n-    let none = \"One Two Three\";\n-\n-    assert_eq!(NewlineStyle::Unix, NewlineStyle::auto_detect(lf));\n-    assert_eq!(NewlineStyle::Windows, NewlineStyle::auto_detect(crlf));\n-    assert_eq!(NewlineStyle::Native, NewlineStyle::auto_detect(none));\n-}\n-\n-#[test]\n-fn test_newline_style_auto_apply() {\n-    let auto = NewlineStyle::Auto;\n-\n-    let formatted_text = \"One\\nTwo\\nThree\";\n-    let raw_input_text = \"One\\nTwo\\nThree\";\n-\n-    let mut out = String::from(formatted_text);\n-    auto.apply(&mut out, raw_input_text);\n-    assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n-\n-    let formatted_text = \"One\\nTwo\\nThree\";\n-    let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n-\n-    let mut out = String::from(formatted_text);\n-    auto.apply(&mut out, raw_input_text);\n-    assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n-\n-    #[cfg(not(windows))]\n-    {\n-        let formatted_text = \"One\\nTwo\\nThree\";\n-        let raw_input_text = \"One Two Three\";\n-\n-        let mut out = String::from(formatted_text);\n-        auto.apply(&mut out, raw_input_text);\n-        assert_eq!(\n-            \"One\\nTwo\\nThree\", &out,\n-            \"auto-native-unix should detect 'lf'\"\n-        );\n-    }\n-\n-    #[cfg(windows)]\n-    {\n-        let formatted_text = \"One\\nTwo\\nThree\";\n-        let raw_input_text = \"One Two Three\";\n-\n-        let mut out = String::from(formatted_text);\n-        auto.apply(&mut out, raw_input_text);\n-        assert_eq!(\n-            \"One\\r\\nTwo\\r\\nThree\", &out,\n-            \"auto-native-windows should detect 'crlf'\"\n-        );\n-    }\n-}"}, {"sha": "3ae73ea1c990dd67a7e7cfb4f28d06395c69e9ee", "filename": "src/formatting.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bc5911348b5b74b4c561325e29111621776de15/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc5911348b5b74b4c561325e29111621776de15/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=4bc5911348b5b74b4c561325e29111621776de15", "patch": "@@ -12,6 +12,7 @@ use syntax::errors::{DiagnosticBuilder, Handler};\n use syntax::parse::{self, ParseSess};\n use syntax::source_map::{FilePathMapping, SourceMap, Span, DUMMY_SP};\n \n+use self::newline_style::apply_newline_style;\n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n use crate::ignore_path::IgnorePathSet;\n@@ -20,6 +21,8 @@ use crate::utils::{count_newlines, get_skip_macro_names};\n use crate::visitor::{FmtVisitor, SnippetProvider};\n use crate::{modules, source_file, ErrorKind, FormatReport, Input, Session};\n \n+mod newline_style;\n+\n // A map of the files of a crate, with their new content\n pub(crate) type SourceFile = Vec<FileRecord>;\n pub(crate) type FileRecord = (FileName, String);\n@@ -191,9 +194,12 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             &self.config,\n             &self.report,\n         );\n-        self.config\n-            .newline_style()\n-            .apply(&mut visitor.buffer, &big_snippet);\n+\n+        apply_newline_style(\n+            self.config.newline_style(),\n+            &mut visitor.buffer,\n+            &big_snippet,\n+        );\n \n         if visitor.macro_rewrite_failure {\n             self.report.add_macro_format_failure();"}, {"sha": "ac62009490001ab8d5101cf6d2ddfd419e4c3f0b", "filename": "src/formatting/newline_style.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/4bc5911348b5b74b4c561325e29111621776de15/src%2Fformatting%2Fnewline_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc5911348b5b74b4c561325e29111621776de15/src%2Fformatting%2Fnewline_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting%2Fnewline_style.rs?ref=4bc5911348b5b74b4c561325e29111621776de15", "patch": "@@ -0,0 +1,250 @@\n+use crate::NewlineStyle;\n+\n+/// Apply this newline style to the formatted text. When the style is set\n+/// to `Auto`, the `raw_input_text` is used to detect the existing line\n+/// endings.\n+///\n+/// If the style is set to `Auto` and `raw_input_text` contains no\n+/// newlines, the `Native` style will be used.\n+pub(crate) fn apply_newline_style(\n+    newline_style: NewlineStyle,\n+    formatted_text: &mut String,\n+    raw_input_text: &str,\n+) {\n+    *formatted_text = match effective_newline_style(newline_style, raw_input_text) {\n+        EffectiveNewlineStyle::Windows => convert_to_windows_newlines(formatted_text),\n+        EffectiveNewlineStyle::Unix => convert_to_unix_newlines(formatted_text),\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum EffectiveNewlineStyle {\n+    Windows,\n+    Unix,\n+}\n+\n+fn effective_newline_style(\n+    newline_style: NewlineStyle,\n+    raw_input_text: &str,\n+) -> EffectiveNewlineStyle {\n+    match newline_style {\n+        NewlineStyle::Auto => auto_detect_newline_style(raw_input_text),\n+        NewlineStyle::Native => native_newline_style(),\n+        NewlineStyle::Windows => EffectiveNewlineStyle::Windows,\n+        NewlineStyle::Unix => EffectiveNewlineStyle::Unix,\n+    }\n+}\n+\n+const LINE_FEED: char = '\\n';\n+const CARRIAGE_RETURN: char = '\\r';\n+const WINDOWS_NEWLINE: &str = \"\\r\\n\";\n+const UNIX_NEWLINE: &str = \"\\n\";\n+\n+fn auto_detect_newline_style(raw_input_text: &str) -> EffectiveNewlineStyle {\n+    let first_line_feed_pos = raw_input_text.chars().position(|ch| ch == LINE_FEED);\n+    match first_line_feed_pos {\n+        Some(first_line_feed_pos) => {\n+            let char_before_line_feed_pos = first_line_feed_pos.saturating_sub(1);\n+            let char_before_line_feed = raw_input_text.chars().nth(char_before_line_feed_pos);\n+            match char_before_line_feed {\n+                Some(CARRIAGE_RETURN) => EffectiveNewlineStyle::Windows,\n+                _ => EffectiveNewlineStyle::Unix,\n+            }\n+        }\n+        None => native_newline_style(),\n+    }\n+}\n+\n+fn native_newline_style() -> EffectiveNewlineStyle {\n+    if cfg!(windows) {\n+        EffectiveNewlineStyle::Windows\n+    } else {\n+        EffectiveNewlineStyle::Unix\n+    }\n+}\n+\n+fn convert_to_windows_newlines(formatted_text: &String) -> String {\n+    let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n+    let mut chars = formatted_text.chars().peekable();\n+    while let Some(current_char) = chars.next() {\n+        let next_char = chars.peek();\n+        match current_char {\n+            LINE_FEED => transformed.push_str(WINDOWS_NEWLINE),\n+            CARRIAGE_RETURN if next_char == Some(&LINE_FEED) => {}\n+            current_char => transformed.push(current_char),\n+        }\n+    }\n+    transformed\n+}\n+\n+fn convert_to_unix_newlines(formatted_text: &String) -> String {\n+    formatted_text.replace(WINDOWS_NEWLINE, UNIX_NEWLINE)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn auto_detects_unix_newlines() {\n+        assert_eq!(\n+            EffectiveNewlineStyle::Unix,\n+            auto_detect_newline_style(\"One\\nTwo\\nThree\")\n+        );\n+    }\n+\n+    #[test]\n+    fn auto_detects_windows_newlines() {\n+        assert_eq!(\n+            EffectiveNewlineStyle::Windows,\n+            auto_detect_newline_style(\"One\\r\\nTwo\\r\\nThree\")\n+        );\n+    }\n+\n+    #[test]\n+    fn auto_detects_windows_newlines_with_multibyte_char_on_first_line() {\n+        assert_eq!(\n+            EffectiveNewlineStyle::Windows,\n+            auto_detect_newline_style(\"A \ud83c\udfa2 of a first line\\r\\nTwo\\r\\nThree\")\n+        );\n+    }\n+\n+    #[test]\n+    fn falls_back_to_native_newlines_if_no_newlines_are_found() {\n+        let expected_newline_style = if cfg!(windows) {\n+            EffectiveNewlineStyle::Windows\n+        } else {\n+            EffectiveNewlineStyle::Unix\n+        };\n+        assert_eq!(\n+            expected_newline_style,\n+            auto_detect_newline_style(\"One Two Three\")\n+        );\n+    }\n+\n+    #[test]\n+    fn auto_detects_and_applies_unix_newlines() {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One\\nTwo\\nThree\";\n+\n+        let mut out = String::from(formatted_text);\n+        apply_newline_style(NewlineStyle::Auto, &mut out, raw_input_text);\n+        assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n+    }\n+\n+    #[test]\n+    fn auto_detects_and_applies_windows_newlines() {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n+\n+        let mut out = String::from(formatted_text);\n+        apply_newline_style(NewlineStyle::Auto, &mut out, raw_input_text);\n+        assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n+    }\n+\n+    #[test]\n+    fn auto_detects_and_applies_native_newlines() {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One Two Three\";\n+\n+        let mut out = String::from(formatted_text);\n+        apply_newline_style(NewlineStyle::Auto, &mut out, raw_input_text);\n+\n+        if cfg!(windows) {\n+            assert_eq!(\n+                \"One\\r\\nTwo\\r\\nThree\", &out,\n+                \"auto-native-windows should detect 'crlf'\"\n+            );\n+        } else {\n+            assert_eq!(\n+                \"One\\nTwo\\nThree\", &out,\n+                \"auto-native-unix should detect 'lf'\"\n+            );\n+        }\n+    }\n+\n+    #[test]\n+    fn applies_unix_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\r\\nTwo\\nThree\",\n+            \"One\\nTwo\\nThree\",\n+            NewlineStyle::Unix,\n+        );\n+    }\n+\n+    #[test]\n+    fn applying_unix_newlines_changes_nothing_for_unix_newlines() {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        test_newlines_are_applied_correctly(formatted_text, formatted_text, NewlineStyle::Unix);\n+    }\n+\n+    #[test]\n+    fn applies_unix_newlines_to_string_with_unix_and_windows_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\r\\nTwo\\r\\nThree\\nFour\",\n+            \"One\\nTwo\\nThree\\nFour\",\n+            NewlineStyle::Unix,\n+        );\n+    }\n+\n+    #[test]\n+    fn applies_windows_newlines_to_string_with_unix_and_windows_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\nTwo\\nThree\\r\\nFour\",\n+            \"One\\r\\nTwo\\r\\nThree\\r\\nFour\",\n+            NewlineStyle::Windows,\n+        );\n+    }\n+\n+    #[test]\n+    fn applying_windows_newlines_changes_nothing_for_windows_newlines() {\n+        let formatted_text = \"One\\r\\nTwo\\r\\nThree\";\n+        test_newlines_are_applied_correctly(formatted_text, formatted_text, NewlineStyle::Windows);\n+    }\n+\n+    #[test]\n+    fn keeps_carriage_returns_when_applying_windows_newlines_to_str_with_unix_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\nTwo\\nThree\\rDrei\",\n+            \"One\\r\\nTwo\\r\\nThree\\rDrei\",\n+            NewlineStyle::Windows,\n+        );\n+    }\n+\n+    #[test]\n+    fn keeps_carriage_returns_when_applying_unix_newlines_to_str_with_unix_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\nTwo\\nThree\\rDrei\",\n+            \"One\\nTwo\\nThree\\rDrei\",\n+            NewlineStyle::Unix,\n+        );\n+    }\n+\n+    #[test]\n+    fn keeps_carriage_returns_when_applying_windows_newlines_to_str_with_windows_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\r\\nTwo\\r\\nThree\\rDrei\",\n+            \"One\\r\\nTwo\\r\\nThree\\rDrei\",\n+            NewlineStyle::Windows,\n+        );\n+    }\n+\n+    #[test]\n+    fn keeps_carriage_returns_when_applying_unix_newlines_to_str_with_windows_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\r\\nTwo\\r\\nThree\\rDrei\",\n+            \"One\\nTwo\\nThree\\rDrei\",\n+            NewlineStyle::Unix,\n+        );\n+    }\n+\n+    fn test_newlines_are_applied_correctly(\n+        input: &str,\n+        expected: &str,\n+        newline_style: NewlineStyle,\n+    ) {\n+        let mut out = String::from(input);\n+        apply_newline_style(newline_style, &mut out, input);\n+        assert_eq!(expected, &out);\n+    }\n+}"}, {"sha": "e5e0b28659896a8ee2882a768009863c8ed39637", "filename": "tests/source/preserves_carriage_return_for_unix.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bc5911348b5b74b4c561325e29111621776de15/tests%2Fsource%2Fpreserves_carriage_return_for_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc5911348b5b74b4c561325e29111621776de15/tests%2Fsource%2Fpreserves_carriage_return_for_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpreserves_carriage_return_for_unix.rs?ref=4bc5911348b5b74b4c561325e29111621776de15", "patch": "@@ -0,0 +1,2 @@\n+// rustfmt-newline_style: Unix\n+// Foo\rBar"}, {"sha": "1085360ee59e829c24af7f434057a5d99529760c", "filename": "tests/source/preserves_carriage_return_for_windows.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bc5911348b5b74b4c561325e29111621776de15/tests%2Fsource%2Fpreserves_carriage_return_for_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc5911348b5b74b4c561325e29111621776de15/tests%2Fsource%2Fpreserves_carriage_return_for_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpreserves_carriage_return_for_windows.rs?ref=4bc5911348b5b74b4c561325e29111621776de15", "patch": "@@ -0,0 +1,2 @@\n+// rustfmt-newline_style: Windows\n+// Foo\rBar"}, {"sha": "e5e0b28659896a8ee2882a768009863c8ed39637", "filename": "tests/target/preserves_carriage_return_for_unix.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bc5911348b5b74b4c561325e29111621776de15/tests%2Ftarget%2Fpreserves_carriage_return_for_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc5911348b5b74b4c561325e29111621776de15/tests%2Ftarget%2Fpreserves_carriage_return_for_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpreserves_carriage_return_for_unix.rs?ref=4bc5911348b5b74b4c561325e29111621776de15", "patch": "@@ -0,0 +1,2 @@\n+// rustfmt-newline_style: Unix\n+// Foo\rBar"}, {"sha": "1085360ee59e829c24af7f434057a5d99529760c", "filename": "tests/target/preserves_carriage_return_for_windows.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bc5911348b5b74b4c561325e29111621776de15/tests%2Ftarget%2Fpreserves_carriage_return_for_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc5911348b5b74b4c561325e29111621776de15/tests%2Ftarget%2Fpreserves_carriage_return_for_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpreserves_carriage_return_for_windows.rs?ref=4bc5911348b5b74b4c561325e29111621776de15", "patch": "@@ -0,0 +1,2 @@\n+// rustfmt-newline_style: Windows\n+// Foo\rBar"}]}