{"sha": "4b23f403e554153f5e7c204448c905762fd17e4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMjNmNDAzZTU1NDE1M2Y1ZTdjMjA0NDQ4YzkwNTc2MmZkMTdlNGI=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-31T18:54:44Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-12-03T11:28:28Z"}, "message": "extend the docs for `WithOptConstParam`", "tree": {"sha": "ab1a9a3ac3aa9cd7c4278321b9eb31ce1cccf560", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab1a9a3ac3aa9cd7c4278321b9eb31ce1cccf560"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b23f403e554153f5e7c204448c905762fd17e4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b23f403e554153f5e7c204448c905762fd17e4b", "html_url": "https://github.com/rust-lang/rust/commit/4b23f403e554153f5e7c204448c905762fd17e4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b23f403e554153f5e7c204448c905762fd17e4b/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8defab08dfcac3ecc63247465fdcddd403c44b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8defab08dfcac3ecc63247465fdcddd403c44b8", "html_url": "https://github.com/rust-lang/rust/commit/b8defab08dfcac3ecc63247465fdcddd403c44b8"}], "stats": {"total": 51, "additions": 38, "deletions": 13}, "files": [{"sha": "2d7f417b64a1dd6c921f233b08ea27b7ce26a36b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4b23f403e554153f5e7c204448c905762fd17e4b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b23f403e554153f5e7c204448c905762fd17e4b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=4b23f403e554153f5e7c204448c905762fd17e4b", "patch": "@@ -1683,34 +1683,59 @@ pub struct BoundConst<'tcx> {\n \n pub type PlaceholderConst<'tcx> = Placeholder<BoundConst<'tcx>>;\n \n-/// A `DefId` which is potentially bundled with its corresponding generic parameter\n-/// in case `did` is a const argument.\n+/// A `DefId` which, in case it is a const argument, is potentially bundled with\n+/// the `DefId` of the generic parameter it instantiates.\n ///\n-/// This is used to prevent cycle errors during typeck\n-/// as `type_of(const_arg)` depends on `typeck(owning_body)`\n-/// which once again requires the type of its generic arguments.\n-///\n-/// Luckily we only need to deal with const arguments once we\n-/// know their corresponding parameters. We (ab)use this by\n-/// calling `type_of(param_did)` for these arguments.\n+/// This is used to avoid calls to `type_of` for const arguments during typeck\n+/// which cause cycle errors.\n ///\n /// ```rust\n /// #![feature(const_generics)]\n ///\n /// struct A;\n /// impl A {\n-///     fn foo<const N: usize>(&self) -> usize { N }\n+///     fn foo<const N: usize>(&self) -> [u8; N] { [0; N] }\n+///     //           ^ const parameter\n /// }\n /// struct B;\n /// impl B {\n-///     fn foo<const N: u8>(&self) -> usize { 42 }\n+///     fn foo<const M: u8>(&self) -> usize { 42 }\n+///     //           ^ const parameter\n /// }\n ///\n /// fn main() {\n ///     let a = A;\n-///     a.foo::<7>();\n+///     let _b = a.foo::<{ 3 + 7 }>();\n+///     //               ^^^^^^^^^ const argument\n /// }\n /// ```\n+///\n+/// Let's look at the call `a.foo::<{ 3 + 7 }>()` here. We do not know\n+/// which `foo` is used until we know the type of `a`.\n+///\n+/// We only know the type of `a` once we are inside of `typeck(main)`.\n+/// We also end up normalizing the type of `_b` during `typeck(main)` which\n+/// requires us to evaluate the const argument.\n+///\n+/// To evaluate that const argument we need to know its type,\n+/// which we would get using `type_of(const_arg)`. This requires us to\n+/// resolve `foo` as it can be either `usize` or `u8` in this example.\n+/// However, resolving `foo` once again requires `typeck(main)` to get the type of `a`,\n+/// which results in a cycle.\n+///\n+/// In short we must not call `type_of(const_arg)` during `typeck(main)`.\n+///\n+/// When first creating the `ty::Const` of the const argument inside of `typeck` we have\n+/// already resolved `foo` so we know which const parameter this argument instantiates.\n+/// This means that we also know the expected result of `type_of(const_arg)` even if we\n+/// aren't allowed to call that query: it is equal to `type_of(const_param)` which is\n+/// trivial to compute.\n+///\n+/// If we now want to use that constant in a place which potentionally needs its type\n+/// we also pass the type of its `const_param`. This is the point of `WithOptConstParam`,\n+/// except that instead of a `Ty` we bundle the `DefId` of the const parameter.\n+/// Meaning that we need to use `type_of(const_param_did)` if `const_param_did` is `Some`\n+/// to get the type of `did`.\n #[derive(Copy, Clone, Debug, TypeFoldable, Lift, TyEncodable, TyDecodable)]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n #[derive(Hash, HashStable)]\n@@ -1721,7 +1746,7 @@ pub struct WithOptConstParam<T> {\n     ///\n     /// Note that even if `did` is a const argument, this may still be `None`.\n     /// All queries taking `WithOptConstParam` start by calling `tcx.opt_const_param_of(def.did)`\n-    /// to potentially update `param_did` in case it `None`.\n+    /// to potentially update `param_did` in the case it is `None`.\n     pub const_param_did: Option<DefId>,\n }\n "}]}