{"sha": "a7d296f24c785e359bfd6d9e491fd8854c3ad967", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZDI5NmYyNGM3ODVlMzU5YmZkNmQ5ZTQ5MWZkODg1NGMzYWQ5Njc=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-20T18:13:13Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-21T00:50:32Z"}, "message": "renamed str::view -> slice_DBG_BRWD\nrenamed str::slice -> slice_DBG_UNIQ\nchanged vec slice method -> to_owned()\nrenamed vec view method  -> slice_V_DBG_BRWD", "tree": {"sha": "dd86187e73441b9bc2bad0157a49f791baac6e06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd86187e73441b9bc2bad0157a49f791baac6e06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7d296f24c785e359bfd6d9e491fd8854c3ad967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d296f24c785e359bfd6d9e491fd8854c3ad967", "html_url": "https://github.com/rust-lang/rust/commit/a7d296f24c785e359bfd6d9e491fd8854c3ad967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7d296f24c785e359bfd6d9e491fd8854c3ad967/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b12714eff5dd2ccde118c520444990216739e006", "url": "https://api.github.com/repos/rust-lang/rust/commits/b12714eff5dd2ccde118c520444990216739e006", "html_url": "https://github.com/rust-lang/rust/commit/b12714eff5dd2ccde118c520444990216739e006"}], "stats": {"total": 310, "additions": 162, "deletions": 148}, "files": [{"sha": "5709d434f60ed6f89a99c06cc27e9c2cf718b8ec", "filename": "doc/rust.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -806,7 +806,7 @@ An example of `use` declarations:\n \n ~~~~\n use core::float::sin;\n-use core::str::{slice, to_upper};\n+use core::str::{slice_DBG_BRWD, to_upper};\n use core::option::Some;\n \n fn main() {\n@@ -817,8 +817,8 @@ fn main() {\n     info!(Some(1.0));\n \n     // Equivalent to\n-    // 'info!(core::str::to_upper(core::str::slice(\"foo\", 0, 1)));'\n-    info!(to_upper(slice(\"foo\", 0, 1)));\n+    // 'info!(core::str::to_upper(core::str::slice_DBG_BRWD(\"foo\", 0, 1)));'\n+    info!(to_upper(slice_DBG_BRWD(\"foo\", 0, 1)));\n }\n ~~~~\n \n@@ -2668,7 +2668,7 @@ Within the body of an item that has type parameter declarations, the names of it\n fn map<A: Copy, B: Copy>(f: &fn(A) -> B, xs: &[A]) -> ~[B] {\n    if xs.len() == 0 { return ~[]; }\n    let first: B = f(xs[0]);\n-   let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n+   let rest: ~[B] = map(f, xs.slice_V_DBG_BRWD(1, xs.len()));\n    return ~[first] + rest;\n }\n ~~~~~~~"}, {"sha": "152546031630627a2f17a423838209f89cc05802", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -51,11 +51,11 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n         while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n         let start_kind = idx;\n         while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n-        let kind = str::to_lower(str::slice(line, start_kind, idx));\n+        let kind = str::to_lower(str::slice_DBG_BRWD(line, start_kind, idx).to_owned());\n \n         // Extract msg:\n         while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-        let msg = str::slice(line, idx, len);\n+        let msg = str::slice_DBG_BRWD(line, idx, len).to_owned();\n \n         debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n "}, {"sha": "576f8a2942f1f3c26e9708dd9cd0c8003a55101a", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -174,8 +174,8 @@ fn parse_name_value_directive(line: ~str,\n         let keycolon = directive + ~\":\";\n         match str::find_str(line, keycolon) {\n             Some(colon) => {\n-                let value = str::slice(line, colon + str::len(keycolon),\n-                                       str::len(line));\n+                let value = str::slice_DBG_BRWD(line, colon + str::len(keycolon),\n+                                       str::len(line)).to_owned();\n                 debug!(\"%s: %s\", directive,  value);\n                 Some(value)\n             }"}, {"sha": "272e44c796fc8c27c781699030f9cdcf10204aab", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -364,14 +364,14 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = buf.slice(0, i + 1);\n+                buf = buf.slice_V_DBG_BRWD(0, i + 1).to_owned();\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n         if buf[max_i] == '.' as u8 {\n-            buf = buf.slice(0, max_i);\n+            buf = buf.slice_V_DBG_BRWD(0, max_i).to_owned();\n         }\n     }\n \n@@ -606,7 +606,7 @@ pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n         // parse remaining bytes as decimal integer,\n         // skipping the exponent char\n         let exp: Option<int> = from_str_bytes_common(\n-            buf.view(i+1, len), 10, true, false, false, ExpNone, false);\n+            buf.slice_V_DBG_BRWD(i+1, len), 10, true, false, false, ExpNone, false);\n \n         match exp {\n             Some(exp_pow) => {"}, {"sha": "47d823f89ffce7f86ce04492b6b43cfeae3ba86a", "filename": "src/libcore/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -410,7 +410,7 @@ impl GenericPath for PosixPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice(0, p)),\n+              Some(p) => Some(f.slice_DBG_BRWD(0, p).to_owned()),\n               None => Some(copy *f)\n             }\n           }\n@@ -422,7 +422,7 @@ impl GenericPath for PosixPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) if p < f.len() => Some(f.slice(p, f.len())),\n+              Some(p) if p < f.len() => Some(f.slice_DBG_BRWD(p, f.len()).to_owned()),\n               _ => None\n             }\n           }\n@@ -622,7 +622,7 @@ impl GenericPath for WindowsPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice(0, p)),\n+              Some(p) => Some(f.slice_DBG_BRWD(0, p).to_owned()),\n               None => Some(copy *f)\n             }\n           }\n@@ -634,7 +634,7 @@ impl GenericPath for WindowsPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) if p < f.len() => Some(f.slice(p, f.len())),\n+              Some(p) if p < f.len() => Some(f.slice_DBG_BRWD(p, f.len()).to_owned()),\n               _ => None\n             }\n           }\n@@ -842,8 +842,8 @@ pub mod windows {\n             let mut i = 2;\n             while i < s.len() {\n                 if is_sep(s[i]) {\n-                    let pre = s.slice(2, i);\n-                    let mut rest = s.slice(i, s.len());\n+                    let pre = s.slice_DBG_BRWD(2, i).to_owned();\n+                    let mut rest = s.slice_DBG_BRWD(i, s.len()).to_owned();\n                     return Some((pre, rest));\n                 }\n                 i += 1;\n@@ -860,9 +860,9 @@ pub mod windows {\n                 let rest = if s.len() == 2 {\n                     ~\"\"\n                 } else {\n-                    s.slice(2, s.len())\n+                    s.slice_DBG_BRWD(2, s.len()).to_owned()\n                 };\n-                return Some((s.slice(0,1), rest));\n+                return Some((s.slice_DBG_BRWD(0,1).to_owned(), rest));\n             }\n             None\n         }"}, {"sha": "33ced3beebf4be8e504f11787050cb49550c4a3f", "filename": "src/libcore/rt/uv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -878,7 +878,7 @@ fn listen() {\n                 if status.is_none() {\n                     rtdebug!(\"got %d bytes\", nread);\n                     let buf = buf.unwrap();\n-                    for buf.view(0, nread as uint).each |byte| {\n+                    for buf.slice_V_DBG_BRWD(0, nread as uint).each |byte| {\n                         fail_unless!(*byte == count as u8);\n                         rtdebug!(\"%u\", *byte as uint);\n                         count += 1;"}, {"sha": "4ef0bd6a17f72beee8c8dc53ae6da4d4230238ea", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -303,7 +303,7 @@ fn read_all(rd: io::Reader) -> ~str {\n         let mut bytes = [0, ..4096];\n         while !rd.eof() {\n             let nread = rd.read(bytes, bytes.len());\n-            wr.write(bytes.view(0, nread));\n+            wr.write(bytes.slice_V_DBG_BRWD(0, nread));\n         }\n     });\n     str::from_bytes(buf)\n@@ -404,7 +404,7 @@ pub fn readclose(fd: c_int) -> ~str {\n             let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n-                writer.write(bytes.view(0, nread));\n+                writer.write(bytes.slice_V_DBG_BRWD(0, nread));\n             }\n         });\n         os::fclose(file);"}, {"sha": "3ed80caa8a17d3846005f545fb7275ada5b74d37", "filename": "src/libcore/str.rs", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -50,7 +50,7 @@ pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n \n /// Copy a slice into a new unique str\n pub pure fn from_slice(s: &str) -> ~str {\n-    unsafe { raw::slice_bytes(s, 0, len(s)) }\n+    unsafe { raw::slice_DBG_UNIQ_bytes(s, 0, len(s)) }\n }\n \n /**\n@@ -265,7 +265,7 @@ pub fn pop_char(s: &mut ~str) -> char {\n  */\n pub fn shift_char(s: &mut ~str) -> char {\n     let CharRange {ch, next} = char_range_at(*s, 0u);\n-    *s = unsafe { raw::slice_bytes(*s, next, len(*s)) };\n+    *s = unsafe { raw::slice_DBG_UNIQ_bytes(*s, next, len(*s)) };\n     return ch;\n }\n \n@@ -279,9 +279,9 @@ pub fn shift_char(s: &mut ~str) -> char {\n  * If the string does not contain any characters\n  */\n #[inline]\n-pub fn view_shift_char(s: &'a str) -> (char, &'a str) {\n+pub fn slice_shift_char(s: &'a str) -> (char, &'a str) {\n     let CharRange {ch, next} = char_range_at(s, 0u);\n-    let next_s = unsafe { raw::view_bytes(s, next, len(s)) };\n+    let next_s = unsafe { raw::slice_DBG_BRWD_bytes(s, next, len(s)) };\n     return (ch, next_s);\n }\n \n@@ -304,7 +304,7 @@ pub pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n \n     match find(s, |c| !chars_to_trim.contains(&c)) {\n       None => ~\"\",\n-      Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n+      Some(first) => unsafe { raw::slice_DBG_UNIQ_bytes(s, first, s.len()) }\n     }\n }\n \n@@ -324,7 +324,7 @@ pub pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n       None => ~\"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_bytes(s, 0u, next) }\n+        unsafe { raw::slice_DBG_UNIQ_bytes(s, 0u, next) }\n       }\n     }\n }\n@@ -346,7 +346,7 @@ pub pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n pub pure fn trim_left(s: &str) -> ~str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n-      Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n+      Some(first) => unsafe { raw::slice_DBG_UNIQ_bytes(s, first, len(s)) }\n     }\n }\n \n@@ -356,7 +356,7 @@ pub pure fn trim_right(s: &str) -> ~str {\n       None => ~\"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_bytes(s, 0u, next) }\n+        unsafe { raw::slice_DBG_UNIQ_bytes(s, 0u, next) }\n       }\n     }\n }\n@@ -408,7 +408,7 @@ pub pure fn chars(s: &str) -> ~[char] {\n  * `begin`.\n  */\n pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n-    slice(s, begin, begin + count_bytes(s, begin, n))\n+    slice_DBG_UNIQ(s, begin, begin + count_bytes(s, begin, n))\n }\n \n /**\n@@ -417,22 +417,22 @@ pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n  * Fails when `begin` and `end` do not point to valid characters or\n  * beyond the last character of the string\n  */\n-pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n+pub pure fn slice_DBG_UNIQ(s: &str, begin: uint, end: uint) -> ~str {\n     fail_unless!(is_char_boundary(s, begin));\n     fail_unless!(is_char_boundary(s, end));\n-    unsafe { raw::slice_bytes(s, begin, end) }\n+    unsafe { raw::slice_DBG_UNIQ_bytes(s, begin, end) }\n }\n \n /**\n- * Returns a view of the given string from the byte range [`begin`..`end`)\n+ * Returns a slice of the given string from the byte range [`begin`..`end`)\n  *\n  * Fails when `begin` and `end` do not point to valid characters or beyond\n  * the last character of the string\n  */\n-pub pure fn view(s: &'a str, begin: uint, end: uint) -> &'a str {\n+pub pure fn slice_DBG_BRWD(s: &'a str, begin: uint, end: uint) -> &'a str {\n     fail_unless!(is_char_boundary(s, begin));\n     fail_unless!(is_char_boundary(s, end));\n-    unsafe { raw::view_bytes(s, begin, end) }\n+    unsafe { raw::slice_DBG_BRWD_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n@@ -465,7 +465,7 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             if s[i] == b {\n                 if allow_empty || start < i {\n                     unsafe {\n-                        result.push(raw::slice_bytes(s, start, i));\n+                        result.push(raw::slice_DBG_UNIQ_bytes(s, start, i));\n                     }\n                 }\n                 start = i + 1u;\n@@ -474,7 +474,7 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            unsafe { result.push(raw::slice_bytes(s, start, l) ) };\n+            unsafe { result.push(raw::slice_DBG_UNIQ_bytes(s, start, l) ) };\n         }\n         result\n     } else {\n@@ -513,7 +513,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n         if sepfn(ch) {\n             if allow_empty || start < i {\n                 unsafe {\n-                    result.push(raw::slice_bytes(s, start, i));\n+                    result.push(raw::slice_DBG_UNIQ_bytes(s, start, i));\n                 }\n             }\n             start = next;\n@@ -523,7 +523,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n     }\n     if allow_empty || start < l {\n         unsafe {\n-            result.push(raw::slice_bytes(s, start, l));\n+            result.push(raw::slice_DBG_UNIQ_bytes(s, start, l));\n         }\n     }\n     result\n@@ -578,7 +578,7 @@ pure fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n pub pure fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n-        unsafe { result.push(raw::slice_bytes(s, from, to)); }\n+        unsafe { result.push(raw::slice_DBG_UNIQ_bytes(s, from, to)); }\n     }\n     result\n }\n@@ -587,7 +587,7 @@ pub pure fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n-            unsafe { result.push(raw::slice_bytes(s, from, to)); }\n+            unsafe { result.push(raw::slice_DBG_UNIQ_bytes(s, from, to)); }\n         }\n     }\n     result\n@@ -721,7 +721,7 @@ pub pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n         } else {\n             unsafe { push_str(&mut result, to); }\n         }\n-        unsafe { push_str(&mut result, raw::slice_bytes(s, start, end)); }\n+        unsafe { push_str(&mut result, raw::slice_DBG_UNIQ_bytes(s, start, end)); }\n     }\n     result\n }\n@@ -2135,7 +2135,7 @@ pub mod raw {\n      * If begin is greater than end.\n      * If end is greater than the length of the string.\n      */\n-    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n+    pub unsafe fn slice_DBG_UNIQ_bytes(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n             fail_unless!((begin <= end));\n             fail_unless!((end <= n));\n@@ -2155,7 +2155,7 @@ pub mod raw {\n     }\n \n     /**\n-     * Takes a bytewise (not UTF-8) view from a string.\n+     * Takes a bytewise (not UTF-8) slice from a string.\n      *\n      * Returns the substring from [`begin`..`end`).\n      *\n@@ -2165,7 +2165,7 @@ pub mod raw {\n      * If end is greater than the length of the string.\n      */\n     #[inline]\n-    pub unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n+    pub unsafe fn slice_DBG_BRWD_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do as_buf(s) |sbuf, n| {\n              fail_unless!((begin <= end));\n              fail_unless!((end <= n));\n@@ -2207,7 +2207,7 @@ pub mod raw {\n         let len = len(*s);\n         fail_unless!((len > 0u));\n         let b = s[0];\n-        *s = unsafe { raw::slice_bytes(*s, 1u, len) };\n+        *s = unsafe { raw::slice_DBG_UNIQ_bytes(*s, 1u, len) };\n         return b;\n     }\n \n@@ -2287,7 +2287,8 @@ pub trait StrSlice {\n     pure fn is_alphanumeric(&self) -> bool;\n     pure fn len(&self) -> uint;\n     pure fn char_len(&self) -> uint;\n-    pure fn slice(&self, begin: uint, end: uint) -> ~str;\n+    pure fn slice_DBG_UNIQ(&self, begin: uint, end: uint) -> ~str;\n+    pure fn slice_DBG_BRWD(&self, begin: uint, end: uint) -> &'self str;\n     pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n     pure fn split_char(&self, sep: char) -> ~[~str];\n     pure fn split_str(&self, sep: &'a str) -> ~[~str];\n@@ -2402,8 +2403,19 @@ impl StrSlice for &'self str {\n      * beyond the last character of the string\n      */\n     #[inline]\n-    pure fn slice(&self, begin: uint, end: uint) -> ~str {\n-        slice(*self, begin, end)\n+    pure fn slice_DBG_UNIQ(&self, begin: uint, end: uint) -> ~str {\n+        slice_DBG_UNIQ(*self, begin, end)\n+    }\n+    /**\n+     * Returns a slice of the given string from the byte range\n+     * [`begin`..`end`)\n+     *\n+     * Fails when `begin` and `end` do not point to valid characters or\n+     * beyond the last character of the string\n+     */\n+    #[inline]\n+    pure fn slice_DBG_BRWD(&self, begin: uint, end: uint) -> &'self str {\n+        slice_DBG_BRWD(*self, begin, end)\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n@@ -2460,7 +2472,7 @@ impl StrSlice for &'self str {\n     pure fn trim_right(&self) -> ~str { trim_right(*self) }\n \n     #[inline]\n-    pure fn to_owned(&self) -> ~str { self.slice(0, self.len()) }\n+    pure fn to_owned(&self) -> ~str { self.slice_DBG_UNIQ(0, self.len()) }\n \n     #[inline]\n     pure fn to_managed(&self) -> @str {\n@@ -2523,8 +2535,8 @@ mod tests {\n \n     #[test]\n     fn test_eq_slice() {\n-        fail_unless!((eq_slice(view(\"foobar\", 0, 3), \"foo\")));\n-        fail_unless!((eq_slice(view(\"barfoo\", 3, 6), \"foo\")));\n+        fail_unless!((eq_slice(slice_DBG_BRWD(\"foobar\", 0, 3), \"foo\")));\n+        fail_unless!((eq_slice(slice_DBG_BRWD(\"barfoo\", 3, 6), \"foo\")));\n         fail_unless!((!eq_slice(\"foo1\", \"foo2\")));\n     }\n \n@@ -2892,9 +2904,9 @@ mod tests {\n     #[test]\n     fn test_unsafe_slice() {\n         unsafe {\n-            fail_unless!(~\"ab\" == raw::slice_bytes(~\"abc\", 0, 2));\n-            fail_unless!(~\"bc\" == raw::slice_bytes(~\"abc\", 1, 3));\n-            fail_unless!(~\"\" == raw::slice_bytes(~\"abc\", 1, 1));\n+            fail_unless!(~\"ab\" == raw::slice_DBG_UNIQ_bytes(~\"abc\", 0, 2));\n+            fail_unless!(~\"bc\" == raw::slice_DBG_UNIQ_bytes(~\"abc\", 1, 3));\n+            fail_unless!(~\"\" == raw::slice_DBG_UNIQ_bytes(~\"abc\", 1, 1));\n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n@@ -2908,7 +2920,7 @@ mod tests {\n                 rs\n             }\n             fail_unless!(half_a_million_letter_a() ==\n-                raw::slice_bytes(a_million_letter_a(), 0u, 500000));\n+                raw::slice_DBG_UNIQ_bytes(a_million_letter_a(), 0u, 500000));\n         }\n     }\n \n@@ -2989,16 +3001,16 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        fail_unless!(~\"ab\" == slice(~\"abc\", 0, 2));\n-        fail_unless!(~\"bc\" == slice(~\"abc\", 1, 3));\n-        fail_unless!(~\"\" == slice(~\"abc\", 1, 1));\n-        fail_unless!(~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0, 3));\n+        fail_unless!(~\"ab\" == slice_DBG_UNIQ(~\"abc\", 0, 2));\n+        fail_unless!(~\"bc\" == slice_DBG_UNIQ(~\"abc\", 1, 3));\n+        fail_unless!(~\"\" == slice_DBG_UNIQ(~\"abc\", 1, 1));\n+        fail_unless!(~\"\\u65e5\" == slice_DBG_UNIQ(~\"\\u65e5\\u672c\", 0, 3));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        fail_unless!(~\"\u0e1b\" == slice(data, 0, 3));\n-        fail_unless!(~\"\u0e23\" == slice(data, 3, 6));\n-        fail_unless!(~\"\" == slice(data, 3, 3));\n-        fail_unless!(~\"\u534e\" == slice(data, 30, 33));\n+        fail_unless!(~\"\u0e1b\" == slice_DBG_UNIQ(data, 0, 3));\n+        fail_unless!(~\"\u0e23\" == slice_DBG_UNIQ(data, 3, 6));\n+        fail_unless!(~\"\" == slice_DBG_UNIQ(data, 3, 3));\n+        fail_unless!(~\"\u534e\" == slice_DBG_UNIQ(data, 30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -3016,23 +3028,23 @@ mod tests {\n             rs\n         }\n         fail_unless!(half_a_million_letter_X() ==\n-            slice(a_million_letter_X(), 0u, 3u * 500000u));\n+            slice_DBG_UNIQ(a_million_letter_X(), 0u, 3u * 500000u));\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let ss = ~\"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        fail_unless!(~\"\u534e\" == slice(ss, 3u, 6u));\n-        fail_unless!(~\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n+        fail_unless!(~\"\u534e\" == slice_DBG_UNIQ(ss, 3u, 6u));\n+        fail_unless!(~\"Vi\u1ec7t Nam\" == slice_DBG_UNIQ(ss, 6u, 16u));\n \n-        fail_unless!(~\"ab\" == slice(~\"abc\", 0u, 2u));\n-        fail_unless!(~\"bc\" == slice(~\"abc\", 1u, 3u));\n-        fail_unless!(~\"\" == slice(~\"abc\", 1u, 1u));\n+        fail_unless!(~\"ab\" == slice_DBG_UNIQ(~\"abc\", 0u, 2u));\n+        fail_unless!(~\"bc\" == slice_DBG_UNIQ(~\"abc\", 1u, 3u));\n+        fail_unless!(~\"\" == slice_DBG_UNIQ(~\"abc\", 1u, 1u));\n \n-        fail_unless!(~\"\u4e2d\" == slice(ss, 0u, 3u));\n-        fail_unless!(~\"\u534eV\" == slice(ss, 3u, 7u));\n-        fail_unless!(~\"\" == slice(ss, 3u, 3u));\n+        fail_unless!(~\"\u4e2d\" == slice_DBG_UNIQ(ss, 0u, 3u));\n+        fail_unless!(~\"\u534eV\" == slice_DBG_UNIQ(ss, 3u, 7u));\n+        fail_unless!(~\"\" == slice_DBG_UNIQ(ss, 3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -3049,7 +3061,7 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_slice_fail() {\n-        slice(~\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n+        slice_DBG_UNIQ(~\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n     }\n \n     #[test]\n@@ -3645,7 +3657,7 @@ mod tests {\n     #[test]\n     fn test_to_managed() {\n         fail_unless!((~\"abc\").to_managed() == @\"abc\");\n-        fail_unless!(view(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n+        fail_unless!(slice_DBG_BRWD(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n     }\n \n     #[test]"}, {"sha": "140d2d56e2461c8a483b6739d97a7c14645a9869", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -164,7 +164,7 @@ pub mod ct {\n     pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n         fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n             if to > from {\n-                ps.push(PieceString(s.slice(from, to)));\n+                ps.push(PieceString(s.slice_DBG_BRWD(from, to).to_owned()));\n             }\n         }\n "}, {"sha": "cff851b5e3eee23fab579183e8b41647bff971e9", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -1707,27 +1707,29 @@ impl<T> Container for &'self [const T] {\n }\n \n pub trait CopyableVector<T> {\n-    pure fn slice(&self, start: uint, end: uint) -> ~[T];\n+    pure fn to_owned(&self) -> ~[T];\n }\n \n /// Extension methods for vectors\n impl<T: Copy> CopyableVector<T> for &'self [const T] {\n-    /// Returns a copy of the elements from [`start`..`end`) from `v`.\n+    /// Returns a copy of `v`.\n     #[inline]\n-    pure fn slice(&self, start: uint, end: uint) -> ~[T] {\n-        // XXX: Purity workaround for stage0.\n+    pure fn to_owned(&self) -> ~[T] {\n+        let mut result = ~[];\n+        // FIXME: #4568\n         unsafe {\n-            let mut result = ~[];\n-            for uint::range(start, end) |i| {\n-                result.push(copy self[i]);\n+            reserve(&mut result, self.len());\n+            for self.each |e| {\n+                result.push(copy *e);\n             }\n-            result\n         }\n+        result\n+\n     }\n }\n \n pub trait ImmutableVector<T> {\n-    pure fn view(&self, start: uint, end: uint) -> &'self [T];\n+    pure fn slice_V_DBG_BRWD(&self, start: uint, end: uint) -> &'self [T];\n     pure fn head(&self) -> &'self T;\n     pure fn head_opt(&self) -> Option<&'self T>;\n     pure fn tail(&self) -> &'self [T];\n@@ -1751,7 +1753,7 @@ pub trait ImmutableVector<T> {\n impl<T> ImmutableVector<T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n-    pure fn view(&self, start: uint, end: uint) -> &'self [T] {\n+    pure fn slice_V_DBG_BRWD(&self, start: uint, end: uint) -> &'self [T] {\n         slice(*self, start, end)\n     }\n \n@@ -3613,9 +3615,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_view() {\n+    fn test_slice_V_DBG_BRWD() {\n         let v = ~[1, 2, 3, 4, 5];\n-        let v = v.view(1u, 3u);\n+        let v = v.slice_V_DBG_BRWD(1u, 3u);\n         fail_unless!(v.len() == 2u);\n         fail_unless!(v[0] == 2);\n         fail_unless!(v[1] == 3);"}, {"sha": "10bf727602e34d613bce4de8cd974a7ccc22d223", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -336,7 +336,7 @@ pub fn check_variants_T<T: Copy>(\n \n pub fn last_part(filename: ~str) -> ~str {\n   let ix = option::get(str::rfind_char(filename, '/'));\n-  str::slice(filename, ix + 1u, str::len(filename) - 3u)\n+  str::slice_DBG_BRWD(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n }\n \n pub enum happiness {"}, {"sha": "bfa045c72de9ff9d2f7a92a078e404af1654a608", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -771,7 +771,7 @@ pub fn link_binary(sess: Session,\n     fn unlib(config: @session::config, +stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n             config.os != session::os_win32 {\n-            stem.slice(3, stem.len())\n+            stem.slice_DBG_BRWD(3, stem.len()).to_owned()\n         } else {\n             stem\n         }"}, {"sha": "be31a67f9cc6237c7f3bfce7c52aaa694495f216", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -1239,7 +1239,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n         }\n \n         // mut -> immutable hack for vec::map\n-        deps.slice(0, deps.len())\n+        deps.slice_V_DBG_BRWD(0, deps.len()).to_owned()\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with"}, {"sha": "a56e6c338175519f46ed0cfcbbb2d3d419bfe9af", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -888,14 +888,14 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n \n     fn ident_without_trailing_underscores(ident: &'r str) -> &'r str {\n         match str::rfind(ident, |c| c != '_') {\n-            Some(idx) => str::view(ident, 0, idx + 1),\n+            Some(idx) => str::slice_DBG_BRWD(ident, 0, idx + 1),\n             None => ident, // all underscores\n         }\n     }\n \n     fn ident_without_leading_underscores(ident: &'r str) -> &'r str {\n         match str::find(ident, |c| c != '_') {\n-            Some(idx) => str::view(ident, idx, ident.len()),\n+            Some(idx) => str::slice_DBG_BRWD(ident, idx, ident.len()),\n             None => ident // all underscores\n         }\n     }"}, {"sha": "96f96a3939250258a66fa7342af4ec8d958e442d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -1430,7 +1430,7 @@ pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n \n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n-    let first_n_bounds = ps.bounds.view(0, n_param);\n+    let first_n_bounds = ps.bounds.slice_V_DBG_BRWD(0, n_param);\n     let vtables_to_skip =\n         ty::count_traits_and_supertraits(tcx, first_n_bounds);\n     let vtable_off = vtables_to_skip + n_bound;"}, {"sha": "1a72f612aeafb9df8e26bf92f6bf3b7dca90cd44", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -250,11 +250,11 @@ fn get_cache(cx: @CrateContext) -> metadata_cache {\n \n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     (if str::starts_with(full_path, work_dir) {\n-        str::slice(full_path, str::len(work_dir) + 1u,\n-                   str::len(full_path))\n+        str::slice_DBG_BRWD(full_path, str::len(work_dir) + 1u,\n+                   str::len(full_path)).to_owned()\n     } else {\n-        str::from_slice(full_path)\n-    }, str::from_slice(work_dir))\n+        full_path.to_owned()\n+    }, work_dir.to_owned())\n }\n \n fn create_file(cx: @CrateContext, +full_path: ~str)"}, {"sha": "06ae329ee5dcf6c68013df16ca0b1d11d890a090", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -488,7 +488,7 @@ pub fn parameterized(cx: ctxt,\n \n pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n     let mut s = encoder::encoded_ty(cx, typ);\n-    if str::len(s) >= 32u { s = str::slice(s, 0u, 32u); }\n+    if str::len(s) >= 32u { s = str::slice_DBG_BRWD(s, 0u, 32u).to_owned(); }\n     return s;\n }\n "}, {"sha": "2e947034d1648e55b92513ca54cf98ead32a74b9", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -171,7 +171,7 @@ fn first_sentence_(s: &str) -> ~str {\n     };\n     match idx {\n         Some(idx) if idx > 2u => {\n-            str::from_slice(str::view(s, 0, idx - 1))\n+            str::from_slice(str::slice_DBG_BRWD(s, 0, idx - 1))\n         }\n         _ => {\n             if str::ends_with(s, ~\".\") {"}, {"sha": "a15c2e7f2304da1e2b3fb7b3d97a5156fd6e2d3b", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -157,7 +157,7 @@ fn readclose(fd: libc::c_int) -> ~str {\n             let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n-                writer.write(bytes.view(0, nread));\n+                writer.write(bytes.slice_V_DBG_BRWD(0, nread).to_owned());\n             }\n         });\n         os::fclose(file);"}, {"sha": "5c1d65beb72b9445f784e007fbda9aada0071a43", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -154,7 +154,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n \n fn parse_header(line: ~str) -> Option<~str> {\n     if str::starts_with(line, ~\"# \") {\n-        Some(str::slice(line, 2u, str::len(line)))\n+        Some(str::slice_DBG_BRWD(line, 2u, str::len(line)).to_owned())\n     } else {\n         None\n     }"}, {"sha": "07f67cbe2107f51784e9ebcc5d7f534edeb7f57c", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -84,7 +84,7 @@ fn unindent(s: &str) -> ~str {\n                 copy *line\n             } else {\n                 fail_unless!(str::len(*line) >= min_indent);\n-                str::slice(*line, min_indent, str::len(*line))\n+                str::slice_DBG_BRWD(*line, min_indent, str::len(*line)).to_owned()\n             }\n         };\n         str::connect(unindented, ~\"\\n\")"}, {"sha": "cbf605e7258c9a2766addf1797a0adb83ae48433", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -831,7 +831,7 @@ priv impl BitvSet {\n                         f: &fn(uint, uint, uint) -> bool) {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        for self.bitv.storage.view(0, min).eachi |i, &w| {\n+        for self.bitv.storage.slice_V_DBG_BRWD(0, min).eachi |i, &w| {\n             if !f(i * uint::bits, w, other.bitv.storage[i]) {\n                 return;\n             }\n@@ -852,12 +852,12 @@ priv impl BitvSet {\n         let min = uint::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n-        for self.bitv.storage.view(min, len1).eachi |i, &w| {\n+        for self.bitv.storage.slice_V_DBG_BRWD(min, len1).eachi |i, &w| {\n             if !f(true, (i + min) * uint::bits, w) {\n                 return;\n             }\n         }\n-        for other.bitv.storage.view(min, len2).eachi |i, &w| {\n+        for other.bitv.storage.slice_V_DBG_BRWD(min, len2).eachi |i, &w| {\n             if !f(false, (i + min) * uint::bits, w) {\n                 return;\n             }"}, {"sha": "176d3c73b62f4e2b4387fbd2b2b9653220af9466", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -571,7 +571,7 @@ pub mod bytepipes {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n             if vec::uniq_len(&const self.buf) >= count {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n-                self.buf = bytes.slice(count, bytes.len());\n+                self.buf = bytes.slice_V_DBG_BRWD(count, bytes.len()).to_owned();\n                 bytes.truncate(count);\n                 return Some(bytes);\n             } else if vec::uniq_len(&const self.buf) > 0 {"}, {"sha": "f19def7ad867b4055dd70d99fde009ee18848f80", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -243,7 +243,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 let mut names;\n                 let mut i_arg = None;\n                 if cur[1] == '-' as u8 {\n-                    let tail = str::slice(cur, 2, curlen);\n+                    let tail = str::slice_DBG_BRWD(cur, 2, curlen).to_owned();\n                     let tail_eq = str::splitn_char(tail, '=', 1);\n                     if tail_eq.len() <= 1 {\n                         names = ~[Long(tail)];\n@@ -279,7 +279,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                                   No => false\n                                 };\n                             if arg_follows && j < curlen {\n-                                i_arg = Some(cur.slice(j, curlen));\n+                                i_arg = Some(cur.slice_DBG_BRWD(j, curlen).to_owned());\n                                 break;\n                             } else {\n                                 last_valid_opt_id = None;"}, {"sha": "c5d0446f1565bf2f0acb49c2987a2c9602b0679c", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -317,10 +317,10 @@ pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (str::slice(s, 0, index), ~\"\");\n+        return (str::slice_DBG_BRWD(s, 0, index).to_owned(), ~\"\");\n     } else {\n-        return (str::slice(s, 0, index),\n-             str::slice(s, index + mat, str::len(s)));\n+        return (str::slice_DBG_BRWD(s, 0, index).to_owned(),\n+             str::slice_DBG_BRWD(s, index + mat, str::len(s)).to_owned());\n     }\n }\n \n@@ -386,8 +386,8 @@ pub pure fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n             if i == 0 {\n                 return Err(~\"url: Scheme cannot be empty.\");\n             } else {\n-                return Ok((rawurl.slice(0,i),\n-                                rawurl.slice(i+1,str::len(rawurl))));\n+                return Ok((rawurl.slice_DBG_BRWD(0,i).to_owned(),\n+                                rawurl.slice_DBG_BRWD(i+1,str::len(rawurl)).to_owned()));\n             }\n           }\n           _ => {\n@@ -489,7 +489,7 @@ pure fn get_authority(rawurl: &str) ->\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = str::slice(rawurl, begin, i);\n+                    host = str::slice_DBG_BRWD(rawurl, begin, i).to_owned();\n                     pos = i;\n                     st = InPort;\n                 }\n@@ -506,13 +506,13 @@ pure fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = str::slice(rawurl, begin, i);\n+                let user = str::slice_DBG_BRWD(rawurl, begin, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = str::slice(rawurl, begin, pos);\n-                let pass = str::slice(rawurl, pos+1, i);\n+                let user = str::slice_DBG_BRWD(rawurl, begin, pos).to_owned();\n+                let pass = str::slice_DBG_BRWD(rawurl, pos+1, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n@@ -543,31 +543,31 @@ pure fn get_authority(rawurl: &str) ->\n     match st {\n       Start => {\n         if host_is_end_plus_one() {\n-            host = str::slice(rawurl, begin, end+1);\n+            host = str::slice_DBG_BRWD(rawurl, begin, end+1).to_owned();\n         } else {\n-            host = str::slice(rawurl, begin, end);\n+            host = str::slice_DBG_BRWD(rawurl, begin, end).to_owned();\n         }\n       }\n       PassHostPort | Ip6Port => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        host = str::slice(rawurl, begin, pos);\n-        port = Some(str::slice(rawurl, pos+1, end));\n+        host = str::slice_DBG_BRWD(rawurl, begin, pos).to_owned();\n+        port = Some(str::slice_DBG_BRWD(rawurl, pos+1, end).to_owned());\n       }\n       Ip6Host | InHost => {\n-        host = str::slice(rawurl, begin, end);\n+        host = str::slice_DBG_BRWD(rawurl, begin, end).to_owned();\n       }\n       InPort => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        port = Some(str::slice(rawurl, pos+1, end));\n+        port = Some(str::slice_DBG_BRWD(rawurl, pos+1, end).to_owned());\n       }\n     }\n \n     let rest = if host_is_end_plus_one() { ~\"\" }\n-    else { str::slice(rawurl, end, len) };\n+    else { str::slice_DBG_BRWD(rawurl, end, len).to_owned() };\n     return Ok((userinfo, host, port, rest));\n }\n \n@@ -599,25 +599,25 @@ pure fn get_path(rawurl: &str, authority: bool) ->\n         }\n     }\n \n-    return Ok((decode_component(str::slice(rawurl, 0, end)),\n-                    str::slice(rawurl, end, len)));\n+    return Ok((decode_component(str::slice_DBG_BRWD(rawurl, 0, end).to_owned()),\n+                    str::slice_DBG_BRWD(rawurl, end, len).to_owned()));\n }\n \n // returns the parsed query and the fragment, if present\n pure fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n-            let f = decode_component(str::slice(rawurl,\n+            let f = decode_component(str::slice_DBG_BRWD(rawurl,\n                                                 1,\n-                                                str::len(rawurl)));\n+                                                str::len(rawurl)).to_owned());\n             return Ok((~[], Some(f)));\n         } else {\n             return Ok((~[], None));\n         }\n     }\n-    let (q, r) = split_char_first(str::slice(rawurl, 1,\n-                                             str::len(rawurl)), '#');\n+    let (q, r) = split_char_first(str::slice_DBG_BRWD(rawurl, 1,\n+                                             str::len(rawurl)).to_owned(), '#');\n     let f = if str::len(r) != 0 {\n         Some(decode_component(r)) } else { None };\n     return Ok((query_from_str(q), f));"}, {"sha": "f796a7fa98e535720fd92f3c0414cda8389e1b07", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -1293,9 +1293,9 @@ mod tests {\n                 unsafe {\n                     match (*node) {\n                       node::Leaf(x) => {\n-                        *str += str::slice(\n+                        *str += str::slice_DBG_BRWD(\n                             *x.content, x.byte_offset,\n-                            x.byte_offset + x.byte_len);\n+                            x.byte_offset + x.byte_len).to_owned();\n                       }\n                       node::Concat(ref x) => {\n                         aux(str, x.left);"}, {"sha": "e4723ff0a2b24e31ce39ecb6d8ab227fcb0324f6", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -398,8 +398,8 @@ mod tests {\n                 let mut left = len;\n                 while left > 0u {\n                     let take = (left + 1u) / 2u;\n-                    sh.input_str(str::slice(t.input, len - left,\n-                                 take + len - left));\n+                    sh.input_str(str::slice_DBG_BRWD(t.input, len - left,\n+                                 take + len - left).to_owned());\n                     left = left - take;\n                 }\n                 let out = sh.result();"}, {"sha": "99bb6998c86e8d0261454d8152886c714f7f7481", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -266,7 +266,7 @@ pub impl FileMap {\n                 Some(e) => e,\n                 None => str::len(*self.src)\n             };\n-            str::slice(*self.src, begin, end)\n+            str::slice_DBG_BRWD(*self.src, begin, end).to_owned()\n         }\n     }\n \n@@ -395,8 +395,8 @@ pub impl CodeMap {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n         fail_unless!(begin.fm.start_pos == end.fm.start_pos);\n-        return str::slice(*begin.fm.src,\n-                          begin.pos.to_uint(), end.pos.to_uint());\n+        return str::slice_DBG_BRWD(*begin.fm.src,\n+                          begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n     }\n \n     pub fn get_filemap(&self, filename: ~str) -> @FileMap {"}, {"sha": "eb39625b1d0d6fd3cd670e54f5832196f5328b41", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -112,7 +112,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n                             match (*tt) {\n                                 // cut off delimiters; don't parse 'em\n                                 tt_delim(ref tts) => {\n-                                    (*tts).slice(1u,(*tts).len()-1u)\n+                                    (*tts).slice_V_DBG_BRWD(1u,(*tts).len()-1u).to_owned()\n                                 }\n                                 _ => cx.span_fatal(\n                                     sp, ~\"macro rhs must be delimited\")"}, {"sha": "08473b0e7fba1118d8916041532b27acae3272a9", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -76,7 +76,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         while j > i && lines[j - 1u].trim().is_empty() {\n             j -= 1u;\n         }\n-        return lines.slice(i, j);\n+        return lines.slice_V_DBG_BRWD(i, j).to_owned();\n     }\n \n     // drop leftmost columns that contain only values in chars\n@@ -103,17 +103,17 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n             if i > chars.len() {\n                 ~\"\"\n             } else {\n-                str::from_chars(chars.slice(i, chars.len()))\n+                str::from_chars(chars.slice_V_DBG_BRWD(i, chars.len()).to_owned())\n             }\n         };\n     }\n \n     if comment.starts_with(~\"//\") {\n-        return comment.slice(3u, comment.len()).trim();\n+        return comment.slice_DBG_BRWD(3u, comment.len()).trim();\n     }\n \n     if comment.starts_with(~\"/*\") {\n-        let lines = str::lines_any(comment.slice(3u, comment.len() - 2u));\n+        let lines = str::lines_any(comment.slice_DBG_BRWD(3u, comment.len() - 2u).to_owned());\n         let lines = vertical_trim(lines);\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));\n@@ -218,7 +218,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n     let col = col.to_uint();\n     if all_whitespace(s, 0u, uint::min(len, col)) {\n         if col < len {\n-            s1 = str::slice(s, col, len);\n+            s1 = str::slice_DBG_BRWD(s, col, len).to_owned();\n         } else { s1 = ~\"\"; }\n     } else { s1 = s; }\n     debug!(\"pushing line: %s\", s1);"}, {"sha": "49f1d041b02e026a9b7e057de6d9273557e4d289", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -176,8 +176,8 @@ pub fn get_str_from(rdr: @mut StringReader, start: BytePos) -> ~str {\n     unsafe {\n         // I'm pretty skeptical about this subtraction. What if there's a\n         // multi-byte character before the mark?\n-        return str::slice(*rdr.src, start.to_uint() - 1u,\n-                          byte_offset(rdr).to_uint() - 1u);\n+        return str::slice_DBG_BRWD(*rdr.src, start.to_uint() - 1u,\n+                          byte_offset(rdr).to_uint() - 1u).to_owned();\n     }\n }\n "}, {"sha": "7302c0c9dc8f97894bd3ed203bea45c28f439f92", "filename": "src/test/compile-fail/issue-3888.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d296f24c785e359bfd6d9e491fd8854c3ad967/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs?ref=a7d296f24c785e359bfd6d9e491fd8854c3ad967", "patch": "@@ -17,7 +17,7 @@ fn vec_peek<T>(v: &'r [T]) -> Option< (&'r T, &'r [T]) > {\n         let vec_len = v.len();\n         let head = &v[0];\n         // note: this *shouldn't* be an illegal borrow! See #3888\n-        let tail = v.view(1, vec_len); //~ ERROR illegal borrow: borrowed value does not live long enough\n+        let tail = v.slice_V_DBG_BRWD(1, vec_len); //~ ERROR illegal borrow: borrowed value does not live long enough\n         Some( (head, tail) )\n     }\n }"}]}