{"sha": "897ef3a0ec001b89fffe7125c20d6a6bb12fee6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5N2VmM2EwZWMwMDFiODlmZmZlNzEyNWMyMGQ2YTZiYjEyZmVlNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-31T15:55:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-31T15:55:13Z"}, "message": "Auto merge of #75936 - sdroege:chunks-exact-construction-bounds-check, r=nagisa\n\nGet rid of bounds check in slice::chunks_exact() and related function\u2026\n\n\u2026s during construction\n\nLLVM can't figure out in\n\n    let rem = self.len() % chunk_size;\n    let len = self.len() - rem;\n    let (fst, snd) = self.split_at(len);\n\nand\n\n    let rem = self.len() % chunk_size;\n    let (fst, snd) = self.split_at(rem);\n\nthat the index passed to split_at() is smaller than the slice length and\nadds a bounds check plus panic for it.\n\nApart from removing the overhead of the bounds check this also allows\nLLVM to optimize code around the ChunksExact iterator better.", "tree": {"sha": "6c9682ceb1b40eca7b815b0d9ceef1c2e5d67b3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c9682ceb1b40eca7b815b0d9ceef1c2e5d67b3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/897ef3a0ec001b89fffe7125c20d6a6bb12fee6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/897ef3a0ec001b89fffe7125c20d6a6bb12fee6c", "html_url": "https://github.com/rust-lang/rust/commit/897ef3a0ec001b89fffe7125c20d6a6bb12fee6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/897ef3a0ec001b89fffe7125c20d6a6bb12fee6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fd8636d2428658cf46df53fb4f445558689fd1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fd8636d2428658cf46df53fb4f445558689fd1c", "html_url": "https://github.com/rust-lang/rust/commit/1fd8636d2428658cf46df53fb4f445558689fd1c"}, {"sha": "8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d", "html_url": "https://github.com/rust-lang/rust/commit/8d3cf9237dcc9d4f2a7c0bde42dc133e60f51c7d"}], "stats": {"total": 154, "additions": 127, "deletions": 27}, "files": [{"sha": "ca0c3416ef56098f587d03087a0e664837eef914", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 127, "deletions": 27, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/897ef3a0ec001b89fffe7125c20d6a6bb12fee6c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897ef3a0ec001b89fffe7125c20d6a6bb12fee6c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=897ef3a0ec001b89fffe7125c20d6a6bb12fee6c", "patch": "@@ -288,10 +288,12 @@ impl<T> [T] {\n     /// Returns a reference to an element or subslice, without doing bounds\n     /// checking.\n     ///\n-    /// This is generally not recommended, use with caution!\n+    /// For a safe alternative see [`get`].\n+    ///\n+    /// # Safety\n+    ///\n     /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n     /// even if the resulting reference is not used.\n-    /// For a safe alternative see [`get`].\n     ///\n     /// [`get`]: #method.get\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n@@ -320,10 +322,12 @@ impl<T> [T] {\n     /// Returns a mutable reference to an element or subslice, without doing\n     /// bounds checking.\n     ///\n-    /// This is generally not recommended, use with caution!\n+    /// For a safe alternative see [`get_mut`].\n+    ///\n+    /// # Safety\n+    ///\n     /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n     /// even if the resulting reference is not used.\n-    /// For a safe alternative see [`get_mut`].\n     ///\n     /// [`get_mut`]: #method.get_mut\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n@@ -865,8 +869,9 @@ impl<T> [T] {\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n         assert_ne!(chunk_size, 0);\n         let rem = self.len() % chunk_size;\n-        let len = self.len() - rem;\n-        let (fst, snd) = self.split_at(len);\n+        let fst_len = self.len() - rem;\n+        // SAFETY: 0 <= fst_len <= self.len() by construction above\n+        let (fst, snd) = unsafe { self.split_at_unchecked(fst_len) };\n         ChunksExact { v: fst, rem: snd, chunk_size }\n     }\n \n@@ -910,8 +915,9 @@ impl<T> [T] {\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n         assert_ne!(chunk_size, 0);\n         let rem = self.len() % chunk_size;\n-        let len = self.len() - rem;\n-        let (fst, snd) = self.split_at_mut(len);\n+        let fst_len = self.len() - rem;\n+        // SAFETY: 0 <= fst_len <= self.len() by construction above\n+        let (fst, snd) = unsafe { self.split_at_mut_unchecked(fst_len) };\n         ChunksExactMut { v: fst, rem: snd, chunk_size }\n     }\n \n@@ -1063,7 +1069,8 @@ impl<T> [T] {\n     pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<'_, T> {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n-        let (fst, snd) = self.split_at(rem);\n+        // SAFETY: 0 <= rem <= self.len() by construction above\n+        let (fst, snd) = unsafe { self.split_at_unchecked(rem) };\n         RChunksExact { v: snd, rem: fst, chunk_size }\n     }\n \n@@ -1108,7 +1115,8 @@ impl<T> [T] {\n     pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<'_, T> {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n-        let (fst, snd) = self.split_at_mut(rem);\n+        // SAFETY: 0 <= rem <= self.len() by construction above\n+        let (fst, snd) = unsafe { self.split_at_mut_unchecked(rem) };\n         RChunksExactMut { v: snd, rem: fst, chunk_size }\n     }\n \n@@ -1129,26 +1137,29 @@ impl<T> [T] {\n     ///\n     /// {\n     ///    let (left, right) = v.split_at(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    ///    assert_eq!(left, []);\n+    ///    assert_eq!(right, [1, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at(2);\n-    ///     assert!(left == [1, 2]);\n-    ///     assert!(right == [3, 4, 5, 6]);\n+    ///     assert_eq!(left, [1, 2]);\n+    ///     assert_eq!(right, [3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at(6);\n-    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n+    ///     assert_eq!(left, [1, 2, 3, 4, 5, 6]);\n+    ///     assert_eq!(right, []);\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n-        (&self[..mid], &self[mid..])\n+        assert!(mid <= self.len());\n+        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n+        // fulfills the requirements of `from_raw_parts_mut`.\n+        unsafe { self.split_at_unchecked(mid) }\n     }\n \n     /// Divides one mutable slice into two at an index.\n@@ -1168,26 +1179,115 @@ impl<T> [T] {\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n     ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1, 0]);\n-    ///     assert!(right == [3, 0, 5, 6]);\n+    ///     assert_eq!(left, [1, 0]);\n+    ///     assert_eq!(right, [3, 0, 5, 6]);\n     ///     left[1] = 2;\n     ///     right[1] = 4;\n     /// }\n-    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n+    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        let len = self.len();\n-        let ptr = self.as_mut_ptr();\n-\n+        assert!(mid <= self.len());\n         // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n         // fulfills the requirements of `from_raw_parts_mut`.\n-        unsafe {\n-            assert!(mid <= len);\n+        unsafe { self.split_at_mut_unchecked(mid) }\n+    }\n \n-            (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid))\n-        }\n+    /// Divides one slice into two at an index, without doing bounds checking.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// For a safe alternative see [`split_at`].\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n+    /// even if the resulting reference is not used. The caller has to ensure that\n+    /// `0 <= mid <= self.len()`.\n+    ///\n+    /// [`split_at`]: #method.split_at\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```compile_fail\n+    /// #![feature(slice_split_at_unchecked)]\n+    ///\n+    /// let v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// unsafe {\n+    ///    let (left, right) = v.split_at_unchecked(0);\n+    ///    assert_eq!(left, []);\n+    ///    assert_eq!(right, [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// unsafe {\n+    ///     let (left, right) = v.split_at_unchecked(2);\n+    ///     assert_eq!(left, [1, 2]);\n+    ///     assert_eq!(right, [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// unsafe {\n+    ///     let (left, right) = v.split_at_unchecked(6);\n+    ///     assert_eq!(left, [1, 2, 3, 4, 5, 6]);\n+    ///     assert_eq!(right, []);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n+    #[inline]\n+    unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n+        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n+        unsafe { (self.get_unchecked(..mid), self.get_unchecked(mid..)) }\n+    }\n+\n+    /// Divides one mutable slice into two at an index, without doing bounds checking.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// For a safe alternative see [`split_at_mut`].\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n+    /// even if the resulting reference is not used. The caller has to ensure that\n+    /// `0 <= mid <= self.len()`.\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```compile_fail\n+    /// #![feature(slice_split_at_unchecked)]\n+    ///\n+    /// let mut v = [1, 0, 3, 0, 5, 6];\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// unsafe {\n+    ///     let (left, right) = v.split_at_mut_unchecked(2);\n+    ///     assert_eq!(left, [1, 0]);\n+    ///     assert_eq!(right, [3, 0, 5, 6]);\n+    ///     left[1] = 2;\n+    ///     right[1] = 4;\n+    /// }\n+    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n+    #[inline]\n+    unsafe fn split_at_mut_unchecked(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        let len = self.len();\n+        let ptr = self.as_mut_ptr();\n+\n+        // SAFETY: Caller has to check that `0 <= mid <= self.len()`.\n+        //\n+        // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n+        // is fine.\n+        unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match"}]}